
h743Loader.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000494  24000004  24000004  00010004  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .ARM          00000008  24000498  24000498  00010498  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .init_array   00000004  240004a0  240004a0  000104a0  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  3 .fini_array   00000004  240004a4  240004a4  000104a4  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .data         0000007c  240004a8  240004a8  000104a8  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .bss          0000008c  24000524  24000524  00010524  2**2
                  ALLOC
  6 .text         00016738  240005b0  240005b0  000105b0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  7 .Dev_info     000000c8  24016ce8  24016ce8  00036ce8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  8 .rodata       0000001c  24016db0  24016db0  00026db0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  9 ._user_heap_stack 00000a00  24016dcc  24016dcc  00026dcc  2**0
                  ALLOC
 10 .ARM.attributes 0000002e  00000000  00000000  00036db0  2**0
                  CONTENTS, READONLY
 11 .debug_info   00023022  00000000  00000000  00036dde  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_abbrev 00004283  00000000  00000000  00059e00  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_aranges 000011b0  00000000  00000000  0005e088  2**3
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_ranges 00000fe0  00000000  00000000  0005f238  2**3
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_macro  0003799b  00000000  00000000  00060218  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_line   00013371  00000000  00000000  00097bb3  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_str    00153489  00000000  00000000  000aaf24  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .comment      0000007b  00000000  00000000  001fe3ad  2**0
                  CONTENTS, READONLY
 19 .debug_frame  00004734  00000000  00000000  001fe428  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

240005b0 <__do_global_dtors_aux>:
240005b0:	b510      	push	{r4, lr}
240005b2:	4c05      	ldr	r4, [pc, #20]	; (240005c8 <__bss_end__+0x18>)
240005b4:	7823      	ldrb	r3, [r4, #0]
240005b6:	b933      	cbnz	r3, 240005c6 <__do_global_dtors_aux+0x16>
240005b8:	4b04      	ldr	r3, [pc, #16]	; (240005cc <__bss_end__+0x1c>)
240005ba:	b113      	cbz	r3, 240005c2 <__do_global_dtors_aux+0x12>
240005bc:	4804      	ldr	r0, [pc, #16]	; (240005d0 <__bss_end__+0x20>)
240005be:	f3af 8000 	nop.w
240005c2:	2301      	movs	r3, #1
240005c4:	7023      	strb	r3, [r4, #0]
240005c6:	bd10      	pop	{r4, pc}
240005c8:	24000524 	.word	0x24000524
240005cc:	00000000 	.word	0x00000000
240005d0:	24016ccc 	.word	0x24016ccc

240005d4 <frame_dummy>:
240005d4:	b508      	push	{r3, lr}
240005d6:	4b03      	ldr	r3, [pc, #12]	; (240005e4 <frame_dummy+0x10>)
240005d8:	b11b      	cbz	r3, 240005e2 <frame_dummy+0xe>
240005da:	4903      	ldr	r1, [pc, #12]	; (240005e8 <frame_dummy+0x14>)
240005dc:	4803      	ldr	r0, [pc, #12]	; (240005ec <frame_dummy+0x18>)
240005de:	f3af 8000 	nop.w
240005e2:	bd08      	pop	{r3, pc}
240005e4:	00000000 	.word	0x00000000
240005e8:	24000528 	.word	0x24000528
240005ec:	24016ccc 	.word	0x24016ccc

240005f0 <_mainCRTStartup>:
240005f0:	4b15      	ldr	r3, [pc, #84]	; (24000648 <_mainCRTStartup+0x58>)
240005f2:	2b00      	cmp	r3, #0
240005f4:	bf08      	it	eq
240005f6:	4b13      	ldreq	r3, [pc, #76]	; (24000644 <_mainCRTStartup+0x54>)
240005f8:	469d      	mov	sp, r3
240005fa:	f5a3 3a80 	sub.w	sl, r3, #65536	; 0x10000
240005fe:	2100      	movs	r1, #0
24000600:	468b      	mov	fp, r1
24000602:	460f      	mov	r7, r1
24000604:	4813      	ldr	r0, [pc, #76]	; (24000654 <_mainCRTStartup+0x64>)
24000606:	4a14      	ldr	r2, [pc, #80]	; (24000658 <_mainCRTStartup+0x68>)
24000608:	1a12      	subs	r2, r2, r0
2400060a:	f016 fb57 	bl	24016cbc <memset>
2400060e:	4b0f      	ldr	r3, [pc, #60]	; (2400064c <_mainCRTStartup+0x5c>)
24000610:	2b00      	cmp	r3, #0
24000612:	d000      	beq.n	24000616 <_mainCRTStartup+0x26>
24000614:	4798      	blx	r3
24000616:	4b0e      	ldr	r3, [pc, #56]	; (24000650 <_mainCRTStartup+0x60>)
24000618:	2b00      	cmp	r3, #0
2400061a:	d000      	beq.n	2400061e <_mainCRTStartup+0x2e>
2400061c:	4798      	blx	r3
2400061e:	2000      	movs	r0, #0
24000620:	2100      	movs	r1, #0
24000622:	0004      	movs	r4, r0
24000624:	000d      	movs	r5, r1
24000626:	480d      	ldr	r0, [pc, #52]	; (2400065c <_mainCRTStartup+0x6c>)
24000628:	2800      	cmp	r0, #0
2400062a:	d002      	beq.n	24000632 <_mainCRTStartup+0x42>
2400062c:	480c      	ldr	r0, [pc, #48]	; (24000660 <_mainCRTStartup+0x70>)
2400062e:	f3af 8000 	nop.w
24000632:	f016 fb1f 	bl	24016c74 <__libc_init_array>
24000636:	0020      	movs	r0, r4
24000638:	0029      	movs	r1, r5
2400063a:	f015 f9ed 	bl	24015a18 <main>
2400063e:	f016 fb05 	bl	24016c4c <exit>
24000642:	bf00      	nop
24000644:	00080000 	.word	0x00080000
	...
24000654:	24000524 	.word	0x24000524
24000658:	240005b0 	.word	0x240005b0
	...
24000664:	240004a8 	.word	0x240004a8
24000668:	240004a8 	.word	0x240004a8
2400066c:	24000524 	.word	0x24000524
24000670:	24000524 	.word	0x24000524
24000674:	240005b0 	.word	0x240005b0

24000678 <HAL_Init>:
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
24000678:	b580      	push	{r7, lr}
2400067a:	b082      	sub	sp, #8
2400067c:	af00      	add	r7, sp, #0
   __HAL_ART_CONFIG_BASE_ADDRESS(0x08100000UL);  /* Configure the Cortex-M4 ART Base address to the Flash Bank 2 : */
   __HAL_ART_ENABLE();                           /* Enable the Cortex-M4 ART */
#endif /* DUAL_CORE &&  CORE_CM4 */

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
2400067e:	2003      	movs	r0, #3
24000680:	f000 ff30 	bl	240014e4 <HAL_NVIC_SetPriorityGrouping>

  /* Update the SystemCoreClock global variable */
#if defined(RCC_D1CFGR_D1CPRE)
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
24000684:	f012 f9ae 	bl	240129e4 <HAL_RCC_GetSysClockFreq>
24000688:	4601      	mov	r1, r0
2400068a:	4b15      	ldr	r3, [pc, #84]	; (240006e0 <HAL_Init+0x68>)
2400068c:	699b      	ldr	r3, [r3, #24]
2400068e:	0a1b      	lsrs	r3, r3, #8
24000690:	f003 030f 	and.w	r3, r3, #15
24000694:	4a13      	ldr	r2, [pc, #76]	; (240006e4 <HAL_Init+0x6c>)
24000696:	5cd3      	ldrb	r3, [r2, r3]
24000698:	f003 031f 	and.w	r3, r3, #31
2400069c:	fa21 f303 	lsr.w	r3, r1, r3
240006a0:	607b      	str	r3, [r7, #4]
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->CDCFGR1 & RCC_CDCFGR1_CDCPRE)>> RCC_CDCFGR1_CDCPRE_Pos]) & 0x1FU);
#endif

  /* Update the SystemD2Clock global variable */
#if defined(RCC_D1CFGR_HPRE)
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
240006a2:	4b0f      	ldr	r3, [pc, #60]	; (240006e0 <HAL_Init+0x68>)
240006a4:	699b      	ldr	r3, [r3, #24]
240006a6:	f003 030f 	and.w	r3, r3, #15
240006aa:	4a0e      	ldr	r2, [pc, #56]	; (240006e4 <HAL_Init+0x6c>)
240006ac:	5cd3      	ldrb	r3, [r2, r3]
240006ae:	f003 031f 	and.w	r3, r3, #31
240006b2:	687a      	ldr	r2, [r7, #4]
240006b4:	fa22 f303 	lsr.w	r3, r2, r3
240006b8:	4a0b      	ldr	r2, [pc, #44]	; (240006e8 <HAL_Init+0x70>)
240006ba:	6013      	str	r3, [r2, #0]
#endif

#if defined(DUAL_CORE) && defined(CORE_CM4)
  SystemCoreClock = SystemD2Clock;
#else
  SystemCoreClock = common_system_clock;
240006bc:	4a0b      	ldr	r2, [pc, #44]	; (240006ec <HAL_Init+0x74>)
240006be:	687b      	ldr	r3, [r7, #4]
240006c0:	6013      	str	r3, [r2, #0]
#endif /* DUAL_CORE && CORE_CM4 */

  /* Use systick as time base source and configure 1ms tick (default clock after Reset is HSI) */
  if(HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
240006c2:	2000      	movs	r0, #0
240006c4:	f000 f87a 	bl	240007bc <HAL_InitTick>
240006c8:	4603      	mov	r3, r0
240006ca:	2b00      	cmp	r3, #0
240006cc:	d001      	beq.n	240006d2 <HAL_Init+0x5a>
  {
    return HAL_ERROR;
240006ce:	2301      	movs	r3, #1
240006d0:	e002      	b.n	240006d8 <HAL_Init+0x60>
  }

  /* Init the low level hardware */
  HAL_MspInit();
240006d2:	f015 ff75 	bl	240165c0 <HAL_MspInit>

  /* Return function status */
  return HAL_OK;
240006d6:	2300      	movs	r3, #0
}
240006d8:	4618      	mov	r0, r3
240006da:	3708      	adds	r7, #8
240006dc:	46bd      	mov	sp, r7
240006de:	bd80      	pop	{r7, pc}
240006e0:	58024400 	.word	0x58024400
240006e4:	24016db8 	.word	0x24016db8
240006e8:	240004bc 	.word	0x240004bc
240006ec:	240004b8 	.word	0x240004b8

240006f0 <HAL_DeInit>:
  * @brief  This function de-Initializes common part of the HAL and stops the systick.
  *         This function is optional.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DeInit(void)
{
240006f0:	b580      	push	{r7, lr}
240006f2:	af00      	add	r7, sp, #0
  /* Reset of all peripherals */
  __HAL_RCC_AHB3_FORCE_RESET();
240006f4:	4b29      	ldr	r3, [pc, #164]	; (2400079c <HAL_DeInit+0xac>)
240006f6:	f06f 4200 	mvn.w	r2, #2147483648	; 0x80000000
240006fa:	67da      	str	r2, [r3, #124]	; 0x7c
  __HAL_RCC_AHB3_RELEASE_RESET();
240006fc:	4b27      	ldr	r3, [pc, #156]	; (2400079c <HAL_DeInit+0xac>)
240006fe:	2200      	movs	r2, #0
24000700:	67da      	str	r2, [r3, #124]	; 0x7c

  __HAL_RCC_AHB1_FORCE_RESET();
24000702:	4b26      	ldr	r3, [pc, #152]	; (2400079c <HAL_DeInit+0xac>)
24000704:	f04f 32ff 	mov.w	r2, #4294967295
24000708:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
  __HAL_RCC_AHB1_RELEASE_RESET();
2400070c:	4b23      	ldr	r3, [pc, #140]	; (2400079c <HAL_DeInit+0xac>)
2400070e:	2200      	movs	r2, #0
24000710:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80

  __HAL_RCC_AHB2_FORCE_RESET();
24000714:	4b21      	ldr	r3, [pc, #132]	; (2400079c <HAL_DeInit+0xac>)
24000716:	f04f 32ff 	mov.w	r2, #4294967295
2400071a:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
  __HAL_RCC_AHB2_RELEASE_RESET();
2400071e:	4b1f      	ldr	r3, [pc, #124]	; (2400079c <HAL_DeInit+0xac>)
24000720:	2200      	movs	r2, #0
24000722:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84

  __HAL_RCC_AHB4_FORCE_RESET();
24000726:	4b1d      	ldr	r3, [pc, #116]	; (2400079c <HAL_DeInit+0xac>)
24000728:	f04f 32ff 	mov.w	r2, #4294967295
2400072c:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
 __HAL_RCC_AHB4_RELEASE_RESET();
24000730:	4b1a      	ldr	r3, [pc, #104]	; (2400079c <HAL_DeInit+0xac>)
24000732:	2200      	movs	r2, #0
24000734:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88

  __HAL_RCC_APB3_FORCE_RESET();
24000738:	4b18      	ldr	r3, [pc, #96]	; (2400079c <HAL_DeInit+0xac>)
2400073a:	f04f 32ff 	mov.w	r2, #4294967295
2400073e:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
  __HAL_RCC_APB3_RELEASE_RESET();
24000742:	4b16      	ldr	r3, [pc, #88]	; (2400079c <HAL_DeInit+0xac>)
24000744:	2200      	movs	r2, #0
24000746:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c

  __HAL_RCC_APB1L_FORCE_RESET();
2400074a:	4b14      	ldr	r3, [pc, #80]	; (2400079c <HAL_DeInit+0xac>)
2400074c:	f04f 32ff 	mov.w	r2, #4294967295
24000750:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
  __HAL_RCC_APB1L_RELEASE_RESET();
24000754:	4b11      	ldr	r3, [pc, #68]	; (2400079c <HAL_DeInit+0xac>)
24000756:	2200      	movs	r2, #0
24000758:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90

  __HAL_RCC_APB1H_FORCE_RESET();
2400075c:	4b0f      	ldr	r3, [pc, #60]	; (2400079c <HAL_DeInit+0xac>)
2400075e:	f04f 32ff 	mov.w	r2, #4294967295
24000762:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
  __HAL_RCC_APB1H_RELEASE_RESET();
24000766:	4b0d      	ldr	r3, [pc, #52]	; (2400079c <HAL_DeInit+0xac>)
24000768:	2200      	movs	r2, #0
2400076a:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94

   __HAL_RCC_APB2_FORCE_RESET();
2400076e:	4b0b      	ldr	r3, [pc, #44]	; (2400079c <HAL_DeInit+0xac>)
24000770:	f04f 32ff 	mov.w	r2, #4294967295
24000774:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
   __HAL_RCC_APB2_RELEASE_RESET();
24000778:	4b08      	ldr	r3, [pc, #32]	; (2400079c <HAL_DeInit+0xac>)
2400077a:	2200      	movs	r2, #0
2400077c:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98

  __HAL_RCC_APB4_FORCE_RESET();
24000780:	4b06      	ldr	r3, [pc, #24]	; (2400079c <HAL_DeInit+0xac>)
24000782:	f04f 32ff 	mov.w	r2, #4294967295
24000786:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c
  __HAL_RCC_APB4_RELEASE_RESET();
2400078a:	4b04      	ldr	r3, [pc, #16]	; (2400079c <HAL_DeInit+0xac>)
2400078c:	2200      	movs	r2, #0
2400078e:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c

  /* De-Init the low level hardware */
  HAL_MspDeInit();
24000792:	f000 f80c 	bl	240007ae <HAL_MspDeInit>

  /* Return function status */
  return HAL_OK;
24000796:	2300      	movs	r3, #0
}
24000798:	4618      	mov	r0, r3
2400079a:	bd80      	pop	{r7, pc}
2400079c:	58024400 	.word	0x58024400
/**
  * @brief  Initializes the MSP.
  * @retval None
  */
__weak void HAL_MspInit(void)
{
240007a0:	b480      	push	{r7}
240007a2:	af00      	add	r7, sp, #0
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_MspInit could be implemented in the user file
   */
}
240007a4:	bf00      	nop
240007a6:	46bd      	mov	sp, r7
240007a8:	f85d 7b04 	ldr.w	r7, [sp], #4
240007ac:	4770      	bx	lr

240007ae <HAL_MspDeInit>:
/**
  * @brief  DeInitializes the MSP.
  * @retval None
  */
__weak void HAL_MspDeInit(void)
{
240007ae:	b480      	push	{r7}
240007b0:	af00      	add	r7, sp, #0
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_MspDeInit could be implemented in the user file
   */
}
240007b2:	bf00      	nop
240007b4:	46bd      	mov	sp, r7
240007b6:	f85d 7b04 	ldr.w	r7, [sp], #4
240007ba:	4770      	bx	lr

240007bc <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
240007bc:	b580      	push	{r7, lr}
240007be:	b082      	sub	sp, #8
240007c0:	af00      	add	r7, sp, #0
240007c2:	6078      	str	r0, [r7, #4]
  /* Check uwTickFreq for MisraC 2012 (even if uwTickFreq is a enum type that don't take the value zero)*/
  if((uint32_t)uwTickFreq == 0UL)
240007c4:	4b15      	ldr	r3, [pc, #84]	; (2400081c <HAL_InitTick+0x60>)
240007c6:	781b      	ldrb	r3, [r3, #0]
240007c8:	2b00      	cmp	r3, #0
240007ca:	d101      	bne.n	240007d0 <HAL_InitTick+0x14>
  {
    return HAL_ERROR;
240007cc:	2301      	movs	r3, #1
240007ce:	e021      	b.n	24000814 <HAL_InitTick+0x58>
  }

  /* Configure the SysTick to have interrupt in 1ms time basis*/
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000UL / (uint32_t)uwTickFreq)) > 0U)
240007d0:	4b13      	ldr	r3, [pc, #76]	; (24000820 <HAL_InitTick+0x64>)
240007d2:	681a      	ldr	r2, [r3, #0]
240007d4:	4b11      	ldr	r3, [pc, #68]	; (2400081c <HAL_InitTick+0x60>)
240007d6:	781b      	ldrb	r3, [r3, #0]
240007d8:	4619      	mov	r1, r3
240007da:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
240007de:	fbb3 f3f1 	udiv	r3, r3, r1
240007e2:	fbb2 f3f3 	udiv	r3, r2, r3
240007e6:	4618      	mov	r0, r3
240007e8:	f000 fec1 	bl	2400156e <HAL_SYSTICK_Config>
240007ec:	4603      	mov	r3, r0
240007ee:	2b00      	cmp	r3, #0
240007f0:	d001      	beq.n	240007f6 <HAL_InitTick+0x3a>
  {
    return HAL_ERROR;
240007f2:	2301      	movs	r3, #1
240007f4:	e00e      	b.n	24000814 <HAL_InitTick+0x58>
  }

  /* Configure the SysTick IRQ priority */
  if (TickPriority < (1UL << __NVIC_PRIO_BITS))
240007f6:	687b      	ldr	r3, [r7, #4]
240007f8:	2b0f      	cmp	r3, #15
240007fa:	d80a      	bhi.n	24000812 <HAL_InitTick+0x56>
  {
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
240007fc:	2200      	movs	r2, #0
240007fe:	6879      	ldr	r1, [r7, #4]
24000800:	f04f 30ff 	mov.w	r0, #4294967295
24000804:	f000 fe79 	bl	240014fa <HAL_NVIC_SetPriority>
    uwTickPrio = TickPriority;
24000808:	4a06      	ldr	r2, [pc, #24]	; (24000824 <HAL_InitTick+0x68>)
2400080a:	687b      	ldr	r3, [r7, #4]
2400080c:	6013      	str	r3, [r2, #0]
  {
    return HAL_ERROR;
  }

  /* Return function status */
  return HAL_OK;
2400080e:	2300      	movs	r3, #0
24000810:	e000      	b.n	24000814 <HAL_InitTick+0x58>
    return HAL_ERROR;
24000812:	2301      	movs	r3, #1
}
24000814:	4618      	mov	r0, r3
24000816:	3708      	adds	r7, #8
24000818:	46bd      	mov	sp, r7
2400081a:	bd80      	pop	{r7, pc}
2400081c:	240004b0 	.word	0x240004b0
24000820:	240004b8 	.word	0x240004b8
24000824:	240004ac 	.word	0x240004ac

24000828 <HAL_IncTick>:
 * @note This function is declared as __weak to be overwritten in case of other
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
24000828:	b480      	push	{r7}
2400082a:	af00      	add	r7, sp, #0
  uwTick += (uint32_t)uwTickFreq;
2400082c:	4b06      	ldr	r3, [pc, #24]	; (24000848 <HAL_IncTick+0x20>)
2400082e:	781b      	ldrb	r3, [r3, #0]
24000830:	461a      	mov	r2, r3
24000832:	4b06      	ldr	r3, [pc, #24]	; (2400084c <HAL_IncTick+0x24>)
24000834:	681b      	ldr	r3, [r3, #0]
24000836:	4413      	add	r3, r2
24000838:	4a04      	ldr	r2, [pc, #16]	; (2400084c <HAL_IncTick+0x24>)
2400083a:	6013      	str	r3, [r2, #0]
}
2400083c:	bf00      	nop
2400083e:	46bd      	mov	sp, r7
24000840:	f85d 7b04 	ldr.w	r7, [sp], #4
24000844:	4770      	bx	lr
24000846:	bf00      	nop
24000848:	240004b0 	.word	0x240004b0
2400084c:	24000544 	.word	0x24000544

24000850 <HAL_GetTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
24000850:	b480      	push	{r7}
24000852:	af00      	add	r7, sp, #0
  return uwTick;
24000854:	4b03      	ldr	r3, [pc, #12]	; (24000864 <HAL_GetTick+0x14>)
24000856:	681b      	ldr	r3, [r3, #0]
}
24000858:	4618      	mov	r0, r3
2400085a:	46bd      	mov	sp, r7
2400085c:	f85d 7b04 	ldr.w	r7, [sp], #4
24000860:	4770      	bx	lr
24000862:	bf00      	nop
24000864:	24000544 	.word	0x24000544

24000868 <HAL_GetTickPrio>:
/**
  * @brief This function returns a tick priority.
  * @retval tick priority
  */
uint32_t HAL_GetTickPrio(void)
{
24000868:	b480      	push	{r7}
2400086a:	af00      	add	r7, sp, #0
  return uwTickPrio;
2400086c:	4b03      	ldr	r3, [pc, #12]	; (2400087c <HAL_GetTickPrio+0x14>)
2400086e:	681b      	ldr	r3, [r3, #0]
}
24000870:	4618      	mov	r0, r3
24000872:	46bd      	mov	sp, r7
24000874:	f85d 7b04 	ldr.w	r7, [sp], #4
24000878:	4770      	bx	lr
2400087a:	bf00      	nop
2400087c:	240004ac 	.word	0x240004ac

24000880 <HAL_SetTickFreq>:
/**
  * @brief Set new tick Freq.
  * @retval Status
  */
HAL_StatusTypeDef HAL_SetTickFreq(HAL_TickFreqTypeDef Freq)
{
24000880:	b580      	push	{r7, lr}
24000882:	b084      	sub	sp, #16
24000884:	af00      	add	r7, sp, #0
24000886:	4603      	mov	r3, r0
24000888:	71fb      	strb	r3, [r7, #7]
  HAL_StatusTypeDef status  = HAL_OK;
2400088a:	2300      	movs	r3, #0
2400088c:	73fb      	strb	r3, [r7, #15]
  HAL_TickFreqTypeDef prevTickFreq;

  assert_param(IS_TICKFREQ(Freq));

  if (uwTickFreq != Freq)
2400088e:	4b0e      	ldr	r3, [pc, #56]	; (240008c8 <HAL_SetTickFreq+0x48>)
24000890:	781b      	ldrb	r3, [r3, #0]
24000892:	79fa      	ldrb	r2, [r7, #7]
24000894:	429a      	cmp	r2, r3
24000896:	d012      	beq.n	240008be <HAL_SetTickFreq+0x3e>
  {

    /* Back up uwTickFreq frequency */
    prevTickFreq = uwTickFreq;
24000898:	4b0b      	ldr	r3, [pc, #44]	; (240008c8 <HAL_SetTickFreq+0x48>)
2400089a:	781b      	ldrb	r3, [r3, #0]
2400089c:	73bb      	strb	r3, [r7, #14]

    /* Update uwTickFreq global variable used by HAL_InitTick() */
    uwTickFreq = Freq;
2400089e:	4a0a      	ldr	r2, [pc, #40]	; (240008c8 <HAL_SetTickFreq+0x48>)
240008a0:	79fb      	ldrb	r3, [r7, #7]
240008a2:	7013      	strb	r3, [r2, #0]

    /* Apply the new tick Freq  */
    status = HAL_InitTick(uwTickPrio);
240008a4:	4b09      	ldr	r3, [pc, #36]	; (240008cc <HAL_SetTickFreq+0x4c>)
240008a6:	681b      	ldr	r3, [r3, #0]
240008a8:	4618      	mov	r0, r3
240008aa:	f7ff ff87 	bl	240007bc <HAL_InitTick>
240008ae:	4603      	mov	r3, r0
240008b0:	73fb      	strb	r3, [r7, #15]
    if (status != HAL_OK)
240008b2:	7bfb      	ldrb	r3, [r7, #15]
240008b4:	2b00      	cmp	r3, #0
240008b6:	d002      	beq.n	240008be <HAL_SetTickFreq+0x3e>
    {
      /* Restore previous tick frequency */
      uwTickFreq = prevTickFreq;
240008b8:	4a03      	ldr	r2, [pc, #12]	; (240008c8 <HAL_SetTickFreq+0x48>)
240008ba:	7bbb      	ldrb	r3, [r7, #14]
240008bc:	7013      	strb	r3, [r2, #0]
    }
  }

  return status;
240008be:	7bfb      	ldrb	r3, [r7, #15]
}
240008c0:	4618      	mov	r0, r3
240008c2:	3710      	adds	r7, #16
240008c4:	46bd      	mov	sp, r7
240008c6:	bd80      	pop	{r7, pc}
240008c8:	240004b0 	.word	0x240004b0
240008cc:	240004ac 	.word	0x240004ac

240008d0 <HAL_GetTickFreq>:
/**
  * @brief Return tick frequency.
  * @retval tick period in Hz
  */
HAL_TickFreqTypeDef HAL_GetTickFreq(void)
{
240008d0:	b480      	push	{r7}
240008d2:	af00      	add	r7, sp, #0
  return uwTickFreq;
240008d4:	4b03      	ldr	r3, [pc, #12]	; (240008e4 <HAL_GetTickFreq+0x14>)
240008d6:	781b      	ldrb	r3, [r3, #0]
}
240008d8:	4618      	mov	r0, r3
240008da:	46bd      	mov	sp, r7
240008dc:	f85d 7b04 	ldr.w	r7, [sp], #4
240008e0:	4770      	bx	lr
240008e2:	bf00      	nop
240008e4:	240004b0 	.word	0x240004b0

240008e8 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay  specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
240008e8:	b580      	push	{r7, lr}
240008ea:	b084      	sub	sp, #16
240008ec:	af00      	add	r7, sp, #0
240008ee:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = HAL_GetTick();
240008f0:	f7ff ffae 	bl	24000850 <HAL_GetTick>
240008f4:	60b8      	str	r0, [r7, #8]
  uint32_t wait = Delay;
240008f6:	687b      	ldr	r3, [r7, #4]
240008f8:	60fb      	str	r3, [r7, #12]

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
240008fa:	68fb      	ldr	r3, [r7, #12]
240008fc:	f1b3 3fff 	cmp.w	r3, #4294967295
24000900:	d005      	beq.n	2400090e <HAL_Delay+0x26>
  {
    wait += (uint32_t)(uwTickFreq);
24000902:	4b09      	ldr	r3, [pc, #36]	; (24000928 <HAL_Delay+0x40>)
24000904:	781b      	ldrb	r3, [r3, #0]
24000906:	461a      	mov	r2, r3
24000908:	68fb      	ldr	r3, [r7, #12]
2400090a:	4413      	add	r3, r2
2400090c:	60fb      	str	r3, [r7, #12]
  }

  while ((HAL_GetTick() - tickstart) < wait)
2400090e:	bf00      	nop
24000910:	f7ff ff9e 	bl	24000850 <HAL_GetTick>
24000914:	4602      	mov	r2, r0
24000916:	68bb      	ldr	r3, [r7, #8]
24000918:	1ad3      	subs	r3, r2, r3
2400091a:	68fa      	ldr	r2, [r7, #12]
2400091c:	429a      	cmp	r2, r3
2400091e:	d8f7      	bhi.n	24000910 <HAL_Delay+0x28>
  {
  }
}
24000920:	bf00      	nop
24000922:	3710      	adds	r7, #16
24000924:	46bd      	mov	sp, r7
24000926:	bd80      	pop	{r7, pc}
24000928:	240004b0 	.word	0x240004b0

2400092c <HAL_SuspendTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *       implementations in user file.
  * @retval None
  */
__weak void HAL_SuspendTick(void)
{
2400092c:	b480      	push	{r7}
2400092e:	af00      	add	r7, sp, #0
  /* Disable SysTick Interrupt */
  SysTick->CTRL &= ~SysTick_CTRL_TICKINT_Msk;
24000930:	4b05      	ldr	r3, [pc, #20]	; (24000948 <HAL_SuspendTick+0x1c>)
24000932:	681b      	ldr	r3, [r3, #0]
24000934:	4a04      	ldr	r2, [pc, #16]	; (24000948 <HAL_SuspendTick+0x1c>)
24000936:	f023 0302 	bic.w	r3, r3, #2
2400093a:	6013      	str	r3, [r2, #0]
}
2400093c:	bf00      	nop
2400093e:	46bd      	mov	sp, r7
24000940:	f85d 7b04 	ldr.w	r7, [sp], #4
24000944:	4770      	bx	lr
24000946:	bf00      	nop
24000948:	e000e010 	.word	0xe000e010

2400094c <HAL_ResumeTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *       implementations in user file.
  * @retval None
  */
__weak void HAL_ResumeTick(void)
{
2400094c:	b480      	push	{r7}
2400094e:	af00      	add	r7, sp, #0
  /* Enable SysTick Interrupt */
  SysTick->CTRL  |= SysTick_CTRL_TICKINT_Msk;
24000950:	4b05      	ldr	r3, [pc, #20]	; (24000968 <HAL_ResumeTick+0x1c>)
24000952:	681b      	ldr	r3, [r3, #0]
24000954:	4a04      	ldr	r2, [pc, #16]	; (24000968 <HAL_ResumeTick+0x1c>)
24000956:	f043 0302 	orr.w	r3, r3, #2
2400095a:	6013      	str	r3, [r2, #0]
}
2400095c:	bf00      	nop
2400095e:	46bd      	mov	sp, r7
24000960:	f85d 7b04 	ldr.w	r7, [sp], #4
24000964:	4770      	bx	lr
24000966:	bf00      	nop
24000968:	e000e010 	.word	0xe000e010

2400096c <HAL_GetHalVersion>:
/**
  * @brief  Returns the HAL revision
  * @retval version : 0xXYZR (8bits for each decimal, R for RC)
  */
uint32_t HAL_GetHalVersion(void)
{
2400096c:	b480      	push	{r7}
2400096e:	af00      	add	r7, sp, #0
 return __STM32H7xx_HAL_VERSION;
24000970:	f04f 7384 	mov.w	r3, #17301504	; 0x1080000
}
24000974:	4618      	mov	r0, r3
24000976:	46bd      	mov	sp, r7
24000978:	f85d 7b04 	ldr.w	r7, [sp], #4
2400097c:	4770      	bx	lr
	...

24000980 <HAL_GetREVID>:
/**
  * @brief  Returns the device revision identifier.
  * @retval Device revision identifier
  */
uint32_t HAL_GetREVID(void)
{
24000980:	b480      	push	{r7}
24000982:	af00      	add	r7, sp, #0
   return((DBGMCU->IDCODE) >> 16);
24000984:	4b03      	ldr	r3, [pc, #12]	; (24000994 <HAL_GetREVID+0x14>)
24000986:	681b      	ldr	r3, [r3, #0]
24000988:	0c1b      	lsrs	r3, r3, #16
}
2400098a:	4618      	mov	r0, r3
2400098c:	46bd      	mov	sp, r7
2400098e:	f85d 7b04 	ldr.w	r7, [sp], #4
24000992:	4770      	bx	lr
24000994:	5c001000 	.word	0x5c001000

24000998 <HAL_GetDEVID>:
/**
  * @brief  Returns the device identifier.
  * @retval Device identifier
  */
uint32_t HAL_GetDEVID(void)
{
24000998:	b480      	push	{r7}
2400099a:	af00      	add	r7, sp, #0
   return((DBGMCU->IDCODE) & IDCODE_DEVID_MASK);
2400099c:	4b04      	ldr	r3, [pc, #16]	; (240009b0 <HAL_GetDEVID+0x18>)
2400099e:	681b      	ldr	r3, [r3, #0]
240009a0:	f3c3 030b 	ubfx	r3, r3, #0, #12
}
240009a4:	4618      	mov	r0, r3
240009a6:	46bd      	mov	sp, r7
240009a8:	f85d 7b04 	ldr.w	r7, [sp], #4
240009ac:	4770      	bx	lr
240009ae:	bf00      	nop
240009b0:	5c001000 	.word	0x5c001000

240009b4 <HAL_GetUIDw0>:
/**
  * @brief  Return the first word of the unique device identifier (UID based on 96 bits)
  * @retval Device identifier
  */
uint32_t HAL_GetUIDw0(void)
{
240009b4:	b480      	push	{r7}
240009b6:	af00      	add	r7, sp, #0
  return(READ_REG(*((uint32_t *)UID_BASE)));
240009b8:	4b03      	ldr	r3, [pc, #12]	; (240009c8 <HAL_GetUIDw0+0x14>)
240009ba:	681b      	ldr	r3, [r3, #0]
}
240009bc:	4618      	mov	r0, r3
240009be:	46bd      	mov	sp, r7
240009c0:	f85d 7b04 	ldr.w	r7, [sp], #4
240009c4:	4770      	bx	lr
240009c6:	bf00      	nop
240009c8:	1ff1e800 	.word	0x1ff1e800

240009cc <HAL_GetUIDw1>:
/**
  * @brief  Return the second word of the unique device identifier (UID based on 96 bits)
  * @retval Device identifier
  */
uint32_t HAL_GetUIDw1(void)
{
240009cc:	b480      	push	{r7}
240009ce:	af00      	add	r7, sp, #0
  return(READ_REG(*((uint32_t *)(UID_BASE + 4U))));
240009d0:	4b03      	ldr	r3, [pc, #12]	; (240009e0 <HAL_GetUIDw1+0x14>)
240009d2:	681b      	ldr	r3, [r3, #0]
}
240009d4:	4618      	mov	r0, r3
240009d6:	46bd      	mov	sp, r7
240009d8:	f85d 7b04 	ldr.w	r7, [sp], #4
240009dc:	4770      	bx	lr
240009de:	bf00      	nop
240009e0:	1ff1e804 	.word	0x1ff1e804

240009e4 <HAL_GetUIDw2>:
/**
  * @brief  Return the third word of the unique device identifier (UID based on 96 bits)
  * @retval Device identifier
  */
uint32_t HAL_GetUIDw2(void)
{
240009e4:	b480      	push	{r7}
240009e6:	af00      	add	r7, sp, #0
  return(READ_REG(*((uint32_t *)(UID_BASE + 8U))));
240009e8:	4b03      	ldr	r3, [pc, #12]	; (240009f8 <HAL_GetUIDw2+0x14>)
240009ea:	681b      	ldr	r3, [r3, #0]
}
240009ec:	4618      	mov	r0, r3
240009ee:	46bd      	mov	sp, r7
240009f0:	f85d 7b04 	ldr.w	r7, [sp], #4
240009f4:	4770      	bx	lr
240009f6:	bf00      	nop
240009f8:	1ff1e808 	.word	0x1ff1e808

240009fc <HAL_SYSCFG_VREFBUF_VoltageScalingConfig>:
  *            @arg SYSCFG_VREFBUF_VOLTAGE_SCALE3: VREF_OUT4 around 1.8 V.
  *                                                This requires VDDA equal to or higher than 2.1 V.
  * @retval None
  */
void HAL_SYSCFG_VREFBUF_VoltageScalingConfig(uint32_t VoltageScaling)
{
240009fc:	b480      	push	{r7}
240009fe:	b083      	sub	sp, #12
24000a00:	af00      	add	r7, sp, #0
24000a02:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_SYSCFG_VREFBUF_VOLTAGE_SCALE(VoltageScaling));

  MODIFY_REG(VREFBUF->CSR, VREFBUF_CSR_VRS, VoltageScaling);
24000a04:	4b06      	ldr	r3, [pc, #24]	; (24000a20 <HAL_SYSCFG_VREFBUF_VoltageScalingConfig+0x24>)
24000a06:	681b      	ldr	r3, [r3, #0]
24000a08:	f023 0270 	bic.w	r2, r3, #112	; 0x70
24000a0c:	4904      	ldr	r1, [pc, #16]	; (24000a20 <HAL_SYSCFG_VREFBUF_VoltageScalingConfig+0x24>)
24000a0e:	687b      	ldr	r3, [r7, #4]
24000a10:	4313      	orrs	r3, r2
24000a12:	600b      	str	r3, [r1, #0]
}
24000a14:	bf00      	nop
24000a16:	370c      	adds	r7, #12
24000a18:	46bd      	mov	sp, r7
24000a1a:	f85d 7b04 	ldr.w	r7, [sp], #4
24000a1e:	4770      	bx	lr
24000a20:	58003c00 	.word	0x58003c00

24000a24 <HAL_SYSCFG_VREFBUF_HighImpedanceConfig>:
  *            @arg SYSCFG_VREFBUF_HIGH_IMPEDANCE_DISABLE: VREF+ pin is internally connect to VREFINT output.
  *            @arg SYSCFG_VREFBUF_HIGH_IMPEDANCE_ENABLE: VREF+ pin is high impedance.
  * @retval None
  */
void HAL_SYSCFG_VREFBUF_HighImpedanceConfig(uint32_t Mode)
{
24000a24:	b480      	push	{r7}
24000a26:	b083      	sub	sp, #12
24000a28:	af00      	add	r7, sp, #0
24000a2a:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_SYSCFG_VREFBUF_HIGH_IMPEDANCE(Mode));

  MODIFY_REG(VREFBUF->CSR, VREFBUF_CSR_HIZ, Mode);
24000a2c:	4b06      	ldr	r3, [pc, #24]	; (24000a48 <HAL_SYSCFG_VREFBUF_HighImpedanceConfig+0x24>)
24000a2e:	681b      	ldr	r3, [r3, #0]
24000a30:	f023 0202 	bic.w	r2, r3, #2
24000a34:	4904      	ldr	r1, [pc, #16]	; (24000a48 <HAL_SYSCFG_VREFBUF_HighImpedanceConfig+0x24>)
24000a36:	687b      	ldr	r3, [r7, #4]
24000a38:	4313      	orrs	r3, r2
24000a3a:	600b      	str	r3, [r1, #0]
}
24000a3c:	bf00      	nop
24000a3e:	370c      	adds	r7, #12
24000a40:	46bd      	mov	sp, r7
24000a42:	f85d 7b04 	ldr.w	r7, [sp], #4
24000a46:	4770      	bx	lr
24000a48:	58003c00 	.word	0x58003c00

24000a4c <HAL_SYSCFG_VREFBUF_TrimmingConfig>:
/**
  * @brief  Tune the Internal Voltage Reference buffer (VREFBUF).
  * @retval None
  */
void HAL_SYSCFG_VREFBUF_TrimmingConfig(uint32_t TrimmingValue)
{
24000a4c:	b480      	push	{r7}
24000a4e:	b083      	sub	sp, #12
24000a50:	af00      	add	r7, sp, #0
24000a52:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_SYSCFG_VREFBUF_TRIMMING(TrimmingValue));

  MODIFY_REG(VREFBUF->CCR, VREFBUF_CCR_TRIM, TrimmingValue);
24000a54:	4b06      	ldr	r3, [pc, #24]	; (24000a70 <HAL_SYSCFG_VREFBUF_TrimmingConfig+0x24>)
24000a56:	685b      	ldr	r3, [r3, #4]
24000a58:	f023 023f 	bic.w	r2, r3, #63	; 0x3f
24000a5c:	4904      	ldr	r1, [pc, #16]	; (24000a70 <HAL_SYSCFG_VREFBUF_TrimmingConfig+0x24>)
24000a5e:	687b      	ldr	r3, [r7, #4]
24000a60:	4313      	orrs	r3, r2
24000a62:	604b      	str	r3, [r1, #4]
}
24000a64:	bf00      	nop
24000a66:	370c      	adds	r7, #12
24000a68:	46bd      	mov	sp, r7
24000a6a:	f85d 7b04 	ldr.w	r7, [sp], #4
24000a6e:	4770      	bx	lr
24000a70:	58003c00 	.word	0x58003c00

24000a74 <HAL_SYSCFG_EnableVREFBUF>:
/**
  * @brief  Enable the Internal Voltage Reference buffer (VREFBUF).
  * @retval HAL_OK/HAL_TIMEOUT
  */
HAL_StatusTypeDef HAL_SYSCFG_EnableVREFBUF(void)
{
24000a74:	b580      	push	{r7, lr}
24000a76:	b082      	sub	sp, #8
24000a78:	af00      	add	r7, sp, #0
  uint32_t  tickstart;

  SET_BIT(VREFBUF->CSR, VREFBUF_CSR_ENVR);
24000a7a:	4b0f      	ldr	r3, [pc, #60]	; (24000ab8 <HAL_SYSCFG_EnableVREFBUF+0x44>)
24000a7c:	681b      	ldr	r3, [r3, #0]
24000a7e:	4a0e      	ldr	r2, [pc, #56]	; (24000ab8 <HAL_SYSCFG_EnableVREFBUF+0x44>)
24000a80:	f043 0301 	orr.w	r3, r3, #1
24000a84:	6013      	str	r3, [r2, #0]

  /* Get Start Tick*/
  tickstart = HAL_GetTick();
24000a86:	f7ff fee3 	bl	24000850 <HAL_GetTick>
24000a8a:	6078      	str	r0, [r7, #4]

  /* Wait for VRR bit  */
  while(READ_BIT(VREFBUF->CSR, VREFBUF_CSR_VRR) == 0UL)
24000a8c:	e008      	b.n	24000aa0 <HAL_SYSCFG_EnableVREFBUF+0x2c>
  {
    if((HAL_GetTick() - tickstart) > VREFBUF_TIMEOUT_VALUE)
24000a8e:	f7ff fedf 	bl	24000850 <HAL_GetTick>
24000a92:	4602      	mov	r2, r0
24000a94:	687b      	ldr	r3, [r7, #4]
24000a96:	1ad3      	subs	r3, r2, r3
24000a98:	2b0a      	cmp	r3, #10
24000a9a:	d901      	bls.n	24000aa0 <HAL_SYSCFG_EnableVREFBUF+0x2c>
    {
      return HAL_TIMEOUT;
24000a9c:	2303      	movs	r3, #3
24000a9e:	e006      	b.n	24000aae <HAL_SYSCFG_EnableVREFBUF+0x3a>
  while(READ_BIT(VREFBUF->CSR, VREFBUF_CSR_VRR) == 0UL)
24000aa0:	4b05      	ldr	r3, [pc, #20]	; (24000ab8 <HAL_SYSCFG_EnableVREFBUF+0x44>)
24000aa2:	681b      	ldr	r3, [r3, #0]
24000aa4:	f003 0308 	and.w	r3, r3, #8
24000aa8:	2b00      	cmp	r3, #0
24000aaa:	d0f0      	beq.n	24000a8e <HAL_SYSCFG_EnableVREFBUF+0x1a>
    }
  }

  return HAL_OK;
24000aac:	2300      	movs	r3, #0
}
24000aae:	4618      	mov	r0, r3
24000ab0:	3708      	adds	r7, #8
24000ab2:	46bd      	mov	sp, r7
24000ab4:	bd80      	pop	{r7, pc}
24000ab6:	bf00      	nop
24000ab8:	58003c00 	.word	0x58003c00

24000abc <HAL_SYSCFG_DisableVREFBUF>:
  * @brief  Disable the Internal Voltage Reference buffer (VREFBUF).
  *
  * @retval None
  */
void HAL_SYSCFG_DisableVREFBUF(void)
{
24000abc:	b480      	push	{r7}
24000abe:	af00      	add	r7, sp, #0
  CLEAR_BIT(VREFBUF->CSR, VREFBUF_CSR_ENVR);
24000ac0:	4b05      	ldr	r3, [pc, #20]	; (24000ad8 <HAL_SYSCFG_DisableVREFBUF+0x1c>)
24000ac2:	681b      	ldr	r3, [r3, #0]
24000ac4:	4a04      	ldr	r2, [pc, #16]	; (24000ad8 <HAL_SYSCFG_DisableVREFBUF+0x1c>)
24000ac6:	f023 0301 	bic.w	r3, r3, #1
24000aca:	6013      	str	r3, [r2, #0]
}
24000acc:	bf00      	nop
24000ace:	46bd      	mov	sp, r7
24000ad0:	f85d 7b04 	ldr.w	r7, [sp], #4
24000ad4:	4770      	bx	lr
24000ad6:	bf00      	nop
24000ad8:	58003c00 	.word	0x58003c00

24000adc <HAL_SYSCFG_ETHInterfaceSelect>:
  *   @arg SYSCFG_ETH_MII : Select the Media Independent Interface
  *   @arg SYSCFG_ETH_RMII: Select the Reduced Media Independent Interface
  * @retval None
  */
void HAL_SYSCFG_ETHInterfaceSelect(uint32_t SYSCFG_ETHInterface)
{
24000adc:	b480      	push	{r7}
24000ade:	b083      	sub	sp, #12
24000ae0:	af00      	add	r7, sp, #0
24000ae2:	6078      	str	r0, [r7, #4]
  /* Check the parameter */
  assert_param(IS_SYSCFG_ETHERNET_CONFIG(SYSCFG_ETHInterface));

  MODIFY_REG(SYSCFG->PMCR, SYSCFG_PMCR_EPIS_SEL, (uint32_t)(SYSCFG_ETHInterface));
24000ae4:	4b06      	ldr	r3, [pc, #24]	; (24000b00 <HAL_SYSCFG_ETHInterfaceSelect+0x24>)
24000ae6:	685b      	ldr	r3, [r3, #4]
24000ae8:	f423 0260 	bic.w	r2, r3, #14680064	; 0xe00000
24000aec:	4904      	ldr	r1, [pc, #16]	; (24000b00 <HAL_SYSCFG_ETHInterfaceSelect+0x24>)
24000aee:	687b      	ldr	r3, [r7, #4]
24000af0:	4313      	orrs	r3, r2
24000af2:	604b      	str	r3, [r1, #4]
}
24000af4:	bf00      	nop
24000af6:	370c      	adds	r7, #12
24000af8:	46bd      	mov	sp, r7
24000afa:	f85d 7b04 	ldr.w	r7, [sp], #4
24000afe:	4770      	bx	lr
24000b00:	58000400 	.word	0x58000400

24000b04 <HAL_SYSCFG_AnalogSwitchConfig>:
  *   @arg SYSCFG_SWITCH_PC3_CLOSE
  * @retval None
  */

void HAL_SYSCFG_AnalogSwitchConfig(uint32_t SYSCFG_AnalogSwitch , uint32_t SYSCFG_SwitchState )
{
24000b04:	b480      	push	{r7}
24000b06:	b083      	sub	sp, #12
24000b08:	af00      	add	r7, sp, #0
24000b0a:	6078      	str	r0, [r7, #4]
24000b0c:	6039      	str	r1, [r7, #0]
  /* Check the parameter */
  assert_param(IS_SYSCFG_ANALOG_SWITCH(SYSCFG_AnalogSwitch));
  assert_param(IS_SYSCFG_SWITCH_STATE(SYSCFG_SwitchState));

  MODIFY_REG(SYSCFG->PMCR, (uint32_t) SYSCFG_AnalogSwitch, (uint32_t)(SYSCFG_SwitchState));
24000b0e:	4b07      	ldr	r3, [pc, #28]	; (24000b2c <HAL_SYSCFG_AnalogSwitchConfig+0x28>)
24000b10:	685a      	ldr	r2, [r3, #4]
24000b12:	687b      	ldr	r3, [r7, #4]
24000b14:	43db      	mvns	r3, r3
24000b16:	401a      	ands	r2, r3
24000b18:	4904      	ldr	r1, [pc, #16]	; (24000b2c <HAL_SYSCFG_AnalogSwitchConfig+0x28>)
24000b1a:	683b      	ldr	r3, [r7, #0]
24000b1c:	4313      	orrs	r3, r2
24000b1e:	604b      	str	r3, [r1, #4]
}
24000b20:	bf00      	nop
24000b22:	370c      	adds	r7, #12
24000b24:	46bd      	mov	sp, r7
24000b26:	f85d 7b04 	ldr.w	r7, [sp], #4
24000b2a:	4770      	bx	lr
24000b2c:	58000400 	.word	0x58000400

24000b30 <HAL_SYSCFG_EnableBOOST>:
  *         when the supply voltage is below 2.7 V: in this case, the analog switch
  *         performance is the same on the full voltage range
  * @retval None
  */
void HAL_SYSCFG_EnableBOOST(void)
{
24000b30:	b480      	push	{r7}
24000b32:	af00      	add	r7, sp, #0
 SET_BIT(SYSCFG->PMCR, SYSCFG_PMCR_BOOSTEN) ;
24000b34:	4b05      	ldr	r3, [pc, #20]	; (24000b4c <HAL_SYSCFG_EnableBOOST+0x1c>)
24000b36:	685b      	ldr	r3, [r3, #4]
24000b38:	4a04      	ldr	r2, [pc, #16]	; (24000b4c <HAL_SYSCFG_EnableBOOST+0x1c>)
24000b3a:	f443 7380 	orr.w	r3, r3, #256	; 0x100
24000b3e:	6053      	str	r3, [r2, #4]
}
24000b40:	bf00      	nop
24000b42:	46bd      	mov	sp, r7
24000b44:	f85d 7b04 	ldr.w	r7, [sp], #4
24000b48:	4770      	bx	lr
24000b4a:	bf00      	nop
24000b4c:	58000400 	.word	0x58000400

24000b50 <HAL_SYSCFG_DisableBOOST>:
  *         when the supply voltage is below 2.7 V: in this case, the analog switch
  *         performance is the same on the full voltage range
  * @retval None
  */
void HAL_SYSCFG_DisableBOOST(void)
{
24000b50:	b480      	push	{r7}
24000b52:	af00      	add	r7, sp, #0
 CLEAR_BIT(SYSCFG->PMCR, SYSCFG_PMCR_BOOSTEN) ;
24000b54:	4b05      	ldr	r3, [pc, #20]	; (24000b6c <HAL_SYSCFG_DisableBOOST+0x1c>)
24000b56:	685b      	ldr	r3, [r3, #4]
24000b58:	4a04      	ldr	r2, [pc, #16]	; (24000b6c <HAL_SYSCFG_DisableBOOST+0x1c>)
24000b5a:	f423 7380 	bic.w	r3, r3, #256	; 0x100
24000b5e:	6053      	str	r3, [r2, #4]
}
24000b60:	bf00      	nop
24000b62:	46bd      	mov	sp, r7
24000b64:	f85d 7b04 	ldr.w	r7, [sp], #4
24000b68:	4770      	bx	lr
24000b6a:	bf00      	nop
24000b6c:	58000400 	.word	0x58000400

24000b70 <HAL_SYSCFG_CM7BootAddConfig>:
  *   @arg SYSCFG_BOOT_ADDR1:  Select the boot address1
  * @param  BootAddress :Specifies the CM7 Boot Address to be loaded in Address0 or Address1
  * @retval None
  */
void HAL_SYSCFG_CM7BootAddConfig(uint32_t BootRegister, uint32_t BootAddress)
{
24000b70:	b480      	push	{r7}
24000b72:	b083      	sub	sp, #12
24000b74:	af00      	add	r7, sp, #0
24000b76:	6078      	str	r0, [r7, #4]
24000b78:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_SYSCFG_BOOT_REGISTER(BootRegister));
  assert_param(IS_SYSCFG_BOOT_ADDRESS(BootAddress));
  if ( BootRegister == SYSCFG_BOOT_ADDR0 )
24000b7a:	687b      	ldr	r3, [r7, #4]
24000b7c:	2b00      	cmp	r3, #0
24000b7e:	d10b      	bne.n	24000b98 <HAL_SYSCFG_CM7BootAddConfig+0x28>
  {
    /* Configure CM7 BOOT ADD0 */
#if defined(DUAL_CORE)
    MODIFY_REG(SYSCFG->UR2, SYSCFG_UR2_BCM7_ADD0, ((BootAddress >> 16) << SYSCFG_UR2_BCM7_ADD0_Pos));
#else
    MODIFY_REG(SYSCFG->UR2, SYSCFG_UR2_BOOT_ADD0, ((BootAddress >> 16) << SYSCFG_UR2_BOOT_ADD0_Pos));
24000b80:	4b0e      	ldr	r3, [pc, #56]	; (24000bbc <HAL_SYSCFG_CM7BootAddConfig+0x4c>)
24000b82:	f8d3 3308 	ldr.w	r3, [r3, #776]	; 0x308
24000b86:	b29a      	uxth	r2, r3
24000b88:	683b      	ldr	r3, [r7, #0]
24000b8a:	0c1b      	lsrs	r3, r3, #16
24000b8c:	041b      	lsls	r3, r3, #16
24000b8e:	490b      	ldr	r1, [pc, #44]	; (24000bbc <HAL_SYSCFG_CM7BootAddConfig+0x4c>)
24000b90:	4313      	orrs	r3, r2
24000b92:	f8c1 3308 	str.w	r3, [r1, #776]	; 0x308
    MODIFY_REG(SYSCFG->UR3, SYSCFG_UR3_BCM7_ADD1, (BootAddress >> 16));
#else
    MODIFY_REG(SYSCFG->UR3, SYSCFG_UR3_BOOT_ADD1, (BootAddress >> 16));
#endif /*DUAL_CORE*/
  }
}
24000b96:	e00a      	b.n	24000bae <HAL_SYSCFG_CM7BootAddConfig+0x3e>
    MODIFY_REG(SYSCFG->UR3, SYSCFG_UR3_BOOT_ADD1, (BootAddress >> 16));
24000b98:	4b08      	ldr	r3, [pc, #32]	; (24000bbc <HAL_SYSCFG_CM7BootAddConfig+0x4c>)
24000b9a:	f8d3 230c 	ldr.w	r2, [r3, #780]	; 0x30c
24000b9e:	4b08      	ldr	r3, [pc, #32]	; (24000bc0 <HAL_SYSCFG_CM7BootAddConfig+0x50>)
24000ba0:	4013      	ands	r3, r2
24000ba2:	683a      	ldr	r2, [r7, #0]
24000ba4:	0c12      	lsrs	r2, r2, #16
24000ba6:	4905      	ldr	r1, [pc, #20]	; (24000bbc <HAL_SYSCFG_CM7BootAddConfig+0x4c>)
24000ba8:	4313      	orrs	r3, r2
24000baa:	f8c1 330c 	str.w	r3, [r1, #780]	; 0x30c
}
24000bae:	bf00      	nop
24000bb0:	370c      	adds	r7, #12
24000bb2:	46bd      	mov	sp, r7
24000bb4:	f85d 7b04 	ldr.w	r7, [sp], #4
24000bb8:	4770      	bx	lr
24000bba:	bf00      	nop
24000bbc:	58000400 	.word	0x58000400
24000bc0:	ffff0000 	.word	0xffff0000

24000bc4 <HAL_EnableCompensationCell>:
  * @note   The I/O compensation cell can be used only when the device supply
  *         voltage ranges from 2.4 to 3.6 V.
  * @retval None
  */
void HAL_EnableCompensationCell(void)
{
24000bc4:	b480      	push	{r7}
24000bc6:	af00      	add	r7, sp, #0
  SET_BIT(SYSCFG->CCCSR, SYSCFG_CCCSR_EN) ;
24000bc8:	4b05      	ldr	r3, [pc, #20]	; (24000be0 <HAL_EnableCompensationCell+0x1c>)
24000bca:	6a1b      	ldr	r3, [r3, #32]
24000bcc:	4a04      	ldr	r2, [pc, #16]	; (24000be0 <HAL_EnableCompensationCell+0x1c>)
24000bce:	f043 0301 	orr.w	r3, r3, #1
24000bd2:	6213      	str	r3, [r2, #32]
}
24000bd4:	bf00      	nop
24000bd6:	46bd      	mov	sp, r7
24000bd8:	f85d 7b04 	ldr.w	r7, [sp], #4
24000bdc:	4770      	bx	lr
24000bde:	bf00      	nop
24000be0:	58000400 	.word	0x58000400

24000be4 <HAL_DisableCompensationCell>:
  * @note   The I/O compensation cell can be used only when the device supply
  *         voltage ranges from 2.4 to 3.6 V.
  * @retval None
  */
void HAL_DisableCompensationCell(void)
{
24000be4:	b480      	push	{r7}
24000be6:	af00      	add	r7, sp, #0
  CLEAR_BIT(SYSCFG->CCCSR, SYSCFG_CCCSR_EN);
24000be8:	4b05      	ldr	r3, [pc, #20]	; (24000c00 <HAL_DisableCompensationCell+0x1c>)
24000bea:	6a1b      	ldr	r3, [r3, #32]
24000bec:	4a04      	ldr	r2, [pc, #16]	; (24000c00 <HAL_DisableCompensationCell+0x1c>)
24000bee:	f023 0301 	bic.w	r3, r3, #1
24000bf2:	6213      	str	r3, [r2, #32]
}
24000bf4:	bf00      	nop
24000bf6:	46bd      	mov	sp, r7
24000bf8:	f85d 7b04 	ldr.w	r7, [sp], #4
24000bfc:	4770      	bx	lr
24000bfe:	bf00      	nop
24000c00:	58000400 	.word	0x58000400

24000c04 <HAL_SYSCFG_EnableIOSpeedOptimize>:
  *         used only if the product supply voltage is below 2.5 V. Setting this bit when VDD is
  *         higher than 2.5 V might be destructive.
  * @retval None
  */
void HAL_SYSCFG_EnableIOSpeedOptimize(void)
{
24000c04:	b480      	push	{r7}
24000c06:	af00      	add	r7, sp, #0
#if defined(SYSCFG_CCCSR_HSLV)
  SET_BIT(SYSCFG->CCCSR, SYSCFG_CCCSR_HSLV);
24000c08:	4b05      	ldr	r3, [pc, #20]	; (24000c20 <HAL_SYSCFG_EnableIOSpeedOptimize+0x1c>)
24000c0a:	6a1b      	ldr	r3, [r3, #32]
24000c0c:	4a04      	ldr	r2, [pc, #16]	; (24000c20 <HAL_SYSCFG_EnableIOSpeedOptimize+0x1c>)
24000c0e:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
24000c12:	6213      	str	r3, [r2, #32]
#else
  SET_BIT(SYSCFG->CCCSR, (SYSCFG_CCCSR_HSLV0| SYSCFG_CCCSR_HSLV1 | SYSCFG_CCCSR_HSLV2  | SYSCFG_CCCSR_HSLV3));
#endif   /* SYSCFG_CCCSR_HSLV */
}
24000c14:	bf00      	nop
24000c16:	46bd      	mov	sp, r7
24000c18:	f85d 7b04 	ldr.w	r7, [sp], #4
24000c1c:	4770      	bx	lr
24000c1e:	bf00      	nop
24000c20:	58000400 	.word	0x58000400

24000c24 <HAL_SYSCFG_DisableIOSpeedOptimize>:
  *         used only if the product supply voltage is below 2.5 V. Setting this bit when VDD is
  *         higher than 2.5 V might be destructive.
  * @retval None
  */
void HAL_SYSCFG_DisableIOSpeedOptimize(void)
{
24000c24:	b480      	push	{r7}
24000c26:	af00      	add	r7, sp, #0
#if defined(SYSCFG_CCCSR_HSLV)
  CLEAR_BIT(SYSCFG->CCCSR, SYSCFG_CCCSR_HSLV);
24000c28:	4b05      	ldr	r3, [pc, #20]	; (24000c40 <HAL_SYSCFG_DisableIOSpeedOptimize+0x1c>)
24000c2a:	6a1b      	ldr	r3, [r3, #32]
24000c2c:	4a04      	ldr	r2, [pc, #16]	; (24000c40 <HAL_SYSCFG_DisableIOSpeedOptimize+0x1c>)
24000c2e:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
24000c32:	6213      	str	r3, [r2, #32]
#else
  CLEAR_BIT(SYSCFG->CCCSR, (SYSCFG_CCCSR_HSLV0| SYSCFG_CCCSR_HSLV1 | SYSCFG_CCCSR_HSLV2  | SYSCFG_CCCSR_HSLV3));
#endif   /* SYSCFG_CCCSR_HSLV */
}
24000c34:	bf00      	nop
24000c36:	46bd      	mov	sp, r7
24000c38:	f85d 7b04 	ldr.w	r7, [sp], #4
24000c3c:	4770      	bx	lr
24000c3e:	bf00      	nop
24000c40:	58000400 	.word	0x58000400

24000c44 <HAL_SYSCFG_CompensationCodeSelect>:
  *   @arg SYSCFG_CELL_CODE : Select Code from the cell (available in the SYSCFG_CCVR)
  *   @arg SYSCFG_REGISTER_CODE: Select Code from the SYSCFG compensation cell code register (SYSCFG_CCCR)
  * @retval None
  */
void HAL_SYSCFG_CompensationCodeSelect(uint32_t SYSCFG_CompCode)
{
24000c44:	b480      	push	{r7}
24000c46:	b083      	sub	sp, #12
24000c48:	af00      	add	r7, sp, #0
24000c4a:	6078      	str	r0, [r7, #4]
  /* Check the parameter */
  assert_param(IS_SYSCFG_CODE_SELECT(SYSCFG_CompCode));
  MODIFY_REG(SYSCFG->CCCSR, SYSCFG_CCCSR_CS, (uint32_t)(SYSCFG_CompCode));
24000c4c:	4b06      	ldr	r3, [pc, #24]	; (24000c68 <HAL_SYSCFG_CompensationCodeSelect+0x24>)
24000c4e:	6a1b      	ldr	r3, [r3, #32]
24000c50:	f023 0202 	bic.w	r2, r3, #2
24000c54:	4904      	ldr	r1, [pc, #16]	; (24000c68 <HAL_SYSCFG_CompensationCodeSelect+0x24>)
24000c56:	687b      	ldr	r3, [r7, #4]
24000c58:	4313      	orrs	r3, r2
24000c5a:	620b      	str	r3, [r1, #32]
}
24000c5c:	bf00      	nop
24000c5e:	370c      	adds	r7, #12
24000c60:	46bd      	mov	sp, r7
24000c62:	f85d 7b04 	ldr.w	r7, [sp], #4
24000c66:	4770      	bx	lr
24000c68:	58000400 	.word	0x58000400

24000c6c <HAL_SYSCFG_CompensationCodeConfig>:
  *         This code is applied to the I/O compensation cell when the CS bit of the
  *          SYSCFG_CMPCR is set
  * @retval None
  */
void HAL_SYSCFG_CompensationCodeConfig(uint32_t SYSCFG_PMOSCode, uint32_t SYSCFG_NMOSCode )
{
24000c6c:	b480      	push	{r7}
24000c6e:	b083      	sub	sp, #12
24000c70:	af00      	add	r7, sp, #0
24000c72:	6078      	str	r0, [r7, #4]
24000c74:	6039      	str	r1, [r7, #0]
  /* Check the parameter */
  assert_param(IS_SYSCFG_CODE_CONFIG(SYSCFG_PMOSCode));
  assert_param(IS_SYSCFG_CODE_CONFIG(SYSCFG_NMOSCode));
  MODIFY_REG(SYSCFG->CCCR, SYSCFG_CCCR_NCC|SYSCFG_CCCR_PCC, (((uint32_t)(SYSCFG_PMOSCode)<< 4)|(uint32_t)(SYSCFG_NMOSCode)) );
24000c76:	4b08      	ldr	r3, [pc, #32]	; (24000c98 <HAL_SYSCFG_CompensationCodeConfig+0x2c>)
24000c78:	6a9b      	ldr	r3, [r3, #40]	; 0x28
24000c7a:	f023 02ff 	bic.w	r2, r3, #255	; 0xff
24000c7e:	687b      	ldr	r3, [r7, #4]
24000c80:	0119      	lsls	r1, r3, #4
24000c82:	683b      	ldr	r3, [r7, #0]
24000c84:	430b      	orrs	r3, r1
24000c86:	4904      	ldr	r1, [pc, #16]	; (24000c98 <HAL_SYSCFG_CompensationCodeConfig+0x2c>)
24000c88:	4313      	orrs	r3, r2
24000c8a:	628b      	str	r3, [r1, #40]	; 0x28
}
24000c8c:	bf00      	nop
24000c8e:	370c      	adds	r7, #12
24000c90:	46bd      	mov	sp, r7
24000c92:	f85d 7b04 	ldr.w	r7, [sp], #4
24000c96:	4770      	bx	lr
24000c98:	58000400 	.word	0x58000400

24000c9c <HAL_DBGMCU_EnableDBGSleepMode>:
/**
  * @brief  Enable the Debug Module during Domain1/CDomain SLEEP mode
  * @retval None
  */
void HAL_EnableDBGSleepMode(void)
{
24000c9c:	b480      	push	{r7}
24000c9e:	af00      	add	r7, sp, #0
  SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_SLEEPD1);
24000ca0:	4b05      	ldr	r3, [pc, #20]	; (24000cb8 <HAL_DBGMCU_EnableDBGSleepMode+0x1c>)
24000ca2:	685b      	ldr	r3, [r3, #4]
24000ca4:	4a04      	ldr	r2, [pc, #16]	; (24000cb8 <HAL_DBGMCU_EnableDBGSleepMode+0x1c>)
24000ca6:	f043 0301 	orr.w	r3, r3, #1
24000caa:	6053      	str	r3, [r2, #4]
}
24000cac:	bf00      	nop
24000cae:	46bd      	mov	sp, r7
24000cb0:	f85d 7b04 	ldr.w	r7, [sp], #4
24000cb4:	4770      	bx	lr
24000cb6:	bf00      	nop
24000cb8:	5c001000 	.word	0x5c001000

24000cbc <HAL_DBGMCU_DisableDBGSleepMode>:
/**
  * @brief  Disable the Debug Module during Domain1/CDomain SLEEP mode
  * @retval None
  */
void HAL_DisableDBGSleepMode(void)
{
24000cbc:	b480      	push	{r7}
24000cbe:	af00      	add	r7, sp, #0
  CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_SLEEPD1);
24000cc0:	4b05      	ldr	r3, [pc, #20]	; (24000cd8 <HAL_DBGMCU_DisableDBGSleepMode+0x1c>)
24000cc2:	685b      	ldr	r3, [r3, #4]
24000cc4:	4a04      	ldr	r2, [pc, #16]	; (24000cd8 <HAL_DBGMCU_DisableDBGSleepMode+0x1c>)
24000cc6:	f023 0301 	bic.w	r3, r3, #1
24000cca:	6053      	str	r3, [r2, #4]
}
24000ccc:	bf00      	nop
24000cce:	46bd      	mov	sp, r7
24000cd0:	f85d 7b04 	ldr.w	r7, [sp], #4
24000cd4:	4770      	bx	lr
24000cd6:	bf00      	nop
24000cd8:	5c001000 	.word	0x5c001000

24000cdc <HAL_DBGMCU_EnableDBGStopMode>:
/**
  * @brief  Enable the Debug Module during Domain1/CDomain STOP mode
  * @retval None
  */
void HAL_EnableDBGStopMode(void)
{
24000cdc:	b480      	push	{r7}
24000cde:	af00      	add	r7, sp, #0
  SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STOPD1);
24000ce0:	4b05      	ldr	r3, [pc, #20]	; (24000cf8 <HAL_DBGMCU_EnableDBGStopMode+0x1c>)
24000ce2:	685b      	ldr	r3, [r3, #4]
24000ce4:	4a04      	ldr	r2, [pc, #16]	; (24000cf8 <HAL_DBGMCU_EnableDBGStopMode+0x1c>)
24000ce6:	f043 0302 	orr.w	r3, r3, #2
24000cea:	6053      	str	r3, [r2, #4]
}
24000cec:	bf00      	nop
24000cee:	46bd      	mov	sp, r7
24000cf0:	f85d 7b04 	ldr.w	r7, [sp], #4
24000cf4:	4770      	bx	lr
24000cf6:	bf00      	nop
24000cf8:	5c001000 	.word	0x5c001000

24000cfc <HAL_DBGMCU_DisableDBGStopMode>:
/**
  * @brief  Disable the Debug Module during Domain1/CDomain STOP mode
  * @retval None
  */
void HAL_DisableDBGStopMode(void)
{
24000cfc:	b480      	push	{r7}
24000cfe:	af00      	add	r7, sp, #0
  CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STOPD1);
24000d00:	4b05      	ldr	r3, [pc, #20]	; (24000d18 <HAL_DBGMCU_DisableDBGStopMode+0x1c>)
24000d02:	685b      	ldr	r3, [r3, #4]
24000d04:	4a04      	ldr	r2, [pc, #16]	; (24000d18 <HAL_DBGMCU_DisableDBGStopMode+0x1c>)
24000d06:	f023 0302 	bic.w	r3, r3, #2
24000d0a:	6053      	str	r3, [r2, #4]
}
24000d0c:	bf00      	nop
24000d0e:	46bd      	mov	sp, r7
24000d10:	f85d 7b04 	ldr.w	r7, [sp], #4
24000d14:	4770      	bx	lr
24000d16:	bf00      	nop
24000d18:	5c001000 	.word	0x5c001000

24000d1c <HAL_DBGMCU_EnableDBGStandbyMode>:
/**
  * @brief  Enable the Debug Module during Domain1/CDomain STANDBY mode
  * @retval None
  */
void HAL_EnableDBGStandbyMode(void)
{
24000d1c:	b480      	push	{r7}
24000d1e:	af00      	add	r7, sp, #0
  SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STANDBYD1);
24000d20:	4b05      	ldr	r3, [pc, #20]	; (24000d38 <HAL_DBGMCU_EnableDBGStandbyMode+0x1c>)
24000d22:	685b      	ldr	r3, [r3, #4]
24000d24:	4a04      	ldr	r2, [pc, #16]	; (24000d38 <HAL_DBGMCU_EnableDBGStandbyMode+0x1c>)
24000d26:	f043 0304 	orr.w	r3, r3, #4
24000d2a:	6053      	str	r3, [r2, #4]
}
24000d2c:	bf00      	nop
24000d2e:	46bd      	mov	sp, r7
24000d30:	f85d 7b04 	ldr.w	r7, [sp], #4
24000d34:	4770      	bx	lr
24000d36:	bf00      	nop
24000d38:	5c001000 	.word	0x5c001000

24000d3c <HAL_DBGMCU_DisableDBGStandbyMode>:
/**
  * @brief  Disable the Debug Module during Domain1/CDomain STANDBY mode
  * @retval None
  */
void HAL_DisableDBGStandbyMode(void)
{
24000d3c:	b480      	push	{r7}
24000d3e:	af00      	add	r7, sp, #0
  CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STANDBYD1);
24000d40:	4b05      	ldr	r3, [pc, #20]	; (24000d58 <HAL_DBGMCU_DisableDBGStandbyMode+0x1c>)
24000d42:	685b      	ldr	r3, [r3, #4]
24000d44:	4a04      	ldr	r2, [pc, #16]	; (24000d58 <HAL_DBGMCU_DisableDBGStandbyMode+0x1c>)
24000d46:	f023 0304 	bic.w	r3, r3, #4
24000d4a:	6053      	str	r3, [r2, #4]
}
24000d4c:	bf00      	nop
24000d4e:	46bd      	mov	sp, r7
24000d50:	f85d 7b04 	ldr.w	r7, [sp], #4
24000d54:	4770      	bx	lr
24000d56:	bf00      	nop
24000d58:	5c001000 	.word	0x5c001000

24000d5c <HAL_EnableDomain3DBGStopMode>:
/**
  * @brief  Enable the Debug Module during Domain3/SRDomain STOP mode
  * @retval None
  */
void HAL_EnableDomain3DBGStopMode(void)
{
24000d5c:	b480      	push	{r7}
24000d5e:	af00      	add	r7, sp, #0
  SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STOPD3);
24000d60:	4b05      	ldr	r3, [pc, #20]	; (24000d78 <HAL_EnableDomain3DBGStopMode+0x1c>)
24000d62:	685b      	ldr	r3, [r3, #4]
24000d64:	4a04      	ldr	r2, [pc, #16]	; (24000d78 <HAL_EnableDomain3DBGStopMode+0x1c>)
24000d66:	f043 0380 	orr.w	r3, r3, #128	; 0x80
24000d6a:	6053      	str	r3, [r2, #4]
}
24000d6c:	bf00      	nop
24000d6e:	46bd      	mov	sp, r7
24000d70:	f85d 7b04 	ldr.w	r7, [sp], #4
24000d74:	4770      	bx	lr
24000d76:	bf00      	nop
24000d78:	5c001000 	.word	0x5c001000

24000d7c <HAL_DisableDomain3DBGStopMode>:
/**
  * @brief  Disable the Debug Module during Domain3/SRDomain STOP mode
  * @retval None
  */
void HAL_DisableDomain3DBGStopMode(void)
{
24000d7c:	b480      	push	{r7}
24000d7e:	af00      	add	r7, sp, #0
  CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STOPD3);
24000d80:	4b05      	ldr	r3, [pc, #20]	; (24000d98 <HAL_DisableDomain3DBGStopMode+0x1c>)
24000d82:	685b      	ldr	r3, [r3, #4]
24000d84:	4a04      	ldr	r2, [pc, #16]	; (24000d98 <HAL_DisableDomain3DBGStopMode+0x1c>)
24000d86:	f023 0380 	bic.w	r3, r3, #128	; 0x80
24000d8a:	6053      	str	r3, [r2, #4]
}
24000d8c:	bf00      	nop
24000d8e:	46bd      	mov	sp, r7
24000d90:	f85d 7b04 	ldr.w	r7, [sp], #4
24000d94:	4770      	bx	lr
24000d96:	bf00      	nop
24000d98:	5c001000 	.word	0x5c001000

24000d9c <HAL_EnableDomain3DBGStandbyMode>:
/**
  * @brief  Enable the Debug Module during Domain3/SRDomain STANDBY mode
  * @retval None
  */
void HAL_EnableDomain3DBGStandbyMode(void)
{
24000d9c:	b480      	push	{r7}
24000d9e:	af00      	add	r7, sp, #0
  SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STANDBYD3);
24000da0:	4b05      	ldr	r3, [pc, #20]	; (24000db8 <HAL_EnableDomain3DBGStandbyMode+0x1c>)
24000da2:	685b      	ldr	r3, [r3, #4]
24000da4:	4a04      	ldr	r2, [pc, #16]	; (24000db8 <HAL_EnableDomain3DBGStandbyMode+0x1c>)
24000da6:	f443 7380 	orr.w	r3, r3, #256	; 0x100
24000daa:	6053      	str	r3, [r2, #4]
}
24000dac:	bf00      	nop
24000dae:	46bd      	mov	sp, r7
24000db0:	f85d 7b04 	ldr.w	r7, [sp], #4
24000db4:	4770      	bx	lr
24000db6:	bf00      	nop
24000db8:	5c001000 	.word	0x5c001000

24000dbc <HAL_DisableDomain3DBGStandbyMode>:
/**
  * @brief  Disable the Debug Module during Domain3/SRDomain STANDBY mode
  * @retval None
  */
void HAL_DisableDomain3DBGStandbyMode(void)
{
24000dbc:	b480      	push	{r7}
24000dbe:	af00      	add	r7, sp, #0
  CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STANDBYD3);
24000dc0:	4b05      	ldr	r3, [pc, #20]	; (24000dd8 <HAL_DisableDomain3DBGStandbyMode+0x1c>)
24000dc2:	685b      	ldr	r3, [r3, #4]
24000dc4:	4a04      	ldr	r2, [pc, #16]	; (24000dd8 <HAL_DisableDomain3DBGStandbyMode+0x1c>)
24000dc6:	f423 7380 	bic.w	r3, r3, #256	; 0x100
24000dca:	6053      	str	r3, [r2, #4]
}
24000dcc:	bf00      	nop
24000dce:	46bd      	mov	sp, r7
24000dd0:	f85d 7b04 	ldr.w	r7, [sp], #4
24000dd4:	4770      	bx	lr
24000dd6:	bf00      	nop
24000dd8:	5c001000 	.word	0x5c001000

24000ddc <HAL_SetFMCMemorySwappingConfig>:
  * @param  BankMapConfig: Defines the FMC Bank mapping configuration. This parameter can be
            FMC_SWAPBMAP_DISABLE, FMC_SWAPBMAP_SDRAM_SRAM, FMC_SWAPBMAP_SDRAMB2
  * @retval HAL state
  */
void HAL_SetFMCMemorySwappingConfig(uint32_t BankMapConfig)
{
24000ddc:	b480      	push	{r7}
24000dde:	b083      	sub	sp, #12
24000de0:	af00      	add	r7, sp, #0
24000de2:	6078      	str	r0, [r7, #4]
  /* Check the parameter */
  assert_param(IS_FMC_SWAPBMAP_MODE(BankMapConfig));
  MODIFY_REG(FMC_Bank1_R->BTCR[0], FMC_BCR1_BMAP, BankMapConfig);
24000de4:	4b06      	ldr	r3, [pc, #24]	; (24000e00 <HAL_SetFMCMemorySwappingConfig+0x24>)
24000de6:	681b      	ldr	r3, [r3, #0]
24000de8:	f023 7240 	bic.w	r2, r3, #50331648	; 0x3000000
24000dec:	4904      	ldr	r1, [pc, #16]	; (24000e00 <HAL_SetFMCMemorySwappingConfig+0x24>)
24000dee:	687b      	ldr	r3, [r7, #4]
24000df0:	4313      	orrs	r3, r2
24000df2:	600b      	str	r3, [r1, #0]
}
24000df4:	bf00      	nop
24000df6:	370c      	adds	r7, #12
24000df8:	46bd      	mov	sp, r7
24000dfa:	f85d 7b04 	ldr.w	r7, [sp], #4
24000dfe:	4770      	bx	lr
24000e00:	52004000 	.word	0x52004000

24000e04 <HAL_GetFMCMemorySwappingConfig>:
  * @brief  Get FMC Bank mapping mode.
  * @retval The FMC Bank mapping mode. This parameter can be
            FMC_SWAPBMAP_DISABLE, FMC_SWAPBMAP_SDRAM_SRAM, FMC_SWAPBMAP_SDRAMB2
*/
uint32_t HAL_GetFMCMemorySwappingConfig(void)
{
24000e04:	b480      	push	{r7}
24000e06:	af00      	add	r7, sp, #0
  return READ_BIT(FMC_Bank1_R->BTCR[0], FMC_BCR1_BMAP);
24000e08:	4b04      	ldr	r3, [pc, #16]	; (24000e1c <HAL_GetFMCMemorySwappingConfig+0x18>)
24000e0a:	681b      	ldr	r3, [r3, #0]
24000e0c:	f003 7340 	and.w	r3, r3, #50331648	; 0x3000000
}
24000e10:	4618      	mov	r0, r3
24000e12:	46bd      	mov	sp, r7
24000e14:	f85d 7b04 	ldr.w	r7, [sp], #4
24000e18:	4770      	bx	lr
24000e1a:	bf00      	nop
24000e1c:	52004000 	.word	0x52004000

24000e20 <HAL_EXTI_EdgeConfig>:
  *   @arg EXTI_RISING_EDGE : Configurable line, with Rising edge trigger detection
  *   @arg EXTI_FALLING_EDGE: Configurable line, with Falling edge trigger detection
  * @retval None
  */
void HAL_EXTI_EdgeConfig(uint32_t EXTI_Line , uint32_t EXTI_Edge )
{
24000e20:	b480      	push	{r7}
24000e22:	b083      	sub	sp, #12
24000e24:	af00      	add	r7, sp, #0
24000e26:	6078      	str	r0, [r7, #4]
24000e28:	6039      	str	r1, [r7, #0]
  /* Check the parameter */
  assert_param(IS_HAL_EXTI_CONFIG_LINE(EXTI_Line));
  assert_param(IS_EXTI_EDGE_LINE(EXTI_Edge));

  /* Clear Rising Falling edge configuration */
  CLEAR_BIT(*(__IO uint32_t *) (((uint32_t) &(EXTI->FTSR1)) + ((EXTI_Line >> 5 ) * 0x20UL)), (uint32_t)(1UL << (EXTI_Line & 0x1FUL)));
24000e2a:	687b      	ldr	r3, [r7, #4]
24000e2c:	095b      	lsrs	r3, r3, #5
24000e2e:	015a      	lsls	r2, r3, #5
24000e30:	4b2e      	ldr	r3, [pc, #184]	; (24000eec <HAL_EXTI_EdgeConfig+0xcc>)
24000e32:	4413      	add	r3, r2
24000e34:	6819      	ldr	r1, [r3, #0]
24000e36:	687b      	ldr	r3, [r7, #4]
24000e38:	f003 031f 	and.w	r3, r3, #31
24000e3c:	2201      	movs	r2, #1
24000e3e:	fa02 f303 	lsl.w	r3, r2, r3
24000e42:	43da      	mvns	r2, r3
24000e44:	687b      	ldr	r3, [r7, #4]
24000e46:	095b      	lsrs	r3, r3, #5
24000e48:	0158      	lsls	r0, r3, #5
24000e4a:	4b28      	ldr	r3, [pc, #160]	; (24000eec <HAL_EXTI_EdgeConfig+0xcc>)
24000e4c:	4403      	add	r3, r0
24000e4e:	4618      	mov	r0, r3
24000e50:	ea01 0302 	and.w	r3, r1, r2
24000e54:	6003      	str	r3, [r0, #0]
  CLEAR_BIT( *(__IO uint32_t *) (((uint32_t) &(EXTI->RTSR1)) + ((EXTI_Line >> 5 ) * 0x20UL)), (uint32_t)(1UL << (EXTI_Line & 0x1FUL)));
24000e56:	687b      	ldr	r3, [r7, #4]
24000e58:	095b      	lsrs	r3, r3, #5
24000e5a:	f103 7330 	add.w	r3, r3, #46137344	; 0x2c00000
24000e5e:	015b      	lsls	r3, r3, #5
24000e60:	681a      	ldr	r2, [r3, #0]
24000e62:	687b      	ldr	r3, [r7, #4]
24000e64:	f003 031f 	and.w	r3, r3, #31
24000e68:	2101      	movs	r1, #1
24000e6a:	fa01 f303 	lsl.w	r3, r1, r3
24000e6e:	43db      	mvns	r3, r3
24000e70:	6879      	ldr	r1, [r7, #4]
24000e72:	0949      	lsrs	r1, r1, #5
24000e74:	f101 7130 	add.w	r1, r1, #46137344	; 0x2c00000
24000e78:	0149      	lsls	r1, r1, #5
24000e7a:	4013      	ands	r3, r2
24000e7c:	600b      	str	r3, [r1, #0]

  if( (EXTI_Edge & EXTI_RISING_EDGE) == EXTI_RISING_EDGE)
24000e7e:	683b      	ldr	r3, [r7, #0]
24000e80:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
24000e84:	2b00      	cmp	r3, #0
24000e86:	d012      	beq.n	24000eae <HAL_EXTI_EdgeConfig+0x8e>
  {
   SET_BIT( *(__IO uint32_t *) (((uint32_t) &(EXTI->RTSR1)) + ((EXTI_Line >> 5 ) * 0x20UL)), (uint32_t)(1UL << (EXTI_Line & 0x1FUL)));
24000e88:	687b      	ldr	r3, [r7, #4]
24000e8a:	095b      	lsrs	r3, r3, #5
24000e8c:	f103 7330 	add.w	r3, r3, #46137344	; 0x2c00000
24000e90:	015b      	lsls	r3, r3, #5
24000e92:	681a      	ldr	r2, [r3, #0]
24000e94:	687b      	ldr	r3, [r7, #4]
24000e96:	f003 031f 	and.w	r3, r3, #31
24000e9a:	2101      	movs	r1, #1
24000e9c:	fa01 f303 	lsl.w	r3, r1, r3
24000ea0:	6879      	ldr	r1, [r7, #4]
24000ea2:	0949      	lsrs	r1, r1, #5
24000ea4:	f101 7130 	add.w	r1, r1, #46137344	; 0x2c00000
24000ea8:	0149      	lsls	r1, r1, #5
24000eaa:	4313      	orrs	r3, r2
24000eac:	600b      	str	r3, [r1, #0]
  }
  if( (EXTI_Edge & EXTI_FALLING_EDGE) == EXTI_FALLING_EDGE)
24000eae:	683b      	ldr	r3, [r7, #0]
24000eb0:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
24000eb4:	2b00      	cmp	r3, #0
24000eb6:	d013      	beq.n	24000ee0 <HAL_EXTI_EdgeConfig+0xc0>
  {
   SET_BIT(*(__IO uint32_t *) (((uint32_t) &(EXTI->FTSR1)) + ((EXTI_Line >> 5 ) * 0x20UL)), (uint32_t)(1UL << (EXTI_Line & 0x1FUL)));
24000eb8:	687b      	ldr	r3, [r7, #4]
24000eba:	095b      	lsrs	r3, r3, #5
24000ebc:	015a      	lsls	r2, r3, #5
24000ebe:	4b0b      	ldr	r3, [pc, #44]	; (24000eec <HAL_EXTI_EdgeConfig+0xcc>)
24000ec0:	4413      	add	r3, r2
24000ec2:	6819      	ldr	r1, [r3, #0]
24000ec4:	687b      	ldr	r3, [r7, #4]
24000ec6:	f003 031f 	and.w	r3, r3, #31
24000eca:	2201      	movs	r2, #1
24000ecc:	409a      	lsls	r2, r3
24000ece:	687b      	ldr	r3, [r7, #4]
24000ed0:	095b      	lsrs	r3, r3, #5
24000ed2:	0158      	lsls	r0, r3, #5
24000ed4:	4b05      	ldr	r3, [pc, #20]	; (24000eec <HAL_EXTI_EdgeConfig+0xcc>)
24000ed6:	4403      	add	r3, r0
24000ed8:	4618      	mov	r0, r3
24000eda:	ea41 0302 	orr.w	r3, r1, r2
24000ede:	6003      	str	r3, [r0, #0]
  }
}
24000ee0:	bf00      	nop
24000ee2:	370c      	adds	r7, #12
24000ee4:	46bd      	mov	sp, r7
24000ee6:	f85d 7b04 	ldr.w	r7, [sp], #4
24000eea:	4770      	bx	lr
24000eec:	58000004 	.word	0x58000004

24000ef0 <HAL_EXTI_GenerateSWInterrupt>:
  * @param   EXTI_Line: Specifies the EXTI LINE, it can be one of the following values,
  *          (EXTI_LINE0..EXTI_LINE21),EXTI_LINE49,EXTI_LINE51,EXTI_LINE82,EXTI_LINE84,EXTI_LINE85 and EXTI_LINE86.
  * @retval None
  */
void HAL_EXTI_GenerateSWInterrupt(uint32_t EXTI_Line)
{
24000ef0:	b480      	push	{r7}
24000ef2:	b083      	sub	sp, #12
24000ef4:	af00      	add	r7, sp, #0
24000ef6:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_HAL_EXTI_CONFIG_LINE(EXTI_Line));

  SET_BIT(*(__IO uint32_t *) (((uint32_t) &(EXTI->SWIER1)) + ((EXTI_Line >> 5 ) * 0x20UL)), (uint32_t)(1UL << (EXTI_Line & 0x1FUL)));
24000ef8:	687b      	ldr	r3, [r7, #4]
24000efa:	095b      	lsrs	r3, r3, #5
24000efc:	015a      	lsls	r2, r3, #5
24000efe:	4b0b      	ldr	r3, [pc, #44]	; (24000f2c <HAL_EXTI_GenerateSWInterrupt+0x3c>)
24000f00:	4413      	add	r3, r2
24000f02:	6819      	ldr	r1, [r3, #0]
24000f04:	687b      	ldr	r3, [r7, #4]
24000f06:	f003 031f 	and.w	r3, r3, #31
24000f0a:	2201      	movs	r2, #1
24000f0c:	409a      	lsls	r2, r3
24000f0e:	687b      	ldr	r3, [r7, #4]
24000f10:	095b      	lsrs	r3, r3, #5
24000f12:	0158      	lsls	r0, r3, #5
24000f14:	4b05      	ldr	r3, [pc, #20]	; (24000f2c <HAL_EXTI_GenerateSWInterrupt+0x3c>)
24000f16:	4403      	add	r3, r0
24000f18:	4618      	mov	r0, r3
24000f1a:	ea41 0302 	orr.w	r3, r1, r2
24000f1e:	6003      	str	r3, [r0, #0]
}
24000f20:	bf00      	nop
24000f22:	370c      	adds	r7, #12
24000f24:	46bd      	mov	sp, r7
24000f26:	f85d 7b04 	ldr.w	r7, [sp], #4
24000f2a:	4770      	bx	lr
24000f2c:	58000008 	.word	0x58000008

24000f30 <HAL_EXTI_D1_ClearFlag>:
  * @param   EXTI_Line: Specifies the EXTI LINE, it can be one of the following values,
  *         (EXTI_LINE0....EXTI_LINE87)excluding :line45, line81,line83 which are reserved
  * @retval None
  */
void HAL_EXTI_D1_ClearFlag(uint32_t EXTI_Line)
{
24000f30:	b480      	push	{r7}
24000f32:	b083      	sub	sp, #12
24000f34:	af00      	add	r7, sp, #0
24000f36:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
 assert_param(IS_EXTI_D1_LINE(EXTI_Line));
 WRITE_REG(*(__IO uint32_t *) (((uint32_t) &(EXTI_D1->PR1)) + ((EXTI_Line >> 5 ) * 0x10UL)), (uint32_t)(1UL << (EXTI_Line & 0x1FUL)));
24000f38:	687b      	ldr	r3, [r7, #4]
24000f3a:	f003 021f 	and.w	r2, r3, #31
24000f3e:	687b      	ldr	r3, [r7, #4]
24000f40:	095b      	lsrs	r3, r3, #5
24000f42:	0119      	lsls	r1, r3, #4
24000f44:	4b05      	ldr	r3, [pc, #20]	; (24000f5c <HAL_EXTI_D1_ClearFlag+0x2c>)
24000f46:	440b      	add	r3, r1
24000f48:	4619      	mov	r1, r3
24000f4a:	2301      	movs	r3, #1
24000f4c:	4093      	lsls	r3, r2
24000f4e:	600b      	str	r3, [r1, #0]

}
24000f50:	bf00      	nop
24000f52:	370c      	adds	r7, #12
24000f54:	46bd      	mov	sp, r7
24000f56:	f85d 7b04 	ldr.w	r7, [sp], #4
24000f5a:	4770      	bx	lr
24000f5c:	58000088 	.word	0x58000088

24000f60 <HAL_EXTI_D1_EventInputConfig>:
  * @param   EXTI_LineCmd controls (Enable/Disable) the EXTI line.

  * @retval None
  */
void HAL_EXTI_D1_EventInputConfig(uint32_t EXTI_Line , uint32_t EXTI_Mode,  uint32_t EXTI_LineCmd )
{
24000f60:	b480      	push	{r7}
24000f62:	b085      	sub	sp, #20
24000f64:	af00      	add	r7, sp, #0
24000f66:	60f8      	str	r0, [r7, #12]
24000f68:	60b9      	str	r1, [r7, #8]
24000f6a:	607a      	str	r2, [r7, #4]
  /* Check the parameter */
  assert_param(IS_EXTI_D1_LINE(EXTI_Line));
  assert_param(IS_EXTI_MODE_LINE(EXTI_Mode));

  if( (EXTI_Mode & EXTI_MODE_IT) == EXTI_MODE_IT)
24000f6c:	68bb      	ldr	r3, [r7, #8]
24000f6e:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
24000f72:	2b00      	cmp	r3, #0
24000f74:	d02d      	beq.n	24000fd2 <HAL_EXTI_D1_EventInputConfig+0x72>
  {
     if( EXTI_LineCmd == 0UL)
24000f76:	687b      	ldr	r3, [r7, #4]
24000f78:	2b00      	cmp	r3, #0
24000f7a:	d116      	bne.n	24000faa <HAL_EXTI_D1_EventInputConfig+0x4a>
     {
       /* Clear EXTI line configuration */
        CLEAR_BIT(*(__IO uint32_t *) (((uint32_t) &(EXTI_D1->IMR1)) + ((EXTI_Line >> 5 ) * 0x10UL)),(uint32_t)(1UL << (EXTI_Line & 0x1FUL)) );
24000f7c:	68fb      	ldr	r3, [r7, #12]
24000f7e:	095a      	lsrs	r2, r3, #5
24000f80:	4b30      	ldr	r3, [pc, #192]	; (24001044 <HAL_EXTI_D1_EventInputConfig+0xe4>)
24000f82:	4413      	add	r3, r2
24000f84:	011b      	lsls	r3, r3, #4
24000f86:	6819      	ldr	r1, [r3, #0]
24000f88:	68fb      	ldr	r3, [r7, #12]
24000f8a:	f003 031f 	and.w	r3, r3, #31
24000f8e:	2201      	movs	r2, #1
24000f90:	fa02 f303 	lsl.w	r3, r2, r3
24000f94:	43da      	mvns	r2, r3
24000f96:	68fb      	ldr	r3, [r7, #12]
24000f98:	0958      	lsrs	r0, r3, #5
24000f9a:	4b2a      	ldr	r3, [pc, #168]	; (24001044 <HAL_EXTI_D1_EventInputConfig+0xe4>)
24000f9c:	4403      	add	r3, r0
24000f9e:	011b      	lsls	r3, r3, #4
24000fa0:	4618      	mov	r0, r3
24000fa2:	ea01 0302 	and.w	r3, r1, r2
24000fa6:	6003      	str	r3, [r0, #0]
24000fa8:	e013      	b.n	24000fd2 <HAL_EXTI_D1_EventInputConfig+0x72>
     }
     else
     {
        SET_BIT(*(__IO uint32_t *) (((uint32_t) &(EXTI_D1->IMR1)) + ((EXTI_Line >> 5 ) * 0x10UL)), (uint32_t)(1UL << (EXTI_Line & 0x1FUL)));
24000faa:	68fb      	ldr	r3, [r7, #12]
24000fac:	095a      	lsrs	r2, r3, #5
24000fae:	4b25      	ldr	r3, [pc, #148]	; (24001044 <HAL_EXTI_D1_EventInputConfig+0xe4>)
24000fb0:	4413      	add	r3, r2
24000fb2:	011b      	lsls	r3, r3, #4
24000fb4:	6819      	ldr	r1, [r3, #0]
24000fb6:	68fb      	ldr	r3, [r7, #12]
24000fb8:	f003 031f 	and.w	r3, r3, #31
24000fbc:	2201      	movs	r2, #1
24000fbe:	409a      	lsls	r2, r3
24000fc0:	68fb      	ldr	r3, [r7, #12]
24000fc2:	0958      	lsrs	r0, r3, #5
24000fc4:	4b1f      	ldr	r3, [pc, #124]	; (24001044 <HAL_EXTI_D1_EventInputConfig+0xe4>)
24000fc6:	4403      	add	r3, r0
24000fc8:	011b      	lsls	r3, r3, #4
24000fca:	4618      	mov	r0, r3
24000fcc:	ea41 0302 	orr.w	r3, r1, r2
24000fd0:	6003      	str	r3, [r0, #0]
     }
  }

  if( (EXTI_Mode & EXTI_MODE_EVT) == EXTI_MODE_EVT)
24000fd2:	68bb      	ldr	r3, [r7, #8]
24000fd4:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
24000fd8:	2b00      	cmp	r3, #0
24000fda:	d02d      	beq.n	24001038 <HAL_EXTI_D1_EventInputConfig+0xd8>
  {
    if( EXTI_LineCmd == 0UL)
24000fdc:	687b      	ldr	r3, [r7, #4]
24000fde:	2b00      	cmp	r3, #0
24000fe0:	d116      	bne.n	24001010 <HAL_EXTI_D1_EventInputConfig+0xb0>
    {
      /* Clear EXTI line configuration */
      CLEAR_BIT(  *(__IO uint32_t *) (((uint32_t) &(EXTI_D1->EMR1)) + ((EXTI_Line >> 5 ) * 0x10UL)), (uint32_t)(1UL << (EXTI_Line & 0x1FUL)));
24000fe2:	68fb      	ldr	r3, [r7, #12]
24000fe4:	095b      	lsrs	r3, r3, #5
24000fe6:	011a      	lsls	r2, r3, #4
24000fe8:	4b17      	ldr	r3, [pc, #92]	; (24001048 <HAL_EXTI_D1_EventInputConfig+0xe8>)
24000fea:	4413      	add	r3, r2
24000fec:	6819      	ldr	r1, [r3, #0]
24000fee:	68fb      	ldr	r3, [r7, #12]
24000ff0:	f003 031f 	and.w	r3, r3, #31
24000ff4:	2201      	movs	r2, #1
24000ff6:	fa02 f303 	lsl.w	r3, r2, r3
24000ffa:	43da      	mvns	r2, r3
24000ffc:	68fb      	ldr	r3, [r7, #12]
24000ffe:	095b      	lsrs	r3, r3, #5
24001000:	0118      	lsls	r0, r3, #4
24001002:	4b11      	ldr	r3, [pc, #68]	; (24001048 <HAL_EXTI_D1_EventInputConfig+0xe8>)
24001004:	4403      	add	r3, r0
24001006:	4618      	mov	r0, r3
24001008:	ea01 0302 	and.w	r3, r1, r2
2400100c:	6003      	str	r3, [r0, #0]
    else
    {
      SET_BIT(  *(__IO uint32_t *) (((uint32_t) &(EXTI_D1->EMR1)) + ((EXTI_Line >> 5 ) * 0x10UL)), (uint32_t)(1UL << (EXTI_Line & 0x1FUL)));
    }
  }
}
2400100e:	e013      	b.n	24001038 <HAL_EXTI_D1_EventInputConfig+0xd8>
      SET_BIT(  *(__IO uint32_t *) (((uint32_t) &(EXTI_D1->EMR1)) + ((EXTI_Line >> 5 ) * 0x10UL)), (uint32_t)(1UL << (EXTI_Line & 0x1FUL)));
24001010:	68fb      	ldr	r3, [r7, #12]
24001012:	095b      	lsrs	r3, r3, #5
24001014:	011a      	lsls	r2, r3, #4
24001016:	4b0c      	ldr	r3, [pc, #48]	; (24001048 <HAL_EXTI_D1_EventInputConfig+0xe8>)
24001018:	4413      	add	r3, r2
2400101a:	6819      	ldr	r1, [r3, #0]
2400101c:	68fb      	ldr	r3, [r7, #12]
2400101e:	f003 031f 	and.w	r3, r3, #31
24001022:	2201      	movs	r2, #1
24001024:	409a      	lsls	r2, r3
24001026:	68fb      	ldr	r3, [r7, #12]
24001028:	095b      	lsrs	r3, r3, #5
2400102a:	0118      	lsls	r0, r3, #4
2400102c:	4b06      	ldr	r3, [pc, #24]	; (24001048 <HAL_EXTI_D1_EventInputConfig+0xe8>)
2400102e:	4403      	add	r3, r0
24001030:	4618      	mov	r0, r3
24001032:	ea41 0302 	orr.w	r3, r1, r2
24001036:	6003      	str	r3, [r0, #0]
}
24001038:	bf00      	nop
2400103a:	3714      	adds	r7, #20
2400103c:	46bd      	mov	sp, r7
2400103e:	f85d 7b04 	ldr.w	r7, [sp], #4
24001042:	4770      	bx	lr
24001044:	05800008 	.word	0x05800008
24001048:	58000084 	.word	0x58000084

2400104c <HAL_EXTI_D3_EventInputConfig>:
  *   @arg LPTIM4_OUT_CLEAR : LPTIM4 out selected as D3 domain pendclear source
  *   @arg LPTIM5_OUT_CLEAR : LPTIM5 out selected as D3 domain pendclear source
  * @retval None
  */
void HAL_EXTI_D3_EventInputConfig(uint32_t EXTI_Line, uint32_t EXTI_LineCmd , uint32_t EXTI_ClearSrc  )
{
2400104c:	b480      	push	{r7}
2400104e:	b087      	sub	sp, #28
24001050:	af00      	add	r7, sp, #0
24001052:	60f8      	str	r0, [r7, #12]
24001054:	60b9      	str	r1, [r7, #8]
24001056:	607a      	str	r2, [r7, #4]

  /* Check the parameter */
  assert_param(IS_EXTI_D3_LINE(EXTI_Line));
  assert_param(IS_EXTI_D3_CLEAR(EXTI_ClearSrc));

  if( EXTI_LineCmd == 0UL)
24001058:	68bb      	ldr	r3, [r7, #8]
2400105a:	2b00      	cmp	r3, #0
2400105c:	d116      	bne.n	2400108c <HAL_EXTI_D3_EventInputConfig+0x40>
  {
    /* Clear EXTI line configuration */
    CLEAR_BIT(*(__IO uint32_t *) (((uint32_t) &(EXTI->D3PMR1)) + ((EXTI_Line >> 5 ) * 0x20UL)),(uint32_t)(1UL << (EXTI_Line & 0x1FUL)) );
2400105e:	68fb      	ldr	r3, [r7, #12]
24001060:	095b      	lsrs	r3, r3, #5
24001062:	015a      	lsls	r2, r3, #5
24001064:	4b2a      	ldr	r3, [pc, #168]	; (24001110 <HAL_EXTI_D3_EventInputConfig+0xc4>)
24001066:	4413      	add	r3, r2
24001068:	6819      	ldr	r1, [r3, #0]
2400106a:	68fb      	ldr	r3, [r7, #12]
2400106c:	f003 031f 	and.w	r3, r3, #31
24001070:	2201      	movs	r2, #1
24001072:	fa02 f303 	lsl.w	r3, r2, r3
24001076:	43da      	mvns	r2, r3
24001078:	68fb      	ldr	r3, [r7, #12]
2400107a:	095b      	lsrs	r3, r3, #5
2400107c:	0158      	lsls	r0, r3, #5
2400107e:	4b24      	ldr	r3, [pc, #144]	; (24001110 <HAL_EXTI_D3_EventInputConfig+0xc4>)
24001080:	4403      	add	r3, r0
24001082:	4618      	mov	r0, r3
24001084:	ea01 0302 	and.w	r3, r1, r2
24001088:	6003      	str	r3, [r0, #0]
2400108a:	e013      	b.n	240010b4 <HAL_EXTI_D3_EventInputConfig+0x68>
  }
  else
  {
    SET_BIT(*(__IO uint32_t *) (((uint32_t) &(EXTI->D3PMR1)) +((EXTI_Line >> 5 ) * 0x20UL)), (uint32_t)(1UL << (EXTI_Line & 0x1FUL)));
2400108c:	68fb      	ldr	r3, [r7, #12]
2400108e:	095b      	lsrs	r3, r3, #5
24001090:	015a      	lsls	r2, r3, #5
24001092:	4b1f      	ldr	r3, [pc, #124]	; (24001110 <HAL_EXTI_D3_EventInputConfig+0xc4>)
24001094:	4413      	add	r3, r2
24001096:	6819      	ldr	r1, [r3, #0]
24001098:	68fb      	ldr	r3, [r7, #12]
2400109a:	f003 031f 	and.w	r3, r3, #31
2400109e:	2201      	movs	r2, #1
240010a0:	409a      	lsls	r2, r3
240010a2:	68fb      	ldr	r3, [r7, #12]
240010a4:	095b      	lsrs	r3, r3, #5
240010a6:	0158      	lsls	r0, r3, #5
240010a8:	4b19      	ldr	r3, [pc, #100]	; (24001110 <HAL_EXTI_D3_EventInputConfig+0xc4>)
240010aa:	4403      	add	r3, r0
240010ac:	4618      	mov	r0, r3
240010ae:	ea41 0302 	orr.w	r3, r1, r2
240010b2:	6003      	str	r3, [r0, #0]
  }

  if(((EXTI_Line>>4)%2UL) == 0UL)
240010b4:	68fb      	ldr	r3, [r7, #12]
240010b6:	091b      	lsrs	r3, r3, #4
240010b8:	f003 0301 	and.w	r3, r3, #1
240010bc:	2b00      	cmp	r3, #0
240010be:	d106      	bne.n	240010ce <HAL_EXTI_D3_EventInputConfig+0x82>
  {
    pRegv = (__IO uint32_t *) (((uint32_t) &(EXTI->D3PCR1L)) + ((EXTI_Line >> 5 ) * 0x20UL));
240010c0:	68fb      	ldr	r3, [r7, #12]
240010c2:	095b      	lsrs	r3, r3, #5
240010c4:	015a      	lsls	r2, r3, #5
240010c6:	4b13      	ldr	r3, [pc, #76]	; (24001114 <HAL_EXTI_D3_EventInputConfig+0xc8>)
240010c8:	4413      	add	r3, r2
240010ca:	617b      	str	r3, [r7, #20]
240010cc:	e005      	b.n	240010da <HAL_EXTI_D3_EventInputConfig+0x8e>
  }
  else
  {
    pRegv = (__IO uint32_t *) (((uint32_t) &(EXTI->D3PCR1H)) + ((EXTI_Line >> 5 ) * 0x20UL));
240010ce:	68fb      	ldr	r3, [r7, #12]
240010d0:	095b      	lsrs	r3, r3, #5
240010d2:	015a      	lsls	r2, r3, #5
240010d4:	4b10      	ldr	r3, [pc, #64]	; (24001118 <HAL_EXTI_D3_EventInputConfig+0xcc>)
240010d6:	4413      	add	r3, r2
240010d8:	617b      	str	r3, [r7, #20]
  }
  MODIFY_REG(*pRegv, (uint32_t)(3UL << ((EXTI_Line*2UL) & 0x1FUL)), (uint32_t)(EXTI_ClearSrc << ((EXTI_Line*2UL) & 0x1FUL)));
240010da:	697b      	ldr	r3, [r7, #20]
240010dc:	681a      	ldr	r2, [r3, #0]
240010de:	68fb      	ldr	r3, [r7, #12]
240010e0:	005b      	lsls	r3, r3, #1
240010e2:	f003 031e 	and.w	r3, r3, #30
240010e6:	2103      	movs	r1, #3
240010e8:	fa01 f303 	lsl.w	r3, r1, r3
240010ec:	43db      	mvns	r3, r3
240010ee:	401a      	ands	r2, r3
240010f0:	68fb      	ldr	r3, [r7, #12]
240010f2:	005b      	lsls	r3, r3, #1
240010f4:	f003 031e 	and.w	r3, r3, #30
240010f8:	6879      	ldr	r1, [r7, #4]
240010fa:	fa01 f303 	lsl.w	r3, r1, r3
240010fe:	431a      	orrs	r2, r3
24001100:	697b      	ldr	r3, [r7, #20]
24001102:	601a      	str	r2, [r3, #0]

}
24001104:	bf00      	nop
24001106:	371c      	adds	r7, #28
24001108:	46bd      	mov	sp, r7
2400110a:	f85d 7b04 	ldr.w	r7, [sp], #4
2400110e:	4770      	bx	lr
24001110:	5800000c 	.word	0x5800000c
24001114:	58000010 	.word	0x58000010
24001118:	58000014 	.word	0x58000014

2400111c <__NVIC_SetPriorityGrouping>:
           In case of a conflict between priority grouping and available
           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
  \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
2400111c:	b480      	push	{r7}
2400111e:	b085      	sub	sp, #20
24001120:	af00      	add	r7, sp, #0
24001122:	6078      	str	r0, [r7, #4]
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
24001124:	687b      	ldr	r3, [r7, #4]
24001126:	f003 0307 	and.w	r3, r3, #7
2400112a:	60fb      	str	r3, [r7, #12]

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
2400112c:	4b0b      	ldr	r3, [pc, #44]	; (2400115c <__NVIC_SetPriorityGrouping+0x40>)
2400112e:	68db      	ldr	r3, [r3, #12]
24001130:	60bb      	str	r3, [r7, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
24001132:	68ba      	ldr	r2, [r7, #8]
24001134:	f64f 03ff 	movw	r3, #63743	; 0xf8ff
24001138:	4013      	ands	r3, r2
2400113a:	60bb      	str	r3, [r7, #8]
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
2400113c:	68fb      	ldr	r3, [r7, #12]
2400113e:	021a      	lsls	r2, r3, #8
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
24001140:	68bb      	ldr	r3, [r7, #8]
24001142:	431a      	orrs	r2, r3
  reg_value  =  (reg_value                                   |
24001144:	4b06      	ldr	r3, [pc, #24]	; (24001160 <__NVIC_SetPriorityGrouping+0x44>)
24001146:	4313      	orrs	r3, r2
24001148:	60bb      	str	r3, [r7, #8]
  SCB->AIRCR =  reg_value;
2400114a:	4a04      	ldr	r2, [pc, #16]	; (2400115c <__NVIC_SetPriorityGrouping+0x40>)
2400114c:	68bb      	ldr	r3, [r7, #8]
2400114e:	60d3      	str	r3, [r2, #12]
}
24001150:	bf00      	nop
24001152:	3714      	adds	r7, #20
24001154:	46bd      	mov	sp, r7
24001156:	f85d 7b04 	ldr.w	r7, [sp], #4
2400115a:	4770      	bx	lr
2400115c:	e000ed00 	.word	0xe000ed00
24001160:	05fa0000 	.word	0x05fa0000

24001164 <__NVIC_GetPriorityGrouping>:
  \brief   Get Priority Grouping
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
24001164:	b480      	push	{r7}
24001166:	af00      	add	r7, sp, #0
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
24001168:	4b04      	ldr	r3, [pc, #16]	; (2400117c <__NVIC_GetPriorityGrouping+0x18>)
2400116a:	68db      	ldr	r3, [r3, #12]
2400116c:	0a1b      	lsrs	r3, r3, #8
2400116e:	f003 0307 	and.w	r3, r3, #7
}
24001172:	4618      	mov	r0, r3
24001174:	46bd      	mov	sp, r7
24001176:	f85d 7b04 	ldr.w	r7, [sp], #4
2400117a:	4770      	bx	lr
2400117c:	e000ed00 	.word	0xe000ed00

24001180 <__NVIC_EnableIRQ>:
  \details Enables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
24001180:	b480      	push	{r7}
24001182:	b083      	sub	sp, #12
24001184:	af00      	add	r7, sp, #0
24001186:	4603      	mov	r3, r0
24001188:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
2400118a:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
2400118e:	2b00      	cmp	r3, #0
24001190:	db0b      	blt.n	240011aa <__NVIC_EnableIRQ+0x2a>
  {
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
24001192:	88fb      	ldrh	r3, [r7, #6]
24001194:	f003 021f 	and.w	r2, r3, #31
24001198:	4907      	ldr	r1, [pc, #28]	; (240011b8 <__NVIC_EnableIRQ+0x38>)
2400119a:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
2400119e:	095b      	lsrs	r3, r3, #5
240011a0:	2001      	movs	r0, #1
240011a2:	fa00 f202 	lsl.w	r2, r0, r2
240011a6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  }
}
240011aa:	bf00      	nop
240011ac:	370c      	adds	r7, #12
240011ae:	46bd      	mov	sp, r7
240011b0:	f85d 7b04 	ldr.w	r7, [sp], #4
240011b4:	4770      	bx	lr
240011b6:	bf00      	nop
240011b8:	e000e100 	.word	0xe000e100

240011bc <__NVIC_DisableIRQ>:
  \details Disables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
{
240011bc:	b480      	push	{r7}
240011be:	b083      	sub	sp, #12
240011c0:	af00      	add	r7, sp, #0
240011c2:	4603      	mov	r3, r0
240011c4:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
240011c6:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
240011ca:	2b00      	cmp	r3, #0
240011cc:	db10      	blt.n	240011f0 <__NVIC_DisableIRQ+0x34>
  {
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
240011ce:	88fb      	ldrh	r3, [r7, #6]
240011d0:	f003 021f 	and.w	r2, r3, #31
240011d4:	4909      	ldr	r1, [pc, #36]	; (240011fc <__NVIC_DisableIRQ+0x40>)
240011d6:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
240011da:	095b      	lsrs	r3, r3, #5
240011dc:	2001      	movs	r0, #1
240011de:	fa00 f202 	lsl.w	r2, r0, r2
240011e2:	3320      	adds	r3, #32
240011e4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
240011e8:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
240011ec:	f3bf 8f6f 	isb	sy
    __DSB();
    __ISB();
  }
}
240011f0:	bf00      	nop
240011f2:	370c      	adds	r7, #12
240011f4:	46bd      	mov	sp, r7
240011f6:	f85d 7b04 	ldr.w	r7, [sp], #4
240011fa:	4770      	bx	lr
240011fc:	e000e100 	.word	0xe000e100

24001200 <__NVIC_GetPendingIRQ>:
  \return             0  Interrupt status is not pending.
  \return             1  Interrupt status is pending.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE uint32_t __NVIC_GetPendingIRQ(IRQn_Type IRQn)
{
24001200:	b480      	push	{r7}
24001202:	b083      	sub	sp, #12
24001204:	af00      	add	r7, sp, #0
24001206:	4603      	mov	r3, r0
24001208:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
2400120a:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
2400120e:	2b00      	cmp	r3, #0
24001210:	db0e      	blt.n	24001230 <__NVIC_GetPendingIRQ+0x30>
  {
    return((uint32_t)(((NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
24001212:	4a0b      	ldr	r2, [pc, #44]	; (24001240 <__NVIC_GetPendingIRQ+0x40>)
24001214:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
24001218:	095b      	lsrs	r3, r3, #5
2400121a:	3340      	adds	r3, #64	; 0x40
2400121c:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
24001220:	88fb      	ldrh	r3, [r7, #6]
24001222:	f003 031f 	and.w	r3, r3, #31
24001226:	fa22 f303 	lsr.w	r3, r2, r3
2400122a:	f003 0301 	and.w	r3, r3, #1
2400122e:	e000      	b.n	24001232 <__NVIC_GetPendingIRQ+0x32>
  }
  else
  {
    return(0U);
24001230:	2300      	movs	r3, #0
  }
}
24001232:	4618      	mov	r0, r3
24001234:	370c      	adds	r7, #12
24001236:	46bd      	mov	sp, r7
24001238:	f85d 7b04 	ldr.w	r7, [sp], #4
2400123c:	4770      	bx	lr
2400123e:	bf00      	nop
24001240:	e000e100 	.word	0xe000e100

24001244 <__NVIC_SetPendingIRQ>:
  \details Sets the pending bit of a device specific interrupt in the NVIC pending register.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_SetPendingIRQ(IRQn_Type IRQn)
{
24001244:	b480      	push	{r7}
24001246:	b083      	sub	sp, #12
24001248:	af00      	add	r7, sp, #0
2400124a:	4603      	mov	r3, r0
2400124c:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
2400124e:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
24001252:	2b00      	cmp	r3, #0
24001254:	db0c      	blt.n	24001270 <__NVIC_SetPendingIRQ+0x2c>
  {
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
24001256:	88fb      	ldrh	r3, [r7, #6]
24001258:	f003 021f 	and.w	r2, r3, #31
2400125c:	4907      	ldr	r1, [pc, #28]	; (2400127c <__NVIC_SetPendingIRQ+0x38>)
2400125e:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
24001262:	095b      	lsrs	r3, r3, #5
24001264:	2001      	movs	r0, #1
24001266:	fa00 f202 	lsl.w	r2, r0, r2
2400126a:	3340      	adds	r3, #64	; 0x40
2400126c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  }
}
24001270:	bf00      	nop
24001272:	370c      	adds	r7, #12
24001274:	46bd      	mov	sp, r7
24001276:	f85d 7b04 	ldr.w	r7, [sp], #4
2400127a:	4770      	bx	lr
2400127c:	e000e100 	.word	0xe000e100

24001280 <__NVIC_ClearPendingIRQ>:
  \details Clears the pending bit of a device specific interrupt in the NVIC pending register.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
24001280:	b480      	push	{r7}
24001282:	b083      	sub	sp, #12
24001284:	af00      	add	r7, sp, #0
24001286:	4603      	mov	r3, r0
24001288:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
2400128a:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
2400128e:	2b00      	cmp	r3, #0
24001290:	db0c      	blt.n	240012ac <__NVIC_ClearPendingIRQ+0x2c>
  {
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
24001292:	88fb      	ldrh	r3, [r7, #6]
24001294:	f003 021f 	and.w	r2, r3, #31
24001298:	4907      	ldr	r1, [pc, #28]	; (240012b8 <__NVIC_ClearPendingIRQ+0x38>)
2400129a:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
2400129e:	095b      	lsrs	r3, r3, #5
240012a0:	2001      	movs	r0, #1
240012a2:	fa00 f202 	lsl.w	r2, r0, r2
240012a6:	3360      	adds	r3, #96	; 0x60
240012a8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  }
}
240012ac:	bf00      	nop
240012ae:	370c      	adds	r7, #12
240012b0:	46bd      	mov	sp, r7
240012b2:	f85d 7b04 	ldr.w	r7, [sp], #4
240012b6:	4770      	bx	lr
240012b8:	e000e100 	.word	0xe000e100

240012bc <__NVIC_GetActive>:
  \return             0  Interrupt status is not active.
  \return             1  Interrupt status is active.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE uint32_t __NVIC_GetActive(IRQn_Type IRQn)
{
240012bc:	b480      	push	{r7}
240012be:	b083      	sub	sp, #12
240012c0:	af00      	add	r7, sp, #0
240012c2:	4603      	mov	r3, r0
240012c4:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
240012c6:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
240012ca:	2b00      	cmp	r3, #0
240012cc:	db0e      	blt.n	240012ec <__NVIC_GetActive+0x30>
  {
    return((uint32_t)(((NVIC->IABR[(((uint32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
240012ce:	4a0b      	ldr	r2, [pc, #44]	; (240012fc <__NVIC_GetActive+0x40>)
240012d0:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
240012d4:	095b      	lsrs	r3, r3, #5
240012d6:	3380      	adds	r3, #128	; 0x80
240012d8:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
240012dc:	88fb      	ldrh	r3, [r7, #6]
240012de:	f003 031f 	and.w	r3, r3, #31
240012e2:	fa22 f303 	lsr.w	r3, r2, r3
240012e6:	f003 0301 	and.w	r3, r3, #1
240012ea:	e000      	b.n	240012ee <__NVIC_GetActive+0x32>
  }
  else
  {
    return(0U);
240012ec:	2300      	movs	r3, #0
  }
}
240012ee:	4618      	mov	r0, r3
240012f0:	370c      	adds	r7, #12
240012f2:	46bd      	mov	sp, r7
240012f4:	f85d 7b04 	ldr.w	r7, [sp], #4
240012f8:	4770      	bx	lr
240012fa:	bf00      	nop
240012fc:	e000e100 	.word	0xe000e100

24001300 <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
24001300:	b480      	push	{r7}
24001302:	b083      	sub	sp, #12
24001304:	af00      	add	r7, sp, #0
24001306:	4603      	mov	r3, r0
24001308:	6039      	str	r1, [r7, #0]
2400130a:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
2400130c:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
24001310:	2b00      	cmp	r3, #0
24001312:	db0a      	blt.n	2400132a <__NVIC_SetPriority+0x2a>
  {
    NVIC->IP[((uint32_t)IRQn)]                = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
24001314:	683b      	ldr	r3, [r7, #0]
24001316:	b2da      	uxtb	r2, r3
24001318:	490c      	ldr	r1, [pc, #48]	; (2400134c <__NVIC_SetPriority+0x4c>)
2400131a:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
2400131e:	0112      	lsls	r2, r2, #4
24001320:	b2d2      	uxtb	r2, r2
24001322:	440b      	add	r3, r1
24001324:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
  }
  else
  {
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
}
24001328:	e00a      	b.n	24001340 <__NVIC_SetPriority+0x40>
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
2400132a:	683b      	ldr	r3, [r7, #0]
2400132c:	b2da      	uxtb	r2, r3
2400132e:	4908      	ldr	r1, [pc, #32]	; (24001350 <__NVIC_SetPriority+0x50>)
24001330:	88fb      	ldrh	r3, [r7, #6]
24001332:	f003 030f 	and.w	r3, r3, #15
24001336:	3b04      	subs	r3, #4
24001338:	0112      	lsls	r2, r2, #4
2400133a:	b2d2      	uxtb	r2, r2
2400133c:	440b      	add	r3, r1
2400133e:	761a      	strb	r2, [r3, #24]
}
24001340:	bf00      	nop
24001342:	370c      	adds	r7, #12
24001344:	46bd      	mov	sp, r7
24001346:	f85d 7b04 	ldr.w	r7, [sp], #4
2400134a:	4770      	bx	lr
2400134c:	e000e100 	.word	0xe000e100
24001350:	e000ed00 	.word	0xe000ed00

24001354 <__NVIC_GetPriority>:
  \param [in]   IRQn  Interrupt number.
  \return             Interrupt Priority.
                      Value is aligned automatically to the implemented priority bits of the microcontroller.
 */
__STATIC_INLINE uint32_t __NVIC_GetPriority(IRQn_Type IRQn)
{
24001354:	b480      	push	{r7}
24001356:	b083      	sub	sp, #12
24001358:	af00      	add	r7, sp, #0
2400135a:	4603      	mov	r3, r0
2400135c:	80fb      	strh	r3, [r7, #6]

  if ((int32_t)(IRQn) >= 0)
2400135e:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
24001362:	2b00      	cmp	r3, #0
24001364:	db09      	blt.n	2400137a <__NVIC_GetPriority+0x26>
  {
    return(((uint32_t)NVIC->IP[((uint32_t)IRQn)]                >> (8U - __NVIC_PRIO_BITS)));
24001366:	4a0d      	ldr	r2, [pc, #52]	; (2400139c <__NVIC_GetPriority+0x48>)
24001368:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
2400136c:	4413      	add	r3, r2
2400136e:	f893 3300 	ldrb.w	r3, [r3, #768]	; 0x300
24001372:	b2db      	uxtb	r3, r3
24001374:	091b      	lsrs	r3, r3, #4
24001376:	b2db      	uxtb	r3, r3
24001378:	e009      	b.n	2400138e <__NVIC_GetPriority+0x3a>
  }
  else
  {
    return(((uint32_t)SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] >> (8U - __NVIC_PRIO_BITS)));
2400137a:	4a09      	ldr	r2, [pc, #36]	; (240013a0 <__NVIC_GetPriority+0x4c>)
2400137c:	88fb      	ldrh	r3, [r7, #6]
2400137e:	f003 030f 	and.w	r3, r3, #15
24001382:	3b04      	subs	r3, #4
24001384:	4413      	add	r3, r2
24001386:	7e1b      	ldrb	r3, [r3, #24]
24001388:	b2db      	uxtb	r3, r3
2400138a:	091b      	lsrs	r3, r3, #4
2400138c:	b2db      	uxtb	r3, r3
  }
}
2400138e:	4618      	mov	r0, r3
24001390:	370c      	adds	r7, #12
24001392:	46bd      	mov	sp, r7
24001394:	f85d 7b04 	ldr.w	r7, [sp], #4
24001398:	4770      	bx	lr
2400139a:	bf00      	nop
2400139c:	e000e100 	.word	0xe000e100
240013a0:	e000ed00 	.word	0xe000ed00

240013a4 <NVIC_EncodePriority>:
  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
  \param [in]       SubPriority  Subpriority value (starting from 0).
  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 */
__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
240013a4:	b480      	push	{r7}
240013a6:	b089      	sub	sp, #36	; 0x24
240013a8:	af00      	add	r7, sp, #0
240013aa:	60f8      	str	r0, [r7, #12]
240013ac:	60b9      	str	r1, [r7, #8]
240013ae:	607a      	str	r2, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
240013b0:	68fb      	ldr	r3, [r7, #12]
240013b2:	f003 0307 	and.w	r3, r3, #7
240013b6:	61fb      	str	r3, [r7, #28]
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
240013b8:	69fb      	ldr	r3, [r7, #28]
240013ba:	f1c3 0307 	rsb	r3, r3, #7
240013be:	2b04      	cmp	r3, #4
240013c0:	bf28      	it	cs
240013c2:	2304      	movcs	r3, #4
240013c4:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
240013c6:	69fb      	ldr	r3, [r7, #28]
240013c8:	3304      	adds	r3, #4
240013ca:	2b06      	cmp	r3, #6
240013cc:	d902      	bls.n	240013d4 <NVIC_EncodePriority+0x30>
240013ce:	69fb      	ldr	r3, [r7, #28]
240013d0:	3b03      	subs	r3, #3
240013d2:	e000      	b.n	240013d6 <NVIC_EncodePriority+0x32>
240013d4:	2300      	movs	r3, #0
240013d6:	617b      	str	r3, [r7, #20]

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
240013d8:	f04f 32ff 	mov.w	r2, #4294967295
240013dc:	69bb      	ldr	r3, [r7, #24]
240013de:	fa02 f303 	lsl.w	r3, r2, r3
240013e2:	43da      	mvns	r2, r3
240013e4:	68bb      	ldr	r3, [r7, #8]
240013e6:	401a      	ands	r2, r3
240013e8:	697b      	ldr	r3, [r7, #20]
240013ea:	409a      	lsls	r2, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
240013ec:	f04f 31ff 	mov.w	r1, #4294967295
240013f0:	697b      	ldr	r3, [r7, #20]
240013f2:	fa01 f303 	lsl.w	r3, r1, r3
240013f6:	43d9      	mvns	r1, r3
240013f8:	687b      	ldr	r3, [r7, #4]
240013fa:	400b      	ands	r3, r1
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
240013fc:	4313      	orrs	r3, r2
         );
}
240013fe:	4618      	mov	r0, r3
24001400:	3724      	adds	r7, #36	; 0x24
24001402:	46bd      	mov	sp, r7
24001404:	f85d 7b04 	ldr.w	r7, [sp], #4
24001408:	4770      	bx	lr

2400140a <NVIC_DecodePriority>:
  \param [in]     PriorityGroup  Used priority group.
  \param [out] pPreemptPriority  Preemptive priority value (starting from 0).
  \param [out]     pSubPriority  Subpriority value (starting from 0).
 */
__STATIC_INLINE void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* const pPreemptPriority, uint32_t* const pSubPriority)
{
2400140a:	b480      	push	{r7}
2400140c:	b089      	sub	sp, #36	; 0x24
2400140e:	af00      	add	r7, sp, #0
24001410:	60f8      	str	r0, [r7, #12]
24001412:	60b9      	str	r1, [r7, #8]
24001414:	607a      	str	r2, [r7, #4]
24001416:	603b      	str	r3, [r7, #0]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
24001418:	68bb      	ldr	r3, [r7, #8]
2400141a:	f003 0307 	and.w	r3, r3, #7
2400141e:	61fb      	str	r3, [r7, #28]
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
24001420:	69fb      	ldr	r3, [r7, #28]
24001422:	f1c3 0307 	rsb	r3, r3, #7
24001426:	2b04      	cmp	r3, #4
24001428:	bf28      	it	cs
2400142a:	2304      	movcs	r3, #4
2400142c:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
2400142e:	69fb      	ldr	r3, [r7, #28]
24001430:	3304      	adds	r3, #4
24001432:	2b06      	cmp	r3, #6
24001434:	d902      	bls.n	2400143c <NVIC_DecodePriority+0x32>
24001436:	69fb      	ldr	r3, [r7, #28]
24001438:	3b03      	subs	r3, #3
2400143a:	e000      	b.n	2400143e <NVIC_DecodePriority+0x34>
2400143c:	2300      	movs	r3, #0
2400143e:	617b      	str	r3, [r7, #20]

  *pPreemptPriority = (Priority >> SubPriorityBits) & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL);
24001440:	68fa      	ldr	r2, [r7, #12]
24001442:	697b      	ldr	r3, [r7, #20]
24001444:	40da      	lsrs	r2, r3
24001446:	f04f 31ff 	mov.w	r1, #4294967295
2400144a:	69bb      	ldr	r3, [r7, #24]
2400144c:	fa01 f303 	lsl.w	r3, r1, r3
24001450:	43db      	mvns	r3, r3
24001452:	401a      	ands	r2, r3
24001454:	687b      	ldr	r3, [r7, #4]
24001456:	601a      	str	r2, [r3, #0]
  *pSubPriority     = (Priority                   ) & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL);
24001458:	f04f 32ff 	mov.w	r2, #4294967295
2400145c:	697b      	ldr	r3, [r7, #20]
2400145e:	fa02 f303 	lsl.w	r3, r2, r3
24001462:	43da      	mvns	r2, r3
24001464:	68fb      	ldr	r3, [r7, #12]
24001466:	401a      	ands	r2, r3
24001468:	683b      	ldr	r3, [r7, #0]
2400146a:	601a      	str	r2, [r3, #0]
}
2400146c:	bf00      	nop
2400146e:	3724      	adds	r7, #36	; 0x24
24001470:	46bd      	mov	sp, r7
24001472:	f85d 7b04 	ldr.w	r7, [sp], #4
24001476:	4770      	bx	lr

24001478 <__NVIC_SystemReset>:
/**
  \brief   System Reset
  \details Initiates a system reset request to reset the MCU.
 */
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
24001478:	b480      	push	{r7}
2400147a:	af00      	add	r7, sp, #0
  __ASM volatile ("dsb 0xF":::"memory");
2400147c:	f3bf 8f4f 	dsb	sy
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
24001480:	4b05      	ldr	r3, [pc, #20]	; (24001498 <__NVIC_SystemReset+0x20>)
24001482:	68db      	ldr	r3, [r3, #12]
24001484:	f403 62e0 	and.w	r2, r3, #1792	; 0x700
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
24001488:	4903      	ldr	r1, [pc, #12]	; (24001498 <__NVIC_SystemReset+0x20>)
2400148a:	4b04      	ldr	r3, [pc, #16]	; (2400149c <__NVIC_SystemReset+0x24>)
2400148c:	4313      	orrs	r3, r2
2400148e:	60cb      	str	r3, [r1, #12]
24001490:	f3bf 8f4f 	dsb	sy
                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
  __DSB();                                                          /* Ensure completion of memory access */

  for(;;)                                                           /* wait until reset */
  {
    __NOP();
24001494:	bf00      	nop
24001496:	e7fd      	b.n	24001494 <__NVIC_SystemReset+0x1c>
24001498:	e000ed00 	.word	0xe000ed00
2400149c:	05fa0004 	.word	0x05fa0004

240014a0 <SysTick_Config>:
  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
240014a0:	b580      	push	{r7, lr}
240014a2:	b082      	sub	sp, #8
240014a4:	af00      	add	r7, sp, #0
240014a6:	6078      	str	r0, [r7, #4]
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
240014a8:	687b      	ldr	r3, [r7, #4]
240014aa:	3b01      	subs	r3, #1
240014ac:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
240014b0:	d301      	bcc.n	240014b6 <SysTick_Config+0x16>
  {
    return (1UL);                                                   /* Reload value impossible */
240014b2:	2301      	movs	r3, #1
240014b4:	e00f      	b.n	240014d6 <SysTick_Config+0x36>
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
240014b6:	4a0a      	ldr	r2, [pc, #40]	; (240014e0 <SysTick_Config+0x40>)
240014b8:	687b      	ldr	r3, [r7, #4]
240014ba:	3b01      	subs	r3, #1
240014bc:	6053      	str	r3, [r2, #4]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
240014be:	210f      	movs	r1, #15
240014c0:	f04f 30ff 	mov.w	r0, #4294967295
240014c4:	f7ff ff1c 	bl	24001300 <__NVIC_SetPriority>
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
240014c8:	4b05      	ldr	r3, [pc, #20]	; (240014e0 <SysTick_Config+0x40>)
240014ca:	2200      	movs	r2, #0
240014cc:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
240014ce:	4b04      	ldr	r3, [pc, #16]	; (240014e0 <SysTick_Config+0x40>)
240014d0:	2207      	movs	r2, #7
240014d2:	601a      	str	r2, [r3, #0]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
240014d4:	2300      	movs	r3, #0
}
240014d6:	4618      	mov	r0, r3
240014d8:	3708      	adds	r7, #8
240014da:	46bd      	mov	sp, r7
240014dc:	bd80      	pop	{r7, pc}
240014de:	bf00      	nop
240014e0:	e000e010 	.word	0xe000e010

240014e4 <HAL_NVIC_SetPriorityGrouping>:
  * @note   When the NVIC_PriorityGroup_0 is selected, IRQ preemption is no more possible.
  *         The pending IRQ priority will be managed only by the subpriority.
  * @retval None
  */
void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
240014e4:	b580      	push	{r7, lr}
240014e6:	b082      	sub	sp, #8
240014e8:	af00      	add	r7, sp, #0
240014ea:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));

  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
240014ec:	6878      	ldr	r0, [r7, #4]
240014ee:	f7ff fe15 	bl	2400111c <__NVIC_SetPriorityGrouping>
}
240014f2:	bf00      	nop
240014f4:	3708      	adds	r7, #8
240014f6:	46bd      	mov	sp, r7
240014f8:	bd80      	pop	{r7, pc}

240014fa <HAL_NVIC_SetPriority>:
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
240014fa:	b580      	push	{r7, lr}
240014fc:	b086      	sub	sp, #24
240014fe:	af00      	add	r7, sp, #0
24001500:	4603      	mov	r3, r0
24001502:	60b9      	str	r1, [r7, #8]
24001504:	607a      	str	r2, [r7, #4]
24001506:	81fb      	strh	r3, [r7, #14]

  /* Check the parameters */
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));

  prioritygroup = NVIC_GetPriorityGrouping();
24001508:	f7ff fe2c 	bl	24001164 <__NVIC_GetPriorityGrouping>
2400150c:	6178      	str	r0, [r7, #20]

  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
2400150e:	687a      	ldr	r2, [r7, #4]
24001510:	68b9      	ldr	r1, [r7, #8]
24001512:	6978      	ldr	r0, [r7, #20]
24001514:	f7ff ff46 	bl	240013a4 <NVIC_EncodePriority>
24001518:	4602      	mov	r2, r0
2400151a:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
2400151e:	4611      	mov	r1, r2
24001520:	4618      	mov	r0, r3
24001522:	f7ff feed 	bl	24001300 <__NVIC_SetPriority>
}
24001526:	bf00      	nop
24001528:	3718      	adds	r7, #24
2400152a:	46bd      	mov	sp, r7
2400152c:	bd80      	pop	{r7, pc}

2400152e <HAL_NVIC_EnableIRQ>:
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32h7xxxx.h))
  * @retval None
  */
void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
{
2400152e:	b580      	push	{r7, lr}
24001530:	b082      	sub	sp, #8
24001532:	af00      	add	r7, sp, #0
24001534:	4603      	mov	r3, r0
24001536:	80fb      	strh	r3, [r7, #6]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
24001538:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
2400153c:	4618      	mov	r0, r3
2400153e:	f7ff fe1f 	bl	24001180 <__NVIC_EnableIRQ>
}
24001542:	bf00      	nop
24001544:	3708      	adds	r7, #8
24001546:	46bd      	mov	sp, r7
24001548:	bd80      	pop	{r7, pc}

2400154a <HAL_NVIC_DisableIRQ>:
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32h7xxxx.h))
  * @retval None
  */
void HAL_NVIC_DisableIRQ(IRQn_Type IRQn)
{
2400154a:	b580      	push	{r7, lr}
2400154c:	b082      	sub	sp, #8
2400154e:	af00      	add	r7, sp, #0
24001550:	4603      	mov	r3, r0
24001552:	80fb      	strh	r3, [r7, #6]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Disable interrupt */
  NVIC_DisableIRQ(IRQn);
24001554:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
24001558:	4618      	mov	r0, r3
2400155a:	f7ff fe2f 	bl	240011bc <__NVIC_DisableIRQ>
}
2400155e:	bf00      	nop
24001560:	3708      	adds	r7, #8
24001562:	46bd      	mov	sp, r7
24001564:	bd80      	pop	{r7, pc}

24001566 <HAL_NVIC_SystemReset>:
/**
  * @brief  Initiates a system reset request to reset the MCU.
  * @retval None
  */
void HAL_NVIC_SystemReset(void)
{
24001566:	b580      	push	{r7, lr}
24001568:	af00      	add	r7, sp, #0
  /* System Reset */
  NVIC_SystemReset();
2400156a:	f7ff ff85 	bl	24001478 <__NVIC_SystemReset>

2400156e <HAL_SYSTICK_Config>:
  * @param  TicksNumb Specifies the ticks Number of ticks between two interrupts.
  * @retval status   - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
2400156e:	b580      	push	{r7, lr}
24001570:	b082      	sub	sp, #8
24001572:	af00      	add	r7, sp, #0
24001574:	6078      	str	r0, [r7, #4]
   return SysTick_Config(TicksNumb);
24001576:	6878      	ldr	r0, [r7, #4]
24001578:	f7ff ff92 	bl	240014a0 <SysTick_Config>
2400157c:	4603      	mov	r3, r0
}
2400157e:	4618      	mov	r0, r3
24001580:	3708      	adds	r7, #8
24001582:	46bd      	mov	sp, r7
24001584:	bd80      	pop	{r7, pc}
	...

24001588 <HAL_MPU_Disable>:
/**
  * @brief  Disables the MPU
  * @retval None
  */
void HAL_MPU_Disable(void)
{
24001588:	b480      	push	{r7}
2400158a:	af00      	add	r7, sp, #0
  \details Ensures the apparent order of the explicit memory operations before
           and after the instruction, without ensuring their completion.
 */
__STATIC_FORCEINLINE void __DMB(void)
{
  __ASM volatile ("dmb 0xF":::"memory");
2400158c:	f3bf 8f5f 	dmb	sy
  /* Make sure outstanding transfers are done */
  __DMB();

  /* Disable fault exceptions */
  SCB->SHCSR &= ~SCB_SHCSR_MEMFAULTENA_Msk;
24001590:	4b06      	ldr	r3, [pc, #24]	; (240015ac <HAL_MPU_Disable+0x24>)
24001592:	6a5b      	ldr	r3, [r3, #36]	; 0x24
24001594:	4a05      	ldr	r2, [pc, #20]	; (240015ac <HAL_MPU_Disable+0x24>)
24001596:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
2400159a:	6253      	str	r3, [r2, #36]	; 0x24

  /* Disable the MPU and clear the control register*/
  MPU->CTRL = 0;
2400159c:	4b04      	ldr	r3, [pc, #16]	; (240015b0 <HAL_MPU_Disable+0x28>)
2400159e:	2200      	movs	r2, #0
240015a0:	605a      	str	r2, [r3, #4]
}
240015a2:	bf00      	nop
240015a4:	46bd      	mov	sp, r7
240015a6:	f85d 7b04 	ldr.w	r7, [sp], #4
240015aa:	4770      	bx	lr
240015ac:	e000ed00 	.word	0xe000ed00
240015b0:	e000ed90 	.word	0xe000ed90

240015b4 <HAL_MPU_Enable>:
  *            @arg MPU_PRIVILEGED_DEFAULT
  *            @arg MPU_HFNMI_PRIVDEF
  * @retval None
  */
void HAL_MPU_Enable(uint32_t MPU_Control)
{
240015b4:	b480      	push	{r7}
240015b6:	b083      	sub	sp, #12
240015b8:	af00      	add	r7, sp, #0
240015ba:	6078      	str	r0, [r7, #4]
  /* Enable the MPU */
  MPU->CTRL = MPU_Control | MPU_CTRL_ENABLE_Msk;
240015bc:	4a0a      	ldr	r2, [pc, #40]	; (240015e8 <HAL_MPU_Enable+0x34>)
240015be:	687b      	ldr	r3, [r7, #4]
240015c0:	f043 0301 	orr.w	r3, r3, #1
240015c4:	6053      	str	r3, [r2, #4]

  /* Enable fault exceptions */
  SCB->SHCSR |= SCB_SHCSR_MEMFAULTENA_Msk;
240015c6:	4b09      	ldr	r3, [pc, #36]	; (240015ec <HAL_MPU_Enable+0x38>)
240015c8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
240015ca:	4a08      	ldr	r2, [pc, #32]	; (240015ec <HAL_MPU_Enable+0x38>)
240015cc:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
240015d0:	6253      	str	r3, [r2, #36]	; 0x24
  __ASM volatile ("dsb 0xF":::"memory");
240015d2:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
240015d6:	f3bf 8f6f 	isb	sy

  /* Ensure MPU setting take effects */
  __DSB();
  __ISB();
}
240015da:	bf00      	nop
240015dc:	370c      	adds	r7, #12
240015de:	46bd      	mov	sp, r7
240015e0:	f85d 7b04 	ldr.w	r7, [sp], #4
240015e4:	4770      	bx	lr
240015e6:	bf00      	nop
240015e8:	e000ed90 	.word	0xe000ed90
240015ec:	e000ed00 	.word	0xe000ed00

240015f0 <HAL_MPU_ConfigRegion>:
  * @param  MPU_Init Pointer to a MPU_Region_InitTypeDef structure that contains
  *                  the initialization and configuration information.
  * @retval None
  */
void HAL_MPU_ConfigRegion(MPU_Region_InitTypeDef *MPU_Init)
{
240015f0:	b480      	push	{r7}
240015f2:	b083      	sub	sp, #12
240015f4:	af00      	add	r7, sp, #0
240015f6:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_MPU_REGION_NUMBER(MPU_Init->Number));
  assert_param(IS_MPU_REGION_ENABLE(MPU_Init->Enable));

  /* Set the Region number */
  MPU->RNR = MPU_Init->Number;
240015f8:	687b      	ldr	r3, [r7, #4]
240015fa:	785a      	ldrb	r2, [r3, #1]
240015fc:	4b1d      	ldr	r3, [pc, #116]	; (24001674 <HAL_MPU_ConfigRegion+0x84>)
240015fe:	609a      	str	r2, [r3, #8]

  if ((MPU_Init->Enable) != 0UL)
24001600:	687b      	ldr	r3, [r7, #4]
24001602:	781b      	ldrb	r3, [r3, #0]
24001604:	2b00      	cmp	r3, #0
24001606:	d029      	beq.n	2400165c <HAL_MPU_ConfigRegion+0x6c>
    assert_param(IS_MPU_ACCESS_CACHEABLE(MPU_Init->IsCacheable));
    assert_param(IS_MPU_ACCESS_BUFFERABLE(MPU_Init->IsBufferable));
    assert_param(IS_MPU_SUB_REGION_DISABLE(MPU_Init->SubRegionDisable));
    assert_param(IS_MPU_REGION_SIZE(MPU_Init->Size));

    MPU->RBAR = MPU_Init->BaseAddress;
24001608:	4a1a      	ldr	r2, [pc, #104]	; (24001674 <HAL_MPU_ConfigRegion+0x84>)
2400160a:	687b      	ldr	r3, [r7, #4]
2400160c:	685b      	ldr	r3, [r3, #4]
2400160e:	60d3      	str	r3, [r2, #12]
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
24001610:	687b      	ldr	r3, [r7, #4]
24001612:	7b1b      	ldrb	r3, [r3, #12]
24001614:	071a      	lsls	r2, r3, #28
                ((uint32_t)MPU_Init->AccessPermission        << MPU_RASR_AP_Pos)   |
24001616:	687b      	ldr	r3, [r7, #4]
24001618:	7adb      	ldrb	r3, [r3, #11]
2400161a:	061b      	lsls	r3, r3, #24
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
2400161c:	431a      	orrs	r2, r3
                ((uint32_t)MPU_Init->TypeExtField            << MPU_RASR_TEX_Pos)  |
2400161e:	687b      	ldr	r3, [r7, #4]
24001620:	7a9b      	ldrb	r3, [r3, #10]
24001622:	04db      	lsls	r3, r3, #19
                ((uint32_t)MPU_Init->AccessPermission        << MPU_RASR_AP_Pos)   |
24001624:	431a      	orrs	r2, r3
                ((uint32_t)MPU_Init->IsShareable             << MPU_RASR_S_Pos)    |
24001626:	687b      	ldr	r3, [r7, #4]
24001628:	7b5b      	ldrb	r3, [r3, #13]
2400162a:	049b      	lsls	r3, r3, #18
                ((uint32_t)MPU_Init->TypeExtField            << MPU_RASR_TEX_Pos)  |
2400162c:	431a      	orrs	r2, r3
                ((uint32_t)MPU_Init->IsCacheable             << MPU_RASR_C_Pos)    |
2400162e:	687b      	ldr	r3, [r7, #4]
24001630:	7b9b      	ldrb	r3, [r3, #14]
24001632:	045b      	lsls	r3, r3, #17
                ((uint32_t)MPU_Init->IsShareable             << MPU_RASR_S_Pos)    |
24001634:	431a      	orrs	r2, r3
                ((uint32_t)MPU_Init->IsBufferable            << MPU_RASR_B_Pos)    |
24001636:	687b      	ldr	r3, [r7, #4]
24001638:	7bdb      	ldrb	r3, [r3, #15]
2400163a:	041b      	lsls	r3, r3, #16
                ((uint32_t)MPU_Init->IsCacheable             << MPU_RASR_C_Pos)    |
2400163c:	431a      	orrs	r2, r3
                ((uint32_t)MPU_Init->SubRegionDisable        << MPU_RASR_SRD_Pos)  |
2400163e:	687b      	ldr	r3, [r7, #4]
24001640:	7a5b      	ldrb	r3, [r3, #9]
24001642:	021b      	lsls	r3, r3, #8
                ((uint32_t)MPU_Init->IsBufferable            << MPU_RASR_B_Pos)    |
24001644:	431a      	orrs	r2, r3
                ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
24001646:	687b      	ldr	r3, [r7, #4]
24001648:	7a1b      	ldrb	r3, [r3, #8]
2400164a:	005b      	lsls	r3, r3, #1
                ((uint32_t)MPU_Init->SubRegionDisable        << MPU_RASR_SRD_Pos)  |
2400164c:	4313      	orrs	r3, r2
                ((uint32_t)MPU_Init->Enable                  << MPU_RASR_ENABLE_Pos);
2400164e:	687a      	ldr	r2, [r7, #4]
24001650:	7812      	ldrb	r2, [r2, #0]
24001652:	4611      	mov	r1, r2
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
24001654:	4a07      	ldr	r2, [pc, #28]	; (24001674 <HAL_MPU_ConfigRegion+0x84>)
                ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
24001656:	430b      	orrs	r3, r1
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
24001658:	6113      	str	r3, [r2, #16]
  else
  {
    MPU->RBAR = 0x00;
    MPU->RASR = 0x00;
  }
}
2400165a:	e005      	b.n	24001668 <HAL_MPU_ConfigRegion+0x78>
    MPU->RBAR = 0x00;
2400165c:	4b05      	ldr	r3, [pc, #20]	; (24001674 <HAL_MPU_ConfigRegion+0x84>)
2400165e:	2200      	movs	r2, #0
24001660:	60da      	str	r2, [r3, #12]
    MPU->RASR = 0x00;
24001662:	4b04      	ldr	r3, [pc, #16]	; (24001674 <HAL_MPU_ConfigRegion+0x84>)
24001664:	2200      	movs	r2, #0
24001666:	611a      	str	r2, [r3, #16]
}
24001668:	bf00      	nop
2400166a:	370c      	adds	r7, #12
2400166c:	46bd      	mov	sp, r7
2400166e:	f85d 7b04 	ldr.w	r7, [sp], #4
24001672:	4770      	bx	lr
24001674:	e000ed90 	.word	0xe000ed90

24001678 <HAL_NVIC_GetPriorityGrouping>:
/**
  * @brief  Gets the priority grouping field from the NVIC Interrupt Controller.
  * @retval Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field)
  */
uint32_t HAL_NVIC_GetPriorityGrouping(void)
{
24001678:	b580      	push	{r7, lr}
2400167a:	af00      	add	r7, sp, #0
  /* Get the PRIGROUP[10:8] field value */
  return NVIC_GetPriorityGrouping();
2400167c:	f7ff fd72 	bl	24001164 <__NVIC_GetPriorityGrouping>
24001680:	4603      	mov	r3, r0
}
24001682:	4618      	mov	r0, r3
24001684:	bd80      	pop	{r7, pc}

24001686 <HAL_NVIC_GetPriority>:
  * @param  pPreemptPriority Pointer on the Preemptive priority value (starting from 0).
  * @param  pSubPriority Pointer on the Subpriority value (starting from 0).
  * @retval None
  */
void HAL_NVIC_GetPriority(IRQn_Type IRQn, uint32_t PriorityGroup, uint32_t *pPreemptPriority, uint32_t *pSubPriority)
{
24001686:	b580      	push	{r7, lr}
24001688:	b084      	sub	sp, #16
2400168a:	af00      	add	r7, sp, #0
2400168c:	60b9      	str	r1, [r7, #8]
2400168e:	607a      	str	r2, [r7, #4]
24001690:	603b      	str	r3, [r7, #0]
24001692:	4603      	mov	r3, r0
24001694:	81fb      	strh	r3, [r7, #14]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
 /* Get priority for Cortex-M system or device specific interrupts */
  NVIC_DecodePriority(NVIC_GetPriority(IRQn), PriorityGroup, pPreemptPriority, pSubPriority);
24001696:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
2400169a:	4618      	mov	r0, r3
2400169c:	f7ff fe5a 	bl	24001354 <__NVIC_GetPriority>
240016a0:	683b      	ldr	r3, [r7, #0]
240016a2:	687a      	ldr	r2, [r7, #4]
240016a4:	68b9      	ldr	r1, [r7, #8]
240016a6:	f7ff feb0 	bl	2400140a <NVIC_DecodePriority>
}
240016aa:	bf00      	nop
240016ac:	3710      	adds	r7, #16
240016ae:	46bd      	mov	sp, r7
240016b0:	bd80      	pop	{r7, pc}

240016b2 <HAL_NVIC_SetPendingIRQ>:
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32h7xxxx.h))
  * @retval None
  */
void HAL_NVIC_SetPendingIRQ(IRQn_Type IRQn)
{
240016b2:	b580      	push	{r7, lr}
240016b4:	b082      	sub	sp, #8
240016b6:	af00      	add	r7, sp, #0
240016b8:	4603      	mov	r3, r0
240016ba:	80fb      	strh	r3, [r7, #6]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Set interrupt pending */
  NVIC_SetPendingIRQ(IRQn);
240016bc:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
240016c0:	4618      	mov	r0, r3
240016c2:	f7ff fdbf 	bl	24001244 <__NVIC_SetPendingIRQ>
}
240016c6:	bf00      	nop
240016c8:	3708      	adds	r7, #8
240016ca:	46bd      	mov	sp, r7
240016cc:	bd80      	pop	{r7, pc}

240016ce <HAL_NVIC_GetPendingIRQ>:
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32h7xxxx.h))
  * @retval status  - 0  Interrupt status is not pending.
  *                 - 1  Interrupt status is pending.
  */
uint32_t HAL_NVIC_GetPendingIRQ(IRQn_Type IRQn)
{
240016ce:	b580      	push	{r7, lr}
240016d0:	b082      	sub	sp, #8
240016d2:	af00      	add	r7, sp, #0
240016d4:	4603      	mov	r3, r0
240016d6:	80fb      	strh	r3, [r7, #6]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Return 1 if pending else 0 */
  return NVIC_GetPendingIRQ(IRQn);
240016d8:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
240016dc:	4618      	mov	r0, r3
240016de:	f7ff fd8f 	bl	24001200 <__NVIC_GetPendingIRQ>
240016e2:	4603      	mov	r3, r0
}
240016e4:	4618      	mov	r0, r3
240016e6:	3708      	adds	r7, #8
240016e8:	46bd      	mov	sp, r7
240016ea:	bd80      	pop	{r7, pc}

240016ec <HAL_NVIC_ClearPendingIRQ>:
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32h7xxxx.h))
  * @retval None
  */
void HAL_NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
240016ec:	b580      	push	{r7, lr}
240016ee:	b082      	sub	sp, #8
240016f0:	af00      	add	r7, sp, #0
240016f2:	4603      	mov	r3, r0
240016f4:	80fb      	strh	r3, [r7, #6]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Clear pending interrupt */
  NVIC_ClearPendingIRQ(IRQn);
240016f6:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
240016fa:	4618      	mov	r0, r3
240016fc:	f7ff fdc0 	bl	24001280 <__NVIC_ClearPendingIRQ>
}
24001700:	bf00      	nop
24001702:	3708      	adds	r7, #8
24001704:	46bd      	mov	sp, r7
24001706:	bd80      	pop	{r7, pc}

24001708 <HAL_NVIC_GetActive>:
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32h7xxxx.h))
  * @retval status  - 0  Interrupt status is not pending.
  *                 - 1  Interrupt status is pending.
  */
uint32_t HAL_NVIC_GetActive(IRQn_Type IRQn)
{
24001708:	b580      	push	{r7, lr}
2400170a:	b082      	sub	sp, #8
2400170c:	af00      	add	r7, sp, #0
2400170e:	4603      	mov	r3, r0
24001710:	80fb      	strh	r3, [r7, #6]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Return 1 if active else 0 */
  return NVIC_GetActive(IRQn);
24001712:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
24001716:	4618      	mov	r0, r3
24001718:	f7ff fdd0 	bl	240012bc <__NVIC_GetActive>
2400171c:	4603      	mov	r3, r0
}
2400171e:	4618      	mov	r0, r3
24001720:	3708      	adds	r7, #8
24001722:	46bd      	mov	sp, r7
24001724:	bd80      	pop	{r7, pc}
	...

24001728 <HAL_SYSTICK_CLKSourceConfig>:
  *             @arg SYSTICK_CLKSOURCE_HCLK_DIV8: AHB clock divided by 8 selected as SysTick clock source.
  *             @arg SYSTICK_CLKSOURCE_HCLK: AHB clock selected as SysTick clock source.
  * @retval None
  */
void HAL_SYSTICK_CLKSourceConfig(uint32_t CLKSource)
{
24001728:	b480      	push	{r7}
2400172a:	b083      	sub	sp, #12
2400172c:	af00      	add	r7, sp, #0
2400172e:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(CLKSource));
  if (CLKSource == SYSTICK_CLKSOURCE_HCLK)
24001730:	687b      	ldr	r3, [r7, #4]
24001732:	2b04      	cmp	r3, #4
24001734:	d106      	bne.n	24001744 <HAL_SYSTICK_CLKSourceConfig+0x1c>
  {
    SysTick->CTRL |= SYSTICK_CLKSOURCE_HCLK;
24001736:	4b09      	ldr	r3, [pc, #36]	; (2400175c <HAL_SYSTICK_CLKSourceConfig+0x34>)
24001738:	681b      	ldr	r3, [r3, #0]
2400173a:	4a08      	ldr	r2, [pc, #32]	; (2400175c <HAL_SYSTICK_CLKSourceConfig+0x34>)
2400173c:	f043 0304 	orr.w	r3, r3, #4
24001740:	6013      	str	r3, [r2, #0]
  }
  else
  {
    SysTick->CTRL &= ~SYSTICK_CLKSOURCE_HCLK;
  }
}
24001742:	e005      	b.n	24001750 <HAL_SYSTICK_CLKSourceConfig+0x28>
    SysTick->CTRL &= ~SYSTICK_CLKSOURCE_HCLK;
24001744:	4b05      	ldr	r3, [pc, #20]	; (2400175c <HAL_SYSTICK_CLKSourceConfig+0x34>)
24001746:	681b      	ldr	r3, [r3, #0]
24001748:	4a04      	ldr	r2, [pc, #16]	; (2400175c <HAL_SYSTICK_CLKSourceConfig+0x34>)
2400174a:	f023 0304 	bic.w	r3, r3, #4
2400174e:	6013      	str	r3, [r2, #0]
}
24001750:	bf00      	nop
24001752:	370c      	adds	r7, #12
24001754:	46bd      	mov	sp, r7
24001756:	f85d 7b04 	ldr.w	r7, [sp], #4
2400175a:	4770      	bx	lr
2400175c:	e000e010 	.word	0xe000e010

24001760 <HAL_SYSTICK_IRQHandler>:
/**
  * @brief  This function handles SYSTICK interrupt request.
  * @retval None
  */
void HAL_SYSTICK_IRQHandler(void)
{
24001760:	b580      	push	{r7, lr}
24001762:	af00      	add	r7, sp, #0
  HAL_SYSTICK_Callback();
24001764:	f000 f802 	bl	2400176c <HAL_SYSTICK_Callback>
}
24001768:	bf00      	nop
2400176a:	bd80      	pop	{r7, pc}

2400176c <HAL_SYSTICK_Callback>:
/**
  * @brief  SYSTICK callback.
  * @retval None
  */
__weak void HAL_SYSTICK_Callback(void)
{
2400176c:	b480      	push	{r7}
2400176e:	af00      	add	r7, sp, #0
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_SYSTICK_Callback could be implemented in the user file
   */
}
24001770:	bf00      	nop
24001772:	46bd      	mov	sp, r7
24001774:	f85d 7b04 	ldr.w	r7, [sp], #4
24001778:	4770      	bx	lr

2400177a <HAL_GetCurrentCPUID>:
/**
* @brief  Returns the current CPU ID.
* @retval CPU identifier
*/
uint32_t HAL_GetCurrentCPUID(void)
{
2400177a:	b480      	push	{r7}
2400177c:	af00      	add	r7, sp, #0
  return  CM7_CPUID;
2400177e:	2303      	movs	r3, #3
}
24001780:	4618      	mov	r0, r3
24001782:	46bd      	mov	sp, r7
24001784:	f85d 7b04 	ldr.w	r7, [sp], #4
24001788:	4770      	bx	lr
	...

2400178c <HAL_DMA_Init>:
  * @param  hdma: Pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Stream.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Init(DMA_HandleTypeDef *hdma)
{
2400178c:	b580      	push	{r7, lr}
2400178e:	b086      	sub	sp, #24
24001790:	af00      	add	r7, sp, #0
24001792:	6078      	str	r0, [r7, #4]
  uint32_t registerValue;
  uint32_t tickstart = HAL_GetTick();
24001794:	f7ff f85c 	bl	24000850 <HAL_GetTick>
24001798:	6138      	str	r0, [r7, #16]
  DMA_Base_Registers *regs_dma;
  BDMA_Base_Registers *regs_bdma;

  /* Check the DMA peripheral handle */
  if(hdma == NULL)
2400179a:	687b      	ldr	r3, [r7, #4]
2400179c:	2b00      	cmp	r3, #0
2400179e:	d101      	bne.n	240017a4 <HAL_DMA_Init+0x18>
  {
    return HAL_ERROR;
240017a0:	2301      	movs	r3, #1
240017a2:	e316      	b.n	24001dd2 <HAL_DMA_Init+0x646>
  assert_param(IS_DMA_PERIPHERAL_DATA_SIZE(hdma->Init.PeriphDataAlignment));
  assert_param(IS_DMA_MEMORY_DATA_SIZE(hdma->Init.MemDataAlignment));
  assert_param(IS_DMA_MODE(hdma->Init.Mode));
  assert_param(IS_DMA_PRIORITY(hdma->Init.Priority));

  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
240017a4:	687b      	ldr	r3, [r7, #4]
240017a6:	681b      	ldr	r3, [r3, #0]
240017a8:	4a66      	ldr	r2, [pc, #408]	; (24001944 <HAL_DMA_Init+0x1b8>)
240017aa:	4293      	cmp	r3, r2
240017ac:	d04a      	beq.n	24001844 <HAL_DMA_Init+0xb8>
240017ae:	687b      	ldr	r3, [r7, #4]
240017b0:	681b      	ldr	r3, [r3, #0]
240017b2:	4a65      	ldr	r2, [pc, #404]	; (24001948 <HAL_DMA_Init+0x1bc>)
240017b4:	4293      	cmp	r3, r2
240017b6:	d045      	beq.n	24001844 <HAL_DMA_Init+0xb8>
240017b8:	687b      	ldr	r3, [r7, #4]
240017ba:	681b      	ldr	r3, [r3, #0]
240017bc:	4a63      	ldr	r2, [pc, #396]	; (2400194c <HAL_DMA_Init+0x1c0>)
240017be:	4293      	cmp	r3, r2
240017c0:	d040      	beq.n	24001844 <HAL_DMA_Init+0xb8>
240017c2:	687b      	ldr	r3, [r7, #4]
240017c4:	681b      	ldr	r3, [r3, #0]
240017c6:	4a62      	ldr	r2, [pc, #392]	; (24001950 <HAL_DMA_Init+0x1c4>)
240017c8:	4293      	cmp	r3, r2
240017ca:	d03b      	beq.n	24001844 <HAL_DMA_Init+0xb8>
240017cc:	687b      	ldr	r3, [r7, #4]
240017ce:	681b      	ldr	r3, [r3, #0]
240017d0:	4a60      	ldr	r2, [pc, #384]	; (24001954 <HAL_DMA_Init+0x1c8>)
240017d2:	4293      	cmp	r3, r2
240017d4:	d036      	beq.n	24001844 <HAL_DMA_Init+0xb8>
240017d6:	687b      	ldr	r3, [r7, #4]
240017d8:	681b      	ldr	r3, [r3, #0]
240017da:	4a5f      	ldr	r2, [pc, #380]	; (24001958 <HAL_DMA_Init+0x1cc>)
240017dc:	4293      	cmp	r3, r2
240017de:	d031      	beq.n	24001844 <HAL_DMA_Init+0xb8>
240017e0:	687b      	ldr	r3, [r7, #4]
240017e2:	681b      	ldr	r3, [r3, #0]
240017e4:	4a5d      	ldr	r2, [pc, #372]	; (2400195c <HAL_DMA_Init+0x1d0>)
240017e6:	4293      	cmp	r3, r2
240017e8:	d02c      	beq.n	24001844 <HAL_DMA_Init+0xb8>
240017ea:	687b      	ldr	r3, [r7, #4]
240017ec:	681b      	ldr	r3, [r3, #0]
240017ee:	4a5c      	ldr	r2, [pc, #368]	; (24001960 <HAL_DMA_Init+0x1d4>)
240017f0:	4293      	cmp	r3, r2
240017f2:	d027      	beq.n	24001844 <HAL_DMA_Init+0xb8>
240017f4:	687b      	ldr	r3, [r7, #4]
240017f6:	681b      	ldr	r3, [r3, #0]
240017f8:	4a5a      	ldr	r2, [pc, #360]	; (24001964 <HAL_DMA_Init+0x1d8>)
240017fa:	4293      	cmp	r3, r2
240017fc:	d022      	beq.n	24001844 <HAL_DMA_Init+0xb8>
240017fe:	687b      	ldr	r3, [r7, #4]
24001800:	681b      	ldr	r3, [r3, #0]
24001802:	4a59      	ldr	r2, [pc, #356]	; (24001968 <HAL_DMA_Init+0x1dc>)
24001804:	4293      	cmp	r3, r2
24001806:	d01d      	beq.n	24001844 <HAL_DMA_Init+0xb8>
24001808:	687b      	ldr	r3, [r7, #4]
2400180a:	681b      	ldr	r3, [r3, #0]
2400180c:	4a57      	ldr	r2, [pc, #348]	; (2400196c <HAL_DMA_Init+0x1e0>)
2400180e:	4293      	cmp	r3, r2
24001810:	d018      	beq.n	24001844 <HAL_DMA_Init+0xb8>
24001812:	687b      	ldr	r3, [r7, #4]
24001814:	681b      	ldr	r3, [r3, #0]
24001816:	4a56      	ldr	r2, [pc, #344]	; (24001970 <HAL_DMA_Init+0x1e4>)
24001818:	4293      	cmp	r3, r2
2400181a:	d013      	beq.n	24001844 <HAL_DMA_Init+0xb8>
2400181c:	687b      	ldr	r3, [r7, #4]
2400181e:	681b      	ldr	r3, [r3, #0]
24001820:	4a54      	ldr	r2, [pc, #336]	; (24001974 <HAL_DMA_Init+0x1e8>)
24001822:	4293      	cmp	r3, r2
24001824:	d00e      	beq.n	24001844 <HAL_DMA_Init+0xb8>
24001826:	687b      	ldr	r3, [r7, #4]
24001828:	681b      	ldr	r3, [r3, #0]
2400182a:	4a53      	ldr	r2, [pc, #332]	; (24001978 <HAL_DMA_Init+0x1ec>)
2400182c:	4293      	cmp	r3, r2
2400182e:	d009      	beq.n	24001844 <HAL_DMA_Init+0xb8>
24001830:	687b      	ldr	r3, [r7, #4]
24001832:	681b      	ldr	r3, [r3, #0]
24001834:	4a51      	ldr	r2, [pc, #324]	; (2400197c <HAL_DMA_Init+0x1f0>)
24001836:	4293      	cmp	r3, r2
24001838:	d004      	beq.n	24001844 <HAL_DMA_Init+0xb8>
2400183a:	687b      	ldr	r3, [r7, #4]
2400183c:	681b      	ldr	r3, [r3, #0]
2400183e:	4a50      	ldr	r2, [pc, #320]	; (24001980 <HAL_DMA_Init+0x1f4>)
24001840:	4293      	cmp	r3, r2
24001842:	d101      	bne.n	24001848 <HAL_DMA_Init+0xbc>
24001844:	2301      	movs	r3, #1
24001846:	e000      	b.n	2400184a <HAL_DMA_Init+0xbe>
24001848:	2300      	movs	r3, #0
2400184a:	2b00      	cmp	r3, #0
2400184c:	f000 813b 	beq.w	24001ac6 <HAL_DMA_Init+0x33a>
      assert_param(IS_DMA_MEMORY_BURST(hdma->Init.MemBurst));
      assert_param(IS_DMA_PERIPHERAL_BURST(hdma->Init.PeriphBurst));
    }

    /* Allocate lock resource */
    __HAL_UNLOCK(hdma);
24001850:	687b      	ldr	r3, [r7, #4]
24001852:	2200      	movs	r2, #0
24001854:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

    /* Change DMA peripheral state */
    hdma->State = HAL_DMA_STATE_BUSY;
24001858:	687b      	ldr	r3, [r7, #4]
2400185a:	2202      	movs	r2, #2
2400185c:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

    /* Disable the peripheral */
    __HAL_DMA_DISABLE(hdma);
24001860:	687b      	ldr	r3, [r7, #4]
24001862:	681b      	ldr	r3, [r3, #0]
24001864:	4a37      	ldr	r2, [pc, #220]	; (24001944 <HAL_DMA_Init+0x1b8>)
24001866:	4293      	cmp	r3, r2
24001868:	d04a      	beq.n	24001900 <HAL_DMA_Init+0x174>
2400186a:	687b      	ldr	r3, [r7, #4]
2400186c:	681b      	ldr	r3, [r3, #0]
2400186e:	4a36      	ldr	r2, [pc, #216]	; (24001948 <HAL_DMA_Init+0x1bc>)
24001870:	4293      	cmp	r3, r2
24001872:	d045      	beq.n	24001900 <HAL_DMA_Init+0x174>
24001874:	687b      	ldr	r3, [r7, #4]
24001876:	681b      	ldr	r3, [r3, #0]
24001878:	4a34      	ldr	r2, [pc, #208]	; (2400194c <HAL_DMA_Init+0x1c0>)
2400187a:	4293      	cmp	r3, r2
2400187c:	d040      	beq.n	24001900 <HAL_DMA_Init+0x174>
2400187e:	687b      	ldr	r3, [r7, #4]
24001880:	681b      	ldr	r3, [r3, #0]
24001882:	4a33      	ldr	r2, [pc, #204]	; (24001950 <HAL_DMA_Init+0x1c4>)
24001884:	4293      	cmp	r3, r2
24001886:	d03b      	beq.n	24001900 <HAL_DMA_Init+0x174>
24001888:	687b      	ldr	r3, [r7, #4]
2400188a:	681b      	ldr	r3, [r3, #0]
2400188c:	4a31      	ldr	r2, [pc, #196]	; (24001954 <HAL_DMA_Init+0x1c8>)
2400188e:	4293      	cmp	r3, r2
24001890:	d036      	beq.n	24001900 <HAL_DMA_Init+0x174>
24001892:	687b      	ldr	r3, [r7, #4]
24001894:	681b      	ldr	r3, [r3, #0]
24001896:	4a30      	ldr	r2, [pc, #192]	; (24001958 <HAL_DMA_Init+0x1cc>)
24001898:	4293      	cmp	r3, r2
2400189a:	d031      	beq.n	24001900 <HAL_DMA_Init+0x174>
2400189c:	687b      	ldr	r3, [r7, #4]
2400189e:	681b      	ldr	r3, [r3, #0]
240018a0:	4a2e      	ldr	r2, [pc, #184]	; (2400195c <HAL_DMA_Init+0x1d0>)
240018a2:	4293      	cmp	r3, r2
240018a4:	d02c      	beq.n	24001900 <HAL_DMA_Init+0x174>
240018a6:	687b      	ldr	r3, [r7, #4]
240018a8:	681b      	ldr	r3, [r3, #0]
240018aa:	4a2d      	ldr	r2, [pc, #180]	; (24001960 <HAL_DMA_Init+0x1d4>)
240018ac:	4293      	cmp	r3, r2
240018ae:	d027      	beq.n	24001900 <HAL_DMA_Init+0x174>
240018b0:	687b      	ldr	r3, [r7, #4]
240018b2:	681b      	ldr	r3, [r3, #0]
240018b4:	4a2b      	ldr	r2, [pc, #172]	; (24001964 <HAL_DMA_Init+0x1d8>)
240018b6:	4293      	cmp	r3, r2
240018b8:	d022      	beq.n	24001900 <HAL_DMA_Init+0x174>
240018ba:	687b      	ldr	r3, [r7, #4]
240018bc:	681b      	ldr	r3, [r3, #0]
240018be:	4a2a      	ldr	r2, [pc, #168]	; (24001968 <HAL_DMA_Init+0x1dc>)
240018c0:	4293      	cmp	r3, r2
240018c2:	d01d      	beq.n	24001900 <HAL_DMA_Init+0x174>
240018c4:	687b      	ldr	r3, [r7, #4]
240018c6:	681b      	ldr	r3, [r3, #0]
240018c8:	4a28      	ldr	r2, [pc, #160]	; (2400196c <HAL_DMA_Init+0x1e0>)
240018ca:	4293      	cmp	r3, r2
240018cc:	d018      	beq.n	24001900 <HAL_DMA_Init+0x174>
240018ce:	687b      	ldr	r3, [r7, #4]
240018d0:	681b      	ldr	r3, [r3, #0]
240018d2:	4a27      	ldr	r2, [pc, #156]	; (24001970 <HAL_DMA_Init+0x1e4>)
240018d4:	4293      	cmp	r3, r2
240018d6:	d013      	beq.n	24001900 <HAL_DMA_Init+0x174>
240018d8:	687b      	ldr	r3, [r7, #4]
240018da:	681b      	ldr	r3, [r3, #0]
240018dc:	4a25      	ldr	r2, [pc, #148]	; (24001974 <HAL_DMA_Init+0x1e8>)
240018de:	4293      	cmp	r3, r2
240018e0:	d00e      	beq.n	24001900 <HAL_DMA_Init+0x174>
240018e2:	687b      	ldr	r3, [r7, #4]
240018e4:	681b      	ldr	r3, [r3, #0]
240018e6:	4a24      	ldr	r2, [pc, #144]	; (24001978 <HAL_DMA_Init+0x1ec>)
240018e8:	4293      	cmp	r3, r2
240018ea:	d009      	beq.n	24001900 <HAL_DMA_Init+0x174>
240018ec:	687b      	ldr	r3, [r7, #4]
240018ee:	681b      	ldr	r3, [r3, #0]
240018f0:	4a22      	ldr	r2, [pc, #136]	; (2400197c <HAL_DMA_Init+0x1f0>)
240018f2:	4293      	cmp	r3, r2
240018f4:	d004      	beq.n	24001900 <HAL_DMA_Init+0x174>
240018f6:	687b      	ldr	r3, [r7, #4]
240018f8:	681b      	ldr	r3, [r3, #0]
240018fa:	4a21      	ldr	r2, [pc, #132]	; (24001980 <HAL_DMA_Init+0x1f4>)
240018fc:	4293      	cmp	r3, r2
240018fe:	d108      	bne.n	24001912 <HAL_DMA_Init+0x186>
24001900:	687b      	ldr	r3, [r7, #4]
24001902:	681b      	ldr	r3, [r3, #0]
24001904:	681a      	ldr	r2, [r3, #0]
24001906:	687b      	ldr	r3, [r7, #4]
24001908:	681b      	ldr	r3, [r3, #0]
2400190a:	f022 0201 	bic.w	r2, r2, #1
2400190e:	601a      	str	r2, [r3, #0]
24001910:	e007      	b.n	24001922 <HAL_DMA_Init+0x196>
24001912:	687b      	ldr	r3, [r7, #4]
24001914:	681b      	ldr	r3, [r3, #0]
24001916:	681a      	ldr	r2, [r3, #0]
24001918:	687b      	ldr	r3, [r7, #4]
2400191a:	681b      	ldr	r3, [r3, #0]
2400191c:	f022 0201 	bic.w	r2, r2, #1
24001920:	601a      	str	r2, [r3, #0]

    /* Check if the DMA Stream is effectively disabled */
    while((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_EN) != 0U)
24001922:	e02f      	b.n	24001984 <HAL_DMA_Init+0x1f8>
    {
      /* Check for the Timeout */
      if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA_ABORT)
24001924:	f7fe ff94 	bl	24000850 <HAL_GetTick>
24001928:	4602      	mov	r2, r0
2400192a:	693b      	ldr	r3, [r7, #16]
2400192c:	1ad3      	subs	r3, r2, r3
2400192e:	2b05      	cmp	r3, #5
24001930:	d928      	bls.n	24001984 <HAL_DMA_Init+0x1f8>
      {
        /* Update error code */
        hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
24001932:	687b      	ldr	r3, [r7, #4]
24001934:	2220      	movs	r2, #32
24001936:	655a      	str	r2, [r3, #84]	; 0x54

        /* Change the DMA state */
        hdma->State = HAL_DMA_STATE_ERROR;
24001938:	687b      	ldr	r3, [r7, #4]
2400193a:	2203      	movs	r2, #3
2400193c:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

        return HAL_ERROR;
24001940:	2301      	movs	r3, #1
24001942:	e246      	b.n	24001dd2 <HAL_DMA_Init+0x646>
24001944:	40020010 	.word	0x40020010
24001948:	40020028 	.word	0x40020028
2400194c:	40020040 	.word	0x40020040
24001950:	40020058 	.word	0x40020058
24001954:	40020070 	.word	0x40020070
24001958:	40020088 	.word	0x40020088
2400195c:	400200a0 	.word	0x400200a0
24001960:	400200b8 	.word	0x400200b8
24001964:	40020410 	.word	0x40020410
24001968:	40020428 	.word	0x40020428
2400196c:	40020440 	.word	0x40020440
24001970:	40020458 	.word	0x40020458
24001974:	40020470 	.word	0x40020470
24001978:	40020488 	.word	0x40020488
2400197c:	400204a0 	.word	0x400204a0
24001980:	400204b8 	.word	0x400204b8
    while((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_EN) != 0U)
24001984:	687b      	ldr	r3, [r7, #4]
24001986:	681b      	ldr	r3, [r3, #0]
24001988:	681b      	ldr	r3, [r3, #0]
2400198a:	f003 0301 	and.w	r3, r3, #1
2400198e:	2b00      	cmp	r3, #0
24001990:	d1c8      	bne.n	24001924 <HAL_DMA_Init+0x198>
      }
    }

    /* Get the CR register value */
    registerValue = ((DMA_Stream_TypeDef   *)hdma->Instance)->CR;
24001992:	687b      	ldr	r3, [r7, #4]
24001994:	681b      	ldr	r3, [r3, #0]
24001996:	681b      	ldr	r3, [r3, #0]
24001998:	617b      	str	r3, [r7, #20]

    /* Clear CHSEL, MBURST, PBURST, PL, MSIZE, PSIZE, MINC, PINC, CIRC, DIR, CT and DBM bits */
    registerValue &= ((uint32_t)~(DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
2400199a:	697a      	ldr	r2, [r7, #20]
2400199c:	4b83      	ldr	r3, [pc, #524]	; (24001bac <HAL_DMA_Init+0x420>)
2400199e:	4013      	ands	r3, r2
240019a0:	617b      	str	r3, [r7, #20]
                        DMA_SxCR_PL    | DMA_SxCR_MSIZE  | DMA_SxCR_PSIZE  | \
                        DMA_SxCR_MINC  | DMA_SxCR_PINC   | DMA_SxCR_CIRC   | \
                        DMA_SxCR_DIR   | DMA_SxCR_CT     | DMA_SxCR_DBM));

    /* Prepare the DMA Stream configuration */
    registerValue |=  hdma->Init.Direction           |
240019a2:	687b      	ldr	r3, [r7, #4]
240019a4:	689a      	ldr	r2, [r3, #8]
            hdma->Init.PeriphInc           | hdma->Init.MemInc           |
240019a6:	687b      	ldr	r3, [r7, #4]
240019a8:	68db      	ldr	r3, [r3, #12]
    registerValue |=  hdma->Init.Direction           |
240019aa:	431a      	orrs	r2, r3
            hdma->Init.PeriphInc           | hdma->Init.MemInc           |
240019ac:	687b      	ldr	r3, [r7, #4]
240019ae:	691b      	ldr	r3, [r3, #16]
240019b0:	431a      	orrs	r2, r3
            hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
240019b2:	687b      	ldr	r3, [r7, #4]
240019b4:	695b      	ldr	r3, [r3, #20]
            hdma->Init.PeriphInc           | hdma->Init.MemInc           |
240019b6:	431a      	orrs	r2, r3
            hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
240019b8:	687b      	ldr	r3, [r7, #4]
240019ba:	699b      	ldr	r3, [r3, #24]
240019bc:	431a      	orrs	r2, r3
            hdma->Init.Mode                | hdma->Init.Priority;
240019be:	687b      	ldr	r3, [r7, #4]
240019c0:	69db      	ldr	r3, [r3, #28]
            hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
240019c2:	431a      	orrs	r2, r3
            hdma->Init.Mode                | hdma->Init.Priority;
240019c4:	687b      	ldr	r3, [r7, #4]
240019c6:	6a1b      	ldr	r3, [r3, #32]
240019c8:	4313      	orrs	r3, r2
    registerValue |=  hdma->Init.Direction           |
240019ca:	697a      	ldr	r2, [r7, #20]
240019cc:	4313      	orrs	r3, r2
240019ce:	617b      	str	r3, [r7, #20]

    /* the Memory burst and peripheral burst are not used when the FIFO is disabled */
    if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
240019d0:	687b      	ldr	r3, [r7, #4]
240019d2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
240019d4:	2b04      	cmp	r3, #4
240019d6:	d107      	bne.n	240019e8 <HAL_DMA_Init+0x25c>
    {
      /* Get memory burst and peripheral burst */
      registerValue |=  hdma->Init.MemBurst | hdma->Init.PeriphBurst;
240019d8:	687b      	ldr	r3, [r7, #4]
240019da:	6ada      	ldr	r2, [r3, #44]	; 0x2c
240019dc:	687b      	ldr	r3, [r7, #4]
240019de:	6b1b      	ldr	r3, [r3, #48]	; 0x30
240019e0:	4313      	orrs	r3, r2
240019e2:	697a      	ldr	r2, [r7, #20]
240019e4:	4313      	orrs	r3, r2
240019e6:	617b      	str	r3, [r7, #20]
    }

    /* Work around for Errata 2.22: UART/USART- DMA transfer lock: DMA stream could be
                                    lock when transfering data to/from USART/UART */
#if (STM32H7_DEV_ID == 0x450UL)
    if((DBGMCU->IDCODE & 0xFFFF0000U) >= 0x20000000U)
240019e8:	4b71      	ldr	r3, [pc, #452]	; (24001bb0 <HAL_DMA_Init+0x424>)
240019ea:	681a      	ldr	r2, [r3, #0]
240019ec:	4b71      	ldr	r3, [pc, #452]	; (24001bb4 <HAL_DMA_Init+0x428>)
240019ee:	4013      	ands	r3, r2
240019f0:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
240019f4:	d328      	bcc.n	24001a48 <HAL_DMA_Init+0x2bc>
    {
#endif /* STM32H7_DEV_ID == 0x450UL */
      if(IS_DMA_UART_USART_REQUEST(hdma->Init.Request) != 0U)
240019f6:	687b      	ldr	r3, [r7, #4]
240019f8:	685b      	ldr	r3, [r3, #4]
240019fa:	2b28      	cmp	r3, #40	; 0x28
240019fc:	d903      	bls.n	24001a06 <HAL_DMA_Init+0x27a>
240019fe:	687b      	ldr	r3, [r7, #4]
24001a00:	685b      	ldr	r3, [r3, #4]
24001a02:	2b2e      	cmp	r3, #46	; 0x2e
24001a04:	d917      	bls.n	24001a36 <HAL_DMA_Init+0x2aa>
24001a06:	687b      	ldr	r3, [r7, #4]
24001a08:	685b      	ldr	r3, [r3, #4]
24001a0a:	2b3e      	cmp	r3, #62	; 0x3e
24001a0c:	d903      	bls.n	24001a16 <HAL_DMA_Init+0x28a>
24001a0e:	687b      	ldr	r3, [r7, #4]
24001a10:	685b      	ldr	r3, [r3, #4]
24001a12:	2b42      	cmp	r3, #66	; 0x42
24001a14:	d90f      	bls.n	24001a36 <HAL_DMA_Init+0x2aa>
24001a16:	687b      	ldr	r3, [r7, #4]
24001a18:	685b      	ldr	r3, [r3, #4]
24001a1a:	2b46      	cmp	r3, #70	; 0x46
24001a1c:	d903      	bls.n	24001a26 <HAL_DMA_Init+0x29a>
24001a1e:	687b      	ldr	r3, [r7, #4]
24001a20:	685b      	ldr	r3, [r3, #4]
24001a22:	2b48      	cmp	r3, #72	; 0x48
24001a24:	d907      	bls.n	24001a36 <HAL_DMA_Init+0x2aa>
24001a26:	687b      	ldr	r3, [r7, #4]
24001a28:	685b      	ldr	r3, [r3, #4]
24001a2a:	2b4e      	cmp	r3, #78	; 0x4e
24001a2c:	d905      	bls.n	24001a3a <HAL_DMA_Init+0x2ae>
24001a2e:	687b      	ldr	r3, [r7, #4]
24001a30:	685b      	ldr	r3, [r3, #4]
24001a32:	2b52      	cmp	r3, #82	; 0x52
24001a34:	d801      	bhi.n	24001a3a <HAL_DMA_Init+0x2ae>
24001a36:	2301      	movs	r3, #1
24001a38:	e000      	b.n	24001a3c <HAL_DMA_Init+0x2b0>
24001a3a:	2300      	movs	r3, #0
24001a3c:	2b00      	cmp	r3, #0
24001a3e:	d003      	beq.n	24001a48 <HAL_DMA_Init+0x2bc>
      {
        registerValue |= DMA_SxCR_TRBUFF;
24001a40:	697b      	ldr	r3, [r7, #20]
24001a42:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
24001a46:	617b      	str	r3, [r7, #20]
#if (STM32H7_DEV_ID == 0x450UL)
    }
#endif /* STM32H7_DEV_ID == 0x450UL */

    /* Write to DMA Stream CR register */
    ((DMA_Stream_TypeDef   *)hdma->Instance)->CR = registerValue;
24001a48:	687b      	ldr	r3, [r7, #4]
24001a4a:	681b      	ldr	r3, [r3, #0]
24001a4c:	697a      	ldr	r2, [r7, #20]
24001a4e:	601a      	str	r2, [r3, #0]

    /* Get the FCR register value */
    registerValue = ((DMA_Stream_TypeDef   *)hdma->Instance)->FCR;
24001a50:	687b      	ldr	r3, [r7, #4]
24001a52:	681b      	ldr	r3, [r3, #0]
24001a54:	695b      	ldr	r3, [r3, #20]
24001a56:	617b      	str	r3, [r7, #20]

    /* Clear Direct mode and FIFO threshold bits */
    registerValue &= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);
24001a58:	697b      	ldr	r3, [r7, #20]
24001a5a:	f023 0307 	bic.w	r3, r3, #7
24001a5e:	617b      	str	r3, [r7, #20]

    /* Prepare the DMA Stream FIFO configuration */
    registerValue |= hdma->Init.FIFOMode;
24001a60:	687b      	ldr	r3, [r7, #4]
24001a62:	6a5b      	ldr	r3, [r3, #36]	; 0x24
24001a64:	697a      	ldr	r2, [r7, #20]
24001a66:	4313      	orrs	r3, r2
24001a68:	617b      	str	r3, [r7, #20]

    /* the FIFO threshold is not used when the FIFO mode is disabled */
    if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
24001a6a:	687b      	ldr	r3, [r7, #4]
24001a6c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
24001a6e:	2b04      	cmp	r3, #4
24001a70:	d117      	bne.n	24001aa2 <HAL_DMA_Init+0x316>
    {
      /* Get the FIFO threshold */
      registerValue |= hdma->Init.FIFOThreshold;
24001a72:	687b      	ldr	r3, [r7, #4]
24001a74:	6a9b      	ldr	r3, [r3, #40]	; 0x28
24001a76:	697a      	ldr	r2, [r7, #20]
24001a78:	4313      	orrs	r3, r2
24001a7a:	617b      	str	r3, [r7, #20]

      /* Check compatibility between FIFO threshold level and size of the memory burst */
      /* for INCR4, INCR8, INCR16 */
      if(hdma->Init.MemBurst != DMA_MBURST_SINGLE)
24001a7c:	687b      	ldr	r3, [r7, #4]
24001a7e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24001a80:	2b00      	cmp	r3, #0
24001a82:	d00e      	beq.n	24001aa2 <HAL_DMA_Init+0x316>
      {
        if (DMA_CheckFifoParam(hdma) != HAL_OK)
24001a84:	6878      	ldr	r0, [r7, #4]
24001a86:	f003 fb41 	bl	2400510c <DMA_CheckFifoParam>
24001a8a:	4603      	mov	r3, r0
24001a8c:	2b00      	cmp	r3, #0
24001a8e:	d008      	beq.n	24001aa2 <HAL_DMA_Init+0x316>
        {
          /* Update error code */
          hdma->ErrorCode = HAL_DMA_ERROR_PARAM;
24001a90:	687b      	ldr	r3, [r7, #4]
24001a92:	2240      	movs	r2, #64	; 0x40
24001a94:	655a      	str	r2, [r3, #84]	; 0x54

          /* Change the DMA state */
          hdma->State = HAL_DMA_STATE_READY;
24001a96:	687b      	ldr	r3, [r7, #4]
24001a98:	2201      	movs	r2, #1
24001a9a:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

          return HAL_ERROR;
24001a9e:	2301      	movs	r3, #1
24001aa0:	e197      	b.n	24001dd2 <HAL_DMA_Init+0x646>
        }
      }
    }

    /* Write to DMA Stream FCR */
    ((DMA_Stream_TypeDef   *)hdma->Instance)->FCR = registerValue;
24001aa2:	687b      	ldr	r3, [r7, #4]
24001aa4:	681b      	ldr	r3, [r3, #0]
24001aa6:	697a      	ldr	r2, [r7, #20]
24001aa8:	615a      	str	r2, [r3, #20]

    /* Initialize StreamBaseAddress and StreamIndex parameters to be used to calculate
       DMA steam Base Address needed by HAL_DMA_IRQHandler() and HAL_DMA_PollForTransfer() */
    regs_dma = (DMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
24001aaa:	6878      	ldr	r0, [r7, #4]
24001aac:	f003 fa7c 	bl	24004fa8 <DMA_CalcBaseAndBitshift>
24001ab0:	4603      	mov	r3, r0
24001ab2:	60bb      	str	r3, [r7, #8]

    /* Clear all interrupt flags */
    regs_dma->IFCR = 0x3FUL << (hdma->StreamIndex & 0x1FU);
24001ab4:	687b      	ldr	r3, [r7, #4]
24001ab6:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24001ab8:	f003 031f 	and.w	r3, r3, #31
24001abc:	223f      	movs	r2, #63	; 0x3f
24001abe:	409a      	lsls	r2, r3
24001ac0:	68bb      	ldr	r3, [r7, #8]
24001ac2:	609a      	str	r2, [r3, #8]
24001ac4:	e0cd      	b.n	24001c62 <HAL_DMA_Init+0x4d6>
  }
  else if(IS_BDMA_CHANNEL_INSTANCE(hdma->Instance) != 0U) /* BDMA instance(s) */
24001ac6:	687b      	ldr	r3, [r7, #4]
24001ac8:	681b      	ldr	r3, [r3, #0]
24001aca:	4a3b      	ldr	r2, [pc, #236]	; (24001bb8 <HAL_DMA_Init+0x42c>)
24001acc:	4293      	cmp	r3, r2
24001ace:	d022      	beq.n	24001b16 <HAL_DMA_Init+0x38a>
24001ad0:	687b      	ldr	r3, [r7, #4]
24001ad2:	681b      	ldr	r3, [r3, #0]
24001ad4:	4a39      	ldr	r2, [pc, #228]	; (24001bbc <HAL_DMA_Init+0x430>)
24001ad6:	4293      	cmp	r3, r2
24001ad8:	d01d      	beq.n	24001b16 <HAL_DMA_Init+0x38a>
24001ada:	687b      	ldr	r3, [r7, #4]
24001adc:	681b      	ldr	r3, [r3, #0]
24001ade:	4a38      	ldr	r2, [pc, #224]	; (24001bc0 <HAL_DMA_Init+0x434>)
24001ae0:	4293      	cmp	r3, r2
24001ae2:	d018      	beq.n	24001b16 <HAL_DMA_Init+0x38a>
24001ae4:	687b      	ldr	r3, [r7, #4]
24001ae6:	681b      	ldr	r3, [r3, #0]
24001ae8:	4a36      	ldr	r2, [pc, #216]	; (24001bc4 <HAL_DMA_Init+0x438>)
24001aea:	4293      	cmp	r3, r2
24001aec:	d013      	beq.n	24001b16 <HAL_DMA_Init+0x38a>
24001aee:	687b      	ldr	r3, [r7, #4]
24001af0:	681b      	ldr	r3, [r3, #0]
24001af2:	4a35      	ldr	r2, [pc, #212]	; (24001bc8 <HAL_DMA_Init+0x43c>)
24001af4:	4293      	cmp	r3, r2
24001af6:	d00e      	beq.n	24001b16 <HAL_DMA_Init+0x38a>
24001af8:	687b      	ldr	r3, [r7, #4]
24001afa:	681b      	ldr	r3, [r3, #0]
24001afc:	4a33      	ldr	r2, [pc, #204]	; (24001bcc <HAL_DMA_Init+0x440>)
24001afe:	4293      	cmp	r3, r2
24001b00:	d009      	beq.n	24001b16 <HAL_DMA_Init+0x38a>
24001b02:	687b      	ldr	r3, [r7, #4]
24001b04:	681b      	ldr	r3, [r3, #0]
24001b06:	4a32      	ldr	r2, [pc, #200]	; (24001bd0 <HAL_DMA_Init+0x444>)
24001b08:	4293      	cmp	r3, r2
24001b0a:	d004      	beq.n	24001b16 <HAL_DMA_Init+0x38a>
24001b0c:	687b      	ldr	r3, [r7, #4]
24001b0e:	681b      	ldr	r3, [r3, #0]
24001b10:	4a30      	ldr	r2, [pc, #192]	; (24001bd4 <HAL_DMA_Init+0x448>)
24001b12:	4293      	cmp	r3, r2
24001b14:	d101      	bne.n	24001b1a <HAL_DMA_Init+0x38e>
24001b16:	2301      	movs	r3, #1
24001b18:	e000      	b.n	24001b1c <HAL_DMA_Init+0x390>
24001b1a:	2300      	movs	r3, #0
24001b1c:	2b00      	cmp	r3, #0
24001b1e:	f000 8097 	beq.w	24001c50 <HAL_DMA_Init+0x4c4>
  {
    if(IS_BDMA_CHANNEL_DMAMUX_INSTANCE(hdma->Instance) != 0U)
24001b22:	687b      	ldr	r3, [r7, #4]
24001b24:	681b      	ldr	r3, [r3, #0]
24001b26:	4a24      	ldr	r2, [pc, #144]	; (24001bb8 <HAL_DMA_Init+0x42c>)
24001b28:	4293      	cmp	r3, r2
24001b2a:	d021      	beq.n	24001b70 <HAL_DMA_Init+0x3e4>
24001b2c:	687b      	ldr	r3, [r7, #4]
24001b2e:	681b      	ldr	r3, [r3, #0]
24001b30:	4a22      	ldr	r2, [pc, #136]	; (24001bbc <HAL_DMA_Init+0x430>)
24001b32:	4293      	cmp	r3, r2
24001b34:	d01c      	beq.n	24001b70 <HAL_DMA_Init+0x3e4>
24001b36:	687b      	ldr	r3, [r7, #4]
24001b38:	681b      	ldr	r3, [r3, #0]
24001b3a:	4a21      	ldr	r2, [pc, #132]	; (24001bc0 <HAL_DMA_Init+0x434>)
24001b3c:	4293      	cmp	r3, r2
24001b3e:	d017      	beq.n	24001b70 <HAL_DMA_Init+0x3e4>
24001b40:	687b      	ldr	r3, [r7, #4]
24001b42:	681b      	ldr	r3, [r3, #0]
24001b44:	4a1f      	ldr	r2, [pc, #124]	; (24001bc4 <HAL_DMA_Init+0x438>)
24001b46:	4293      	cmp	r3, r2
24001b48:	d012      	beq.n	24001b70 <HAL_DMA_Init+0x3e4>
24001b4a:	687b      	ldr	r3, [r7, #4]
24001b4c:	681b      	ldr	r3, [r3, #0]
24001b4e:	4a1e      	ldr	r2, [pc, #120]	; (24001bc8 <HAL_DMA_Init+0x43c>)
24001b50:	4293      	cmp	r3, r2
24001b52:	d00d      	beq.n	24001b70 <HAL_DMA_Init+0x3e4>
24001b54:	687b      	ldr	r3, [r7, #4]
24001b56:	681b      	ldr	r3, [r3, #0]
24001b58:	4a1c      	ldr	r2, [pc, #112]	; (24001bcc <HAL_DMA_Init+0x440>)
24001b5a:	4293      	cmp	r3, r2
24001b5c:	d008      	beq.n	24001b70 <HAL_DMA_Init+0x3e4>
24001b5e:	687b      	ldr	r3, [r7, #4]
24001b60:	681b      	ldr	r3, [r3, #0]
24001b62:	4a1b      	ldr	r2, [pc, #108]	; (24001bd0 <HAL_DMA_Init+0x444>)
24001b64:	4293      	cmp	r3, r2
24001b66:	d003      	beq.n	24001b70 <HAL_DMA_Init+0x3e4>
24001b68:	687b      	ldr	r3, [r7, #4]
24001b6a:	681b      	ldr	r3, [r3, #0]
24001b6c:	4a19      	ldr	r2, [pc, #100]	; (24001bd4 <HAL_DMA_Init+0x448>)
24001b6e:	4293      	cmp	r3, r2
24001b70:	bf00      	nop
      /* Check the request parameter */
      assert_param(IS_BDMA_REQUEST(hdma->Init.Request));
    }

    /* Allocate lock resource */
    __HAL_UNLOCK(hdma);
24001b72:	687b      	ldr	r3, [r7, #4]
24001b74:	2200      	movs	r2, #0
24001b76:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

    /* Change DMA peripheral state */
    hdma->State = HAL_DMA_STATE_BUSY;
24001b7a:	687b      	ldr	r3, [r7, #4]
24001b7c:	2202      	movs	r2, #2
24001b7e:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

    /* Get the CR register value */
    registerValue = ((BDMA_Channel_TypeDef *)hdma->Instance)->CCR;
24001b82:	687b      	ldr	r3, [r7, #4]
24001b84:	681b      	ldr	r3, [r3, #0]
24001b86:	681b      	ldr	r3, [r3, #0]
24001b88:	617b      	str	r3, [r7, #20]

    /* Clear PL, MSIZE, PSIZE, MINC, PINC, CIRC, DIR, MEM2MEM, DBM and CT bits */
    registerValue &= ((uint32_t)~(BDMA_CCR_PL    | BDMA_CCR_MSIZE   | BDMA_CCR_PSIZE  | \
24001b8a:	697a      	ldr	r2, [r7, #20]
24001b8c:	4b12      	ldr	r3, [pc, #72]	; (24001bd8 <HAL_DMA_Init+0x44c>)
24001b8e:	4013      	ands	r3, r2
24001b90:	617b      	str	r3, [r7, #20]
                                  BDMA_CCR_MINC  | BDMA_CCR_PINC    | BDMA_CCR_CIRC   | \
                                  BDMA_CCR_DIR   | BDMA_CCR_MEM2MEM | BDMA_CCR_DBM    | \
                                  BDMA_CCR_CT));

    /* Prepare the DMA Channel configuration */
    registerValue |=  DMA_TO_BDMA_DIRECTION(hdma->Init.Direction)            |
24001b92:	687b      	ldr	r3, [r7, #4]
24001b94:	689b      	ldr	r3, [r3, #8]
24001b96:	2b40      	cmp	r3, #64	; 0x40
24001b98:	d020      	beq.n	24001bdc <HAL_DMA_Init+0x450>
24001b9a:	687b      	ldr	r3, [r7, #4]
24001b9c:	689b      	ldr	r3, [r3, #8]
24001b9e:	2b80      	cmp	r3, #128	; 0x80
24001ba0:	d102      	bne.n	24001ba8 <HAL_DMA_Init+0x41c>
24001ba2:	f44f 4380 	mov.w	r3, #16384	; 0x4000
24001ba6:	e01a      	b.n	24001bde <HAL_DMA_Init+0x452>
24001ba8:	2300      	movs	r3, #0
24001baa:	e018      	b.n	24001bde <HAL_DMA_Init+0x452>
24001bac:	fe10803f 	.word	0xfe10803f
24001bb0:	5c001000 	.word	0x5c001000
24001bb4:	ffff0000 	.word	0xffff0000
24001bb8:	58025408 	.word	0x58025408
24001bbc:	5802541c 	.word	0x5802541c
24001bc0:	58025430 	.word	0x58025430
24001bc4:	58025444 	.word	0x58025444
24001bc8:	58025458 	.word	0x58025458
24001bcc:	5802546c 	.word	0x5802546c
24001bd0:	58025480 	.word	0x58025480
24001bd4:	58025494 	.word	0x58025494
24001bd8:	fffe000f 	.word	0xfffe000f
24001bdc:	2310      	movs	r3, #16
                      DMA_TO_BDMA_PERIPHERAL_INC(hdma->Init.PeriphInc)       |
24001bde:	687a      	ldr	r2, [r7, #4]
24001be0:	68d2      	ldr	r2, [r2, #12]
24001be2:	08d2      	lsrs	r2, r2, #3
    registerValue |=  DMA_TO_BDMA_DIRECTION(hdma->Init.Direction)            |
24001be4:	431a      	orrs	r2, r3
                      DMA_TO_BDMA_MEMORY_INC(hdma->Init.MemInc)              |
24001be6:	687b      	ldr	r3, [r7, #4]
24001be8:	691b      	ldr	r3, [r3, #16]
24001bea:	08db      	lsrs	r3, r3, #3
                      DMA_TO_BDMA_PERIPHERAL_INC(hdma->Init.PeriphInc)       |
24001bec:	431a      	orrs	r2, r3
                      DMA_TO_BDMA_PDATA_SIZE(hdma->Init.PeriphDataAlignment) |
24001bee:	687b      	ldr	r3, [r7, #4]
24001bf0:	695b      	ldr	r3, [r3, #20]
24001bf2:	08db      	lsrs	r3, r3, #3
                      DMA_TO_BDMA_MEMORY_INC(hdma->Init.MemInc)              |
24001bf4:	431a      	orrs	r2, r3
                      DMA_TO_BDMA_MDATA_SIZE(hdma->Init.MemDataAlignment)    |
24001bf6:	687b      	ldr	r3, [r7, #4]
24001bf8:	699b      	ldr	r3, [r3, #24]
24001bfa:	08db      	lsrs	r3, r3, #3
                      DMA_TO_BDMA_PDATA_SIZE(hdma->Init.PeriphDataAlignment) |
24001bfc:	431a      	orrs	r2, r3
                      DMA_TO_BDMA_MODE(hdma->Init.Mode)                      |
24001bfe:	687b      	ldr	r3, [r7, #4]
24001c00:	69db      	ldr	r3, [r3, #28]
24001c02:	08db      	lsrs	r3, r3, #3
                      DMA_TO_BDMA_MDATA_SIZE(hdma->Init.MemDataAlignment)    |
24001c04:	431a      	orrs	r2, r3
                      DMA_TO_BDMA_PRIORITY(hdma->Init.Priority);
24001c06:	687b      	ldr	r3, [r7, #4]
24001c08:	6a1b      	ldr	r3, [r3, #32]
24001c0a:	091b      	lsrs	r3, r3, #4
                      DMA_TO_BDMA_MODE(hdma->Init.Mode)                      |
24001c0c:	4313      	orrs	r3, r2
    registerValue |=  DMA_TO_BDMA_DIRECTION(hdma->Init.Direction)            |
24001c0e:	697a      	ldr	r2, [r7, #20]
24001c10:	4313      	orrs	r3, r2
24001c12:	617b      	str	r3, [r7, #20]

    /* Write to DMA Channel CR register */
    ((BDMA_Channel_TypeDef *)hdma->Instance)->CCR = registerValue;
24001c14:	687b      	ldr	r3, [r7, #4]
24001c16:	681b      	ldr	r3, [r3, #0]
24001c18:	697a      	ldr	r2, [r7, #20]
24001c1a:	601a      	str	r2, [r3, #0]

    /* calculation of the channel index */
    hdma->StreamIndex = (((uint32_t)((uint32_t*)hdma->Instance) - (uint32_t)BDMA_Channel0) / ((uint32_t)BDMA_Channel1 - (uint32_t)BDMA_Channel0)) << 2U;
24001c1c:	687b      	ldr	r3, [r7, #4]
24001c1e:	681b      	ldr	r3, [r3, #0]
24001c20:	461a      	mov	r2, r3
24001c22:	4b6e      	ldr	r3, [pc, #440]	; (24001ddc <HAL_DMA_Init+0x650>)
24001c24:	4413      	add	r3, r2
24001c26:	4a6e      	ldr	r2, [pc, #440]	; (24001de0 <HAL_DMA_Init+0x654>)
24001c28:	fba2 2303 	umull	r2, r3, r2, r3
24001c2c:	091b      	lsrs	r3, r3, #4
24001c2e:	009a      	lsls	r2, r3, #2
24001c30:	687b      	ldr	r3, [r7, #4]
24001c32:	65da      	str	r2, [r3, #92]	; 0x5c

    /* Initialize StreamBaseAddress and StreamIndex parameters to be used to calculate
    DMA steam Base Address needed by HAL_DMA_IRQHandler() and HAL_DMA_PollForTransfer() */
    regs_bdma = (BDMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
24001c34:	6878      	ldr	r0, [r7, #4]
24001c36:	f003 f9b7 	bl	24004fa8 <DMA_CalcBaseAndBitshift>
24001c3a:	4603      	mov	r3, r0
24001c3c:	60fb      	str	r3, [r7, #12]

    /* Clear all interrupt flags */
    regs_bdma->IFCR = ((BDMA_IFCR_CGIF0) << (hdma->StreamIndex & 0x1FU));
24001c3e:	687b      	ldr	r3, [r7, #4]
24001c40:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24001c42:	f003 031f 	and.w	r3, r3, #31
24001c46:	2201      	movs	r2, #1
24001c48:	409a      	lsls	r2, r3
24001c4a:	68fb      	ldr	r3, [r7, #12]
24001c4c:	605a      	str	r2, [r3, #4]
24001c4e:	e008      	b.n	24001c62 <HAL_DMA_Init+0x4d6>
  }
  else
  {
    hdma->ErrorCode = HAL_DMA_ERROR_PARAM;
24001c50:	687b      	ldr	r3, [r7, #4]
24001c52:	2240      	movs	r2, #64	; 0x40
24001c54:	655a      	str	r2, [r3, #84]	; 0x54
    hdma->State     = HAL_DMA_STATE_ERROR;
24001c56:	687b      	ldr	r3, [r7, #4]
24001c58:	2203      	movs	r2, #3
24001c5a:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

    return HAL_ERROR;
24001c5e:	2301      	movs	r3, #1
24001c60:	e0b7      	b.n	24001dd2 <HAL_DMA_Init+0x646>
  }

  if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
24001c62:	687b      	ldr	r3, [r7, #4]
24001c64:	681b      	ldr	r3, [r3, #0]
24001c66:	4a5f      	ldr	r2, [pc, #380]	; (24001de4 <HAL_DMA_Init+0x658>)
24001c68:	4293      	cmp	r3, r2
24001c6a:	d072      	beq.n	24001d52 <HAL_DMA_Init+0x5c6>
24001c6c:	687b      	ldr	r3, [r7, #4]
24001c6e:	681b      	ldr	r3, [r3, #0]
24001c70:	4a5d      	ldr	r2, [pc, #372]	; (24001de8 <HAL_DMA_Init+0x65c>)
24001c72:	4293      	cmp	r3, r2
24001c74:	d06d      	beq.n	24001d52 <HAL_DMA_Init+0x5c6>
24001c76:	687b      	ldr	r3, [r7, #4]
24001c78:	681b      	ldr	r3, [r3, #0]
24001c7a:	4a5c      	ldr	r2, [pc, #368]	; (24001dec <HAL_DMA_Init+0x660>)
24001c7c:	4293      	cmp	r3, r2
24001c7e:	d068      	beq.n	24001d52 <HAL_DMA_Init+0x5c6>
24001c80:	687b      	ldr	r3, [r7, #4]
24001c82:	681b      	ldr	r3, [r3, #0]
24001c84:	4a5a      	ldr	r2, [pc, #360]	; (24001df0 <HAL_DMA_Init+0x664>)
24001c86:	4293      	cmp	r3, r2
24001c88:	d063      	beq.n	24001d52 <HAL_DMA_Init+0x5c6>
24001c8a:	687b      	ldr	r3, [r7, #4]
24001c8c:	681b      	ldr	r3, [r3, #0]
24001c8e:	4a59      	ldr	r2, [pc, #356]	; (24001df4 <HAL_DMA_Init+0x668>)
24001c90:	4293      	cmp	r3, r2
24001c92:	d05e      	beq.n	24001d52 <HAL_DMA_Init+0x5c6>
24001c94:	687b      	ldr	r3, [r7, #4]
24001c96:	681b      	ldr	r3, [r3, #0]
24001c98:	4a57      	ldr	r2, [pc, #348]	; (24001df8 <HAL_DMA_Init+0x66c>)
24001c9a:	4293      	cmp	r3, r2
24001c9c:	d059      	beq.n	24001d52 <HAL_DMA_Init+0x5c6>
24001c9e:	687b      	ldr	r3, [r7, #4]
24001ca0:	681b      	ldr	r3, [r3, #0]
24001ca2:	4a56      	ldr	r2, [pc, #344]	; (24001dfc <HAL_DMA_Init+0x670>)
24001ca4:	4293      	cmp	r3, r2
24001ca6:	d054      	beq.n	24001d52 <HAL_DMA_Init+0x5c6>
24001ca8:	687b      	ldr	r3, [r7, #4]
24001caa:	681b      	ldr	r3, [r3, #0]
24001cac:	4a54      	ldr	r2, [pc, #336]	; (24001e00 <HAL_DMA_Init+0x674>)
24001cae:	4293      	cmp	r3, r2
24001cb0:	d04f      	beq.n	24001d52 <HAL_DMA_Init+0x5c6>
24001cb2:	687b      	ldr	r3, [r7, #4]
24001cb4:	681b      	ldr	r3, [r3, #0]
24001cb6:	4a53      	ldr	r2, [pc, #332]	; (24001e04 <HAL_DMA_Init+0x678>)
24001cb8:	4293      	cmp	r3, r2
24001cba:	d04a      	beq.n	24001d52 <HAL_DMA_Init+0x5c6>
24001cbc:	687b      	ldr	r3, [r7, #4]
24001cbe:	681b      	ldr	r3, [r3, #0]
24001cc0:	4a51      	ldr	r2, [pc, #324]	; (24001e08 <HAL_DMA_Init+0x67c>)
24001cc2:	4293      	cmp	r3, r2
24001cc4:	d045      	beq.n	24001d52 <HAL_DMA_Init+0x5c6>
24001cc6:	687b      	ldr	r3, [r7, #4]
24001cc8:	681b      	ldr	r3, [r3, #0]
24001cca:	4a50      	ldr	r2, [pc, #320]	; (24001e0c <HAL_DMA_Init+0x680>)
24001ccc:	4293      	cmp	r3, r2
24001cce:	d040      	beq.n	24001d52 <HAL_DMA_Init+0x5c6>
24001cd0:	687b      	ldr	r3, [r7, #4]
24001cd2:	681b      	ldr	r3, [r3, #0]
24001cd4:	4a4e      	ldr	r2, [pc, #312]	; (24001e10 <HAL_DMA_Init+0x684>)
24001cd6:	4293      	cmp	r3, r2
24001cd8:	d03b      	beq.n	24001d52 <HAL_DMA_Init+0x5c6>
24001cda:	687b      	ldr	r3, [r7, #4]
24001cdc:	681b      	ldr	r3, [r3, #0]
24001cde:	4a4d      	ldr	r2, [pc, #308]	; (24001e14 <HAL_DMA_Init+0x688>)
24001ce0:	4293      	cmp	r3, r2
24001ce2:	d036      	beq.n	24001d52 <HAL_DMA_Init+0x5c6>
24001ce4:	687b      	ldr	r3, [r7, #4]
24001ce6:	681b      	ldr	r3, [r3, #0]
24001ce8:	4a4b      	ldr	r2, [pc, #300]	; (24001e18 <HAL_DMA_Init+0x68c>)
24001cea:	4293      	cmp	r3, r2
24001cec:	d031      	beq.n	24001d52 <HAL_DMA_Init+0x5c6>
24001cee:	687b      	ldr	r3, [r7, #4]
24001cf0:	681b      	ldr	r3, [r3, #0]
24001cf2:	4a4a      	ldr	r2, [pc, #296]	; (24001e1c <HAL_DMA_Init+0x690>)
24001cf4:	4293      	cmp	r3, r2
24001cf6:	d02c      	beq.n	24001d52 <HAL_DMA_Init+0x5c6>
24001cf8:	687b      	ldr	r3, [r7, #4]
24001cfa:	681b      	ldr	r3, [r3, #0]
24001cfc:	4a48      	ldr	r2, [pc, #288]	; (24001e20 <HAL_DMA_Init+0x694>)
24001cfe:	4293      	cmp	r3, r2
24001d00:	d027      	beq.n	24001d52 <HAL_DMA_Init+0x5c6>
24001d02:	687b      	ldr	r3, [r7, #4]
24001d04:	681b      	ldr	r3, [r3, #0]
24001d06:	4a47      	ldr	r2, [pc, #284]	; (24001e24 <HAL_DMA_Init+0x698>)
24001d08:	4293      	cmp	r3, r2
24001d0a:	d022      	beq.n	24001d52 <HAL_DMA_Init+0x5c6>
24001d0c:	687b      	ldr	r3, [r7, #4]
24001d0e:	681b      	ldr	r3, [r3, #0]
24001d10:	4a45      	ldr	r2, [pc, #276]	; (24001e28 <HAL_DMA_Init+0x69c>)
24001d12:	4293      	cmp	r3, r2
24001d14:	d01d      	beq.n	24001d52 <HAL_DMA_Init+0x5c6>
24001d16:	687b      	ldr	r3, [r7, #4]
24001d18:	681b      	ldr	r3, [r3, #0]
24001d1a:	4a44      	ldr	r2, [pc, #272]	; (24001e2c <HAL_DMA_Init+0x6a0>)
24001d1c:	4293      	cmp	r3, r2
24001d1e:	d018      	beq.n	24001d52 <HAL_DMA_Init+0x5c6>
24001d20:	687b      	ldr	r3, [r7, #4]
24001d22:	681b      	ldr	r3, [r3, #0]
24001d24:	4a42      	ldr	r2, [pc, #264]	; (24001e30 <HAL_DMA_Init+0x6a4>)
24001d26:	4293      	cmp	r3, r2
24001d28:	d013      	beq.n	24001d52 <HAL_DMA_Init+0x5c6>
24001d2a:	687b      	ldr	r3, [r7, #4]
24001d2c:	681b      	ldr	r3, [r3, #0]
24001d2e:	4a41      	ldr	r2, [pc, #260]	; (24001e34 <HAL_DMA_Init+0x6a8>)
24001d30:	4293      	cmp	r3, r2
24001d32:	d00e      	beq.n	24001d52 <HAL_DMA_Init+0x5c6>
24001d34:	687b      	ldr	r3, [r7, #4]
24001d36:	681b      	ldr	r3, [r3, #0]
24001d38:	4a3f      	ldr	r2, [pc, #252]	; (24001e38 <HAL_DMA_Init+0x6ac>)
24001d3a:	4293      	cmp	r3, r2
24001d3c:	d009      	beq.n	24001d52 <HAL_DMA_Init+0x5c6>
24001d3e:	687b      	ldr	r3, [r7, #4]
24001d40:	681b      	ldr	r3, [r3, #0]
24001d42:	4a3e      	ldr	r2, [pc, #248]	; (24001e3c <HAL_DMA_Init+0x6b0>)
24001d44:	4293      	cmp	r3, r2
24001d46:	d004      	beq.n	24001d52 <HAL_DMA_Init+0x5c6>
24001d48:	687b      	ldr	r3, [r7, #4]
24001d4a:	681b      	ldr	r3, [r3, #0]
24001d4c:	4a3c      	ldr	r2, [pc, #240]	; (24001e40 <HAL_DMA_Init+0x6b4>)
24001d4e:	4293      	cmp	r3, r2
24001d50:	d101      	bne.n	24001d56 <HAL_DMA_Init+0x5ca>
24001d52:	2301      	movs	r3, #1
24001d54:	e000      	b.n	24001d58 <HAL_DMA_Init+0x5cc>
24001d56:	2300      	movs	r3, #0
24001d58:	2b00      	cmp	r3, #0
24001d5a:	d032      	beq.n	24001dc2 <HAL_DMA_Init+0x636>
  {
    /* Initialize parameters for DMAMUX channel :
    DMAmuxChannel, DMAmuxChannelStatus and DMAmuxChannelStatusMask
    */
    DMA_CalcDMAMUXChannelBaseAndMask(hdma);
24001d5c:	6878      	ldr	r0, [r7, #4]
24001d5e:	f003 fa51 	bl	24005204 <DMA_CalcDMAMUXChannelBaseAndMask>

    if(hdma->Init.Direction == DMA_MEMORY_TO_MEMORY)
24001d62:	687b      	ldr	r3, [r7, #4]
24001d64:	689b      	ldr	r3, [r3, #8]
24001d66:	2b80      	cmp	r3, #128	; 0x80
24001d68:	d102      	bne.n	24001d70 <HAL_DMA_Init+0x5e4>
    {
      /* if memory to memory force the request to 0*/
      hdma->Init.Request = DMA_REQUEST_MEM2MEM;
24001d6a:	687b      	ldr	r3, [r7, #4]
24001d6c:	2200      	movs	r2, #0
24001d6e:	605a      	str	r2, [r3, #4]
    }

    /* Set peripheral request  to DMAMUX channel */
    hdma->DMAmuxChannel->CCR = (hdma->Init.Request & DMAMUX_CxCR_DMAREQ_ID);
24001d70:	687b      	ldr	r3, [r7, #4]
24001d72:	685a      	ldr	r2, [r3, #4]
24001d74:	687b      	ldr	r3, [r7, #4]
24001d76:	6e1b      	ldr	r3, [r3, #96]	; 0x60
24001d78:	b2d2      	uxtb	r2, r2
24001d7a:	601a      	str	r2, [r3, #0]

    /* Clear the DMAMUX synchro overrun flag */
    hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
24001d7c:	687b      	ldr	r3, [r7, #4]
24001d7e:	6e5b      	ldr	r3, [r3, #100]	; 0x64
24001d80:	687a      	ldr	r2, [r7, #4]
24001d82:	6e92      	ldr	r2, [r2, #104]	; 0x68
24001d84:	605a      	str	r2, [r3, #4]

    /* Initialize parameters for DMAMUX request generator :
    if the DMA request is DMA_REQUEST_GENERATOR0 to DMA_REQUEST_GENERATOR7
    */
    if((hdma->Init.Request >= DMA_REQUEST_GENERATOR0) && (hdma->Init.Request <= DMA_REQUEST_GENERATOR7))
24001d86:	687b      	ldr	r3, [r7, #4]
24001d88:	685b      	ldr	r3, [r3, #4]
24001d8a:	2b00      	cmp	r3, #0
24001d8c:	d010      	beq.n	24001db0 <HAL_DMA_Init+0x624>
24001d8e:	687b      	ldr	r3, [r7, #4]
24001d90:	685b      	ldr	r3, [r3, #4]
24001d92:	2b08      	cmp	r3, #8
24001d94:	d80c      	bhi.n	24001db0 <HAL_DMA_Init+0x624>
    {
      /* Initialize parameters for DMAMUX request generator :
      DMAmuxRequestGen, DMAmuxRequestGenStatus and DMAmuxRequestGenStatusMask */
      DMA_CalcDMAMUXRequestGenBaseAndMask(hdma);
24001d96:	6878      	ldr	r0, [r7, #4]
24001d98:	f003 face 	bl	24005338 <DMA_CalcDMAMUXRequestGenBaseAndMask>

      /* Reset the DMAMUX request generator register */
      hdma->DMAmuxRequestGen->RGCR = 0U;
24001d9c:	687b      	ldr	r3, [r7, #4]
24001d9e:	6edb      	ldr	r3, [r3, #108]	; 0x6c
24001da0:	2200      	movs	r2, #0
24001da2:	601a      	str	r2, [r3, #0]

      /* Clear the DMAMUX request generator overrun flag */
      hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
24001da4:	687b      	ldr	r3, [r7, #4]
24001da6:	6f1b      	ldr	r3, [r3, #112]	; 0x70
24001da8:	687a      	ldr	r2, [r7, #4]
24001daa:	6f52      	ldr	r2, [r2, #116]	; 0x74
24001dac:	605a      	str	r2, [r3, #4]
24001dae:	e008      	b.n	24001dc2 <HAL_DMA_Init+0x636>
    }
    else
    {
      hdma->DMAmuxRequestGen = 0U;
24001db0:	687b      	ldr	r3, [r7, #4]
24001db2:	2200      	movs	r2, #0
24001db4:	66da      	str	r2, [r3, #108]	; 0x6c
      hdma->DMAmuxRequestGenStatus = 0U;
24001db6:	687b      	ldr	r3, [r7, #4]
24001db8:	2200      	movs	r2, #0
24001dba:	671a      	str	r2, [r3, #112]	; 0x70
      hdma->DMAmuxRequestGenStatusMask = 0U;
24001dbc:	687b      	ldr	r3, [r7, #4]
24001dbe:	2200      	movs	r2, #0
24001dc0:	675a      	str	r2, [r3, #116]	; 0x74
    }
  }

  /* Initialize the error code */
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
24001dc2:	687b      	ldr	r3, [r7, #4]
24001dc4:	2200      	movs	r2, #0
24001dc6:	655a      	str	r2, [r3, #84]	; 0x54

  /* Initialize the DMA state */
  hdma->State = HAL_DMA_STATE_READY;
24001dc8:	687b      	ldr	r3, [r7, #4]
24001dca:	2201      	movs	r2, #1
24001dcc:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

  return HAL_OK;
24001dd0:	2300      	movs	r3, #0
}
24001dd2:	4618      	mov	r0, r3
24001dd4:	3718      	adds	r7, #24
24001dd6:	46bd      	mov	sp, r7
24001dd8:	bd80      	pop	{r7, pc}
24001dda:	bf00      	nop
24001ddc:	a7fdabf8 	.word	0xa7fdabf8
24001de0:	cccccccd 	.word	0xcccccccd
24001de4:	40020010 	.word	0x40020010
24001de8:	40020028 	.word	0x40020028
24001dec:	40020040 	.word	0x40020040
24001df0:	40020058 	.word	0x40020058
24001df4:	40020070 	.word	0x40020070
24001df8:	40020088 	.word	0x40020088
24001dfc:	400200a0 	.word	0x400200a0
24001e00:	400200b8 	.word	0x400200b8
24001e04:	40020410 	.word	0x40020410
24001e08:	40020428 	.word	0x40020428
24001e0c:	40020440 	.word	0x40020440
24001e10:	40020458 	.word	0x40020458
24001e14:	40020470 	.word	0x40020470
24001e18:	40020488 	.word	0x40020488
24001e1c:	400204a0 	.word	0x400204a0
24001e20:	400204b8 	.word	0x400204b8
24001e24:	58025408 	.word	0x58025408
24001e28:	5802541c 	.word	0x5802541c
24001e2c:	58025430 	.word	0x58025430
24001e30:	58025444 	.word	0x58025444
24001e34:	58025458 	.word	0x58025458
24001e38:	5802546c 	.word	0x5802546c
24001e3c:	58025480 	.word	0x58025480
24001e40:	58025494 	.word	0x58025494

24001e44 <HAL_DMA_DeInit>:
  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Stream.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_DeInit(DMA_HandleTypeDef *hdma)
{
24001e44:	b580      	push	{r7, lr}
24001e46:	b084      	sub	sp, #16
24001e48:	af00      	add	r7, sp, #0
24001e4a:	6078      	str	r0, [r7, #4]
  DMA_Base_Registers *regs_dma;
  BDMA_Base_Registers *regs_bdma;

  /* Check the DMA peripheral handle */
  if(hdma == NULL)
24001e4c:	687b      	ldr	r3, [r7, #4]
24001e4e:	2b00      	cmp	r3, #0
24001e50:	d101      	bne.n	24001e56 <HAL_DMA_DeInit+0x12>
  {
    return HAL_ERROR;
24001e52:	2301      	movs	r3, #1
24001e54:	e225      	b.n	240022a2 <HAL_DMA_DeInit+0x45e>
  }

  /* Disable the selected DMA Streamx */
  __HAL_DMA_DISABLE(hdma);
24001e56:	687b      	ldr	r3, [r7, #4]
24001e58:	681b      	ldr	r3, [r3, #0]
24001e5a:	4a82      	ldr	r2, [pc, #520]	; (24002064 <HAL_DMA_DeInit+0x220>)
24001e5c:	4293      	cmp	r3, r2
24001e5e:	d04a      	beq.n	24001ef6 <HAL_DMA_DeInit+0xb2>
24001e60:	687b      	ldr	r3, [r7, #4]
24001e62:	681b      	ldr	r3, [r3, #0]
24001e64:	4a80      	ldr	r2, [pc, #512]	; (24002068 <HAL_DMA_DeInit+0x224>)
24001e66:	4293      	cmp	r3, r2
24001e68:	d045      	beq.n	24001ef6 <HAL_DMA_DeInit+0xb2>
24001e6a:	687b      	ldr	r3, [r7, #4]
24001e6c:	681b      	ldr	r3, [r3, #0]
24001e6e:	4a7f      	ldr	r2, [pc, #508]	; (2400206c <HAL_DMA_DeInit+0x228>)
24001e70:	4293      	cmp	r3, r2
24001e72:	d040      	beq.n	24001ef6 <HAL_DMA_DeInit+0xb2>
24001e74:	687b      	ldr	r3, [r7, #4]
24001e76:	681b      	ldr	r3, [r3, #0]
24001e78:	4a7d      	ldr	r2, [pc, #500]	; (24002070 <HAL_DMA_DeInit+0x22c>)
24001e7a:	4293      	cmp	r3, r2
24001e7c:	d03b      	beq.n	24001ef6 <HAL_DMA_DeInit+0xb2>
24001e7e:	687b      	ldr	r3, [r7, #4]
24001e80:	681b      	ldr	r3, [r3, #0]
24001e82:	4a7c      	ldr	r2, [pc, #496]	; (24002074 <HAL_DMA_DeInit+0x230>)
24001e84:	4293      	cmp	r3, r2
24001e86:	d036      	beq.n	24001ef6 <HAL_DMA_DeInit+0xb2>
24001e88:	687b      	ldr	r3, [r7, #4]
24001e8a:	681b      	ldr	r3, [r3, #0]
24001e8c:	4a7a      	ldr	r2, [pc, #488]	; (24002078 <HAL_DMA_DeInit+0x234>)
24001e8e:	4293      	cmp	r3, r2
24001e90:	d031      	beq.n	24001ef6 <HAL_DMA_DeInit+0xb2>
24001e92:	687b      	ldr	r3, [r7, #4]
24001e94:	681b      	ldr	r3, [r3, #0]
24001e96:	4a79      	ldr	r2, [pc, #484]	; (2400207c <HAL_DMA_DeInit+0x238>)
24001e98:	4293      	cmp	r3, r2
24001e9a:	d02c      	beq.n	24001ef6 <HAL_DMA_DeInit+0xb2>
24001e9c:	687b      	ldr	r3, [r7, #4]
24001e9e:	681b      	ldr	r3, [r3, #0]
24001ea0:	4a77      	ldr	r2, [pc, #476]	; (24002080 <HAL_DMA_DeInit+0x23c>)
24001ea2:	4293      	cmp	r3, r2
24001ea4:	d027      	beq.n	24001ef6 <HAL_DMA_DeInit+0xb2>
24001ea6:	687b      	ldr	r3, [r7, #4]
24001ea8:	681b      	ldr	r3, [r3, #0]
24001eaa:	4a76      	ldr	r2, [pc, #472]	; (24002084 <HAL_DMA_DeInit+0x240>)
24001eac:	4293      	cmp	r3, r2
24001eae:	d022      	beq.n	24001ef6 <HAL_DMA_DeInit+0xb2>
24001eb0:	687b      	ldr	r3, [r7, #4]
24001eb2:	681b      	ldr	r3, [r3, #0]
24001eb4:	4a74      	ldr	r2, [pc, #464]	; (24002088 <HAL_DMA_DeInit+0x244>)
24001eb6:	4293      	cmp	r3, r2
24001eb8:	d01d      	beq.n	24001ef6 <HAL_DMA_DeInit+0xb2>
24001eba:	687b      	ldr	r3, [r7, #4]
24001ebc:	681b      	ldr	r3, [r3, #0]
24001ebe:	4a73      	ldr	r2, [pc, #460]	; (2400208c <HAL_DMA_DeInit+0x248>)
24001ec0:	4293      	cmp	r3, r2
24001ec2:	d018      	beq.n	24001ef6 <HAL_DMA_DeInit+0xb2>
24001ec4:	687b      	ldr	r3, [r7, #4]
24001ec6:	681b      	ldr	r3, [r3, #0]
24001ec8:	4a71      	ldr	r2, [pc, #452]	; (24002090 <HAL_DMA_DeInit+0x24c>)
24001eca:	4293      	cmp	r3, r2
24001ecc:	d013      	beq.n	24001ef6 <HAL_DMA_DeInit+0xb2>
24001ece:	687b      	ldr	r3, [r7, #4]
24001ed0:	681b      	ldr	r3, [r3, #0]
24001ed2:	4a70      	ldr	r2, [pc, #448]	; (24002094 <HAL_DMA_DeInit+0x250>)
24001ed4:	4293      	cmp	r3, r2
24001ed6:	d00e      	beq.n	24001ef6 <HAL_DMA_DeInit+0xb2>
24001ed8:	687b      	ldr	r3, [r7, #4]
24001eda:	681b      	ldr	r3, [r3, #0]
24001edc:	4a6e      	ldr	r2, [pc, #440]	; (24002098 <HAL_DMA_DeInit+0x254>)
24001ede:	4293      	cmp	r3, r2
24001ee0:	d009      	beq.n	24001ef6 <HAL_DMA_DeInit+0xb2>
24001ee2:	687b      	ldr	r3, [r7, #4]
24001ee4:	681b      	ldr	r3, [r3, #0]
24001ee6:	4a6d      	ldr	r2, [pc, #436]	; (2400209c <HAL_DMA_DeInit+0x258>)
24001ee8:	4293      	cmp	r3, r2
24001eea:	d004      	beq.n	24001ef6 <HAL_DMA_DeInit+0xb2>
24001eec:	687b      	ldr	r3, [r7, #4]
24001eee:	681b      	ldr	r3, [r3, #0]
24001ef0:	4a6b      	ldr	r2, [pc, #428]	; (240020a0 <HAL_DMA_DeInit+0x25c>)
24001ef2:	4293      	cmp	r3, r2
24001ef4:	d108      	bne.n	24001f08 <HAL_DMA_DeInit+0xc4>
24001ef6:	687b      	ldr	r3, [r7, #4]
24001ef8:	681b      	ldr	r3, [r3, #0]
24001efa:	681a      	ldr	r2, [r3, #0]
24001efc:	687b      	ldr	r3, [r7, #4]
24001efe:	681b      	ldr	r3, [r3, #0]
24001f00:	f022 0201 	bic.w	r2, r2, #1
24001f04:	601a      	str	r2, [r3, #0]
24001f06:	e007      	b.n	24001f18 <HAL_DMA_DeInit+0xd4>
24001f08:	687b      	ldr	r3, [r7, #4]
24001f0a:	681b      	ldr	r3, [r3, #0]
24001f0c:	681a      	ldr	r2, [r3, #0]
24001f0e:	687b      	ldr	r3, [r7, #4]
24001f10:	681b      	ldr	r3, [r3, #0]
24001f12:	f022 0201 	bic.w	r2, r2, #1
24001f16:	601a      	str	r2, [r3, #0]

  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
24001f18:	687b      	ldr	r3, [r7, #4]
24001f1a:	681b      	ldr	r3, [r3, #0]
24001f1c:	4a51      	ldr	r2, [pc, #324]	; (24002064 <HAL_DMA_DeInit+0x220>)
24001f1e:	4293      	cmp	r3, r2
24001f20:	d04a      	beq.n	24001fb8 <HAL_DMA_DeInit+0x174>
24001f22:	687b      	ldr	r3, [r7, #4]
24001f24:	681b      	ldr	r3, [r3, #0]
24001f26:	4a50      	ldr	r2, [pc, #320]	; (24002068 <HAL_DMA_DeInit+0x224>)
24001f28:	4293      	cmp	r3, r2
24001f2a:	d045      	beq.n	24001fb8 <HAL_DMA_DeInit+0x174>
24001f2c:	687b      	ldr	r3, [r7, #4]
24001f2e:	681b      	ldr	r3, [r3, #0]
24001f30:	4a4e      	ldr	r2, [pc, #312]	; (2400206c <HAL_DMA_DeInit+0x228>)
24001f32:	4293      	cmp	r3, r2
24001f34:	d040      	beq.n	24001fb8 <HAL_DMA_DeInit+0x174>
24001f36:	687b      	ldr	r3, [r7, #4]
24001f38:	681b      	ldr	r3, [r3, #0]
24001f3a:	4a4d      	ldr	r2, [pc, #308]	; (24002070 <HAL_DMA_DeInit+0x22c>)
24001f3c:	4293      	cmp	r3, r2
24001f3e:	d03b      	beq.n	24001fb8 <HAL_DMA_DeInit+0x174>
24001f40:	687b      	ldr	r3, [r7, #4]
24001f42:	681b      	ldr	r3, [r3, #0]
24001f44:	4a4b      	ldr	r2, [pc, #300]	; (24002074 <HAL_DMA_DeInit+0x230>)
24001f46:	4293      	cmp	r3, r2
24001f48:	d036      	beq.n	24001fb8 <HAL_DMA_DeInit+0x174>
24001f4a:	687b      	ldr	r3, [r7, #4]
24001f4c:	681b      	ldr	r3, [r3, #0]
24001f4e:	4a4a      	ldr	r2, [pc, #296]	; (24002078 <HAL_DMA_DeInit+0x234>)
24001f50:	4293      	cmp	r3, r2
24001f52:	d031      	beq.n	24001fb8 <HAL_DMA_DeInit+0x174>
24001f54:	687b      	ldr	r3, [r7, #4]
24001f56:	681b      	ldr	r3, [r3, #0]
24001f58:	4a48      	ldr	r2, [pc, #288]	; (2400207c <HAL_DMA_DeInit+0x238>)
24001f5a:	4293      	cmp	r3, r2
24001f5c:	d02c      	beq.n	24001fb8 <HAL_DMA_DeInit+0x174>
24001f5e:	687b      	ldr	r3, [r7, #4]
24001f60:	681b      	ldr	r3, [r3, #0]
24001f62:	4a47      	ldr	r2, [pc, #284]	; (24002080 <HAL_DMA_DeInit+0x23c>)
24001f64:	4293      	cmp	r3, r2
24001f66:	d027      	beq.n	24001fb8 <HAL_DMA_DeInit+0x174>
24001f68:	687b      	ldr	r3, [r7, #4]
24001f6a:	681b      	ldr	r3, [r3, #0]
24001f6c:	4a45      	ldr	r2, [pc, #276]	; (24002084 <HAL_DMA_DeInit+0x240>)
24001f6e:	4293      	cmp	r3, r2
24001f70:	d022      	beq.n	24001fb8 <HAL_DMA_DeInit+0x174>
24001f72:	687b      	ldr	r3, [r7, #4]
24001f74:	681b      	ldr	r3, [r3, #0]
24001f76:	4a44      	ldr	r2, [pc, #272]	; (24002088 <HAL_DMA_DeInit+0x244>)
24001f78:	4293      	cmp	r3, r2
24001f7a:	d01d      	beq.n	24001fb8 <HAL_DMA_DeInit+0x174>
24001f7c:	687b      	ldr	r3, [r7, #4]
24001f7e:	681b      	ldr	r3, [r3, #0]
24001f80:	4a42      	ldr	r2, [pc, #264]	; (2400208c <HAL_DMA_DeInit+0x248>)
24001f82:	4293      	cmp	r3, r2
24001f84:	d018      	beq.n	24001fb8 <HAL_DMA_DeInit+0x174>
24001f86:	687b      	ldr	r3, [r7, #4]
24001f88:	681b      	ldr	r3, [r3, #0]
24001f8a:	4a41      	ldr	r2, [pc, #260]	; (24002090 <HAL_DMA_DeInit+0x24c>)
24001f8c:	4293      	cmp	r3, r2
24001f8e:	d013      	beq.n	24001fb8 <HAL_DMA_DeInit+0x174>
24001f90:	687b      	ldr	r3, [r7, #4]
24001f92:	681b      	ldr	r3, [r3, #0]
24001f94:	4a3f      	ldr	r2, [pc, #252]	; (24002094 <HAL_DMA_DeInit+0x250>)
24001f96:	4293      	cmp	r3, r2
24001f98:	d00e      	beq.n	24001fb8 <HAL_DMA_DeInit+0x174>
24001f9a:	687b      	ldr	r3, [r7, #4]
24001f9c:	681b      	ldr	r3, [r3, #0]
24001f9e:	4a3e      	ldr	r2, [pc, #248]	; (24002098 <HAL_DMA_DeInit+0x254>)
24001fa0:	4293      	cmp	r3, r2
24001fa2:	d009      	beq.n	24001fb8 <HAL_DMA_DeInit+0x174>
24001fa4:	687b      	ldr	r3, [r7, #4]
24001fa6:	681b      	ldr	r3, [r3, #0]
24001fa8:	4a3c      	ldr	r2, [pc, #240]	; (2400209c <HAL_DMA_DeInit+0x258>)
24001faa:	4293      	cmp	r3, r2
24001fac:	d004      	beq.n	24001fb8 <HAL_DMA_DeInit+0x174>
24001fae:	687b      	ldr	r3, [r7, #4]
24001fb0:	681b      	ldr	r3, [r3, #0]
24001fb2:	4a3b      	ldr	r2, [pc, #236]	; (240020a0 <HAL_DMA_DeInit+0x25c>)
24001fb4:	4293      	cmp	r3, r2
24001fb6:	d101      	bne.n	24001fbc <HAL_DMA_DeInit+0x178>
24001fb8:	2301      	movs	r3, #1
24001fba:	e000      	b.n	24001fbe <HAL_DMA_DeInit+0x17a>
24001fbc:	2300      	movs	r3, #0
24001fbe:	2b00      	cmp	r3, #0
24001fc0:	d025      	beq.n	2400200e <HAL_DMA_DeInit+0x1ca>
  {
    /* Reset DMA Streamx control register */
    ((DMA_Stream_TypeDef   *)hdma->Instance)->CR   = 0U;
24001fc2:	687b      	ldr	r3, [r7, #4]
24001fc4:	681b      	ldr	r3, [r3, #0]
24001fc6:	2200      	movs	r2, #0
24001fc8:	601a      	str	r2, [r3, #0]

    /* Reset DMA Streamx number of data to transfer register */
    ((DMA_Stream_TypeDef   *)hdma->Instance)->NDTR = 0U;
24001fca:	687b      	ldr	r3, [r7, #4]
24001fcc:	681b      	ldr	r3, [r3, #0]
24001fce:	2200      	movs	r2, #0
24001fd0:	605a      	str	r2, [r3, #4]

    /* Reset DMA Streamx peripheral address register */
    ((DMA_Stream_TypeDef   *)hdma->Instance)->PAR  = 0U;
24001fd2:	687b      	ldr	r3, [r7, #4]
24001fd4:	681b      	ldr	r3, [r3, #0]
24001fd6:	2200      	movs	r2, #0
24001fd8:	609a      	str	r2, [r3, #8]

    /* Reset DMA Streamx memory 0 address register */
    ((DMA_Stream_TypeDef   *)hdma->Instance)->M0AR = 0U;
24001fda:	687b      	ldr	r3, [r7, #4]
24001fdc:	681b      	ldr	r3, [r3, #0]
24001fde:	2200      	movs	r2, #0
24001fe0:	60da      	str	r2, [r3, #12]

    /* Reset DMA Streamx memory 1 address register */
    ((DMA_Stream_TypeDef   *)hdma->Instance)->M1AR = 0U;
24001fe2:	687b      	ldr	r3, [r7, #4]
24001fe4:	681b      	ldr	r3, [r3, #0]
24001fe6:	2200      	movs	r2, #0
24001fe8:	611a      	str	r2, [r3, #16]

    /* Reset DMA Streamx FIFO control register */
    ((DMA_Stream_TypeDef   *)hdma->Instance)->FCR  = (uint32_t)0x00000021U;
24001fea:	687b      	ldr	r3, [r7, #4]
24001fec:	681b      	ldr	r3, [r3, #0]
24001fee:	2221      	movs	r2, #33	; 0x21
24001ff0:	615a      	str	r2, [r3, #20]

    /* Get DMA steam Base Address */
    regs_dma = (DMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
24001ff2:	6878      	ldr	r0, [r7, #4]
24001ff4:	f002 ffd8 	bl	24004fa8 <DMA_CalcBaseAndBitshift>
24001ff8:	4603      	mov	r3, r0
24001ffa:	60bb      	str	r3, [r7, #8]

    /* Clear all interrupt flags at correct offset within the register */
    regs_dma->IFCR = 0x3FUL << (hdma->StreamIndex & 0x1FU);
24001ffc:	687b      	ldr	r3, [r7, #4]
24001ffe:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24002000:	f003 031f 	and.w	r3, r3, #31
24002004:	223f      	movs	r2, #63	; 0x3f
24002006:	409a      	lsls	r2, r3
24002008:	68bb      	ldr	r3, [r7, #8]
2400200a:	609a      	str	r2, [r3, #8]
2400200c:	e081      	b.n	24002112 <HAL_DMA_DeInit+0x2ce>
  }
  else if(IS_BDMA_CHANNEL_INSTANCE(hdma->Instance) != 0U) /* BDMA instance(s) */
2400200e:	687b      	ldr	r3, [r7, #4]
24002010:	681b      	ldr	r3, [r3, #0]
24002012:	4a24      	ldr	r2, [pc, #144]	; (240020a4 <HAL_DMA_DeInit+0x260>)
24002014:	4293      	cmp	r3, r2
24002016:	d022      	beq.n	2400205e <HAL_DMA_DeInit+0x21a>
24002018:	687b      	ldr	r3, [r7, #4]
2400201a:	681b      	ldr	r3, [r3, #0]
2400201c:	4a22      	ldr	r2, [pc, #136]	; (240020a8 <HAL_DMA_DeInit+0x264>)
2400201e:	4293      	cmp	r3, r2
24002020:	d01d      	beq.n	2400205e <HAL_DMA_DeInit+0x21a>
24002022:	687b      	ldr	r3, [r7, #4]
24002024:	681b      	ldr	r3, [r3, #0]
24002026:	4a21      	ldr	r2, [pc, #132]	; (240020ac <HAL_DMA_DeInit+0x268>)
24002028:	4293      	cmp	r3, r2
2400202a:	d018      	beq.n	2400205e <HAL_DMA_DeInit+0x21a>
2400202c:	687b      	ldr	r3, [r7, #4]
2400202e:	681b      	ldr	r3, [r3, #0]
24002030:	4a1f      	ldr	r2, [pc, #124]	; (240020b0 <HAL_DMA_DeInit+0x26c>)
24002032:	4293      	cmp	r3, r2
24002034:	d013      	beq.n	2400205e <HAL_DMA_DeInit+0x21a>
24002036:	687b      	ldr	r3, [r7, #4]
24002038:	681b      	ldr	r3, [r3, #0]
2400203a:	4a1e      	ldr	r2, [pc, #120]	; (240020b4 <HAL_DMA_DeInit+0x270>)
2400203c:	4293      	cmp	r3, r2
2400203e:	d00e      	beq.n	2400205e <HAL_DMA_DeInit+0x21a>
24002040:	687b      	ldr	r3, [r7, #4]
24002042:	681b      	ldr	r3, [r3, #0]
24002044:	4a1c      	ldr	r2, [pc, #112]	; (240020b8 <HAL_DMA_DeInit+0x274>)
24002046:	4293      	cmp	r3, r2
24002048:	d009      	beq.n	2400205e <HAL_DMA_DeInit+0x21a>
2400204a:	687b      	ldr	r3, [r7, #4]
2400204c:	681b      	ldr	r3, [r3, #0]
2400204e:	4a1b      	ldr	r2, [pc, #108]	; (240020bc <HAL_DMA_DeInit+0x278>)
24002050:	4293      	cmp	r3, r2
24002052:	d004      	beq.n	2400205e <HAL_DMA_DeInit+0x21a>
24002054:	687b      	ldr	r3, [r7, #4]
24002056:	681b      	ldr	r3, [r3, #0]
24002058:	4a19      	ldr	r2, [pc, #100]	; (240020c0 <HAL_DMA_DeInit+0x27c>)
2400205a:	4293      	cmp	r3, r2
2400205c:	d132      	bne.n	240020c4 <HAL_DMA_DeInit+0x280>
2400205e:	2301      	movs	r3, #1
24002060:	e031      	b.n	240020c6 <HAL_DMA_DeInit+0x282>
24002062:	bf00      	nop
24002064:	40020010 	.word	0x40020010
24002068:	40020028 	.word	0x40020028
2400206c:	40020040 	.word	0x40020040
24002070:	40020058 	.word	0x40020058
24002074:	40020070 	.word	0x40020070
24002078:	40020088 	.word	0x40020088
2400207c:	400200a0 	.word	0x400200a0
24002080:	400200b8 	.word	0x400200b8
24002084:	40020410 	.word	0x40020410
24002088:	40020428 	.word	0x40020428
2400208c:	40020440 	.word	0x40020440
24002090:	40020458 	.word	0x40020458
24002094:	40020470 	.word	0x40020470
24002098:	40020488 	.word	0x40020488
2400209c:	400204a0 	.word	0x400204a0
240020a0:	400204b8 	.word	0x400204b8
240020a4:	58025408 	.word	0x58025408
240020a8:	5802541c 	.word	0x5802541c
240020ac:	58025430 	.word	0x58025430
240020b0:	58025444 	.word	0x58025444
240020b4:	58025458 	.word	0x58025458
240020b8:	5802546c 	.word	0x5802546c
240020bc:	58025480 	.word	0x58025480
240020c0:	58025494 	.word	0x58025494
240020c4:	2300      	movs	r3, #0
240020c6:	2b00      	cmp	r3, #0
240020c8:	d021      	beq.n	2400210e <HAL_DMA_DeInit+0x2ca>
  {
    /* Reset DMA Channel control register */
    ((BDMA_Channel_TypeDef *)hdma->Instance)->CCR  = 0U;
240020ca:	687b      	ldr	r3, [r7, #4]
240020cc:	681b      	ldr	r3, [r3, #0]
240020ce:	2200      	movs	r2, #0
240020d0:	601a      	str	r2, [r3, #0]

    /* Reset DMA Channel Number of Data to Transfer register */
    ((BDMA_Channel_TypeDef *)hdma->Instance)->CNDTR = 0U;
240020d2:	687b      	ldr	r3, [r7, #4]
240020d4:	681b      	ldr	r3, [r3, #0]
240020d6:	2200      	movs	r2, #0
240020d8:	605a      	str	r2, [r3, #4]

    /* Reset DMA Channel peripheral address register */
    ((BDMA_Channel_TypeDef *)hdma->Instance)->CPAR  = 0U;
240020da:	687b      	ldr	r3, [r7, #4]
240020dc:	681b      	ldr	r3, [r3, #0]
240020de:	2200      	movs	r2, #0
240020e0:	609a      	str	r2, [r3, #8]

    /* Reset DMA Channel memory 0 address register */
    ((BDMA_Channel_TypeDef *)hdma->Instance)->CM0AR = 0U;
240020e2:	687b      	ldr	r3, [r7, #4]
240020e4:	681b      	ldr	r3, [r3, #0]
240020e6:	2200      	movs	r2, #0
240020e8:	60da      	str	r2, [r3, #12]

    /* Reset DMA Channel memory 1 address register */
    ((BDMA_Channel_TypeDef *)hdma->Instance)->CM1AR = 0U;
240020ea:	687b      	ldr	r3, [r7, #4]
240020ec:	681b      	ldr	r3, [r3, #0]
240020ee:	2200      	movs	r2, #0
240020f0:	611a      	str	r2, [r3, #16]

    /* Get DMA steam Base Address */
    regs_bdma = (BDMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
240020f2:	6878      	ldr	r0, [r7, #4]
240020f4:	f002 ff58 	bl	24004fa8 <DMA_CalcBaseAndBitshift>
240020f8:	4603      	mov	r3, r0
240020fa:	60fb      	str	r3, [r7, #12]

    /* Clear all interrupt flags at correct offset within the register */
    regs_bdma->IFCR = ((BDMA_IFCR_CGIF0) << (hdma->StreamIndex & 0x1FU));
240020fc:	687b      	ldr	r3, [r7, #4]
240020fe:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24002100:	f003 031f 	and.w	r3, r3, #31
24002104:	2201      	movs	r2, #1
24002106:	409a      	lsls	r2, r3
24002108:	68fb      	ldr	r3, [r7, #12]
2400210a:	605a      	str	r2, [r3, #4]
2400210c:	e001      	b.n	24002112 <HAL_DMA_DeInit+0x2ce>
  }
  else
  {
    /* Return error status */
    return HAL_ERROR;
2400210e:	2301      	movs	r3, #1
24002110:	e0c7      	b.n	240022a2 <HAL_DMA_DeInit+0x45e>
  }

  if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
24002112:	687b      	ldr	r3, [r7, #4]
24002114:	681b      	ldr	r3, [r3, #0]
24002116:	4a65      	ldr	r2, [pc, #404]	; (240022ac <HAL_DMA_DeInit+0x468>)
24002118:	4293      	cmp	r3, r2
2400211a:	d072      	beq.n	24002202 <HAL_DMA_DeInit+0x3be>
2400211c:	687b      	ldr	r3, [r7, #4]
2400211e:	681b      	ldr	r3, [r3, #0]
24002120:	4a63      	ldr	r2, [pc, #396]	; (240022b0 <HAL_DMA_DeInit+0x46c>)
24002122:	4293      	cmp	r3, r2
24002124:	d06d      	beq.n	24002202 <HAL_DMA_DeInit+0x3be>
24002126:	687b      	ldr	r3, [r7, #4]
24002128:	681b      	ldr	r3, [r3, #0]
2400212a:	4a62      	ldr	r2, [pc, #392]	; (240022b4 <HAL_DMA_DeInit+0x470>)
2400212c:	4293      	cmp	r3, r2
2400212e:	d068      	beq.n	24002202 <HAL_DMA_DeInit+0x3be>
24002130:	687b      	ldr	r3, [r7, #4]
24002132:	681b      	ldr	r3, [r3, #0]
24002134:	4a60      	ldr	r2, [pc, #384]	; (240022b8 <HAL_DMA_DeInit+0x474>)
24002136:	4293      	cmp	r3, r2
24002138:	d063      	beq.n	24002202 <HAL_DMA_DeInit+0x3be>
2400213a:	687b      	ldr	r3, [r7, #4]
2400213c:	681b      	ldr	r3, [r3, #0]
2400213e:	4a5f      	ldr	r2, [pc, #380]	; (240022bc <HAL_DMA_DeInit+0x478>)
24002140:	4293      	cmp	r3, r2
24002142:	d05e      	beq.n	24002202 <HAL_DMA_DeInit+0x3be>
24002144:	687b      	ldr	r3, [r7, #4]
24002146:	681b      	ldr	r3, [r3, #0]
24002148:	4a5d      	ldr	r2, [pc, #372]	; (240022c0 <HAL_DMA_DeInit+0x47c>)
2400214a:	4293      	cmp	r3, r2
2400214c:	d059      	beq.n	24002202 <HAL_DMA_DeInit+0x3be>
2400214e:	687b      	ldr	r3, [r7, #4]
24002150:	681b      	ldr	r3, [r3, #0]
24002152:	4a5c      	ldr	r2, [pc, #368]	; (240022c4 <HAL_DMA_DeInit+0x480>)
24002154:	4293      	cmp	r3, r2
24002156:	d054      	beq.n	24002202 <HAL_DMA_DeInit+0x3be>
24002158:	687b      	ldr	r3, [r7, #4]
2400215a:	681b      	ldr	r3, [r3, #0]
2400215c:	4a5a      	ldr	r2, [pc, #360]	; (240022c8 <HAL_DMA_DeInit+0x484>)
2400215e:	4293      	cmp	r3, r2
24002160:	d04f      	beq.n	24002202 <HAL_DMA_DeInit+0x3be>
24002162:	687b      	ldr	r3, [r7, #4]
24002164:	681b      	ldr	r3, [r3, #0]
24002166:	4a59      	ldr	r2, [pc, #356]	; (240022cc <HAL_DMA_DeInit+0x488>)
24002168:	4293      	cmp	r3, r2
2400216a:	d04a      	beq.n	24002202 <HAL_DMA_DeInit+0x3be>
2400216c:	687b      	ldr	r3, [r7, #4]
2400216e:	681b      	ldr	r3, [r3, #0]
24002170:	4a57      	ldr	r2, [pc, #348]	; (240022d0 <HAL_DMA_DeInit+0x48c>)
24002172:	4293      	cmp	r3, r2
24002174:	d045      	beq.n	24002202 <HAL_DMA_DeInit+0x3be>
24002176:	687b      	ldr	r3, [r7, #4]
24002178:	681b      	ldr	r3, [r3, #0]
2400217a:	4a56      	ldr	r2, [pc, #344]	; (240022d4 <HAL_DMA_DeInit+0x490>)
2400217c:	4293      	cmp	r3, r2
2400217e:	d040      	beq.n	24002202 <HAL_DMA_DeInit+0x3be>
24002180:	687b      	ldr	r3, [r7, #4]
24002182:	681b      	ldr	r3, [r3, #0]
24002184:	4a54      	ldr	r2, [pc, #336]	; (240022d8 <HAL_DMA_DeInit+0x494>)
24002186:	4293      	cmp	r3, r2
24002188:	d03b      	beq.n	24002202 <HAL_DMA_DeInit+0x3be>
2400218a:	687b      	ldr	r3, [r7, #4]
2400218c:	681b      	ldr	r3, [r3, #0]
2400218e:	4a53      	ldr	r2, [pc, #332]	; (240022dc <HAL_DMA_DeInit+0x498>)
24002190:	4293      	cmp	r3, r2
24002192:	d036      	beq.n	24002202 <HAL_DMA_DeInit+0x3be>
24002194:	687b      	ldr	r3, [r7, #4]
24002196:	681b      	ldr	r3, [r3, #0]
24002198:	4a51      	ldr	r2, [pc, #324]	; (240022e0 <HAL_DMA_DeInit+0x49c>)
2400219a:	4293      	cmp	r3, r2
2400219c:	d031      	beq.n	24002202 <HAL_DMA_DeInit+0x3be>
2400219e:	687b      	ldr	r3, [r7, #4]
240021a0:	681b      	ldr	r3, [r3, #0]
240021a2:	4a50      	ldr	r2, [pc, #320]	; (240022e4 <HAL_DMA_DeInit+0x4a0>)
240021a4:	4293      	cmp	r3, r2
240021a6:	d02c      	beq.n	24002202 <HAL_DMA_DeInit+0x3be>
240021a8:	687b      	ldr	r3, [r7, #4]
240021aa:	681b      	ldr	r3, [r3, #0]
240021ac:	4a4e      	ldr	r2, [pc, #312]	; (240022e8 <HAL_DMA_DeInit+0x4a4>)
240021ae:	4293      	cmp	r3, r2
240021b0:	d027      	beq.n	24002202 <HAL_DMA_DeInit+0x3be>
240021b2:	687b      	ldr	r3, [r7, #4]
240021b4:	681b      	ldr	r3, [r3, #0]
240021b6:	4a4d      	ldr	r2, [pc, #308]	; (240022ec <HAL_DMA_DeInit+0x4a8>)
240021b8:	4293      	cmp	r3, r2
240021ba:	d022      	beq.n	24002202 <HAL_DMA_DeInit+0x3be>
240021bc:	687b      	ldr	r3, [r7, #4]
240021be:	681b      	ldr	r3, [r3, #0]
240021c0:	4a4b      	ldr	r2, [pc, #300]	; (240022f0 <HAL_DMA_DeInit+0x4ac>)
240021c2:	4293      	cmp	r3, r2
240021c4:	d01d      	beq.n	24002202 <HAL_DMA_DeInit+0x3be>
240021c6:	687b      	ldr	r3, [r7, #4]
240021c8:	681b      	ldr	r3, [r3, #0]
240021ca:	4a4a      	ldr	r2, [pc, #296]	; (240022f4 <HAL_DMA_DeInit+0x4b0>)
240021cc:	4293      	cmp	r3, r2
240021ce:	d018      	beq.n	24002202 <HAL_DMA_DeInit+0x3be>
240021d0:	687b      	ldr	r3, [r7, #4]
240021d2:	681b      	ldr	r3, [r3, #0]
240021d4:	4a48      	ldr	r2, [pc, #288]	; (240022f8 <HAL_DMA_DeInit+0x4b4>)
240021d6:	4293      	cmp	r3, r2
240021d8:	d013      	beq.n	24002202 <HAL_DMA_DeInit+0x3be>
240021da:	687b      	ldr	r3, [r7, #4]
240021dc:	681b      	ldr	r3, [r3, #0]
240021de:	4a47      	ldr	r2, [pc, #284]	; (240022fc <HAL_DMA_DeInit+0x4b8>)
240021e0:	4293      	cmp	r3, r2
240021e2:	d00e      	beq.n	24002202 <HAL_DMA_DeInit+0x3be>
240021e4:	687b      	ldr	r3, [r7, #4]
240021e6:	681b      	ldr	r3, [r3, #0]
240021e8:	4a45      	ldr	r2, [pc, #276]	; (24002300 <HAL_DMA_DeInit+0x4bc>)
240021ea:	4293      	cmp	r3, r2
240021ec:	d009      	beq.n	24002202 <HAL_DMA_DeInit+0x3be>
240021ee:	687b      	ldr	r3, [r7, #4]
240021f0:	681b      	ldr	r3, [r3, #0]
240021f2:	4a44      	ldr	r2, [pc, #272]	; (24002304 <HAL_DMA_DeInit+0x4c0>)
240021f4:	4293      	cmp	r3, r2
240021f6:	d004      	beq.n	24002202 <HAL_DMA_DeInit+0x3be>
240021f8:	687b      	ldr	r3, [r7, #4]
240021fa:	681b      	ldr	r3, [r3, #0]
240021fc:	4a42      	ldr	r2, [pc, #264]	; (24002308 <HAL_DMA_DeInit+0x4c4>)
240021fe:	4293      	cmp	r3, r2
24002200:	d101      	bne.n	24002206 <HAL_DMA_DeInit+0x3c2>
24002202:	2301      	movs	r3, #1
24002204:	e000      	b.n	24002208 <HAL_DMA_DeInit+0x3c4>
24002206:	2300      	movs	r3, #0
24002208:	2b00      	cmp	r3, #0
2400220a:	d02c      	beq.n	24002266 <HAL_DMA_DeInit+0x422>
  {
    /* Initialize parameters for DMAMUX channel :
    DMAmuxChannel, DMAmuxChannelStatus and DMAmuxChannelStatusMask */
    DMA_CalcDMAMUXChannelBaseAndMask(hdma);
2400220c:	6878      	ldr	r0, [r7, #4]
2400220e:	f002 fff9 	bl	24005204 <DMA_CalcDMAMUXChannelBaseAndMask>

    if(hdma->DMAmuxChannel != 0U)
24002212:	687b      	ldr	r3, [r7, #4]
24002214:	6e1b      	ldr	r3, [r3, #96]	; 0x60
24002216:	2b00      	cmp	r3, #0
24002218:	d008      	beq.n	2400222c <HAL_DMA_DeInit+0x3e8>
    {
      /* Resett he DMAMUX channel that corresponds to the DMA stream */
      hdma->DMAmuxChannel->CCR = 0U;
2400221a:	687b      	ldr	r3, [r7, #4]
2400221c:	6e1b      	ldr	r3, [r3, #96]	; 0x60
2400221e:	2200      	movs	r2, #0
24002220:	601a      	str	r2, [r3, #0]

      /* Clear the DMAMUX synchro overrun flag */
      hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
24002222:	687b      	ldr	r3, [r7, #4]
24002224:	6e5b      	ldr	r3, [r3, #100]	; 0x64
24002226:	687a      	ldr	r2, [r7, #4]
24002228:	6e92      	ldr	r2, [r2, #104]	; 0x68
2400222a:	605a      	str	r2, [r3, #4]
    }

    if((hdma->Init.Request >= DMA_REQUEST_GENERATOR0) && (hdma->Init.Request <= DMA_REQUEST_GENERATOR7))
2400222c:	687b      	ldr	r3, [r7, #4]
2400222e:	685b      	ldr	r3, [r3, #4]
24002230:	2b00      	cmp	r3, #0
24002232:	d00f      	beq.n	24002254 <HAL_DMA_DeInit+0x410>
24002234:	687b      	ldr	r3, [r7, #4]
24002236:	685b      	ldr	r3, [r3, #4]
24002238:	2b08      	cmp	r3, #8
2400223a:	d80b      	bhi.n	24002254 <HAL_DMA_DeInit+0x410>
    {
      /* Initialize parameters for DMAMUX request generator :
      DMAmuxRequestGen, DMAmuxRequestGenStatus and DMAmuxRequestGenStatusMask */
      DMA_CalcDMAMUXRequestGenBaseAndMask(hdma);
2400223c:	6878      	ldr	r0, [r7, #4]
2400223e:	f003 f87b 	bl	24005338 <DMA_CalcDMAMUXRequestGenBaseAndMask>

      /* Reset the DMAMUX request generator register */
      hdma->DMAmuxRequestGen->RGCR = 0U;
24002242:	687b      	ldr	r3, [r7, #4]
24002244:	6edb      	ldr	r3, [r3, #108]	; 0x6c
24002246:	2200      	movs	r2, #0
24002248:	601a      	str	r2, [r3, #0]

      /* Clear the DMAMUX request generator overrun flag */
      hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
2400224a:	687b      	ldr	r3, [r7, #4]
2400224c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
2400224e:	687a      	ldr	r2, [r7, #4]
24002250:	6f52      	ldr	r2, [r2, #116]	; 0x74
24002252:	605a      	str	r2, [r3, #4]
    }

    hdma->DMAmuxRequestGen = 0U;
24002254:	687b      	ldr	r3, [r7, #4]
24002256:	2200      	movs	r2, #0
24002258:	66da      	str	r2, [r3, #108]	; 0x6c
    hdma->DMAmuxRequestGenStatus = 0U;
2400225a:	687b      	ldr	r3, [r7, #4]
2400225c:	2200      	movs	r2, #0
2400225e:	671a      	str	r2, [r3, #112]	; 0x70
    hdma->DMAmuxRequestGenStatusMask = 0U;
24002260:	687b      	ldr	r3, [r7, #4]
24002262:	2200      	movs	r2, #0
24002264:	675a      	str	r2, [r3, #116]	; 0x74
  }


  /* Clean callbacks */
  hdma->XferCpltCallback       = NULL;
24002266:	687b      	ldr	r3, [r7, #4]
24002268:	2200      	movs	r2, #0
2400226a:	63da      	str	r2, [r3, #60]	; 0x3c
  hdma->XferHalfCpltCallback   = NULL;
2400226c:	687b      	ldr	r3, [r7, #4]
2400226e:	2200      	movs	r2, #0
24002270:	641a      	str	r2, [r3, #64]	; 0x40
  hdma->XferM1CpltCallback     = NULL;
24002272:	687b      	ldr	r3, [r7, #4]
24002274:	2200      	movs	r2, #0
24002276:	645a      	str	r2, [r3, #68]	; 0x44
  hdma->XferM1HalfCpltCallback = NULL;
24002278:	687b      	ldr	r3, [r7, #4]
2400227a:	2200      	movs	r2, #0
2400227c:	649a      	str	r2, [r3, #72]	; 0x48
  hdma->XferErrorCallback      = NULL;
2400227e:	687b      	ldr	r3, [r7, #4]
24002280:	2200      	movs	r2, #0
24002282:	64da      	str	r2, [r3, #76]	; 0x4c
  hdma->XferAbortCallback      = NULL;
24002284:	687b      	ldr	r3, [r7, #4]
24002286:	2200      	movs	r2, #0
24002288:	651a      	str	r2, [r3, #80]	; 0x50

  /* Initialize the error code */
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
2400228a:	687b      	ldr	r3, [r7, #4]
2400228c:	2200      	movs	r2, #0
2400228e:	655a      	str	r2, [r3, #84]	; 0x54

  /* Initialize the DMA state */
  hdma->State = HAL_DMA_STATE_RESET;
24002290:	687b      	ldr	r3, [r7, #4]
24002292:	2200      	movs	r2, #0
24002294:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

  /* Release Lock */
  __HAL_UNLOCK(hdma);
24002298:	687b      	ldr	r3, [r7, #4]
2400229a:	2200      	movs	r2, #0
2400229c:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

  return HAL_OK;
240022a0:	2300      	movs	r3, #0
}
240022a2:	4618      	mov	r0, r3
240022a4:	3710      	adds	r7, #16
240022a6:	46bd      	mov	sp, r7
240022a8:	bd80      	pop	{r7, pc}
240022aa:	bf00      	nop
240022ac:	40020010 	.word	0x40020010
240022b0:	40020028 	.word	0x40020028
240022b4:	40020040 	.word	0x40020040
240022b8:	40020058 	.word	0x40020058
240022bc:	40020070 	.word	0x40020070
240022c0:	40020088 	.word	0x40020088
240022c4:	400200a0 	.word	0x400200a0
240022c8:	400200b8 	.word	0x400200b8
240022cc:	40020410 	.word	0x40020410
240022d0:	40020428 	.word	0x40020428
240022d4:	40020440 	.word	0x40020440
240022d8:	40020458 	.word	0x40020458
240022dc:	40020470 	.word	0x40020470
240022e0:	40020488 	.word	0x40020488
240022e4:	400204a0 	.word	0x400204a0
240022e8:	400204b8 	.word	0x400204b8
240022ec:	58025408 	.word	0x58025408
240022f0:	5802541c 	.word	0x5802541c
240022f4:	58025430 	.word	0x58025430
240022f8:	58025444 	.word	0x58025444
240022fc:	58025458 	.word	0x58025458
24002300:	5802546c 	.word	0x5802546c
24002304:	58025480 	.word	0x58025480
24002308:	58025494 	.word	0x58025494

2400230c <HAL_DMA_Start>:
  * @param  DstAddress: The destination memory Buffer address
  * @param  DataLength: The length of data to be transferred from source to destination
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Start(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{
2400230c:	b580      	push	{r7, lr}
2400230e:	b086      	sub	sp, #24
24002310:	af00      	add	r7, sp, #0
24002312:	60f8      	str	r0, [r7, #12]
24002314:	60b9      	str	r1, [r7, #8]
24002316:	607a      	str	r2, [r7, #4]
24002318:	603b      	str	r3, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
2400231a:	2300      	movs	r3, #0
2400231c:	75fb      	strb	r3, [r7, #23]

  /* Check the parameters */
  assert_param(IS_DMA_BUFFER_SIZE(DataLength));

  /* Check the DMA peripheral handle */
  if(hdma == NULL)
2400231e:	68fb      	ldr	r3, [r7, #12]
24002320:	2b00      	cmp	r3, #0
24002322:	d101      	bne.n	24002328 <HAL_DMA_Start+0x1c>
  {
    return HAL_ERROR;
24002324:	2301      	movs	r3, #1
24002326:	e0ec      	b.n	24002502 <HAL_DMA_Start+0x1f6>
  }

  /* Process locked */
  __HAL_LOCK(hdma);
24002328:	68fb      	ldr	r3, [r7, #12]
2400232a:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
2400232e:	2b01      	cmp	r3, #1
24002330:	d101      	bne.n	24002336 <HAL_DMA_Start+0x2a>
24002332:	2302      	movs	r3, #2
24002334:	e0e5      	b.n	24002502 <HAL_DMA_Start+0x1f6>
24002336:	68fb      	ldr	r3, [r7, #12]
24002338:	2201      	movs	r2, #1
2400233a:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

  if(HAL_DMA_STATE_READY == hdma->State)
2400233e:	68fb      	ldr	r3, [r7, #12]
24002340:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
24002344:	b2db      	uxtb	r3, r3
24002346:	2b01      	cmp	r3, #1
24002348:	f040 80d0 	bne.w	240024ec <HAL_DMA_Start+0x1e0>
  {
    /* Change DMA peripheral state */
    hdma->State = HAL_DMA_STATE_BUSY;
2400234c:	68fb      	ldr	r3, [r7, #12]
2400234e:	2202      	movs	r2, #2
24002350:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

    /* Initialize the error code */
    hdma->ErrorCode = HAL_DMA_ERROR_NONE;
24002354:	68fb      	ldr	r3, [r7, #12]
24002356:	2200      	movs	r2, #0
24002358:	655a      	str	r2, [r3, #84]	; 0x54

    /* Disable the peripheral */
    __HAL_DMA_DISABLE(hdma);
2400235a:	68fb      	ldr	r3, [r7, #12]
2400235c:	681b      	ldr	r3, [r3, #0]
2400235e:	4a6b      	ldr	r2, [pc, #428]	; (2400250c <HAL_DMA_Start+0x200>)
24002360:	4293      	cmp	r3, r2
24002362:	d04a      	beq.n	240023fa <HAL_DMA_Start+0xee>
24002364:	68fb      	ldr	r3, [r7, #12]
24002366:	681b      	ldr	r3, [r3, #0]
24002368:	4a69      	ldr	r2, [pc, #420]	; (24002510 <HAL_DMA_Start+0x204>)
2400236a:	4293      	cmp	r3, r2
2400236c:	d045      	beq.n	240023fa <HAL_DMA_Start+0xee>
2400236e:	68fb      	ldr	r3, [r7, #12]
24002370:	681b      	ldr	r3, [r3, #0]
24002372:	4a68      	ldr	r2, [pc, #416]	; (24002514 <HAL_DMA_Start+0x208>)
24002374:	4293      	cmp	r3, r2
24002376:	d040      	beq.n	240023fa <HAL_DMA_Start+0xee>
24002378:	68fb      	ldr	r3, [r7, #12]
2400237a:	681b      	ldr	r3, [r3, #0]
2400237c:	4a66      	ldr	r2, [pc, #408]	; (24002518 <HAL_DMA_Start+0x20c>)
2400237e:	4293      	cmp	r3, r2
24002380:	d03b      	beq.n	240023fa <HAL_DMA_Start+0xee>
24002382:	68fb      	ldr	r3, [r7, #12]
24002384:	681b      	ldr	r3, [r3, #0]
24002386:	4a65      	ldr	r2, [pc, #404]	; (2400251c <HAL_DMA_Start+0x210>)
24002388:	4293      	cmp	r3, r2
2400238a:	d036      	beq.n	240023fa <HAL_DMA_Start+0xee>
2400238c:	68fb      	ldr	r3, [r7, #12]
2400238e:	681b      	ldr	r3, [r3, #0]
24002390:	4a63      	ldr	r2, [pc, #396]	; (24002520 <HAL_DMA_Start+0x214>)
24002392:	4293      	cmp	r3, r2
24002394:	d031      	beq.n	240023fa <HAL_DMA_Start+0xee>
24002396:	68fb      	ldr	r3, [r7, #12]
24002398:	681b      	ldr	r3, [r3, #0]
2400239a:	4a62      	ldr	r2, [pc, #392]	; (24002524 <HAL_DMA_Start+0x218>)
2400239c:	4293      	cmp	r3, r2
2400239e:	d02c      	beq.n	240023fa <HAL_DMA_Start+0xee>
240023a0:	68fb      	ldr	r3, [r7, #12]
240023a2:	681b      	ldr	r3, [r3, #0]
240023a4:	4a60      	ldr	r2, [pc, #384]	; (24002528 <HAL_DMA_Start+0x21c>)
240023a6:	4293      	cmp	r3, r2
240023a8:	d027      	beq.n	240023fa <HAL_DMA_Start+0xee>
240023aa:	68fb      	ldr	r3, [r7, #12]
240023ac:	681b      	ldr	r3, [r3, #0]
240023ae:	4a5f      	ldr	r2, [pc, #380]	; (2400252c <HAL_DMA_Start+0x220>)
240023b0:	4293      	cmp	r3, r2
240023b2:	d022      	beq.n	240023fa <HAL_DMA_Start+0xee>
240023b4:	68fb      	ldr	r3, [r7, #12]
240023b6:	681b      	ldr	r3, [r3, #0]
240023b8:	4a5d      	ldr	r2, [pc, #372]	; (24002530 <HAL_DMA_Start+0x224>)
240023ba:	4293      	cmp	r3, r2
240023bc:	d01d      	beq.n	240023fa <HAL_DMA_Start+0xee>
240023be:	68fb      	ldr	r3, [r7, #12]
240023c0:	681b      	ldr	r3, [r3, #0]
240023c2:	4a5c      	ldr	r2, [pc, #368]	; (24002534 <HAL_DMA_Start+0x228>)
240023c4:	4293      	cmp	r3, r2
240023c6:	d018      	beq.n	240023fa <HAL_DMA_Start+0xee>
240023c8:	68fb      	ldr	r3, [r7, #12]
240023ca:	681b      	ldr	r3, [r3, #0]
240023cc:	4a5a      	ldr	r2, [pc, #360]	; (24002538 <HAL_DMA_Start+0x22c>)
240023ce:	4293      	cmp	r3, r2
240023d0:	d013      	beq.n	240023fa <HAL_DMA_Start+0xee>
240023d2:	68fb      	ldr	r3, [r7, #12]
240023d4:	681b      	ldr	r3, [r3, #0]
240023d6:	4a59      	ldr	r2, [pc, #356]	; (2400253c <HAL_DMA_Start+0x230>)
240023d8:	4293      	cmp	r3, r2
240023da:	d00e      	beq.n	240023fa <HAL_DMA_Start+0xee>
240023dc:	68fb      	ldr	r3, [r7, #12]
240023de:	681b      	ldr	r3, [r3, #0]
240023e0:	4a57      	ldr	r2, [pc, #348]	; (24002540 <HAL_DMA_Start+0x234>)
240023e2:	4293      	cmp	r3, r2
240023e4:	d009      	beq.n	240023fa <HAL_DMA_Start+0xee>
240023e6:	68fb      	ldr	r3, [r7, #12]
240023e8:	681b      	ldr	r3, [r3, #0]
240023ea:	4a56      	ldr	r2, [pc, #344]	; (24002544 <HAL_DMA_Start+0x238>)
240023ec:	4293      	cmp	r3, r2
240023ee:	d004      	beq.n	240023fa <HAL_DMA_Start+0xee>
240023f0:	68fb      	ldr	r3, [r7, #12]
240023f2:	681b      	ldr	r3, [r3, #0]
240023f4:	4a54      	ldr	r2, [pc, #336]	; (24002548 <HAL_DMA_Start+0x23c>)
240023f6:	4293      	cmp	r3, r2
240023f8:	d108      	bne.n	2400240c <HAL_DMA_Start+0x100>
240023fa:	68fb      	ldr	r3, [r7, #12]
240023fc:	681b      	ldr	r3, [r3, #0]
240023fe:	681a      	ldr	r2, [r3, #0]
24002400:	68fb      	ldr	r3, [r7, #12]
24002402:	681b      	ldr	r3, [r3, #0]
24002404:	f022 0201 	bic.w	r2, r2, #1
24002408:	601a      	str	r2, [r3, #0]
2400240a:	e007      	b.n	2400241c <HAL_DMA_Start+0x110>
2400240c:	68fb      	ldr	r3, [r7, #12]
2400240e:	681b      	ldr	r3, [r3, #0]
24002410:	681a      	ldr	r2, [r3, #0]
24002412:	68fb      	ldr	r3, [r7, #12]
24002414:	681b      	ldr	r3, [r3, #0]
24002416:	f022 0201 	bic.w	r2, r2, #1
2400241a:	601a      	str	r2, [r3, #0]

    /* Configure the source, destination address and the data length */
    DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength);
2400241c:	683b      	ldr	r3, [r7, #0]
2400241e:	687a      	ldr	r2, [r7, #4]
24002420:	68b9      	ldr	r1, [r7, #8]
24002422:	68f8      	ldr	r0, [r7, #12]
24002424:	f002 fc14 	bl	24004c50 <DMA_SetConfig>

    /* Enable the Peripheral */
    __HAL_DMA_ENABLE(hdma);
24002428:	68fb      	ldr	r3, [r7, #12]
2400242a:	681b      	ldr	r3, [r3, #0]
2400242c:	4a37      	ldr	r2, [pc, #220]	; (2400250c <HAL_DMA_Start+0x200>)
2400242e:	4293      	cmp	r3, r2
24002430:	d04a      	beq.n	240024c8 <HAL_DMA_Start+0x1bc>
24002432:	68fb      	ldr	r3, [r7, #12]
24002434:	681b      	ldr	r3, [r3, #0]
24002436:	4a36      	ldr	r2, [pc, #216]	; (24002510 <HAL_DMA_Start+0x204>)
24002438:	4293      	cmp	r3, r2
2400243a:	d045      	beq.n	240024c8 <HAL_DMA_Start+0x1bc>
2400243c:	68fb      	ldr	r3, [r7, #12]
2400243e:	681b      	ldr	r3, [r3, #0]
24002440:	4a34      	ldr	r2, [pc, #208]	; (24002514 <HAL_DMA_Start+0x208>)
24002442:	4293      	cmp	r3, r2
24002444:	d040      	beq.n	240024c8 <HAL_DMA_Start+0x1bc>
24002446:	68fb      	ldr	r3, [r7, #12]
24002448:	681b      	ldr	r3, [r3, #0]
2400244a:	4a33      	ldr	r2, [pc, #204]	; (24002518 <HAL_DMA_Start+0x20c>)
2400244c:	4293      	cmp	r3, r2
2400244e:	d03b      	beq.n	240024c8 <HAL_DMA_Start+0x1bc>
24002450:	68fb      	ldr	r3, [r7, #12]
24002452:	681b      	ldr	r3, [r3, #0]
24002454:	4a31      	ldr	r2, [pc, #196]	; (2400251c <HAL_DMA_Start+0x210>)
24002456:	4293      	cmp	r3, r2
24002458:	d036      	beq.n	240024c8 <HAL_DMA_Start+0x1bc>
2400245a:	68fb      	ldr	r3, [r7, #12]
2400245c:	681b      	ldr	r3, [r3, #0]
2400245e:	4a30      	ldr	r2, [pc, #192]	; (24002520 <HAL_DMA_Start+0x214>)
24002460:	4293      	cmp	r3, r2
24002462:	d031      	beq.n	240024c8 <HAL_DMA_Start+0x1bc>
24002464:	68fb      	ldr	r3, [r7, #12]
24002466:	681b      	ldr	r3, [r3, #0]
24002468:	4a2e      	ldr	r2, [pc, #184]	; (24002524 <HAL_DMA_Start+0x218>)
2400246a:	4293      	cmp	r3, r2
2400246c:	d02c      	beq.n	240024c8 <HAL_DMA_Start+0x1bc>
2400246e:	68fb      	ldr	r3, [r7, #12]
24002470:	681b      	ldr	r3, [r3, #0]
24002472:	4a2d      	ldr	r2, [pc, #180]	; (24002528 <HAL_DMA_Start+0x21c>)
24002474:	4293      	cmp	r3, r2
24002476:	d027      	beq.n	240024c8 <HAL_DMA_Start+0x1bc>
24002478:	68fb      	ldr	r3, [r7, #12]
2400247a:	681b      	ldr	r3, [r3, #0]
2400247c:	4a2b      	ldr	r2, [pc, #172]	; (2400252c <HAL_DMA_Start+0x220>)
2400247e:	4293      	cmp	r3, r2
24002480:	d022      	beq.n	240024c8 <HAL_DMA_Start+0x1bc>
24002482:	68fb      	ldr	r3, [r7, #12]
24002484:	681b      	ldr	r3, [r3, #0]
24002486:	4a2a      	ldr	r2, [pc, #168]	; (24002530 <HAL_DMA_Start+0x224>)
24002488:	4293      	cmp	r3, r2
2400248a:	d01d      	beq.n	240024c8 <HAL_DMA_Start+0x1bc>
2400248c:	68fb      	ldr	r3, [r7, #12]
2400248e:	681b      	ldr	r3, [r3, #0]
24002490:	4a28      	ldr	r2, [pc, #160]	; (24002534 <HAL_DMA_Start+0x228>)
24002492:	4293      	cmp	r3, r2
24002494:	d018      	beq.n	240024c8 <HAL_DMA_Start+0x1bc>
24002496:	68fb      	ldr	r3, [r7, #12]
24002498:	681b      	ldr	r3, [r3, #0]
2400249a:	4a27      	ldr	r2, [pc, #156]	; (24002538 <HAL_DMA_Start+0x22c>)
2400249c:	4293      	cmp	r3, r2
2400249e:	d013      	beq.n	240024c8 <HAL_DMA_Start+0x1bc>
240024a0:	68fb      	ldr	r3, [r7, #12]
240024a2:	681b      	ldr	r3, [r3, #0]
240024a4:	4a25      	ldr	r2, [pc, #148]	; (2400253c <HAL_DMA_Start+0x230>)
240024a6:	4293      	cmp	r3, r2
240024a8:	d00e      	beq.n	240024c8 <HAL_DMA_Start+0x1bc>
240024aa:	68fb      	ldr	r3, [r7, #12]
240024ac:	681b      	ldr	r3, [r3, #0]
240024ae:	4a24      	ldr	r2, [pc, #144]	; (24002540 <HAL_DMA_Start+0x234>)
240024b0:	4293      	cmp	r3, r2
240024b2:	d009      	beq.n	240024c8 <HAL_DMA_Start+0x1bc>
240024b4:	68fb      	ldr	r3, [r7, #12]
240024b6:	681b      	ldr	r3, [r3, #0]
240024b8:	4a22      	ldr	r2, [pc, #136]	; (24002544 <HAL_DMA_Start+0x238>)
240024ba:	4293      	cmp	r3, r2
240024bc:	d004      	beq.n	240024c8 <HAL_DMA_Start+0x1bc>
240024be:	68fb      	ldr	r3, [r7, #12]
240024c0:	681b      	ldr	r3, [r3, #0]
240024c2:	4a21      	ldr	r2, [pc, #132]	; (24002548 <HAL_DMA_Start+0x23c>)
240024c4:	4293      	cmp	r3, r2
240024c6:	d108      	bne.n	240024da <HAL_DMA_Start+0x1ce>
240024c8:	68fb      	ldr	r3, [r7, #12]
240024ca:	681b      	ldr	r3, [r3, #0]
240024cc:	681a      	ldr	r2, [r3, #0]
240024ce:	68fb      	ldr	r3, [r7, #12]
240024d0:	681b      	ldr	r3, [r3, #0]
240024d2:	f042 0201 	orr.w	r2, r2, #1
240024d6:	601a      	str	r2, [r3, #0]
240024d8:	e012      	b.n	24002500 <HAL_DMA_Start+0x1f4>
240024da:	68fb      	ldr	r3, [r7, #12]
240024dc:	681b      	ldr	r3, [r3, #0]
240024de:	681a      	ldr	r2, [r3, #0]
240024e0:	68fb      	ldr	r3, [r7, #12]
240024e2:	681b      	ldr	r3, [r3, #0]
240024e4:	f042 0201 	orr.w	r2, r2, #1
240024e8:	601a      	str	r2, [r3, #0]
240024ea:	e009      	b.n	24002500 <HAL_DMA_Start+0x1f4>
  }
  else
  {
    /* Process unlocked */
    __HAL_UNLOCK(hdma);
240024ec:	68fb      	ldr	r3, [r7, #12]
240024ee:	2200      	movs	r2, #0
240024f0:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

    /* Set the error code to busy */
    hdma->ErrorCode = HAL_DMA_ERROR_BUSY;
240024f4:	68fb      	ldr	r3, [r7, #12]
240024f6:	f44f 6200 	mov.w	r2, #2048	; 0x800
240024fa:	655a      	str	r2, [r3, #84]	; 0x54

    /* Return error status */
    status = HAL_ERROR;
240024fc:	2301      	movs	r3, #1
240024fe:	75fb      	strb	r3, [r7, #23]
  }
  return status;
24002500:	7dfb      	ldrb	r3, [r7, #23]
}
24002502:	4618      	mov	r0, r3
24002504:	3718      	adds	r7, #24
24002506:	46bd      	mov	sp, r7
24002508:	bd80      	pop	{r7, pc}
2400250a:	bf00      	nop
2400250c:	40020010 	.word	0x40020010
24002510:	40020028 	.word	0x40020028
24002514:	40020040 	.word	0x40020040
24002518:	40020058 	.word	0x40020058
2400251c:	40020070 	.word	0x40020070
24002520:	40020088 	.word	0x40020088
24002524:	400200a0 	.word	0x400200a0
24002528:	400200b8 	.word	0x400200b8
2400252c:	40020410 	.word	0x40020410
24002530:	40020428 	.word	0x40020428
24002534:	40020440 	.word	0x40020440
24002538:	40020458 	.word	0x40020458
2400253c:	40020470 	.word	0x40020470
24002540:	40020488 	.word	0x40020488
24002544:	400204a0 	.word	0x400204a0
24002548:	400204b8 	.word	0x400204b8

2400254c <HAL_DMA_Start_IT>:
  * @param  DstAddress: The destination memory Buffer address
  * @param  DataLength: The length of data to be transferred from source to destination
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Start_IT(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{
2400254c:	b580      	push	{r7, lr}
2400254e:	b086      	sub	sp, #24
24002550:	af00      	add	r7, sp, #0
24002552:	60f8      	str	r0, [r7, #12]
24002554:	60b9      	str	r1, [r7, #8]
24002556:	607a      	str	r2, [r7, #4]
24002558:	603b      	str	r3, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
2400255a:	2300      	movs	r3, #0
2400255c:	75fb      	strb	r3, [r7, #23]

  /* Check the parameters */
  assert_param(IS_DMA_BUFFER_SIZE(DataLength));

  /* Check the DMA peripheral handle */
  if(hdma == NULL)
2400255e:	68fb      	ldr	r3, [r7, #12]
24002560:	2b00      	cmp	r3, #0
24002562:	d101      	bne.n	24002568 <HAL_DMA_Start_IT+0x1c>
  {
    return HAL_ERROR;
24002564:	2301      	movs	r3, #1
24002566:	e226      	b.n	240029b6 <HAL_DMA_Start_IT+0x46a>
  }

  /* Process locked */
  __HAL_LOCK(hdma);
24002568:	68fb      	ldr	r3, [r7, #12]
2400256a:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
2400256e:	2b01      	cmp	r3, #1
24002570:	d101      	bne.n	24002576 <HAL_DMA_Start_IT+0x2a>
24002572:	2302      	movs	r3, #2
24002574:	e21f      	b.n	240029b6 <HAL_DMA_Start_IT+0x46a>
24002576:	68fb      	ldr	r3, [r7, #12]
24002578:	2201      	movs	r2, #1
2400257a:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

  if(HAL_DMA_STATE_READY == hdma->State)
2400257e:	68fb      	ldr	r3, [r7, #12]
24002580:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
24002584:	b2db      	uxtb	r3, r3
24002586:	2b01      	cmp	r3, #1
24002588:	f040 820a 	bne.w	240029a0 <HAL_DMA_Start_IT+0x454>
  {
    /* Change DMA peripheral state */
    hdma->State = HAL_DMA_STATE_BUSY;
2400258c:	68fb      	ldr	r3, [r7, #12]
2400258e:	2202      	movs	r2, #2
24002590:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

    /* Initialize the error code */
    hdma->ErrorCode = HAL_DMA_ERROR_NONE;
24002594:	68fb      	ldr	r3, [r7, #12]
24002596:	2200      	movs	r2, #0
24002598:	655a      	str	r2, [r3, #84]	; 0x54

    /* Disable the peripheral */
    __HAL_DMA_DISABLE(hdma);
2400259a:	68fb      	ldr	r3, [r7, #12]
2400259c:	681b      	ldr	r3, [r3, #0]
2400259e:	4a68      	ldr	r2, [pc, #416]	; (24002740 <HAL_DMA_Start_IT+0x1f4>)
240025a0:	4293      	cmp	r3, r2
240025a2:	d04a      	beq.n	2400263a <HAL_DMA_Start_IT+0xee>
240025a4:	68fb      	ldr	r3, [r7, #12]
240025a6:	681b      	ldr	r3, [r3, #0]
240025a8:	4a66      	ldr	r2, [pc, #408]	; (24002744 <HAL_DMA_Start_IT+0x1f8>)
240025aa:	4293      	cmp	r3, r2
240025ac:	d045      	beq.n	2400263a <HAL_DMA_Start_IT+0xee>
240025ae:	68fb      	ldr	r3, [r7, #12]
240025b0:	681b      	ldr	r3, [r3, #0]
240025b2:	4a65      	ldr	r2, [pc, #404]	; (24002748 <HAL_DMA_Start_IT+0x1fc>)
240025b4:	4293      	cmp	r3, r2
240025b6:	d040      	beq.n	2400263a <HAL_DMA_Start_IT+0xee>
240025b8:	68fb      	ldr	r3, [r7, #12]
240025ba:	681b      	ldr	r3, [r3, #0]
240025bc:	4a63      	ldr	r2, [pc, #396]	; (2400274c <HAL_DMA_Start_IT+0x200>)
240025be:	4293      	cmp	r3, r2
240025c0:	d03b      	beq.n	2400263a <HAL_DMA_Start_IT+0xee>
240025c2:	68fb      	ldr	r3, [r7, #12]
240025c4:	681b      	ldr	r3, [r3, #0]
240025c6:	4a62      	ldr	r2, [pc, #392]	; (24002750 <HAL_DMA_Start_IT+0x204>)
240025c8:	4293      	cmp	r3, r2
240025ca:	d036      	beq.n	2400263a <HAL_DMA_Start_IT+0xee>
240025cc:	68fb      	ldr	r3, [r7, #12]
240025ce:	681b      	ldr	r3, [r3, #0]
240025d0:	4a60      	ldr	r2, [pc, #384]	; (24002754 <HAL_DMA_Start_IT+0x208>)
240025d2:	4293      	cmp	r3, r2
240025d4:	d031      	beq.n	2400263a <HAL_DMA_Start_IT+0xee>
240025d6:	68fb      	ldr	r3, [r7, #12]
240025d8:	681b      	ldr	r3, [r3, #0]
240025da:	4a5f      	ldr	r2, [pc, #380]	; (24002758 <HAL_DMA_Start_IT+0x20c>)
240025dc:	4293      	cmp	r3, r2
240025de:	d02c      	beq.n	2400263a <HAL_DMA_Start_IT+0xee>
240025e0:	68fb      	ldr	r3, [r7, #12]
240025e2:	681b      	ldr	r3, [r3, #0]
240025e4:	4a5d      	ldr	r2, [pc, #372]	; (2400275c <HAL_DMA_Start_IT+0x210>)
240025e6:	4293      	cmp	r3, r2
240025e8:	d027      	beq.n	2400263a <HAL_DMA_Start_IT+0xee>
240025ea:	68fb      	ldr	r3, [r7, #12]
240025ec:	681b      	ldr	r3, [r3, #0]
240025ee:	4a5c      	ldr	r2, [pc, #368]	; (24002760 <HAL_DMA_Start_IT+0x214>)
240025f0:	4293      	cmp	r3, r2
240025f2:	d022      	beq.n	2400263a <HAL_DMA_Start_IT+0xee>
240025f4:	68fb      	ldr	r3, [r7, #12]
240025f6:	681b      	ldr	r3, [r3, #0]
240025f8:	4a5a      	ldr	r2, [pc, #360]	; (24002764 <HAL_DMA_Start_IT+0x218>)
240025fa:	4293      	cmp	r3, r2
240025fc:	d01d      	beq.n	2400263a <HAL_DMA_Start_IT+0xee>
240025fe:	68fb      	ldr	r3, [r7, #12]
24002600:	681b      	ldr	r3, [r3, #0]
24002602:	4a59      	ldr	r2, [pc, #356]	; (24002768 <HAL_DMA_Start_IT+0x21c>)
24002604:	4293      	cmp	r3, r2
24002606:	d018      	beq.n	2400263a <HAL_DMA_Start_IT+0xee>
24002608:	68fb      	ldr	r3, [r7, #12]
2400260a:	681b      	ldr	r3, [r3, #0]
2400260c:	4a57      	ldr	r2, [pc, #348]	; (2400276c <HAL_DMA_Start_IT+0x220>)
2400260e:	4293      	cmp	r3, r2
24002610:	d013      	beq.n	2400263a <HAL_DMA_Start_IT+0xee>
24002612:	68fb      	ldr	r3, [r7, #12]
24002614:	681b      	ldr	r3, [r3, #0]
24002616:	4a56      	ldr	r2, [pc, #344]	; (24002770 <HAL_DMA_Start_IT+0x224>)
24002618:	4293      	cmp	r3, r2
2400261a:	d00e      	beq.n	2400263a <HAL_DMA_Start_IT+0xee>
2400261c:	68fb      	ldr	r3, [r7, #12]
2400261e:	681b      	ldr	r3, [r3, #0]
24002620:	4a54      	ldr	r2, [pc, #336]	; (24002774 <HAL_DMA_Start_IT+0x228>)
24002622:	4293      	cmp	r3, r2
24002624:	d009      	beq.n	2400263a <HAL_DMA_Start_IT+0xee>
24002626:	68fb      	ldr	r3, [r7, #12]
24002628:	681b      	ldr	r3, [r3, #0]
2400262a:	4a53      	ldr	r2, [pc, #332]	; (24002778 <HAL_DMA_Start_IT+0x22c>)
2400262c:	4293      	cmp	r3, r2
2400262e:	d004      	beq.n	2400263a <HAL_DMA_Start_IT+0xee>
24002630:	68fb      	ldr	r3, [r7, #12]
24002632:	681b      	ldr	r3, [r3, #0]
24002634:	4a51      	ldr	r2, [pc, #324]	; (2400277c <HAL_DMA_Start_IT+0x230>)
24002636:	4293      	cmp	r3, r2
24002638:	d108      	bne.n	2400264c <HAL_DMA_Start_IT+0x100>
2400263a:	68fb      	ldr	r3, [r7, #12]
2400263c:	681b      	ldr	r3, [r3, #0]
2400263e:	681a      	ldr	r2, [r3, #0]
24002640:	68fb      	ldr	r3, [r7, #12]
24002642:	681b      	ldr	r3, [r3, #0]
24002644:	f022 0201 	bic.w	r2, r2, #1
24002648:	601a      	str	r2, [r3, #0]
2400264a:	e007      	b.n	2400265c <HAL_DMA_Start_IT+0x110>
2400264c:	68fb      	ldr	r3, [r7, #12]
2400264e:	681b      	ldr	r3, [r3, #0]
24002650:	681a      	ldr	r2, [r3, #0]
24002652:	68fb      	ldr	r3, [r7, #12]
24002654:	681b      	ldr	r3, [r3, #0]
24002656:	f022 0201 	bic.w	r2, r2, #1
2400265a:	601a      	str	r2, [r3, #0]

    /* Configure the source, destination address and the data length */
    DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength);
2400265c:	683b      	ldr	r3, [r7, #0]
2400265e:	687a      	ldr	r2, [r7, #4]
24002660:	68b9      	ldr	r1, [r7, #8]
24002662:	68f8      	ldr	r0, [r7, #12]
24002664:	f002 faf4 	bl	24004c50 <DMA_SetConfig>

    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
24002668:	68fb      	ldr	r3, [r7, #12]
2400266a:	681b      	ldr	r3, [r3, #0]
2400266c:	4a34      	ldr	r2, [pc, #208]	; (24002740 <HAL_DMA_Start_IT+0x1f4>)
2400266e:	4293      	cmp	r3, r2
24002670:	d04a      	beq.n	24002708 <HAL_DMA_Start_IT+0x1bc>
24002672:	68fb      	ldr	r3, [r7, #12]
24002674:	681b      	ldr	r3, [r3, #0]
24002676:	4a33      	ldr	r2, [pc, #204]	; (24002744 <HAL_DMA_Start_IT+0x1f8>)
24002678:	4293      	cmp	r3, r2
2400267a:	d045      	beq.n	24002708 <HAL_DMA_Start_IT+0x1bc>
2400267c:	68fb      	ldr	r3, [r7, #12]
2400267e:	681b      	ldr	r3, [r3, #0]
24002680:	4a31      	ldr	r2, [pc, #196]	; (24002748 <HAL_DMA_Start_IT+0x1fc>)
24002682:	4293      	cmp	r3, r2
24002684:	d040      	beq.n	24002708 <HAL_DMA_Start_IT+0x1bc>
24002686:	68fb      	ldr	r3, [r7, #12]
24002688:	681b      	ldr	r3, [r3, #0]
2400268a:	4a30      	ldr	r2, [pc, #192]	; (2400274c <HAL_DMA_Start_IT+0x200>)
2400268c:	4293      	cmp	r3, r2
2400268e:	d03b      	beq.n	24002708 <HAL_DMA_Start_IT+0x1bc>
24002690:	68fb      	ldr	r3, [r7, #12]
24002692:	681b      	ldr	r3, [r3, #0]
24002694:	4a2e      	ldr	r2, [pc, #184]	; (24002750 <HAL_DMA_Start_IT+0x204>)
24002696:	4293      	cmp	r3, r2
24002698:	d036      	beq.n	24002708 <HAL_DMA_Start_IT+0x1bc>
2400269a:	68fb      	ldr	r3, [r7, #12]
2400269c:	681b      	ldr	r3, [r3, #0]
2400269e:	4a2d      	ldr	r2, [pc, #180]	; (24002754 <HAL_DMA_Start_IT+0x208>)
240026a0:	4293      	cmp	r3, r2
240026a2:	d031      	beq.n	24002708 <HAL_DMA_Start_IT+0x1bc>
240026a4:	68fb      	ldr	r3, [r7, #12]
240026a6:	681b      	ldr	r3, [r3, #0]
240026a8:	4a2b      	ldr	r2, [pc, #172]	; (24002758 <HAL_DMA_Start_IT+0x20c>)
240026aa:	4293      	cmp	r3, r2
240026ac:	d02c      	beq.n	24002708 <HAL_DMA_Start_IT+0x1bc>
240026ae:	68fb      	ldr	r3, [r7, #12]
240026b0:	681b      	ldr	r3, [r3, #0]
240026b2:	4a2a      	ldr	r2, [pc, #168]	; (2400275c <HAL_DMA_Start_IT+0x210>)
240026b4:	4293      	cmp	r3, r2
240026b6:	d027      	beq.n	24002708 <HAL_DMA_Start_IT+0x1bc>
240026b8:	68fb      	ldr	r3, [r7, #12]
240026ba:	681b      	ldr	r3, [r3, #0]
240026bc:	4a28      	ldr	r2, [pc, #160]	; (24002760 <HAL_DMA_Start_IT+0x214>)
240026be:	4293      	cmp	r3, r2
240026c0:	d022      	beq.n	24002708 <HAL_DMA_Start_IT+0x1bc>
240026c2:	68fb      	ldr	r3, [r7, #12]
240026c4:	681b      	ldr	r3, [r3, #0]
240026c6:	4a27      	ldr	r2, [pc, #156]	; (24002764 <HAL_DMA_Start_IT+0x218>)
240026c8:	4293      	cmp	r3, r2
240026ca:	d01d      	beq.n	24002708 <HAL_DMA_Start_IT+0x1bc>
240026cc:	68fb      	ldr	r3, [r7, #12]
240026ce:	681b      	ldr	r3, [r3, #0]
240026d0:	4a25      	ldr	r2, [pc, #148]	; (24002768 <HAL_DMA_Start_IT+0x21c>)
240026d2:	4293      	cmp	r3, r2
240026d4:	d018      	beq.n	24002708 <HAL_DMA_Start_IT+0x1bc>
240026d6:	68fb      	ldr	r3, [r7, #12]
240026d8:	681b      	ldr	r3, [r3, #0]
240026da:	4a24      	ldr	r2, [pc, #144]	; (2400276c <HAL_DMA_Start_IT+0x220>)
240026dc:	4293      	cmp	r3, r2
240026de:	d013      	beq.n	24002708 <HAL_DMA_Start_IT+0x1bc>
240026e0:	68fb      	ldr	r3, [r7, #12]
240026e2:	681b      	ldr	r3, [r3, #0]
240026e4:	4a22      	ldr	r2, [pc, #136]	; (24002770 <HAL_DMA_Start_IT+0x224>)
240026e6:	4293      	cmp	r3, r2
240026e8:	d00e      	beq.n	24002708 <HAL_DMA_Start_IT+0x1bc>
240026ea:	68fb      	ldr	r3, [r7, #12]
240026ec:	681b      	ldr	r3, [r3, #0]
240026ee:	4a21      	ldr	r2, [pc, #132]	; (24002774 <HAL_DMA_Start_IT+0x228>)
240026f0:	4293      	cmp	r3, r2
240026f2:	d009      	beq.n	24002708 <HAL_DMA_Start_IT+0x1bc>
240026f4:	68fb      	ldr	r3, [r7, #12]
240026f6:	681b      	ldr	r3, [r3, #0]
240026f8:	4a1f      	ldr	r2, [pc, #124]	; (24002778 <HAL_DMA_Start_IT+0x22c>)
240026fa:	4293      	cmp	r3, r2
240026fc:	d004      	beq.n	24002708 <HAL_DMA_Start_IT+0x1bc>
240026fe:	68fb      	ldr	r3, [r7, #12]
24002700:	681b      	ldr	r3, [r3, #0]
24002702:	4a1e      	ldr	r2, [pc, #120]	; (2400277c <HAL_DMA_Start_IT+0x230>)
24002704:	4293      	cmp	r3, r2
24002706:	d101      	bne.n	2400270c <HAL_DMA_Start_IT+0x1c0>
24002708:	2301      	movs	r3, #1
2400270a:	e000      	b.n	2400270e <HAL_DMA_Start_IT+0x1c2>
2400270c:	2300      	movs	r3, #0
2400270e:	2b00      	cmp	r3, #0
24002710:	d036      	beq.n	24002780 <HAL_DMA_Start_IT+0x234>
    {
      /* Enable Common interrupts*/
      MODIFY_REG(((DMA_Stream_TypeDef   *)hdma->Instance)->CR, (DMA_IT_TC | DMA_IT_TE | DMA_IT_DME | DMA_IT_HT), (DMA_IT_TC | DMA_IT_TE | DMA_IT_DME));
24002712:	68fb      	ldr	r3, [r7, #12]
24002714:	681b      	ldr	r3, [r3, #0]
24002716:	681b      	ldr	r3, [r3, #0]
24002718:	f023 021e 	bic.w	r2, r3, #30
2400271c:	68fb      	ldr	r3, [r7, #12]
2400271e:	681b      	ldr	r3, [r3, #0]
24002720:	f042 0216 	orr.w	r2, r2, #22
24002724:	601a      	str	r2, [r3, #0]

      if(hdma->XferHalfCpltCallback != NULL)
24002726:	68fb      	ldr	r3, [r7, #12]
24002728:	6c1b      	ldr	r3, [r3, #64]	; 0x40
2400272a:	2b00      	cmp	r3, #0
2400272c:	d03e      	beq.n	240027ac <HAL_DMA_Start_IT+0x260>
      {
        /* Enable Half Transfer IT if corresponding Callback is set */
        ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  |= DMA_IT_HT;
2400272e:	68fb      	ldr	r3, [r7, #12]
24002730:	681b      	ldr	r3, [r3, #0]
24002732:	681a      	ldr	r2, [r3, #0]
24002734:	68fb      	ldr	r3, [r7, #12]
24002736:	681b      	ldr	r3, [r3, #0]
24002738:	f042 0208 	orr.w	r2, r2, #8
2400273c:	601a      	str	r2, [r3, #0]
2400273e:	e035      	b.n	240027ac <HAL_DMA_Start_IT+0x260>
24002740:	40020010 	.word	0x40020010
24002744:	40020028 	.word	0x40020028
24002748:	40020040 	.word	0x40020040
2400274c:	40020058 	.word	0x40020058
24002750:	40020070 	.word	0x40020070
24002754:	40020088 	.word	0x40020088
24002758:	400200a0 	.word	0x400200a0
2400275c:	400200b8 	.word	0x400200b8
24002760:	40020410 	.word	0x40020410
24002764:	40020428 	.word	0x40020428
24002768:	40020440 	.word	0x40020440
2400276c:	40020458 	.word	0x40020458
24002770:	40020470 	.word	0x40020470
24002774:	40020488 	.word	0x40020488
24002778:	400204a0 	.word	0x400204a0
2400277c:	400204b8 	.word	0x400204b8
      }
    }
    else /* BDMA channel */
    {
      /* Enable Common interrupts */
      MODIFY_REG(((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR, (BDMA_CCR_TCIE | BDMA_CCR_HTIE | BDMA_CCR_TEIE), (BDMA_CCR_TCIE | BDMA_CCR_TEIE));
24002780:	68fb      	ldr	r3, [r7, #12]
24002782:	681b      	ldr	r3, [r3, #0]
24002784:	681b      	ldr	r3, [r3, #0]
24002786:	f023 020e 	bic.w	r2, r3, #14
2400278a:	68fb      	ldr	r3, [r7, #12]
2400278c:	681b      	ldr	r3, [r3, #0]
2400278e:	f042 020a 	orr.w	r2, r2, #10
24002792:	601a      	str	r2, [r3, #0]

      if(hdma->XferHalfCpltCallback != NULL)
24002794:	68fb      	ldr	r3, [r7, #12]
24002796:	6c1b      	ldr	r3, [r3, #64]	; 0x40
24002798:	2b00      	cmp	r3, #0
2400279a:	d007      	beq.n	240027ac <HAL_DMA_Start_IT+0x260>
      {
        /*Enable Half Transfer IT if corresponding Callback is set */
        ((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR  |= BDMA_CCR_HTIE;
2400279c:	68fb      	ldr	r3, [r7, #12]
2400279e:	681b      	ldr	r3, [r3, #0]
240027a0:	681a      	ldr	r2, [r3, #0]
240027a2:	68fb      	ldr	r3, [r7, #12]
240027a4:	681b      	ldr	r3, [r3, #0]
240027a6:	f042 0204 	orr.w	r2, r2, #4
240027aa:	601a      	str	r2, [r3, #0]
      }
    }

    if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
240027ac:	68fb      	ldr	r3, [r7, #12]
240027ae:	681b      	ldr	r3, [r3, #0]
240027b0:	4a83      	ldr	r2, [pc, #524]	; (240029c0 <HAL_DMA_Start_IT+0x474>)
240027b2:	4293      	cmp	r3, r2
240027b4:	d072      	beq.n	2400289c <HAL_DMA_Start_IT+0x350>
240027b6:	68fb      	ldr	r3, [r7, #12]
240027b8:	681b      	ldr	r3, [r3, #0]
240027ba:	4a82      	ldr	r2, [pc, #520]	; (240029c4 <HAL_DMA_Start_IT+0x478>)
240027bc:	4293      	cmp	r3, r2
240027be:	d06d      	beq.n	2400289c <HAL_DMA_Start_IT+0x350>
240027c0:	68fb      	ldr	r3, [r7, #12]
240027c2:	681b      	ldr	r3, [r3, #0]
240027c4:	4a80      	ldr	r2, [pc, #512]	; (240029c8 <HAL_DMA_Start_IT+0x47c>)
240027c6:	4293      	cmp	r3, r2
240027c8:	d068      	beq.n	2400289c <HAL_DMA_Start_IT+0x350>
240027ca:	68fb      	ldr	r3, [r7, #12]
240027cc:	681b      	ldr	r3, [r3, #0]
240027ce:	4a7f      	ldr	r2, [pc, #508]	; (240029cc <HAL_DMA_Start_IT+0x480>)
240027d0:	4293      	cmp	r3, r2
240027d2:	d063      	beq.n	2400289c <HAL_DMA_Start_IT+0x350>
240027d4:	68fb      	ldr	r3, [r7, #12]
240027d6:	681b      	ldr	r3, [r3, #0]
240027d8:	4a7d      	ldr	r2, [pc, #500]	; (240029d0 <HAL_DMA_Start_IT+0x484>)
240027da:	4293      	cmp	r3, r2
240027dc:	d05e      	beq.n	2400289c <HAL_DMA_Start_IT+0x350>
240027de:	68fb      	ldr	r3, [r7, #12]
240027e0:	681b      	ldr	r3, [r3, #0]
240027e2:	4a7c      	ldr	r2, [pc, #496]	; (240029d4 <HAL_DMA_Start_IT+0x488>)
240027e4:	4293      	cmp	r3, r2
240027e6:	d059      	beq.n	2400289c <HAL_DMA_Start_IT+0x350>
240027e8:	68fb      	ldr	r3, [r7, #12]
240027ea:	681b      	ldr	r3, [r3, #0]
240027ec:	4a7a      	ldr	r2, [pc, #488]	; (240029d8 <HAL_DMA_Start_IT+0x48c>)
240027ee:	4293      	cmp	r3, r2
240027f0:	d054      	beq.n	2400289c <HAL_DMA_Start_IT+0x350>
240027f2:	68fb      	ldr	r3, [r7, #12]
240027f4:	681b      	ldr	r3, [r3, #0]
240027f6:	4a79      	ldr	r2, [pc, #484]	; (240029dc <HAL_DMA_Start_IT+0x490>)
240027f8:	4293      	cmp	r3, r2
240027fa:	d04f      	beq.n	2400289c <HAL_DMA_Start_IT+0x350>
240027fc:	68fb      	ldr	r3, [r7, #12]
240027fe:	681b      	ldr	r3, [r3, #0]
24002800:	4a77      	ldr	r2, [pc, #476]	; (240029e0 <HAL_DMA_Start_IT+0x494>)
24002802:	4293      	cmp	r3, r2
24002804:	d04a      	beq.n	2400289c <HAL_DMA_Start_IT+0x350>
24002806:	68fb      	ldr	r3, [r7, #12]
24002808:	681b      	ldr	r3, [r3, #0]
2400280a:	4a76      	ldr	r2, [pc, #472]	; (240029e4 <HAL_DMA_Start_IT+0x498>)
2400280c:	4293      	cmp	r3, r2
2400280e:	d045      	beq.n	2400289c <HAL_DMA_Start_IT+0x350>
24002810:	68fb      	ldr	r3, [r7, #12]
24002812:	681b      	ldr	r3, [r3, #0]
24002814:	4a74      	ldr	r2, [pc, #464]	; (240029e8 <HAL_DMA_Start_IT+0x49c>)
24002816:	4293      	cmp	r3, r2
24002818:	d040      	beq.n	2400289c <HAL_DMA_Start_IT+0x350>
2400281a:	68fb      	ldr	r3, [r7, #12]
2400281c:	681b      	ldr	r3, [r3, #0]
2400281e:	4a73      	ldr	r2, [pc, #460]	; (240029ec <HAL_DMA_Start_IT+0x4a0>)
24002820:	4293      	cmp	r3, r2
24002822:	d03b      	beq.n	2400289c <HAL_DMA_Start_IT+0x350>
24002824:	68fb      	ldr	r3, [r7, #12]
24002826:	681b      	ldr	r3, [r3, #0]
24002828:	4a71      	ldr	r2, [pc, #452]	; (240029f0 <HAL_DMA_Start_IT+0x4a4>)
2400282a:	4293      	cmp	r3, r2
2400282c:	d036      	beq.n	2400289c <HAL_DMA_Start_IT+0x350>
2400282e:	68fb      	ldr	r3, [r7, #12]
24002830:	681b      	ldr	r3, [r3, #0]
24002832:	4a70      	ldr	r2, [pc, #448]	; (240029f4 <HAL_DMA_Start_IT+0x4a8>)
24002834:	4293      	cmp	r3, r2
24002836:	d031      	beq.n	2400289c <HAL_DMA_Start_IT+0x350>
24002838:	68fb      	ldr	r3, [r7, #12]
2400283a:	681b      	ldr	r3, [r3, #0]
2400283c:	4a6e      	ldr	r2, [pc, #440]	; (240029f8 <HAL_DMA_Start_IT+0x4ac>)
2400283e:	4293      	cmp	r3, r2
24002840:	d02c      	beq.n	2400289c <HAL_DMA_Start_IT+0x350>
24002842:	68fb      	ldr	r3, [r7, #12]
24002844:	681b      	ldr	r3, [r3, #0]
24002846:	4a6d      	ldr	r2, [pc, #436]	; (240029fc <HAL_DMA_Start_IT+0x4b0>)
24002848:	4293      	cmp	r3, r2
2400284a:	d027      	beq.n	2400289c <HAL_DMA_Start_IT+0x350>
2400284c:	68fb      	ldr	r3, [r7, #12]
2400284e:	681b      	ldr	r3, [r3, #0]
24002850:	4a6b      	ldr	r2, [pc, #428]	; (24002a00 <HAL_DMA_Start_IT+0x4b4>)
24002852:	4293      	cmp	r3, r2
24002854:	d022      	beq.n	2400289c <HAL_DMA_Start_IT+0x350>
24002856:	68fb      	ldr	r3, [r7, #12]
24002858:	681b      	ldr	r3, [r3, #0]
2400285a:	4a6a      	ldr	r2, [pc, #424]	; (24002a04 <HAL_DMA_Start_IT+0x4b8>)
2400285c:	4293      	cmp	r3, r2
2400285e:	d01d      	beq.n	2400289c <HAL_DMA_Start_IT+0x350>
24002860:	68fb      	ldr	r3, [r7, #12]
24002862:	681b      	ldr	r3, [r3, #0]
24002864:	4a68      	ldr	r2, [pc, #416]	; (24002a08 <HAL_DMA_Start_IT+0x4bc>)
24002866:	4293      	cmp	r3, r2
24002868:	d018      	beq.n	2400289c <HAL_DMA_Start_IT+0x350>
2400286a:	68fb      	ldr	r3, [r7, #12]
2400286c:	681b      	ldr	r3, [r3, #0]
2400286e:	4a67      	ldr	r2, [pc, #412]	; (24002a0c <HAL_DMA_Start_IT+0x4c0>)
24002870:	4293      	cmp	r3, r2
24002872:	d013      	beq.n	2400289c <HAL_DMA_Start_IT+0x350>
24002874:	68fb      	ldr	r3, [r7, #12]
24002876:	681b      	ldr	r3, [r3, #0]
24002878:	4a65      	ldr	r2, [pc, #404]	; (24002a10 <HAL_DMA_Start_IT+0x4c4>)
2400287a:	4293      	cmp	r3, r2
2400287c:	d00e      	beq.n	2400289c <HAL_DMA_Start_IT+0x350>
2400287e:	68fb      	ldr	r3, [r7, #12]
24002880:	681b      	ldr	r3, [r3, #0]
24002882:	4a64      	ldr	r2, [pc, #400]	; (24002a14 <HAL_DMA_Start_IT+0x4c8>)
24002884:	4293      	cmp	r3, r2
24002886:	d009      	beq.n	2400289c <HAL_DMA_Start_IT+0x350>
24002888:	68fb      	ldr	r3, [r7, #12]
2400288a:	681b      	ldr	r3, [r3, #0]
2400288c:	4a62      	ldr	r2, [pc, #392]	; (24002a18 <HAL_DMA_Start_IT+0x4cc>)
2400288e:	4293      	cmp	r3, r2
24002890:	d004      	beq.n	2400289c <HAL_DMA_Start_IT+0x350>
24002892:	68fb      	ldr	r3, [r7, #12]
24002894:	681b      	ldr	r3, [r3, #0]
24002896:	4a61      	ldr	r2, [pc, #388]	; (24002a1c <HAL_DMA_Start_IT+0x4d0>)
24002898:	4293      	cmp	r3, r2
2400289a:	d101      	bne.n	240028a0 <HAL_DMA_Start_IT+0x354>
2400289c:	2301      	movs	r3, #1
2400289e:	e000      	b.n	240028a2 <HAL_DMA_Start_IT+0x356>
240028a0:	2300      	movs	r3, #0
240028a2:	2b00      	cmp	r3, #0
240028a4:	d01a      	beq.n	240028dc <HAL_DMA_Start_IT+0x390>
    {
      /* Check if DMAMUX Synchronization is enabled */
      if((hdma->DMAmuxChannel->CCR & DMAMUX_CxCR_SE) != 0U)
240028a6:	68fb      	ldr	r3, [r7, #12]
240028a8:	6e1b      	ldr	r3, [r3, #96]	; 0x60
240028aa:	681b      	ldr	r3, [r3, #0]
240028ac:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
240028b0:	2b00      	cmp	r3, #0
240028b2:	d007      	beq.n	240028c4 <HAL_DMA_Start_IT+0x378>
      {
        /* Enable DMAMUX sync overrun IT*/
        hdma->DMAmuxChannel->CCR |= DMAMUX_CxCR_SOIE;
240028b4:	68fb      	ldr	r3, [r7, #12]
240028b6:	6e1b      	ldr	r3, [r3, #96]	; 0x60
240028b8:	681a      	ldr	r2, [r3, #0]
240028ba:	68fb      	ldr	r3, [r7, #12]
240028bc:	6e1b      	ldr	r3, [r3, #96]	; 0x60
240028be:	f442 7280 	orr.w	r2, r2, #256	; 0x100
240028c2:	601a      	str	r2, [r3, #0]
      }

      if(hdma->DMAmuxRequestGen != 0U)
240028c4:	68fb      	ldr	r3, [r7, #12]
240028c6:	6edb      	ldr	r3, [r3, #108]	; 0x6c
240028c8:	2b00      	cmp	r3, #0
240028ca:	d007      	beq.n	240028dc <HAL_DMA_Start_IT+0x390>
      {
        /* if using DMAMUX request generator, enable the DMAMUX request generator overrun IT*/
        /* enable the request gen overrun IT */
        hdma->DMAmuxRequestGen->RGCR |= DMAMUX_RGxCR_OIE;
240028cc:	68fb      	ldr	r3, [r7, #12]
240028ce:	6edb      	ldr	r3, [r3, #108]	; 0x6c
240028d0:	681a      	ldr	r2, [r3, #0]
240028d2:	68fb      	ldr	r3, [r7, #12]
240028d4:	6edb      	ldr	r3, [r3, #108]	; 0x6c
240028d6:	f442 7280 	orr.w	r2, r2, #256	; 0x100
240028da:	601a      	str	r2, [r3, #0]
      }
    }

    /* Enable the Peripheral */
    __HAL_DMA_ENABLE(hdma);
240028dc:	68fb      	ldr	r3, [r7, #12]
240028de:	681b      	ldr	r3, [r3, #0]
240028e0:	4a37      	ldr	r2, [pc, #220]	; (240029c0 <HAL_DMA_Start_IT+0x474>)
240028e2:	4293      	cmp	r3, r2
240028e4:	d04a      	beq.n	2400297c <HAL_DMA_Start_IT+0x430>
240028e6:	68fb      	ldr	r3, [r7, #12]
240028e8:	681b      	ldr	r3, [r3, #0]
240028ea:	4a36      	ldr	r2, [pc, #216]	; (240029c4 <HAL_DMA_Start_IT+0x478>)
240028ec:	4293      	cmp	r3, r2
240028ee:	d045      	beq.n	2400297c <HAL_DMA_Start_IT+0x430>
240028f0:	68fb      	ldr	r3, [r7, #12]
240028f2:	681b      	ldr	r3, [r3, #0]
240028f4:	4a34      	ldr	r2, [pc, #208]	; (240029c8 <HAL_DMA_Start_IT+0x47c>)
240028f6:	4293      	cmp	r3, r2
240028f8:	d040      	beq.n	2400297c <HAL_DMA_Start_IT+0x430>
240028fa:	68fb      	ldr	r3, [r7, #12]
240028fc:	681b      	ldr	r3, [r3, #0]
240028fe:	4a33      	ldr	r2, [pc, #204]	; (240029cc <HAL_DMA_Start_IT+0x480>)
24002900:	4293      	cmp	r3, r2
24002902:	d03b      	beq.n	2400297c <HAL_DMA_Start_IT+0x430>
24002904:	68fb      	ldr	r3, [r7, #12]
24002906:	681b      	ldr	r3, [r3, #0]
24002908:	4a31      	ldr	r2, [pc, #196]	; (240029d0 <HAL_DMA_Start_IT+0x484>)
2400290a:	4293      	cmp	r3, r2
2400290c:	d036      	beq.n	2400297c <HAL_DMA_Start_IT+0x430>
2400290e:	68fb      	ldr	r3, [r7, #12]
24002910:	681b      	ldr	r3, [r3, #0]
24002912:	4a30      	ldr	r2, [pc, #192]	; (240029d4 <HAL_DMA_Start_IT+0x488>)
24002914:	4293      	cmp	r3, r2
24002916:	d031      	beq.n	2400297c <HAL_DMA_Start_IT+0x430>
24002918:	68fb      	ldr	r3, [r7, #12]
2400291a:	681b      	ldr	r3, [r3, #0]
2400291c:	4a2e      	ldr	r2, [pc, #184]	; (240029d8 <HAL_DMA_Start_IT+0x48c>)
2400291e:	4293      	cmp	r3, r2
24002920:	d02c      	beq.n	2400297c <HAL_DMA_Start_IT+0x430>
24002922:	68fb      	ldr	r3, [r7, #12]
24002924:	681b      	ldr	r3, [r3, #0]
24002926:	4a2d      	ldr	r2, [pc, #180]	; (240029dc <HAL_DMA_Start_IT+0x490>)
24002928:	4293      	cmp	r3, r2
2400292a:	d027      	beq.n	2400297c <HAL_DMA_Start_IT+0x430>
2400292c:	68fb      	ldr	r3, [r7, #12]
2400292e:	681b      	ldr	r3, [r3, #0]
24002930:	4a2b      	ldr	r2, [pc, #172]	; (240029e0 <HAL_DMA_Start_IT+0x494>)
24002932:	4293      	cmp	r3, r2
24002934:	d022      	beq.n	2400297c <HAL_DMA_Start_IT+0x430>
24002936:	68fb      	ldr	r3, [r7, #12]
24002938:	681b      	ldr	r3, [r3, #0]
2400293a:	4a2a      	ldr	r2, [pc, #168]	; (240029e4 <HAL_DMA_Start_IT+0x498>)
2400293c:	4293      	cmp	r3, r2
2400293e:	d01d      	beq.n	2400297c <HAL_DMA_Start_IT+0x430>
24002940:	68fb      	ldr	r3, [r7, #12]
24002942:	681b      	ldr	r3, [r3, #0]
24002944:	4a28      	ldr	r2, [pc, #160]	; (240029e8 <HAL_DMA_Start_IT+0x49c>)
24002946:	4293      	cmp	r3, r2
24002948:	d018      	beq.n	2400297c <HAL_DMA_Start_IT+0x430>
2400294a:	68fb      	ldr	r3, [r7, #12]
2400294c:	681b      	ldr	r3, [r3, #0]
2400294e:	4a27      	ldr	r2, [pc, #156]	; (240029ec <HAL_DMA_Start_IT+0x4a0>)
24002950:	4293      	cmp	r3, r2
24002952:	d013      	beq.n	2400297c <HAL_DMA_Start_IT+0x430>
24002954:	68fb      	ldr	r3, [r7, #12]
24002956:	681b      	ldr	r3, [r3, #0]
24002958:	4a25      	ldr	r2, [pc, #148]	; (240029f0 <HAL_DMA_Start_IT+0x4a4>)
2400295a:	4293      	cmp	r3, r2
2400295c:	d00e      	beq.n	2400297c <HAL_DMA_Start_IT+0x430>
2400295e:	68fb      	ldr	r3, [r7, #12]
24002960:	681b      	ldr	r3, [r3, #0]
24002962:	4a24      	ldr	r2, [pc, #144]	; (240029f4 <HAL_DMA_Start_IT+0x4a8>)
24002964:	4293      	cmp	r3, r2
24002966:	d009      	beq.n	2400297c <HAL_DMA_Start_IT+0x430>
24002968:	68fb      	ldr	r3, [r7, #12]
2400296a:	681b      	ldr	r3, [r3, #0]
2400296c:	4a22      	ldr	r2, [pc, #136]	; (240029f8 <HAL_DMA_Start_IT+0x4ac>)
2400296e:	4293      	cmp	r3, r2
24002970:	d004      	beq.n	2400297c <HAL_DMA_Start_IT+0x430>
24002972:	68fb      	ldr	r3, [r7, #12]
24002974:	681b      	ldr	r3, [r3, #0]
24002976:	4a21      	ldr	r2, [pc, #132]	; (240029fc <HAL_DMA_Start_IT+0x4b0>)
24002978:	4293      	cmp	r3, r2
2400297a:	d108      	bne.n	2400298e <HAL_DMA_Start_IT+0x442>
2400297c:	68fb      	ldr	r3, [r7, #12]
2400297e:	681b      	ldr	r3, [r3, #0]
24002980:	681a      	ldr	r2, [r3, #0]
24002982:	68fb      	ldr	r3, [r7, #12]
24002984:	681b      	ldr	r3, [r3, #0]
24002986:	f042 0201 	orr.w	r2, r2, #1
2400298a:	601a      	str	r2, [r3, #0]
2400298c:	e012      	b.n	240029b4 <HAL_DMA_Start_IT+0x468>
2400298e:	68fb      	ldr	r3, [r7, #12]
24002990:	681b      	ldr	r3, [r3, #0]
24002992:	681a      	ldr	r2, [r3, #0]
24002994:	68fb      	ldr	r3, [r7, #12]
24002996:	681b      	ldr	r3, [r3, #0]
24002998:	f042 0201 	orr.w	r2, r2, #1
2400299c:	601a      	str	r2, [r3, #0]
2400299e:	e009      	b.n	240029b4 <HAL_DMA_Start_IT+0x468>
  }
  else
  {
    /* Process unlocked */
    __HAL_UNLOCK(hdma);
240029a0:	68fb      	ldr	r3, [r7, #12]
240029a2:	2200      	movs	r2, #0
240029a4:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

    /* Set the error code to busy */
    hdma->ErrorCode = HAL_DMA_ERROR_BUSY;
240029a8:	68fb      	ldr	r3, [r7, #12]
240029aa:	f44f 6200 	mov.w	r2, #2048	; 0x800
240029ae:	655a      	str	r2, [r3, #84]	; 0x54

    /* Return error status */
    status = HAL_ERROR;
240029b0:	2301      	movs	r3, #1
240029b2:	75fb      	strb	r3, [r7, #23]
  }

  return status;
240029b4:	7dfb      	ldrb	r3, [r7, #23]
}
240029b6:	4618      	mov	r0, r3
240029b8:	3718      	adds	r7, #24
240029ba:	46bd      	mov	sp, r7
240029bc:	bd80      	pop	{r7, pc}
240029be:	bf00      	nop
240029c0:	40020010 	.word	0x40020010
240029c4:	40020028 	.word	0x40020028
240029c8:	40020040 	.word	0x40020040
240029cc:	40020058 	.word	0x40020058
240029d0:	40020070 	.word	0x40020070
240029d4:	40020088 	.word	0x40020088
240029d8:	400200a0 	.word	0x400200a0
240029dc:	400200b8 	.word	0x400200b8
240029e0:	40020410 	.word	0x40020410
240029e4:	40020428 	.word	0x40020428
240029e8:	40020440 	.word	0x40020440
240029ec:	40020458 	.word	0x40020458
240029f0:	40020470 	.word	0x40020470
240029f4:	40020488 	.word	0x40020488
240029f8:	400204a0 	.word	0x400204a0
240029fc:	400204b8 	.word	0x400204b8
24002a00:	58025408 	.word	0x58025408
24002a04:	5802541c 	.word	0x5802541c
24002a08:	58025430 	.word	0x58025430
24002a0c:	58025444 	.word	0x58025444
24002a10:	58025458 	.word	0x58025458
24002a14:	5802546c 	.word	0x5802546c
24002a18:	58025480 	.word	0x58025480
24002a1c:	58025494 	.word	0x58025494

24002a20 <HAL_DMA_Abort>:
  *        and the Stream will be effectively disabled only after the transfer of
  *        this single data is finished.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Abort(DMA_HandleTypeDef *hdma)
{
24002a20:	b580      	push	{r7, lr}
24002a22:	b086      	sub	sp, #24
24002a24:	af00      	add	r7, sp, #0
24002a26:	6078      	str	r0, [r7, #4]
  /* calculate DMA base and stream number */
  DMA_Base_Registers *regs_dma;
  BDMA_Base_Registers *regs_bdma;
  const __IO uint32_t *enableRegister;

  uint32_t tickstart = HAL_GetTick();
24002a28:	f7fd ff12 	bl	24000850 <HAL_GetTick>
24002a2c:	6138      	str	r0, [r7, #16]

 /* Check the DMA peripheral handle */
  if(hdma == NULL)
24002a2e:	687b      	ldr	r3, [r7, #4]
24002a30:	2b00      	cmp	r3, #0
24002a32:	d101      	bne.n	24002a38 <HAL_DMA_Abort+0x18>
  {
    return HAL_ERROR;
24002a34:	2301      	movs	r3, #1
24002a36:	e2dc      	b.n	24002ff2 <HAL_DMA_Abort+0x5d2>
  }

  /* Check the DMA peripheral state */
  if(hdma->State != HAL_DMA_STATE_BUSY)
24002a38:	687b      	ldr	r3, [r7, #4]
24002a3a:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
24002a3e:	b2db      	uxtb	r3, r3
24002a40:	2b02      	cmp	r3, #2
24002a42:	d008      	beq.n	24002a56 <HAL_DMA_Abort+0x36>
  {
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
24002a44:	687b      	ldr	r3, [r7, #4]
24002a46:	2280      	movs	r2, #128	; 0x80
24002a48:	655a      	str	r2, [r3, #84]	; 0x54

    /* Process Unlocked */
    __HAL_UNLOCK(hdma);
24002a4a:	687b      	ldr	r3, [r7, #4]
24002a4c:	2200      	movs	r2, #0
24002a4e:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

    return HAL_ERROR;
24002a52:	2301      	movs	r3, #1
24002a54:	e2cd      	b.n	24002ff2 <HAL_DMA_Abort+0x5d2>
  }
  else
  {
    /* Disable all the transfer interrupts */
    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
24002a56:	687b      	ldr	r3, [r7, #4]
24002a58:	681b      	ldr	r3, [r3, #0]
24002a5a:	4a76      	ldr	r2, [pc, #472]	; (24002c34 <HAL_DMA_Abort+0x214>)
24002a5c:	4293      	cmp	r3, r2
24002a5e:	d04a      	beq.n	24002af6 <HAL_DMA_Abort+0xd6>
24002a60:	687b      	ldr	r3, [r7, #4]
24002a62:	681b      	ldr	r3, [r3, #0]
24002a64:	4a74      	ldr	r2, [pc, #464]	; (24002c38 <HAL_DMA_Abort+0x218>)
24002a66:	4293      	cmp	r3, r2
24002a68:	d045      	beq.n	24002af6 <HAL_DMA_Abort+0xd6>
24002a6a:	687b      	ldr	r3, [r7, #4]
24002a6c:	681b      	ldr	r3, [r3, #0]
24002a6e:	4a73      	ldr	r2, [pc, #460]	; (24002c3c <HAL_DMA_Abort+0x21c>)
24002a70:	4293      	cmp	r3, r2
24002a72:	d040      	beq.n	24002af6 <HAL_DMA_Abort+0xd6>
24002a74:	687b      	ldr	r3, [r7, #4]
24002a76:	681b      	ldr	r3, [r3, #0]
24002a78:	4a71      	ldr	r2, [pc, #452]	; (24002c40 <HAL_DMA_Abort+0x220>)
24002a7a:	4293      	cmp	r3, r2
24002a7c:	d03b      	beq.n	24002af6 <HAL_DMA_Abort+0xd6>
24002a7e:	687b      	ldr	r3, [r7, #4]
24002a80:	681b      	ldr	r3, [r3, #0]
24002a82:	4a70      	ldr	r2, [pc, #448]	; (24002c44 <HAL_DMA_Abort+0x224>)
24002a84:	4293      	cmp	r3, r2
24002a86:	d036      	beq.n	24002af6 <HAL_DMA_Abort+0xd6>
24002a88:	687b      	ldr	r3, [r7, #4]
24002a8a:	681b      	ldr	r3, [r3, #0]
24002a8c:	4a6e      	ldr	r2, [pc, #440]	; (24002c48 <HAL_DMA_Abort+0x228>)
24002a8e:	4293      	cmp	r3, r2
24002a90:	d031      	beq.n	24002af6 <HAL_DMA_Abort+0xd6>
24002a92:	687b      	ldr	r3, [r7, #4]
24002a94:	681b      	ldr	r3, [r3, #0]
24002a96:	4a6d      	ldr	r2, [pc, #436]	; (24002c4c <HAL_DMA_Abort+0x22c>)
24002a98:	4293      	cmp	r3, r2
24002a9a:	d02c      	beq.n	24002af6 <HAL_DMA_Abort+0xd6>
24002a9c:	687b      	ldr	r3, [r7, #4]
24002a9e:	681b      	ldr	r3, [r3, #0]
24002aa0:	4a6b      	ldr	r2, [pc, #428]	; (24002c50 <HAL_DMA_Abort+0x230>)
24002aa2:	4293      	cmp	r3, r2
24002aa4:	d027      	beq.n	24002af6 <HAL_DMA_Abort+0xd6>
24002aa6:	687b      	ldr	r3, [r7, #4]
24002aa8:	681b      	ldr	r3, [r3, #0]
24002aaa:	4a6a      	ldr	r2, [pc, #424]	; (24002c54 <HAL_DMA_Abort+0x234>)
24002aac:	4293      	cmp	r3, r2
24002aae:	d022      	beq.n	24002af6 <HAL_DMA_Abort+0xd6>
24002ab0:	687b      	ldr	r3, [r7, #4]
24002ab2:	681b      	ldr	r3, [r3, #0]
24002ab4:	4a68      	ldr	r2, [pc, #416]	; (24002c58 <HAL_DMA_Abort+0x238>)
24002ab6:	4293      	cmp	r3, r2
24002ab8:	d01d      	beq.n	24002af6 <HAL_DMA_Abort+0xd6>
24002aba:	687b      	ldr	r3, [r7, #4]
24002abc:	681b      	ldr	r3, [r3, #0]
24002abe:	4a67      	ldr	r2, [pc, #412]	; (24002c5c <HAL_DMA_Abort+0x23c>)
24002ac0:	4293      	cmp	r3, r2
24002ac2:	d018      	beq.n	24002af6 <HAL_DMA_Abort+0xd6>
24002ac4:	687b      	ldr	r3, [r7, #4]
24002ac6:	681b      	ldr	r3, [r3, #0]
24002ac8:	4a65      	ldr	r2, [pc, #404]	; (24002c60 <HAL_DMA_Abort+0x240>)
24002aca:	4293      	cmp	r3, r2
24002acc:	d013      	beq.n	24002af6 <HAL_DMA_Abort+0xd6>
24002ace:	687b      	ldr	r3, [r7, #4]
24002ad0:	681b      	ldr	r3, [r3, #0]
24002ad2:	4a64      	ldr	r2, [pc, #400]	; (24002c64 <HAL_DMA_Abort+0x244>)
24002ad4:	4293      	cmp	r3, r2
24002ad6:	d00e      	beq.n	24002af6 <HAL_DMA_Abort+0xd6>
24002ad8:	687b      	ldr	r3, [r7, #4]
24002ada:	681b      	ldr	r3, [r3, #0]
24002adc:	4a62      	ldr	r2, [pc, #392]	; (24002c68 <HAL_DMA_Abort+0x248>)
24002ade:	4293      	cmp	r3, r2
24002ae0:	d009      	beq.n	24002af6 <HAL_DMA_Abort+0xd6>
24002ae2:	687b      	ldr	r3, [r7, #4]
24002ae4:	681b      	ldr	r3, [r3, #0]
24002ae6:	4a61      	ldr	r2, [pc, #388]	; (24002c6c <HAL_DMA_Abort+0x24c>)
24002ae8:	4293      	cmp	r3, r2
24002aea:	d004      	beq.n	24002af6 <HAL_DMA_Abort+0xd6>
24002aec:	687b      	ldr	r3, [r7, #4]
24002aee:	681b      	ldr	r3, [r3, #0]
24002af0:	4a5f      	ldr	r2, [pc, #380]	; (24002c70 <HAL_DMA_Abort+0x250>)
24002af2:	4293      	cmp	r3, r2
24002af4:	d101      	bne.n	24002afa <HAL_DMA_Abort+0xda>
24002af6:	2301      	movs	r3, #1
24002af8:	e000      	b.n	24002afc <HAL_DMA_Abort+0xdc>
24002afa:	2300      	movs	r3, #0
24002afc:	2b00      	cmp	r3, #0
24002afe:	d013      	beq.n	24002b28 <HAL_DMA_Abort+0x108>
    {
       /* Disable DMA All Interrupts  */
      ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME | DMA_IT_HT);
24002b00:	687b      	ldr	r3, [r7, #4]
24002b02:	681b      	ldr	r3, [r3, #0]
24002b04:	681a      	ldr	r2, [r3, #0]
24002b06:	687b      	ldr	r3, [r7, #4]
24002b08:	681b      	ldr	r3, [r3, #0]
24002b0a:	f022 021e 	bic.w	r2, r2, #30
24002b0e:	601a      	str	r2, [r3, #0]
      ((DMA_Stream_TypeDef   *)hdma->Instance)->FCR &= ~(DMA_IT_FE);
24002b10:	687b      	ldr	r3, [r7, #4]
24002b12:	681b      	ldr	r3, [r3, #0]
24002b14:	695a      	ldr	r2, [r3, #20]
24002b16:	687b      	ldr	r3, [r7, #4]
24002b18:	681b      	ldr	r3, [r3, #0]
24002b1a:	f022 0280 	bic.w	r2, r2, #128	; 0x80
24002b1e:	615a      	str	r2, [r3, #20]

      enableRegister = (__IO uint32_t *)(&(((DMA_Stream_TypeDef   *)hdma->Instance)->CR));
24002b20:	687b      	ldr	r3, [r7, #4]
24002b22:	681b      	ldr	r3, [r3, #0]
24002b24:	617b      	str	r3, [r7, #20]
24002b26:	e00a      	b.n	24002b3e <HAL_DMA_Abort+0x11e>
    }
    else /* BDMA channel */
    {
      /* Disable DMA All Interrupts */
      ((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR  &= ~(BDMA_CCR_TCIE | BDMA_CCR_HTIE | BDMA_CCR_TEIE);
24002b28:	687b      	ldr	r3, [r7, #4]
24002b2a:	681b      	ldr	r3, [r3, #0]
24002b2c:	681a      	ldr	r2, [r3, #0]
24002b2e:	687b      	ldr	r3, [r7, #4]
24002b30:	681b      	ldr	r3, [r3, #0]
24002b32:	f022 020e 	bic.w	r2, r2, #14
24002b36:	601a      	str	r2, [r3, #0]

      enableRegister = (__IO uint32_t *)(&(((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR));
24002b38:	687b      	ldr	r3, [r7, #4]
24002b3a:	681b      	ldr	r3, [r3, #0]
24002b3c:	617b      	str	r3, [r7, #20]
    }

    if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
24002b3e:	687b      	ldr	r3, [r7, #4]
24002b40:	681b      	ldr	r3, [r3, #0]
24002b42:	4a3c      	ldr	r2, [pc, #240]	; (24002c34 <HAL_DMA_Abort+0x214>)
24002b44:	4293      	cmp	r3, r2
24002b46:	d072      	beq.n	24002c2e <HAL_DMA_Abort+0x20e>
24002b48:	687b      	ldr	r3, [r7, #4]
24002b4a:	681b      	ldr	r3, [r3, #0]
24002b4c:	4a3a      	ldr	r2, [pc, #232]	; (24002c38 <HAL_DMA_Abort+0x218>)
24002b4e:	4293      	cmp	r3, r2
24002b50:	d06d      	beq.n	24002c2e <HAL_DMA_Abort+0x20e>
24002b52:	687b      	ldr	r3, [r7, #4]
24002b54:	681b      	ldr	r3, [r3, #0]
24002b56:	4a39      	ldr	r2, [pc, #228]	; (24002c3c <HAL_DMA_Abort+0x21c>)
24002b58:	4293      	cmp	r3, r2
24002b5a:	d068      	beq.n	24002c2e <HAL_DMA_Abort+0x20e>
24002b5c:	687b      	ldr	r3, [r7, #4]
24002b5e:	681b      	ldr	r3, [r3, #0]
24002b60:	4a37      	ldr	r2, [pc, #220]	; (24002c40 <HAL_DMA_Abort+0x220>)
24002b62:	4293      	cmp	r3, r2
24002b64:	d063      	beq.n	24002c2e <HAL_DMA_Abort+0x20e>
24002b66:	687b      	ldr	r3, [r7, #4]
24002b68:	681b      	ldr	r3, [r3, #0]
24002b6a:	4a36      	ldr	r2, [pc, #216]	; (24002c44 <HAL_DMA_Abort+0x224>)
24002b6c:	4293      	cmp	r3, r2
24002b6e:	d05e      	beq.n	24002c2e <HAL_DMA_Abort+0x20e>
24002b70:	687b      	ldr	r3, [r7, #4]
24002b72:	681b      	ldr	r3, [r3, #0]
24002b74:	4a34      	ldr	r2, [pc, #208]	; (24002c48 <HAL_DMA_Abort+0x228>)
24002b76:	4293      	cmp	r3, r2
24002b78:	d059      	beq.n	24002c2e <HAL_DMA_Abort+0x20e>
24002b7a:	687b      	ldr	r3, [r7, #4]
24002b7c:	681b      	ldr	r3, [r3, #0]
24002b7e:	4a33      	ldr	r2, [pc, #204]	; (24002c4c <HAL_DMA_Abort+0x22c>)
24002b80:	4293      	cmp	r3, r2
24002b82:	d054      	beq.n	24002c2e <HAL_DMA_Abort+0x20e>
24002b84:	687b      	ldr	r3, [r7, #4]
24002b86:	681b      	ldr	r3, [r3, #0]
24002b88:	4a31      	ldr	r2, [pc, #196]	; (24002c50 <HAL_DMA_Abort+0x230>)
24002b8a:	4293      	cmp	r3, r2
24002b8c:	d04f      	beq.n	24002c2e <HAL_DMA_Abort+0x20e>
24002b8e:	687b      	ldr	r3, [r7, #4]
24002b90:	681b      	ldr	r3, [r3, #0]
24002b92:	4a30      	ldr	r2, [pc, #192]	; (24002c54 <HAL_DMA_Abort+0x234>)
24002b94:	4293      	cmp	r3, r2
24002b96:	d04a      	beq.n	24002c2e <HAL_DMA_Abort+0x20e>
24002b98:	687b      	ldr	r3, [r7, #4]
24002b9a:	681b      	ldr	r3, [r3, #0]
24002b9c:	4a2e      	ldr	r2, [pc, #184]	; (24002c58 <HAL_DMA_Abort+0x238>)
24002b9e:	4293      	cmp	r3, r2
24002ba0:	d045      	beq.n	24002c2e <HAL_DMA_Abort+0x20e>
24002ba2:	687b      	ldr	r3, [r7, #4]
24002ba4:	681b      	ldr	r3, [r3, #0]
24002ba6:	4a2d      	ldr	r2, [pc, #180]	; (24002c5c <HAL_DMA_Abort+0x23c>)
24002ba8:	4293      	cmp	r3, r2
24002baa:	d040      	beq.n	24002c2e <HAL_DMA_Abort+0x20e>
24002bac:	687b      	ldr	r3, [r7, #4]
24002bae:	681b      	ldr	r3, [r3, #0]
24002bb0:	4a2b      	ldr	r2, [pc, #172]	; (24002c60 <HAL_DMA_Abort+0x240>)
24002bb2:	4293      	cmp	r3, r2
24002bb4:	d03b      	beq.n	24002c2e <HAL_DMA_Abort+0x20e>
24002bb6:	687b      	ldr	r3, [r7, #4]
24002bb8:	681b      	ldr	r3, [r3, #0]
24002bba:	4a2a      	ldr	r2, [pc, #168]	; (24002c64 <HAL_DMA_Abort+0x244>)
24002bbc:	4293      	cmp	r3, r2
24002bbe:	d036      	beq.n	24002c2e <HAL_DMA_Abort+0x20e>
24002bc0:	687b      	ldr	r3, [r7, #4]
24002bc2:	681b      	ldr	r3, [r3, #0]
24002bc4:	4a28      	ldr	r2, [pc, #160]	; (24002c68 <HAL_DMA_Abort+0x248>)
24002bc6:	4293      	cmp	r3, r2
24002bc8:	d031      	beq.n	24002c2e <HAL_DMA_Abort+0x20e>
24002bca:	687b      	ldr	r3, [r7, #4]
24002bcc:	681b      	ldr	r3, [r3, #0]
24002bce:	4a27      	ldr	r2, [pc, #156]	; (24002c6c <HAL_DMA_Abort+0x24c>)
24002bd0:	4293      	cmp	r3, r2
24002bd2:	d02c      	beq.n	24002c2e <HAL_DMA_Abort+0x20e>
24002bd4:	687b      	ldr	r3, [r7, #4]
24002bd6:	681b      	ldr	r3, [r3, #0]
24002bd8:	4a25      	ldr	r2, [pc, #148]	; (24002c70 <HAL_DMA_Abort+0x250>)
24002bda:	4293      	cmp	r3, r2
24002bdc:	d027      	beq.n	24002c2e <HAL_DMA_Abort+0x20e>
24002bde:	687b      	ldr	r3, [r7, #4]
24002be0:	681b      	ldr	r3, [r3, #0]
24002be2:	4a24      	ldr	r2, [pc, #144]	; (24002c74 <HAL_DMA_Abort+0x254>)
24002be4:	4293      	cmp	r3, r2
24002be6:	d022      	beq.n	24002c2e <HAL_DMA_Abort+0x20e>
24002be8:	687b      	ldr	r3, [r7, #4]
24002bea:	681b      	ldr	r3, [r3, #0]
24002bec:	4a22      	ldr	r2, [pc, #136]	; (24002c78 <HAL_DMA_Abort+0x258>)
24002bee:	4293      	cmp	r3, r2
24002bf0:	d01d      	beq.n	24002c2e <HAL_DMA_Abort+0x20e>
24002bf2:	687b      	ldr	r3, [r7, #4]
24002bf4:	681b      	ldr	r3, [r3, #0]
24002bf6:	4a21      	ldr	r2, [pc, #132]	; (24002c7c <HAL_DMA_Abort+0x25c>)
24002bf8:	4293      	cmp	r3, r2
24002bfa:	d018      	beq.n	24002c2e <HAL_DMA_Abort+0x20e>
24002bfc:	687b      	ldr	r3, [r7, #4]
24002bfe:	681b      	ldr	r3, [r3, #0]
24002c00:	4a1f      	ldr	r2, [pc, #124]	; (24002c80 <HAL_DMA_Abort+0x260>)
24002c02:	4293      	cmp	r3, r2
24002c04:	d013      	beq.n	24002c2e <HAL_DMA_Abort+0x20e>
24002c06:	687b      	ldr	r3, [r7, #4]
24002c08:	681b      	ldr	r3, [r3, #0]
24002c0a:	4a1e      	ldr	r2, [pc, #120]	; (24002c84 <HAL_DMA_Abort+0x264>)
24002c0c:	4293      	cmp	r3, r2
24002c0e:	d00e      	beq.n	24002c2e <HAL_DMA_Abort+0x20e>
24002c10:	687b      	ldr	r3, [r7, #4]
24002c12:	681b      	ldr	r3, [r3, #0]
24002c14:	4a1c      	ldr	r2, [pc, #112]	; (24002c88 <HAL_DMA_Abort+0x268>)
24002c16:	4293      	cmp	r3, r2
24002c18:	d009      	beq.n	24002c2e <HAL_DMA_Abort+0x20e>
24002c1a:	687b      	ldr	r3, [r7, #4]
24002c1c:	681b      	ldr	r3, [r3, #0]
24002c1e:	4a1b      	ldr	r2, [pc, #108]	; (24002c8c <HAL_DMA_Abort+0x26c>)
24002c20:	4293      	cmp	r3, r2
24002c22:	d004      	beq.n	24002c2e <HAL_DMA_Abort+0x20e>
24002c24:	687b      	ldr	r3, [r7, #4]
24002c26:	681b      	ldr	r3, [r3, #0]
24002c28:	4a19      	ldr	r2, [pc, #100]	; (24002c90 <HAL_DMA_Abort+0x270>)
24002c2a:	4293      	cmp	r3, r2
24002c2c:	d132      	bne.n	24002c94 <HAL_DMA_Abort+0x274>
24002c2e:	2301      	movs	r3, #1
24002c30:	e031      	b.n	24002c96 <HAL_DMA_Abort+0x276>
24002c32:	bf00      	nop
24002c34:	40020010 	.word	0x40020010
24002c38:	40020028 	.word	0x40020028
24002c3c:	40020040 	.word	0x40020040
24002c40:	40020058 	.word	0x40020058
24002c44:	40020070 	.word	0x40020070
24002c48:	40020088 	.word	0x40020088
24002c4c:	400200a0 	.word	0x400200a0
24002c50:	400200b8 	.word	0x400200b8
24002c54:	40020410 	.word	0x40020410
24002c58:	40020428 	.word	0x40020428
24002c5c:	40020440 	.word	0x40020440
24002c60:	40020458 	.word	0x40020458
24002c64:	40020470 	.word	0x40020470
24002c68:	40020488 	.word	0x40020488
24002c6c:	400204a0 	.word	0x400204a0
24002c70:	400204b8 	.word	0x400204b8
24002c74:	58025408 	.word	0x58025408
24002c78:	5802541c 	.word	0x5802541c
24002c7c:	58025430 	.word	0x58025430
24002c80:	58025444 	.word	0x58025444
24002c84:	58025458 	.word	0x58025458
24002c88:	5802546c 	.word	0x5802546c
24002c8c:	58025480 	.word	0x58025480
24002c90:	58025494 	.word	0x58025494
24002c94:	2300      	movs	r3, #0
24002c96:	2b00      	cmp	r3, #0
24002c98:	d007      	beq.n	24002caa <HAL_DMA_Abort+0x28a>
    {
      /* disable the DMAMUX sync overrun IT */
      hdma->DMAmuxChannel->CCR &= ~DMAMUX_CxCR_SOIE;
24002c9a:	687b      	ldr	r3, [r7, #4]
24002c9c:	6e1b      	ldr	r3, [r3, #96]	; 0x60
24002c9e:	681a      	ldr	r2, [r3, #0]
24002ca0:	687b      	ldr	r3, [r7, #4]
24002ca2:	6e1b      	ldr	r3, [r3, #96]	; 0x60
24002ca4:	f422 7280 	bic.w	r2, r2, #256	; 0x100
24002ca8:	601a      	str	r2, [r3, #0]
    }

    /* Disable the stream */
    __HAL_DMA_DISABLE(hdma);
24002caa:	687b      	ldr	r3, [r7, #4]
24002cac:	681b      	ldr	r3, [r3, #0]
24002cae:	4a6d      	ldr	r2, [pc, #436]	; (24002e64 <HAL_DMA_Abort+0x444>)
24002cb0:	4293      	cmp	r3, r2
24002cb2:	d04a      	beq.n	24002d4a <HAL_DMA_Abort+0x32a>
24002cb4:	687b      	ldr	r3, [r7, #4]
24002cb6:	681b      	ldr	r3, [r3, #0]
24002cb8:	4a6b      	ldr	r2, [pc, #428]	; (24002e68 <HAL_DMA_Abort+0x448>)
24002cba:	4293      	cmp	r3, r2
24002cbc:	d045      	beq.n	24002d4a <HAL_DMA_Abort+0x32a>
24002cbe:	687b      	ldr	r3, [r7, #4]
24002cc0:	681b      	ldr	r3, [r3, #0]
24002cc2:	4a6a      	ldr	r2, [pc, #424]	; (24002e6c <HAL_DMA_Abort+0x44c>)
24002cc4:	4293      	cmp	r3, r2
24002cc6:	d040      	beq.n	24002d4a <HAL_DMA_Abort+0x32a>
24002cc8:	687b      	ldr	r3, [r7, #4]
24002cca:	681b      	ldr	r3, [r3, #0]
24002ccc:	4a68      	ldr	r2, [pc, #416]	; (24002e70 <HAL_DMA_Abort+0x450>)
24002cce:	4293      	cmp	r3, r2
24002cd0:	d03b      	beq.n	24002d4a <HAL_DMA_Abort+0x32a>
24002cd2:	687b      	ldr	r3, [r7, #4]
24002cd4:	681b      	ldr	r3, [r3, #0]
24002cd6:	4a67      	ldr	r2, [pc, #412]	; (24002e74 <HAL_DMA_Abort+0x454>)
24002cd8:	4293      	cmp	r3, r2
24002cda:	d036      	beq.n	24002d4a <HAL_DMA_Abort+0x32a>
24002cdc:	687b      	ldr	r3, [r7, #4]
24002cde:	681b      	ldr	r3, [r3, #0]
24002ce0:	4a65      	ldr	r2, [pc, #404]	; (24002e78 <HAL_DMA_Abort+0x458>)
24002ce2:	4293      	cmp	r3, r2
24002ce4:	d031      	beq.n	24002d4a <HAL_DMA_Abort+0x32a>
24002ce6:	687b      	ldr	r3, [r7, #4]
24002ce8:	681b      	ldr	r3, [r3, #0]
24002cea:	4a64      	ldr	r2, [pc, #400]	; (24002e7c <HAL_DMA_Abort+0x45c>)
24002cec:	4293      	cmp	r3, r2
24002cee:	d02c      	beq.n	24002d4a <HAL_DMA_Abort+0x32a>
24002cf0:	687b      	ldr	r3, [r7, #4]
24002cf2:	681b      	ldr	r3, [r3, #0]
24002cf4:	4a62      	ldr	r2, [pc, #392]	; (24002e80 <HAL_DMA_Abort+0x460>)
24002cf6:	4293      	cmp	r3, r2
24002cf8:	d027      	beq.n	24002d4a <HAL_DMA_Abort+0x32a>
24002cfa:	687b      	ldr	r3, [r7, #4]
24002cfc:	681b      	ldr	r3, [r3, #0]
24002cfe:	4a61      	ldr	r2, [pc, #388]	; (24002e84 <HAL_DMA_Abort+0x464>)
24002d00:	4293      	cmp	r3, r2
24002d02:	d022      	beq.n	24002d4a <HAL_DMA_Abort+0x32a>
24002d04:	687b      	ldr	r3, [r7, #4]
24002d06:	681b      	ldr	r3, [r3, #0]
24002d08:	4a5f      	ldr	r2, [pc, #380]	; (24002e88 <HAL_DMA_Abort+0x468>)
24002d0a:	4293      	cmp	r3, r2
24002d0c:	d01d      	beq.n	24002d4a <HAL_DMA_Abort+0x32a>
24002d0e:	687b      	ldr	r3, [r7, #4]
24002d10:	681b      	ldr	r3, [r3, #0]
24002d12:	4a5e      	ldr	r2, [pc, #376]	; (24002e8c <HAL_DMA_Abort+0x46c>)
24002d14:	4293      	cmp	r3, r2
24002d16:	d018      	beq.n	24002d4a <HAL_DMA_Abort+0x32a>
24002d18:	687b      	ldr	r3, [r7, #4]
24002d1a:	681b      	ldr	r3, [r3, #0]
24002d1c:	4a5c      	ldr	r2, [pc, #368]	; (24002e90 <HAL_DMA_Abort+0x470>)
24002d1e:	4293      	cmp	r3, r2
24002d20:	d013      	beq.n	24002d4a <HAL_DMA_Abort+0x32a>
24002d22:	687b      	ldr	r3, [r7, #4]
24002d24:	681b      	ldr	r3, [r3, #0]
24002d26:	4a5b      	ldr	r2, [pc, #364]	; (24002e94 <HAL_DMA_Abort+0x474>)
24002d28:	4293      	cmp	r3, r2
24002d2a:	d00e      	beq.n	24002d4a <HAL_DMA_Abort+0x32a>
24002d2c:	687b      	ldr	r3, [r7, #4]
24002d2e:	681b      	ldr	r3, [r3, #0]
24002d30:	4a59      	ldr	r2, [pc, #356]	; (24002e98 <HAL_DMA_Abort+0x478>)
24002d32:	4293      	cmp	r3, r2
24002d34:	d009      	beq.n	24002d4a <HAL_DMA_Abort+0x32a>
24002d36:	687b      	ldr	r3, [r7, #4]
24002d38:	681b      	ldr	r3, [r3, #0]
24002d3a:	4a58      	ldr	r2, [pc, #352]	; (24002e9c <HAL_DMA_Abort+0x47c>)
24002d3c:	4293      	cmp	r3, r2
24002d3e:	d004      	beq.n	24002d4a <HAL_DMA_Abort+0x32a>
24002d40:	687b      	ldr	r3, [r7, #4]
24002d42:	681b      	ldr	r3, [r3, #0]
24002d44:	4a56      	ldr	r2, [pc, #344]	; (24002ea0 <HAL_DMA_Abort+0x480>)
24002d46:	4293      	cmp	r3, r2
24002d48:	d108      	bne.n	24002d5c <HAL_DMA_Abort+0x33c>
24002d4a:	687b      	ldr	r3, [r7, #4]
24002d4c:	681b      	ldr	r3, [r3, #0]
24002d4e:	681a      	ldr	r2, [r3, #0]
24002d50:	687b      	ldr	r3, [r7, #4]
24002d52:	681b      	ldr	r3, [r3, #0]
24002d54:	f022 0201 	bic.w	r2, r2, #1
24002d58:	601a      	str	r2, [r3, #0]
24002d5a:	e007      	b.n	24002d6c <HAL_DMA_Abort+0x34c>
24002d5c:	687b      	ldr	r3, [r7, #4]
24002d5e:	681b      	ldr	r3, [r3, #0]
24002d60:	681a      	ldr	r2, [r3, #0]
24002d62:	687b      	ldr	r3, [r7, #4]
24002d64:	681b      	ldr	r3, [r3, #0]
24002d66:	f022 0201 	bic.w	r2, r2, #1
24002d6a:	601a      	str	r2, [r3, #0]

    /* Check if the DMA Stream is effectively disabled */
    while(((*enableRegister) & DMA_SxCR_EN) != 0U)
24002d6c:	e013      	b.n	24002d96 <HAL_DMA_Abort+0x376>
    {
      /* Check for the Timeout */
      if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA_ABORT)
24002d6e:	f7fd fd6f 	bl	24000850 <HAL_GetTick>
24002d72:	4602      	mov	r2, r0
24002d74:	693b      	ldr	r3, [r7, #16]
24002d76:	1ad3      	subs	r3, r2, r3
24002d78:	2b05      	cmp	r3, #5
24002d7a:	d90c      	bls.n	24002d96 <HAL_DMA_Abort+0x376>
      {
        /* Update error code */
        hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
24002d7c:	687b      	ldr	r3, [r7, #4]
24002d7e:	2220      	movs	r2, #32
24002d80:	655a      	str	r2, [r3, #84]	; 0x54

        /* Process Unlocked */
        __HAL_UNLOCK(hdma);
24002d82:	687b      	ldr	r3, [r7, #4]
24002d84:	2200      	movs	r2, #0
24002d86:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

        /* Change the DMA state */
        hdma->State = HAL_DMA_STATE_ERROR;
24002d8a:	687b      	ldr	r3, [r7, #4]
24002d8c:	2203      	movs	r2, #3
24002d8e:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

        return HAL_ERROR;
24002d92:	2301      	movs	r3, #1
24002d94:	e12d      	b.n	24002ff2 <HAL_DMA_Abort+0x5d2>
    while(((*enableRegister) & DMA_SxCR_EN) != 0U)
24002d96:	697b      	ldr	r3, [r7, #20]
24002d98:	681b      	ldr	r3, [r3, #0]
24002d9a:	f003 0301 	and.w	r3, r3, #1
24002d9e:	2b00      	cmp	r3, #0
24002da0:	d1e5      	bne.n	24002d6e <HAL_DMA_Abort+0x34e>
      }
    }

    /* Clear all interrupt flags at correct offset within the register */
    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
24002da2:	687b      	ldr	r3, [r7, #4]
24002da4:	681b      	ldr	r3, [r3, #0]
24002da6:	4a2f      	ldr	r2, [pc, #188]	; (24002e64 <HAL_DMA_Abort+0x444>)
24002da8:	4293      	cmp	r3, r2
24002daa:	d04a      	beq.n	24002e42 <HAL_DMA_Abort+0x422>
24002dac:	687b      	ldr	r3, [r7, #4]
24002dae:	681b      	ldr	r3, [r3, #0]
24002db0:	4a2d      	ldr	r2, [pc, #180]	; (24002e68 <HAL_DMA_Abort+0x448>)
24002db2:	4293      	cmp	r3, r2
24002db4:	d045      	beq.n	24002e42 <HAL_DMA_Abort+0x422>
24002db6:	687b      	ldr	r3, [r7, #4]
24002db8:	681b      	ldr	r3, [r3, #0]
24002dba:	4a2c      	ldr	r2, [pc, #176]	; (24002e6c <HAL_DMA_Abort+0x44c>)
24002dbc:	4293      	cmp	r3, r2
24002dbe:	d040      	beq.n	24002e42 <HAL_DMA_Abort+0x422>
24002dc0:	687b      	ldr	r3, [r7, #4]
24002dc2:	681b      	ldr	r3, [r3, #0]
24002dc4:	4a2a      	ldr	r2, [pc, #168]	; (24002e70 <HAL_DMA_Abort+0x450>)
24002dc6:	4293      	cmp	r3, r2
24002dc8:	d03b      	beq.n	24002e42 <HAL_DMA_Abort+0x422>
24002dca:	687b      	ldr	r3, [r7, #4]
24002dcc:	681b      	ldr	r3, [r3, #0]
24002dce:	4a29      	ldr	r2, [pc, #164]	; (24002e74 <HAL_DMA_Abort+0x454>)
24002dd0:	4293      	cmp	r3, r2
24002dd2:	d036      	beq.n	24002e42 <HAL_DMA_Abort+0x422>
24002dd4:	687b      	ldr	r3, [r7, #4]
24002dd6:	681b      	ldr	r3, [r3, #0]
24002dd8:	4a27      	ldr	r2, [pc, #156]	; (24002e78 <HAL_DMA_Abort+0x458>)
24002dda:	4293      	cmp	r3, r2
24002ddc:	d031      	beq.n	24002e42 <HAL_DMA_Abort+0x422>
24002dde:	687b      	ldr	r3, [r7, #4]
24002de0:	681b      	ldr	r3, [r3, #0]
24002de2:	4a26      	ldr	r2, [pc, #152]	; (24002e7c <HAL_DMA_Abort+0x45c>)
24002de4:	4293      	cmp	r3, r2
24002de6:	d02c      	beq.n	24002e42 <HAL_DMA_Abort+0x422>
24002de8:	687b      	ldr	r3, [r7, #4]
24002dea:	681b      	ldr	r3, [r3, #0]
24002dec:	4a24      	ldr	r2, [pc, #144]	; (24002e80 <HAL_DMA_Abort+0x460>)
24002dee:	4293      	cmp	r3, r2
24002df0:	d027      	beq.n	24002e42 <HAL_DMA_Abort+0x422>
24002df2:	687b      	ldr	r3, [r7, #4]
24002df4:	681b      	ldr	r3, [r3, #0]
24002df6:	4a23      	ldr	r2, [pc, #140]	; (24002e84 <HAL_DMA_Abort+0x464>)
24002df8:	4293      	cmp	r3, r2
24002dfa:	d022      	beq.n	24002e42 <HAL_DMA_Abort+0x422>
24002dfc:	687b      	ldr	r3, [r7, #4]
24002dfe:	681b      	ldr	r3, [r3, #0]
24002e00:	4a21      	ldr	r2, [pc, #132]	; (24002e88 <HAL_DMA_Abort+0x468>)
24002e02:	4293      	cmp	r3, r2
24002e04:	d01d      	beq.n	24002e42 <HAL_DMA_Abort+0x422>
24002e06:	687b      	ldr	r3, [r7, #4]
24002e08:	681b      	ldr	r3, [r3, #0]
24002e0a:	4a20      	ldr	r2, [pc, #128]	; (24002e8c <HAL_DMA_Abort+0x46c>)
24002e0c:	4293      	cmp	r3, r2
24002e0e:	d018      	beq.n	24002e42 <HAL_DMA_Abort+0x422>
24002e10:	687b      	ldr	r3, [r7, #4]
24002e12:	681b      	ldr	r3, [r3, #0]
24002e14:	4a1e      	ldr	r2, [pc, #120]	; (24002e90 <HAL_DMA_Abort+0x470>)
24002e16:	4293      	cmp	r3, r2
24002e18:	d013      	beq.n	24002e42 <HAL_DMA_Abort+0x422>
24002e1a:	687b      	ldr	r3, [r7, #4]
24002e1c:	681b      	ldr	r3, [r3, #0]
24002e1e:	4a1d      	ldr	r2, [pc, #116]	; (24002e94 <HAL_DMA_Abort+0x474>)
24002e20:	4293      	cmp	r3, r2
24002e22:	d00e      	beq.n	24002e42 <HAL_DMA_Abort+0x422>
24002e24:	687b      	ldr	r3, [r7, #4]
24002e26:	681b      	ldr	r3, [r3, #0]
24002e28:	4a1b      	ldr	r2, [pc, #108]	; (24002e98 <HAL_DMA_Abort+0x478>)
24002e2a:	4293      	cmp	r3, r2
24002e2c:	d009      	beq.n	24002e42 <HAL_DMA_Abort+0x422>
24002e2e:	687b      	ldr	r3, [r7, #4]
24002e30:	681b      	ldr	r3, [r3, #0]
24002e32:	4a1a      	ldr	r2, [pc, #104]	; (24002e9c <HAL_DMA_Abort+0x47c>)
24002e34:	4293      	cmp	r3, r2
24002e36:	d004      	beq.n	24002e42 <HAL_DMA_Abort+0x422>
24002e38:	687b      	ldr	r3, [r7, #4]
24002e3a:	681b      	ldr	r3, [r3, #0]
24002e3c:	4a18      	ldr	r2, [pc, #96]	; (24002ea0 <HAL_DMA_Abort+0x480>)
24002e3e:	4293      	cmp	r3, r2
24002e40:	d101      	bne.n	24002e46 <HAL_DMA_Abort+0x426>
24002e42:	2301      	movs	r3, #1
24002e44:	e000      	b.n	24002e48 <HAL_DMA_Abort+0x428>
24002e46:	2300      	movs	r3, #0
24002e48:	2b00      	cmp	r3, #0
24002e4a:	d02b      	beq.n	24002ea4 <HAL_DMA_Abort+0x484>
    {
      regs_dma = (DMA_Base_Registers *)hdma->StreamBaseAddress;
24002e4c:	687b      	ldr	r3, [r7, #4]
24002e4e:	6d9b      	ldr	r3, [r3, #88]	; 0x58
24002e50:	60bb      	str	r3, [r7, #8]
      regs_dma->IFCR = 0x3FUL << (hdma->StreamIndex & 0x1FU);
24002e52:	687b      	ldr	r3, [r7, #4]
24002e54:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24002e56:	f003 031f 	and.w	r3, r3, #31
24002e5a:	223f      	movs	r2, #63	; 0x3f
24002e5c:	409a      	lsls	r2, r3
24002e5e:	68bb      	ldr	r3, [r7, #8]
24002e60:	609a      	str	r2, [r3, #8]
24002e62:	e02a      	b.n	24002eba <HAL_DMA_Abort+0x49a>
24002e64:	40020010 	.word	0x40020010
24002e68:	40020028 	.word	0x40020028
24002e6c:	40020040 	.word	0x40020040
24002e70:	40020058 	.word	0x40020058
24002e74:	40020070 	.word	0x40020070
24002e78:	40020088 	.word	0x40020088
24002e7c:	400200a0 	.word	0x400200a0
24002e80:	400200b8 	.word	0x400200b8
24002e84:	40020410 	.word	0x40020410
24002e88:	40020428 	.word	0x40020428
24002e8c:	40020440 	.word	0x40020440
24002e90:	40020458 	.word	0x40020458
24002e94:	40020470 	.word	0x40020470
24002e98:	40020488 	.word	0x40020488
24002e9c:	400204a0 	.word	0x400204a0
24002ea0:	400204b8 	.word	0x400204b8
    }
    else /* BDMA channel */
    {
      regs_bdma = (BDMA_Base_Registers *)hdma->StreamBaseAddress;
24002ea4:	687b      	ldr	r3, [r7, #4]
24002ea6:	6d9b      	ldr	r3, [r3, #88]	; 0x58
24002ea8:	60fb      	str	r3, [r7, #12]
      regs_bdma->IFCR = ((BDMA_IFCR_CGIF0) << (hdma->StreamIndex & 0x1FU));
24002eaa:	687b      	ldr	r3, [r7, #4]
24002eac:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24002eae:	f003 031f 	and.w	r3, r3, #31
24002eb2:	2201      	movs	r2, #1
24002eb4:	409a      	lsls	r2, r3
24002eb6:	68fb      	ldr	r3, [r7, #12]
24002eb8:	605a      	str	r2, [r3, #4]
    }

    if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
24002eba:	687b      	ldr	r3, [r7, #4]
24002ebc:	681b      	ldr	r3, [r3, #0]
24002ebe:	4a4f      	ldr	r2, [pc, #316]	; (24002ffc <HAL_DMA_Abort+0x5dc>)
24002ec0:	4293      	cmp	r3, r2
24002ec2:	d072      	beq.n	24002faa <HAL_DMA_Abort+0x58a>
24002ec4:	687b      	ldr	r3, [r7, #4]
24002ec6:	681b      	ldr	r3, [r3, #0]
24002ec8:	4a4d      	ldr	r2, [pc, #308]	; (24003000 <HAL_DMA_Abort+0x5e0>)
24002eca:	4293      	cmp	r3, r2
24002ecc:	d06d      	beq.n	24002faa <HAL_DMA_Abort+0x58a>
24002ece:	687b      	ldr	r3, [r7, #4]
24002ed0:	681b      	ldr	r3, [r3, #0]
24002ed2:	4a4c      	ldr	r2, [pc, #304]	; (24003004 <HAL_DMA_Abort+0x5e4>)
24002ed4:	4293      	cmp	r3, r2
24002ed6:	d068      	beq.n	24002faa <HAL_DMA_Abort+0x58a>
24002ed8:	687b      	ldr	r3, [r7, #4]
24002eda:	681b      	ldr	r3, [r3, #0]
24002edc:	4a4a      	ldr	r2, [pc, #296]	; (24003008 <HAL_DMA_Abort+0x5e8>)
24002ede:	4293      	cmp	r3, r2
24002ee0:	d063      	beq.n	24002faa <HAL_DMA_Abort+0x58a>
24002ee2:	687b      	ldr	r3, [r7, #4]
24002ee4:	681b      	ldr	r3, [r3, #0]
24002ee6:	4a49      	ldr	r2, [pc, #292]	; (2400300c <HAL_DMA_Abort+0x5ec>)
24002ee8:	4293      	cmp	r3, r2
24002eea:	d05e      	beq.n	24002faa <HAL_DMA_Abort+0x58a>
24002eec:	687b      	ldr	r3, [r7, #4]
24002eee:	681b      	ldr	r3, [r3, #0]
24002ef0:	4a47      	ldr	r2, [pc, #284]	; (24003010 <HAL_DMA_Abort+0x5f0>)
24002ef2:	4293      	cmp	r3, r2
24002ef4:	d059      	beq.n	24002faa <HAL_DMA_Abort+0x58a>
24002ef6:	687b      	ldr	r3, [r7, #4]
24002ef8:	681b      	ldr	r3, [r3, #0]
24002efa:	4a46      	ldr	r2, [pc, #280]	; (24003014 <HAL_DMA_Abort+0x5f4>)
24002efc:	4293      	cmp	r3, r2
24002efe:	d054      	beq.n	24002faa <HAL_DMA_Abort+0x58a>
24002f00:	687b      	ldr	r3, [r7, #4]
24002f02:	681b      	ldr	r3, [r3, #0]
24002f04:	4a44      	ldr	r2, [pc, #272]	; (24003018 <HAL_DMA_Abort+0x5f8>)
24002f06:	4293      	cmp	r3, r2
24002f08:	d04f      	beq.n	24002faa <HAL_DMA_Abort+0x58a>
24002f0a:	687b      	ldr	r3, [r7, #4]
24002f0c:	681b      	ldr	r3, [r3, #0]
24002f0e:	4a43      	ldr	r2, [pc, #268]	; (2400301c <HAL_DMA_Abort+0x5fc>)
24002f10:	4293      	cmp	r3, r2
24002f12:	d04a      	beq.n	24002faa <HAL_DMA_Abort+0x58a>
24002f14:	687b      	ldr	r3, [r7, #4]
24002f16:	681b      	ldr	r3, [r3, #0]
24002f18:	4a41      	ldr	r2, [pc, #260]	; (24003020 <HAL_DMA_Abort+0x600>)
24002f1a:	4293      	cmp	r3, r2
24002f1c:	d045      	beq.n	24002faa <HAL_DMA_Abort+0x58a>
24002f1e:	687b      	ldr	r3, [r7, #4]
24002f20:	681b      	ldr	r3, [r3, #0]
24002f22:	4a40      	ldr	r2, [pc, #256]	; (24003024 <HAL_DMA_Abort+0x604>)
24002f24:	4293      	cmp	r3, r2
24002f26:	d040      	beq.n	24002faa <HAL_DMA_Abort+0x58a>
24002f28:	687b      	ldr	r3, [r7, #4]
24002f2a:	681b      	ldr	r3, [r3, #0]
24002f2c:	4a3e      	ldr	r2, [pc, #248]	; (24003028 <HAL_DMA_Abort+0x608>)
24002f2e:	4293      	cmp	r3, r2
24002f30:	d03b      	beq.n	24002faa <HAL_DMA_Abort+0x58a>
24002f32:	687b      	ldr	r3, [r7, #4]
24002f34:	681b      	ldr	r3, [r3, #0]
24002f36:	4a3d      	ldr	r2, [pc, #244]	; (2400302c <HAL_DMA_Abort+0x60c>)
24002f38:	4293      	cmp	r3, r2
24002f3a:	d036      	beq.n	24002faa <HAL_DMA_Abort+0x58a>
24002f3c:	687b      	ldr	r3, [r7, #4]
24002f3e:	681b      	ldr	r3, [r3, #0]
24002f40:	4a3b      	ldr	r2, [pc, #236]	; (24003030 <HAL_DMA_Abort+0x610>)
24002f42:	4293      	cmp	r3, r2
24002f44:	d031      	beq.n	24002faa <HAL_DMA_Abort+0x58a>
24002f46:	687b      	ldr	r3, [r7, #4]
24002f48:	681b      	ldr	r3, [r3, #0]
24002f4a:	4a3a      	ldr	r2, [pc, #232]	; (24003034 <HAL_DMA_Abort+0x614>)
24002f4c:	4293      	cmp	r3, r2
24002f4e:	d02c      	beq.n	24002faa <HAL_DMA_Abort+0x58a>
24002f50:	687b      	ldr	r3, [r7, #4]
24002f52:	681b      	ldr	r3, [r3, #0]
24002f54:	4a38      	ldr	r2, [pc, #224]	; (24003038 <HAL_DMA_Abort+0x618>)
24002f56:	4293      	cmp	r3, r2
24002f58:	d027      	beq.n	24002faa <HAL_DMA_Abort+0x58a>
24002f5a:	687b      	ldr	r3, [r7, #4]
24002f5c:	681b      	ldr	r3, [r3, #0]
24002f5e:	4a37      	ldr	r2, [pc, #220]	; (2400303c <HAL_DMA_Abort+0x61c>)
24002f60:	4293      	cmp	r3, r2
24002f62:	d022      	beq.n	24002faa <HAL_DMA_Abort+0x58a>
24002f64:	687b      	ldr	r3, [r7, #4]
24002f66:	681b      	ldr	r3, [r3, #0]
24002f68:	4a35      	ldr	r2, [pc, #212]	; (24003040 <HAL_DMA_Abort+0x620>)
24002f6a:	4293      	cmp	r3, r2
24002f6c:	d01d      	beq.n	24002faa <HAL_DMA_Abort+0x58a>
24002f6e:	687b      	ldr	r3, [r7, #4]
24002f70:	681b      	ldr	r3, [r3, #0]
24002f72:	4a34      	ldr	r2, [pc, #208]	; (24003044 <HAL_DMA_Abort+0x624>)
24002f74:	4293      	cmp	r3, r2
24002f76:	d018      	beq.n	24002faa <HAL_DMA_Abort+0x58a>
24002f78:	687b      	ldr	r3, [r7, #4]
24002f7a:	681b      	ldr	r3, [r3, #0]
24002f7c:	4a32      	ldr	r2, [pc, #200]	; (24003048 <HAL_DMA_Abort+0x628>)
24002f7e:	4293      	cmp	r3, r2
24002f80:	d013      	beq.n	24002faa <HAL_DMA_Abort+0x58a>
24002f82:	687b      	ldr	r3, [r7, #4]
24002f84:	681b      	ldr	r3, [r3, #0]
24002f86:	4a31      	ldr	r2, [pc, #196]	; (2400304c <HAL_DMA_Abort+0x62c>)
24002f88:	4293      	cmp	r3, r2
24002f8a:	d00e      	beq.n	24002faa <HAL_DMA_Abort+0x58a>
24002f8c:	687b      	ldr	r3, [r7, #4]
24002f8e:	681b      	ldr	r3, [r3, #0]
24002f90:	4a2f      	ldr	r2, [pc, #188]	; (24003050 <HAL_DMA_Abort+0x630>)
24002f92:	4293      	cmp	r3, r2
24002f94:	d009      	beq.n	24002faa <HAL_DMA_Abort+0x58a>
24002f96:	687b      	ldr	r3, [r7, #4]
24002f98:	681b      	ldr	r3, [r3, #0]
24002f9a:	4a2e      	ldr	r2, [pc, #184]	; (24003054 <HAL_DMA_Abort+0x634>)
24002f9c:	4293      	cmp	r3, r2
24002f9e:	d004      	beq.n	24002faa <HAL_DMA_Abort+0x58a>
24002fa0:	687b      	ldr	r3, [r7, #4]
24002fa2:	681b      	ldr	r3, [r3, #0]
24002fa4:	4a2c      	ldr	r2, [pc, #176]	; (24003058 <HAL_DMA_Abort+0x638>)
24002fa6:	4293      	cmp	r3, r2
24002fa8:	d101      	bne.n	24002fae <HAL_DMA_Abort+0x58e>
24002faa:	2301      	movs	r3, #1
24002fac:	e000      	b.n	24002fb0 <HAL_DMA_Abort+0x590>
24002fae:	2300      	movs	r3, #0
24002fb0:	2b00      	cmp	r3, #0
24002fb2:	d015      	beq.n	24002fe0 <HAL_DMA_Abort+0x5c0>
    {
      /* Clear the DMAMUX synchro overrun flag */
      hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
24002fb4:	687b      	ldr	r3, [r7, #4]
24002fb6:	6e5b      	ldr	r3, [r3, #100]	; 0x64
24002fb8:	687a      	ldr	r2, [r7, #4]
24002fba:	6e92      	ldr	r2, [r2, #104]	; 0x68
24002fbc:	605a      	str	r2, [r3, #4]

      if(hdma->DMAmuxRequestGen != 0U)
24002fbe:	687b      	ldr	r3, [r7, #4]
24002fc0:	6edb      	ldr	r3, [r3, #108]	; 0x6c
24002fc2:	2b00      	cmp	r3, #0
24002fc4:	d00c      	beq.n	24002fe0 <HAL_DMA_Abort+0x5c0>
      {
        /* if using DMAMUX request generator, disable the DMAMUX request generator overrun IT */
        /* disable the request gen overrun IT */
        hdma->DMAmuxRequestGen->RGCR &= ~DMAMUX_RGxCR_OIE;
24002fc6:	687b      	ldr	r3, [r7, #4]
24002fc8:	6edb      	ldr	r3, [r3, #108]	; 0x6c
24002fca:	681a      	ldr	r2, [r3, #0]
24002fcc:	687b      	ldr	r3, [r7, #4]
24002fce:	6edb      	ldr	r3, [r3, #108]	; 0x6c
24002fd0:	f422 7280 	bic.w	r2, r2, #256	; 0x100
24002fd4:	601a      	str	r2, [r3, #0]

        /* Clear the DMAMUX request generator overrun flag */
        hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
24002fd6:	687b      	ldr	r3, [r7, #4]
24002fd8:	6f1b      	ldr	r3, [r3, #112]	; 0x70
24002fda:	687a      	ldr	r2, [r7, #4]
24002fdc:	6f52      	ldr	r2, [r2, #116]	; 0x74
24002fde:	605a      	str	r2, [r3, #4]
      }
    }

    /* Process Unlocked */
    __HAL_UNLOCK(hdma);
24002fe0:	687b      	ldr	r3, [r7, #4]
24002fe2:	2200      	movs	r2, #0
24002fe4:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

    /* Change the DMA state */
    hdma->State = HAL_DMA_STATE_READY;
24002fe8:	687b      	ldr	r3, [r7, #4]
24002fea:	2201      	movs	r2, #1
24002fec:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
  }

  return HAL_OK;
24002ff0:	2300      	movs	r3, #0
}
24002ff2:	4618      	mov	r0, r3
24002ff4:	3718      	adds	r7, #24
24002ff6:	46bd      	mov	sp, r7
24002ff8:	bd80      	pop	{r7, pc}
24002ffa:	bf00      	nop
24002ffc:	40020010 	.word	0x40020010
24003000:	40020028 	.word	0x40020028
24003004:	40020040 	.word	0x40020040
24003008:	40020058 	.word	0x40020058
2400300c:	40020070 	.word	0x40020070
24003010:	40020088 	.word	0x40020088
24003014:	400200a0 	.word	0x400200a0
24003018:	400200b8 	.word	0x400200b8
2400301c:	40020410 	.word	0x40020410
24003020:	40020428 	.word	0x40020428
24003024:	40020440 	.word	0x40020440
24003028:	40020458 	.word	0x40020458
2400302c:	40020470 	.word	0x40020470
24003030:	40020488 	.word	0x40020488
24003034:	400204a0 	.word	0x400204a0
24003038:	400204b8 	.word	0x400204b8
2400303c:	58025408 	.word	0x58025408
24003040:	5802541c 	.word	0x5802541c
24003044:	58025430 	.word	0x58025430
24003048:	58025444 	.word	0x58025444
2400304c:	58025458 	.word	0x58025458
24003050:	5802546c 	.word	0x5802546c
24003054:	58025480 	.word	0x58025480
24003058:	58025494 	.word	0x58025494

2400305c <HAL_DMA_Abort_IT>:
  * @param  hdma  : pointer to a DMA_HandleTypeDef structure that contains
  *                 the configuration information for the specified DMA Stream.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Abort_IT(DMA_HandleTypeDef *hdma)
{
2400305c:	b580      	push	{r7, lr}
2400305e:	b084      	sub	sp, #16
24003060:	af00      	add	r7, sp, #0
24003062:	6078      	str	r0, [r7, #4]
  BDMA_Base_Registers *regs_bdma;

  /* Check the DMA peripheral handle */
  if(hdma == NULL)
24003064:	687b      	ldr	r3, [r7, #4]
24003066:	2b00      	cmp	r3, #0
24003068:	d101      	bne.n	2400306e <HAL_DMA_Abort_IT+0x12>
  {
    return HAL_ERROR;
2400306a:	2301      	movs	r3, #1
2400306c:	e205      	b.n	2400347a <HAL_DMA_Abort_IT+0x41e>
  }

  if(hdma->State != HAL_DMA_STATE_BUSY)
2400306e:	687b      	ldr	r3, [r7, #4]
24003070:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
24003074:	b2db      	uxtb	r3, r3
24003076:	2b02      	cmp	r3, #2
24003078:	d004      	beq.n	24003084 <HAL_DMA_Abort_IT+0x28>
  {
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
2400307a:	687b      	ldr	r3, [r7, #4]
2400307c:	2280      	movs	r2, #128	; 0x80
2400307e:	655a      	str	r2, [r3, #84]	; 0x54
    return HAL_ERROR;
24003080:	2301      	movs	r3, #1
24003082:	e1fa      	b.n	2400347a <HAL_DMA_Abort_IT+0x41e>
  }
  else
  {
    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
24003084:	687b      	ldr	r3, [r7, #4]
24003086:	681b      	ldr	r3, [r3, #0]
24003088:	4a8c      	ldr	r2, [pc, #560]	; (240032bc <HAL_DMA_Abort_IT+0x260>)
2400308a:	4293      	cmp	r3, r2
2400308c:	d04a      	beq.n	24003124 <HAL_DMA_Abort_IT+0xc8>
2400308e:	687b      	ldr	r3, [r7, #4]
24003090:	681b      	ldr	r3, [r3, #0]
24003092:	4a8b      	ldr	r2, [pc, #556]	; (240032c0 <HAL_DMA_Abort_IT+0x264>)
24003094:	4293      	cmp	r3, r2
24003096:	d045      	beq.n	24003124 <HAL_DMA_Abort_IT+0xc8>
24003098:	687b      	ldr	r3, [r7, #4]
2400309a:	681b      	ldr	r3, [r3, #0]
2400309c:	4a89      	ldr	r2, [pc, #548]	; (240032c4 <HAL_DMA_Abort_IT+0x268>)
2400309e:	4293      	cmp	r3, r2
240030a0:	d040      	beq.n	24003124 <HAL_DMA_Abort_IT+0xc8>
240030a2:	687b      	ldr	r3, [r7, #4]
240030a4:	681b      	ldr	r3, [r3, #0]
240030a6:	4a88      	ldr	r2, [pc, #544]	; (240032c8 <HAL_DMA_Abort_IT+0x26c>)
240030a8:	4293      	cmp	r3, r2
240030aa:	d03b      	beq.n	24003124 <HAL_DMA_Abort_IT+0xc8>
240030ac:	687b      	ldr	r3, [r7, #4]
240030ae:	681b      	ldr	r3, [r3, #0]
240030b0:	4a86      	ldr	r2, [pc, #536]	; (240032cc <HAL_DMA_Abort_IT+0x270>)
240030b2:	4293      	cmp	r3, r2
240030b4:	d036      	beq.n	24003124 <HAL_DMA_Abort_IT+0xc8>
240030b6:	687b      	ldr	r3, [r7, #4]
240030b8:	681b      	ldr	r3, [r3, #0]
240030ba:	4a85      	ldr	r2, [pc, #532]	; (240032d0 <HAL_DMA_Abort_IT+0x274>)
240030bc:	4293      	cmp	r3, r2
240030be:	d031      	beq.n	24003124 <HAL_DMA_Abort_IT+0xc8>
240030c0:	687b      	ldr	r3, [r7, #4]
240030c2:	681b      	ldr	r3, [r3, #0]
240030c4:	4a83      	ldr	r2, [pc, #524]	; (240032d4 <HAL_DMA_Abort_IT+0x278>)
240030c6:	4293      	cmp	r3, r2
240030c8:	d02c      	beq.n	24003124 <HAL_DMA_Abort_IT+0xc8>
240030ca:	687b      	ldr	r3, [r7, #4]
240030cc:	681b      	ldr	r3, [r3, #0]
240030ce:	4a82      	ldr	r2, [pc, #520]	; (240032d8 <HAL_DMA_Abort_IT+0x27c>)
240030d0:	4293      	cmp	r3, r2
240030d2:	d027      	beq.n	24003124 <HAL_DMA_Abort_IT+0xc8>
240030d4:	687b      	ldr	r3, [r7, #4]
240030d6:	681b      	ldr	r3, [r3, #0]
240030d8:	4a80      	ldr	r2, [pc, #512]	; (240032dc <HAL_DMA_Abort_IT+0x280>)
240030da:	4293      	cmp	r3, r2
240030dc:	d022      	beq.n	24003124 <HAL_DMA_Abort_IT+0xc8>
240030de:	687b      	ldr	r3, [r7, #4]
240030e0:	681b      	ldr	r3, [r3, #0]
240030e2:	4a7f      	ldr	r2, [pc, #508]	; (240032e0 <HAL_DMA_Abort_IT+0x284>)
240030e4:	4293      	cmp	r3, r2
240030e6:	d01d      	beq.n	24003124 <HAL_DMA_Abort_IT+0xc8>
240030e8:	687b      	ldr	r3, [r7, #4]
240030ea:	681b      	ldr	r3, [r3, #0]
240030ec:	4a7d      	ldr	r2, [pc, #500]	; (240032e4 <HAL_DMA_Abort_IT+0x288>)
240030ee:	4293      	cmp	r3, r2
240030f0:	d018      	beq.n	24003124 <HAL_DMA_Abort_IT+0xc8>
240030f2:	687b      	ldr	r3, [r7, #4]
240030f4:	681b      	ldr	r3, [r3, #0]
240030f6:	4a7c      	ldr	r2, [pc, #496]	; (240032e8 <HAL_DMA_Abort_IT+0x28c>)
240030f8:	4293      	cmp	r3, r2
240030fa:	d013      	beq.n	24003124 <HAL_DMA_Abort_IT+0xc8>
240030fc:	687b      	ldr	r3, [r7, #4]
240030fe:	681b      	ldr	r3, [r3, #0]
24003100:	4a7a      	ldr	r2, [pc, #488]	; (240032ec <HAL_DMA_Abort_IT+0x290>)
24003102:	4293      	cmp	r3, r2
24003104:	d00e      	beq.n	24003124 <HAL_DMA_Abort_IT+0xc8>
24003106:	687b      	ldr	r3, [r7, #4]
24003108:	681b      	ldr	r3, [r3, #0]
2400310a:	4a79      	ldr	r2, [pc, #484]	; (240032f0 <HAL_DMA_Abort_IT+0x294>)
2400310c:	4293      	cmp	r3, r2
2400310e:	d009      	beq.n	24003124 <HAL_DMA_Abort_IT+0xc8>
24003110:	687b      	ldr	r3, [r7, #4]
24003112:	681b      	ldr	r3, [r3, #0]
24003114:	4a77      	ldr	r2, [pc, #476]	; (240032f4 <HAL_DMA_Abort_IT+0x298>)
24003116:	4293      	cmp	r3, r2
24003118:	d004      	beq.n	24003124 <HAL_DMA_Abort_IT+0xc8>
2400311a:	687b      	ldr	r3, [r7, #4]
2400311c:	681b      	ldr	r3, [r3, #0]
2400311e:	4a76      	ldr	r2, [pc, #472]	; (240032f8 <HAL_DMA_Abort_IT+0x29c>)
24003120:	4293      	cmp	r3, r2
24003122:	d101      	bne.n	24003128 <HAL_DMA_Abort_IT+0xcc>
24003124:	2301      	movs	r3, #1
24003126:	e000      	b.n	2400312a <HAL_DMA_Abort_IT+0xce>
24003128:	2300      	movs	r3, #0
2400312a:	2b00      	cmp	r3, #0
2400312c:	d065      	beq.n	240031fa <HAL_DMA_Abort_IT+0x19e>
    {
      /* Set Abort State  */
      hdma->State = HAL_DMA_STATE_ABORT;
2400312e:	687b      	ldr	r3, [r7, #4]
24003130:	2204      	movs	r2, #4
24003132:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

      /* Disable the stream */
      __HAL_DMA_DISABLE(hdma);
24003136:	687b      	ldr	r3, [r7, #4]
24003138:	681b      	ldr	r3, [r3, #0]
2400313a:	4a60      	ldr	r2, [pc, #384]	; (240032bc <HAL_DMA_Abort_IT+0x260>)
2400313c:	4293      	cmp	r3, r2
2400313e:	d04a      	beq.n	240031d6 <HAL_DMA_Abort_IT+0x17a>
24003140:	687b      	ldr	r3, [r7, #4]
24003142:	681b      	ldr	r3, [r3, #0]
24003144:	4a5e      	ldr	r2, [pc, #376]	; (240032c0 <HAL_DMA_Abort_IT+0x264>)
24003146:	4293      	cmp	r3, r2
24003148:	d045      	beq.n	240031d6 <HAL_DMA_Abort_IT+0x17a>
2400314a:	687b      	ldr	r3, [r7, #4]
2400314c:	681b      	ldr	r3, [r3, #0]
2400314e:	4a5d      	ldr	r2, [pc, #372]	; (240032c4 <HAL_DMA_Abort_IT+0x268>)
24003150:	4293      	cmp	r3, r2
24003152:	d040      	beq.n	240031d6 <HAL_DMA_Abort_IT+0x17a>
24003154:	687b      	ldr	r3, [r7, #4]
24003156:	681b      	ldr	r3, [r3, #0]
24003158:	4a5b      	ldr	r2, [pc, #364]	; (240032c8 <HAL_DMA_Abort_IT+0x26c>)
2400315a:	4293      	cmp	r3, r2
2400315c:	d03b      	beq.n	240031d6 <HAL_DMA_Abort_IT+0x17a>
2400315e:	687b      	ldr	r3, [r7, #4]
24003160:	681b      	ldr	r3, [r3, #0]
24003162:	4a5a      	ldr	r2, [pc, #360]	; (240032cc <HAL_DMA_Abort_IT+0x270>)
24003164:	4293      	cmp	r3, r2
24003166:	d036      	beq.n	240031d6 <HAL_DMA_Abort_IT+0x17a>
24003168:	687b      	ldr	r3, [r7, #4]
2400316a:	681b      	ldr	r3, [r3, #0]
2400316c:	4a58      	ldr	r2, [pc, #352]	; (240032d0 <HAL_DMA_Abort_IT+0x274>)
2400316e:	4293      	cmp	r3, r2
24003170:	d031      	beq.n	240031d6 <HAL_DMA_Abort_IT+0x17a>
24003172:	687b      	ldr	r3, [r7, #4]
24003174:	681b      	ldr	r3, [r3, #0]
24003176:	4a57      	ldr	r2, [pc, #348]	; (240032d4 <HAL_DMA_Abort_IT+0x278>)
24003178:	4293      	cmp	r3, r2
2400317a:	d02c      	beq.n	240031d6 <HAL_DMA_Abort_IT+0x17a>
2400317c:	687b      	ldr	r3, [r7, #4]
2400317e:	681b      	ldr	r3, [r3, #0]
24003180:	4a55      	ldr	r2, [pc, #340]	; (240032d8 <HAL_DMA_Abort_IT+0x27c>)
24003182:	4293      	cmp	r3, r2
24003184:	d027      	beq.n	240031d6 <HAL_DMA_Abort_IT+0x17a>
24003186:	687b      	ldr	r3, [r7, #4]
24003188:	681b      	ldr	r3, [r3, #0]
2400318a:	4a54      	ldr	r2, [pc, #336]	; (240032dc <HAL_DMA_Abort_IT+0x280>)
2400318c:	4293      	cmp	r3, r2
2400318e:	d022      	beq.n	240031d6 <HAL_DMA_Abort_IT+0x17a>
24003190:	687b      	ldr	r3, [r7, #4]
24003192:	681b      	ldr	r3, [r3, #0]
24003194:	4a52      	ldr	r2, [pc, #328]	; (240032e0 <HAL_DMA_Abort_IT+0x284>)
24003196:	4293      	cmp	r3, r2
24003198:	d01d      	beq.n	240031d6 <HAL_DMA_Abort_IT+0x17a>
2400319a:	687b      	ldr	r3, [r7, #4]
2400319c:	681b      	ldr	r3, [r3, #0]
2400319e:	4a51      	ldr	r2, [pc, #324]	; (240032e4 <HAL_DMA_Abort_IT+0x288>)
240031a0:	4293      	cmp	r3, r2
240031a2:	d018      	beq.n	240031d6 <HAL_DMA_Abort_IT+0x17a>
240031a4:	687b      	ldr	r3, [r7, #4]
240031a6:	681b      	ldr	r3, [r3, #0]
240031a8:	4a4f      	ldr	r2, [pc, #316]	; (240032e8 <HAL_DMA_Abort_IT+0x28c>)
240031aa:	4293      	cmp	r3, r2
240031ac:	d013      	beq.n	240031d6 <HAL_DMA_Abort_IT+0x17a>
240031ae:	687b      	ldr	r3, [r7, #4]
240031b0:	681b      	ldr	r3, [r3, #0]
240031b2:	4a4e      	ldr	r2, [pc, #312]	; (240032ec <HAL_DMA_Abort_IT+0x290>)
240031b4:	4293      	cmp	r3, r2
240031b6:	d00e      	beq.n	240031d6 <HAL_DMA_Abort_IT+0x17a>
240031b8:	687b      	ldr	r3, [r7, #4]
240031ba:	681b      	ldr	r3, [r3, #0]
240031bc:	4a4c      	ldr	r2, [pc, #304]	; (240032f0 <HAL_DMA_Abort_IT+0x294>)
240031be:	4293      	cmp	r3, r2
240031c0:	d009      	beq.n	240031d6 <HAL_DMA_Abort_IT+0x17a>
240031c2:	687b      	ldr	r3, [r7, #4]
240031c4:	681b      	ldr	r3, [r3, #0]
240031c6:	4a4b      	ldr	r2, [pc, #300]	; (240032f4 <HAL_DMA_Abort_IT+0x298>)
240031c8:	4293      	cmp	r3, r2
240031ca:	d004      	beq.n	240031d6 <HAL_DMA_Abort_IT+0x17a>
240031cc:	687b      	ldr	r3, [r7, #4]
240031ce:	681b      	ldr	r3, [r3, #0]
240031d0:	4a49      	ldr	r2, [pc, #292]	; (240032f8 <HAL_DMA_Abort_IT+0x29c>)
240031d2:	4293      	cmp	r3, r2
240031d4:	d108      	bne.n	240031e8 <HAL_DMA_Abort_IT+0x18c>
240031d6:	687b      	ldr	r3, [r7, #4]
240031d8:	681b      	ldr	r3, [r3, #0]
240031da:	681a      	ldr	r2, [r3, #0]
240031dc:	687b      	ldr	r3, [r7, #4]
240031de:	681b      	ldr	r3, [r3, #0]
240031e0:	f022 0201 	bic.w	r2, r2, #1
240031e4:	601a      	str	r2, [r3, #0]
240031e6:	e147      	b.n	24003478 <HAL_DMA_Abort_IT+0x41c>
240031e8:	687b      	ldr	r3, [r7, #4]
240031ea:	681b      	ldr	r3, [r3, #0]
240031ec:	681a      	ldr	r2, [r3, #0]
240031ee:	687b      	ldr	r3, [r7, #4]
240031f0:	681b      	ldr	r3, [r3, #0]
240031f2:	f022 0201 	bic.w	r2, r2, #1
240031f6:	601a      	str	r2, [r3, #0]
240031f8:	e13e      	b.n	24003478 <HAL_DMA_Abort_IT+0x41c>
    }
    else /* BDMA channel */
    {
      /* Disable DMA All Interrupts  */
      ((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR  &= ~(BDMA_CCR_TCIE | BDMA_CCR_HTIE | BDMA_CCR_TEIE);
240031fa:	687b      	ldr	r3, [r7, #4]
240031fc:	681b      	ldr	r3, [r3, #0]
240031fe:	681a      	ldr	r2, [r3, #0]
24003200:	687b      	ldr	r3, [r7, #4]
24003202:	681b      	ldr	r3, [r3, #0]
24003204:	f022 020e 	bic.w	r2, r2, #14
24003208:	601a      	str	r2, [r3, #0]

      /* Disable the channel */
      __HAL_DMA_DISABLE(hdma);
2400320a:	687b      	ldr	r3, [r7, #4]
2400320c:	681b      	ldr	r3, [r3, #0]
2400320e:	4a2b      	ldr	r2, [pc, #172]	; (240032bc <HAL_DMA_Abort_IT+0x260>)
24003210:	4293      	cmp	r3, r2
24003212:	d04a      	beq.n	240032aa <HAL_DMA_Abort_IT+0x24e>
24003214:	687b      	ldr	r3, [r7, #4]
24003216:	681b      	ldr	r3, [r3, #0]
24003218:	4a29      	ldr	r2, [pc, #164]	; (240032c0 <HAL_DMA_Abort_IT+0x264>)
2400321a:	4293      	cmp	r3, r2
2400321c:	d045      	beq.n	240032aa <HAL_DMA_Abort_IT+0x24e>
2400321e:	687b      	ldr	r3, [r7, #4]
24003220:	681b      	ldr	r3, [r3, #0]
24003222:	4a28      	ldr	r2, [pc, #160]	; (240032c4 <HAL_DMA_Abort_IT+0x268>)
24003224:	4293      	cmp	r3, r2
24003226:	d040      	beq.n	240032aa <HAL_DMA_Abort_IT+0x24e>
24003228:	687b      	ldr	r3, [r7, #4]
2400322a:	681b      	ldr	r3, [r3, #0]
2400322c:	4a26      	ldr	r2, [pc, #152]	; (240032c8 <HAL_DMA_Abort_IT+0x26c>)
2400322e:	4293      	cmp	r3, r2
24003230:	d03b      	beq.n	240032aa <HAL_DMA_Abort_IT+0x24e>
24003232:	687b      	ldr	r3, [r7, #4]
24003234:	681b      	ldr	r3, [r3, #0]
24003236:	4a25      	ldr	r2, [pc, #148]	; (240032cc <HAL_DMA_Abort_IT+0x270>)
24003238:	4293      	cmp	r3, r2
2400323a:	d036      	beq.n	240032aa <HAL_DMA_Abort_IT+0x24e>
2400323c:	687b      	ldr	r3, [r7, #4]
2400323e:	681b      	ldr	r3, [r3, #0]
24003240:	4a23      	ldr	r2, [pc, #140]	; (240032d0 <HAL_DMA_Abort_IT+0x274>)
24003242:	4293      	cmp	r3, r2
24003244:	d031      	beq.n	240032aa <HAL_DMA_Abort_IT+0x24e>
24003246:	687b      	ldr	r3, [r7, #4]
24003248:	681b      	ldr	r3, [r3, #0]
2400324a:	4a22      	ldr	r2, [pc, #136]	; (240032d4 <HAL_DMA_Abort_IT+0x278>)
2400324c:	4293      	cmp	r3, r2
2400324e:	d02c      	beq.n	240032aa <HAL_DMA_Abort_IT+0x24e>
24003250:	687b      	ldr	r3, [r7, #4]
24003252:	681b      	ldr	r3, [r3, #0]
24003254:	4a20      	ldr	r2, [pc, #128]	; (240032d8 <HAL_DMA_Abort_IT+0x27c>)
24003256:	4293      	cmp	r3, r2
24003258:	d027      	beq.n	240032aa <HAL_DMA_Abort_IT+0x24e>
2400325a:	687b      	ldr	r3, [r7, #4]
2400325c:	681b      	ldr	r3, [r3, #0]
2400325e:	4a1f      	ldr	r2, [pc, #124]	; (240032dc <HAL_DMA_Abort_IT+0x280>)
24003260:	4293      	cmp	r3, r2
24003262:	d022      	beq.n	240032aa <HAL_DMA_Abort_IT+0x24e>
24003264:	687b      	ldr	r3, [r7, #4]
24003266:	681b      	ldr	r3, [r3, #0]
24003268:	4a1d      	ldr	r2, [pc, #116]	; (240032e0 <HAL_DMA_Abort_IT+0x284>)
2400326a:	4293      	cmp	r3, r2
2400326c:	d01d      	beq.n	240032aa <HAL_DMA_Abort_IT+0x24e>
2400326e:	687b      	ldr	r3, [r7, #4]
24003270:	681b      	ldr	r3, [r3, #0]
24003272:	4a1c      	ldr	r2, [pc, #112]	; (240032e4 <HAL_DMA_Abort_IT+0x288>)
24003274:	4293      	cmp	r3, r2
24003276:	d018      	beq.n	240032aa <HAL_DMA_Abort_IT+0x24e>
24003278:	687b      	ldr	r3, [r7, #4]
2400327a:	681b      	ldr	r3, [r3, #0]
2400327c:	4a1a      	ldr	r2, [pc, #104]	; (240032e8 <HAL_DMA_Abort_IT+0x28c>)
2400327e:	4293      	cmp	r3, r2
24003280:	d013      	beq.n	240032aa <HAL_DMA_Abort_IT+0x24e>
24003282:	687b      	ldr	r3, [r7, #4]
24003284:	681b      	ldr	r3, [r3, #0]
24003286:	4a19      	ldr	r2, [pc, #100]	; (240032ec <HAL_DMA_Abort_IT+0x290>)
24003288:	4293      	cmp	r3, r2
2400328a:	d00e      	beq.n	240032aa <HAL_DMA_Abort_IT+0x24e>
2400328c:	687b      	ldr	r3, [r7, #4]
2400328e:	681b      	ldr	r3, [r3, #0]
24003290:	4a17      	ldr	r2, [pc, #92]	; (240032f0 <HAL_DMA_Abort_IT+0x294>)
24003292:	4293      	cmp	r3, r2
24003294:	d009      	beq.n	240032aa <HAL_DMA_Abort_IT+0x24e>
24003296:	687b      	ldr	r3, [r7, #4]
24003298:	681b      	ldr	r3, [r3, #0]
2400329a:	4a16      	ldr	r2, [pc, #88]	; (240032f4 <HAL_DMA_Abort_IT+0x298>)
2400329c:	4293      	cmp	r3, r2
2400329e:	d004      	beq.n	240032aa <HAL_DMA_Abort_IT+0x24e>
240032a0:	687b      	ldr	r3, [r7, #4]
240032a2:	681b      	ldr	r3, [r3, #0]
240032a4:	4a14      	ldr	r2, [pc, #80]	; (240032f8 <HAL_DMA_Abort_IT+0x29c>)
240032a6:	4293      	cmp	r3, r2
240032a8:	d128      	bne.n	240032fc <HAL_DMA_Abort_IT+0x2a0>
240032aa:	687b      	ldr	r3, [r7, #4]
240032ac:	681b      	ldr	r3, [r3, #0]
240032ae:	681a      	ldr	r2, [r3, #0]
240032b0:	687b      	ldr	r3, [r7, #4]
240032b2:	681b      	ldr	r3, [r3, #0]
240032b4:	f022 0201 	bic.w	r2, r2, #1
240032b8:	601a      	str	r2, [r3, #0]
240032ba:	e027      	b.n	2400330c <HAL_DMA_Abort_IT+0x2b0>
240032bc:	40020010 	.word	0x40020010
240032c0:	40020028 	.word	0x40020028
240032c4:	40020040 	.word	0x40020040
240032c8:	40020058 	.word	0x40020058
240032cc:	40020070 	.word	0x40020070
240032d0:	40020088 	.word	0x40020088
240032d4:	400200a0 	.word	0x400200a0
240032d8:	400200b8 	.word	0x400200b8
240032dc:	40020410 	.word	0x40020410
240032e0:	40020428 	.word	0x40020428
240032e4:	40020440 	.word	0x40020440
240032e8:	40020458 	.word	0x40020458
240032ec:	40020470 	.word	0x40020470
240032f0:	40020488 	.word	0x40020488
240032f4:	400204a0 	.word	0x400204a0
240032f8:	400204b8 	.word	0x400204b8
240032fc:	687b      	ldr	r3, [r7, #4]
240032fe:	681b      	ldr	r3, [r3, #0]
24003300:	681a      	ldr	r2, [r3, #0]
24003302:	687b      	ldr	r3, [r7, #4]
24003304:	681b      	ldr	r3, [r3, #0]
24003306:	f022 0201 	bic.w	r2, r2, #1
2400330a:	601a      	str	r2, [r3, #0]

      if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
2400330c:	687b      	ldr	r3, [r7, #4]
2400330e:	681b      	ldr	r3, [r3, #0]
24003310:	4a5c      	ldr	r2, [pc, #368]	; (24003484 <HAL_DMA_Abort_IT+0x428>)
24003312:	4293      	cmp	r3, r2
24003314:	d072      	beq.n	240033fc <HAL_DMA_Abort_IT+0x3a0>
24003316:	687b      	ldr	r3, [r7, #4]
24003318:	681b      	ldr	r3, [r3, #0]
2400331a:	4a5b      	ldr	r2, [pc, #364]	; (24003488 <HAL_DMA_Abort_IT+0x42c>)
2400331c:	4293      	cmp	r3, r2
2400331e:	d06d      	beq.n	240033fc <HAL_DMA_Abort_IT+0x3a0>
24003320:	687b      	ldr	r3, [r7, #4]
24003322:	681b      	ldr	r3, [r3, #0]
24003324:	4a59      	ldr	r2, [pc, #356]	; (2400348c <HAL_DMA_Abort_IT+0x430>)
24003326:	4293      	cmp	r3, r2
24003328:	d068      	beq.n	240033fc <HAL_DMA_Abort_IT+0x3a0>
2400332a:	687b      	ldr	r3, [r7, #4]
2400332c:	681b      	ldr	r3, [r3, #0]
2400332e:	4a58      	ldr	r2, [pc, #352]	; (24003490 <HAL_DMA_Abort_IT+0x434>)
24003330:	4293      	cmp	r3, r2
24003332:	d063      	beq.n	240033fc <HAL_DMA_Abort_IT+0x3a0>
24003334:	687b      	ldr	r3, [r7, #4]
24003336:	681b      	ldr	r3, [r3, #0]
24003338:	4a56      	ldr	r2, [pc, #344]	; (24003494 <HAL_DMA_Abort_IT+0x438>)
2400333a:	4293      	cmp	r3, r2
2400333c:	d05e      	beq.n	240033fc <HAL_DMA_Abort_IT+0x3a0>
2400333e:	687b      	ldr	r3, [r7, #4]
24003340:	681b      	ldr	r3, [r3, #0]
24003342:	4a55      	ldr	r2, [pc, #340]	; (24003498 <HAL_DMA_Abort_IT+0x43c>)
24003344:	4293      	cmp	r3, r2
24003346:	d059      	beq.n	240033fc <HAL_DMA_Abort_IT+0x3a0>
24003348:	687b      	ldr	r3, [r7, #4]
2400334a:	681b      	ldr	r3, [r3, #0]
2400334c:	4a53      	ldr	r2, [pc, #332]	; (2400349c <HAL_DMA_Abort_IT+0x440>)
2400334e:	4293      	cmp	r3, r2
24003350:	d054      	beq.n	240033fc <HAL_DMA_Abort_IT+0x3a0>
24003352:	687b      	ldr	r3, [r7, #4]
24003354:	681b      	ldr	r3, [r3, #0]
24003356:	4a52      	ldr	r2, [pc, #328]	; (240034a0 <HAL_DMA_Abort_IT+0x444>)
24003358:	4293      	cmp	r3, r2
2400335a:	d04f      	beq.n	240033fc <HAL_DMA_Abort_IT+0x3a0>
2400335c:	687b      	ldr	r3, [r7, #4]
2400335e:	681b      	ldr	r3, [r3, #0]
24003360:	4a50      	ldr	r2, [pc, #320]	; (240034a4 <HAL_DMA_Abort_IT+0x448>)
24003362:	4293      	cmp	r3, r2
24003364:	d04a      	beq.n	240033fc <HAL_DMA_Abort_IT+0x3a0>
24003366:	687b      	ldr	r3, [r7, #4]
24003368:	681b      	ldr	r3, [r3, #0]
2400336a:	4a4f      	ldr	r2, [pc, #316]	; (240034a8 <HAL_DMA_Abort_IT+0x44c>)
2400336c:	4293      	cmp	r3, r2
2400336e:	d045      	beq.n	240033fc <HAL_DMA_Abort_IT+0x3a0>
24003370:	687b      	ldr	r3, [r7, #4]
24003372:	681b      	ldr	r3, [r3, #0]
24003374:	4a4d      	ldr	r2, [pc, #308]	; (240034ac <HAL_DMA_Abort_IT+0x450>)
24003376:	4293      	cmp	r3, r2
24003378:	d040      	beq.n	240033fc <HAL_DMA_Abort_IT+0x3a0>
2400337a:	687b      	ldr	r3, [r7, #4]
2400337c:	681b      	ldr	r3, [r3, #0]
2400337e:	4a4c      	ldr	r2, [pc, #304]	; (240034b0 <HAL_DMA_Abort_IT+0x454>)
24003380:	4293      	cmp	r3, r2
24003382:	d03b      	beq.n	240033fc <HAL_DMA_Abort_IT+0x3a0>
24003384:	687b      	ldr	r3, [r7, #4]
24003386:	681b      	ldr	r3, [r3, #0]
24003388:	4a4a      	ldr	r2, [pc, #296]	; (240034b4 <HAL_DMA_Abort_IT+0x458>)
2400338a:	4293      	cmp	r3, r2
2400338c:	d036      	beq.n	240033fc <HAL_DMA_Abort_IT+0x3a0>
2400338e:	687b      	ldr	r3, [r7, #4]
24003390:	681b      	ldr	r3, [r3, #0]
24003392:	4a49      	ldr	r2, [pc, #292]	; (240034b8 <HAL_DMA_Abort_IT+0x45c>)
24003394:	4293      	cmp	r3, r2
24003396:	d031      	beq.n	240033fc <HAL_DMA_Abort_IT+0x3a0>
24003398:	687b      	ldr	r3, [r7, #4]
2400339a:	681b      	ldr	r3, [r3, #0]
2400339c:	4a47      	ldr	r2, [pc, #284]	; (240034bc <HAL_DMA_Abort_IT+0x460>)
2400339e:	4293      	cmp	r3, r2
240033a0:	d02c      	beq.n	240033fc <HAL_DMA_Abort_IT+0x3a0>
240033a2:	687b      	ldr	r3, [r7, #4]
240033a4:	681b      	ldr	r3, [r3, #0]
240033a6:	4a46      	ldr	r2, [pc, #280]	; (240034c0 <HAL_DMA_Abort_IT+0x464>)
240033a8:	4293      	cmp	r3, r2
240033aa:	d027      	beq.n	240033fc <HAL_DMA_Abort_IT+0x3a0>
240033ac:	687b      	ldr	r3, [r7, #4]
240033ae:	681b      	ldr	r3, [r3, #0]
240033b0:	4a44      	ldr	r2, [pc, #272]	; (240034c4 <HAL_DMA_Abort_IT+0x468>)
240033b2:	4293      	cmp	r3, r2
240033b4:	d022      	beq.n	240033fc <HAL_DMA_Abort_IT+0x3a0>
240033b6:	687b      	ldr	r3, [r7, #4]
240033b8:	681b      	ldr	r3, [r3, #0]
240033ba:	4a43      	ldr	r2, [pc, #268]	; (240034c8 <HAL_DMA_Abort_IT+0x46c>)
240033bc:	4293      	cmp	r3, r2
240033be:	d01d      	beq.n	240033fc <HAL_DMA_Abort_IT+0x3a0>
240033c0:	687b      	ldr	r3, [r7, #4]
240033c2:	681b      	ldr	r3, [r3, #0]
240033c4:	4a41      	ldr	r2, [pc, #260]	; (240034cc <HAL_DMA_Abort_IT+0x470>)
240033c6:	4293      	cmp	r3, r2
240033c8:	d018      	beq.n	240033fc <HAL_DMA_Abort_IT+0x3a0>
240033ca:	687b      	ldr	r3, [r7, #4]
240033cc:	681b      	ldr	r3, [r3, #0]
240033ce:	4a40      	ldr	r2, [pc, #256]	; (240034d0 <HAL_DMA_Abort_IT+0x474>)
240033d0:	4293      	cmp	r3, r2
240033d2:	d013      	beq.n	240033fc <HAL_DMA_Abort_IT+0x3a0>
240033d4:	687b      	ldr	r3, [r7, #4]
240033d6:	681b      	ldr	r3, [r3, #0]
240033d8:	4a3e      	ldr	r2, [pc, #248]	; (240034d4 <HAL_DMA_Abort_IT+0x478>)
240033da:	4293      	cmp	r3, r2
240033dc:	d00e      	beq.n	240033fc <HAL_DMA_Abort_IT+0x3a0>
240033de:	687b      	ldr	r3, [r7, #4]
240033e0:	681b      	ldr	r3, [r3, #0]
240033e2:	4a3d      	ldr	r2, [pc, #244]	; (240034d8 <HAL_DMA_Abort_IT+0x47c>)
240033e4:	4293      	cmp	r3, r2
240033e6:	d009      	beq.n	240033fc <HAL_DMA_Abort_IT+0x3a0>
240033e8:	687b      	ldr	r3, [r7, #4]
240033ea:	681b      	ldr	r3, [r3, #0]
240033ec:	4a3b      	ldr	r2, [pc, #236]	; (240034dc <HAL_DMA_Abort_IT+0x480>)
240033ee:	4293      	cmp	r3, r2
240033f0:	d004      	beq.n	240033fc <HAL_DMA_Abort_IT+0x3a0>
240033f2:	687b      	ldr	r3, [r7, #4]
240033f4:	681b      	ldr	r3, [r3, #0]
240033f6:	4a3a      	ldr	r2, [pc, #232]	; (240034e0 <HAL_DMA_Abort_IT+0x484>)
240033f8:	4293      	cmp	r3, r2
240033fa:	d101      	bne.n	24003400 <HAL_DMA_Abort_IT+0x3a4>
240033fc:	2301      	movs	r3, #1
240033fe:	e000      	b.n	24003402 <HAL_DMA_Abort_IT+0x3a6>
24003400:	2300      	movs	r3, #0
24003402:	2b00      	cmp	r3, #0
24003404:	d028      	beq.n	24003458 <HAL_DMA_Abort_IT+0x3fc>
      {
        /* disable the DMAMUX sync overrun IT */
        hdma->DMAmuxChannel->CCR &= ~DMAMUX_CxCR_SOIE;
24003406:	687b      	ldr	r3, [r7, #4]
24003408:	6e1b      	ldr	r3, [r3, #96]	; 0x60
2400340a:	681a      	ldr	r2, [r3, #0]
2400340c:	687b      	ldr	r3, [r7, #4]
2400340e:	6e1b      	ldr	r3, [r3, #96]	; 0x60
24003410:	f422 7280 	bic.w	r2, r2, #256	; 0x100
24003414:	601a      	str	r2, [r3, #0]

        /* Clear all flags */
        regs_bdma = (BDMA_Base_Registers *)hdma->StreamBaseAddress;
24003416:	687b      	ldr	r3, [r7, #4]
24003418:	6d9b      	ldr	r3, [r3, #88]	; 0x58
2400341a:	60fb      	str	r3, [r7, #12]
        regs_bdma->IFCR = ((BDMA_IFCR_CGIF0) << (hdma->StreamIndex & 0x1FU));
2400341c:	687b      	ldr	r3, [r7, #4]
2400341e:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24003420:	f003 031f 	and.w	r3, r3, #31
24003424:	2201      	movs	r2, #1
24003426:	409a      	lsls	r2, r3
24003428:	68fb      	ldr	r3, [r7, #12]
2400342a:	605a      	str	r2, [r3, #4]

        /* Clear the DMAMUX synchro overrun flag */
        hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
2400342c:	687b      	ldr	r3, [r7, #4]
2400342e:	6e5b      	ldr	r3, [r3, #100]	; 0x64
24003430:	687a      	ldr	r2, [r7, #4]
24003432:	6e92      	ldr	r2, [r2, #104]	; 0x68
24003434:	605a      	str	r2, [r3, #4]

        if(hdma->DMAmuxRequestGen != 0U)
24003436:	687b      	ldr	r3, [r7, #4]
24003438:	6edb      	ldr	r3, [r3, #108]	; 0x6c
2400343a:	2b00      	cmp	r3, #0
2400343c:	d00c      	beq.n	24003458 <HAL_DMA_Abort_IT+0x3fc>
        {
          /* if using DMAMUX request generator, disable the DMAMUX request generator overrun IT*/
          /* disable the request gen overrun IT */
          hdma->DMAmuxRequestGen->RGCR &= ~DMAMUX_RGxCR_OIE;
2400343e:	687b      	ldr	r3, [r7, #4]
24003440:	6edb      	ldr	r3, [r3, #108]	; 0x6c
24003442:	681a      	ldr	r2, [r3, #0]
24003444:	687b      	ldr	r3, [r7, #4]
24003446:	6edb      	ldr	r3, [r3, #108]	; 0x6c
24003448:	f422 7280 	bic.w	r2, r2, #256	; 0x100
2400344c:	601a      	str	r2, [r3, #0]

          /* Clear the DMAMUX request generator overrun flag */
          hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
2400344e:	687b      	ldr	r3, [r7, #4]
24003450:	6f1b      	ldr	r3, [r3, #112]	; 0x70
24003452:	687a      	ldr	r2, [r7, #4]
24003454:	6f52      	ldr	r2, [r2, #116]	; 0x74
24003456:	605a      	str	r2, [r3, #4]
        }
      }

      /* Process Unlocked */
      __HAL_UNLOCK(hdma);
24003458:	687b      	ldr	r3, [r7, #4]
2400345a:	2200      	movs	r2, #0
2400345c:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

      /* Change the DMA state */
      hdma->State = HAL_DMA_STATE_READY;
24003460:	687b      	ldr	r3, [r7, #4]
24003462:	2201      	movs	r2, #1
24003464:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

      /* Call User Abort callback */
      if(hdma->XferAbortCallback != NULL)
24003468:	687b      	ldr	r3, [r7, #4]
2400346a:	6d1b      	ldr	r3, [r3, #80]	; 0x50
2400346c:	2b00      	cmp	r3, #0
2400346e:	d003      	beq.n	24003478 <HAL_DMA_Abort_IT+0x41c>
      {
        hdma->XferAbortCallback(hdma);
24003470:	687b      	ldr	r3, [r7, #4]
24003472:	6d1b      	ldr	r3, [r3, #80]	; 0x50
24003474:	6878      	ldr	r0, [r7, #4]
24003476:	4798      	blx	r3
      }
    }
  }

  return HAL_OK;
24003478:	2300      	movs	r3, #0
}
2400347a:	4618      	mov	r0, r3
2400347c:	3710      	adds	r7, #16
2400347e:	46bd      	mov	sp, r7
24003480:	bd80      	pop	{r7, pc}
24003482:	bf00      	nop
24003484:	40020010 	.word	0x40020010
24003488:	40020028 	.word	0x40020028
2400348c:	40020040 	.word	0x40020040
24003490:	40020058 	.word	0x40020058
24003494:	40020070 	.word	0x40020070
24003498:	40020088 	.word	0x40020088
2400349c:	400200a0 	.word	0x400200a0
240034a0:	400200b8 	.word	0x400200b8
240034a4:	40020410 	.word	0x40020410
240034a8:	40020428 	.word	0x40020428
240034ac:	40020440 	.word	0x40020440
240034b0:	40020458 	.word	0x40020458
240034b4:	40020470 	.word	0x40020470
240034b8:	40020488 	.word	0x40020488
240034bc:	400204a0 	.word	0x400204a0
240034c0:	400204b8 	.word	0x400204b8
240034c4:	58025408 	.word	0x58025408
240034c8:	5802541c 	.word	0x5802541c
240034cc:	58025430 	.word	0x58025430
240034d0:	58025444 	.word	0x58025444
240034d4:	58025458 	.word	0x58025458
240034d8:	5802546c 	.word	0x5802546c
240034dc:	58025480 	.word	0x58025480
240034e0:	58025494 	.word	0x58025494

240034e4 <HAL_DMA_PollForTransfer>:
  * @note   The HAL_DMA_PollForTransfer API cannot be used in circular and double buffering mode (automatic circular mode).
  * @param  Timeout:       Timeout duration.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_PollForTransfer(DMA_HandleTypeDef *hdma, HAL_DMA_LevelCompleteTypeDef CompleteLevel, uint32_t Timeout)
{
240034e4:	b580      	push	{r7, lr}
240034e6:	b08a      	sub	sp, #40	; 0x28
240034e8:	af00      	add	r7, sp, #0
240034ea:	60f8      	str	r0, [r7, #12]
240034ec:	460b      	mov	r3, r1
240034ee:	607a      	str	r2, [r7, #4]
240034f0:	72fb      	strb	r3, [r7, #11]
  HAL_StatusTypeDef status = HAL_OK;
240034f2:	2300      	movs	r3, #0
240034f4:	76fb      	strb	r3, [r7, #27]
  uint32_t cpltlevel_mask;
  uint32_t tickstart = HAL_GetTick();
240034f6:	f7fd f9ab 	bl	24000850 <HAL_GetTick>
240034fa:	6178      	str	r0, [r7, #20]
  __IO uint32_t *isr_reg;
  /* IT clear flag register */
  __IO uint32_t *ifcr_reg;

  /* Check the DMA peripheral handle */
  if(hdma == NULL)
240034fc:	68fb      	ldr	r3, [r7, #12]
240034fe:	2b00      	cmp	r3, #0
24003500:	d101      	bne.n	24003506 <HAL_DMA_PollForTransfer+0x22>
  {
    return HAL_ERROR;
24003502:	2301      	movs	r3, #1
24003504:	e373      	b.n	24003bee <HAL_DMA_PollForTransfer+0x70a>
  }

  if(HAL_DMA_STATE_BUSY != hdma->State)
24003506:	68fb      	ldr	r3, [r7, #12]
24003508:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
2400350c:	b2db      	uxtb	r3, r3
2400350e:	2b02      	cmp	r3, #2
24003510:	d008      	beq.n	24003524 <HAL_DMA_PollForTransfer+0x40>
  {
    /* No transfer ongoing */
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
24003512:	68fb      	ldr	r3, [r7, #12]
24003514:	2280      	movs	r2, #128	; 0x80
24003516:	655a      	str	r2, [r3, #84]	; 0x54
    __HAL_UNLOCK(hdma);
24003518:	68fb      	ldr	r3, [r7, #12]
2400351a:	2200      	movs	r2, #0
2400351c:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

    return HAL_ERROR;
24003520:	2301      	movs	r3, #1
24003522:	e364      	b.n	24003bee <HAL_DMA_PollForTransfer+0x70a>
  }

  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
24003524:	68fb      	ldr	r3, [r7, #12]
24003526:	681b      	ldr	r3, [r3, #0]
24003528:	4a7b      	ldr	r2, [pc, #492]	; (24003718 <HAL_DMA_PollForTransfer+0x234>)
2400352a:	4293      	cmp	r3, r2
2400352c:	d04a      	beq.n	240035c4 <HAL_DMA_PollForTransfer+0xe0>
2400352e:	68fb      	ldr	r3, [r7, #12]
24003530:	681b      	ldr	r3, [r3, #0]
24003532:	4a7a      	ldr	r2, [pc, #488]	; (2400371c <HAL_DMA_PollForTransfer+0x238>)
24003534:	4293      	cmp	r3, r2
24003536:	d045      	beq.n	240035c4 <HAL_DMA_PollForTransfer+0xe0>
24003538:	68fb      	ldr	r3, [r7, #12]
2400353a:	681b      	ldr	r3, [r3, #0]
2400353c:	4a78      	ldr	r2, [pc, #480]	; (24003720 <HAL_DMA_PollForTransfer+0x23c>)
2400353e:	4293      	cmp	r3, r2
24003540:	d040      	beq.n	240035c4 <HAL_DMA_PollForTransfer+0xe0>
24003542:	68fb      	ldr	r3, [r7, #12]
24003544:	681b      	ldr	r3, [r3, #0]
24003546:	4a77      	ldr	r2, [pc, #476]	; (24003724 <HAL_DMA_PollForTransfer+0x240>)
24003548:	4293      	cmp	r3, r2
2400354a:	d03b      	beq.n	240035c4 <HAL_DMA_PollForTransfer+0xe0>
2400354c:	68fb      	ldr	r3, [r7, #12]
2400354e:	681b      	ldr	r3, [r3, #0]
24003550:	4a75      	ldr	r2, [pc, #468]	; (24003728 <HAL_DMA_PollForTransfer+0x244>)
24003552:	4293      	cmp	r3, r2
24003554:	d036      	beq.n	240035c4 <HAL_DMA_PollForTransfer+0xe0>
24003556:	68fb      	ldr	r3, [r7, #12]
24003558:	681b      	ldr	r3, [r3, #0]
2400355a:	4a74      	ldr	r2, [pc, #464]	; (2400372c <HAL_DMA_PollForTransfer+0x248>)
2400355c:	4293      	cmp	r3, r2
2400355e:	d031      	beq.n	240035c4 <HAL_DMA_PollForTransfer+0xe0>
24003560:	68fb      	ldr	r3, [r7, #12]
24003562:	681b      	ldr	r3, [r3, #0]
24003564:	4a72      	ldr	r2, [pc, #456]	; (24003730 <HAL_DMA_PollForTransfer+0x24c>)
24003566:	4293      	cmp	r3, r2
24003568:	d02c      	beq.n	240035c4 <HAL_DMA_PollForTransfer+0xe0>
2400356a:	68fb      	ldr	r3, [r7, #12]
2400356c:	681b      	ldr	r3, [r3, #0]
2400356e:	4a71      	ldr	r2, [pc, #452]	; (24003734 <HAL_DMA_PollForTransfer+0x250>)
24003570:	4293      	cmp	r3, r2
24003572:	d027      	beq.n	240035c4 <HAL_DMA_PollForTransfer+0xe0>
24003574:	68fb      	ldr	r3, [r7, #12]
24003576:	681b      	ldr	r3, [r3, #0]
24003578:	4a6f      	ldr	r2, [pc, #444]	; (24003738 <HAL_DMA_PollForTransfer+0x254>)
2400357a:	4293      	cmp	r3, r2
2400357c:	d022      	beq.n	240035c4 <HAL_DMA_PollForTransfer+0xe0>
2400357e:	68fb      	ldr	r3, [r7, #12]
24003580:	681b      	ldr	r3, [r3, #0]
24003582:	4a6e      	ldr	r2, [pc, #440]	; (2400373c <HAL_DMA_PollForTransfer+0x258>)
24003584:	4293      	cmp	r3, r2
24003586:	d01d      	beq.n	240035c4 <HAL_DMA_PollForTransfer+0xe0>
24003588:	68fb      	ldr	r3, [r7, #12]
2400358a:	681b      	ldr	r3, [r3, #0]
2400358c:	4a6c      	ldr	r2, [pc, #432]	; (24003740 <HAL_DMA_PollForTransfer+0x25c>)
2400358e:	4293      	cmp	r3, r2
24003590:	d018      	beq.n	240035c4 <HAL_DMA_PollForTransfer+0xe0>
24003592:	68fb      	ldr	r3, [r7, #12]
24003594:	681b      	ldr	r3, [r3, #0]
24003596:	4a6b      	ldr	r2, [pc, #428]	; (24003744 <HAL_DMA_PollForTransfer+0x260>)
24003598:	4293      	cmp	r3, r2
2400359a:	d013      	beq.n	240035c4 <HAL_DMA_PollForTransfer+0xe0>
2400359c:	68fb      	ldr	r3, [r7, #12]
2400359e:	681b      	ldr	r3, [r3, #0]
240035a0:	4a69      	ldr	r2, [pc, #420]	; (24003748 <HAL_DMA_PollForTransfer+0x264>)
240035a2:	4293      	cmp	r3, r2
240035a4:	d00e      	beq.n	240035c4 <HAL_DMA_PollForTransfer+0xe0>
240035a6:	68fb      	ldr	r3, [r7, #12]
240035a8:	681b      	ldr	r3, [r3, #0]
240035aa:	4a68      	ldr	r2, [pc, #416]	; (2400374c <HAL_DMA_PollForTransfer+0x268>)
240035ac:	4293      	cmp	r3, r2
240035ae:	d009      	beq.n	240035c4 <HAL_DMA_PollForTransfer+0xe0>
240035b0:	68fb      	ldr	r3, [r7, #12]
240035b2:	681b      	ldr	r3, [r3, #0]
240035b4:	4a66      	ldr	r2, [pc, #408]	; (24003750 <HAL_DMA_PollForTransfer+0x26c>)
240035b6:	4293      	cmp	r3, r2
240035b8:	d004      	beq.n	240035c4 <HAL_DMA_PollForTransfer+0xe0>
240035ba:	68fb      	ldr	r3, [r7, #12]
240035bc:	681b      	ldr	r3, [r3, #0]
240035be:	4a65      	ldr	r2, [pc, #404]	; (24003754 <HAL_DMA_PollForTransfer+0x270>)
240035c0:	4293      	cmp	r3, r2
240035c2:	d101      	bne.n	240035c8 <HAL_DMA_PollForTransfer+0xe4>
240035c4:	2301      	movs	r3, #1
240035c6:	e000      	b.n	240035ca <HAL_DMA_PollForTransfer+0xe6>
240035c8:	2300      	movs	r3, #0
240035ca:	2b00      	cmp	r3, #0
240035cc:	d028      	beq.n	24003620 <HAL_DMA_PollForTransfer+0x13c>
  {
    /* Polling mode not supported in circular mode and double buffering mode */
    if ((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_CIRC) != 0U)
240035ce:	68fb      	ldr	r3, [r7, #12]
240035d0:	681b      	ldr	r3, [r3, #0]
240035d2:	681b      	ldr	r3, [r3, #0]
240035d4:	f403 7380 	and.w	r3, r3, #256	; 0x100
240035d8:	2b00      	cmp	r3, #0
240035da:	d005      	beq.n	240035e8 <HAL_DMA_PollForTransfer+0x104>
    {
      hdma->ErrorCode = HAL_DMA_ERROR_NOT_SUPPORTED;
240035dc:	68fb      	ldr	r3, [r7, #12]
240035de:	f44f 7280 	mov.w	r2, #256	; 0x100
240035e2:	655a      	str	r2, [r3, #84]	; 0x54
      return HAL_ERROR;
240035e4:	2301      	movs	r3, #1
240035e6:	e302      	b.n	24003bee <HAL_DMA_PollForTransfer+0x70a>
    }

    /* Get the level transfer complete flag */
    if(CompleteLevel == HAL_DMA_FULL_TRANSFER)
240035e8:	7afb      	ldrb	r3, [r7, #11]
240035ea:	2b00      	cmp	r3, #0
240035ec:	d108      	bne.n	24003600 <HAL_DMA_PollForTransfer+0x11c>
    {
      /* Transfer Complete flag */
      cpltlevel_mask = DMA_FLAG_TCIF0_4 << (hdma->StreamIndex & 0x1FU);
240035ee:	68fb      	ldr	r3, [r7, #12]
240035f0:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
240035f2:	f003 031f 	and.w	r3, r3, #31
240035f6:	2220      	movs	r2, #32
240035f8:	fa02 f303 	lsl.w	r3, r2, r3
240035fc:	627b      	str	r3, [r7, #36]	; 0x24
240035fe:	e007      	b.n	24003610 <HAL_DMA_PollForTransfer+0x12c>
    }
    else
    {
      /* Half Transfer Complete flag */
      cpltlevel_mask = DMA_FLAG_HTIF0_4 << (hdma->StreamIndex & 0x1FU);
24003600:	68fb      	ldr	r3, [r7, #12]
24003602:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24003604:	f003 031f 	and.w	r3, r3, #31
24003608:	2210      	movs	r2, #16
2400360a:	fa02 f303 	lsl.w	r3, r2, r3
2400360e:	627b      	str	r3, [r7, #36]	; 0x24
    }

    isr_reg  = &(((DMA_Base_Registers *)hdma->StreamBaseAddress)->ISR);
24003610:	68fb      	ldr	r3, [r7, #12]
24003612:	6d9b      	ldr	r3, [r3, #88]	; 0x58
24003614:	623b      	str	r3, [r7, #32]
    ifcr_reg = &(((DMA_Base_Registers *)hdma->StreamBaseAddress)->IFCR);
24003616:	68fb      	ldr	r3, [r7, #12]
24003618:	6d9b      	ldr	r3, [r3, #88]	; 0x58
2400361a:	3308      	adds	r3, #8
2400361c:	61fb      	str	r3, [r7, #28]
2400361e:	e1d5      	b.n	240039cc <HAL_DMA_PollForTransfer+0x4e8>
  }
  else /* BDMA channel */
  {
    /* Polling mode not supported in circular mode */
    if ((((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR & BDMA_CCR_CIRC) != 0U)
24003620:	68fb      	ldr	r3, [r7, #12]
24003622:	681b      	ldr	r3, [r3, #0]
24003624:	681b      	ldr	r3, [r3, #0]
24003626:	f003 0320 	and.w	r3, r3, #32
2400362a:	2b00      	cmp	r3, #0
2400362c:	d005      	beq.n	2400363a <HAL_DMA_PollForTransfer+0x156>
    {
      hdma->ErrorCode = HAL_DMA_ERROR_NOT_SUPPORTED;
2400362e:	68fb      	ldr	r3, [r7, #12]
24003630:	f44f 7280 	mov.w	r2, #256	; 0x100
24003634:	655a      	str	r2, [r3, #84]	; 0x54
      return HAL_ERROR;
24003636:	2301      	movs	r3, #1
24003638:	e2d9      	b.n	24003bee <HAL_DMA_PollForTransfer+0x70a>
    }

    /* Get the level transfer complete flag */
    if(CompleteLevel == HAL_DMA_FULL_TRANSFER)
2400363a:	7afb      	ldrb	r3, [r7, #11]
2400363c:	2b00      	cmp	r3, #0
2400363e:	d108      	bne.n	24003652 <HAL_DMA_PollForTransfer+0x16e>
    {
      /* Transfer Complete flag */
      cpltlevel_mask = BDMA_FLAG_TC0 << (hdma->StreamIndex & 0x1FU);
24003640:	68fb      	ldr	r3, [r7, #12]
24003642:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24003644:	f003 031f 	and.w	r3, r3, #31
24003648:	2202      	movs	r2, #2
2400364a:	fa02 f303 	lsl.w	r3, r2, r3
2400364e:	627b      	str	r3, [r7, #36]	; 0x24
24003650:	e007      	b.n	24003662 <HAL_DMA_PollForTransfer+0x17e>
    }
    else
    {
      /* Half Transfer Complete flag */
      cpltlevel_mask = BDMA_FLAG_HT0 << (hdma->StreamIndex & 0x1FU);
24003652:	68fb      	ldr	r3, [r7, #12]
24003654:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24003656:	f003 031f 	and.w	r3, r3, #31
2400365a:	2204      	movs	r2, #4
2400365c:	fa02 f303 	lsl.w	r3, r2, r3
24003660:	627b      	str	r3, [r7, #36]	; 0x24
    }

    isr_reg  = &(((BDMA_Base_Registers *)hdma->StreamBaseAddress)->ISR);
24003662:	68fb      	ldr	r3, [r7, #12]
24003664:	6d9b      	ldr	r3, [r3, #88]	; 0x58
24003666:	623b      	str	r3, [r7, #32]
    ifcr_reg = &(((BDMA_Base_Registers *)hdma->StreamBaseAddress)->IFCR);
24003668:	68fb      	ldr	r3, [r7, #12]
2400366a:	6d9b      	ldr	r3, [r3, #88]	; 0x58
2400366c:	3304      	adds	r3, #4
2400366e:	61fb      	str	r3, [r7, #28]
  }

  while(((*isr_reg) & cpltlevel_mask) == 0U)
24003670:	e1ac      	b.n	240039cc <HAL_DMA_PollForTransfer+0x4e8>
  {
    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
24003672:	68fb      	ldr	r3, [r7, #12]
24003674:	681b      	ldr	r3, [r3, #0]
24003676:	4a28      	ldr	r2, [pc, #160]	; (24003718 <HAL_DMA_PollForTransfer+0x234>)
24003678:	4293      	cmp	r3, r2
2400367a:	d04a      	beq.n	24003712 <HAL_DMA_PollForTransfer+0x22e>
2400367c:	68fb      	ldr	r3, [r7, #12]
2400367e:	681b      	ldr	r3, [r3, #0]
24003680:	4a26      	ldr	r2, [pc, #152]	; (2400371c <HAL_DMA_PollForTransfer+0x238>)
24003682:	4293      	cmp	r3, r2
24003684:	d045      	beq.n	24003712 <HAL_DMA_PollForTransfer+0x22e>
24003686:	68fb      	ldr	r3, [r7, #12]
24003688:	681b      	ldr	r3, [r3, #0]
2400368a:	4a25      	ldr	r2, [pc, #148]	; (24003720 <HAL_DMA_PollForTransfer+0x23c>)
2400368c:	4293      	cmp	r3, r2
2400368e:	d040      	beq.n	24003712 <HAL_DMA_PollForTransfer+0x22e>
24003690:	68fb      	ldr	r3, [r7, #12]
24003692:	681b      	ldr	r3, [r3, #0]
24003694:	4a23      	ldr	r2, [pc, #140]	; (24003724 <HAL_DMA_PollForTransfer+0x240>)
24003696:	4293      	cmp	r3, r2
24003698:	d03b      	beq.n	24003712 <HAL_DMA_PollForTransfer+0x22e>
2400369a:	68fb      	ldr	r3, [r7, #12]
2400369c:	681b      	ldr	r3, [r3, #0]
2400369e:	4a22      	ldr	r2, [pc, #136]	; (24003728 <HAL_DMA_PollForTransfer+0x244>)
240036a0:	4293      	cmp	r3, r2
240036a2:	d036      	beq.n	24003712 <HAL_DMA_PollForTransfer+0x22e>
240036a4:	68fb      	ldr	r3, [r7, #12]
240036a6:	681b      	ldr	r3, [r3, #0]
240036a8:	4a20      	ldr	r2, [pc, #128]	; (2400372c <HAL_DMA_PollForTransfer+0x248>)
240036aa:	4293      	cmp	r3, r2
240036ac:	d031      	beq.n	24003712 <HAL_DMA_PollForTransfer+0x22e>
240036ae:	68fb      	ldr	r3, [r7, #12]
240036b0:	681b      	ldr	r3, [r3, #0]
240036b2:	4a1f      	ldr	r2, [pc, #124]	; (24003730 <HAL_DMA_PollForTransfer+0x24c>)
240036b4:	4293      	cmp	r3, r2
240036b6:	d02c      	beq.n	24003712 <HAL_DMA_PollForTransfer+0x22e>
240036b8:	68fb      	ldr	r3, [r7, #12]
240036ba:	681b      	ldr	r3, [r3, #0]
240036bc:	4a1d      	ldr	r2, [pc, #116]	; (24003734 <HAL_DMA_PollForTransfer+0x250>)
240036be:	4293      	cmp	r3, r2
240036c0:	d027      	beq.n	24003712 <HAL_DMA_PollForTransfer+0x22e>
240036c2:	68fb      	ldr	r3, [r7, #12]
240036c4:	681b      	ldr	r3, [r3, #0]
240036c6:	4a1c      	ldr	r2, [pc, #112]	; (24003738 <HAL_DMA_PollForTransfer+0x254>)
240036c8:	4293      	cmp	r3, r2
240036ca:	d022      	beq.n	24003712 <HAL_DMA_PollForTransfer+0x22e>
240036cc:	68fb      	ldr	r3, [r7, #12]
240036ce:	681b      	ldr	r3, [r3, #0]
240036d0:	4a1a      	ldr	r2, [pc, #104]	; (2400373c <HAL_DMA_PollForTransfer+0x258>)
240036d2:	4293      	cmp	r3, r2
240036d4:	d01d      	beq.n	24003712 <HAL_DMA_PollForTransfer+0x22e>
240036d6:	68fb      	ldr	r3, [r7, #12]
240036d8:	681b      	ldr	r3, [r3, #0]
240036da:	4a19      	ldr	r2, [pc, #100]	; (24003740 <HAL_DMA_PollForTransfer+0x25c>)
240036dc:	4293      	cmp	r3, r2
240036de:	d018      	beq.n	24003712 <HAL_DMA_PollForTransfer+0x22e>
240036e0:	68fb      	ldr	r3, [r7, #12]
240036e2:	681b      	ldr	r3, [r3, #0]
240036e4:	4a17      	ldr	r2, [pc, #92]	; (24003744 <HAL_DMA_PollForTransfer+0x260>)
240036e6:	4293      	cmp	r3, r2
240036e8:	d013      	beq.n	24003712 <HAL_DMA_PollForTransfer+0x22e>
240036ea:	68fb      	ldr	r3, [r7, #12]
240036ec:	681b      	ldr	r3, [r3, #0]
240036ee:	4a16      	ldr	r2, [pc, #88]	; (24003748 <HAL_DMA_PollForTransfer+0x264>)
240036f0:	4293      	cmp	r3, r2
240036f2:	d00e      	beq.n	24003712 <HAL_DMA_PollForTransfer+0x22e>
240036f4:	68fb      	ldr	r3, [r7, #12]
240036f6:	681b      	ldr	r3, [r3, #0]
240036f8:	4a14      	ldr	r2, [pc, #80]	; (2400374c <HAL_DMA_PollForTransfer+0x268>)
240036fa:	4293      	cmp	r3, r2
240036fc:	d009      	beq.n	24003712 <HAL_DMA_PollForTransfer+0x22e>
240036fe:	68fb      	ldr	r3, [r7, #12]
24003700:	681b      	ldr	r3, [r3, #0]
24003702:	4a13      	ldr	r2, [pc, #76]	; (24003750 <HAL_DMA_PollForTransfer+0x26c>)
24003704:	4293      	cmp	r3, r2
24003706:	d004      	beq.n	24003712 <HAL_DMA_PollForTransfer+0x22e>
24003708:	68fb      	ldr	r3, [r7, #12]
2400370a:	681b      	ldr	r3, [r3, #0]
2400370c:	4a11      	ldr	r2, [pc, #68]	; (24003754 <HAL_DMA_PollForTransfer+0x270>)
2400370e:	4293      	cmp	r3, r2
24003710:	d122      	bne.n	24003758 <HAL_DMA_PollForTransfer+0x274>
24003712:	2301      	movs	r3, #1
24003714:	e021      	b.n	2400375a <HAL_DMA_PollForTransfer+0x276>
24003716:	bf00      	nop
24003718:	40020010 	.word	0x40020010
2400371c:	40020028 	.word	0x40020028
24003720:	40020040 	.word	0x40020040
24003724:	40020058 	.word	0x40020058
24003728:	40020070 	.word	0x40020070
2400372c:	40020088 	.word	0x40020088
24003730:	400200a0 	.word	0x400200a0
24003734:	400200b8 	.word	0x400200b8
24003738:	40020410 	.word	0x40020410
2400373c:	40020428 	.word	0x40020428
24003740:	40020440 	.word	0x40020440
24003744:	40020458 	.word	0x40020458
24003748:	40020470 	.word	0x40020470
2400374c:	40020488 	.word	0x40020488
24003750:	400204a0 	.word	0x400204a0
24003754:	400204b8 	.word	0x400204b8
24003758:	2300      	movs	r3, #0
2400375a:	2b00      	cmp	r3, #0
2400375c:	d057      	beq.n	2400380e <HAL_DMA_PollForTransfer+0x32a>
    {
      if(((*isr_reg) & (DMA_FLAG_FEIF0_4 << (hdma->StreamIndex & 0x1FU))) != 0U)
2400375e:	6a3b      	ldr	r3, [r7, #32]
24003760:	681a      	ldr	r2, [r3, #0]
24003762:	68fb      	ldr	r3, [r7, #12]
24003764:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24003766:	f003 031f 	and.w	r3, r3, #31
2400376a:	fa22 f303 	lsr.w	r3, r2, r3
2400376e:	f003 0301 	and.w	r3, r3, #1
24003772:	2b00      	cmp	r3, #0
24003774:	d00d      	beq.n	24003792 <HAL_DMA_PollForTransfer+0x2ae>
      {
        /* Update error code */
        hdma->ErrorCode |= HAL_DMA_ERROR_FE;
24003776:	68fb      	ldr	r3, [r7, #12]
24003778:	6d5b      	ldr	r3, [r3, #84]	; 0x54
2400377a:	f043 0202 	orr.w	r2, r3, #2
2400377e:	68fb      	ldr	r3, [r7, #12]
24003780:	655a      	str	r2, [r3, #84]	; 0x54

        /* Clear the FIFO error flag */
        (*ifcr_reg) = DMA_FLAG_FEIF0_4 << (hdma->StreamIndex & 0x1FU);
24003782:	68fb      	ldr	r3, [r7, #12]
24003784:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24003786:	f003 031f 	and.w	r3, r3, #31
2400378a:	2201      	movs	r2, #1
2400378c:	409a      	lsls	r2, r3
2400378e:	69fb      	ldr	r3, [r7, #28]
24003790:	601a      	str	r2, [r3, #0]
      }

      if(((*isr_reg) & (DMA_FLAG_DMEIF0_4 << (hdma->StreamIndex & 0x1FU))) != 0U)
24003792:	6a3b      	ldr	r3, [r7, #32]
24003794:	681a      	ldr	r2, [r3, #0]
24003796:	68fb      	ldr	r3, [r7, #12]
24003798:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
2400379a:	f003 031f 	and.w	r3, r3, #31
2400379e:	2104      	movs	r1, #4
240037a0:	fa01 f303 	lsl.w	r3, r1, r3
240037a4:	4013      	ands	r3, r2
240037a6:	2b00      	cmp	r3, #0
240037a8:	d00d      	beq.n	240037c6 <HAL_DMA_PollForTransfer+0x2e2>
      {
        /* Update error code */
        hdma->ErrorCode |= HAL_DMA_ERROR_DME;
240037aa:	68fb      	ldr	r3, [r7, #12]
240037ac:	6d5b      	ldr	r3, [r3, #84]	; 0x54
240037ae:	f043 0204 	orr.w	r2, r3, #4
240037b2:	68fb      	ldr	r3, [r7, #12]
240037b4:	655a      	str	r2, [r3, #84]	; 0x54

        /* Clear the Direct Mode error flag */
        (*ifcr_reg) = DMA_FLAG_DMEIF0_4 << (hdma->StreamIndex & 0x1FU);
240037b6:	68fb      	ldr	r3, [r7, #12]
240037b8:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
240037ba:	f003 031f 	and.w	r3, r3, #31
240037be:	2204      	movs	r2, #4
240037c0:	409a      	lsls	r2, r3
240037c2:	69fb      	ldr	r3, [r7, #28]
240037c4:	601a      	str	r2, [r3, #0]
      }

      if(((*isr_reg) & (DMA_FLAG_TEIF0_4 << (hdma->StreamIndex & 0x1FU))) != 0U)
240037c6:	6a3b      	ldr	r3, [r7, #32]
240037c8:	681a      	ldr	r2, [r3, #0]
240037ca:	68fb      	ldr	r3, [r7, #12]
240037cc:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
240037ce:	f003 031f 	and.w	r3, r3, #31
240037d2:	2108      	movs	r1, #8
240037d4:	fa01 f303 	lsl.w	r3, r1, r3
240037d8:	4013      	ands	r3, r2
240037da:	2b00      	cmp	r3, #0
240037dc:	d038      	beq.n	24003850 <HAL_DMA_PollForTransfer+0x36c>
      {
        /* Update error code */
        hdma->ErrorCode |= HAL_DMA_ERROR_TE;
240037de:	68fb      	ldr	r3, [r7, #12]
240037e0:	6d5b      	ldr	r3, [r3, #84]	; 0x54
240037e2:	f043 0201 	orr.w	r2, r3, #1
240037e6:	68fb      	ldr	r3, [r7, #12]
240037e8:	655a      	str	r2, [r3, #84]	; 0x54

        /* Clear the transfer error flag */
        (*ifcr_reg) = DMA_FLAG_TEIF0_4 << (hdma->StreamIndex & 0x1FU);
240037ea:	68fb      	ldr	r3, [r7, #12]
240037ec:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
240037ee:	f003 031f 	and.w	r3, r3, #31
240037f2:	2208      	movs	r2, #8
240037f4:	409a      	lsls	r2, r3
240037f6:	69fb      	ldr	r3, [r7, #28]
240037f8:	601a      	str	r2, [r3, #0]

        /* Change the DMA state */
        hdma->State = HAL_DMA_STATE_READY;
240037fa:	68fb      	ldr	r3, [r7, #12]
240037fc:	2201      	movs	r2, #1
240037fe:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

        /* Process Unlocked */
        __HAL_UNLOCK(hdma);
24003802:	68fb      	ldr	r3, [r7, #12]
24003804:	2200      	movs	r2, #0
24003806:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

        return HAL_ERROR;
2400380a:	2301      	movs	r3, #1
2400380c:	e1ef      	b.n	24003bee <HAL_DMA_PollForTransfer+0x70a>
      }
    }
    else /* BDMA channel */
    {
      if(((*isr_reg) & (BDMA_FLAG_TE0 << (hdma->StreamIndex & 0x1FU))) != 0U)
2400380e:	6a3b      	ldr	r3, [r7, #32]
24003810:	681a      	ldr	r2, [r3, #0]
24003812:	68fb      	ldr	r3, [r7, #12]
24003814:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24003816:	f003 031f 	and.w	r3, r3, #31
2400381a:	2108      	movs	r1, #8
2400381c:	fa01 f303 	lsl.w	r3, r1, r3
24003820:	4013      	ands	r3, r2
24003822:	2b00      	cmp	r3, #0
24003824:	d014      	beq.n	24003850 <HAL_DMA_PollForTransfer+0x36c>
      {
        /* When a DMA transfer error occurs */
        /* A hardware clear of its EN bits is performed */
        /* Clear all flags */
        (*isr_reg) = ((BDMA_ISR_GIF0) << (hdma->StreamIndex & 0x1FU));
24003826:	68fb      	ldr	r3, [r7, #12]
24003828:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
2400382a:	f003 031f 	and.w	r3, r3, #31
2400382e:	2201      	movs	r2, #1
24003830:	409a      	lsls	r2, r3
24003832:	6a3b      	ldr	r3, [r7, #32]
24003834:	601a      	str	r2, [r3, #0]

        /* Update error code */
        hdma->ErrorCode = HAL_DMA_ERROR_TE;
24003836:	68fb      	ldr	r3, [r7, #12]
24003838:	2201      	movs	r2, #1
2400383a:	655a      	str	r2, [r3, #84]	; 0x54

        /* Change the DMA state */
        hdma->State = HAL_DMA_STATE_READY;
2400383c:	68fb      	ldr	r3, [r7, #12]
2400383e:	2201      	movs	r2, #1
24003840:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

        /* Process Unlocked */
        __HAL_UNLOCK(hdma);
24003844:	68fb      	ldr	r3, [r7, #12]
24003846:	2200      	movs	r2, #0
24003848:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

        return HAL_ERROR;
2400384c:	2301      	movs	r3, #1
2400384e:	e1ce      	b.n	24003bee <HAL_DMA_PollForTransfer+0x70a>
      }
    }

    /* Check for the Timeout (Not applicable in circular mode)*/
    if(Timeout != HAL_MAX_DELAY)
24003850:	687b      	ldr	r3, [r7, #4]
24003852:	f1b3 3fff 	cmp.w	r3, #4294967295
24003856:	d012      	beq.n	2400387e <HAL_DMA_PollForTransfer+0x39a>
    {
      if(((HAL_GetTick() - tickstart ) > Timeout)||(Timeout == 0U))
24003858:	f7fc fffa 	bl	24000850 <HAL_GetTick>
2400385c:	4602      	mov	r2, r0
2400385e:	697b      	ldr	r3, [r7, #20]
24003860:	1ad3      	subs	r3, r2, r3
24003862:	687a      	ldr	r2, [r7, #4]
24003864:	429a      	cmp	r2, r3
24003866:	d302      	bcc.n	2400386e <HAL_DMA_PollForTransfer+0x38a>
24003868:	687b      	ldr	r3, [r7, #4]
2400386a:	2b00      	cmp	r3, #0
2400386c:	d107      	bne.n	2400387e <HAL_DMA_PollForTransfer+0x39a>
      {
        /* Update error code */
        hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
2400386e:	68fb      	ldr	r3, [r7, #12]
24003870:	2220      	movs	r2, #32
24003872:	655a      	str	r2, [r3, #84]	; 0x54

        /* if timeout then abort the current transfer */
        /* No need to check return value: as in this case we will return HAL_ERROR with HAL_DMA_ERROR_TIMEOUT error code  */
        (void) HAL_DMA_Abort(hdma);
24003874:	68f8      	ldr	r0, [r7, #12]
24003876:	f7ff f8d3 	bl	24002a20 <HAL_DMA_Abort>
              - Clear the transfer error flags
              - Unlock
              - Set the State
          */

        return HAL_ERROR;
2400387a:	2301      	movs	r3, #1
2400387c:	e1b7      	b.n	24003bee <HAL_DMA_PollForTransfer+0x70a>
      }
    }

    if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
2400387e:	68fb      	ldr	r3, [r7, #12]
24003880:	681b      	ldr	r3, [r3, #0]
24003882:	4a8f      	ldr	r2, [pc, #572]	; (24003ac0 <HAL_DMA_PollForTransfer+0x5dc>)
24003884:	4293      	cmp	r3, r2
24003886:	d072      	beq.n	2400396e <HAL_DMA_PollForTransfer+0x48a>
24003888:	68fb      	ldr	r3, [r7, #12]
2400388a:	681b      	ldr	r3, [r3, #0]
2400388c:	4a8d      	ldr	r2, [pc, #564]	; (24003ac4 <HAL_DMA_PollForTransfer+0x5e0>)
2400388e:	4293      	cmp	r3, r2
24003890:	d06d      	beq.n	2400396e <HAL_DMA_PollForTransfer+0x48a>
24003892:	68fb      	ldr	r3, [r7, #12]
24003894:	681b      	ldr	r3, [r3, #0]
24003896:	4a8c      	ldr	r2, [pc, #560]	; (24003ac8 <HAL_DMA_PollForTransfer+0x5e4>)
24003898:	4293      	cmp	r3, r2
2400389a:	d068      	beq.n	2400396e <HAL_DMA_PollForTransfer+0x48a>
2400389c:	68fb      	ldr	r3, [r7, #12]
2400389e:	681b      	ldr	r3, [r3, #0]
240038a0:	4a8a      	ldr	r2, [pc, #552]	; (24003acc <HAL_DMA_PollForTransfer+0x5e8>)
240038a2:	4293      	cmp	r3, r2
240038a4:	d063      	beq.n	2400396e <HAL_DMA_PollForTransfer+0x48a>
240038a6:	68fb      	ldr	r3, [r7, #12]
240038a8:	681b      	ldr	r3, [r3, #0]
240038aa:	4a89      	ldr	r2, [pc, #548]	; (24003ad0 <HAL_DMA_PollForTransfer+0x5ec>)
240038ac:	4293      	cmp	r3, r2
240038ae:	d05e      	beq.n	2400396e <HAL_DMA_PollForTransfer+0x48a>
240038b0:	68fb      	ldr	r3, [r7, #12]
240038b2:	681b      	ldr	r3, [r3, #0]
240038b4:	4a87      	ldr	r2, [pc, #540]	; (24003ad4 <HAL_DMA_PollForTransfer+0x5f0>)
240038b6:	4293      	cmp	r3, r2
240038b8:	d059      	beq.n	2400396e <HAL_DMA_PollForTransfer+0x48a>
240038ba:	68fb      	ldr	r3, [r7, #12]
240038bc:	681b      	ldr	r3, [r3, #0]
240038be:	4a86      	ldr	r2, [pc, #536]	; (24003ad8 <HAL_DMA_PollForTransfer+0x5f4>)
240038c0:	4293      	cmp	r3, r2
240038c2:	d054      	beq.n	2400396e <HAL_DMA_PollForTransfer+0x48a>
240038c4:	68fb      	ldr	r3, [r7, #12]
240038c6:	681b      	ldr	r3, [r3, #0]
240038c8:	4a84      	ldr	r2, [pc, #528]	; (24003adc <HAL_DMA_PollForTransfer+0x5f8>)
240038ca:	4293      	cmp	r3, r2
240038cc:	d04f      	beq.n	2400396e <HAL_DMA_PollForTransfer+0x48a>
240038ce:	68fb      	ldr	r3, [r7, #12]
240038d0:	681b      	ldr	r3, [r3, #0]
240038d2:	4a83      	ldr	r2, [pc, #524]	; (24003ae0 <HAL_DMA_PollForTransfer+0x5fc>)
240038d4:	4293      	cmp	r3, r2
240038d6:	d04a      	beq.n	2400396e <HAL_DMA_PollForTransfer+0x48a>
240038d8:	68fb      	ldr	r3, [r7, #12]
240038da:	681b      	ldr	r3, [r3, #0]
240038dc:	4a81      	ldr	r2, [pc, #516]	; (24003ae4 <HAL_DMA_PollForTransfer+0x600>)
240038de:	4293      	cmp	r3, r2
240038e0:	d045      	beq.n	2400396e <HAL_DMA_PollForTransfer+0x48a>
240038e2:	68fb      	ldr	r3, [r7, #12]
240038e4:	681b      	ldr	r3, [r3, #0]
240038e6:	4a80      	ldr	r2, [pc, #512]	; (24003ae8 <HAL_DMA_PollForTransfer+0x604>)
240038e8:	4293      	cmp	r3, r2
240038ea:	d040      	beq.n	2400396e <HAL_DMA_PollForTransfer+0x48a>
240038ec:	68fb      	ldr	r3, [r7, #12]
240038ee:	681b      	ldr	r3, [r3, #0]
240038f0:	4a7e      	ldr	r2, [pc, #504]	; (24003aec <HAL_DMA_PollForTransfer+0x608>)
240038f2:	4293      	cmp	r3, r2
240038f4:	d03b      	beq.n	2400396e <HAL_DMA_PollForTransfer+0x48a>
240038f6:	68fb      	ldr	r3, [r7, #12]
240038f8:	681b      	ldr	r3, [r3, #0]
240038fa:	4a7d      	ldr	r2, [pc, #500]	; (24003af0 <HAL_DMA_PollForTransfer+0x60c>)
240038fc:	4293      	cmp	r3, r2
240038fe:	d036      	beq.n	2400396e <HAL_DMA_PollForTransfer+0x48a>
24003900:	68fb      	ldr	r3, [r7, #12]
24003902:	681b      	ldr	r3, [r3, #0]
24003904:	4a7b      	ldr	r2, [pc, #492]	; (24003af4 <HAL_DMA_PollForTransfer+0x610>)
24003906:	4293      	cmp	r3, r2
24003908:	d031      	beq.n	2400396e <HAL_DMA_PollForTransfer+0x48a>
2400390a:	68fb      	ldr	r3, [r7, #12]
2400390c:	681b      	ldr	r3, [r3, #0]
2400390e:	4a7a      	ldr	r2, [pc, #488]	; (24003af8 <HAL_DMA_PollForTransfer+0x614>)
24003910:	4293      	cmp	r3, r2
24003912:	d02c      	beq.n	2400396e <HAL_DMA_PollForTransfer+0x48a>
24003914:	68fb      	ldr	r3, [r7, #12]
24003916:	681b      	ldr	r3, [r3, #0]
24003918:	4a78      	ldr	r2, [pc, #480]	; (24003afc <HAL_DMA_PollForTransfer+0x618>)
2400391a:	4293      	cmp	r3, r2
2400391c:	d027      	beq.n	2400396e <HAL_DMA_PollForTransfer+0x48a>
2400391e:	68fb      	ldr	r3, [r7, #12]
24003920:	681b      	ldr	r3, [r3, #0]
24003922:	4a77      	ldr	r2, [pc, #476]	; (24003b00 <HAL_DMA_PollForTransfer+0x61c>)
24003924:	4293      	cmp	r3, r2
24003926:	d022      	beq.n	2400396e <HAL_DMA_PollForTransfer+0x48a>
24003928:	68fb      	ldr	r3, [r7, #12]
2400392a:	681b      	ldr	r3, [r3, #0]
2400392c:	4a75      	ldr	r2, [pc, #468]	; (24003b04 <HAL_DMA_PollForTransfer+0x620>)
2400392e:	4293      	cmp	r3, r2
24003930:	d01d      	beq.n	2400396e <HAL_DMA_PollForTransfer+0x48a>
24003932:	68fb      	ldr	r3, [r7, #12]
24003934:	681b      	ldr	r3, [r3, #0]
24003936:	4a74      	ldr	r2, [pc, #464]	; (24003b08 <HAL_DMA_PollForTransfer+0x624>)
24003938:	4293      	cmp	r3, r2
2400393a:	d018      	beq.n	2400396e <HAL_DMA_PollForTransfer+0x48a>
2400393c:	68fb      	ldr	r3, [r7, #12]
2400393e:	681b      	ldr	r3, [r3, #0]
24003940:	4a72      	ldr	r2, [pc, #456]	; (24003b0c <HAL_DMA_PollForTransfer+0x628>)
24003942:	4293      	cmp	r3, r2
24003944:	d013      	beq.n	2400396e <HAL_DMA_PollForTransfer+0x48a>
24003946:	68fb      	ldr	r3, [r7, #12]
24003948:	681b      	ldr	r3, [r3, #0]
2400394a:	4a71      	ldr	r2, [pc, #452]	; (24003b10 <HAL_DMA_PollForTransfer+0x62c>)
2400394c:	4293      	cmp	r3, r2
2400394e:	d00e      	beq.n	2400396e <HAL_DMA_PollForTransfer+0x48a>
24003950:	68fb      	ldr	r3, [r7, #12]
24003952:	681b      	ldr	r3, [r3, #0]
24003954:	4a6f      	ldr	r2, [pc, #444]	; (24003b14 <HAL_DMA_PollForTransfer+0x630>)
24003956:	4293      	cmp	r3, r2
24003958:	d009      	beq.n	2400396e <HAL_DMA_PollForTransfer+0x48a>
2400395a:	68fb      	ldr	r3, [r7, #12]
2400395c:	681b      	ldr	r3, [r3, #0]
2400395e:	4a6e      	ldr	r2, [pc, #440]	; (24003b18 <HAL_DMA_PollForTransfer+0x634>)
24003960:	4293      	cmp	r3, r2
24003962:	d004      	beq.n	2400396e <HAL_DMA_PollForTransfer+0x48a>
24003964:	68fb      	ldr	r3, [r7, #12]
24003966:	681b      	ldr	r3, [r3, #0]
24003968:	4a6c      	ldr	r2, [pc, #432]	; (24003b1c <HAL_DMA_PollForTransfer+0x638>)
2400396a:	4293      	cmp	r3, r2
2400396c:	d101      	bne.n	24003972 <HAL_DMA_PollForTransfer+0x48e>
2400396e:	2301      	movs	r3, #1
24003970:	e000      	b.n	24003974 <HAL_DMA_PollForTransfer+0x490>
24003972:	2300      	movs	r3, #0
24003974:	2b00      	cmp	r3, #0
24003976:	d029      	beq.n	240039cc <HAL_DMA_PollForTransfer+0x4e8>
    {
      /* Check for DMAMUX Request generator (if used) overrun status */
      if(hdma->DMAmuxRequestGen != 0U)
24003978:	68fb      	ldr	r3, [r7, #12]
2400397a:	6edb      	ldr	r3, [r3, #108]	; 0x6c
2400397c:	2b00      	cmp	r3, #0
2400397e:	d012      	beq.n	240039a6 <HAL_DMA_PollForTransfer+0x4c2>
      {
        /* if using DMAMUX request generator Check for DMAMUX request generator overrun */
        if((hdma->DMAmuxRequestGenStatus->RGSR & hdma->DMAmuxRequestGenStatusMask) != 0U)
24003980:	68fb      	ldr	r3, [r7, #12]
24003982:	6f1b      	ldr	r3, [r3, #112]	; 0x70
24003984:	681a      	ldr	r2, [r3, #0]
24003986:	68fb      	ldr	r3, [r7, #12]
24003988:	6f5b      	ldr	r3, [r3, #116]	; 0x74
2400398a:	4013      	ands	r3, r2
2400398c:	2b00      	cmp	r3, #0
2400398e:	d00a      	beq.n	240039a6 <HAL_DMA_PollForTransfer+0x4c2>
        {
          /* Clear the DMAMUX request generator overrun flag */
          hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
24003990:	68fb      	ldr	r3, [r7, #12]
24003992:	6f1b      	ldr	r3, [r3, #112]	; 0x70
24003994:	68fa      	ldr	r2, [r7, #12]
24003996:	6f52      	ldr	r2, [r2, #116]	; 0x74
24003998:	605a      	str	r2, [r3, #4]

          /* Update error code */
          hdma->ErrorCode |= HAL_DMA_ERROR_REQGEN;
2400399a:	68fb      	ldr	r3, [r7, #12]
2400399c:	6d5b      	ldr	r3, [r3, #84]	; 0x54
2400399e:	f443 6280 	orr.w	r2, r3, #1024	; 0x400
240039a2:	68fb      	ldr	r3, [r7, #12]
240039a4:	655a      	str	r2, [r3, #84]	; 0x54
        }
      }

      /* Check for DMAMUX Synchronization overrun */
      if((hdma->DMAmuxChannelStatus->CSR & hdma->DMAmuxChannelStatusMask) != 0U)
240039a6:	68fb      	ldr	r3, [r7, #12]
240039a8:	6e5b      	ldr	r3, [r3, #100]	; 0x64
240039aa:	681a      	ldr	r2, [r3, #0]
240039ac:	68fb      	ldr	r3, [r7, #12]
240039ae:	6e9b      	ldr	r3, [r3, #104]	; 0x68
240039b0:	4013      	ands	r3, r2
240039b2:	2b00      	cmp	r3, #0
240039b4:	d00a      	beq.n	240039cc <HAL_DMA_PollForTransfer+0x4e8>
      {
        /* Clear the DMAMUX synchro overrun flag */
        hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
240039b6:	68fb      	ldr	r3, [r7, #12]
240039b8:	6e5b      	ldr	r3, [r3, #100]	; 0x64
240039ba:	68fa      	ldr	r2, [r7, #12]
240039bc:	6e92      	ldr	r2, [r2, #104]	; 0x68
240039be:	605a      	str	r2, [r3, #4]

        /* Update error code */
        hdma->ErrorCode |= HAL_DMA_ERROR_SYNC;
240039c0:	68fb      	ldr	r3, [r7, #12]
240039c2:	6d5b      	ldr	r3, [r3, #84]	; 0x54
240039c4:	f443 7200 	orr.w	r2, r3, #512	; 0x200
240039c8:	68fb      	ldr	r3, [r7, #12]
240039ca:	655a      	str	r2, [r3, #84]	; 0x54
  while(((*isr_reg) & cpltlevel_mask) == 0U)
240039cc:	6a3b      	ldr	r3, [r7, #32]
240039ce:	681a      	ldr	r2, [r3, #0]
240039d0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
240039d2:	4013      	ands	r3, r2
240039d4:	2b00      	cmp	r3, #0
240039d6:	f43f ae4c 	beq.w	24003672 <HAL_DMA_PollForTransfer+0x18e>
    }
  }


  /* Get the level transfer complete flag */
  if(CompleteLevel == HAL_DMA_FULL_TRANSFER)
240039da:	7afb      	ldrb	r3, [r7, #11]
240039dc:	2b00      	cmp	r3, #0
240039de:	f040 809f 	bne.w	24003b20 <HAL_DMA_PollForTransfer+0x63c>
  {
    /* Clear the half transfer and transfer complete flags */
    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
240039e2:	68fb      	ldr	r3, [r7, #12]
240039e4:	681b      	ldr	r3, [r3, #0]
240039e6:	4a36      	ldr	r2, [pc, #216]	; (24003ac0 <HAL_DMA_PollForTransfer+0x5dc>)
240039e8:	4293      	cmp	r3, r2
240039ea:	d04a      	beq.n	24003a82 <HAL_DMA_PollForTransfer+0x59e>
240039ec:	68fb      	ldr	r3, [r7, #12]
240039ee:	681b      	ldr	r3, [r3, #0]
240039f0:	4a34      	ldr	r2, [pc, #208]	; (24003ac4 <HAL_DMA_PollForTransfer+0x5e0>)
240039f2:	4293      	cmp	r3, r2
240039f4:	d045      	beq.n	24003a82 <HAL_DMA_PollForTransfer+0x59e>
240039f6:	68fb      	ldr	r3, [r7, #12]
240039f8:	681b      	ldr	r3, [r3, #0]
240039fa:	4a33      	ldr	r2, [pc, #204]	; (24003ac8 <HAL_DMA_PollForTransfer+0x5e4>)
240039fc:	4293      	cmp	r3, r2
240039fe:	d040      	beq.n	24003a82 <HAL_DMA_PollForTransfer+0x59e>
24003a00:	68fb      	ldr	r3, [r7, #12]
24003a02:	681b      	ldr	r3, [r3, #0]
24003a04:	4a31      	ldr	r2, [pc, #196]	; (24003acc <HAL_DMA_PollForTransfer+0x5e8>)
24003a06:	4293      	cmp	r3, r2
24003a08:	d03b      	beq.n	24003a82 <HAL_DMA_PollForTransfer+0x59e>
24003a0a:	68fb      	ldr	r3, [r7, #12]
24003a0c:	681b      	ldr	r3, [r3, #0]
24003a0e:	4a30      	ldr	r2, [pc, #192]	; (24003ad0 <HAL_DMA_PollForTransfer+0x5ec>)
24003a10:	4293      	cmp	r3, r2
24003a12:	d036      	beq.n	24003a82 <HAL_DMA_PollForTransfer+0x59e>
24003a14:	68fb      	ldr	r3, [r7, #12]
24003a16:	681b      	ldr	r3, [r3, #0]
24003a18:	4a2e      	ldr	r2, [pc, #184]	; (24003ad4 <HAL_DMA_PollForTransfer+0x5f0>)
24003a1a:	4293      	cmp	r3, r2
24003a1c:	d031      	beq.n	24003a82 <HAL_DMA_PollForTransfer+0x59e>
24003a1e:	68fb      	ldr	r3, [r7, #12]
24003a20:	681b      	ldr	r3, [r3, #0]
24003a22:	4a2d      	ldr	r2, [pc, #180]	; (24003ad8 <HAL_DMA_PollForTransfer+0x5f4>)
24003a24:	4293      	cmp	r3, r2
24003a26:	d02c      	beq.n	24003a82 <HAL_DMA_PollForTransfer+0x59e>
24003a28:	68fb      	ldr	r3, [r7, #12]
24003a2a:	681b      	ldr	r3, [r3, #0]
24003a2c:	4a2b      	ldr	r2, [pc, #172]	; (24003adc <HAL_DMA_PollForTransfer+0x5f8>)
24003a2e:	4293      	cmp	r3, r2
24003a30:	d027      	beq.n	24003a82 <HAL_DMA_PollForTransfer+0x59e>
24003a32:	68fb      	ldr	r3, [r7, #12]
24003a34:	681b      	ldr	r3, [r3, #0]
24003a36:	4a2a      	ldr	r2, [pc, #168]	; (24003ae0 <HAL_DMA_PollForTransfer+0x5fc>)
24003a38:	4293      	cmp	r3, r2
24003a3a:	d022      	beq.n	24003a82 <HAL_DMA_PollForTransfer+0x59e>
24003a3c:	68fb      	ldr	r3, [r7, #12]
24003a3e:	681b      	ldr	r3, [r3, #0]
24003a40:	4a28      	ldr	r2, [pc, #160]	; (24003ae4 <HAL_DMA_PollForTransfer+0x600>)
24003a42:	4293      	cmp	r3, r2
24003a44:	d01d      	beq.n	24003a82 <HAL_DMA_PollForTransfer+0x59e>
24003a46:	68fb      	ldr	r3, [r7, #12]
24003a48:	681b      	ldr	r3, [r3, #0]
24003a4a:	4a27      	ldr	r2, [pc, #156]	; (24003ae8 <HAL_DMA_PollForTransfer+0x604>)
24003a4c:	4293      	cmp	r3, r2
24003a4e:	d018      	beq.n	24003a82 <HAL_DMA_PollForTransfer+0x59e>
24003a50:	68fb      	ldr	r3, [r7, #12]
24003a52:	681b      	ldr	r3, [r3, #0]
24003a54:	4a25      	ldr	r2, [pc, #148]	; (24003aec <HAL_DMA_PollForTransfer+0x608>)
24003a56:	4293      	cmp	r3, r2
24003a58:	d013      	beq.n	24003a82 <HAL_DMA_PollForTransfer+0x59e>
24003a5a:	68fb      	ldr	r3, [r7, #12]
24003a5c:	681b      	ldr	r3, [r3, #0]
24003a5e:	4a24      	ldr	r2, [pc, #144]	; (24003af0 <HAL_DMA_PollForTransfer+0x60c>)
24003a60:	4293      	cmp	r3, r2
24003a62:	d00e      	beq.n	24003a82 <HAL_DMA_PollForTransfer+0x59e>
24003a64:	68fb      	ldr	r3, [r7, #12]
24003a66:	681b      	ldr	r3, [r3, #0]
24003a68:	4a22      	ldr	r2, [pc, #136]	; (24003af4 <HAL_DMA_PollForTransfer+0x610>)
24003a6a:	4293      	cmp	r3, r2
24003a6c:	d009      	beq.n	24003a82 <HAL_DMA_PollForTransfer+0x59e>
24003a6e:	68fb      	ldr	r3, [r7, #12]
24003a70:	681b      	ldr	r3, [r3, #0]
24003a72:	4a21      	ldr	r2, [pc, #132]	; (24003af8 <HAL_DMA_PollForTransfer+0x614>)
24003a74:	4293      	cmp	r3, r2
24003a76:	d004      	beq.n	24003a82 <HAL_DMA_PollForTransfer+0x59e>
24003a78:	68fb      	ldr	r3, [r7, #12]
24003a7a:	681b      	ldr	r3, [r3, #0]
24003a7c:	4a1f      	ldr	r2, [pc, #124]	; (24003afc <HAL_DMA_PollForTransfer+0x618>)
24003a7e:	4293      	cmp	r3, r2
24003a80:	d101      	bne.n	24003a86 <HAL_DMA_PollForTransfer+0x5a2>
24003a82:	2301      	movs	r3, #1
24003a84:	e000      	b.n	24003a88 <HAL_DMA_PollForTransfer+0x5a4>
24003a86:	2300      	movs	r3, #0
24003a88:	2b00      	cmp	r3, #0
24003a8a:	d008      	beq.n	24003a9e <HAL_DMA_PollForTransfer+0x5ba>
    {
      (*ifcr_reg) = (DMA_FLAG_HTIF0_4 | DMA_FLAG_TCIF0_4) << (hdma->StreamIndex & 0x1FU);
24003a8c:	68fb      	ldr	r3, [r7, #12]
24003a8e:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24003a90:	f003 031f 	and.w	r3, r3, #31
24003a94:	2230      	movs	r2, #48	; 0x30
24003a96:	409a      	lsls	r2, r3
24003a98:	69fb      	ldr	r3, [r7, #28]
24003a9a:	601a      	str	r2, [r3, #0]
24003a9c:	e007      	b.n	24003aae <HAL_DMA_PollForTransfer+0x5ca>
    }
    else /* BDMA channel */
    {
      (*ifcr_reg) = (BDMA_FLAG_TC0 << (hdma->StreamIndex & 0x1FU));
24003a9e:	68fb      	ldr	r3, [r7, #12]
24003aa0:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24003aa2:	f003 031f 	and.w	r3, r3, #31
24003aa6:	2202      	movs	r2, #2
24003aa8:	409a      	lsls	r2, r3
24003aaa:	69fb      	ldr	r3, [r7, #28]
24003aac:	601a      	str	r2, [r3, #0]
    }

    /* Process Unlocked */
    __HAL_UNLOCK(hdma);
24003aae:	68fb      	ldr	r3, [r7, #12]
24003ab0:	2200      	movs	r2, #0
24003ab2:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

    hdma->State = HAL_DMA_STATE_READY;
24003ab6:	68fb      	ldr	r3, [r7, #12]
24003ab8:	2201      	movs	r2, #1
24003aba:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
24003abe:	e095      	b.n	24003bec <HAL_DMA_PollForTransfer+0x708>
24003ac0:	40020010 	.word	0x40020010
24003ac4:	40020028 	.word	0x40020028
24003ac8:	40020040 	.word	0x40020040
24003acc:	40020058 	.word	0x40020058
24003ad0:	40020070 	.word	0x40020070
24003ad4:	40020088 	.word	0x40020088
24003ad8:	400200a0 	.word	0x400200a0
24003adc:	400200b8 	.word	0x400200b8
24003ae0:	40020410 	.word	0x40020410
24003ae4:	40020428 	.word	0x40020428
24003ae8:	40020440 	.word	0x40020440
24003aec:	40020458 	.word	0x40020458
24003af0:	40020470 	.word	0x40020470
24003af4:	40020488 	.word	0x40020488
24003af8:	400204a0 	.word	0x400204a0
24003afc:	400204b8 	.word	0x400204b8
24003b00:	58025408 	.word	0x58025408
24003b04:	5802541c 	.word	0x5802541c
24003b08:	58025430 	.word	0x58025430
24003b0c:	58025444 	.word	0x58025444
24003b10:	58025458 	.word	0x58025458
24003b14:	5802546c 	.word	0x5802546c
24003b18:	58025480 	.word	0x58025480
24003b1c:	58025494 	.word	0x58025494
  }
  else /*CompleteLevel = HAL_DMA_HALF_TRANSFER*/
  {
    /* Clear the half transfer and transfer complete flags */
    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
24003b20:	68fb      	ldr	r3, [r7, #12]
24003b22:	681b      	ldr	r3, [r3, #0]
24003b24:	4a34      	ldr	r2, [pc, #208]	; (24003bf8 <HAL_DMA_PollForTransfer+0x714>)
24003b26:	4293      	cmp	r3, r2
24003b28:	d04a      	beq.n	24003bc0 <HAL_DMA_PollForTransfer+0x6dc>
24003b2a:	68fb      	ldr	r3, [r7, #12]
24003b2c:	681b      	ldr	r3, [r3, #0]
24003b2e:	4a33      	ldr	r2, [pc, #204]	; (24003bfc <HAL_DMA_PollForTransfer+0x718>)
24003b30:	4293      	cmp	r3, r2
24003b32:	d045      	beq.n	24003bc0 <HAL_DMA_PollForTransfer+0x6dc>
24003b34:	68fb      	ldr	r3, [r7, #12]
24003b36:	681b      	ldr	r3, [r3, #0]
24003b38:	4a31      	ldr	r2, [pc, #196]	; (24003c00 <HAL_DMA_PollForTransfer+0x71c>)
24003b3a:	4293      	cmp	r3, r2
24003b3c:	d040      	beq.n	24003bc0 <HAL_DMA_PollForTransfer+0x6dc>
24003b3e:	68fb      	ldr	r3, [r7, #12]
24003b40:	681b      	ldr	r3, [r3, #0]
24003b42:	4a30      	ldr	r2, [pc, #192]	; (24003c04 <HAL_DMA_PollForTransfer+0x720>)
24003b44:	4293      	cmp	r3, r2
24003b46:	d03b      	beq.n	24003bc0 <HAL_DMA_PollForTransfer+0x6dc>
24003b48:	68fb      	ldr	r3, [r7, #12]
24003b4a:	681b      	ldr	r3, [r3, #0]
24003b4c:	4a2e      	ldr	r2, [pc, #184]	; (24003c08 <HAL_DMA_PollForTransfer+0x724>)
24003b4e:	4293      	cmp	r3, r2
24003b50:	d036      	beq.n	24003bc0 <HAL_DMA_PollForTransfer+0x6dc>
24003b52:	68fb      	ldr	r3, [r7, #12]
24003b54:	681b      	ldr	r3, [r3, #0]
24003b56:	4a2d      	ldr	r2, [pc, #180]	; (24003c0c <HAL_DMA_PollForTransfer+0x728>)
24003b58:	4293      	cmp	r3, r2
24003b5a:	d031      	beq.n	24003bc0 <HAL_DMA_PollForTransfer+0x6dc>
24003b5c:	68fb      	ldr	r3, [r7, #12]
24003b5e:	681b      	ldr	r3, [r3, #0]
24003b60:	4a2b      	ldr	r2, [pc, #172]	; (24003c10 <HAL_DMA_PollForTransfer+0x72c>)
24003b62:	4293      	cmp	r3, r2
24003b64:	d02c      	beq.n	24003bc0 <HAL_DMA_PollForTransfer+0x6dc>
24003b66:	68fb      	ldr	r3, [r7, #12]
24003b68:	681b      	ldr	r3, [r3, #0]
24003b6a:	4a2a      	ldr	r2, [pc, #168]	; (24003c14 <HAL_DMA_PollForTransfer+0x730>)
24003b6c:	4293      	cmp	r3, r2
24003b6e:	d027      	beq.n	24003bc0 <HAL_DMA_PollForTransfer+0x6dc>
24003b70:	68fb      	ldr	r3, [r7, #12]
24003b72:	681b      	ldr	r3, [r3, #0]
24003b74:	4a28      	ldr	r2, [pc, #160]	; (24003c18 <HAL_DMA_PollForTransfer+0x734>)
24003b76:	4293      	cmp	r3, r2
24003b78:	d022      	beq.n	24003bc0 <HAL_DMA_PollForTransfer+0x6dc>
24003b7a:	68fb      	ldr	r3, [r7, #12]
24003b7c:	681b      	ldr	r3, [r3, #0]
24003b7e:	4a27      	ldr	r2, [pc, #156]	; (24003c1c <HAL_DMA_PollForTransfer+0x738>)
24003b80:	4293      	cmp	r3, r2
24003b82:	d01d      	beq.n	24003bc0 <HAL_DMA_PollForTransfer+0x6dc>
24003b84:	68fb      	ldr	r3, [r7, #12]
24003b86:	681b      	ldr	r3, [r3, #0]
24003b88:	4a25      	ldr	r2, [pc, #148]	; (24003c20 <HAL_DMA_PollForTransfer+0x73c>)
24003b8a:	4293      	cmp	r3, r2
24003b8c:	d018      	beq.n	24003bc0 <HAL_DMA_PollForTransfer+0x6dc>
24003b8e:	68fb      	ldr	r3, [r7, #12]
24003b90:	681b      	ldr	r3, [r3, #0]
24003b92:	4a24      	ldr	r2, [pc, #144]	; (24003c24 <HAL_DMA_PollForTransfer+0x740>)
24003b94:	4293      	cmp	r3, r2
24003b96:	d013      	beq.n	24003bc0 <HAL_DMA_PollForTransfer+0x6dc>
24003b98:	68fb      	ldr	r3, [r7, #12]
24003b9a:	681b      	ldr	r3, [r3, #0]
24003b9c:	4a22      	ldr	r2, [pc, #136]	; (24003c28 <HAL_DMA_PollForTransfer+0x744>)
24003b9e:	4293      	cmp	r3, r2
24003ba0:	d00e      	beq.n	24003bc0 <HAL_DMA_PollForTransfer+0x6dc>
24003ba2:	68fb      	ldr	r3, [r7, #12]
24003ba4:	681b      	ldr	r3, [r3, #0]
24003ba6:	4a21      	ldr	r2, [pc, #132]	; (24003c2c <HAL_DMA_PollForTransfer+0x748>)
24003ba8:	4293      	cmp	r3, r2
24003baa:	d009      	beq.n	24003bc0 <HAL_DMA_PollForTransfer+0x6dc>
24003bac:	68fb      	ldr	r3, [r7, #12]
24003bae:	681b      	ldr	r3, [r3, #0]
24003bb0:	4a1f      	ldr	r2, [pc, #124]	; (24003c30 <HAL_DMA_PollForTransfer+0x74c>)
24003bb2:	4293      	cmp	r3, r2
24003bb4:	d004      	beq.n	24003bc0 <HAL_DMA_PollForTransfer+0x6dc>
24003bb6:	68fb      	ldr	r3, [r7, #12]
24003bb8:	681b      	ldr	r3, [r3, #0]
24003bba:	4a1e      	ldr	r2, [pc, #120]	; (24003c34 <HAL_DMA_PollForTransfer+0x750>)
24003bbc:	4293      	cmp	r3, r2
24003bbe:	d101      	bne.n	24003bc4 <HAL_DMA_PollForTransfer+0x6e0>
24003bc0:	2301      	movs	r3, #1
24003bc2:	e000      	b.n	24003bc6 <HAL_DMA_PollForTransfer+0x6e2>
24003bc4:	2300      	movs	r3, #0
24003bc6:	2b00      	cmp	r3, #0
24003bc8:	d008      	beq.n	24003bdc <HAL_DMA_PollForTransfer+0x6f8>
    {
      (*ifcr_reg) = (DMA_FLAG_HTIF0_4) << (hdma->StreamIndex & 0x1FU);
24003bca:	68fb      	ldr	r3, [r7, #12]
24003bcc:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24003bce:	f003 031f 	and.w	r3, r3, #31
24003bd2:	2210      	movs	r2, #16
24003bd4:	409a      	lsls	r2, r3
24003bd6:	69fb      	ldr	r3, [r7, #28]
24003bd8:	601a      	str	r2, [r3, #0]
24003bda:	e007      	b.n	24003bec <HAL_DMA_PollForTransfer+0x708>
    }
    else /* BDMA channel */
    {
      (*ifcr_reg) = (BDMA_FLAG_HT0 << (hdma->StreamIndex & 0x1FU));
24003bdc:	68fb      	ldr	r3, [r7, #12]
24003bde:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24003be0:	f003 031f 	and.w	r3, r3, #31
24003be4:	2204      	movs	r2, #4
24003be6:	409a      	lsls	r2, r3
24003be8:	69fb      	ldr	r3, [r7, #28]
24003bea:	601a      	str	r2, [r3, #0]
    }
  }

  return status;
24003bec:	7efb      	ldrb	r3, [r7, #27]
}
24003bee:	4618      	mov	r0, r3
24003bf0:	3728      	adds	r7, #40	; 0x28
24003bf2:	46bd      	mov	sp, r7
24003bf4:	bd80      	pop	{r7, pc}
24003bf6:	bf00      	nop
24003bf8:	40020010 	.word	0x40020010
24003bfc:	40020028 	.word	0x40020028
24003c00:	40020040 	.word	0x40020040
24003c04:	40020058 	.word	0x40020058
24003c08:	40020070 	.word	0x40020070
24003c0c:	40020088 	.word	0x40020088
24003c10:	400200a0 	.word	0x400200a0
24003c14:	400200b8 	.word	0x400200b8
24003c18:	40020410 	.word	0x40020410
24003c1c:	40020428 	.word	0x40020428
24003c20:	40020440 	.word	0x40020440
24003c24:	40020458 	.word	0x40020458
24003c28:	40020470 	.word	0x40020470
24003c2c:	40020488 	.word	0x40020488
24003c30:	400204a0 	.word	0x400204a0
24003c34:	400204b8 	.word	0x400204b8

24003c38 <HAL_DMA_IRQHandler>:
  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Stream.
  * @retval None
  */
void HAL_DMA_IRQHandler(DMA_HandleTypeDef *hdma)
{
24003c38:	b580      	push	{r7, lr}
24003c3a:	b08a      	sub	sp, #40	; 0x28
24003c3c:	af00      	add	r7, sp, #0
24003c3e:	6078      	str	r0, [r7, #4]
  uint32_t tmpisr_dma, tmpisr_bdma;
  uint32_t ccr_reg;
  __IO uint32_t count = 0U;
24003c40:	2300      	movs	r3, #0
24003c42:	60fb      	str	r3, [r7, #12]
  uint32_t timeout = SystemCoreClock / 9600U;
24003c44:	4b67      	ldr	r3, [pc, #412]	; (24003de4 <HAL_DMA_IRQHandler+0x1ac>)
24003c46:	681b      	ldr	r3, [r3, #0]
24003c48:	4a67      	ldr	r2, [pc, #412]	; (24003de8 <HAL_DMA_IRQHandler+0x1b0>)
24003c4a:	fba2 2303 	umull	r2, r3, r2, r3
24003c4e:	0a9b      	lsrs	r3, r3, #10
24003c50:	627b      	str	r3, [r7, #36]	; 0x24

  /* calculate DMA base and stream number */
  DMA_Base_Registers  *regs_dma  = (DMA_Base_Registers *)hdma->StreamBaseAddress;
24003c52:	687b      	ldr	r3, [r7, #4]
24003c54:	6d9b      	ldr	r3, [r3, #88]	; 0x58
24003c56:	623b      	str	r3, [r7, #32]
  BDMA_Base_Registers *regs_bdma = (BDMA_Base_Registers *)hdma->StreamBaseAddress;
24003c58:	687b      	ldr	r3, [r7, #4]
24003c5a:	6d9b      	ldr	r3, [r3, #88]	; 0x58
24003c5c:	61fb      	str	r3, [r7, #28]

  tmpisr_dma  = regs_dma->ISR;
24003c5e:	6a3b      	ldr	r3, [r7, #32]
24003c60:	681b      	ldr	r3, [r3, #0]
24003c62:	61bb      	str	r3, [r7, #24]
  tmpisr_bdma = regs_bdma->ISR;
24003c64:	69fb      	ldr	r3, [r7, #28]
24003c66:	681b      	ldr	r3, [r3, #0]
24003c68:	617b      	str	r3, [r7, #20]

  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U)  /* DMA1 or DMA2 instance */
24003c6a:	687b      	ldr	r3, [r7, #4]
24003c6c:	681b      	ldr	r3, [r3, #0]
24003c6e:	4a5f      	ldr	r2, [pc, #380]	; (24003dec <HAL_DMA_IRQHandler+0x1b4>)
24003c70:	4293      	cmp	r3, r2
24003c72:	d04a      	beq.n	24003d0a <HAL_DMA_IRQHandler+0xd2>
24003c74:	687b      	ldr	r3, [r7, #4]
24003c76:	681b      	ldr	r3, [r3, #0]
24003c78:	4a5d      	ldr	r2, [pc, #372]	; (24003df0 <HAL_DMA_IRQHandler+0x1b8>)
24003c7a:	4293      	cmp	r3, r2
24003c7c:	d045      	beq.n	24003d0a <HAL_DMA_IRQHandler+0xd2>
24003c7e:	687b      	ldr	r3, [r7, #4]
24003c80:	681b      	ldr	r3, [r3, #0]
24003c82:	4a5c      	ldr	r2, [pc, #368]	; (24003df4 <HAL_DMA_IRQHandler+0x1bc>)
24003c84:	4293      	cmp	r3, r2
24003c86:	d040      	beq.n	24003d0a <HAL_DMA_IRQHandler+0xd2>
24003c88:	687b      	ldr	r3, [r7, #4]
24003c8a:	681b      	ldr	r3, [r3, #0]
24003c8c:	4a5a      	ldr	r2, [pc, #360]	; (24003df8 <HAL_DMA_IRQHandler+0x1c0>)
24003c8e:	4293      	cmp	r3, r2
24003c90:	d03b      	beq.n	24003d0a <HAL_DMA_IRQHandler+0xd2>
24003c92:	687b      	ldr	r3, [r7, #4]
24003c94:	681b      	ldr	r3, [r3, #0]
24003c96:	4a59      	ldr	r2, [pc, #356]	; (24003dfc <HAL_DMA_IRQHandler+0x1c4>)
24003c98:	4293      	cmp	r3, r2
24003c9a:	d036      	beq.n	24003d0a <HAL_DMA_IRQHandler+0xd2>
24003c9c:	687b      	ldr	r3, [r7, #4]
24003c9e:	681b      	ldr	r3, [r3, #0]
24003ca0:	4a57      	ldr	r2, [pc, #348]	; (24003e00 <HAL_DMA_IRQHandler+0x1c8>)
24003ca2:	4293      	cmp	r3, r2
24003ca4:	d031      	beq.n	24003d0a <HAL_DMA_IRQHandler+0xd2>
24003ca6:	687b      	ldr	r3, [r7, #4]
24003ca8:	681b      	ldr	r3, [r3, #0]
24003caa:	4a56      	ldr	r2, [pc, #344]	; (24003e04 <HAL_DMA_IRQHandler+0x1cc>)
24003cac:	4293      	cmp	r3, r2
24003cae:	d02c      	beq.n	24003d0a <HAL_DMA_IRQHandler+0xd2>
24003cb0:	687b      	ldr	r3, [r7, #4]
24003cb2:	681b      	ldr	r3, [r3, #0]
24003cb4:	4a54      	ldr	r2, [pc, #336]	; (24003e08 <HAL_DMA_IRQHandler+0x1d0>)
24003cb6:	4293      	cmp	r3, r2
24003cb8:	d027      	beq.n	24003d0a <HAL_DMA_IRQHandler+0xd2>
24003cba:	687b      	ldr	r3, [r7, #4]
24003cbc:	681b      	ldr	r3, [r3, #0]
24003cbe:	4a53      	ldr	r2, [pc, #332]	; (24003e0c <HAL_DMA_IRQHandler+0x1d4>)
24003cc0:	4293      	cmp	r3, r2
24003cc2:	d022      	beq.n	24003d0a <HAL_DMA_IRQHandler+0xd2>
24003cc4:	687b      	ldr	r3, [r7, #4]
24003cc6:	681b      	ldr	r3, [r3, #0]
24003cc8:	4a51      	ldr	r2, [pc, #324]	; (24003e10 <HAL_DMA_IRQHandler+0x1d8>)
24003cca:	4293      	cmp	r3, r2
24003ccc:	d01d      	beq.n	24003d0a <HAL_DMA_IRQHandler+0xd2>
24003cce:	687b      	ldr	r3, [r7, #4]
24003cd0:	681b      	ldr	r3, [r3, #0]
24003cd2:	4a50      	ldr	r2, [pc, #320]	; (24003e14 <HAL_DMA_IRQHandler+0x1dc>)
24003cd4:	4293      	cmp	r3, r2
24003cd6:	d018      	beq.n	24003d0a <HAL_DMA_IRQHandler+0xd2>
24003cd8:	687b      	ldr	r3, [r7, #4]
24003cda:	681b      	ldr	r3, [r3, #0]
24003cdc:	4a4e      	ldr	r2, [pc, #312]	; (24003e18 <HAL_DMA_IRQHandler+0x1e0>)
24003cde:	4293      	cmp	r3, r2
24003ce0:	d013      	beq.n	24003d0a <HAL_DMA_IRQHandler+0xd2>
24003ce2:	687b      	ldr	r3, [r7, #4]
24003ce4:	681b      	ldr	r3, [r3, #0]
24003ce6:	4a4d      	ldr	r2, [pc, #308]	; (24003e1c <HAL_DMA_IRQHandler+0x1e4>)
24003ce8:	4293      	cmp	r3, r2
24003cea:	d00e      	beq.n	24003d0a <HAL_DMA_IRQHandler+0xd2>
24003cec:	687b      	ldr	r3, [r7, #4]
24003cee:	681b      	ldr	r3, [r3, #0]
24003cf0:	4a4b      	ldr	r2, [pc, #300]	; (24003e20 <HAL_DMA_IRQHandler+0x1e8>)
24003cf2:	4293      	cmp	r3, r2
24003cf4:	d009      	beq.n	24003d0a <HAL_DMA_IRQHandler+0xd2>
24003cf6:	687b      	ldr	r3, [r7, #4]
24003cf8:	681b      	ldr	r3, [r3, #0]
24003cfa:	4a4a      	ldr	r2, [pc, #296]	; (24003e24 <HAL_DMA_IRQHandler+0x1ec>)
24003cfc:	4293      	cmp	r3, r2
24003cfe:	d004      	beq.n	24003d0a <HAL_DMA_IRQHandler+0xd2>
24003d00:	687b      	ldr	r3, [r7, #4]
24003d02:	681b      	ldr	r3, [r3, #0]
24003d04:	4a48      	ldr	r2, [pc, #288]	; (24003e28 <HAL_DMA_IRQHandler+0x1f0>)
24003d06:	4293      	cmp	r3, r2
24003d08:	d101      	bne.n	24003d0e <HAL_DMA_IRQHandler+0xd6>
24003d0a:	2301      	movs	r3, #1
24003d0c:	e000      	b.n	24003d10 <HAL_DMA_IRQHandler+0xd8>
24003d0e:	2300      	movs	r3, #0
24003d10:	2b00      	cmp	r3, #0
24003d12:	f000 842b 	beq.w	2400456c <HAL_DMA_IRQHandler+0x934>
  {
    /* Transfer Error Interrupt management ***************************************/
    if ((tmpisr_dma & (DMA_FLAG_TEIF0_4 << (hdma->StreamIndex & 0x1FU))) != 0U)
24003d16:	687b      	ldr	r3, [r7, #4]
24003d18:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24003d1a:	f003 031f 	and.w	r3, r3, #31
24003d1e:	2208      	movs	r2, #8
24003d20:	409a      	lsls	r2, r3
24003d22:	69bb      	ldr	r3, [r7, #24]
24003d24:	4013      	ands	r3, r2
24003d26:	2b00      	cmp	r3, #0
24003d28:	f000 80a2 	beq.w	24003e70 <HAL_DMA_IRQHandler+0x238>
    {
      if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TE) != 0U)
24003d2c:	687b      	ldr	r3, [r7, #4]
24003d2e:	681b      	ldr	r3, [r3, #0]
24003d30:	4a2e      	ldr	r2, [pc, #184]	; (24003dec <HAL_DMA_IRQHandler+0x1b4>)
24003d32:	4293      	cmp	r3, r2
24003d34:	d04a      	beq.n	24003dcc <HAL_DMA_IRQHandler+0x194>
24003d36:	687b      	ldr	r3, [r7, #4]
24003d38:	681b      	ldr	r3, [r3, #0]
24003d3a:	4a2d      	ldr	r2, [pc, #180]	; (24003df0 <HAL_DMA_IRQHandler+0x1b8>)
24003d3c:	4293      	cmp	r3, r2
24003d3e:	d045      	beq.n	24003dcc <HAL_DMA_IRQHandler+0x194>
24003d40:	687b      	ldr	r3, [r7, #4]
24003d42:	681b      	ldr	r3, [r3, #0]
24003d44:	4a2b      	ldr	r2, [pc, #172]	; (24003df4 <HAL_DMA_IRQHandler+0x1bc>)
24003d46:	4293      	cmp	r3, r2
24003d48:	d040      	beq.n	24003dcc <HAL_DMA_IRQHandler+0x194>
24003d4a:	687b      	ldr	r3, [r7, #4]
24003d4c:	681b      	ldr	r3, [r3, #0]
24003d4e:	4a2a      	ldr	r2, [pc, #168]	; (24003df8 <HAL_DMA_IRQHandler+0x1c0>)
24003d50:	4293      	cmp	r3, r2
24003d52:	d03b      	beq.n	24003dcc <HAL_DMA_IRQHandler+0x194>
24003d54:	687b      	ldr	r3, [r7, #4]
24003d56:	681b      	ldr	r3, [r3, #0]
24003d58:	4a28      	ldr	r2, [pc, #160]	; (24003dfc <HAL_DMA_IRQHandler+0x1c4>)
24003d5a:	4293      	cmp	r3, r2
24003d5c:	d036      	beq.n	24003dcc <HAL_DMA_IRQHandler+0x194>
24003d5e:	687b      	ldr	r3, [r7, #4]
24003d60:	681b      	ldr	r3, [r3, #0]
24003d62:	4a27      	ldr	r2, [pc, #156]	; (24003e00 <HAL_DMA_IRQHandler+0x1c8>)
24003d64:	4293      	cmp	r3, r2
24003d66:	d031      	beq.n	24003dcc <HAL_DMA_IRQHandler+0x194>
24003d68:	687b      	ldr	r3, [r7, #4]
24003d6a:	681b      	ldr	r3, [r3, #0]
24003d6c:	4a25      	ldr	r2, [pc, #148]	; (24003e04 <HAL_DMA_IRQHandler+0x1cc>)
24003d6e:	4293      	cmp	r3, r2
24003d70:	d02c      	beq.n	24003dcc <HAL_DMA_IRQHandler+0x194>
24003d72:	687b      	ldr	r3, [r7, #4]
24003d74:	681b      	ldr	r3, [r3, #0]
24003d76:	4a24      	ldr	r2, [pc, #144]	; (24003e08 <HAL_DMA_IRQHandler+0x1d0>)
24003d78:	4293      	cmp	r3, r2
24003d7a:	d027      	beq.n	24003dcc <HAL_DMA_IRQHandler+0x194>
24003d7c:	687b      	ldr	r3, [r7, #4]
24003d7e:	681b      	ldr	r3, [r3, #0]
24003d80:	4a22      	ldr	r2, [pc, #136]	; (24003e0c <HAL_DMA_IRQHandler+0x1d4>)
24003d82:	4293      	cmp	r3, r2
24003d84:	d022      	beq.n	24003dcc <HAL_DMA_IRQHandler+0x194>
24003d86:	687b      	ldr	r3, [r7, #4]
24003d88:	681b      	ldr	r3, [r3, #0]
24003d8a:	4a21      	ldr	r2, [pc, #132]	; (24003e10 <HAL_DMA_IRQHandler+0x1d8>)
24003d8c:	4293      	cmp	r3, r2
24003d8e:	d01d      	beq.n	24003dcc <HAL_DMA_IRQHandler+0x194>
24003d90:	687b      	ldr	r3, [r7, #4]
24003d92:	681b      	ldr	r3, [r3, #0]
24003d94:	4a1f      	ldr	r2, [pc, #124]	; (24003e14 <HAL_DMA_IRQHandler+0x1dc>)
24003d96:	4293      	cmp	r3, r2
24003d98:	d018      	beq.n	24003dcc <HAL_DMA_IRQHandler+0x194>
24003d9a:	687b      	ldr	r3, [r7, #4]
24003d9c:	681b      	ldr	r3, [r3, #0]
24003d9e:	4a1e      	ldr	r2, [pc, #120]	; (24003e18 <HAL_DMA_IRQHandler+0x1e0>)
24003da0:	4293      	cmp	r3, r2
24003da2:	d013      	beq.n	24003dcc <HAL_DMA_IRQHandler+0x194>
24003da4:	687b      	ldr	r3, [r7, #4]
24003da6:	681b      	ldr	r3, [r3, #0]
24003da8:	4a1c      	ldr	r2, [pc, #112]	; (24003e1c <HAL_DMA_IRQHandler+0x1e4>)
24003daa:	4293      	cmp	r3, r2
24003dac:	d00e      	beq.n	24003dcc <HAL_DMA_IRQHandler+0x194>
24003dae:	687b      	ldr	r3, [r7, #4]
24003db0:	681b      	ldr	r3, [r3, #0]
24003db2:	4a1b      	ldr	r2, [pc, #108]	; (24003e20 <HAL_DMA_IRQHandler+0x1e8>)
24003db4:	4293      	cmp	r3, r2
24003db6:	d009      	beq.n	24003dcc <HAL_DMA_IRQHandler+0x194>
24003db8:	687b      	ldr	r3, [r7, #4]
24003dba:	681b      	ldr	r3, [r3, #0]
24003dbc:	4a19      	ldr	r2, [pc, #100]	; (24003e24 <HAL_DMA_IRQHandler+0x1ec>)
24003dbe:	4293      	cmp	r3, r2
24003dc0:	d004      	beq.n	24003dcc <HAL_DMA_IRQHandler+0x194>
24003dc2:	687b      	ldr	r3, [r7, #4]
24003dc4:	681b      	ldr	r3, [r3, #0]
24003dc6:	4a18      	ldr	r2, [pc, #96]	; (24003e28 <HAL_DMA_IRQHandler+0x1f0>)
24003dc8:	4293      	cmp	r3, r2
24003dca:	d12f      	bne.n	24003e2c <HAL_DMA_IRQHandler+0x1f4>
24003dcc:	687b      	ldr	r3, [r7, #4]
24003dce:	681b      	ldr	r3, [r3, #0]
24003dd0:	681b      	ldr	r3, [r3, #0]
24003dd2:	f003 0304 	and.w	r3, r3, #4
24003dd6:	2b00      	cmp	r3, #0
24003dd8:	bf14      	ite	ne
24003dda:	2301      	movne	r3, #1
24003ddc:	2300      	moveq	r3, #0
24003dde:	b2db      	uxtb	r3, r3
24003de0:	e02e      	b.n	24003e40 <HAL_DMA_IRQHandler+0x208>
24003de2:	bf00      	nop
24003de4:	240004b8 	.word	0x240004b8
24003de8:	1b4e81b5 	.word	0x1b4e81b5
24003dec:	40020010 	.word	0x40020010
24003df0:	40020028 	.word	0x40020028
24003df4:	40020040 	.word	0x40020040
24003df8:	40020058 	.word	0x40020058
24003dfc:	40020070 	.word	0x40020070
24003e00:	40020088 	.word	0x40020088
24003e04:	400200a0 	.word	0x400200a0
24003e08:	400200b8 	.word	0x400200b8
24003e0c:	40020410 	.word	0x40020410
24003e10:	40020428 	.word	0x40020428
24003e14:	40020440 	.word	0x40020440
24003e18:	40020458 	.word	0x40020458
24003e1c:	40020470 	.word	0x40020470
24003e20:	40020488 	.word	0x40020488
24003e24:	400204a0 	.word	0x400204a0
24003e28:	400204b8 	.word	0x400204b8
24003e2c:	687b      	ldr	r3, [r7, #4]
24003e2e:	681b      	ldr	r3, [r3, #0]
24003e30:	681b      	ldr	r3, [r3, #0]
24003e32:	f003 0308 	and.w	r3, r3, #8
24003e36:	2b00      	cmp	r3, #0
24003e38:	bf14      	ite	ne
24003e3a:	2301      	movne	r3, #1
24003e3c:	2300      	moveq	r3, #0
24003e3e:	b2db      	uxtb	r3, r3
24003e40:	2b00      	cmp	r3, #0
24003e42:	d015      	beq.n	24003e70 <HAL_DMA_IRQHandler+0x238>
      {
        /* Disable the transfer error interrupt */
        ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  &= ~(DMA_IT_TE);
24003e44:	687b      	ldr	r3, [r7, #4]
24003e46:	681b      	ldr	r3, [r3, #0]
24003e48:	681a      	ldr	r2, [r3, #0]
24003e4a:	687b      	ldr	r3, [r7, #4]
24003e4c:	681b      	ldr	r3, [r3, #0]
24003e4e:	f022 0204 	bic.w	r2, r2, #4
24003e52:	601a      	str	r2, [r3, #0]

        /* Clear the transfer error flag */
        regs_dma->IFCR = DMA_FLAG_TEIF0_4 << (hdma->StreamIndex & 0x1FU);
24003e54:	687b      	ldr	r3, [r7, #4]
24003e56:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24003e58:	f003 031f 	and.w	r3, r3, #31
24003e5c:	2208      	movs	r2, #8
24003e5e:	409a      	lsls	r2, r3
24003e60:	6a3b      	ldr	r3, [r7, #32]
24003e62:	609a      	str	r2, [r3, #8]

        /* Update error code */
        hdma->ErrorCode |= HAL_DMA_ERROR_TE;
24003e64:	687b      	ldr	r3, [r7, #4]
24003e66:	6d5b      	ldr	r3, [r3, #84]	; 0x54
24003e68:	f043 0201 	orr.w	r2, r3, #1
24003e6c:	687b      	ldr	r3, [r7, #4]
24003e6e:	655a      	str	r2, [r3, #84]	; 0x54
      }
    }
    /* FIFO Error Interrupt management ******************************************/
    if ((tmpisr_dma & (DMA_FLAG_FEIF0_4 << (hdma->StreamIndex & 0x1FU))) != 0U)
24003e70:	687b      	ldr	r3, [r7, #4]
24003e72:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24003e74:	f003 031f 	and.w	r3, r3, #31
24003e78:	69ba      	ldr	r2, [r7, #24]
24003e7a:	fa22 f303 	lsr.w	r3, r2, r3
24003e7e:	f003 0301 	and.w	r3, r3, #1
24003e82:	2b00      	cmp	r3, #0
24003e84:	d06e      	beq.n	24003f64 <HAL_DMA_IRQHandler+0x32c>
    {
      if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_FE) != 0U)
24003e86:	687b      	ldr	r3, [r7, #4]
24003e88:	681b      	ldr	r3, [r3, #0]
24003e8a:	4a69      	ldr	r2, [pc, #420]	; (24004030 <HAL_DMA_IRQHandler+0x3f8>)
24003e8c:	4293      	cmp	r3, r2
24003e8e:	d04a      	beq.n	24003f26 <HAL_DMA_IRQHandler+0x2ee>
24003e90:	687b      	ldr	r3, [r7, #4]
24003e92:	681b      	ldr	r3, [r3, #0]
24003e94:	4a67      	ldr	r2, [pc, #412]	; (24004034 <HAL_DMA_IRQHandler+0x3fc>)
24003e96:	4293      	cmp	r3, r2
24003e98:	d045      	beq.n	24003f26 <HAL_DMA_IRQHandler+0x2ee>
24003e9a:	687b      	ldr	r3, [r7, #4]
24003e9c:	681b      	ldr	r3, [r3, #0]
24003e9e:	4a66      	ldr	r2, [pc, #408]	; (24004038 <HAL_DMA_IRQHandler+0x400>)
24003ea0:	4293      	cmp	r3, r2
24003ea2:	d040      	beq.n	24003f26 <HAL_DMA_IRQHandler+0x2ee>
24003ea4:	687b      	ldr	r3, [r7, #4]
24003ea6:	681b      	ldr	r3, [r3, #0]
24003ea8:	4a64      	ldr	r2, [pc, #400]	; (2400403c <HAL_DMA_IRQHandler+0x404>)
24003eaa:	4293      	cmp	r3, r2
24003eac:	d03b      	beq.n	24003f26 <HAL_DMA_IRQHandler+0x2ee>
24003eae:	687b      	ldr	r3, [r7, #4]
24003eb0:	681b      	ldr	r3, [r3, #0]
24003eb2:	4a63      	ldr	r2, [pc, #396]	; (24004040 <HAL_DMA_IRQHandler+0x408>)
24003eb4:	4293      	cmp	r3, r2
24003eb6:	d036      	beq.n	24003f26 <HAL_DMA_IRQHandler+0x2ee>
24003eb8:	687b      	ldr	r3, [r7, #4]
24003eba:	681b      	ldr	r3, [r3, #0]
24003ebc:	4a61      	ldr	r2, [pc, #388]	; (24004044 <HAL_DMA_IRQHandler+0x40c>)
24003ebe:	4293      	cmp	r3, r2
24003ec0:	d031      	beq.n	24003f26 <HAL_DMA_IRQHandler+0x2ee>
24003ec2:	687b      	ldr	r3, [r7, #4]
24003ec4:	681b      	ldr	r3, [r3, #0]
24003ec6:	4a60      	ldr	r2, [pc, #384]	; (24004048 <HAL_DMA_IRQHandler+0x410>)
24003ec8:	4293      	cmp	r3, r2
24003eca:	d02c      	beq.n	24003f26 <HAL_DMA_IRQHandler+0x2ee>
24003ecc:	687b      	ldr	r3, [r7, #4]
24003ece:	681b      	ldr	r3, [r3, #0]
24003ed0:	4a5e      	ldr	r2, [pc, #376]	; (2400404c <HAL_DMA_IRQHandler+0x414>)
24003ed2:	4293      	cmp	r3, r2
24003ed4:	d027      	beq.n	24003f26 <HAL_DMA_IRQHandler+0x2ee>
24003ed6:	687b      	ldr	r3, [r7, #4]
24003ed8:	681b      	ldr	r3, [r3, #0]
24003eda:	4a5d      	ldr	r2, [pc, #372]	; (24004050 <HAL_DMA_IRQHandler+0x418>)
24003edc:	4293      	cmp	r3, r2
24003ede:	d022      	beq.n	24003f26 <HAL_DMA_IRQHandler+0x2ee>
24003ee0:	687b      	ldr	r3, [r7, #4]
24003ee2:	681b      	ldr	r3, [r3, #0]
24003ee4:	4a5b      	ldr	r2, [pc, #364]	; (24004054 <HAL_DMA_IRQHandler+0x41c>)
24003ee6:	4293      	cmp	r3, r2
24003ee8:	d01d      	beq.n	24003f26 <HAL_DMA_IRQHandler+0x2ee>
24003eea:	687b      	ldr	r3, [r7, #4]
24003eec:	681b      	ldr	r3, [r3, #0]
24003eee:	4a5a      	ldr	r2, [pc, #360]	; (24004058 <HAL_DMA_IRQHandler+0x420>)
24003ef0:	4293      	cmp	r3, r2
24003ef2:	d018      	beq.n	24003f26 <HAL_DMA_IRQHandler+0x2ee>
24003ef4:	687b      	ldr	r3, [r7, #4]
24003ef6:	681b      	ldr	r3, [r3, #0]
24003ef8:	4a58      	ldr	r2, [pc, #352]	; (2400405c <HAL_DMA_IRQHandler+0x424>)
24003efa:	4293      	cmp	r3, r2
24003efc:	d013      	beq.n	24003f26 <HAL_DMA_IRQHandler+0x2ee>
24003efe:	687b      	ldr	r3, [r7, #4]
24003f00:	681b      	ldr	r3, [r3, #0]
24003f02:	4a57      	ldr	r2, [pc, #348]	; (24004060 <HAL_DMA_IRQHandler+0x428>)
24003f04:	4293      	cmp	r3, r2
24003f06:	d00e      	beq.n	24003f26 <HAL_DMA_IRQHandler+0x2ee>
24003f08:	687b      	ldr	r3, [r7, #4]
24003f0a:	681b      	ldr	r3, [r3, #0]
24003f0c:	4a55      	ldr	r2, [pc, #340]	; (24004064 <HAL_DMA_IRQHandler+0x42c>)
24003f0e:	4293      	cmp	r3, r2
24003f10:	d009      	beq.n	24003f26 <HAL_DMA_IRQHandler+0x2ee>
24003f12:	687b      	ldr	r3, [r7, #4]
24003f14:	681b      	ldr	r3, [r3, #0]
24003f16:	4a54      	ldr	r2, [pc, #336]	; (24004068 <HAL_DMA_IRQHandler+0x430>)
24003f18:	4293      	cmp	r3, r2
24003f1a:	d004      	beq.n	24003f26 <HAL_DMA_IRQHandler+0x2ee>
24003f1c:	687b      	ldr	r3, [r7, #4]
24003f1e:	681b      	ldr	r3, [r3, #0]
24003f20:	4a52      	ldr	r2, [pc, #328]	; (2400406c <HAL_DMA_IRQHandler+0x434>)
24003f22:	4293      	cmp	r3, r2
24003f24:	d10a      	bne.n	24003f3c <HAL_DMA_IRQHandler+0x304>
24003f26:	687b      	ldr	r3, [r7, #4]
24003f28:	681b      	ldr	r3, [r3, #0]
24003f2a:	695b      	ldr	r3, [r3, #20]
24003f2c:	f003 0380 	and.w	r3, r3, #128	; 0x80
24003f30:	2b00      	cmp	r3, #0
24003f32:	bf14      	ite	ne
24003f34:	2301      	movne	r3, #1
24003f36:	2300      	moveq	r3, #0
24003f38:	b2db      	uxtb	r3, r3
24003f3a:	e003      	b.n	24003f44 <HAL_DMA_IRQHandler+0x30c>
24003f3c:	687b      	ldr	r3, [r7, #4]
24003f3e:	681b      	ldr	r3, [r3, #0]
24003f40:	681b      	ldr	r3, [r3, #0]
24003f42:	2300      	movs	r3, #0
24003f44:	2b00      	cmp	r3, #0
24003f46:	d00d      	beq.n	24003f64 <HAL_DMA_IRQHandler+0x32c>
      {
        /* Clear the FIFO error flag */
        regs_dma->IFCR = DMA_FLAG_FEIF0_4 << (hdma->StreamIndex & 0x1FU);
24003f48:	687b      	ldr	r3, [r7, #4]
24003f4a:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24003f4c:	f003 031f 	and.w	r3, r3, #31
24003f50:	2201      	movs	r2, #1
24003f52:	409a      	lsls	r2, r3
24003f54:	6a3b      	ldr	r3, [r7, #32]
24003f56:	609a      	str	r2, [r3, #8]

        /* Update error code */
        hdma->ErrorCode |= HAL_DMA_ERROR_FE;
24003f58:	687b      	ldr	r3, [r7, #4]
24003f5a:	6d5b      	ldr	r3, [r3, #84]	; 0x54
24003f5c:	f043 0202 	orr.w	r2, r3, #2
24003f60:	687b      	ldr	r3, [r7, #4]
24003f62:	655a      	str	r2, [r3, #84]	; 0x54
      }
    }
    /* Direct Mode Error Interrupt management ***********************************/
    if ((tmpisr_dma & (DMA_FLAG_DMEIF0_4 << (hdma->StreamIndex & 0x1FU))) != 0U)
24003f64:	687b      	ldr	r3, [r7, #4]
24003f66:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24003f68:	f003 031f 	and.w	r3, r3, #31
24003f6c:	2204      	movs	r2, #4
24003f6e:	409a      	lsls	r2, r3
24003f70:	69bb      	ldr	r3, [r7, #24]
24003f72:	4013      	ands	r3, r2
24003f74:	2b00      	cmp	r3, #0
24003f76:	f000 808f 	beq.w	24004098 <HAL_DMA_IRQHandler+0x460>
    {
      if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_DME) != 0U)
24003f7a:	687b      	ldr	r3, [r7, #4]
24003f7c:	681b      	ldr	r3, [r3, #0]
24003f7e:	4a2c      	ldr	r2, [pc, #176]	; (24004030 <HAL_DMA_IRQHandler+0x3f8>)
24003f80:	4293      	cmp	r3, r2
24003f82:	d04a      	beq.n	2400401a <HAL_DMA_IRQHandler+0x3e2>
24003f84:	687b      	ldr	r3, [r7, #4]
24003f86:	681b      	ldr	r3, [r3, #0]
24003f88:	4a2a      	ldr	r2, [pc, #168]	; (24004034 <HAL_DMA_IRQHandler+0x3fc>)
24003f8a:	4293      	cmp	r3, r2
24003f8c:	d045      	beq.n	2400401a <HAL_DMA_IRQHandler+0x3e2>
24003f8e:	687b      	ldr	r3, [r7, #4]
24003f90:	681b      	ldr	r3, [r3, #0]
24003f92:	4a29      	ldr	r2, [pc, #164]	; (24004038 <HAL_DMA_IRQHandler+0x400>)
24003f94:	4293      	cmp	r3, r2
24003f96:	d040      	beq.n	2400401a <HAL_DMA_IRQHandler+0x3e2>
24003f98:	687b      	ldr	r3, [r7, #4]
24003f9a:	681b      	ldr	r3, [r3, #0]
24003f9c:	4a27      	ldr	r2, [pc, #156]	; (2400403c <HAL_DMA_IRQHandler+0x404>)
24003f9e:	4293      	cmp	r3, r2
24003fa0:	d03b      	beq.n	2400401a <HAL_DMA_IRQHandler+0x3e2>
24003fa2:	687b      	ldr	r3, [r7, #4]
24003fa4:	681b      	ldr	r3, [r3, #0]
24003fa6:	4a26      	ldr	r2, [pc, #152]	; (24004040 <HAL_DMA_IRQHandler+0x408>)
24003fa8:	4293      	cmp	r3, r2
24003faa:	d036      	beq.n	2400401a <HAL_DMA_IRQHandler+0x3e2>
24003fac:	687b      	ldr	r3, [r7, #4]
24003fae:	681b      	ldr	r3, [r3, #0]
24003fb0:	4a24      	ldr	r2, [pc, #144]	; (24004044 <HAL_DMA_IRQHandler+0x40c>)
24003fb2:	4293      	cmp	r3, r2
24003fb4:	d031      	beq.n	2400401a <HAL_DMA_IRQHandler+0x3e2>
24003fb6:	687b      	ldr	r3, [r7, #4]
24003fb8:	681b      	ldr	r3, [r3, #0]
24003fba:	4a23      	ldr	r2, [pc, #140]	; (24004048 <HAL_DMA_IRQHandler+0x410>)
24003fbc:	4293      	cmp	r3, r2
24003fbe:	d02c      	beq.n	2400401a <HAL_DMA_IRQHandler+0x3e2>
24003fc0:	687b      	ldr	r3, [r7, #4]
24003fc2:	681b      	ldr	r3, [r3, #0]
24003fc4:	4a21      	ldr	r2, [pc, #132]	; (2400404c <HAL_DMA_IRQHandler+0x414>)
24003fc6:	4293      	cmp	r3, r2
24003fc8:	d027      	beq.n	2400401a <HAL_DMA_IRQHandler+0x3e2>
24003fca:	687b      	ldr	r3, [r7, #4]
24003fcc:	681b      	ldr	r3, [r3, #0]
24003fce:	4a20      	ldr	r2, [pc, #128]	; (24004050 <HAL_DMA_IRQHandler+0x418>)
24003fd0:	4293      	cmp	r3, r2
24003fd2:	d022      	beq.n	2400401a <HAL_DMA_IRQHandler+0x3e2>
24003fd4:	687b      	ldr	r3, [r7, #4]
24003fd6:	681b      	ldr	r3, [r3, #0]
24003fd8:	4a1e      	ldr	r2, [pc, #120]	; (24004054 <HAL_DMA_IRQHandler+0x41c>)
24003fda:	4293      	cmp	r3, r2
24003fdc:	d01d      	beq.n	2400401a <HAL_DMA_IRQHandler+0x3e2>
24003fde:	687b      	ldr	r3, [r7, #4]
24003fe0:	681b      	ldr	r3, [r3, #0]
24003fe2:	4a1d      	ldr	r2, [pc, #116]	; (24004058 <HAL_DMA_IRQHandler+0x420>)
24003fe4:	4293      	cmp	r3, r2
24003fe6:	d018      	beq.n	2400401a <HAL_DMA_IRQHandler+0x3e2>
24003fe8:	687b      	ldr	r3, [r7, #4]
24003fea:	681b      	ldr	r3, [r3, #0]
24003fec:	4a1b      	ldr	r2, [pc, #108]	; (2400405c <HAL_DMA_IRQHandler+0x424>)
24003fee:	4293      	cmp	r3, r2
24003ff0:	d013      	beq.n	2400401a <HAL_DMA_IRQHandler+0x3e2>
24003ff2:	687b      	ldr	r3, [r7, #4]
24003ff4:	681b      	ldr	r3, [r3, #0]
24003ff6:	4a1a      	ldr	r2, [pc, #104]	; (24004060 <HAL_DMA_IRQHandler+0x428>)
24003ff8:	4293      	cmp	r3, r2
24003ffa:	d00e      	beq.n	2400401a <HAL_DMA_IRQHandler+0x3e2>
24003ffc:	687b      	ldr	r3, [r7, #4]
24003ffe:	681b      	ldr	r3, [r3, #0]
24004000:	4a18      	ldr	r2, [pc, #96]	; (24004064 <HAL_DMA_IRQHandler+0x42c>)
24004002:	4293      	cmp	r3, r2
24004004:	d009      	beq.n	2400401a <HAL_DMA_IRQHandler+0x3e2>
24004006:	687b      	ldr	r3, [r7, #4]
24004008:	681b      	ldr	r3, [r3, #0]
2400400a:	4a17      	ldr	r2, [pc, #92]	; (24004068 <HAL_DMA_IRQHandler+0x430>)
2400400c:	4293      	cmp	r3, r2
2400400e:	d004      	beq.n	2400401a <HAL_DMA_IRQHandler+0x3e2>
24004010:	687b      	ldr	r3, [r7, #4]
24004012:	681b      	ldr	r3, [r3, #0]
24004014:	4a15      	ldr	r2, [pc, #84]	; (2400406c <HAL_DMA_IRQHandler+0x434>)
24004016:	4293      	cmp	r3, r2
24004018:	d12a      	bne.n	24004070 <HAL_DMA_IRQHandler+0x438>
2400401a:	687b      	ldr	r3, [r7, #4]
2400401c:	681b      	ldr	r3, [r3, #0]
2400401e:	681b      	ldr	r3, [r3, #0]
24004020:	f003 0302 	and.w	r3, r3, #2
24004024:	2b00      	cmp	r3, #0
24004026:	bf14      	ite	ne
24004028:	2301      	movne	r3, #1
2400402a:	2300      	moveq	r3, #0
2400402c:	b2db      	uxtb	r3, r3
2400402e:	e023      	b.n	24004078 <HAL_DMA_IRQHandler+0x440>
24004030:	40020010 	.word	0x40020010
24004034:	40020028 	.word	0x40020028
24004038:	40020040 	.word	0x40020040
2400403c:	40020058 	.word	0x40020058
24004040:	40020070 	.word	0x40020070
24004044:	40020088 	.word	0x40020088
24004048:	400200a0 	.word	0x400200a0
2400404c:	400200b8 	.word	0x400200b8
24004050:	40020410 	.word	0x40020410
24004054:	40020428 	.word	0x40020428
24004058:	40020440 	.word	0x40020440
2400405c:	40020458 	.word	0x40020458
24004060:	40020470 	.word	0x40020470
24004064:	40020488 	.word	0x40020488
24004068:	400204a0 	.word	0x400204a0
2400406c:	400204b8 	.word	0x400204b8
24004070:	687b      	ldr	r3, [r7, #4]
24004072:	681b      	ldr	r3, [r3, #0]
24004074:	681b      	ldr	r3, [r3, #0]
24004076:	2300      	movs	r3, #0
24004078:	2b00      	cmp	r3, #0
2400407a:	d00d      	beq.n	24004098 <HAL_DMA_IRQHandler+0x460>
      {
        /* Clear the direct mode error flag */
        regs_dma->IFCR = DMA_FLAG_DMEIF0_4 << (hdma->StreamIndex & 0x1FU);
2400407c:	687b      	ldr	r3, [r7, #4]
2400407e:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24004080:	f003 031f 	and.w	r3, r3, #31
24004084:	2204      	movs	r2, #4
24004086:	409a      	lsls	r2, r3
24004088:	6a3b      	ldr	r3, [r7, #32]
2400408a:	609a      	str	r2, [r3, #8]

        /* Update error code */
        hdma->ErrorCode |= HAL_DMA_ERROR_DME;
2400408c:	687b      	ldr	r3, [r7, #4]
2400408e:	6d5b      	ldr	r3, [r3, #84]	; 0x54
24004090:	f043 0204 	orr.w	r2, r3, #4
24004094:	687b      	ldr	r3, [r7, #4]
24004096:	655a      	str	r2, [r3, #84]	; 0x54
      }
    }
    /* Half Transfer Complete Interrupt management ******************************/
    if ((tmpisr_dma & (DMA_FLAG_HTIF0_4 << (hdma->StreamIndex & 0x1FU))) != 0U)
24004098:	687b      	ldr	r3, [r7, #4]
2400409a:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
2400409c:	f003 031f 	and.w	r3, r3, #31
240040a0:	2210      	movs	r2, #16
240040a2:	409a      	lsls	r2, r3
240040a4:	69bb      	ldr	r3, [r7, #24]
240040a6:	4013      	ands	r3, r2
240040a8:	2b00      	cmp	r3, #0
240040aa:	f000 80a6 	beq.w	240041fa <HAL_DMA_IRQHandler+0x5c2>
    {
      if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_HT) != 0U)
240040ae:	687b      	ldr	r3, [r7, #4]
240040b0:	681b      	ldr	r3, [r3, #0]
240040b2:	4a85      	ldr	r2, [pc, #532]	; (240042c8 <HAL_DMA_IRQHandler+0x690>)
240040b4:	4293      	cmp	r3, r2
240040b6:	d04a      	beq.n	2400414e <HAL_DMA_IRQHandler+0x516>
240040b8:	687b      	ldr	r3, [r7, #4]
240040ba:	681b      	ldr	r3, [r3, #0]
240040bc:	4a83      	ldr	r2, [pc, #524]	; (240042cc <HAL_DMA_IRQHandler+0x694>)
240040be:	4293      	cmp	r3, r2
240040c0:	d045      	beq.n	2400414e <HAL_DMA_IRQHandler+0x516>
240040c2:	687b      	ldr	r3, [r7, #4]
240040c4:	681b      	ldr	r3, [r3, #0]
240040c6:	4a82      	ldr	r2, [pc, #520]	; (240042d0 <HAL_DMA_IRQHandler+0x698>)
240040c8:	4293      	cmp	r3, r2
240040ca:	d040      	beq.n	2400414e <HAL_DMA_IRQHandler+0x516>
240040cc:	687b      	ldr	r3, [r7, #4]
240040ce:	681b      	ldr	r3, [r3, #0]
240040d0:	4a80      	ldr	r2, [pc, #512]	; (240042d4 <HAL_DMA_IRQHandler+0x69c>)
240040d2:	4293      	cmp	r3, r2
240040d4:	d03b      	beq.n	2400414e <HAL_DMA_IRQHandler+0x516>
240040d6:	687b      	ldr	r3, [r7, #4]
240040d8:	681b      	ldr	r3, [r3, #0]
240040da:	4a7f      	ldr	r2, [pc, #508]	; (240042d8 <HAL_DMA_IRQHandler+0x6a0>)
240040dc:	4293      	cmp	r3, r2
240040de:	d036      	beq.n	2400414e <HAL_DMA_IRQHandler+0x516>
240040e0:	687b      	ldr	r3, [r7, #4]
240040e2:	681b      	ldr	r3, [r3, #0]
240040e4:	4a7d      	ldr	r2, [pc, #500]	; (240042dc <HAL_DMA_IRQHandler+0x6a4>)
240040e6:	4293      	cmp	r3, r2
240040e8:	d031      	beq.n	2400414e <HAL_DMA_IRQHandler+0x516>
240040ea:	687b      	ldr	r3, [r7, #4]
240040ec:	681b      	ldr	r3, [r3, #0]
240040ee:	4a7c      	ldr	r2, [pc, #496]	; (240042e0 <HAL_DMA_IRQHandler+0x6a8>)
240040f0:	4293      	cmp	r3, r2
240040f2:	d02c      	beq.n	2400414e <HAL_DMA_IRQHandler+0x516>
240040f4:	687b      	ldr	r3, [r7, #4]
240040f6:	681b      	ldr	r3, [r3, #0]
240040f8:	4a7a      	ldr	r2, [pc, #488]	; (240042e4 <HAL_DMA_IRQHandler+0x6ac>)
240040fa:	4293      	cmp	r3, r2
240040fc:	d027      	beq.n	2400414e <HAL_DMA_IRQHandler+0x516>
240040fe:	687b      	ldr	r3, [r7, #4]
24004100:	681b      	ldr	r3, [r3, #0]
24004102:	4a79      	ldr	r2, [pc, #484]	; (240042e8 <HAL_DMA_IRQHandler+0x6b0>)
24004104:	4293      	cmp	r3, r2
24004106:	d022      	beq.n	2400414e <HAL_DMA_IRQHandler+0x516>
24004108:	687b      	ldr	r3, [r7, #4]
2400410a:	681b      	ldr	r3, [r3, #0]
2400410c:	4a77      	ldr	r2, [pc, #476]	; (240042ec <HAL_DMA_IRQHandler+0x6b4>)
2400410e:	4293      	cmp	r3, r2
24004110:	d01d      	beq.n	2400414e <HAL_DMA_IRQHandler+0x516>
24004112:	687b      	ldr	r3, [r7, #4]
24004114:	681b      	ldr	r3, [r3, #0]
24004116:	4a76      	ldr	r2, [pc, #472]	; (240042f0 <HAL_DMA_IRQHandler+0x6b8>)
24004118:	4293      	cmp	r3, r2
2400411a:	d018      	beq.n	2400414e <HAL_DMA_IRQHandler+0x516>
2400411c:	687b      	ldr	r3, [r7, #4]
2400411e:	681b      	ldr	r3, [r3, #0]
24004120:	4a74      	ldr	r2, [pc, #464]	; (240042f4 <HAL_DMA_IRQHandler+0x6bc>)
24004122:	4293      	cmp	r3, r2
24004124:	d013      	beq.n	2400414e <HAL_DMA_IRQHandler+0x516>
24004126:	687b      	ldr	r3, [r7, #4]
24004128:	681b      	ldr	r3, [r3, #0]
2400412a:	4a73      	ldr	r2, [pc, #460]	; (240042f8 <HAL_DMA_IRQHandler+0x6c0>)
2400412c:	4293      	cmp	r3, r2
2400412e:	d00e      	beq.n	2400414e <HAL_DMA_IRQHandler+0x516>
24004130:	687b      	ldr	r3, [r7, #4]
24004132:	681b      	ldr	r3, [r3, #0]
24004134:	4a71      	ldr	r2, [pc, #452]	; (240042fc <HAL_DMA_IRQHandler+0x6c4>)
24004136:	4293      	cmp	r3, r2
24004138:	d009      	beq.n	2400414e <HAL_DMA_IRQHandler+0x516>
2400413a:	687b      	ldr	r3, [r7, #4]
2400413c:	681b      	ldr	r3, [r3, #0]
2400413e:	4a70      	ldr	r2, [pc, #448]	; (24004300 <HAL_DMA_IRQHandler+0x6c8>)
24004140:	4293      	cmp	r3, r2
24004142:	d004      	beq.n	2400414e <HAL_DMA_IRQHandler+0x516>
24004144:	687b      	ldr	r3, [r7, #4]
24004146:	681b      	ldr	r3, [r3, #0]
24004148:	4a6e      	ldr	r2, [pc, #440]	; (24004304 <HAL_DMA_IRQHandler+0x6cc>)
2400414a:	4293      	cmp	r3, r2
2400414c:	d10a      	bne.n	24004164 <HAL_DMA_IRQHandler+0x52c>
2400414e:	687b      	ldr	r3, [r7, #4]
24004150:	681b      	ldr	r3, [r3, #0]
24004152:	681b      	ldr	r3, [r3, #0]
24004154:	f003 0308 	and.w	r3, r3, #8
24004158:	2b00      	cmp	r3, #0
2400415a:	bf14      	ite	ne
2400415c:	2301      	movne	r3, #1
2400415e:	2300      	moveq	r3, #0
24004160:	b2db      	uxtb	r3, r3
24004162:	e009      	b.n	24004178 <HAL_DMA_IRQHandler+0x540>
24004164:	687b      	ldr	r3, [r7, #4]
24004166:	681b      	ldr	r3, [r3, #0]
24004168:	681b      	ldr	r3, [r3, #0]
2400416a:	f003 0304 	and.w	r3, r3, #4
2400416e:	2b00      	cmp	r3, #0
24004170:	bf14      	ite	ne
24004172:	2301      	movne	r3, #1
24004174:	2300      	moveq	r3, #0
24004176:	b2db      	uxtb	r3, r3
24004178:	2b00      	cmp	r3, #0
2400417a:	d03e      	beq.n	240041fa <HAL_DMA_IRQHandler+0x5c2>
      {
        /* Clear the half transfer complete flag */
        regs_dma->IFCR = DMA_FLAG_HTIF0_4 << (hdma->StreamIndex & 0x1FU);
2400417c:	687b      	ldr	r3, [r7, #4]
2400417e:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24004180:	f003 031f 	and.w	r3, r3, #31
24004184:	2210      	movs	r2, #16
24004186:	409a      	lsls	r2, r3
24004188:	6a3b      	ldr	r3, [r7, #32]
2400418a:	609a      	str	r2, [r3, #8]

        /* Multi_Buffering mode enabled */
        if(((((DMA_Stream_TypeDef   *)hdma->Instance)->CR) & (uint32_t)(DMA_SxCR_DBM)) != 0U)
2400418c:	687b      	ldr	r3, [r7, #4]
2400418e:	681b      	ldr	r3, [r3, #0]
24004190:	681b      	ldr	r3, [r3, #0]
24004192:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
24004196:	2b00      	cmp	r3, #0
24004198:	d018      	beq.n	240041cc <HAL_DMA_IRQHandler+0x594>
        {
          /* Current memory buffer used is Memory 0 */
          if((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_CT) == 0U)
2400419a:	687b      	ldr	r3, [r7, #4]
2400419c:	681b      	ldr	r3, [r3, #0]
2400419e:	681b      	ldr	r3, [r3, #0]
240041a0:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
240041a4:	2b00      	cmp	r3, #0
240041a6:	d108      	bne.n	240041ba <HAL_DMA_IRQHandler+0x582>
          {
            if(hdma->XferHalfCpltCallback != NULL)
240041a8:	687b      	ldr	r3, [r7, #4]
240041aa:	6c1b      	ldr	r3, [r3, #64]	; 0x40
240041ac:	2b00      	cmp	r3, #0
240041ae:	d024      	beq.n	240041fa <HAL_DMA_IRQHandler+0x5c2>
            {
              /* Half transfer callback */
              hdma->XferHalfCpltCallback(hdma);
240041b0:	687b      	ldr	r3, [r7, #4]
240041b2:	6c1b      	ldr	r3, [r3, #64]	; 0x40
240041b4:	6878      	ldr	r0, [r7, #4]
240041b6:	4798      	blx	r3
240041b8:	e01f      	b.n	240041fa <HAL_DMA_IRQHandler+0x5c2>
            }
          }
          /* Current memory buffer used is Memory 1 */
          else
          {
            if(hdma->XferM1HalfCpltCallback != NULL)
240041ba:	687b      	ldr	r3, [r7, #4]
240041bc:	6c9b      	ldr	r3, [r3, #72]	; 0x48
240041be:	2b00      	cmp	r3, #0
240041c0:	d01b      	beq.n	240041fa <HAL_DMA_IRQHandler+0x5c2>
            {
              /* Half transfer callback */
              hdma->XferM1HalfCpltCallback(hdma);
240041c2:	687b      	ldr	r3, [r7, #4]
240041c4:	6c9b      	ldr	r3, [r3, #72]	; 0x48
240041c6:	6878      	ldr	r0, [r7, #4]
240041c8:	4798      	blx	r3
240041ca:	e016      	b.n	240041fa <HAL_DMA_IRQHandler+0x5c2>
          }
        }
        else
        {
          /* Disable the half transfer interrupt if the DMA mode is not CIRCULAR */
          if((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_CIRC) == 0U)
240041cc:	687b      	ldr	r3, [r7, #4]
240041ce:	681b      	ldr	r3, [r3, #0]
240041d0:	681b      	ldr	r3, [r3, #0]
240041d2:	f403 7380 	and.w	r3, r3, #256	; 0x100
240041d6:	2b00      	cmp	r3, #0
240041d8:	d107      	bne.n	240041ea <HAL_DMA_IRQHandler+0x5b2>
          {
            /* Disable the half transfer interrupt */
            ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  &= ~(DMA_IT_HT);
240041da:	687b      	ldr	r3, [r7, #4]
240041dc:	681b      	ldr	r3, [r3, #0]
240041de:	681a      	ldr	r2, [r3, #0]
240041e0:	687b      	ldr	r3, [r7, #4]
240041e2:	681b      	ldr	r3, [r3, #0]
240041e4:	f022 0208 	bic.w	r2, r2, #8
240041e8:	601a      	str	r2, [r3, #0]
          }

          if(hdma->XferHalfCpltCallback != NULL)
240041ea:	687b      	ldr	r3, [r7, #4]
240041ec:	6c1b      	ldr	r3, [r3, #64]	; 0x40
240041ee:	2b00      	cmp	r3, #0
240041f0:	d003      	beq.n	240041fa <HAL_DMA_IRQHandler+0x5c2>
          {
            /* Half transfer callback */
            hdma->XferHalfCpltCallback(hdma);
240041f2:	687b      	ldr	r3, [r7, #4]
240041f4:	6c1b      	ldr	r3, [r3, #64]	; 0x40
240041f6:	6878      	ldr	r0, [r7, #4]
240041f8:	4798      	blx	r3
          }
        }
      }
    }
    /* Transfer Complete Interrupt management ***********************************/
    if ((tmpisr_dma & (DMA_FLAG_TCIF0_4 << (hdma->StreamIndex & 0x1FU))) != 0U)
240041fa:	687b      	ldr	r3, [r7, #4]
240041fc:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
240041fe:	f003 031f 	and.w	r3, r3, #31
24004202:	2220      	movs	r2, #32
24004204:	409a      	lsls	r2, r3
24004206:	69bb      	ldr	r3, [r7, #24]
24004208:	4013      	ands	r3, r2
2400420a:	2b00      	cmp	r3, #0
2400420c:	f000 8110 	beq.w	24004430 <HAL_DMA_IRQHandler+0x7f8>
    {
      if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TC) != 0U)
24004210:	687b      	ldr	r3, [r7, #4]
24004212:	681b      	ldr	r3, [r3, #0]
24004214:	4a2c      	ldr	r2, [pc, #176]	; (240042c8 <HAL_DMA_IRQHandler+0x690>)
24004216:	4293      	cmp	r3, r2
24004218:	d04a      	beq.n	240042b0 <HAL_DMA_IRQHandler+0x678>
2400421a:	687b      	ldr	r3, [r7, #4]
2400421c:	681b      	ldr	r3, [r3, #0]
2400421e:	4a2b      	ldr	r2, [pc, #172]	; (240042cc <HAL_DMA_IRQHandler+0x694>)
24004220:	4293      	cmp	r3, r2
24004222:	d045      	beq.n	240042b0 <HAL_DMA_IRQHandler+0x678>
24004224:	687b      	ldr	r3, [r7, #4]
24004226:	681b      	ldr	r3, [r3, #0]
24004228:	4a29      	ldr	r2, [pc, #164]	; (240042d0 <HAL_DMA_IRQHandler+0x698>)
2400422a:	4293      	cmp	r3, r2
2400422c:	d040      	beq.n	240042b0 <HAL_DMA_IRQHandler+0x678>
2400422e:	687b      	ldr	r3, [r7, #4]
24004230:	681b      	ldr	r3, [r3, #0]
24004232:	4a28      	ldr	r2, [pc, #160]	; (240042d4 <HAL_DMA_IRQHandler+0x69c>)
24004234:	4293      	cmp	r3, r2
24004236:	d03b      	beq.n	240042b0 <HAL_DMA_IRQHandler+0x678>
24004238:	687b      	ldr	r3, [r7, #4]
2400423a:	681b      	ldr	r3, [r3, #0]
2400423c:	4a26      	ldr	r2, [pc, #152]	; (240042d8 <HAL_DMA_IRQHandler+0x6a0>)
2400423e:	4293      	cmp	r3, r2
24004240:	d036      	beq.n	240042b0 <HAL_DMA_IRQHandler+0x678>
24004242:	687b      	ldr	r3, [r7, #4]
24004244:	681b      	ldr	r3, [r3, #0]
24004246:	4a25      	ldr	r2, [pc, #148]	; (240042dc <HAL_DMA_IRQHandler+0x6a4>)
24004248:	4293      	cmp	r3, r2
2400424a:	d031      	beq.n	240042b0 <HAL_DMA_IRQHandler+0x678>
2400424c:	687b      	ldr	r3, [r7, #4]
2400424e:	681b      	ldr	r3, [r3, #0]
24004250:	4a23      	ldr	r2, [pc, #140]	; (240042e0 <HAL_DMA_IRQHandler+0x6a8>)
24004252:	4293      	cmp	r3, r2
24004254:	d02c      	beq.n	240042b0 <HAL_DMA_IRQHandler+0x678>
24004256:	687b      	ldr	r3, [r7, #4]
24004258:	681b      	ldr	r3, [r3, #0]
2400425a:	4a22      	ldr	r2, [pc, #136]	; (240042e4 <HAL_DMA_IRQHandler+0x6ac>)
2400425c:	4293      	cmp	r3, r2
2400425e:	d027      	beq.n	240042b0 <HAL_DMA_IRQHandler+0x678>
24004260:	687b      	ldr	r3, [r7, #4]
24004262:	681b      	ldr	r3, [r3, #0]
24004264:	4a20      	ldr	r2, [pc, #128]	; (240042e8 <HAL_DMA_IRQHandler+0x6b0>)
24004266:	4293      	cmp	r3, r2
24004268:	d022      	beq.n	240042b0 <HAL_DMA_IRQHandler+0x678>
2400426a:	687b      	ldr	r3, [r7, #4]
2400426c:	681b      	ldr	r3, [r3, #0]
2400426e:	4a1f      	ldr	r2, [pc, #124]	; (240042ec <HAL_DMA_IRQHandler+0x6b4>)
24004270:	4293      	cmp	r3, r2
24004272:	d01d      	beq.n	240042b0 <HAL_DMA_IRQHandler+0x678>
24004274:	687b      	ldr	r3, [r7, #4]
24004276:	681b      	ldr	r3, [r3, #0]
24004278:	4a1d      	ldr	r2, [pc, #116]	; (240042f0 <HAL_DMA_IRQHandler+0x6b8>)
2400427a:	4293      	cmp	r3, r2
2400427c:	d018      	beq.n	240042b0 <HAL_DMA_IRQHandler+0x678>
2400427e:	687b      	ldr	r3, [r7, #4]
24004280:	681b      	ldr	r3, [r3, #0]
24004282:	4a1c      	ldr	r2, [pc, #112]	; (240042f4 <HAL_DMA_IRQHandler+0x6bc>)
24004284:	4293      	cmp	r3, r2
24004286:	d013      	beq.n	240042b0 <HAL_DMA_IRQHandler+0x678>
24004288:	687b      	ldr	r3, [r7, #4]
2400428a:	681b      	ldr	r3, [r3, #0]
2400428c:	4a1a      	ldr	r2, [pc, #104]	; (240042f8 <HAL_DMA_IRQHandler+0x6c0>)
2400428e:	4293      	cmp	r3, r2
24004290:	d00e      	beq.n	240042b0 <HAL_DMA_IRQHandler+0x678>
24004292:	687b      	ldr	r3, [r7, #4]
24004294:	681b      	ldr	r3, [r3, #0]
24004296:	4a19      	ldr	r2, [pc, #100]	; (240042fc <HAL_DMA_IRQHandler+0x6c4>)
24004298:	4293      	cmp	r3, r2
2400429a:	d009      	beq.n	240042b0 <HAL_DMA_IRQHandler+0x678>
2400429c:	687b      	ldr	r3, [r7, #4]
2400429e:	681b      	ldr	r3, [r3, #0]
240042a0:	4a17      	ldr	r2, [pc, #92]	; (24004300 <HAL_DMA_IRQHandler+0x6c8>)
240042a2:	4293      	cmp	r3, r2
240042a4:	d004      	beq.n	240042b0 <HAL_DMA_IRQHandler+0x678>
240042a6:	687b      	ldr	r3, [r7, #4]
240042a8:	681b      	ldr	r3, [r3, #0]
240042aa:	4a16      	ldr	r2, [pc, #88]	; (24004304 <HAL_DMA_IRQHandler+0x6cc>)
240042ac:	4293      	cmp	r3, r2
240042ae:	d12b      	bne.n	24004308 <HAL_DMA_IRQHandler+0x6d0>
240042b0:	687b      	ldr	r3, [r7, #4]
240042b2:	681b      	ldr	r3, [r3, #0]
240042b4:	681b      	ldr	r3, [r3, #0]
240042b6:	f003 0310 	and.w	r3, r3, #16
240042ba:	2b00      	cmp	r3, #0
240042bc:	bf14      	ite	ne
240042be:	2301      	movne	r3, #1
240042c0:	2300      	moveq	r3, #0
240042c2:	b2db      	uxtb	r3, r3
240042c4:	e02a      	b.n	2400431c <HAL_DMA_IRQHandler+0x6e4>
240042c6:	bf00      	nop
240042c8:	40020010 	.word	0x40020010
240042cc:	40020028 	.word	0x40020028
240042d0:	40020040 	.word	0x40020040
240042d4:	40020058 	.word	0x40020058
240042d8:	40020070 	.word	0x40020070
240042dc:	40020088 	.word	0x40020088
240042e0:	400200a0 	.word	0x400200a0
240042e4:	400200b8 	.word	0x400200b8
240042e8:	40020410 	.word	0x40020410
240042ec:	40020428 	.word	0x40020428
240042f0:	40020440 	.word	0x40020440
240042f4:	40020458 	.word	0x40020458
240042f8:	40020470 	.word	0x40020470
240042fc:	40020488 	.word	0x40020488
24004300:	400204a0 	.word	0x400204a0
24004304:	400204b8 	.word	0x400204b8
24004308:	687b      	ldr	r3, [r7, #4]
2400430a:	681b      	ldr	r3, [r3, #0]
2400430c:	681b      	ldr	r3, [r3, #0]
2400430e:	f003 0302 	and.w	r3, r3, #2
24004312:	2b00      	cmp	r3, #0
24004314:	bf14      	ite	ne
24004316:	2301      	movne	r3, #1
24004318:	2300      	moveq	r3, #0
2400431a:	b2db      	uxtb	r3, r3
2400431c:	2b00      	cmp	r3, #0
2400431e:	f000 8087 	beq.w	24004430 <HAL_DMA_IRQHandler+0x7f8>
      {
        /* Clear the transfer complete flag */
        regs_dma->IFCR = DMA_FLAG_TCIF0_4 << (hdma->StreamIndex & 0x1FU);
24004322:	687b      	ldr	r3, [r7, #4]
24004324:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24004326:	f003 031f 	and.w	r3, r3, #31
2400432a:	2220      	movs	r2, #32
2400432c:	409a      	lsls	r2, r3
2400432e:	6a3b      	ldr	r3, [r7, #32]
24004330:	609a      	str	r2, [r3, #8]

        if(HAL_DMA_STATE_ABORT == hdma->State)
24004332:	687b      	ldr	r3, [r7, #4]
24004334:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
24004338:	b2db      	uxtb	r3, r3
2400433a:	2b04      	cmp	r3, #4
2400433c:	d139      	bne.n	240043b2 <HAL_DMA_IRQHandler+0x77a>
        {
          /* Disable all the transfer interrupts */
          ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME);
2400433e:	687b      	ldr	r3, [r7, #4]
24004340:	681b      	ldr	r3, [r3, #0]
24004342:	681a      	ldr	r2, [r3, #0]
24004344:	687b      	ldr	r3, [r7, #4]
24004346:	681b      	ldr	r3, [r3, #0]
24004348:	f022 0216 	bic.w	r2, r2, #22
2400434c:	601a      	str	r2, [r3, #0]
          ((DMA_Stream_TypeDef   *)hdma->Instance)->FCR &= ~(DMA_IT_FE);
2400434e:	687b      	ldr	r3, [r7, #4]
24004350:	681b      	ldr	r3, [r3, #0]
24004352:	695a      	ldr	r2, [r3, #20]
24004354:	687b      	ldr	r3, [r7, #4]
24004356:	681b      	ldr	r3, [r3, #0]
24004358:	f022 0280 	bic.w	r2, r2, #128	; 0x80
2400435c:	615a      	str	r2, [r3, #20]

          if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
2400435e:	687b      	ldr	r3, [r7, #4]
24004360:	6c1b      	ldr	r3, [r3, #64]	; 0x40
24004362:	2b00      	cmp	r3, #0
24004364:	d103      	bne.n	2400436e <HAL_DMA_IRQHandler+0x736>
24004366:	687b      	ldr	r3, [r7, #4]
24004368:	6c9b      	ldr	r3, [r3, #72]	; 0x48
2400436a:	2b00      	cmp	r3, #0
2400436c:	d007      	beq.n	2400437e <HAL_DMA_IRQHandler+0x746>
          {
            ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  &= ~(DMA_IT_HT);
2400436e:	687b      	ldr	r3, [r7, #4]
24004370:	681b      	ldr	r3, [r3, #0]
24004372:	681a      	ldr	r2, [r3, #0]
24004374:	687b      	ldr	r3, [r7, #4]
24004376:	681b      	ldr	r3, [r3, #0]
24004378:	f022 0208 	bic.w	r2, r2, #8
2400437c:	601a      	str	r2, [r3, #0]
          }

          /* Clear all interrupt flags at correct offset within the register */
          regs_dma->IFCR = 0x3FUL << (hdma->StreamIndex & 0x1FU);
2400437e:	687b      	ldr	r3, [r7, #4]
24004380:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24004382:	f003 031f 	and.w	r3, r3, #31
24004386:	223f      	movs	r2, #63	; 0x3f
24004388:	409a      	lsls	r2, r3
2400438a:	6a3b      	ldr	r3, [r7, #32]
2400438c:	609a      	str	r2, [r3, #8]

          /* Process Unlocked */
          __HAL_UNLOCK(hdma);
2400438e:	687b      	ldr	r3, [r7, #4]
24004390:	2200      	movs	r2, #0
24004392:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

          /* Change the DMA state */
          hdma->State = HAL_DMA_STATE_READY;
24004396:	687b      	ldr	r3, [r7, #4]
24004398:	2201      	movs	r2, #1
2400439a:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

          if(hdma->XferAbortCallback != NULL)
2400439e:	687b      	ldr	r3, [r7, #4]
240043a0:	6d1b      	ldr	r3, [r3, #80]	; 0x50
240043a2:	2b00      	cmp	r3, #0
240043a4:	f000 834a 	beq.w	24004a3c <HAL_DMA_IRQHandler+0xe04>
          {
            hdma->XferAbortCallback(hdma);
240043a8:	687b      	ldr	r3, [r7, #4]
240043aa:	6d1b      	ldr	r3, [r3, #80]	; 0x50
240043ac:	6878      	ldr	r0, [r7, #4]
240043ae:	4798      	blx	r3
          }
          return;
240043b0:	e344      	b.n	24004a3c <HAL_DMA_IRQHandler+0xe04>
        }

        if(((((DMA_Stream_TypeDef   *)hdma->Instance)->CR) & (uint32_t)(DMA_SxCR_DBM)) != 0U)
240043b2:	687b      	ldr	r3, [r7, #4]
240043b4:	681b      	ldr	r3, [r3, #0]
240043b6:	681b      	ldr	r3, [r3, #0]
240043b8:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
240043bc:	2b00      	cmp	r3, #0
240043be:	d018      	beq.n	240043f2 <HAL_DMA_IRQHandler+0x7ba>
        {
          /* Current memory buffer used is Memory 0 */
          if((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_CT) == 0U)
240043c0:	687b      	ldr	r3, [r7, #4]
240043c2:	681b      	ldr	r3, [r3, #0]
240043c4:	681b      	ldr	r3, [r3, #0]
240043c6:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
240043ca:	2b00      	cmp	r3, #0
240043cc:	d108      	bne.n	240043e0 <HAL_DMA_IRQHandler+0x7a8>
          {
            if(hdma->XferM1CpltCallback != NULL)
240043ce:	687b      	ldr	r3, [r7, #4]
240043d0:	6c5b      	ldr	r3, [r3, #68]	; 0x44
240043d2:	2b00      	cmp	r3, #0
240043d4:	d02c      	beq.n	24004430 <HAL_DMA_IRQHandler+0x7f8>
            {
              /* Transfer complete Callback for memory1 */
              hdma->XferM1CpltCallback(hdma);
240043d6:	687b      	ldr	r3, [r7, #4]
240043d8:	6c5b      	ldr	r3, [r3, #68]	; 0x44
240043da:	6878      	ldr	r0, [r7, #4]
240043dc:	4798      	blx	r3
240043de:	e027      	b.n	24004430 <HAL_DMA_IRQHandler+0x7f8>
            }
          }
          /* Current memory buffer used is Memory 1 */
          else
          {
            if(hdma->XferCpltCallback != NULL)
240043e0:	687b      	ldr	r3, [r7, #4]
240043e2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
240043e4:	2b00      	cmp	r3, #0
240043e6:	d023      	beq.n	24004430 <HAL_DMA_IRQHandler+0x7f8>
            {
              /* Transfer complete Callback for memory0 */
              hdma->XferCpltCallback(hdma);
240043e8:	687b      	ldr	r3, [r7, #4]
240043ea:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
240043ec:	6878      	ldr	r0, [r7, #4]
240043ee:	4798      	blx	r3
240043f0:	e01e      	b.n	24004430 <HAL_DMA_IRQHandler+0x7f8>
          }
        }
        /* Disable the transfer complete interrupt if the DMA mode is not CIRCULAR */
        else
        {
          if((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_CIRC) == 0U)
240043f2:	687b      	ldr	r3, [r7, #4]
240043f4:	681b      	ldr	r3, [r3, #0]
240043f6:	681b      	ldr	r3, [r3, #0]
240043f8:	f403 7380 	and.w	r3, r3, #256	; 0x100
240043fc:	2b00      	cmp	r3, #0
240043fe:	d10f      	bne.n	24004420 <HAL_DMA_IRQHandler+0x7e8>
          {
            /* Disable the transfer complete interrupt */
            ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  &= ~(DMA_IT_TC);
24004400:	687b      	ldr	r3, [r7, #4]
24004402:	681b      	ldr	r3, [r3, #0]
24004404:	681a      	ldr	r2, [r3, #0]
24004406:	687b      	ldr	r3, [r7, #4]
24004408:	681b      	ldr	r3, [r3, #0]
2400440a:	f022 0210 	bic.w	r2, r2, #16
2400440e:	601a      	str	r2, [r3, #0]

            /* Process Unlocked */
            __HAL_UNLOCK(hdma);
24004410:	687b      	ldr	r3, [r7, #4]
24004412:	2200      	movs	r2, #0
24004414:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

            /* Change the DMA state */
            hdma->State = HAL_DMA_STATE_READY;
24004418:	687b      	ldr	r3, [r7, #4]
2400441a:	2201      	movs	r2, #1
2400441c:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
          }

          if(hdma->XferCpltCallback != NULL)
24004420:	687b      	ldr	r3, [r7, #4]
24004422:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24004424:	2b00      	cmp	r3, #0
24004426:	d003      	beq.n	24004430 <HAL_DMA_IRQHandler+0x7f8>
          {
            /* Transfer complete callback */
            hdma->XferCpltCallback(hdma);
24004428:	687b      	ldr	r3, [r7, #4]
2400442a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400442c:	6878      	ldr	r0, [r7, #4]
2400442e:	4798      	blx	r3
        }
      }
    }

    /* manage error case */
    if(hdma->ErrorCode != HAL_DMA_ERROR_NONE)
24004430:	687b      	ldr	r3, [r7, #4]
24004432:	6d5b      	ldr	r3, [r3, #84]	; 0x54
24004434:	2b00      	cmp	r3, #0
24004436:	f000 8306 	beq.w	24004a46 <HAL_DMA_IRQHandler+0xe0e>
    {
      if((hdma->ErrorCode & HAL_DMA_ERROR_TE) != 0U)
2400443a:	687b      	ldr	r3, [r7, #4]
2400443c:	6d5b      	ldr	r3, [r3, #84]	; 0x54
2400443e:	f003 0301 	and.w	r3, r3, #1
24004442:	2b00      	cmp	r3, #0
24004444:	f000 8088 	beq.w	24004558 <HAL_DMA_IRQHandler+0x920>
      {
        hdma->State = HAL_DMA_STATE_ABORT;
24004448:	687b      	ldr	r3, [r7, #4]
2400444a:	2204      	movs	r2, #4
2400444c:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

        /* Disable the stream */
        __HAL_DMA_DISABLE(hdma);
24004450:	687b      	ldr	r3, [r7, #4]
24004452:	681b      	ldr	r3, [r3, #0]
24004454:	4a7a      	ldr	r2, [pc, #488]	; (24004640 <HAL_DMA_IRQHandler+0xa08>)
24004456:	4293      	cmp	r3, r2
24004458:	d04a      	beq.n	240044f0 <HAL_DMA_IRQHandler+0x8b8>
2400445a:	687b      	ldr	r3, [r7, #4]
2400445c:	681b      	ldr	r3, [r3, #0]
2400445e:	4a79      	ldr	r2, [pc, #484]	; (24004644 <HAL_DMA_IRQHandler+0xa0c>)
24004460:	4293      	cmp	r3, r2
24004462:	d045      	beq.n	240044f0 <HAL_DMA_IRQHandler+0x8b8>
24004464:	687b      	ldr	r3, [r7, #4]
24004466:	681b      	ldr	r3, [r3, #0]
24004468:	4a77      	ldr	r2, [pc, #476]	; (24004648 <HAL_DMA_IRQHandler+0xa10>)
2400446a:	4293      	cmp	r3, r2
2400446c:	d040      	beq.n	240044f0 <HAL_DMA_IRQHandler+0x8b8>
2400446e:	687b      	ldr	r3, [r7, #4]
24004470:	681b      	ldr	r3, [r3, #0]
24004472:	4a76      	ldr	r2, [pc, #472]	; (2400464c <HAL_DMA_IRQHandler+0xa14>)
24004474:	4293      	cmp	r3, r2
24004476:	d03b      	beq.n	240044f0 <HAL_DMA_IRQHandler+0x8b8>
24004478:	687b      	ldr	r3, [r7, #4]
2400447a:	681b      	ldr	r3, [r3, #0]
2400447c:	4a74      	ldr	r2, [pc, #464]	; (24004650 <HAL_DMA_IRQHandler+0xa18>)
2400447e:	4293      	cmp	r3, r2
24004480:	d036      	beq.n	240044f0 <HAL_DMA_IRQHandler+0x8b8>
24004482:	687b      	ldr	r3, [r7, #4]
24004484:	681b      	ldr	r3, [r3, #0]
24004486:	4a73      	ldr	r2, [pc, #460]	; (24004654 <HAL_DMA_IRQHandler+0xa1c>)
24004488:	4293      	cmp	r3, r2
2400448a:	d031      	beq.n	240044f0 <HAL_DMA_IRQHandler+0x8b8>
2400448c:	687b      	ldr	r3, [r7, #4]
2400448e:	681b      	ldr	r3, [r3, #0]
24004490:	4a71      	ldr	r2, [pc, #452]	; (24004658 <HAL_DMA_IRQHandler+0xa20>)
24004492:	4293      	cmp	r3, r2
24004494:	d02c      	beq.n	240044f0 <HAL_DMA_IRQHandler+0x8b8>
24004496:	687b      	ldr	r3, [r7, #4]
24004498:	681b      	ldr	r3, [r3, #0]
2400449a:	4a70      	ldr	r2, [pc, #448]	; (2400465c <HAL_DMA_IRQHandler+0xa24>)
2400449c:	4293      	cmp	r3, r2
2400449e:	d027      	beq.n	240044f0 <HAL_DMA_IRQHandler+0x8b8>
240044a0:	687b      	ldr	r3, [r7, #4]
240044a2:	681b      	ldr	r3, [r3, #0]
240044a4:	4a6e      	ldr	r2, [pc, #440]	; (24004660 <HAL_DMA_IRQHandler+0xa28>)
240044a6:	4293      	cmp	r3, r2
240044a8:	d022      	beq.n	240044f0 <HAL_DMA_IRQHandler+0x8b8>
240044aa:	687b      	ldr	r3, [r7, #4]
240044ac:	681b      	ldr	r3, [r3, #0]
240044ae:	4a6d      	ldr	r2, [pc, #436]	; (24004664 <HAL_DMA_IRQHandler+0xa2c>)
240044b0:	4293      	cmp	r3, r2
240044b2:	d01d      	beq.n	240044f0 <HAL_DMA_IRQHandler+0x8b8>
240044b4:	687b      	ldr	r3, [r7, #4]
240044b6:	681b      	ldr	r3, [r3, #0]
240044b8:	4a6b      	ldr	r2, [pc, #428]	; (24004668 <HAL_DMA_IRQHandler+0xa30>)
240044ba:	4293      	cmp	r3, r2
240044bc:	d018      	beq.n	240044f0 <HAL_DMA_IRQHandler+0x8b8>
240044be:	687b      	ldr	r3, [r7, #4]
240044c0:	681b      	ldr	r3, [r3, #0]
240044c2:	4a6a      	ldr	r2, [pc, #424]	; (2400466c <HAL_DMA_IRQHandler+0xa34>)
240044c4:	4293      	cmp	r3, r2
240044c6:	d013      	beq.n	240044f0 <HAL_DMA_IRQHandler+0x8b8>
240044c8:	687b      	ldr	r3, [r7, #4]
240044ca:	681b      	ldr	r3, [r3, #0]
240044cc:	4a68      	ldr	r2, [pc, #416]	; (24004670 <HAL_DMA_IRQHandler+0xa38>)
240044ce:	4293      	cmp	r3, r2
240044d0:	d00e      	beq.n	240044f0 <HAL_DMA_IRQHandler+0x8b8>
240044d2:	687b      	ldr	r3, [r7, #4]
240044d4:	681b      	ldr	r3, [r3, #0]
240044d6:	4a67      	ldr	r2, [pc, #412]	; (24004674 <HAL_DMA_IRQHandler+0xa3c>)
240044d8:	4293      	cmp	r3, r2
240044da:	d009      	beq.n	240044f0 <HAL_DMA_IRQHandler+0x8b8>
240044dc:	687b      	ldr	r3, [r7, #4]
240044de:	681b      	ldr	r3, [r3, #0]
240044e0:	4a65      	ldr	r2, [pc, #404]	; (24004678 <HAL_DMA_IRQHandler+0xa40>)
240044e2:	4293      	cmp	r3, r2
240044e4:	d004      	beq.n	240044f0 <HAL_DMA_IRQHandler+0x8b8>
240044e6:	687b      	ldr	r3, [r7, #4]
240044e8:	681b      	ldr	r3, [r3, #0]
240044ea:	4a64      	ldr	r2, [pc, #400]	; (2400467c <HAL_DMA_IRQHandler+0xa44>)
240044ec:	4293      	cmp	r3, r2
240044ee:	d108      	bne.n	24004502 <HAL_DMA_IRQHandler+0x8ca>
240044f0:	687b      	ldr	r3, [r7, #4]
240044f2:	681b      	ldr	r3, [r3, #0]
240044f4:	681a      	ldr	r2, [r3, #0]
240044f6:	687b      	ldr	r3, [r7, #4]
240044f8:	681b      	ldr	r3, [r3, #0]
240044fa:	f022 0201 	bic.w	r2, r2, #1
240044fe:	601a      	str	r2, [r3, #0]
24004500:	e007      	b.n	24004512 <HAL_DMA_IRQHandler+0x8da>
24004502:	687b      	ldr	r3, [r7, #4]
24004504:	681b      	ldr	r3, [r3, #0]
24004506:	681a      	ldr	r2, [r3, #0]
24004508:	687b      	ldr	r3, [r7, #4]
2400450a:	681b      	ldr	r3, [r3, #0]
2400450c:	f022 0201 	bic.w	r2, r2, #1
24004510:	601a      	str	r2, [r3, #0]

        do
        {
          if (++count > timeout)
24004512:	68fb      	ldr	r3, [r7, #12]
24004514:	3301      	adds	r3, #1
24004516:	60fb      	str	r3, [r7, #12]
24004518:	6a7a      	ldr	r2, [r7, #36]	; 0x24
2400451a:	429a      	cmp	r2, r3
2400451c:	d307      	bcc.n	2400452e <HAL_DMA_IRQHandler+0x8f6>
          {
            break;
          }
        }
        while((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_EN) != 0U);
2400451e:	687b      	ldr	r3, [r7, #4]
24004520:	681b      	ldr	r3, [r3, #0]
24004522:	681b      	ldr	r3, [r3, #0]
24004524:	f003 0301 	and.w	r3, r3, #1
24004528:	2b00      	cmp	r3, #0
2400452a:	d1f2      	bne.n	24004512 <HAL_DMA_IRQHandler+0x8da>
2400452c:	e000      	b.n	24004530 <HAL_DMA_IRQHandler+0x8f8>
            break;
2400452e:	bf00      	nop

        /* Process Unlocked */
        __HAL_UNLOCK(hdma);
24004530:	687b      	ldr	r3, [r7, #4]
24004532:	2200      	movs	r2, #0
24004534:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

        if((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_EN) != 0U)
24004538:	687b      	ldr	r3, [r7, #4]
2400453a:	681b      	ldr	r3, [r3, #0]
2400453c:	681b      	ldr	r3, [r3, #0]
2400453e:	f003 0301 	and.w	r3, r3, #1
24004542:	2b00      	cmp	r3, #0
24004544:	d004      	beq.n	24004550 <HAL_DMA_IRQHandler+0x918>
        {
          /* Change the DMA state to error if DMA disable fails */
          hdma->State = HAL_DMA_STATE_ERROR;
24004546:	687b      	ldr	r3, [r7, #4]
24004548:	2203      	movs	r2, #3
2400454a:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
2400454e:	e003      	b.n	24004558 <HAL_DMA_IRQHandler+0x920>
        }
        else
        {
          /* Change the DMA state to Ready if DMA disable success */
          hdma->State = HAL_DMA_STATE_READY;
24004550:	687b      	ldr	r3, [r7, #4]
24004552:	2201      	movs	r2, #1
24004554:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
        }
      }

      if(hdma->XferErrorCallback != NULL)
24004558:	687b      	ldr	r3, [r7, #4]
2400455a:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
2400455c:	2b00      	cmp	r3, #0
2400455e:	f000 8272 	beq.w	24004a46 <HAL_DMA_IRQHandler+0xe0e>
      {
        /* Transfer error callback */
        hdma->XferErrorCallback(hdma);
24004562:	687b      	ldr	r3, [r7, #4]
24004564:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
24004566:	6878      	ldr	r0, [r7, #4]
24004568:	4798      	blx	r3
2400456a:	e26c      	b.n	24004a46 <HAL_DMA_IRQHandler+0xe0e>
      }
    }
  }
  else if(IS_BDMA_CHANNEL_INSTANCE(hdma->Instance) != 0U)  /* BDMA instance(s) */
2400456c:	687b      	ldr	r3, [r7, #4]
2400456e:	681b      	ldr	r3, [r3, #0]
24004570:	4a43      	ldr	r2, [pc, #268]	; (24004680 <HAL_DMA_IRQHandler+0xa48>)
24004572:	4293      	cmp	r3, r2
24004574:	d022      	beq.n	240045bc <HAL_DMA_IRQHandler+0x984>
24004576:	687b      	ldr	r3, [r7, #4]
24004578:	681b      	ldr	r3, [r3, #0]
2400457a:	4a42      	ldr	r2, [pc, #264]	; (24004684 <HAL_DMA_IRQHandler+0xa4c>)
2400457c:	4293      	cmp	r3, r2
2400457e:	d01d      	beq.n	240045bc <HAL_DMA_IRQHandler+0x984>
24004580:	687b      	ldr	r3, [r7, #4]
24004582:	681b      	ldr	r3, [r3, #0]
24004584:	4a40      	ldr	r2, [pc, #256]	; (24004688 <HAL_DMA_IRQHandler+0xa50>)
24004586:	4293      	cmp	r3, r2
24004588:	d018      	beq.n	240045bc <HAL_DMA_IRQHandler+0x984>
2400458a:	687b      	ldr	r3, [r7, #4]
2400458c:	681b      	ldr	r3, [r3, #0]
2400458e:	4a3f      	ldr	r2, [pc, #252]	; (2400468c <HAL_DMA_IRQHandler+0xa54>)
24004590:	4293      	cmp	r3, r2
24004592:	d013      	beq.n	240045bc <HAL_DMA_IRQHandler+0x984>
24004594:	687b      	ldr	r3, [r7, #4]
24004596:	681b      	ldr	r3, [r3, #0]
24004598:	4a3d      	ldr	r2, [pc, #244]	; (24004690 <HAL_DMA_IRQHandler+0xa58>)
2400459a:	4293      	cmp	r3, r2
2400459c:	d00e      	beq.n	240045bc <HAL_DMA_IRQHandler+0x984>
2400459e:	687b      	ldr	r3, [r7, #4]
240045a0:	681b      	ldr	r3, [r3, #0]
240045a2:	4a3c      	ldr	r2, [pc, #240]	; (24004694 <HAL_DMA_IRQHandler+0xa5c>)
240045a4:	4293      	cmp	r3, r2
240045a6:	d009      	beq.n	240045bc <HAL_DMA_IRQHandler+0x984>
240045a8:	687b      	ldr	r3, [r7, #4]
240045aa:	681b      	ldr	r3, [r3, #0]
240045ac:	4a3a      	ldr	r2, [pc, #232]	; (24004698 <HAL_DMA_IRQHandler+0xa60>)
240045ae:	4293      	cmp	r3, r2
240045b0:	d004      	beq.n	240045bc <HAL_DMA_IRQHandler+0x984>
240045b2:	687b      	ldr	r3, [r7, #4]
240045b4:	681b      	ldr	r3, [r3, #0]
240045b6:	4a39      	ldr	r2, [pc, #228]	; (2400469c <HAL_DMA_IRQHandler+0xa64>)
240045b8:	4293      	cmp	r3, r2
240045ba:	d101      	bne.n	240045c0 <HAL_DMA_IRQHandler+0x988>
240045bc:	2301      	movs	r3, #1
240045be:	e000      	b.n	240045c2 <HAL_DMA_IRQHandler+0x98a>
240045c0:	2300      	movs	r3, #0
240045c2:	2b00      	cmp	r3, #0
240045c4:	f000 823f 	beq.w	24004a46 <HAL_DMA_IRQHandler+0xe0e>
  {
    ccr_reg = (((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR);
240045c8:	687b      	ldr	r3, [r7, #4]
240045ca:	681b      	ldr	r3, [r3, #0]
240045cc:	681b      	ldr	r3, [r3, #0]
240045ce:	613b      	str	r3, [r7, #16]

    /* Half Transfer Complete Interrupt management ******************************/
    if (((tmpisr_bdma & (BDMA_FLAG_HT0 << (hdma->StreamIndex & 0x1FU))) != 0U) && ((ccr_reg & BDMA_CCR_HTIE) != 0U))
240045d0:	687b      	ldr	r3, [r7, #4]
240045d2:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
240045d4:	f003 031f 	and.w	r3, r3, #31
240045d8:	2204      	movs	r2, #4
240045da:	409a      	lsls	r2, r3
240045dc:	697b      	ldr	r3, [r7, #20]
240045de:	4013      	ands	r3, r2
240045e0:	2b00      	cmp	r3, #0
240045e2:	f000 80cd 	beq.w	24004780 <HAL_DMA_IRQHandler+0xb48>
240045e6:	693b      	ldr	r3, [r7, #16]
240045e8:	f003 0304 	and.w	r3, r3, #4
240045ec:	2b00      	cmp	r3, #0
240045ee:	f000 80c7 	beq.w	24004780 <HAL_DMA_IRQHandler+0xb48>
    {
      /* Clear the half transfer complete flag */
      regs_bdma->IFCR = (BDMA_ISR_HTIF0 << (hdma->StreamIndex & 0x1FU));
240045f2:	687b      	ldr	r3, [r7, #4]
240045f4:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
240045f6:	f003 031f 	and.w	r3, r3, #31
240045fa:	2204      	movs	r2, #4
240045fc:	409a      	lsls	r2, r3
240045fe:	69fb      	ldr	r3, [r7, #28]
24004600:	605a      	str	r2, [r3, #4]

      /* Disable the transfer complete interrupt if the DMA mode is Double Buffering */
      if((ccr_reg & BDMA_CCR_DBM) != 0U)
24004602:	693b      	ldr	r3, [r7, #16]
24004604:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
24004608:	2b00      	cmp	r3, #0
2400460a:	d049      	beq.n	240046a0 <HAL_DMA_IRQHandler+0xa68>
      {
        /* Current memory buffer used is Memory 0 */
        if((ccr_reg & BDMA_CCR_CT) == 0U)
2400460c:	693b      	ldr	r3, [r7, #16]
2400460e:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
24004612:	2b00      	cmp	r3, #0
24004614:	d109      	bne.n	2400462a <HAL_DMA_IRQHandler+0x9f2>
        {
          if(hdma->XferM1HalfCpltCallback != NULL)
24004616:	687b      	ldr	r3, [r7, #4]
24004618:	6c9b      	ldr	r3, [r3, #72]	; 0x48
2400461a:	2b00      	cmp	r3, #0
2400461c:	f000 8210 	beq.w	24004a40 <HAL_DMA_IRQHandler+0xe08>
          {
            /* Half transfer Callback for Memory 1 */
            hdma->XferM1HalfCpltCallback(hdma);
24004620:	687b      	ldr	r3, [r7, #4]
24004622:	6c9b      	ldr	r3, [r3, #72]	; 0x48
24004624:	6878      	ldr	r0, [r7, #4]
24004626:	4798      	blx	r3
      if((ccr_reg & BDMA_CCR_DBM) != 0U)
24004628:	e20a      	b.n	24004a40 <HAL_DMA_IRQHandler+0xe08>
          }
        }
        /* Current memory buffer used is Memory 1 */
        else
        {
          if(hdma->XferHalfCpltCallback != NULL)
2400462a:	687b      	ldr	r3, [r7, #4]
2400462c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
2400462e:	2b00      	cmp	r3, #0
24004630:	f000 8206 	beq.w	24004a40 <HAL_DMA_IRQHandler+0xe08>
          {
            /* Half transfer Callback for Memory 0 */
            hdma->XferHalfCpltCallback(hdma);
24004634:	687b      	ldr	r3, [r7, #4]
24004636:	6c1b      	ldr	r3, [r3, #64]	; 0x40
24004638:	6878      	ldr	r0, [r7, #4]
2400463a:	4798      	blx	r3
      if((ccr_reg & BDMA_CCR_DBM) != 0U)
2400463c:	e200      	b.n	24004a40 <HAL_DMA_IRQHandler+0xe08>
2400463e:	bf00      	nop
24004640:	40020010 	.word	0x40020010
24004644:	40020028 	.word	0x40020028
24004648:	40020040 	.word	0x40020040
2400464c:	40020058 	.word	0x40020058
24004650:	40020070 	.word	0x40020070
24004654:	40020088 	.word	0x40020088
24004658:	400200a0 	.word	0x400200a0
2400465c:	400200b8 	.word	0x400200b8
24004660:	40020410 	.word	0x40020410
24004664:	40020428 	.word	0x40020428
24004668:	40020440 	.word	0x40020440
2400466c:	40020458 	.word	0x40020458
24004670:	40020470 	.word	0x40020470
24004674:	40020488 	.word	0x40020488
24004678:	400204a0 	.word	0x400204a0
2400467c:	400204b8 	.word	0x400204b8
24004680:	58025408 	.word	0x58025408
24004684:	5802541c 	.word	0x5802541c
24004688:	58025430 	.word	0x58025430
2400468c:	58025444 	.word	0x58025444
24004690:	58025458 	.word	0x58025458
24004694:	5802546c 	.word	0x5802546c
24004698:	58025480 	.word	0x58025480
2400469c:	58025494 	.word	0x58025494
          }
        }
      }
      else
      {
        if((ccr_reg & BDMA_CCR_CIRC) == 0U)
240046a0:	693b      	ldr	r3, [r7, #16]
240046a2:	f003 0320 	and.w	r3, r3, #32
240046a6:	2b00      	cmp	r3, #0
240046a8:	d160      	bne.n	2400476c <HAL_DMA_IRQHandler+0xb34>
        {
          /* Disable the half transfer interrupt */
          __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
240046aa:	687b      	ldr	r3, [r7, #4]
240046ac:	681b      	ldr	r3, [r3, #0]
240046ae:	4a8c      	ldr	r2, [pc, #560]	; (240048e0 <HAL_DMA_IRQHandler+0xca8>)
240046b0:	4293      	cmp	r3, r2
240046b2:	d04a      	beq.n	2400474a <HAL_DMA_IRQHandler+0xb12>
240046b4:	687b      	ldr	r3, [r7, #4]
240046b6:	681b      	ldr	r3, [r3, #0]
240046b8:	4a8a      	ldr	r2, [pc, #552]	; (240048e4 <HAL_DMA_IRQHandler+0xcac>)
240046ba:	4293      	cmp	r3, r2
240046bc:	d045      	beq.n	2400474a <HAL_DMA_IRQHandler+0xb12>
240046be:	687b      	ldr	r3, [r7, #4]
240046c0:	681b      	ldr	r3, [r3, #0]
240046c2:	4a89      	ldr	r2, [pc, #548]	; (240048e8 <HAL_DMA_IRQHandler+0xcb0>)
240046c4:	4293      	cmp	r3, r2
240046c6:	d040      	beq.n	2400474a <HAL_DMA_IRQHandler+0xb12>
240046c8:	687b      	ldr	r3, [r7, #4]
240046ca:	681b      	ldr	r3, [r3, #0]
240046cc:	4a87      	ldr	r2, [pc, #540]	; (240048ec <HAL_DMA_IRQHandler+0xcb4>)
240046ce:	4293      	cmp	r3, r2
240046d0:	d03b      	beq.n	2400474a <HAL_DMA_IRQHandler+0xb12>
240046d2:	687b      	ldr	r3, [r7, #4]
240046d4:	681b      	ldr	r3, [r3, #0]
240046d6:	4a86      	ldr	r2, [pc, #536]	; (240048f0 <HAL_DMA_IRQHandler+0xcb8>)
240046d8:	4293      	cmp	r3, r2
240046da:	d036      	beq.n	2400474a <HAL_DMA_IRQHandler+0xb12>
240046dc:	687b      	ldr	r3, [r7, #4]
240046de:	681b      	ldr	r3, [r3, #0]
240046e0:	4a84      	ldr	r2, [pc, #528]	; (240048f4 <HAL_DMA_IRQHandler+0xcbc>)
240046e2:	4293      	cmp	r3, r2
240046e4:	d031      	beq.n	2400474a <HAL_DMA_IRQHandler+0xb12>
240046e6:	687b      	ldr	r3, [r7, #4]
240046e8:	681b      	ldr	r3, [r3, #0]
240046ea:	4a83      	ldr	r2, [pc, #524]	; (240048f8 <HAL_DMA_IRQHandler+0xcc0>)
240046ec:	4293      	cmp	r3, r2
240046ee:	d02c      	beq.n	2400474a <HAL_DMA_IRQHandler+0xb12>
240046f0:	687b      	ldr	r3, [r7, #4]
240046f2:	681b      	ldr	r3, [r3, #0]
240046f4:	4a81      	ldr	r2, [pc, #516]	; (240048fc <HAL_DMA_IRQHandler+0xcc4>)
240046f6:	4293      	cmp	r3, r2
240046f8:	d027      	beq.n	2400474a <HAL_DMA_IRQHandler+0xb12>
240046fa:	687b      	ldr	r3, [r7, #4]
240046fc:	681b      	ldr	r3, [r3, #0]
240046fe:	4a80      	ldr	r2, [pc, #512]	; (24004900 <HAL_DMA_IRQHandler+0xcc8>)
24004700:	4293      	cmp	r3, r2
24004702:	d022      	beq.n	2400474a <HAL_DMA_IRQHandler+0xb12>
24004704:	687b      	ldr	r3, [r7, #4]
24004706:	681b      	ldr	r3, [r3, #0]
24004708:	4a7e      	ldr	r2, [pc, #504]	; (24004904 <HAL_DMA_IRQHandler+0xccc>)
2400470a:	4293      	cmp	r3, r2
2400470c:	d01d      	beq.n	2400474a <HAL_DMA_IRQHandler+0xb12>
2400470e:	687b      	ldr	r3, [r7, #4]
24004710:	681b      	ldr	r3, [r3, #0]
24004712:	4a7d      	ldr	r2, [pc, #500]	; (24004908 <HAL_DMA_IRQHandler+0xcd0>)
24004714:	4293      	cmp	r3, r2
24004716:	d018      	beq.n	2400474a <HAL_DMA_IRQHandler+0xb12>
24004718:	687b      	ldr	r3, [r7, #4]
2400471a:	681b      	ldr	r3, [r3, #0]
2400471c:	4a7b      	ldr	r2, [pc, #492]	; (2400490c <HAL_DMA_IRQHandler+0xcd4>)
2400471e:	4293      	cmp	r3, r2
24004720:	d013      	beq.n	2400474a <HAL_DMA_IRQHandler+0xb12>
24004722:	687b      	ldr	r3, [r7, #4]
24004724:	681b      	ldr	r3, [r3, #0]
24004726:	4a7a      	ldr	r2, [pc, #488]	; (24004910 <HAL_DMA_IRQHandler+0xcd8>)
24004728:	4293      	cmp	r3, r2
2400472a:	d00e      	beq.n	2400474a <HAL_DMA_IRQHandler+0xb12>
2400472c:	687b      	ldr	r3, [r7, #4]
2400472e:	681b      	ldr	r3, [r3, #0]
24004730:	4a78      	ldr	r2, [pc, #480]	; (24004914 <HAL_DMA_IRQHandler+0xcdc>)
24004732:	4293      	cmp	r3, r2
24004734:	d009      	beq.n	2400474a <HAL_DMA_IRQHandler+0xb12>
24004736:	687b      	ldr	r3, [r7, #4]
24004738:	681b      	ldr	r3, [r3, #0]
2400473a:	4a77      	ldr	r2, [pc, #476]	; (24004918 <HAL_DMA_IRQHandler+0xce0>)
2400473c:	4293      	cmp	r3, r2
2400473e:	d004      	beq.n	2400474a <HAL_DMA_IRQHandler+0xb12>
24004740:	687b      	ldr	r3, [r7, #4]
24004742:	681b      	ldr	r3, [r3, #0]
24004744:	4a75      	ldr	r2, [pc, #468]	; (2400491c <HAL_DMA_IRQHandler+0xce4>)
24004746:	4293      	cmp	r3, r2
24004748:	d108      	bne.n	2400475c <HAL_DMA_IRQHandler+0xb24>
2400474a:	687b      	ldr	r3, [r7, #4]
2400474c:	681b      	ldr	r3, [r3, #0]
2400474e:	681a      	ldr	r2, [r3, #0]
24004750:	687b      	ldr	r3, [r7, #4]
24004752:	681b      	ldr	r3, [r3, #0]
24004754:	f022 0208 	bic.w	r2, r2, #8
24004758:	601a      	str	r2, [r3, #0]
2400475a:	e007      	b.n	2400476c <HAL_DMA_IRQHandler+0xb34>
2400475c:	687b      	ldr	r3, [r7, #4]
2400475e:	681b      	ldr	r3, [r3, #0]
24004760:	681a      	ldr	r2, [r3, #0]
24004762:	687b      	ldr	r3, [r7, #4]
24004764:	681b      	ldr	r3, [r3, #0]
24004766:	f022 0204 	bic.w	r2, r2, #4
2400476a:	601a      	str	r2, [r3, #0]
        }

        /* DMA peripheral state is not updated in Half Transfer */
        /* but in Transfer Complete case */

       if(hdma->XferHalfCpltCallback != NULL)
2400476c:	687b      	ldr	r3, [r7, #4]
2400476e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
24004770:	2b00      	cmp	r3, #0
24004772:	f000 8165 	beq.w	24004a40 <HAL_DMA_IRQHandler+0xe08>
        {
          /* Half transfer callback */
          hdma->XferHalfCpltCallback(hdma);
24004776:	687b      	ldr	r3, [r7, #4]
24004778:	6c1b      	ldr	r3, [r3, #64]	; 0x40
2400477a:	6878      	ldr	r0, [r7, #4]
2400477c:	4798      	blx	r3
      if((ccr_reg & BDMA_CCR_DBM) != 0U)
2400477e:	e15f      	b.n	24004a40 <HAL_DMA_IRQHandler+0xe08>
        }
      }
    }

    /* Transfer Complete Interrupt management ***********************************/
    else if (((tmpisr_bdma & (BDMA_FLAG_TC0 << (hdma->StreamIndex & 0x1FU))) != 0U) && ((ccr_reg & BDMA_CCR_TCIE) != 0U))
24004780:	687b      	ldr	r3, [r7, #4]
24004782:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24004784:	f003 031f 	and.w	r3, r3, #31
24004788:	2202      	movs	r2, #2
2400478a:	409a      	lsls	r2, r3
2400478c:	697b      	ldr	r3, [r7, #20]
2400478e:	4013      	ands	r3, r2
24004790:	2b00      	cmp	r3, #0
24004792:	f000 80c5 	beq.w	24004920 <HAL_DMA_IRQHandler+0xce8>
24004796:	693b      	ldr	r3, [r7, #16]
24004798:	f003 0302 	and.w	r3, r3, #2
2400479c:	2b00      	cmp	r3, #0
2400479e:	f000 80bf 	beq.w	24004920 <HAL_DMA_IRQHandler+0xce8>
    {
      /* Clear the transfer complete flag */
      regs_bdma->IFCR = (BDMA_ISR_TCIF0) << (hdma->StreamIndex & 0x1FU);
240047a2:	687b      	ldr	r3, [r7, #4]
240047a4:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
240047a6:	f003 031f 	and.w	r3, r3, #31
240047aa:	2202      	movs	r2, #2
240047ac:	409a      	lsls	r2, r3
240047ae:	69fb      	ldr	r3, [r7, #28]
240047b0:	605a      	str	r2, [r3, #4]

      /* Disable the transfer complete interrupt if the DMA mode is Double Buffering */
      if((ccr_reg & BDMA_CCR_DBM) != 0U)
240047b2:	693b      	ldr	r3, [r7, #16]
240047b4:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
240047b8:	2b00      	cmp	r3, #0
240047ba:	d018      	beq.n	240047ee <HAL_DMA_IRQHandler+0xbb6>
      {
        /* Current memory buffer used is Memory 0 */
        if((ccr_reg & BDMA_CCR_CT) == 0U)
240047bc:	693b      	ldr	r3, [r7, #16]
240047be:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
240047c2:	2b00      	cmp	r3, #0
240047c4:	d109      	bne.n	240047da <HAL_DMA_IRQHandler+0xba2>
        {
          if(hdma->XferM1CpltCallback != NULL)
240047c6:	687b      	ldr	r3, [r7, #4]
240047c8:	6c5b      	ldr	r3, [r3, #68]	; 0x44
240047ca:	2b00      	cmp	r3, #0
240047cc:	f000 813a 	beq.w	24004a44 <HAL_DMA_IRQHandler+0xe0c>
          {
            /* Transfer complete Callback for Memory 1 */
            hdma->XferM1CpltCallback(hdma);
240047d0:	687b      	ldr	r3, [r7, #4]
240047d2:	6c5b      	ldr	r3, [r3, #68]	; 0x44
240047d4:	6878      	ldr	r0, [r7, #4]
240047d6:	4798      	blx	r3
      if((ccr_reg & BDMA_CCR_DBM) != 0U)
240047d8:	e134      	b.n	24004a44 <HAL_DMA_IRQHandler+0xe0c>
          }
        }
        /* Current memory buffer used is Memory 1 */
        else
        {
          if(hdma->XferCpltCallback != NULL)
240047da:	687b      	ldr	r3, [r7, #4]
240047dc:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
240047de:	2b00      	cmp	r3, #0
240047e0:	f000 8130 	beq.w	24004a44 <HAL_DMA_IRQHandler+0xe0c>
          {
            /* Transfer complete Callback for Memory 0 */
            hdma->XferCpltCallback(hdma);
240047e4:	687b      	ldr	r3, [r7, #4]
240047e6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
240047e8:	6878      	ldr	r0, [r7, #4]
240047ea:	4798      	blx	r3
      if((ccr_reg & BDMA_CCR_DBM) != 0U)
240047ec:	e12a      	b.n	24004a44 <HAL_DMA_IRQHandler+0xe0c>
          }
        }
      }
      else
      {
        if((ccr_reg & BDMA_CCR_CIRC) == 0U)
240047ee:	693b      	ldr	r3, [r7, #16]
240047f0:	f003 0320 	and.w	r3, r3, #32
240047f4:	2b00      	cmp	r3, #0
240047f6:	d168      	bne.n	240048ca <HAL_DMA_IRQHandler+0xc92>
        {
          /* Disable the transfer complete and error interrupt, if the DMA mode is not CIRCULAR */
          __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TE | DMA_IT_TC);
240047f8:	687b      	ldr	r3, [r7, #4]
240047fa:	681b      	ldr	r3, [r3, #0]
240047fc:	4a38      	ldr	r2, [pc, #224]	; (240048e0 <HAL_DMA_IRQHandler+0xca8>)
240047fe:	4293      	cmp	r3, r2
24004800:	d04a      	beq.n	24004898 <HAL_DMA_IRQHandler+0xc60>
24004802:	687b      	ldr	r3, [r7, #4]
24004804:	681b      	ldr	r3, [r3, #0]
24004806:	4a37      	ldr	r2, [pc, #220]	; (240048e4 <HAL_DMA_IRQHandler+0xcac>)
24004808:	4293      	cmp	r3, r2
2400480a:	d045      	beq.n	24004898 <HAL_DMA_IRQHandler+0xc60>
2400480c:	687b      	ldr	r3, [r7, #4]
2400480e:	681b      	ldr	r3, [r3, #0]
24004810:	4a35      	ldr	r2, [pc, #212]	; (240048e8 <HAL_DMA_IRQHandler+0xcb0>)
24004812:	4293      	cmp	r3, r2
24004814:	d040      	beq.n	24004898 <HAL_DMA_IRQHandler+0xc60>
24004816:	687b      	ldr	r3, [r7, #4]
24004818:	681b      	ldr	r3, [r3, #0]
2400481a:	4a34      	ldr	r2, [pc, #208]	; (240048ec <HAL_DMA_IRQHandler+0xcb4>)
2400481c:	4293      	cmp	r3, r2
2400481e:	d03b      	beq.n	24004898 <HAL_DMA_IRQHandler+0xc60>
24004820:	687b      	ldr	r3, [r7, #4]
24004822:	681b      	ldr	r3, [r3, #0]
24004824:	4a32      	ldr	r2, [pc, #200]	; (240048f0 <HAL_DMA_IRQHandler+0xcb8>)
24004826:	4293      	cmp	r3, r2
24004828:	d036      	beq.n	24004898 <HAL_DMA_IRQHandler+0xc60>
2400482a:	687b      	ldr	r3, [r7, #4]
2400482c:	681b      	ldr	r3, [r3, #0]
2400482e:	4a31      	ldr	r2, [pc, #196]	; (240048f4 <HAL_DMA_IRQHandler+0xcbc>)
24004830:	4293      	cmp	r3, r2
24004832:	d031      	beq.n	24004898 <HAL_DMA_IRQHandler+0xc60>
24004834:	687b      	ldr	r3, [r7, #4]
24004836:	681b      	ldr	r3, [r3, #0]
24004838:	4a2f      	ldr	r2, [pc, #188]	; (240048f8 <HAL_DMA_IRQHandler+0xcc0>)
2400483a:	4293      	cmp	r3, r2
2400483c:	d02c      	beq.n	24004898 <HAL_DMA_IRQHandler+0xc60>
2400483e:	687b      	ldr	r3, [r7, #4]
24004840:	681b      	ldr	r3, [r3, #0]
24004842:	4a2e      	ldr	r2, [pc, #184]	; (240048fc <HAL_DMA_IRQHandler+0xcc4>)
24004844:	4293      	cmp	r3, r2
24004846:	d027      	beq.n	24004898 <HAL_DMA_IRQHandler+0xc60>
24004848:	687b      	ldr	r3, [r7, #4]
2400484a:	681b      	ldr	r3, [r3, #0]
2400484c:	4a2c      	ldr	r2, [pc, #176]	; (24004900 <HAL_DMA_IRQHandler+0xcc8>)
2400484e:	4293      	cmp	r3, r2
24004850:	d022      	beq.n	24004898 <HAL_DMA_IRQHandler+0xc60>
24004852:	687b      	ldr	r3, [r7, #4]
24004854:	681b      	ldr	r3, [r3, #0]
24004856:	4a2b      	ldr	r2, [pc, #172]	; (24004904 <HAL_DMA_IRQHandler+0xccc>)
24004858:	4293      	cmp	r3, r2
2400485a:	d01d      	beq.n	24004898 <HAL_DMA_IRQHandler+0xc60>
2400485c:	687b      	ldr	r3, [r7, #4]
2400485e:	681b      	ldr	r3, [r3, #0]
24004860:	4a29      	ldr	r2, [pc, #164]	; (24004908 <HAL_DMA_IRQHandler+0xcd0>)
24004862:	4293      	cmp	r3, r2
24004864:	d018      	beq.n	24004898 <HAL_DMA_IRQHandler+0xc60>
24004866:	687b      	ldr	r3, [r7, #4]
24004868:	681b      	ldr	r3, [r3, #0]
2400486a:	4a28      	ldr	r2, [pc, #160]	; (2400490c <HAL_DMA_IRQHandler+0xcd4>)
2400486c:	4293      	cmp	r3, r2
2400486e:	d013      	beq.n	24004898 <HAL_DMA_IRQHandler+0xc60>
24004870:	687b      	ldr	r3, [r7, #4]
24004872:	681b      	ldr	r3, [r3, #0]
24004874:	4a26      	ldr	r2, [pc, #152]	; (24004910 <HAL_DMA_IRQHandler+0xcd8>)
24004876:	4293      	cmp	r3, r2
24004878:	d00e      	beq.n	24004898 <HAL_DMA_IRQHandler+0xc60>
2400487a:	687b      	ldr	r3, [r7, #4]
2400487c:	681b      	ldr	r3, [r3, #0]
2400487e:	4a25      	ldr	r2, [pc, #148]	; (24004914 <HAL_DMA_IRQHandler+0xcdc>)
24004880:	4293      	cmp	r3, r2
24004882:	d009      	beq.n	24004898 <HAL_DMA_IRQHandler+0xc60>
24004884:	687b      	ldr	r3, [r7, #4]
24004886:	681b      	ldr	r3, [r3, #0]
24004888:	4a23      	ldr	r2, [pc, #140]	; (24004918 <HAL_DMA_IRQHandler+0xce0>)
2400488a:	4293      	cmp	r3, r2
2400488c:	d004      	beq.n	24004898 <HAL_DMA_IRQHandler+0xc60>
2400488e:	687b      	ldr	r3, [r7, #4]
24004890:	681b      	ldr	r3, [r3, #0]
24004892:	4a22      	ldr	r2, [pc, #136]	; (2400491c <HAL_DMA_IRQHandler+0xce4>)
24004894:	4293      	cmp	r3, r2
24004896:	d108      	bne.n	240048aa <HAL_DMA_IRQHandler+0xc72>
24004898:	687b      	ldr	r3, [r7, #4]
2400489a:	681b      	ldr	r3, [r3, #0]
2400489c:	681a      	ldr	r2, [r3, #0]
2400489e:	687b      	ldr	r3, [r7, #4]
240048a0:	681b      	ldr	r3, [r3, #0]
240048a2:	f022 0214 	bic.w	r2, r2, #20
240048a6:	601a      	str	r2, [r3, #0]
240048a8:	e007      	b.n	240048ba <HAL_DMA_IRQHandler+0xc82>
240048aa:	687b      	ldr	r3, [r7, #4]
240048ac:	681b      	ldr	r3, [r3, #0]
240048ae:	681a      	ldr	r2, [r3, #0]
240048b0:	687b      	ldr	r3, [r7, #4]
240048b2:	681b      	ldr	r3, [r3, #0]
240048b4:	f022 020a 	bic.w	r2, r2, #10
240048b8:	601a      	str	r2, [r3, #0]

          /* Process Unlocked */
          __HAL_UNLOCK(hdma);
240048ba:	687b      	ldr	r3, [r7, #4]
240048bc:	2200      	movs	r2, #0
240048be:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

          /* Change the DMA state */
          hdma->State = HAL_DMA_STATE_READY;
240048c2:	687b      	ldr	r3, [r7, #4]
240048c4:	2201      	movs	r2, #1
240048c6:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
        }

        if(hdma->XferCpltCallback != NULL)
240048ca:	687b      	ldr	r3, [r7, #4]
240048cc:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
240048ce:	2b00      	cmp	r3, #0
240048d0:	f000 80b8 	beq.w	24004a44 <HAL_DMA_IRQHandler+0xe0c>
        {
          /* Transfer complete callback */
          hdma->XferCpltCallback(hdma);
240048d4:	687b      	ldr	r3, [r7, #4]
240048d6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
240048d8:	6878      	ldr	r0, [r7, #4]
240048da:	4798      	blx	r3
      if((ccr_reg & BDMA_CCR_DBM) != 0U)
240048dc:	e0b2      	b.n	24004a44 <HAL_DMA_IRQHandler+0xe0c>
240048de:	bf00      	nop
240048e0:	40020010 	.word	0x40020010
240048e4:	40020028 	.word	0x40020028
240048e8:	40020040 	.word	0x40020040
240048ec:	40020058 	.word	0x40020058
240048f0:	40020070 	.word	0x40020070
240048f4:	40020088 	.word	0x40020088
240048f8:	400200a0 	.word	0x400200a0
240048fc:	400200b8 	.word	0x400200b8
24004900:	40020410 	.word	0x40020410
24004904:	40020428 	.word	0x40020428
24004908:	40020440 	.word	0x40020440
2400490c:	40020458 	.word	0x40020458
24004910:	40020470 	.word	0x40020470
24004914:	40020488 	.word	0x40020488
24004918:	400204a0 	.word	0x400204a0
2400491c:	400204b8 	.word	0x400204b8
        }
      }
    }
    /* Transfer Error Interrupt management **************************************/
    else if (((tmpisr_bdma & (BDMA_FLAG_TE0 << (hdma->StreamIndex & 0x1FU))) != 0U) && ((ccr_reg & BDMA_CCR_TEIE) != 0U))
24004920:	687b      	ldr	r3, [r7, #4]
24004922:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24004924:	f003 031f 	and.w	r3, r3, #31
24004928:	2208      	movs	r2, #8
2400492a:	409a      	lsls	r2, r3
2400492c:	697b      	ldr	r3, [r7, #20]
2400492e:	4013      	ands	r3, r2
24004930:	2b00      	cmp	r3, #0
24004932:	f000 8088 	beq.w	24004a46 <HAL_DMA_IRQHandler+0xe0e>
24004936:	693b      	ldr	r3, [r7, #16]
24004938:	f003 0308 	and.w	r3, r3, #8
2400493c:	2b00      	cmp	r3, #0
2400493e:	f000 8082 	beq.w	24004a46 <HAL_DMA_IRQHandler+0xe0e>
    {
      /* When a DMA transfer error occurs */
      /* A hardware clear of its EN bits is performed */
      /* Disable ALL DMA IT */
      __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
24004942:	687b      	ldr	r3, [r7, #4]
24004944:	681b      	ldr	r3, [r3, #0]
24004946:	4a41      	ldr	r2, [pc, #260]	; (24004a4c <HAL_DMA_IRQHandler+0xe14>)
24004948:	4293      	cmp	r3, r2
2400494a:	d04a      	beq.n	240049e2 <HAL_DMA_IRQHandler+0xdaa>
2400494c:	687b      	ldr	r3, [r7, #4]
2400494e:	681b      	ldr	r3, [r3, #0]
24004950:	4a3f      	ldr	r2, [pc, #252]	; (24004a50 <HAL_DMA_IRQHandler+0xe18>)
24004952:	4293      	cmp	r3, r2
24004954:	d045      	beq.n	240049e2 <HAL_DMA_IRQHandler+0xdaa>
24004956:	687b      	ldr	r3, [r7, #4]
24004958:	681b      	ldr	r3, [r3, #0]
2400495a:	4a3e      	ldr	r2, [pc, #248]	; (24004a54 <HAL_DMA_IRQHandler+0xe1c>)
2400495c:	4293      	cmp	r3, r2
2400495e:	d040      	beq.n	240049e2 <HAL_DMA_IRQHandler+0xdaa>
24004960:	687b      	ldr	r3, [r7, #4]
24004962:	681b      	ldr	r3, [r3, #0]
24004964:	4a3c      	ldr	r2, [pc, #240]	; (24004a58 <HAL_DMA_IRQHandler+0xe20>)
24004966:	4293      	cmp	r3, r2
24004968:	d03b      	beq.n	240049e2 <HAL_DMA_IRQHandler+0xdaa>
2400496a:	687b      	ldr	r3, [r7, #4]
2400496c:	681b      	ldr	r3, [r3, #0]
2400496e:	4a3b      	ldr	r2, [pc, #236]	; (24004a5c <HAL_DMA_IRQHandler+0xe24>)
24004970:	4293      	cmp	r3, r2
24004972:	d036      	beq.n	240049e2 <HAL_DMA_IRQHandler+0xdaa>
24004974:	687b      	ldr	r3, [r7, #4]
24004976:	681b      	ldr	r3, [r3, #0]
24004978:	4a39      	ldr	r2, [pc, #228]	; (24004a60 <HAL_DMA_IRQHandler+0xe28>)
2400497a:	4293      	cmp	r3, r2
2400497c:	d031      	beq.n	240049e2 <HAL_DMA_IRQHandler+0xdaa>
2400497e:	687b      	ldr	r3, [r7, #4]
24004980:	681b      	ldr	r3, [r3, #0]
24004982:	4a38      	ldr	r2, [pc, #224]	; (24004a64 <HAL_DMA_IRQHandler+0xe2c>)
24004984:	4293      	cmp	r3, r2
24004986:	d02c      	beq.n	240049e2 <HAL_DMA_IRQHandler+0xdaa>
24004988:	687b      	ldr	r3, [r7, #4]
2400498a:	681b      	ldr	r3, [r3, #0]
2400498c:	4a36      	ldr	r2, [pc, #216]	; (24004a68 <HAL_DMA_IRQHandler+0xe30>)
2400498e:	4293      	cmp	r3, r2
24004990:	d027      	beq.n	240049e2 <HAL_DMA_IRQHandler+0xdaa>
24004992:	687b      	ldr	r3, [r7, #4]
24004994:	681b      	ldr	r3, [r3, #0]
24004996:	4a35      	ldr	r2, [pc, #212]	; (24004a6c <HAL_DMA_IRQHandler+0xe34>)
24004998:	4293      	cmp	r3, r2
2400499a:	d022      	beq.n	240049e2 <HAL_DMA_IRQHandler+0xdaa>
2400499c:	687b      	ldr	r3, [r7, #4]
2400499e:	681b      	ldr	r3, [r3, #0]
240049a0:	4a33      	ldr	r2, [pc, #204]	; (24004a70 <HAL_DMA_IRQHandler+0xe38>)
240049a2:	4293      	cmp	r3, r2
240049a4:	d01d      	beq.n	240049e2 <HAL_DMA_IRQHandler+0xdaa>
240049a6:	687b      	ldr	r3, [r7, #4]
240049a8:	681b      	ldr	r3, [r3, #0]
240049aa:	4a32      	ldr	r2, [pc, #200]	; (24004a74 <HAL_DMA_IRQHandler+0xe3c>)
240049ac:	4293      	cmp	r3, r2
240049ae:	d018      	beq.n	240049e2 <HAL_DMA_IRQHandler+0xdaa>
240049b0:	687b      	ldr	r3, [r7, #4]
240049b2:	681b      	ldr	r3, [r3, #0]
240049b4:	4a30      	ldr	r2, [pc, #192]	; (24004a78 <HAL_DMA_IRQHandler+0xe40>)
240049b6:	4293      	cmp	r3, r2
240049b8:	d013      	beq.n	240049e2 <HAL_DMA_IRQHandler+0xdaa>
240049ba:	687b      	ldr	r3, [r7, #4]
240049bc:	681b      	ldr	r3, [r3, #0]
240049be:	4a2f      	ldr	r2, [pc, #188]	; (24004a7c <HAL_DMA_IRQHandler+0xe44>)
240049c0:	4293      	cmp	r3, r2
240049c2:	d00e      	beq.n	240049e2 <HAL_DMA_IRQHandler+0xdaa>
240049c4:	687b      	ldr	r3, [r7, #4]
240049c6:	681b      	ldr	r3, [r3, #0]
240049c8:	4a2d      	ldr	r2, [pc, #180]	; (24004a80 <HAL_DMA_IRQHandler+0xe48>)
240049ca:	4293      	cmp	r3, r2
240049cc:	d009      	beq.n	240049e2 <HAL_DMA_IRQHandler+0xdaa>
240049ce:	687b      	ldr	r3, [r7, #4]
240049d0:	681b      	ldr	r3, [r3, #0]
240049d2:	4a2c      	ldr	r2, [pc, #176]	; (24004a84 <HAL_DMA_IRQHandler+0xe4c>)
240049d4:	4293      	cmp	r3, r2
240049d6:	d004      	beq.n	240049e2 <HAL_DMA_IRQHandler+0xdaa>
240049d8:	687b      	ldr	r3, [r7, #4]
240049da:	681b      	ldr	r3, [r3, #0]
240049dc:	4a2a      	ldr	r2, [pc, #168]	; (24004a88 <HAL_DMA_IRQHandler+0xe50>)
240049de:	4293      	cmp	r3, r2
240049e0:	d108      	bne.n	240049f4 <HAL_DMA_IRQHandler+0xdbc>
240049e2:	687b      	ldr	r3, [r7, #4]
240049e4:	681b      	ldr	r3, [r3, #0]
240049e6:	681a      	ldr	r2, [r3, #0]
240049e8:	687b      	ldr	r3, [r7, #4]
240049ea:	681b      	ldr	r3, [r3, #0]
240049ec:	f022 021c 	bic.w	r2, r2, #28
240049f0:	601a      	str	r2, [r3, #0]
240049f2:	e007      	b.n	24004a04 <HAL_DMA_IRQHandler+0xdcc>
240049f4:	687b      	ldr	r3, [r7, #4]
240049f6:	681b      	ldr	r3, [r3, #0]
240049f8:	681a      	ldr	r2, [r3, #0]
240049fa:	687b      	ldr	r3, [r7, #4]
240049fc:	681b      	ldr	r3, [r3, #0]
240049fe:	f022 020e 	bic.w	r2, r2, #14
24004a02:	601a      	str	r2, [r3, #0]

      /* Clear all flags */
      regs_bdma->IFCR = (BDMA_ISR_GIF0) << (hdma->StreamIndex & 0x1FU);
24004a04:	687b      	ldr	r3, [r7, #4]
24004a06:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24004a08:	f003 031f 	and.w	r3, r3, #31
24004a0c:	2201      	movs	r2, #1
24004a0e:	409a      	lsls	r2, r3
24004a10:	69fb      	ldr	r3, [r7, #28]
24004a12:	605a      	str	r2, [r3, #4]

      /* Update error code */
      hdma->ErrorCode = HAL_DMA_ERROR_TE;
24004a14:	687b      	ldr	r3, [r7, #4]
24004a16:	2201      	movs	r2, #1
24004a18:	655a      	str	r2, [r3, #84]	; 0x54

      /* Process Unlocked */
      __HAL_UNLOCK(hdma);
24004a1a:	687b      	ldr	r3, [r7, #4]
24004a1c:	2200      	movs	r2, #0
24004a1e:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

      /* Change the DMA state */
      hdma->State = HAL_DMA_STATE_READY;
24004a22:	687b      	ldr	r3, [r7, #4]
24004a24:	2201      	movs	r2, #1
24004a26:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

      if (hdma->XferErrorCallback != NULL)
24004a2a:	687b      	ldr	r3, [r7, #4]
24004a2c:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
24004a2e:	2b00      	cmp	r3, #0
24004a30:	d009      	beq.n	24004a46 <HAL_DMA_IRQHandler+0xe0e>
      {
        /* Transfer error callback */
        hdma->XferErrorCallback(hdma);
24004a32:	687b      	ldr	r3, [r7, #4]
24004a34:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
24004a36:	6878      	ldr	r0, [r7, #4]
24004a38:	4798      	blx	r3
24004a3a:	e004      	b.n	24004a46 <HAL_DMA_IRQHandler+0xe0e>
          return;
24004a3c:	bf00      	nop
24004a3e:	e002      	b.n	24004a46 <HAL_DMA_IRQHandler+0xe0e>
      if((ccr_reg & BDMA_CCR_DBM) != 0U)
24004a40:	bf00      	nop
24004a42:	e000      	b.n	24004a46 <HAL_DMA_IRQHandler+0xe0e>
      if((ccr_reg & BDMA_CCR_DBM) != 0U)
24004a44:	bf00      	nop
  }
  else
  {
    /* Nothing To Do */
  }
}
24004a46:	3728      	adds	r7, #40	; 0x28
24004a48:	46bd      	mov	sp, r7
24004a4a:	bd80      	pop	{r7, pc}
24004a4c:	40020010 	.word	0x40020010
24004a50:	40020028 	.word	0x40020028
24004a54:	40020040 	.word	0x40020040
24004a58:	40020058 	.word	0x40020058
24004a5c:	40020070 	.word	0x40020070
24004a60:	40020088 	.word	0x40020088
24004a64:	400200a0 	.word	0x400200a0
24004a68:	400200b8 	.word	0x400200b8
24004a6c:	40020410 	.word	0x40020410
24004a70:	40020428 	.word	0x40020428
24004a74:	40020440 	.word	0x40020440
24004a78:	40020458 	.word	0x40020458
24004a7c:	40020470 	.word	0x40020470
24004a80:	40020488 	.word	0x40020488
24004a84:	400204a0 	.word	0x400204a0
24004a88:	400204b8 	.word	0x400204b8

24004a8c <HAL_DMA_RegisterCallback>:
  * @param  pCallback:            pointer to private callback function which has pointer to
  *                               a DMA_HandleTypeDef structure as parameter.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_RegisterCallback(DMA_HandleTypeDef *hdma, HAL_DMA_CallbackIDTypeDef CallbackID, void (* pCallback)(DMA_HandleTypeDef *_hdma))
{
24004a8c:	b480      	push	{r7}
24004a8e:	b087      	sub	sp, #28
24004a90:	af00      	add	r7, sp, #0
24004a92:	60f8      	str	r0, [r7, #12]
24004a94:	460b      	mov	r3, r1
24004a96:	607a      	str	r2, [r7, #4]
24004a98:	72fb      	strb	r3, [r7, #11]

  HAL_StatusTypeDef status = HAL_OK;
24004a9a:	2300      	movs	r3, #0
24004a9c:	75fb      	strb	r3, [r7, #23]

  /* Check the DMA peripheral handle */
  if(hdma == NULL)
24004a9e:	68fb      	ldr	r3, [r7, #12]
24004aa0:	2b00      	cmp	r3, #0
24004aa2:	d101      	bne.n	24004aa8 <HAL_DMA_RegisterCallback+0x1c>
  {
    return HAL_ERROR;
24004aa4:	2301      	movs	r3, #1
24004aa6:	e044      	b.n	24004b32 <HAL_DMA_RegisterCallback+0xa6>
  }

  /* Process locked */
  __HAL_LOCK(hdma);
24004aa8:	68fb      	ldr	r3, [r7, #12]
24004aaa:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
24004aae:	2b01      	cmp	r3, #1
24004ab0:	d101      	bne.n	24004ab6 <HAL_DMA_RegisterCallback+0x2a>
24004ab2:	2302      	movs	r3, #2
24004ab4:	e03d      	b.n	24004b32 <HAL_DMA_RegisterCallback+0xa6>
24004ab6:	68fb      	ldr	r3, [r7, #12]
24004ab8:	2201      	movs	r2, #1
24004aba:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

  if(HAL_DMA_STATE_READY == hdma->State)
24004abe:	68fb      	ldr	r3, [r7, #12]
24004ac0:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
24004ac4:	b2db      	uxtb	r3, r3
24004ac6:	2b01      	cmp	r3, #1
24004ac8:	d12a      	bne.n	24004b20 <HAL_DMA_RegisterCallback+0x94>
  {
    switch (CallbackID)
24004aca:	7afb      	ldrb	r3, [r7, #11]
24004acc:	2b05      	cmp	r3, #5
24004ace:	d82a      	bhi.n	24004b26 <HAL_DMA_RegisterCallback+0x9a>
24004ad0:	a201      	add	r2, pc, #4	; (adr r2, 24004ad8 <HAL_DMA_RegisterCallback+0x4c>)
24004ad2:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
24004ad6:	bf00      	nop
24004ad8:	24004af1 	.word	0x24004af1
24004adc:	24004af9 	.word	0x24004af9
24004ae0:	24004b01 	.word	0x24004b01
24004ae4:	24004b09 	.word	0x24004b09
24004ae8:	24004b11 	.word	0x24004b11
24004aec:	24004b19 	.word	0x24004b19
    {
    case  HAL_DMA_XFER_CPLT_CB_ID:
      hdma->XferCpltCallback = pCallback;
24004af0:	68fb      	ldr	r3, [r7, #12]
24004af2:	687a      	ldr	r2, [r7, #4]
24004af4:	63da      	str	r2, [r3, #60]	; 0x3c
      break;
24004af6:	e017      	b.n	24004b28 <HAL_DMA_RegisterCallback+0x9c>

    case  HAL_DMA_XFER_HALFCPLT_CB_ID:
      hdma->XferHalfCpltCallback = pCallback;
24004af8:	68fb      	ldr	r3, [r7, #12]
24004afa:	687a      	ldr	r2, [r7, #4]
24004afc:	641a      	str	r2, [r3, #64]	; 0x40
      break;
24004afe:	e013      	b.n	24004b28 <HAL_DMA_RegisterCallback+0x9c>

    case  HAL_DMA_XFER_M1CPLT_CB_ID:
      hdma->XferM1CpltCallback = pCallback;
24004b00:	68fb      	ldr	r3, [r7, #12]
24004b02:	687a      	ldr	r2, [r7, #4]
24004b04:	645a      	str	r2, [r3, #68]	; 0x44
      break;
24004b06:	e00f      	b.n	24004b28 <HAL_DMA_RegisterCallback+0x9c>

    case  HAL_DMA_XFER_M1HALFCPLT_CB_ID:
      hdma->XferM1HalfCpltCallback = pCallback;
24004b08:	68fb      	ldr	r3, [r7, #12]
24004b0a:	687a      	ldr	r2, [r7, #4]
24004b0c:	649a      	str	r2, [r3, #72]	; 0x48
      break;
24004b0e:	e00b      	b.n	24004b28 <HAL_DMA_RegisterCallback+0x9c>

    case  HAL_DMA_XFER_ERROR_CB_ID:
      hdma->XferErrorCallback = pCallback;
24004b10:	68fb      	ldr	r3, [r7, #12]
24004b12:	687a      	ldr	r2, [r7, #4]
24004b14:	64da      	str	r2, [r3, #76]	; 0x4c
      break;
24004b16:	e007      	b.n	24004b28 <HAL_DMA_RegisterCallback+0x9c>

    case  HAL_DMA_XFER_ABORT_CB_ID:
      hdma->XferAbortCallback = pCallback;
24004b18:	68fb      	ldr	r3, [r7, #12]
24004b1a:	687a      	ldr	r2, [r7, #4]
24004b1c:	651a      	str	r2, [r3, #80]	; 0x50
      break;
24004b1e:	e003      	b.n	24004b28 <HAL_DMA_RegisterCallback+0x9c>
    }
  }
  else
  {
    /* Return error status */
    status =  HAL_ERROR;
24004b20:	2301      	movs	r3, #1
24004b22:	75fb      	strb	r3, [r7, #23]
24004b24:	e000      	b.n	24004b28 <HAL_DMA_RegisterCallback+0x9c>
      break;
24004b26:	bf00      	nop
  }

  /* Release Lock */
  __HAL_UNLOCK(hdma);
24004b28:	68fb      	ldr	r3, [r7, #12]
24004b2a:	2200      	movs	r2, #0
24004b2c:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

  return status;
24004b30:	7dfb      	ldrb	r3, [r7, #23]
}
24004b32:	4618      	mov	r0, r3
24004b34:	371c      	adds	r7, #28
24004b36:	46bd      	mov	sp, r7
24004b38:	f85d 7b04 	ldr.w	r7, [sp], #4
24004b3c:	4770      	bx	lr
24004b3e:	bf00      	nop

24004b40 <HAL_DMA_UnRegisterCallback>:
  * @param  CallbackID:           User Callback identifier
  *                               a HAL_DMA_CallbackIDTypeDef ENUM as parameter.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_UnRegisterCallback(DMA_HandleTypeDef *hdma, HAL_DMA_CallbackIDTypeDef CallbackID)
{
24004b40:	b480      	push	{r7}
24004b42:	b085      	sub	sp, #20
24004b44:	af00      	add	r7, sp, #0
24004b46:	6078      	str	r0, [r7, #4]
24004b48:	460b      	mov	r3, r1
24004b4a:	70fb      	strb	r3, [r7, #3]
  HAL_StatusTypeDef status = HAL_OK;
24004b4c:	2300      	movs	r3, #0
24004b4e:	73fb      	strb	r3, [r7, #15]

  /* Check the DMA peripheral handle */
  if(hdma == NULL)
24004b50:	687b      	ldr	r3, [r7, #4]
24004b52:	2b00      	cmp	r3, #0
24004b54:	d101      	bne.n	24004b5a <HAL_DMA_UnRegisterCallback+0x1a>
  {
    return HAL_ERROR;
24004b56:	2301      	movs	r3, #1
24004b58:	e05a      	b.n	24004c10 <HAL_DMA_UnRegisterCallback+0xd0>
  }

  /* Process locked */
  __HAL_LOCK(hdma);
24004b5a:	687b      	ldr	r3, [r7, #4]
24004b5c:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
24004b60:	2b01      	cmp	r3, #1
24004b62:	d101      	bne.n	24004b68 <HAL_DMA_UnRegisterCallback+0x28>
24004b64:	2302      	movs	r3, #2
24004b66:	e053      	b.n	24004c10 <HAL_DMA_UnRegisterCallback+0xd0>
24004b68:	687b      	ldr	r3, [r7, #4]
24004b6a:	2201      	movs	r2, #1
24004b6c:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

  if(HAL_DMA_STATE_READY == hdma->State)
24004b70:	687b      	ldr	r3, [r7, #4]
24004b72:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
24004b76:	b2db      	uxtb	r3, r3
24004b78:	2b01      	cmp	r3, #1
24004b7a:	d142      	bne.n	24004c02 <HAL_DMA_UnRegisterCallback+0xc2>
  {
    switch (CallbackID)
24004b7c:	78fb      	ldrb	r3, [r7, #3]
24004b7e:	2b06      	cmp	r3, #6
24004b80:	d83b      	bhi.n	24004bfa <HAL_DMA_UnRegisterCallback+0xba>
24004b82:	a201      	add	r2, pc, #4	; (adr r2, 24004b88 <HAL_DMA_UnRegisterCallback+0x48>)
24004b84:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
24004b88:	24004ba5 	.word	0x24004ba5
24004b8c:	24004bad 	.word	0x24004bad
24004b90:	24004bb5 	.word	0x24004bb5
24004b94:	24004bbd 	.word	0x24004bbd
24004b98:	24004bc5 	.word	0x24004bc5
24004b9c:	24004bcd 	.word	0x24004bcd
24004ba0:	24004bd5 	.word	0x24004bd5
    {
    case  HAL_DMA_XFER_CPLT_CB_ID:
      hdma->XferCpltCallback = NULL;
24004ba4:	687b      	ldr	r3, [r7, #4]
24004ba6:	2200      	movs	r2, #0
24004ba8:	63da      	str	r2, [r3, #60]	; 0x3c
      break;
24004baa:	e02c      	b.n	24004c06 <HAL_DMA_UnRegisterCallback+0xc6>

    case  HAL_DMA_XFER_HALFCPLT_CB_ID:
      hdma->XferHalfCpltCallback = NULL;
24004bac:	687b      	ldr	r3, [r7, #4]
24004bae:	2200      	movs	r2, #0
24004bb0:	641a      	str	r2, [r3, #64]	; 0x40
      break;
24004bb2:	e028      	b.n	24004c06 <HAL_DMA_UnRegisterCallback+0xc6>

    case  HAL_DMA_XFER_M1CPLT_CB_ID:
      hdma->XferM1CpltCallback = NULL;
24004bb4:	687b      	ldr	r3, [r7, #4]
24004bb6:	2200      	movs	r2, #0
24004bb8:	645a      	str	r2, [r3, #68]	; 0x44
      break;
24004bba:	e024      	b.n	24004c06 <HAL_DMA_UnRegisterCallback+0xc6>

    case  HAL_DMA_XFER_M1HALFCPLT_CB_ID:
      hdma->XferM1HalfCpltCallback = NULL;
24004bbc:	687b      	ldr	r3, [r7, #4]
24004bbe:	2200      	movs	r2, #0
24004bc0:	649a      	str	r2, [r3, #72]	; 0x48
      break;
24004bc2:	e020      	b.n	24004c06 <HAL_DMA_UnRegisterCallback+0xc6>

    case  HAL_DMA_XFER_ERROR_CB_ID:
      hdma->XferErrorCallback = NULL;
24004bc4:	687b      	ldr	r3, [r7, #4]
24004bc6:	2200      	movs	r2, #0
24004bc8:	64da      	str	r2, [r3, #76]	; 0x4c
      break;
24004bca:	e01c      	b.n	24004c06 <HAL_DMA_UnRegisterCallback+0xc6>

    case  HAL_DMA_XFER_ABORT_CB_ID:
      hdma->XferAbortCallback = NULL;
24004bcc:	687b      	ldr	r3, [r7, #4]
24004bce:	2200      	movs	r2, #0
24004bd0:	651a      	str	r2, [r3, #80]	; 0x50
      break;
24004bd2:	e018      	b.n	24004c06 <HAL_DMA_UnRegisterCallback+0xc6>

    case   HAL_DMA_XFER_ALL_CB_ID:
      hdma->XferCpltCallback = NULL;
24004bd4:	687b      	ldr	r3, [r7, #4]
24004bd6:	2200      	movs	r2, #0
24004bd8:	63da      	str	r2, [r3, #60]	; 0x3c
      hdma->XferHalfCpltCallback = NULL;
24004bda:	687b      	ldr	r3, [r7, #4]
24004bdc:	2200      	movs	r2, #0
24004bde:	641a      	str	r2, [r3, #64]	; 0x40
      hdma->XferM1CpltCallback = NULL;
24004be0:	687b      	ldr	r3, [r7, #4]
24004be2:	2200      	movs	r2, #0
24004be4:	645a      	str	r2, [r3, #68]	; 0x44
      hdma->XferM1HalfCpltCallback = NULL;
24004be6:	687b      	ldr	r3, [r7, #4]
24004be8:	2200      	movs	r2, #0
24004bea:	649a      	str	r2, [r3, #72]	; 0x48
      hdma->XferErrorCallback = NULL;
24004bec:	687b      	ldr	r3, [r7, #4]
24004bee:	2200      	movs	r2, #0
24004bf0:	64da      	str	r2, [r3, #76]	; 0x4c
      hdma->XferAbortCallback = NULL;
24004bf2:	687b      	ldr	r3, [r7, #4]
24004bf4:	2200      	movs	r2, #0
24004bf6:	651a      	str	r2, [r3, #80]	; 0x50
      break;
24004bf8:	e005      	b.n	24004c06 <HAL_DMA_UnRegisterCallback+0xc6>

    default:
      status = HAL_ERROR;
24004bfa:	2301      	movs	r3, #1
24004bfc:	73fb      	strb	r3, [r7, #15]
      break;
24004bfe:	bf00      	nop
24004c00:	e001      	b.n	24004c06 <HAL_DMA_UnRegisterCallback+0xc6>
    }
  }
  else
  {
    status = HAL_ERROR;
24004c02:	2301      	movs	r3, #1
24004c04:	73fb      	strb	r3, [r7, #15]
  }

  /* Release Lock */
  __HAL_UNLOCK(hdma);
24004c06:	687b      	ldr	r3, [r7, #4]
24004c08:	2200      	movs	r2, #0
24004c0a:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

  return status;
24004c0e:	7bfb      	ldrb	r3, [r7, #15]
}
24004c10:	4618      	mov	r0, r3
24004c12:	3714      	adds	r7, #20
24004c14:	46bd      	mov	sp, r7
24004c16:	f85d 7b04 	ldr.w	r7, [sp], #4
24004c1a:	4770      	bx	lr

24004c1c <HAL_DMA_GetState>:
  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Stream.
  * @retval HAL state
  */
HAL_DMA_StateTypeDef HAL_DMA_GetState(DMA_HandleTypeDef *hdma)
{
24004c1c:	b480      	push	{r7}
24004c1e:	b083      	sub	sp, #12
24004c20:	af00      	add	r7, sp, #0
24004c22:	6078      	str	r0, [r7, #4]
  return hdma->State;
24004c24:	687b      	ldr	r3, [r7, #4]
24004c26:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
24004c2a:	b2db      	uxtb	r3, r3
}
24004c2c:	4618      	mov	r0, r3
24004c2e:	370c      	adds	r7, #12
24004c30:	46bd      	mov	sp, r7
24004c32:	f85d 7b04 	ldr.w	r7, [sp], #4
24004c36:	4770      	bx	lr

24004c38 <HAL_DMA_GetError>:
  * @param  hdma : pointer to a DMA_HandleTypeDef structure that contains
  *              the configuration information for the specified DMA Stream.
  * @retval DMA Error Code
  */
uint32_t HAL_DMA_GetError(DMA_HandleTypeDef *hdma)
{
24004c38:	b480      	push	{r7}
24004c3a:	b083      	sub	sp, #12
24004c3c:	af00      	add	r7, sp, #0
24004c3e:	6078      	str	r0, [r7, #4]
  return hdma->ErrorCode;
24004c40:	687b      	ldr	r3, [r7, #4]
24004c42:	6d5b      	ldr	r3, [r3, #84]	; 0x54
}
24004c44:	4618      	mov	r0, r3
24004c46:	370c      	adds	r7, #12
24004c48:	46bd      	mov	sp, r7
24004c4a:	f85d 7b04 	ldr.w	r7, [sp], #4
24004c4e:	4770      	bx	lr

24004c50 <DMA_SetConfig>:
  * @param  DstAddress: The destination memory Buffer address
  * @param  DataLength: The length of data to be transferred from source to destination
  * @retval None
  */
static void DMA_SetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{
24004c50:	b480      	push	{r7}
24004c52:	b087      	sub	sp, #28
24004c54:	af00      	add	r7, sp, #0
24004c56:	60f8      	str	r0, [r7, #12]
24004c58:	60b9      	str	r1, [r7, #8]
24004c5a:	607a      	str	r2, [r7, #4]
24004c5c:	603b      	str	r3, [r7, #0]
  /* calculate DMA base and stream number */
  DMA_Base_Registers  *regs_dma  = (DMA_Base_Registers *)hdma->StreamBaseAddress;
24004c5e:	68fb      	ldr	r3, [r7, #12]
24004c60:	6d9b      	ldr	r3, [r3, #88]	; 0x58
24004c62:	617b      	str	r3, [r7, #20]
  BDMA_Base_Registers *regs_bdma = (BDMA_Base_Registers *)hdma->StreamBaseAddress;
24004c64:	68fb      	ldr	r3, [r7, #12]
24004c66:	6d9b      	ldr	r3, [r3, #88]	; 0x58
24004c68:	613b      	str	r3, [r7, #16]

  if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
24004c6a:	68fb      	ldr	r3, [r7, #12]
24004c6c:	681b      	ldr	r3, [r3, #0]
24004c6e:	4a84      	ldr	r2, [pc, #528]	; (24004e80 <DMA_SetConfig+0x230>)
24004c70:	4293      	cmp	r3, r2
24004c72:	d072      	beq.n	24004d5a <DMA_SetConfig+0x10a>
24004c74:	68fb      	ldr	r3, [r7, #12]
24004c76:	681b      	ldr	r3, [r3, #0]
24004c78:	4a82      	ldr	r2, [pc, #520]	; (24004e84 <DMA_SetConfig+0x234>)
24004c7a:	4293      	cmp	r3, r2
24004c7c:	d06d      	beq.n	24004d5a <DMA_SetConfig+0x10a>
24004c7e:	68fb      	ldr	r3, [r7, #12]
24004c80:	681b      	ldr	r3, [r3, #0]
24004c82:	4a81      	ldr	r2, [pc, #516]	; (24004e88 <DMA_SetConfig+0x238>)
24004c84:	4293      	cmp	r3, r2
24004c86:	d068      	beq.n	24004d5a <DMA_SetConfig+0x10a>
24004c88:	68fb      	ldr	r3, [r7, #12]
24004c8a:	681b      	ldr	r3, [r3, #0]
24004c8c:	4a7f      	ldr	r2, [pc, #508]	; (24004e8c <DMA_SetConfig+0x23c>)
24004c8e:	4293      	cmp	r3, r2
24004c90:	d063      	beq.n	24004d5a <DMA_SetConfig+0x10a>
24004c92:	68fb      	ldr	r3, [r7, #12]
24004c94:	681b      	ldr	r3, [r3, #0]
24004c96:	4a7e      	ldr	r2, [pc, #504]	; (24004e90 <DMA_SetConfig+0x240>)
24004c98:	4293      	cmp	r3, r2
24004c9a:	d05e      	beq.n	24004d5a <DMA_SetConfig+0x10a>
24004c9c:	68fb      	ldr	r3, [r7, #12]
24004c9e:	681b      	ldr	r3, [r3, #0]
24004ca0:	4a7c      	ldr	r2, [pc, #496]	; (24004e94 <DMA_SetConfig+0x244>)
24004ca2:	4293      	cmp	r3, r2
24004ca4:	d059      	beq.n	24004d5a <DMA_SetConfig+0x10a>
24004ca6:	68fb      	ldr	r3, [r7, #12]
24004ca8:	681b      	ldr	r3, [r3, #0]
24004caa:	4a7b      	ldr	r2, [pc, #492]	; (24004e98 <DMA_SetConfig+0x248>)
24004cac:	4293      	cmp	r3, r2
24004cae:	d054      	beq.n	24004d5a <DMA_SetConfig+0x10a>
24004cb0:	68fb      	ldr	r3, [r7, #12]
24004cb2:	681b      	ldr	r3, [r3, #0]
24004cb4:	4a79      	ldr	r2, [pc, #484]	; (24004e9c <DMA_SetConfig+0x24c>)
24004cb6:	4293      	cmp	r3, r2
24004cb8:	d04f      	beq.n	24004d5a <DMA_SetConfig+0x10a>
24004cba:	68fb      	ldr	r3, [r7, #12]
24004cbc:	681b      	ldr	r3, [r3, #0]
24004cbe:	4a78      	ldr	r2, [pc, #480]	; (24004ea0 <DMA_SetConfig+0x250>)
24004cc0:	4293      	cmp	r3, r2
24004cc2:	d04a      	beq.n	24004d5a <DMA_SetConfig+0x10a>
24004cc4:	68fb      	ldr	r3, [r7, #12]
24004cc6:	681b      	ldr	r3, [r3, #0]
24004cc8:	4a76      	ldr	r2, [pc, #472]	; (24004ea4 <DMA_SetConfig+0x254>)
24004cca:	4293      	cmp	r3, r2
24004ccc:	d045      	beq.n	24004d5a <DMA_SetConfig+0x10a>
24004cce:	68fb      	ldr	r3, [r7, #12]
24004cd0:	681b      	ldr	r3, [r3, #0]
24004cd2:	4a75      	ldr	r2, [pc, #468]	; (24004ea8 <DMA_SetConfig+0x258>)
24004cd4:	4293      	cmp	r3, r2
24004cd6:	d040      	beq.n	24004d5a <DMA_SetConfig+0x10a>
24004cd8:	68fb      	ldr	r3, [r7, #12]
24004cda:	681b      	ldr	r3, [r3, #0]
24004cdc:	4a73      	ldr	r2, [pc, #460]	; (24004eac <DMA_SetConfig+0x25c>)
24004cde:	4293      	cmp	r3, r2
24004ce0:	d03b      	beq.n	24004d5a <DMA_SetConfig+0x10a>
24004ce2:	68fb      	ldr	r3, [r7, #12]
24004ce4:	681b      	ldr	r3, [r3, #0]
24004ce6:	4a72      	ldr	r2, [pc, #456]	; (24004eb0 <DMA_SetConfig+0x260>)
24004ce8:	4293      	cmp	r3, r2
24004cea:	d036      	beq.n	24004d5a <DMA_SetConfig+0x10a>
24004cec:	68fb      	ldr	r3, [r7, #12]
24004cee:	681b      	ldr	r3, [r3, #0]
24004cf0:	4a70      	ldr	r2, [pc, #448]	; (24004eb4 <DMA_SetConfig+0x264>)
24004cf2:	4293      	cmp	r3, r2
24004cf4:	d031      	beq.n	24004d5a <DMA_SetConfig+0x10a>
24004cf6:	68fb      	ldr	r3, [r7, #12]
24004cf8:	681b      	ldr	r3, [r3, #0]
24004cfa:	4a6f      	ldr	r2, [pc, #444]	; (24004eb8 <DMA_SetConfig+0x268>)
24004cfc:	4293      	cmp	r3, r2
24004cfe:	d02c      	beq.n	24004d5a <DMA_SetConfig+0x10a>
24004d00:	68fb      	ldr	r3, [r7, #12]
24004d02:	681b      	ldr	r3, [r3, #0]
24004d04:	4a6d      	ldr	r2, [pc, #436]	; (24004ebc <DMA_SetConfig+0x26c>)
24004d06:	4293      	cmp	r3, r2
24004d08:	d027      	beq.n	24004d5a <DMA_SetConfig+0x10a>
24004d0a:	68fb      	ldr	r3, [r7, #12]
24004d0c:	681b      	ldr	r3, [r3, #0]
24004d0e:	4a6c      	ldr	r2, [pc, #432]	; (24004ec0 <DMA_SetConfig+0x270>)
24004d10:	4293      	cmp	r3, r2
24004d12:	d022      	beq.n	24004d5a <DMA_SetConfig+0x10a>
24004d14:	68fb      	ldr	r3, [r7, #12]
24004d16:	681b      	ldr	r3, [r3, #0]
24004d18:	4a6a      	ldr	r2, [pc, #424]	; (24004ec4 <DMA_SetConfig+0x274>)
24004d1a:	4293      	cmp	r3, r2
24004d1c:	d01d      	beq.n	24004d5a <DMA_SetConfig+0x10a>
24004d1e:	68fb      	ldr	r3, [r7, #12]
24004d20:	681b      	ldr	r3, [r3, #0]
24004d22:	4a69      	ldr	r2, [pc, #420]	; (24004ec8 <DMA_SetConfig+0x278>)
24004d24:	4293      	cmp	r3, r2
24004d26:	d018      	beq.n	24004d5a <DMA_SetConfig+0x10a>
24004d28:	68fb      	ldr	r3, [r7, #12]
24004d2a:	681b      	ldr	r3, [r3, #0]
24004d2c:	4a67      	ldr	r2, [pc, #412]	; (24004ecc <DMA_SetConfig+0x27c>)
24004d2e:	4293      	cmp	r3, r2
24004d30:	d013      	beq.n	24004d5a <DMA_SetConfig+0x10a>
24004d32:	68fb      	ldr	r3, [r7, #12]
24004d34:	681b      	ldr	r3, [r3, #0]
24004d36:	4a66      	ldr	r2, [pc, #408]	; (24004ed0 <DMA_SetConfig+0x280>)
24004d38:	4293      	cmp	r3, r2
24004d3a:	d00e      	beq.n	24004d5a <DMA_SetConfig+0x10a>
24004d3c:	68fb      	ldr	r3, [r7, #12]
24004d3e:	681b      	ldr	r3, [r3, #0]
24004d40:	4a64      	ldr	r2, [pc, #400]	; (24004ed4 <DMA_SetConfig+0x284>)
24004d42:	4293      	cmp	r3, r2
24004d44:	d009      	beq.n	24004d5a <DMA_SetConfig+0x10a>
24004d46:	68fb      	ldr	r3, [r7, #12]
24004d48:	681b      	ldr	r3, [r3, #0]
24004d4a:	4a63      	ldr	r2, [pc, #396]	; (24004ed8 <DMA_SetConfig+0x288>)
24004d4c:	4293      	cmp	r3, r2
24004d4e:	d004      	beq.n	24004d5a <DMA_SetConfig+0x10a>
24004d50:	68fb      	ldr	r3, [r7, #12]
24004d52:	681b      	ldr	r3, [r3, #0]
24004d54:	4a61      	ldr	r2, [pc, #388]	; (24004edc <DMA_SetConfig+0x28c>)
24004d56:	4293      	cmp	r3, r2
24004d58:	d101      	bne.n	24004d5e <DMA_SetConfig+0x10e>
24004d5a:	2301      	movs	r3, #1
24004d5c:	e000      	b.n	24004d60 <DMA_SetConfig+0x110>
24004d5e:	2300      	movs	r3, #0
24004d60:	2b00      	cmp	r3, #0
24004d62:	d00d      	beq.n	24004d80 <DMA_SetConfig+0x130>
  {
    /* Clear the DMAMUX synchro overrun flag */
    hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
24004d64:	68fb      	ldr	r3, [r7, #12]
24004d66:	6e5b      	ldr	r3, [r3, #100]	; 0x64
24004d68:	68fa      	ldr	r2, [r7, #12]
24004d6a:	6e92      	ldr	r2, [r2, #104]	; 0x68
24004d6c:	605a      	str	r2, [r3, #4]

    if(hdma->DMAmuxRequestGen != 0U)
24004d6e:	68fb      	ldr	r3, [r7, #12]
24004d70:	6edb      	ldr	r3, [r3, #108]	; 0x6c
24004d72:	2b00      	cmp	r3, #0
24004d74:	d004      	beq.n	24004d80 <DMA_SetConfig+0x130>
    {
      /* Clear the DMAMUX request generator overrun flag */
      hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
24004d76:	68fb      	ldr	r3, [r7, #12]
24004d78:	6f1b      	ldr	r3, [r3, #112]	; 0x70
24004d7a:	68fa      	ldr	r2, [r7, #12]
24004d7c:	6f52      	ldr	r2, [r2, #116]	; 0x74
24004d7e:	605a      	str	r2, [r3, #4]
    }
  }

  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
24004d80:	68fb      	ldr	r3, [r7, #12]
24004d82:	681b      	ldr	r3, [r3, #0]
24004d84:	4a3e      	ldr	r2, [pc, #248]	; (24004e80 <DMA_SetConfig+0x230>)
24004d86:	4293      	cmp	r3, r2
24004d88:	d04a      	beq.n	24004e20 <DMA_SetConfig+0x1d0>
24004d8a:	68fb      	ldr	r3, [r7, #12]
24004d8c:	681b      	ldr	r3, [r3, #0]
24004d8e:	4a3d      	ldr	r2, [pc, #244]	; (24004e84 <DMA_SetConfig+0x234>)
24004d90:	4293      	cmp	r3, r2
24004d92:	d045      	beq.n	24004e20 <DMA_SetConfig+0x1d0>
24004d94:	68fb      	ldr	r3, [r7, #12]
24004d96:	681b      	ldr	r3, [r3, #0]
24004d98:	4a3b      	ldr	r2, [pc, #236]	; (24004e88 <DMA_SetConfig+0x238>)
24004d9a:	4293      	cmp	r3, r2
24004d9c:	d040      	beq.n	24004e20 <DMA_SetConfig+0x1d0>
24004d9e:	68fb      	ldr	r3, [r7, #12]
24004da0:	681b      	ldr	r3, [r3, #0]
24004da2:	4a3a      	ldr	r2, [pc, #232]	; (24004e8c <DMA_SetConfig+0x23c>)
24004da4:	4293      	cmp	r3, r2
24004da6:	d03b      	beq.n	24004e20 <DMA_SetConfig+0x1d0>
24004da8:	68fb      	ldr	r3, [r7, #12]
24004daa:	681b      	ldr	r3, [r3, #0]
24004dac:	4a38      	ldr	r2, [pc, #224]	; (24004e90 <DMA_SetConfig+0x240>)
24004dae:	4293      	cmp	r3, r2
24004db0:	d036      	beq.n	24004e20 <DMA_SetConfig+0x1d0>
24004db2:	68fb      	ldr	r3, [r7, #12]
24004db4:	681b      	ldr	r3, [r3, #0]
24004db6:	4a37      	ldr	r2, [pc, #220]	; (24004e94 <DMA_SetConfig+0x244>)
24004db8:	4293      	cmp	r3, r2
24004dba:	d031      	beq.n	24004e20 <DMA_SetConfig+0x1d0>
24004dbc:	68fb      	ldr	r3, [r7, #12]
24004dbe:	681b      	ldr	r3, [r3, #0]
24004dc0:	4a35      	ldr	r2, [pc, #212]	; (24004e98 <DMA_SetConfig+0x248>)
24004dc2:	4293      	cmp	r3, r2
24004dc4:	d02c      	beq.n	24004e20 <DMA_SetConfig+0x1d0>
24004dc6:	68fb      	ldr	r3, [r7, #12]
24004dc8:	681b      	ldr	r3, [r3, #0]
24004dca:	4a34      	ldr	r2, [pc, #208]	; (24004e9c <DMA_SetConfig+0x24c>)
24004dcc:	4293      	cmp	r3, r2
24004dce:	d027      	beq.n	24004e20 <DMA_SetConfig+0x1d0>
24004dd0:	68fb      	ldr	r3, [r7, #12]
24004dd2:	681b      	ldr	r3, [r3, #0]
24004dd4:	4a32      	ldr	r2, [pc, #200]	; (24004ea0 <DMA_SetConfig+0x250>)
24004dd6:	4293      	cmp	r3, r2
24004dd8:	d022      	beq.n	24004e20 <DMA_SetConfig+0x1d0>
24004dda:	68fb      	ldr	r3, [r7, #12]
24004ddc:	681b      	ldr	r3, [r3, #0]
24004dde:	4a31      	ldr	r2, [pc, #196]	; (24004ea4 <DMA_SetConfig+0x254>)
24004de0:	4293      	cmp	r3, r2
24004de2:	d01d      	beq.n	24004e20 <DMA_SetConfig+0x1d0>
24004de4:	68fb      	ldr	r3, [r7, #12]
24004de6:	681b      	ldr	r3, [r3, #0]
24004de8:	4a2f      	ldr	r2, [pc, #188]	; (24004ea8 <DMA_SetConfig+0x258>)
24004dea:	4293      	cmp	r3, r2
24004dec:	d018      	beq.n	24004e20 <DMA_SetConfig+0x1d0>
24004dee:	68fb      	ldr	r3, [r7, #12]
24004df0:	681b      	ldr	r3, [r3, #0]
24004df2:	4a2e      	ldr	r2, [pc, #184]	; (24004eac <DMA_SetConfig+0x25c>)
24004df4:	4293      	cmp	r3, r2
24004df6:	d013      	beq.n	24004e20 <DMA_SetConfig+0x1d0>
24004df8:	68fb      	ldr	r3, [r7, #12]
24004dfa:	681b      	ldr	r3, [r3, #0]
24004dfc:	4a2c      	ldr	r2, [pc, #176]	; (24004eb0 <DMA_SetConfig+0x260>)
24004dfe:	4293      	cmp	r3, r2
24004e00:	d00e      	beq.n	24004e20 <DMA_SetConfig+0x1d0>
24004e02:	68fb      	ldr	r3, [r7, #12]
24004e04:	681b      	ldr	r3, [r3, #0]
24004e06:	4a2b      	ldr	r2, [pc, #172]	; (24004eb4 <DMA_SetConfig+0x264>)
24004e08:	4293      	cmp	r3, r2
24004e0a:	d009      	beq.n	24004e20 <DMA_SetConfig+0x1d0>
24004e0c:	68fb      	ldr	r3, [r7, #12]
24004e0e:	681b      	ldr	r3, [r3, #0]
24004e10:	4a29      	ldr	r2, [pc, #164]	; (24004eb8 <DMA_SetConfig+0x268>)
24004e12:	4293      	cmp	r3, r2
24004e14:	d004      	beq.n	24004e20 <DMA_SetConfig+0x1d0>
24004e16:	68fb      	ldr	r3, [r7, #12]
24004e18:	681b      	ldr	r3, [r3, #0]
24004e1a:	4a28      	ldr	r2, [pc, #160]	; (24004ebc <DMA_SetConfig+0x26c>)
24004e1c:	4293      	cmp	r3, r2
24004e1e:	d101      	bne.n	24004e24 <DMA_SetConfig+0x1d4>
24004e20:	2301      	movs	r3, #1
24004e22:	e000      	b.n	24004e26 <DMA_SetConfig+0x1d6>
24004e24:	2300      	movs	r3, #0
24004e26:	2b00      	cmp	r3, #0
24004e28:	d05a      	beq.n	24004ee0 <DMA_SetConfig+0x290>
  {
    /* Clear all interrupt flags at correct offset within the register */
    regs_dma->IFCR = 0x3FUL << (hdma->StreamIndex & 0x1FU);
24004e2a:	68fb      	ldr	r3, [r7, #12]
24004e2c:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24004e2e:	f003 031f 	and.w	r3, r3, #31
24004e32:	223f      	movs	r2, #63	; 0x3f
24004e34:	409a      	lsls	r2, r3
24004e36:	697b      	ldr	r3, [r7, #20]
24004e38:	609a      	str	r2, [r3, #8]

    /* Clear DBM bit */
    ((DMA_Stream_TypeDef *)hdma->Instance)->CR &= (uint32_t)(~DMA_SxCR_DBM);
24004e3a:	68fb      	ldr	r3, [r7, #12]
24004e3c:	681b      	ldr	r3, [r3, #0]
24004e3e:	681a      	ldr	r2, [r3, #0]
24004e40:	68fb      	ldr	r3, [r7, #12]
24004e42:	681b      	ldr	r3, [r3, #0]
24004e44:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
24004e48:	601a      	str	r2, [r3, #0]

    /* Configure DMA Stream data length */
    ((DMA_Stream_TypeDef *)hdma->Instance)->NDTR = DataLength;
24004e4a:	68fb      	ldr	r3, [r7, #12]
24004e4c:	681b      	ldr	r3, [r3, #0]
24004e4e:	683a      	ldr	r2, [r7, #0]
24004e50:	605a      	str	r2, [r3, #4]

    /* Peripheral to Memory */
    if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
24004e52:	68fb      	ldr	r3, [r7, #12]
24004e54:	689b      	ldr	r3, [r3, #8]
24004e56:	2b40      	cmp	r3, #64	; 0x40
24004e58:	d108      	bne.n	24004e6c <DMA_SetConfig+0x21c>
    {
      /* Configure DMA Stream destination address */
      ((DMA_Stream_TypeDef *)hdma->Instance)->PAR = DstAddress;
24004e5a:	68fb      	ldr	r3, [r7, #12]
24004e5c:	681b      	ldr	r3, [r3, #0]
24004e5e:	687a      	ldr	r2, [r7, #4]
24004e60:	609a      	str	r2, [r3, #8]

      /* Configure DMA Stream source address */
      ((DMA_Stream_TypeDef *)hdma->Instance)->M0AR = SrcAddress;
24004e62:	68fb      	ldr	r3, [r7, #12]
24004e64:	681b      	ldr	r3, [r3, #0]
24004e66:	68ba      	ldr	r2, [r7, #8]
24004e68:	60da      	str	r2, [r3, #12]
  }
  else
  {
    /* Nothing To Do */
  }
}
24004e6a:	e087      	b.n	24004f7c <DMA_SetConfig+0x32c>
      ((DMA_Stream_TypeDef *)hdma->Instance)->PAR = SrcAddress;
24004e6c:	68fb      	ldr	r3, [r7, #12]
24004e6e:	681b      	ldr	r3, [r3, #0]
24004e70:	68ba      	ldr	r2, [r7, #8]
24004e72:	609a      	str	r2, [r3, #8]
      ((DMA_Stream_TypeDef *)hdma->Instance)->M0AR = DstAddress;
24004e74:	68fb      	ldr	r3, [r7, #12]
24004e76:	681b      	ldr	r3, [r3, #0]
24004e78:	687a      	ldr	r2, [r7, #4]
24004e7a:	60da      	str	r2, [r3, #12]
}
24004e7c:	e07e      	b.n	24004f7c <DMA_SetConfig+0x32c>
24004e7e:	bf00      	nop
24004e80:	40020010 	.word	0x40020010
24004e84:	40020028 	.word	0x40020028
24004e88:	40020040 	.word	0x40020040
24004e8c:	40020058 	.word	0x40020058
24004e90:	40020070 	.word	0x40020070
24004e94:	40020088 	.word	0x40020088
24004e98:	400200a0 	.word	0x400200a0
24004e9c:	400200b8 	.word	0x400200b8
24004ea0:	40020410 	.word	0x40020410
24004ea4:	40020428 	.word	0x40020428
24004ea8:	40020440 	.word	0x40020440
24004eac:	40020458 	.word	0x40020458
24004eb0:	40020470 	.word	0x40020470
24004eb4:	40020488 	.word	0x40020488
24004eb8:	400204a0 	.word	0x400204a0
24004ebc:	400204b8 	.word	0x400204b8
24004ec0:	58025408 	.word	0x58025408
24004ec4:	5802541c 	.word	0x5802541c
24004ec8:	58025430 	.word	0x58025430
24004ecc:	58025444 	.word	0x58025444
24004ed0:	58025458 	.word	0x58025458
24004ed4:	5802546c 	.word	0x5802546c
24004ed8:	58025480 	.word	0x58025480
24004edc:	58025494 	.word	0x58025494
  else if(IS_BDMA_CHANNEL_INSTANCE(hdma->Instance) != 0U) /* BDMA instance(s) */
24004ee0:	68fb      	ldr	r3, [r7, #12]
24004ee2:	681b      	ldr	r3, [r3, #0]
24004ee4:	4a28      	ldr	r2, [pc, #160]	; (24004f88 <DMA_SetConfig+0x338>)
24004ee6:	4293      	cmp	r3, r2
24004ee8:	d022      	beq.n	24004f30 <DMA_SetConfig+0x2e0>
24004eea:	68fb      	ldr	r3, [r7, #12]
24004eec:	681b      	ldr	r3, [r3, #0]
24004eee:	4a27      	ldr	r2, [pc, #156]	; (24004f8c <DMA_SetConfig+0x33c>)
24004ef0:	4293      	cmp	r3, r2
24004ef2:	d01d      	beq.n	24004f30 <DMA_SetConfig+0x2e0>
24004ef4:	68fb      	ldr	r3, [r7, #12]
24004ef6:	681b      	ldr	r3, [r3, #0]
24004ef8:	4a25      	ldr	r2, [pc, #148]	; (24004f90 <DMA_SetConfig+0x340>)
24004efa:	4293      	cmp	r3, r2
24004efc:	d018      	beq.n	24004f30 <DMA_SetConfig+0x2e0>
24004efe:	68fb      	ldr	r3, [r7, #12]
24004f00:	681b      	ldr	r3, [r3, #0]
24004f02:	4a24      	ldr	r2, [pc, #144]	; (24004f94 <DMA_SetConfig+0x344>)
24004f04:	4293      	cmp	r3, r2
24004f06:	d013      	beq.n	24004f30 <DMA_SetConfig+0x2e0>
24004f08:	68fb      	ldr	r3, [r7, #12]
24004f0a:	681b      	ldr	r3, [r3, #0]
24004f0c:	4a22      	ldr	r2, [pc, #136]	; (24004f98 <DMA_SetConfig+0x348>)
24004f0e:	4293      	cmp	r3, r2
24004f10:	d00e      	beq.n	24004f30 <DMA_SetConfig+0x2e0>
24004f12:	68fb      	ldr	r3, [r7, #12]
24004f14:	681b      	ldr	r3, [r3, #0]
24004f16:	4a21      	ldr	r2, [pc, #132]	; (24004f9c <DMA_SetConfig+0x34c>)
24004f18:	4293      	cmp	r3, r2
24004f1a:	d009      	beq.n	24004f30 <DMA_SetConfig+0x2e0>
24004f1c:	68fb      	ldr	r3, [r7, #12]
24004f1e:	681b      	ldr	r3, [r3, #0]
24004f20:	4a1f      	ldr	r2, [pc, #124]	; (24004fa0 <DMA_SetConfig+0x350>)
24004f22:	4293      	cmp	r3, r2
24004f24:	d004      	beq.n	24004f30 <DMA_SetConfig+0x2e0>
24004f26:	68fb      	ldr	r3, [r7, #12]
24004f28:	681b      	ldr	r3, [r3, #0]
24004f2a:	4a1e      	ldr	r2, [pc, #120]	; (24004fa4 <DMA_SetConfig+0x354>)
24004f2c:	4293      	cmp	r3, r2
24004f2e:	d101      	bne.n	24004f34 <DMA_SetConfig+0x2e4>
24004f30:	2301      	movs	r3, #1
24004f32:	e000      	b.n	24004f36 <DMA_SetConfig+0x2e6>
24004f34:	2300      	movs	r3, #0
24004f36:	2b00      	cmp	r3, #0
24004f38:	d020      	beq.n	24004f7c <DMA_SetConfig+0x32c>
    regs_bdma->IFCR = (BDMA_ISR_GIF0) << (hdma->StreamIndex & 0x1FU);
24004f3a:	68fb      	ldr	r3, [r7, #12]
24004f3c:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24004f3e:	f003 031f 	and.w	r3, r3, #31
24004f42:	2201      	movs	r2, #1
24004f44:	409a      	lsls	r2, r3
24004f46:	693b      	ldr	r3, [r7, #16]
24004f48:	605a      	str	r2, [r3, #4]
    ((BDMA_Channel_TypeDef *)hdma->Instance)->CNDTR = DataLength;
24004f4a:	68fb      	ldr	r3, [r7, #12]
24004f4c:	681b      	ldr	r3, [r3, #0]
24004f4e:	683a      	ldr	r2, [r7, #0]
24004f50:	605a      	str	r2, [r3, #4]
    if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
24004f52:	68fb      	ldr	r3, [r7, #12]
24004f54:	689b      	ldr	r3, [r3, #8]
24004f56:	2b40      	cmp	r3, #64	; 0x40
24004f58:	d108      	bne.n	24004f6c <DMA_SetConfig+0x31c>
      ((BDMA_Channel_TypeDef *)hdma->Instance)->CPAR = DstAddress;
24004f5a:	68fb      	ldr	r3, [r7, #12]
24004f5c:	681b      	ldr	r3, [r3, #0]
24004f5e:	687a      	ldr	r2, [r7, #4]
24004f60:	609a      	str	r2, [r3, #8]
      ((BDMA_Channel_TypeDef *)hdma->Instance)->CM0AR = SrcAddress;
24004f62:	68fb      	ldr	r3, [r7, #12]
24004f64:	681b      	ldr	r3, [r3, #0]
24004f66:	68ba      	ldr	r2, [r7, #8]
24004f68:	60da      	str	r2, [r3, #12]
}
24004f6a:	e007      	b.n	24004f7c <DMA_SetConfig+0x32c>
      ((BDMA_Channel_TypeDef *)hdma->Instance)->CPAR = SrcAddress;
24004f6c:	68fb      	ldr	r3, [r7, #12]
24004f6e:	681b      	ldr	r3, [r3, #0]
24004f70:	68ba      	ldr	r2, [r7, #8]
24004f72:	609a      	str	r2, [r3, #8]
      ((BDMA_Channel_TypeDef *)hdma->Instance)->CM0AR = DstAddress;
24004f74:	68fb      	ldr	r3, [r7, #12]
24004f76:	681b      	ldr	r3, [r3, #0]
24004f78:	687a      	ldr	r2, [r7, #4]
24004f7a:	60da      	str	r2, [r3, #12]
}
24004f7c:	bf00      	nop
24004f7e:	371c      	adds	r7, #28
24004f80:	46bd      	mov	sp, r7
24004f82:	f85d 7b04 	ldr.w	r7, [sp], #4
24004f86:	4770      	bx	lr
24004f88:	58025408 	.word	0x58025408
24004f8c:	5802541c 	.word	0x5802541c
24004f90:	58025430 	.word	0x58025430
24004f94:	58025444 	.word	0x58025444
24004f98:	58025458 	.word	0x58025458
24004f9c:	5802546c 	.word	0x5802546c
24004fa0:	58025480 	.word	0x58025480
24004fa4:	58025494 	.word	0x58025494

24004fa8 <DMA_CalcBaseAndBitshift>:
  * @param  hdma:       pointer to a DMA_HandleTypeDef structure that contains
  *                     the configuration information for the specified DMA Stream.
  * @retval Stream base address
  */
static uint32_t DMA_CalcBaseAndBitshift(DMA_HandleTypeDef *hdma)
{
24004fa8:	b480      	push	{r7}
24004faa:	b085      	sub	sp, #20
24004fac:	af00      	add	r7, sp, #0
24004fae:	6078      	str	r0, [r7, #4]
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
24004fb0:	687b      	ldr	r3, [r7, #4]
24004fb2:	681b      	ldr	r3, [r3, #0]
24004fb4:	4a42      	ldr	r2, [pc, #264]	; (240050c0 <DMA_CalcBaseAndBitshift+0x118>)
24004fb6:	4293      	cmp	r3, r2
24004fb8:	d04a      	beq.n	24005050 <DMA_CalcBaseAndBitshift+0xa8>
24004fba:	687b      	ldr	r3, [r7, #4]
24004fbc:	681b      	ldr	r3, [r3, #0]
24004fbe:	4a41      	ldr	r2, [pc, #260]	; (240050c4 <DMA_CalcBaseAndBitshift+0x11c>)
24004fc0:	4293      	cmp	r3, r2
24004fc2:	d045      	beq.n	24005050 <DMA_CalcBaseAndBitshift+0xa8>
24004fc4:	687b      	ldr	r3, [r7, #4]
24004fc6:	681b      	ldr	r3, [r3, #0]
24004fc8:	4a3f      	ldr	r2, [pc, #252]	; (240050c8 <DMA_CalcBaseAndBitshift+0x120>)
24004fca:	4293      	cmp	r3, r2
24004fcc:	d040      	beq.n	24005050 <DMA_CalcBaseAndBitshift+0xa8>
24004fce:	687b      	ldr	r3, [r7, #4]
24004fd0:	681b      	ldr	r3, [r3, #0]
24004fd2:	4a3e      	ldr	r2, [pc, #248]	; (240050cc <DMA_CalcBaseAndBitshift+0x124>)
24004fd4:	4293      	cmp	r3, r2
24004fd6:	d03b      	beq.n	24005050 <DMA_CalcBaseAndBitshift+0xa8>
24004fd8:	687b      	ldr	r3, [r7, #4]
24004fda:	681b      	ldr	r3, [r3, #0]
24004fdc:	4a3c      	ldr	r2, [pc, #240]	; (240050d0 <DMA_CalcBaseAndBitshift+0x128>)
24004fde:	4293      	cmp	r3, r2
24004fe0:	d036      	beq.n	24005050 <DMA_CalcBaseAndBitshift+0xa8>
24004fe2:	687b      	ldr	r3, [r7, #4]
24004fe4:	681b      	ldr	r3, [r3, #0]
24004fe6:	4a3b      	ldr	r2, [pc, #236]	; (240050d4 <DMA_CalcBaseAndBitshift+0x12c>)
24004fe8:	4293      	cmp	r3, r2
24004fea:	d031      	beq.n	24005050 <DMA_CalcBaseAndBitshift+0xa8>
24004fec:	687b      	ldr	r3, [r7, #4]
24004fee:	681b      	ldr	r3, [r3, #0]
24004ff0:	4a39      	ldr	r2, [pc, #228]	; (240050d8 <DMA_CalcBaseAndBitshift+0x130>)
24004ff2:	4293      	cmp	r3, r2
24004ff4:	d02c      	beq.n	24005050 <DMA_CalcBaseAndBitshift+0xa8>
24004ff6:	687b      	ldr	r3, [r7, #4]
24004ff8:	681b      	ldr	r3, [r3, #0]
24004ffa:	4a38      	ldr	r2, [pc, #224]	; (240050dc <DMA_CalcBaseAndBitshift+0x134>)
24004ffc:	4293      	cmp	r3, r2
24004ffe:	d027      	beq.n	24005050 <DMA_CalcBaseAndBitshift+0xa8>
24005000:	687b      	ldr	r3, [r7, #4]
24005002:	681b      	ldr	r3, [r3, #0]
24005004:	4a36      	ldr	r2, [pc, #216]	; (240050e0 <DMA_CalcBaseAndBitshift+0x138>)
24005006:	4293      	cmp	r3, r2
24005008:	d022      	beq.n	24005050 <DMA_CalcBaseAndBitshift+0xa8>
2400500a:	687b      	ldr	r3, [r7, #4]
2400500c:	681b      	ldr	r3, [r3, #0]
2400500e:	4a35      	ldr	r2, [pc, #212]	; (240050e4 <DMA_CalcBaseAndBitshift+0x13c>)
24005010:	4293      	cmp	r3, r2
24005012:	d01d      	beq.n	24005050 <DMA_CalcBaseAndBitshift+0xa8>
24005014:	687b      	ldr	r3, [r7, #4]
24005016:	681b      	ldr	r3, [r3, #0]
24005018:	4a33      	ldr	r2, [pc, #204]	; (240050e8 <DMA_CalcBaseAndBitshift+0x140>)
2400501a:	4293      	cmp	r3, r2
2400501c:	d018      	beq.n	24005050 <DMA_CalcBaseAndBitshift+0xa8>
2400501e:	687b      	ldr	r3, [r7, #4]
24005020:	681b      	ldr	r3, [r3, #0]
24005022:	4a32      	ldr	r2, [pc, #200]	; (240050ec <DMA_CalcBaseAndBitshift+0x144>)
24005024:	4293      	cmp	r3, r2
24005026:	d013      	beq.n	24005050 <DMA_CalcBaseAndBitshift+0xa8>
24005028:	687b      	ldr	r3, [r7, #4]
2400502a:	681b      	ldr	r3, [r3, #0]
2400502c:	4a30      	ldr	r2, [pc, #192]	; (240050f0 <DMA_CalcBaseAndBitshift+0x148>)
2400502e:	4293      	cmp	r3, r2
24005030:	d00e      	beq.n	24005050 <DMA_CalcBaseAndBitshift+0xa8>
24005032:	687b      	ldr	r3, [r7, #4]
24005034:	681b      	ldr	r3, [r3, #0]
24005036:	4a2f      	ldr	r2, [pc, #188]	; (240050f4 <DMA_CalcBaseAndBitshift+0x14c>)
24005038:	4293      	cmp	r3, r2
2400503a:	d009      	beq.n	24005050 <DMA_CalcBaseAndBitshift+0xa8>
2400503c:	687b      	ldr	r3, [r7, #4]
2400503e:	681b      	ldr	r3, [r3, #0]
24005040:	4a2d      	ldr	r2, [pc, #180]	; (240050f8 <DMA_CalcBaseAndBitshift+0x150>)
24005042:	4293      	cmp	r3, r2
24005044:	d004      	beq.n	24005050 <DMA_CalcBaseAndBitshift+0xa8>
24005046:	687b      	ldr	r3, [r7, #4]
24005048:	681b      	ldr	r3, [r3, #0]
2400504a:	4a2c      	ldr	r2, [pc, #176]	; (240050fc <DMA_CalcBaseAndBitshift+0x154>)
2400504c:	4293      	cmp	r3, r2
2400504e:	d101      	bne.n	24005054 <DMA_CalcBaseAndBitshift+0xac>
24005050:	2301      	movs	r3, #1
24005052:	e000      	b.n	24005056 <DMA_CalcBaseAndBitshift+0xae>
24005054:	2300      	movs	r3, #0
24005056:	2b00      	cmp	r3, #0
24005058:	d024      	beq.n	240050a4 <DMA_CalcBaseAndBitshift+0xfc>
  {
    uint32_t stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 16U) / 24U;
2400505a:	687b      	ldr	r3, [r7, #4]
2400505c:	681b      	ldr	r3, [r3, #0]
2400505e:	b2db      	uxtb	r3, r3
24005060:	3b10      	subs	r3, #16
24005062:	4a27      	ldr	r2, [pc, #156]	; (24005100 <DMA_CalcBaseAndBitshift+0x158>)
24005064:	fba2 2303 	umull	r2, r3, r2, r3
24005068:	091b      	lsrs	r3, r3, #4
2400506a:	60fb      	str	r3, [r7, #12]

    /* lookup table for necessary bitshift of flags within status registers */
    static const uint8_t flagBitshiftOffset[8U] = {0U, 6U, 16U, 22U, 0U, 6U, 16U, 22U};
    hdma->StreamIndex = flagBitshiftOffset[stream_number & 0x7U];
2400506c:	68fb      	ldr	r3, [r7, #12]
2400506e:	f003 0307 	and.w	r3, r3, #7
24005072:	4a24      	ldr	r2, [pc, #144]	; (24005104 <DMA_CalcBaseAndBitshift+0x15c>)
24005074:	5cd3      	ldrb	r3, [r2, r3]
24005076:	461a      	mov	r2, r3
24005078:	687b      	ldr	r3, [r7, #4]
2400507a:	65da      	str	r2, [r3, #92]	; 0x5c

    if (stream_number > 3U)
2400507c:	68fb      	ldr	r3, [r7, #12]
2400507e:	2b03      	cmp	r3, #3
24005080:	d908      	bls.n	24005094 <DMA_CalcBaseAndBitshift+0xec>
    {
      /* return pointer to HISR and HIFCR */
      hdma->StreamBaseAddress = (((uint32_t)((uint32_t*)hdma->Instance) & (uint32_t)(~0x3FFU)) + 4U);
24005082:	687b      	ldr	r3, [r7, #4]
24005084:	681b      	ldr	r3, [r3, #0]
24005086:	461a      	mov	r2, r3
24005088:	4b1f      	ldr	r3, [pc, #124]	; (24005108 <DMA_CalcBaseAndBitshift+0x160>)
2400508a:	4013      	ands	r3, r2
2400508c:	1d1a      	adds	r2, r3, #4
2400508e:	687b      	ldr	r3, [r7, #4]
24005090:	659a      	str	r2, [r3, #88]	; 0x58
24005092:	e00d      	b.n	240050b0 <DMA_CalcBaseAndBitshift+0x108>
    }
    else
    {
      /* return pointer to LISR and LIFCR */
      hdma->StreamBaseAddress = ((uint32_t)((uint32_t*)hdma->Instance) & (uint32_t)(~0x3FFU));
24005094:	687b      	ldr	r3, [r7, #4]
24005096:	681b      	ldr	r3, [r3, #0]
24005098:	461a      	mov	r2, r3
2400509a:	4b1b      	ldr	r3, [pc, #108]	; (24005108 <DMA_CalcBaseAndBitshift+0x160>)
2400509c:	4013      	ands	r3, r2
2400509e:	687a      	ldr	r2, [r7, #4]
240050a0:	6593      	str	r3, [r2, #88]	; 0x58
240050a2:	e005      	b.n	240050b0 <DMA_CalcBaseAndBitshift+0x108>
    }
  }
  else /* BDMA instance(s) */
  {
    /* return pointer to ISR and IFCR */
    hdma->StreamBaseAddress = ((uint32_t)((uint32_t*)hdma->Instance) & (uint32_t)(~0xFFU));
240050a4:	687b      	ldr	r3, [r7, #4]
240050a6:	681b      	ldr	r3, [r3, #0]
240050a8:	f023 02ff 	bic.w	r2, r3, #255	; 0xff
240050ac:	687b      	ldr	r3, [r7, #4]
240050ae:	659a      	str	r2, [r3, #88]	; 0x58
  }

  return hdma->StreamBaseAddress;
240050b0:	687b      	ldr	r3, [r7, #4]
240050b2:	6d9b      	ldr	r3, [r3, #88]	; 0x58
}
240050b4:	4618      	mov	r0, r3
240050b6:	3714      	adds	r7, #20
240050b8:	46bd      	mov	sp, r7
240050ba:	f85d 7b04 	ldr.w	r7, [sp], #4
240050be:	4770      	bx	lr
240050c0:	40020010 	.word	0x40020010
240050c4:	40020028 	.word	0x40020028
240050c8:	40020040 	.word	0x40020040
240050cc:	40020058 	.word	0x40020058
240050d0:	40020070 	.word	0x40020070
240050d4:	40020088 	.word	0x40020088
240050d8:	400200a0 	.word	0x400200a0
240050dc:	400200b8 	.word	0x400200b8
240050e0:	40020410 	.word	0x40020410
240050e4:	40020428 	.word	0x40020428
240050e8:	40020440 	.word	0x40020440
240050ec:	40020458 	.word	0x40020458
240050f0:	40020470 	.word	0x40020470
240050f4:	40020488 	.word	0x40020488
240050f8:	400204a0 	.word	0x400204a0
240050fc:	400204b8 	.word	0x400204b8
24005100:	aaaaaaab 	.word	0xaaaaaaab
24005104:	24016db0 	.word	0x24016db0
24005108:	fffffc00 	.word	0xfffffc00

2400510c <DMA_CheckFifoParam>:
  * @param  hdma:       pointer to a DMA_HandleTypeDef structure that contains
  *                     the configuration information for the specified DMA Stream.
  * @retval HAL status
  */
static HAL_StatusTypeDef DMA_CheckFifoParam(DMA_HandleTypeDef *hdma)
{
2400510c:	b480      	push	{r7}
2400510e:	b085      	sub	sp, #20
24005110:	af00      	add	r7, sp, #0
24005112:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
24005114:	2300      	movs	r3, #0
24005116:	73fb      	strb	r3, [r7, #15]

  /* Memory Data size equal to Byte */
  if (hdma->Init.MemDataAlignment == DMA_MDATAALIGN_BYTE)
24005118:	687b      	ldr	r3, [r7, #4]
2400511a:	699b      	ldr	r3, [r3, #24]
2400511c:	2b00      	cmp	r3, #0
2400511e:	d120      	bne.n	24005162 <DMA_CheckFifoParam+0x56>
  {
    switch (hdma->Init.FIFOThreshold)
24005120:	687b      	ldr	r3, [r7, #4]
24005122:	6a9b      	ldr	r3, [r3, #40]	; 0x28
24005124:	2b03      	cmp	r3, #3
24005126:	d858      	bhi.n	240051da <DMA_CheckFifoParam+0xce>
24005128:	a201      	add	r2, pc, #4	; (adr r2, 24005130 <DMA_CheckFifoParam+0x24>)
2400512a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
2400512e:	bf00      	nop
24005130:	24005141 	.word	0x24005141
24005134:	24005153 	.word	0x24005153
24005138:	24005141 	.word	0x24005141
2400513c:	240051db 	.word	0x240051db
    {
      case DMA_FIFO_THRESHOLD_1QUARTERFULL:
      case DMA_FIFO_THRESHOLD_3QUARTERSFULL:

        if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
24005140:	687b      	ldr	r3, [r7, #4]
24005142:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24005144:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
24005148:	2b00      	cmp	r3, #0
2400514a:	d048      	beq.n	240051de <DMA_CheckFifoParam+0xd2>
        {
          status = HAL_ERROR;
2400514c:	2301      	movs	r3, #1
2400514e:	73fb      	strb	r3, [r7, #15]
        }
        break;
24005150:	e045      	b.n	240051de <DMA_CheckFifoParam+0xd2>

      case DMA_FIFO_THRESHOLD_HALFFULL:
        if (hdma->Init.MemBurst == DMA_MBURST_INC16)
24005152:	687b      	ldr	r3, [r7, #4]
24005154:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24005156:	f1b3 7fc0 	cmp.w	r3, #25165824	; 0x1800000
2400515a:	d142      	bne.n	240051e2 <DMA_CheckFifoParam+0xd6>
        {
          status = HAL_ERROR;
2400515c:	2301      	movs	r3, #1
2400515e:	73fb      	strb	r3, [r7, #15]
        }
        break;
24005160:	e03f      	b.n	240051e2 <DMA_CheckFifoParam+0xd6>
        break;
    }
  }

  /* Memory Data size equal to Half-Word */
  else if (hdma->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)
24005162:	687b      	ldr	r3, [r7, #4]
24005164:	699b      	ldr	r3, [r3, #24]
24005166:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
2400516a:	d123      	bne.n	240051b4 <DMA_CheckFifoParam+0xa8>
  {
    switch (hdma->Init.FIFOThreshold)
2400516c:	687b      	ldr	r3, [r7, #4]
2400516e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
24005170:	2b03      	cmp	r3, #3
24005172:	d838      	bhi.n	240051e6 <DMA_CheckFifoParam+0xda>
24005174:	a201      	add	r2, pc, #4	; (adr r2, 2400517c <DMA_CheckFifoParam+0x70>)
24005176:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
2400517a:	bf00      	nop
2400517c:	2400518d 	.word	0x2400518d
24005180:	24005193 	.word	0x24005193
24005184:	2400518d 	.word	0x2400518d
24005188:	240051a5 	.word	0x240051a5
    {
      case DMA_FIFO_THRESHOLD_1QUARTERFULL:
      case DMA_FIFO_THRESHOLD_3QUARTERSFULL:
        status = HAL_ERROR;
2400518c:	2301      	movs	r3, #1
2400518e:	73fb      	strb	r3, [r7, #15]
        break;
24005190:	e030      	b.n	240051f4 <DMA_CheckFifoParam+0xe8>

      case DMA_FIFO_THRESHOLD_HALFFULL:
        if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
24005192:	687b      	ldr	r3, [r7, #4]
24005194:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24005196:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
2400519a:	2b00      	cmp	r3, #0
2400519c:	d025      	beq.n	240051ea <DMA_CheckFifoParam+0xde>
        {
          status = HAL_ERROR;
2400519e:	2301      	movs	r3, #1
240051a0:	73fb      	strb	r3, [r7, #15]
        }
        break;
240051a2:	e022      	b.n	240051ea <DMA_CheckFifoParam+0xde>

      case DMA_FIFO_THRESHOLD_FULL:
        if (hdma->Init.MemBurst == DMA_MBURST_INC16)
240051a4:	687b      	ldr	r3, [r7, #4]
240051a6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
240051a8:	f1b3 7fc0 	cmp.w	r3, #25165824	; 0x1800000
240051ac:	d11f      	bne.n	240051ee <DMA_CheckFifoParam+0xe2>
        {
          status = HAL_ERROR;
240051ae:	2301      	movs	r3, #1
240051b0:	73fb      	strb	r3, [r7, #15]
        }
        break;
240051b2:	e01c      	b.n	240051ee <DMA_CheckFifoParam+0xe2>
  }

  /* Memory Data size equal to Word */
  else
  {
    switch (hdma->Init.FIFOThreshold)
240051b4:	687b      	ldr	r3, [r7, #4]
240051b6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
240051b8:	2b02      	cmp	r3, #2
240051ba:	d902      	bls.n	240051c2 <DMA_CheckFifoParam+0xb6>
240051bc:	2b03      	cmp	r3, #3
240051be:	d003      	beq.n	240051c8 <DMA_CheckFifoParam+0xbc>
          status = HAL_ERROR;
        }
    break;

      default:
        break;
240051c0:	e018      	b.n	240051f4 <DMA_CheckFifoParam+0xe8>
        status = HAL_ERROR;
240051c2:	2301      	movs	r3, #1
240051c4:	73fb      	strb	r3, [r7, #15]
        break;
240051c6:	e015      	b.n	240051f4 <DMA_CheckFifoParam+0xe8>
        if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
240051c8:	687b      	ldr	r3, [r7, #4]
240051ca:	6adb      	ldr	r3, [r3, #44]	; 0x2c
240051cc:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
240051d0:	2b00      	cmp	r3, #0
240051d2:	d00e      	beq.n	240051f2 <DMA_CheckFifoParam+0xe6>
          status = HAL_ERROR;
240051d4:	2301      	movs	r3, #1
240051d6:	73fb      	strb	r3, [r7, #15]
    break;
240051d8:	e00b      	b.n	240051f2 <DMA_CheckFifoParam+0xe6>
        break;
240051da:	bf00      	nop
240051dc:	e00a      	b.n	240051f4 <DMA_CheckFifoParam+0xe8>
        break;
240051de:	bf00      	nop
240051e0:	e008      	b.n	240051f4 <DMA_CheckFifoParam+0xe8>
        break;
240051e2:	bf00      	nop
240051e4:	e006      	b.n	240051f4 <DMA_CheckFifoParam+0xe8>
        break;
240051e6:	bf00      	nop
240051e8:	e004      	b.n	240051f4 <DMA_CheckFifoParam+0xe8>
        break;
240051ea:	bf00      	nop
240051ec:	e002      	b.n	240051f4 <DMA_CheckFifoParam+0xe8>
        break;
240051ee:	bf00      	nop
240051f0:	e000      	b.n	240051f4 <DMA_CheckFifoParam+0xe8>
    break;
240051f2:	bf00      	nop
    }
  }

  return status;
240051f4:	7bfb      	ldrb	r3, [r7, #15]
}
240051f6:	4618      	mov	r0, r3
240051f8:	3714      	adds	r7, #20
240051fa:	46bd      	mov	sp, r7
240051fc:	f85d 7b04 	ldr.w	r7, [sp], #4
24005200:	4770      	bx	lr
24005202:	bf00      	nop

24005204 <DMA_CalcDMAMUXChannelBaseAndMask>:
  * @param  hdma:       pointer to a DMA_HandleTypeDef structure that contains
  *                     the configuration information for the specified DMA Stream.
  * @retval HAL status
  */
static void DMA_CalcDMAMUXChannelBaseAndMask(DMA_HandleTypeDef *hdma)
{
24005204:	b480      	push	{r7}
24005206:	b085      	sub	sp, #20
24005208:	af00      	add	r7, sp, #0
2400520a:	6078      	str	r0, [r7, #4]
  uint32_t stream_number;
  uint32_t stream_baseaddress = (uint32_t)((uint32_t*)hdma->Instance);
2400520c:	687b      	ldr	r3, [r7, #4]
2400520e:	681b      	ldr	r3, [r3, #0]
24005210:	60bb      	str	r3, [r7, #8]

  if(IS_BDMA_CHANNEL_DMAMUX_INSTANCE(hdma->Instance) != 0U)
24005212:	687b      	ldr	r3, [r7, #4]
24005214:	681b      	ldr	r3, [r3, #0]
24005216:	4a38      	ldr	r2, [pc, #224]	; (240052f8 <DMA_CalcDMAMUXChannelBaseAndMask+0xf4>)
24005218:	4293      	cmp	r3, r2
2400521a:	d022      	beq.n	24005262 <DMA_CalcDMAMUXChannelBaseAndMask+0x5e>
2400521c:	687b      	ldr	r3, [r7, #4]
2400521e:	681b      	ldr	r3, [r3, #0]
24005220:	4a36      	ldr	r2, [pc, #216]	; (240052fc <DMA_CalcDMAMUXChannelBaseAndMask+0xf8>)
24005222:	4293      	cmp	r3, r2
24005224:	d01d      	beq.n	24005262 <DMA_CalcDMAMUXChannelBaseAndMask+0x5e>
24005226:	687b      	ldr	r3, [r7, #4]
24005228:	681b      	ldr	r3, [r3, #0]
2400522a:	4a35      	ldr	r2, [pc, #212]	; (24005300 <DMA_CalcDMAMUXChannelBaseAndMask+0xfc>)
2400522c:	4293      	cmp	r3, r2
2400522e:	d018      	beq.n	24005262 <DMA_CalcDMAMUXChannelBaseAndMask+0x5e>
24005230:	687b      	ldr	r3, [r7, #4]
24005232:	681b      	ldr	r3, [r3, #0]
24005234:	4a33      	ldr	r2, [pc, #204]	; (24005304 <DMA_CalcDMAMUXChannelBaseAndMask+0x100>)
24005236:	4293      	cmp	r3, r2
24005238:	d013      	beq.n	24005262 <DMA_CalcDMAMUXChannelBaseAndMask+0x5e>
2400523a:	687b      	ldr	r3, [r7, #4]
2400523c:	681b      	ldr	r3, [r3, #0]
2400523e:	4a32      	ldr	r2, [pc, #200]	; (24005308 <DMA_CalcDMAMUXChannelBaseAndMask+0x104>)
24005240:	4293      	cmp	r3, r2
24005242:	d00e      	beq.n	24005262 <DMA_CalcDMAMUXChannelBaseAndMask+0x5e>
24005244:	687b      	ldr	r3, [r7, #4]
24005246:	681b      	ldr	r3, [r3, #0]
24005248:	4a30      	ldr	r2, [pc, #192]	; (2400530c <DMA_CalcDMAMUXChannelBaseAndMask+0x108>)
2400524a:	4293      	cmp	r3, r2
2400524c:	d009      	beq.n	24005262 <DMA_CalcDMAMUXChannelBaseAndMask+0x5e>
2400524e:	687b      	ldr	r3, [r7, #4]
24005250:	681b      	ldr	r3, [r3, #0]
24005252:	4a2f      	ldr	r2, [pc, #188]	; (24005310 <DMA_CalcDMAMUXChannelBaseAndMask+0x10c>)
24005254:	4293      	cmp	r3, r2
24005256:	d004      	beq.n	24005262 <DMA_CalcDMAMUXChannelBaseAndMask+0x5e>
24005258:	687b      	ldr	r3, [r7, #4]
2400525a:	681b      	ldr	r3, [r3, #0]
2400525c:	4a2d      	ldr	r2, [pc, #180]	; (24005314 <DMA_CalcDMAMUXChannelBaseAndMask+0x110>)
2400525e:	4293      	cmp	r3, r2
24005260:	d101      	bne.n	24005266 <DMA_CalcDMAMUXChannelBaseAndMask+0x62>
24005262:	2301      	movs	r3, #1
24005264:	e000      	b.n	24005268 <DMA_CalcDMAMUXChannelBaseAndMask+0x64>
24005266:	2300      	movs	r3, #0
24005268:	2b00      	cmp	r3, #0
2400526a:	d01a      	beq.n	240052a2 <DMA_CalcDMAMUXChannelBaseAndMask+0x9e>
  {
    /* BDMA Channels are connected to DMAMUX2 channels */
    stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 8U) / 20U;
2400526c:	687b      	ldr	r3, [r7, #4]
2400526e:	681b      	ldr	r3, [r3, #0]
24005270:	b2db      	uxtb	r3, r3
24005272:	3b08      	subs	r3, #8
24005274:	4a28      	ldr	r2, [pc, #160]	; (24005318 <DMA_CalcDMAMUXChannelBaseAndMask+0x114>)
24005276:	fba2 2303 	umull	r2, r3, r2, r3
2400527a:	091b      	lsrs	r3, r3, #4
2400527c:	60fb      	str	r3, [r7, #12]
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX2_Channel0) + (stream_number * 4U)));
2400527e:	68fa      	ldr	r2, [r7, #12]
24005280:	4b26      	ldr	r3, [pc, #152]	; (2400531c <DMA_CalcDMAMUXChannelBaseAndMask+0x118>)
24005282:	4413      	add	r3, r2
24005284:	009b      	lsls	r3, r3, #2
24005286:	461a      	mov	r2, r3
24005288:	687b      	ldr	r3, [r7, #4]
2400528a:	661a      	str	r2, [r3, #96]	; 0x60
    hdma->DMAmuxChannelStatus = DMAMUX2_ChannelStatus;
2400528c:	687b      	ldr	r3, [r7, #4]
2400528e:	4a24      	ldr	r2, [pc, #144]	; (24005320 <DMA_CalcDMAMUXChannelBaseAndMask+0x11c>)
24005290:	665a      	str	r2, [r3, #100]	; 0x64
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
24005292:	68fb      	ldr	r3, [r7, #12]
24005294:	f003 031f 	and.w	r3, r3, #31
24005298:	2201      	movs	r2, #1
2400529a:	409a      	lsls	r2, r3
2400529c:	687b      	ldr	r3, [r7, #4]
2400529e:	669a      	str	r2, [r3, #104]	; 0x68
    }
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_Channel0) + (stream_number * 4U)));
    hdma->DMAmuxChannelStatus = DMAMUX1_ChannelStatus;
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
  }
}
240052a0:	e024      	b.n	240052ec <DMA_CalcDMAMUXChannelBaseAndMask+0xe8>
    stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 16U) / 24U;
240052a2:	687b      	ldr	r3, [r7, #4]
240052a4:	681b      	ldr	r3, [r3, #0]
240052a6:	b2db      	uxtb	r3, r3
240052a8:	3b10      	subs	r3, #16
240052aa:	4a1e      	ldr	r2, [pc, #120]	; (24005324 <DMA_CalcDMAMUXChannelBaseAndMask+0x120>)
240052ac:	fba2 2303 	umull	r2, r3, r2, r3
240052b0:	091b      	lsrs	r3, r3, #4
240052b2:	60fb      	str	r3, [r7, #12]
    if((stream_baseaddress <= ((uint32_t)DMA2_Stream7) ) && \
240052b4:	68bb      	ldr	r3, [r7, #8]
240052b6:	4a1c      	ldr	r2, [pc, #112]	; (24005328 <DMA_CalcDMAMUXChannelBaseAndMask+0x124>)
240052b8:	4293      	cmp	r3, r2
240052ba:	d806      	bhi.n	240052ca <DMA_CalcDMAMUXChannelBaseAndMask+0xc6>
240052bc:	68bb      	ldr	r3, [r7, #8]
240052be:	4a1b      	ldr	r2, [pc, #108]	; (2400532c <DMA_CalcDMAMUXChannelBaseAndMask+0x128>)
240052c0:	4293      	cmp	r3, r2
240052c2:	d902      	bls.n	240052ca <DMA_CalcDMAMUXChannelBaseAndMask+0xc6>
      stream_number += 8U;
240052c4:	68fb      	ldr	r3, [r7, #12]
240052c6:	3308      	adds	r3, #8
240052c8:	60fb      	str	r3, [r7, #12]
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_Channel0) + (stream_number * 4U)));
240052ca:	68fa      	ldr	r2, [r7, #12]
240052cc:	4b18      	ldr	r3, [pc, #96]	; (24005330 <DMA_CalcDMAMUXChannelBaseAndMask+0x12c>)
240052ce:	4413      	add	r3, r2
240052d0:	009b      	lsls	r3, r3, #2
240052d2:	461a      	mov	r2, r3
240052d4:	687b      	ldr	r3, [r7, #4]
240052d6:	661a      	str	r2, [r3, #96]	; 0x60
    hdma->DMAmuxChannelStatus = DMAMUX1_ChannelStatus;
240052d8:	687b      	ldr	r3, [r7, #4]
240052da:	4a16      	ldr	r2, [pc, #88]	; (24005334 <DMA_CalcDMAMUXChannelBaseAndMask+0x130>)
240052dc:	665a      	str	r2, [r3, #100]	; 0x64
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
240052de:	68fb      	ldr	r3, [r7, #12]
240052e0:	f003 031f 	and.w	r3, r3, #31
240052e4:	2201      	movs	r2, #1
240052e6:	409a      	lsls	r2, r3
240052e8:	687b      	ldr	r3, [r7, #4]
240052ea:	669a      	str	r2, [r3, #104]	; 0x68
}
240052ec:	bf00      	nop
240052ee:	3714      	adds	r7, #20
240052f0:	46bd      	mov	sp, r7
240052f2:	f85d 7b04 	ldr.w	r7, [sp], #4
240052f6:	4770      	bx	lr
240052f8:	58025408 	.word	0x58025408
240052fc:	5802541c 	.word	0x5802541c
24005300:	58025430 	.word	0x58025430
24005304:	58025444 	.word	0x58025444
24005308:	58025458 	.word	0x58025458
2400530c:	5802546c 	.word	0x5802546c
24005310:	58025480 	.word	0x58025480
24005314:	58025494 	.word	0x58025494
24005318:	cccccccd 	.word	0xcccccccd
2400531c:	16009600 	.word	0x16009600
24005320:	58025880 	.word	0x58025880
24005324:	aaaaaaab 	.word	0xaaaaaaab
24005328:	400204b8 	.word	0x400204b8
2400532c:	4002040f 	.word	0x4002040f
24005330:	10008200 	.word	0x10008200
24005334:	40020880 	.word	0x40020880

24005338 <DMA_CalcDMAMUXRequestGenBaseAndMask>:
  * @param  hdma:       pointer to a DMA_HandleTypeDef structure that contains
  *                     the configuration information for the specified DMA Stream.
  * @retval HAL status
  */
static void DMA_CalcDMAMUXRequestGenBaseAndMask(DMA_HandleTypeDef *hdma)
{
24005338:	b480      	push	{r7}
2400533a:	b085      	sub	sp, #20
2400533c:	af00      	add	r7, sp, #0
2400533e:	6078      	str	r0, [r7, #4]
  uint32_t request =  hdma->Init.Request & DMAMUX_CxCR_DMAREQ_ID;
24005340:	687b      	ldr	r3, [r7, #4]
24005342:	685b      	ldr	r3, [r3, #4]
24005344:	b2db      	uxtb	r3, r3
24005346:	60fb      	str	r3, [r7, #12]

  if((request >= DMA_REQUEST_GENERATOR0) && (request <= DMA_REQUEST_GENERATOR7))
24005348:	68fb      	ldr	r3, [r7, #12]
2400534a:	2b00      	cmp	r3, #0
2400534c:	d04a      	beq.n	240053e4 <DMA_CalcDMAMUXRequestGenBaseAndMask+0xac>
2400534e:	68fb      	ldr	r3, [r7, #12]
24005350:	2b08      	cmp	r3, #8
24005352:	d847      	bhi.n	240053e4 <DMA_CalcDMAMUXRequestGenBaseAndMask+0xac>
  {
    if(IS_BDMA_CHANNEL_DMAMUX_INSTANCE(hdma->Instance) != 0U)
24005354:	687b      	ldr	r3, [r7, #4]
24005356:	681b      	ldr	r3, [r3, #0]
24005358:	4a25      	ldr	r2, [pc, #148]	; (240053f0 <DMA_CalcDMAMUXRequestGenBaseAndMask+0xb8>)
2400535a:	4293      	cmp	r3, r2
2400535c:	d022      	beq.n	240053a4 <DMA_CalcDMAMUXRequestGenBaseAndMask+0x6c>
2400535e:	687b      	ldr	r3, [r7, #4]
24005360:	681b      	ldr	r3, [r3, #0]
24005362:	4a24      	ldr	r2, [pc, #144]	; (240053f4 <DMA_CalcDMAMUXRequestGenBaseAndMask+0xbc>)
24005364:	4293      	cmp	r3, r2
24005366:	d01d      	beq.n	240053a4 <DMA_CalcDMAMUXRequestGenBaseAndMask+0x6c>
24005368:	687b      	ldr	r3, [r7, #4]
2400536a:	681b      	ldr	r3, [r3, #0]
2400536c:	4a22      	ldr	r2, [pc, #136]	; (240053f8 <DMA_CalcDMAMUXRequestGenBaseAndMask+0xc0>)
2400536e:	4293      	cmp	r3, r2
24005370:	d018      	beq.n	240053a4 <DMA_CalcDMAMUXRequestGenBaseAndMask+0x6c>
24005372:	687b      	ldr	r3, [r7, #4]
24005374:	681b      	ldr	r3, [r3, #0]
24005376:	4a21      	ldr	r2, [pc, #132]	; (240053fc <DMA_CalcDMAMUXRequestGenBaseAndMask+0xc4>)
24005378:	4293      	cmp	r3, r2
2400537a:	d013      	beq.n	240053a4 <DMA_CalcDMAMUXRequestGenBaseAndMask+0x6c>
2400537c:	687b      	ldr	r3, [r7, #4]
2400537e:	681b      	ldr	r3, [r3, #0]
24005380:	4a1f      	ldr	r2, [pc, #124]	; (24005400 <DMA_CalcDMAMUXRequestGenBaseAndMask+0xc8>)
24005382:	4293      	cmp	r3, r2
24005384:	d00e      	beq.n	240053a4 <DMA_CalcDMAMUXRequestGenBaseAndMask+0x6c>
24005386:	687b      	ldr	r3, [r7, #4]
24005388:	681b      	ldr	r3, [r3, #0]
2400538a:	4a1e      	ldr	r2, [pc, #120]	; (24005404 <DMA_CalcDMAMUXRequestGenBaseAndMask+0xcc>)
2400538c:	4293      	cmp	r3, r2
2400538e:	d009      	beq.n	240053a4 <DMA_CalcDMAMUXRequestGenBaseAndMask+0x6c>
24005390:	687b      	ldr	r3, [r7, #4]
24005392:	681b      	ldr	r3, [r3, #0]
24005394:	4a1c      	ldr	r2, [pc, #112]	; (24005408 <DMA_CalcDMAMUXRequestGenBaseAndMask+0xd0>)
24005396:	4293      	cmp	r3, r2
24005398:	d004      	beq.n	240053a4 <DMA_CalcDMAMUXRequestGenBaseAndMask+0x6c>
2400539a:	687b      	ldr	r3, [r7, #4]
2400539c:	681b      	ldr	r3, [r3, #0]
2400539e:	4a1b      	ldr	r2, [pc, #108]	; (2400540c <DMA_CalcDMAMUXRequestGenBaseAndMask+0xd4>)
240053a0:	4293      	cmp	r3, r2
240053a2:	d101      	bne.n	240053a8 <DMA_CalcDMAMUXRequestGenBaseAndMask+0x70>
240053a4:	2301      	movs	r3, #1
240053a6:	e000      	b.n	240053aa <DMA_CalcDMAMUXRequestGenBaseAndMask+0x72>
240053a8:	2300      	movs	r3, #0
240053aa:	2b00      	cmp	r3, #0
240053ac:	d00a      	beq.n	240053c4 <DMA_CalcDMAMUXRequestGenBaseAndMask+0x8c>
    {
      /* BDMA Channels are connected to DMAMUX2 request generator blocks */
      hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX2_RequestGenerator0) + ((request - 1U) * 4U)));
240053ae:	68fa      	ldr	r2, [r7, #12]
240053b0:	4b17      	ldr	r3, [pc, #92]	; (24005410 <DMA_CalcDMAMUXRequestGenBaseAndMask+0xd8>)
240053b2:	4413      	add	r3, r2
240053b4:	009b      	lsls	r3, r3, #2
240053b6:	461a      	mov	r2, r3
240053b8:	687b      	ldr	r3, [r7, #4]
240053ba:	66da      	str	r2, [r3, #108]	; 0x6c

      hdma->DMAmuxRequestGenStatus = DMAMUX2_RequestGenStatus;
240053bc:	687b      	ldr	r3, [r7, #4]
240053be:	4a15      	ldr	r2, [pc, #84]	; (24005414 <DMA_CalcDMAMUXRequestGenBaseAndMask+0xdc>)
240053c0:	671a      	str	r2, [r3, #112]	; 0x70
240053c2:	e009      	b.n	240053d8 <DMA_CalcDMAMUXRequestGenBaseAndMask+0xa0>
    }
    else
    {
      /* DMA1 and DMA2 Streams use DMAMUX1 request generator blocks */
      hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_RequestGenerator0) + ((request - 1U) * 4U)));
240053c4:	68fa      	ldr	r2, [r7, #12]
240053c6:	4b14      	ldr	r3, [pc, #80]	; (24005418 <DMA_CalcDMAMUXRequestGenBaseAndMask+0xe0>)
240053c8:	4413      	add	r3, r2
240053ca:	009b      	lsls	r3, r3, #2
240053cc:	461a      	mov	r2, r3
240053ce:	687b      	ldr	r3, [r7, #4]
240053d0:	66da      	str	r2, [r3, #108]	; 0x6c

      hdma->DMAmuxRequestGenStatus = DMAMUX1_RequestGenStatus;
240053d2:	687b      	ldr	r3, [r7, #4]
240053d4:	4a11      	ldr	r2, [pc, #68]	; (2400541c <DMA_CalcDMAMUXRequestGenBaseAndMask+0xe4>)
240053d6:	671a      	str	r2, [r3, #112]	; 0x70
    }

    hdma->DMAmuxRequestGenStatusMask = 1UL << (request - 1U);
240053d8:	68fb      	ldr	r3, [r7, #12]
240053da:	3b01      	subs	r3, #1
240053dc:	2201      	movs	r2, #1
240053de:	409a      	lsls	r2, r3
240053e0:	687b      	ldr	r3, [r7, #4]
240053e2:	675a      	str	r2, [r3, #116]	; 0x74
  }
}
240053e4:	bf00      	nop
240053e6:	3714      	adds	r7, #20
240053e8:	46bd      	mov	sp, r7
240053ea:	f85d 7b04 	ldr.w	r7, [sp], #4
240053ee:	4770      	bx	lr
240053f0:	58025408 	.word	0x58025408
240053f4:	5802541c 	.word	0x5802541c
240053f8:	58025430 	.word	0x58025430
240053fc:	58025444 	.word	0x58025444
24005400:	58025458 	.word	0x58025458
24005404:	5802546c 	.word	0x5802546c
24005408:	58025480 	.word	0x58025480
2400540c:	58025494 	.word	0x58025494
24005410:	1600963f 	.word	0x1600963f
24005414:	58025940 	.word	0x58025940
24005418:	1000823f 	.word	0x1000823f
2400541c:	40020940 	.word	0x40020940

24005420 <HAL_DMAEx_MultiBufferStart>:
  * @param  SecondMemAddress: The second memory Buffer address in case of multi buffer Transfer
  * @param  DataLength: The length of data to be transferred from source to destination
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMAEx_MultiBufferStart(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t SecondMemAddress, uint32_t DataLength)
{
24005420:	b580      	push	{r7, lr}
24005422:	b086      	sub	sp, #24
24005424:	af00      	add	r7, sp, #0
24005426:	60f8      	str	r0, [r7, #12]
24005428:	60b9      	str	r1, [r7, #8]
2400542a:	607a      	str	r2, [r7, #4]
2400542c:	603b      	str	r3, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
2400542e:	2300      	movs	r3, #0
24005430:	75fb      	strb	r3, [r7, #23]
  /* Check the parameters */
  assert_param(IS_DMA_BUFFER_SIZE(DataLength));
  assert_param(IS_DMA_ALL_INSTANCE(hdma->Instance));

  /* Memory-to-memory transfer not supported in double buffering mode */
  if (hdma->Init.Direction == DMA_MEMORY_TO_MEMORY)
24005432:	68fb      	ldr	r3, [r7, #12]
24005434:	689b      	ldr	r3, [r3, #8]
24005436:	2b80      	cmp	r3, #128	; 0x80
24005438:	d106      	bne.n	24005448 <HAL_DMAEx_MultiBufferStart+0x28>
  {
    hdma->ErrorCode = HAL_DMA_ERROR_NOT_SUPPORTED;
2400543a:	68fb      	ldr	r3, [r7, #12]
2400543c:	f44f 7280 	mov.w	r2, #256	; 0x100
24005440:	655a      	str	r2, [r3, #84]	; 0x54
    status = HAL_ERROR;
24005442:	2301      	movs	r3, #1
24005444:	75fb      	strb	r3, [r7, #23]
24005446:	e1c8      	b.n	240057da <HAL_DMAEx_MultiBufferStart+0x3ba>
  }
  else
  {
    /* Process Locked */
    __HAL_LOCK(hdma);
24005448:	68fb      	ldr	r3, [r7, #12]
2400544a:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
2400544e:	2b01      	cmp	r3, #1
24005450:	d101      	bne.n	24005456 <HAL_DMAEx_MultiBufferStart+0x36>
24005452:	2302      	movs	r3, #2
24005454:	e1c2      	b.n	240057dc <HAL_DMAEx_MultiBufferStart+0x3bc>
24005456:	68fb      	ldr	r3, [r7, #12]
24005458:	2201      	movs	r2, #1
2400545a:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

    if(HAL_DMA_STATE_READY == hdma->State)
2400545e:	68fb      	ldr	r3, [r7, #12]
24005460:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
24005464:	b2db      	uxtb	r3, r3
24005466:	2b01      	cmp	r3, #1
24005468:	f040 81b1 	bne.w	240057ce <HAL_DMAEx_MultiBufferStart+0x3ae>
    {
      /* Change DMA peripheral state */
      hdma->State = HAL_DMA_STATE_BUSY;
2400546c:	68fb      	ldr	r3, [r7, #12]
2400546e:	2202      	movs	r2, #2
24005470:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

      /* Initialize the error code */
      hdma->ErrorCode = HAL_DMA_ERROR_NONE;
24005474:	68fb      	ldr	r3, [r7, #12]
24005476:	2200      	movs	r2, #0
24005478:	655a      	str	r2, [r3, #84]	; 0x54

      if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
2400547a:	68fb      	ldr	r3, [r7, #12]
2400547c:	681b      	ldr	r3, [r3, #0]
2400547e:	4a7f      	ldr	r2, [pc, #508]	; (2400567c <HAL_DMAEx_MultiBufferStart+0x25c>)
24005480:	4293      	cmp	r3, r2
24005482:	d04a      	beq.n	2400551a <HAL_DMAEx_MultiBufferStart+0xfa>
24005484:	68fb      	ldr	r3, [r7, #12]
24005486:	681b      	ldr	r3, [r3, #0]
24005488:	4a7d      	ldr	r2, [pc, #500]	; (24005680 <HAL_DMAEx_MultiBufferStart+0x260>)
2400548a:	4293      	cmp	r3, r2
2400548c:	d045      	beq.n	2400551a <HAL_DMAEx_MultiBufferStart+0xfa>
2400548e:	68fb      	ldr	r3, [r7, #12]
24005490:	681b      	ldr	r3, [r3, #0]
24005492:	4a7c      	ldr	r2, [pc, #496]	; (24005684 <HAL_DMAEx_MultiBufferStart+0x264>)
24005494:	4293      	cmp	r3, r2
24005496:	d040      	beq.n	2400551a <HAL_DMAEx_MultiBufferStart+0xfa>
24005498:	68fb      	ldr	r3, [r7, #12]
2400549a:	681b      	ldr	r3, [r3, #0]
2400549c:	4a7a      	ldr	r2, [pc, #488]	; (24005688 <HAL_DMAEx_MultiBufferStart+0x268>)
2400549e:	4293      	cmp	r3, r2
240054a0:	d03b      	beq.n	2400551a <HAL_DMAEx_MultiBufferStart+0xfa>
240054a2:	68fb      	ldr	r3, [r7, #12]
240054a4:	681b      	ldr	r3, [r3, #0]
240054a6:	4a79      	ldr	r2, [pc, #484]	; (2400568c <HAL_DMAEx_MultiBufferStart+0x26c>)
240054a8:	4293      	cmp	r3, r2
240054aa:	d036      	beq.n	2400551a <HAL_DMAEx_MultiBufferStart+0xfa>
240054ac:	68fb      	ldr	r3, [r7, #12]
240054ae:	681b      	ldr	r3, [r3, #0]
240054b0:	4a77      	ldr	r2, [pc, #476]	; (24005690 <HAL_DMAEx_MultiBufferStart+0x270>)
240054b2:	4293      	cmp	r3, r2
240054b4:	d031      	beq.n	2400551a <HAL_DMAEx_MultiBufferStart+0xfa>
240054b6:	68fb      	ldr	r3, [r7, #12]
240054b8:	681b      	ldr	r3, [r3, #0]
240054ba:	4a76      	ldr	r2, [pc, #472]	; (24005694 <HAL_DMAEx_MultiBufferStart+0x274>)
240054bc:	4293      	cmp	r3, r2
240054be:	d02c      	beq.n	2400551a <HAL_DMAEx_MultiBufferStart+0xfa>
240054c0:	68fb      	ldr	r3, [r7, #12]
240054c2:	681b      	ldr	r3, [r3, #0]
240054c4:	4a74      	ldr	r2, [pc, #464]	; (24005698 <HAL_DMAEx_MultiBufferStart+0x278>)
240054c6:	4293      	cmp	r3, r2
240054c8:	d027      	beq.n	2400551a <HAL_DMAEx_MultiBufferStart+0xfa>
240054ca:	68fb      	ldr	r3, [r7, #12]
240054cc:	681b      	ldr	r3, [r3, #0]
240054ce:	4a73      	ldr	r2, [pc, #460]	; (2400569c <HAL_DMAEx_MultiBufferStart+0x27c>)
240054d0:	4293      	cmp	r3, r2
240054d2:	d022      	beq.n	2400551a <HAL_DMAEx_MultiBufferStart+0xfa>
240054d4:	68fb      	ldr	r3, [r7, #12]
240054d6:	681b      	ldr	r3, [r3, #0]
240054d8:	4a71      	ldr	r2, [pc, #452]	; (240056a0 <HAL_DMAEx_MultiBufferStart+0x280>)
240054da:	4293      	cmp	r3, r2
240054dc:	d01d      	beq.n	2400551a <HAL_DMAEx_MultiBufferStart+0xfa>
240054de:	68fb      	ldr	r3, [r7, #12]
240054e0:	681b      	ldr	r3, [r3, #0]
240054e2:	4a70      	ldr	r2, [pc, #448]	; (240056a4 <HAL_DMAEx_MultiBufferStart+0x284>)
240054e4:	4293      	cmp	r3, r2
240054e6:	d018      	beq.n	2400551a <HAL_DMAEx_MultiBufferStart+0xfa>
240054e8:	68fb      	ldr	r3, [r7, #12]
240054ea:	681b      	ldr	r3, [r3, #0]
240054ec:	4a6e      	ldr	r2, [pc, #440]	; (240056a8 <HAL_DMAEx_MultiBufferStart+0x288>)
240054ee:	4293      	cmp	r3, r2
240054f0:	d013      	beq.n	2400551a <HAL_DMAEx_MultiBufferStart+0xfa>
240054f2:	68fb      	ldr	r3, [r7, #12]
240054f4:	681b      	ldr	r3, [r3, #0]
240054f6:	4a6d      	ldr	r2, [pc, #436]	; (240056ac <HAL_DMAEx_MultiBufferStart+0x28c>)
240054f8:	4293      	cmp	r3, r2
240054fa:	d00e      	beq.n	2400551a <HAL_DMAEx_MultiBufferStart+0xfa>
240054fc:	68fb      	ldr	r3, [r7, #12]
240054fe:	681b      	ldr	r3, [r3, #0]
24005500:	4a6b      	ldr	r2, [pc, #428]	; (240056b0 <HAL_DMAEx_MultiBufferStart+0x290>)
24005502:	4293      	cmp	r3, r2
24005504:	d009      	beq.n	2400551a <HAL_DMAEx_MultiBufferStart+0xfa>
24005506:	68fb      	ldr	r3, [r7, #12]
24005508:	681b      	ldr	r3, [r3, #0]
2400550a:	4a6a      	ldr	r2, [pc, #424]	; (240056b4 <HAL_DMAEx_MultiBufferStart+0x294>)
2400550c:	4293      	cmp	r3, r2
2400550e:	d004      	beq.n	2400551a <HAL_DMAEx_MultiBufferStart+0xfa>
24005510:	68fb      	ldr	r3, [r7, #12]
24005512:	681b      	ldr	r3, [r3, #0]
24005514:	4a68      	ldr	r2, [pc, #416]	; (240056b8 <HAL_DMAEx_MultiBufferStart+0x298>)
24005516:	4293      	cmp	r3, r2
24005518:	d101      	bne.n	2400551e <HAL_DMAEx_MultiBufferStart+0xfe>
2400551a:	2301      	movs	r3, #1
2400551c:	e000      	b.n	24005520 <HAL_DMAEx_MultiBufferStart+0x100>
2400551e:	2300      	movs	r3, #0
24005520:	2b00      	cmp	r3, #0
24005522:	d018      	beq.n	24005556 <HAL_DMAEx_MultiBufferStart+0x136>
      {
        /* Enable the Double buffer mode */
        ((DMA_Stream_TypeDef   *)hdma->Instance)->CR |= DMA_SxCR_DBM;
24005524:	68fb      	ldr	r3, [r7, #12]
24005526:	681b      	ldr	r3, [r3, #0]
24005528:	681a      	ldr	r2, [r3, #0]
2400552a:	68fb      	ldr	r3, [r7, #12]
2400552c:	681b      	ldr	r3, [r3, #0]
2400552e:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
24005532:	601a      	str	r2, [r3, #0]

        /* Configure DMA Stream destination address */
        ((DMA_Stream_TypeDef   *)hdma->Instance)->M1AR = SecondMemAddress;
24005534:	68fb      	ldr	r3, [r7, #12]
24005536:	681b      	ldr	r3, [r3, #0]
24005538:	683a      	ldr	r2, [r7, #0]
2400553a:	611a      	str	r2, [r3, #16]

        /* Calculate the interrupt clear flag register (IFCR) base address  */
        ifcRegister_Base = (uint32_t *)((uint32_t)(hdma->StreamBaseAddress + 8U));
2400553c:	68fb      	ldr	r3, [r7, #12]
2400553e:	6d9b      	ldr	r3, [r3, #88]	; 0x58
24005540:	3308      	adds	r3, #8
24005542:	613b      	str	r3, [r7, #16]

        /* Clear all flags */
        *ifcRegister_Base = 0x3FUL << (hdma->StreamIndex & 0x1FU);
24005544:	68fb      	ldr	r3, [r7, #12]
24005546:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24005548:	f003 031f 	and.w	r3, r3, #31
2400554c:	223f      	movs	r2, #63	; 0x3f
2400554e:	409a      	lsls	r2, r3
24005550:	693b      	ldr	r3, [r7, #16]
24005552:	601a      	str	r2, [r3, #0]
24005554:	e018      	b.n	24005588 <HAL_DMAEx_MultiBufferStart+0x168>
      }
      else /* BDMA instance(s) */
      {
        /* Enable the Double buffer mode */
        ((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR |= (BDMA_CCR_DBM | BDMA_CCR_CIRC);
24005556:	68fb      	ldr	r3, [r7, #12]
24005558:	681b      	ldr	r3, [r3, #0]
2400555a:	6819      	ldr	r1, [r3, #0]
2400555c:	68fb      	ldr	r3, [r7, #12]
2400555e:	681a      	ldr	r2, [r3, #0]
24005560:	f248 0320 	movw	r3, #32800	; 0x8020
24005564:	430b      	orrs	r3, r1
24005566:	6013      	str	r3, [r2, #0]

        /* Configure DMA Stream destination address */
        ((BDMA_Channel_TypeDef   *)hdma->Instance)->CM1AR = SecondMemAddress;
24005568:	68fb      	ldr	r3, [r7, #12]
2400556a:	681b      	ldr	r3, [r3, #0]
2400556c:	683a      	ldr	r2, [r7, #0]
2400556e:	611a      	str	r2, [r3, #16]

        /* Calculate the interrupt clear flag register (IFCR) base address  */
        ifcRegister_Base = (uint32_t *)((uint32_t)(hdma->StreamBaseAddress + 4U));
24005570:	68fb      	ldr	r3, [r7, #12]
24005572:	6d9b      	ldr	r3, [r3, #88]	; 0x58
24005574:	3304      	adds	r3, #4
24005576:	613b      	str	r3, [r7, #16]

        /* Clear all flags */
        *ifcRegister_Base = (BDMA_ISR_GIF0) << (hdma->StreamIndex & 0x1FU);
24005578:	68fb      	ldr	r3, [r7, #12]
2400557a:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
2400557c:	f003 031f 	and.w	r3, r3, #31
24005580:	2201      	movs	r2, #1
24005582:	409a      	lsls	r2, r3
24005584:	693b      	ldr	r3, [r7, #16]
24005586:	601a      	str	r2, [r3, #0]
      }

      if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
24005588:	68fb      	ldr	r3, [r7, #12]
2400558a:	681b      	ldr	r3, [r3, #0]
2400558c:	4a3b      	ldr	r2, [pc, #236]	; (2400567c <HAL_DMAEx_MultiBufferStart+0x25c>)
2400558e:	4293      	cmp	r3, r2
24005590:	d072      	beq.n	24005678 <HAL_DMAEx_MultiBufferStart+0x258>
24005592:	68fb      	ldr	r3, [r7, #12]
24005594:	681b      	ldr	r3, [r3, #0]
24005596:	4a3a      	ldr	r2, [pc, #232]	; (24005680 <HAL_DMAEx_MultiBufferStart+0x260>)
24005598:	4293      	cmp	r3, r2
2400559a:	d06d      	beq.n	24005678 <HAL_DMAEx_MultiBufferStart+0x258>
2400559c:	68fb      	ldr	r3, [r7, #12]
2400559e:	681b      	ldr	r3, [r3, #0]
240055a0:	4a38      	ldr	r2, [pc, #224]	; (24005684 <HAL_DMAEx_MultiBufferStart+0x264>)
240055a2:	4293      	cmp	r3, r2
240055a4:	d068      	beq.n	24005678 <HAL_DMAEx_MultiBufferStart+0x258>
240055a6:	68fb      	ldr	r3, [r7, #12]
240055a8:	681b      	ldr	r3, [r3, #0]
240055aa:	4a37      	ldr	r2, [pc, #220]	; (24005688 <HAL_DMAEx_MultiBufferStart+0x268>)
240055ac:	4293      	cmp	r3, r2
240055ae:	d063      	beq.n	24005678 <HAL_DMAEx_MultiBufferStart+0x258>
240055b0:	68fb      	ldr	r3, [r7, #12]
240055b2:	681b      	ldr	r3, [r3, #0]
240055b4:	4a35      	ldr	r2, [pc, #212]	; (2400568c <HAL_DMAEx_MultiBufferStart+0x26c>)
240055b6:	4293      	cmp	r3, r2
240055b8:	d05e      	beq.n	24005678 <HAL_DMAEx_MultiBufferStart+0x258>
240055ba:	68fb      	ldr	r3, [r7, #12]
240055bc:	681b      	ldr	r3, [r3, #0]
240055be:	4a34      	ldr	r2, [pc, #208]	; (24005690 <HAL_DMAEx_MultiBufferStart+0x270>)
240055c0:	4293      	cmp	r3, r2
240055c2:	d059      	beq.n	24005678 <HAL_DMAEx_MultiBufferStart+0x258>
240055c4:	68fb      	ldr	r3, [r7, #12]
240055c6:	681b      	ldr	r3, [r3, #0]
240055c8:	4a32      	ldr	r2, [pc, #200]	; (24005694 <HAL_DMAEx_MultiBufferStart+0x274>)
240055ca:	4293      	cmp	r3, r2
240055cc:	d054      	beq.n	24005678 <HAL_DMAEx_MultiBufferStart+0x258>
240055ce:	68fb      	ldr	r3, [r7, #12]
240055d0:	681b      	ldr	r3, [r3, #0]
240055d2:	4a31      	ldr	r2, [pc, #196]	; (24005698 <HAL_DMAEx_MultiBufferStart+0x278>)
240055d4:	4293      	cmp	r3, r2
240055d6:	d04f      	beq.n	24005678 <HAL_DMAEx_MultiBufferStart+0x258>
240055d8:	68fb      	ldr	r3, [r7, #12]
240055da:	681b      	ldr	r3, [r3, #0]
240055dc:	4a2f      	ldr	r2, [pc, #188]	; (2400569c <HAL_DMAEx_MultiBufferStart+0x27c>)
240055de:	4293      	cmp	r3, r2
240055e0:	d04a      	beq.n	24005678 <HAL_DMAEx_MultiBufferStart+0x258>
240055e2:	68fb      	ldr	r3, [r7, #12]
240055e4:	681b      	ldr	r3, [r3, #0]
240055e6:	4a2e      	ldr	r2, [pc, #184]	; (240056a0 <HAL_DMAEx_MultiBufferStart+0x280>)
240055e8:	4293      	cmp	r3, r2
240055ea:	d045      	beq.n	24005678 <HAL_DMAEx_MultiBufferStart+0x258>
240055ec:	68fb      	ldr	r3, [r7, #12]
240055ee:	681b      	ldr	r3, [r3, #0]
240055f0:	4a2c      	ldr	r2, [pc, #176]	; (240056a4 <HAL_DMAEx_MultiBufferStart+0x284>)
240055f2:	4293      	cmp	r3, r2
240055f4:	d040      	beq.n	24005678 <HAL_DMAEx_MultiBufferStart+0x258>
240055f6:	68fb      	ldr	r3, [r7, #12]
240055f8:	681b      	ldr	r3, [r3, #0]
240055fa:	4a2b      	ldr	r2, [pc, #172]	; (240056a8 <HAL_DMAEx_MultiBufferStart+0x288>)
240055fc:	4293      	cmp	r3, r2
240055fe:	d03b      	beq.n	24005678 <HAL_DMAEx_MultiBufferStart+0x258>
24005600:	68fb      	ldr	r3, [r7, #12]
24005602:	681b      	ldr	r3, [r3, #0]
24005604:	4a29      	ldr	r2, [pc, #164]	; (240056ac <HAL_DMAEx_MultiBufferStart+0x28c>)
24005606:	4293      	cmp	r3, r2
24005608:	d036      	beq.n	24005678 <HAL_DMAEx_MultiBufferStart+0x258>
2400560a:	68fb      	ldr	r3, [r7, #12]
2400560c:	681b      	ldr	r3, [r3, #0]
2400560e:	4a28      	ldr	r2, [pc, #160]	; (240056b0 <HAL_DMAEx_MultiBufferStart+0x290>)
24005610:	4293      	cmp	r3, r2
24005612:	d031      	beq.n	24005678 <HAL_DMAEx_MultiBufferStart+0x258>
24005614:	68fb      	ldr	r3, [r7, #12]
24005616:	681b      	ldr	r3, [r3, #0]
24005618:	4a26      	ldr	r2, [pc, #152]	; (240056b4 <HAL_DMAEx_MultiBufferStart+0x294>)
2400561a:	4293      	cmp	r3, r2
2400561c:	d02c      	beq.n	24005678 <HAL_DMAEx_MultiBufferStart+0x258>
2400561e:	68fb      	ldr	r3, [r7, #12]
24005620:	681b      	ldr	r3, [r3, #0]
24005622:	4a25      	ldr	r2, [pc, #148]	; (240056b8 <HAL_DMAEx_MultiBufferStart+0x298>)
24005624:	4293      	cmp	r3, r2
24005626:	d027      	beq.n	24005678 <HAL_DMAEx_MultiBufferStart+0x258>
24005628:	68fb      	ldr	r3, [r7, #12]
2400562a:	681b      	ldr	r3, [r3, #0]
2400562c:	4a23      	ldr	r2, [pc, #140]	; (240056bc <HAL_DMAEx_MultiBufferStart+0x29c>)
2400562e:	4293      	cmp	r3, r2
24005630:	d022      	beq.n	24005678 <HAL_DMAEx_MultiBufferStart+0x258>
24005632:	68fb      	ldr	r3, [r7, #12]
24005634:	681b      	ldr	r3, [r3, #0]
24005636:	4a22      	ldr	r2, [pc, #136]	; (240056c0 <HAL_DMAEx_MultiBufferStart+0x2a0>)
24005638:	4293      	cmp	r3, r2
2400563a:	d01d      	beq.n	24005678 <HAL_DMAEx_MultiBufferStart+0x258>
2400563c:	68fb      	ldr	r3, [r7, #12]
2400563e:	681b      	ldr	r3, [r3, #0]
24005640:	4a20      	ldr	r2, [pc, #128]	; (240056c4 <HAL_DMAEx_MultiBufferStart+0x2a4>)
24005642:	4293      	cmp	r3, r2
24005644:	d018      	beq.n	24005678 <HAL_DMAEx_MultiBufferStart+0x258>
24005646:	68fb      	ldr	r3, [r7, #12]
24005648:	681b      	ldr	r3, [r3, #0]
2400564a:	4a1f      	ldr	r2, [pc, #124]	; (240056c8 <HAL_DMAEx_MultiBufferStart+0x2a8>)
2400564c:	4293      	cmp	r3, r2
2400564e:	d013      	beq.n	24005678 <HAL_DMAEx_MultiBufferStart+0x258>
24005650:	68fb      	ldr	r3, [r7, #12]
24005652:	681b      	ldr	r3, [r3, #0]
24005654:	4a1d      	ldr	r2, [pc, #116]	; (240056cc <HAL_DMAEx_MultiBufferStart+0x2ac>)
24005656:	4293      	cmp	r3, r2
24005658:	d00e      	beq.n	24005678 <HAL_DMAEx_MultiBufferStart+0x258>
2400565a:	68fb      	ldr	r3, [r7, #12]
2400565c:	681b      	ldr	r3, [r3, #0]
2400565e:	4a1c      	ldr	r2, [pc, #112]	; (240056d0 <HAL_DMAEx_MultiBufferStart+0x2b0>)
24005660:	4293      	cmp	r3, r2
24005662:	d009      	beq.n	24005678 <HAL_DMAEx_MultiBufferStart+0x258>
24005664:	68fb      	ldr	r3, [r7, #12]
24005666:	681b      	ldr	r3, [r3, #0]
24005668:	4a1a      	ldr	r2, [pc, #104]	; (240056d4 <HAL_DMAEx_MultiBufferStart+0x2b4>)
2400566a:	4293      	cmp	r3, r2
2400566c:	d004      	beq.n	24005678 <HAL_DMAEx_MultiBufferStart+0x258>
2400566e:	68fb      	ldr	r3, [r7, #12]
24005670:	681b      	ldr	r3, [r3, #0]
24005672:	4a19      	ldr	r2, [pc, #100]	; (240056d8 <HAL_DMAEx_MultiBufferStart+0x2b8>)
24005674:	4293      	cmp	r3, r2
24005676:	d131      	bne.n	240056dc <HAL_DMAEx_MultiBufferStart+0x2bc>
24005678:	2301      	movs	r3, #1
2400567a:	e030      	b.n	240056de <HAL_DMAEx_MultiBufferStart+0x2be>
2400567c:	40020010 	.word	0x40020010
24005680:	40020028 	.word	0x40020028
24005684:	40020040 	.word	0x40020040
24005688:	40020058 	.word	0x40020058
2400568c:	40020070 	.word	0x40020070
24005690:	40020088 	.word	0x40020088
24005694:	400200a0 	.word	0x400200a0
24005698:	400200b8 	.word	0x400200b8
2400569c:	40020410 	.word	0x40020410
240056a0:	40020428 	.word	0x40020428
240056a4:	40020440 	.word	0x40020440
240056a8:	40020458 	.word	0x40020458
240056ac:	40020470 	.word	0x40020470
240056b0:	40020488 	.word	0x40020488
240056b4:	400204a0 	.word	0x400204a0
240056b8:	400204b8 	.word	0x400204b8
240056bc:	58025408 	.word	0x58025408
240056c0:	5802541c 	.word	0x5802541c
240056c4:	58025430 	.word	0x58025430
240056c8:	58025444 	.word	0x58025444
240056cc:	58025458 	.word	0x58025458
240056d0:	5802546c 	.word	0x5802546c
240056d4:	58025480 	.word	0x58025480
240056d8:	58025494 	.word	0x58025494
240056dc:	2300      	movs	r3, #0
240056de:	2b00      	cmp	r3, #0
240056e0:	d013      	beq.n	2400570a <HAL_DMAEx_MultiBufferStart+0x2ea>
      {
        /* Configure the source, destination address and the data length */
        DMA_MultiBufferSetConfig(hdma, SrcAddress, DstAddress, DataLength);
240056e2:	6a3b      	ldr	r3, [r7, #32]
240056e4:	687a      	ldr	r2, [r7, #4]
240056e6:	68b9      	ldr	r1, [r7, #8]
240056e8:	68f8      	ldr	r0, [r7, #12]
240056ea:	f000 fea5 	bl	24006438 <DMA_MultiBufferSetConfig>

        /* Clear the DMAMUX synchro overrun flag */
        hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
240056ee:	68fb      	ldr	r3, [r7, #12]
240056f0:	6e5b      	ldr	r3, [r3, #100]	; 0x64
240056f2:	68fa      	ldr	r2, [r7, #12]
240056f4:	6e92      	ldr	r2, [r2, #104]	; 0x68
240056f6:	605a      	str	r2, [r3, #4]

        if(hdma->DMAmuxRequestGen != 0U)
240056f8:	68fb      	ldr	r3, [r7, #12]
240056fa:	6edb      	ldr	r3, [r3, #108]	; 0x6c
240056fc:	2b00      	cmp	r3, #0
240056fe:	d004      	beq.n	2400570a <HAL_DMAEx_MultiBufferStart+0x2ea>
        {
          /* Clear the DMAMUX request generator overrun flag */
          hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
24005700:	68fb      	ldr	r3, [r7, #12]
24005702:	6f1b      	ldr	r3, [r3, #112]	; 0x70
24005704:	68fa      	ldr	r2, [r7, #12]
24005706:	6f52      	ldr	r2, [r2, #116]	; 0x74
24005708:	605a      	str	r2, [r3, #4]
        }
      }

      /* Enable the peripheral */
      __HAL_DMA_ENABLE(hdma);
2400570a:	68fb      	ldr	r3, [r7, #12]
2400570c:	681b      	ldr	r3, [r3, #0]
2400570e:	4a35      	ldr	r2, [pc, #212]	; (240057e4 <HAL_DMAEx_MultiBufferStart+0x3c4>)
24005710:	4293      	cmp	r3, r2
24005712:	d04a      	beq.n	240057aa <HAL_DMAEx_MultiBufferStart+0x38a>
24005714:	68fb      	ldr	r3, [r7, #12]
24005716:	681b      	ldr	r3, [r3, #0]
24005718:	4a33      	ldr	r2, [pc, #204]	; (240057e8 <HAL_DMAEx_MultiBufferStart+0x3c8>)
2400571a:	4293      	cmp	r3, r2
2400571c:	d045      	beq.n	240057aa <HAL_DMAEx_MultiBufferStart+0x38a>
2400571e:	68fb      	ldr	r3, [r7, #12]
24005720:	681b      	ldr	r3, [r3, #0]
24005722:	4a32      	ldr	r2, [pc, #200]	; (240057ec <HAL_DMAEx_MultiBufferStart+0x3cc>)
24005724:	4293      	cmp	r3, r2
24005726:	d040      	beq.n	240057aa <HAL_DMAEx_MultiBufferStart+0x38a>
24005728:	68fb      	ldr	r3, [r7, #12]
2400572a:	681b      	ldr	r3, [r3, #0]
2400572c:	4a30      	ldr	r2, [pc, #192]	; (240057f0 <HAL_DMAEx_MultiBufferStart+0x3d0>)
2400572e:	4293      	cmp	r3, r2
24005730:	d03b      	beq.n	240057aa <HAL_DMAEx_MultiBufferStart+0x38a>
24005732:	68fb      	ldr	r3, [r7, #12]
24005734:	681b      	ldr	r3, [r3, #0]
24005736:	4a2f      	ldr	r2, [pc, #188]	; (240057f4 <HAL_DMAEx_MultiBufferStart+0x3d4>)
24005738:	4293      	cmp	r3, r2
2400573a:	d036      	beq.n	240057aa <HAL_DMAEx_MultiBufferStart+0x38a>
2400573c:	68fb      	ldr	r3, [r7, #12]
2400573e:	681b      	ldr	r3, [r3, #0]
24005740:	4a2d      	ldr	r2, [pc, #180]	; (240057f8 <HAL_DMAEx_MultiBufferStart+0x3d8>)
24005742:	4293      	cmp	r3, r2
24005744:	d031      	beq.n	240057aa <HAL_DMAEx_MultiBufferStart+0x38a>
24005746:	68fb      	ldr	r3, [r7, #12]
24005748:	681b      	ldr	r3, [r3, #0]
2400574a:	4a2c      	ldr	r2, [pc, #176]	; (240057fc <HAL_DMAEx_MultiBufferStart+0x3dc>)
2400574c:	4293      	cmp	r3, r2
2400574e:	d02c      	beq.n	240057aa <HAL_DMAEx_MultiBufferStart+0x38a>
24005750:	68fb      	ldr	r3, [r7, #12]
24005752:	681b      	ldr	r3, [r3, #0]
24005754:	4a2a      	ldr	r2, [pc, #168]	; (24005800 <HAL_DMAEx_MultiBufferStart+0x3e0>)
24005756:	4293      	cmp	r3, r2
24005758:	d027      	beq.n	240057aa <HAL_DMAEx_MultiBufferStart+0x38a>
2400575a:	68fb      	ldr	r3, [r7, #12]
2400575c:	681b      	ldr	r3, [r3, #0]
2400575e:	4a29      	ldr	r2, [pc, #164]	; (24005804 <HAL_DMAEx_MultiBufferStart+0x3e4>)
24005760:	4293      	cmp	r3, r2
24005762:	d022      	beq.n	240057aa <HAL_DMAEx_MultiBufferStart+0x38a>
24005764:	68fb      	ldr	r3, [r7, #12]
24005766:	681b      	ldr	r3, [r3, #0]
24005768:	4a27      	ldr	r2, [pc, #156]	; (24005808 <HAL_DMAEx_MultiBufferStart+0x3e8>)
2400576a:	4293      	cmp	r3, r2
2400576c:	d01d      	beq.n	240057aa <HAL_DMAEx_MultiBufferStart+0x38a>
2400576e:	68fb      	ldr	r3, [r7, #12]
24005770:	681b      	ldr	r3, [r3, #0]
24005772:	4a26      	ldr	r2, [pc, #152]	; (2400580c <HAL_DMAEx_MultiBufferStart+0x3ec>)
24005774:	4293      	cmp	r3, r2
24005776:	d018      	beq.n	240057aa <HAL_DMAEx_MultiBufferStart+0x38a>
24005778:	68fb      	ldr	r3, [r7, #12]
2400577a:	681b      	ldr	r3, [r3, #0]
2400577c:	4a24      	ldr	r2, [pc, #144]	; (24005810 <HAL_DMAEx_MultiBufferStart+0x3f0>)
2400577e:	4293      	cmp	r3, r2
24005780:	d013      	beq.n	240057aa <HAL_DMAEx_MultiBufferStart+0x38a>
24005782:	68fb      	ldr	r3, [r7, #12]
24005784:	681b      	ldr	r3, [r3, #0]
24005786:	4a23      	ldr	r2, [pc, #140]	; (24005814 <HAL_DMAEx_MultiBufferStart+0x3f4>)
24005788:	4293      	cmp	r3, r2
2400578a:	d00e      	beq.n	240057aa <HAL_DMAEx_MultiBufferStart+0x38a>
2400578c:	68fb      	ldr	r3, [r7, #12]
2400578e:	681b      	ldr	r3, [r3, #0]
24005790:	4a21      	ldr	r2, [pc, #132]	; (24005818 <HAL_DMAEx_MultiBufferStart+0x3f8>)
24005792:	4293      	cmp	r3, r2
24005794:	d009      	beq.n	240057aa <HAL_DMAEx_MultiBufferStart+0x38a>
24005796:	68fb      	ldr	r3, [r7, #12]
24005798:	681b      	ldr	r3, [r3, #0]
2400579a:	4a20      	ldr	r2, [pc, #128]	; (2400581c <HAL_DMAEx_MultiBufferStart+0x3fc>)
2400579c:	4293      	cmp	r3, r2
2400579e:	d004      	beq.n	240057aa <HAL_DMAEx_MultiBufferStart+0x38a>
240057a0:	68fb      	ldr	r3, [r7, #12]
240057a2:	681b      	ldr	r3, [r3, #0]
240057a4:	4a1e      	ldr	r2, [pc, #120]	; (24005820 <HAL_DMAEx_MultiBufferStart+0x400>)
240057a6:	4293      	cmp	r3, r2
240057a8:	d108      	bne.n	240057bc <HAL_DMAEx_MultiBufferStart+0x39c>
240057aa:	68fb      	ldr	r3, [r7, #12]
240057ac:	681b      	ldr	r3, [r3, #0]
240057ae:	681a      	ldr	r2, [r3, #0]
240057b0:	68fb      	ldr	r3, [r7, #12]
240057b2:	681b      	ldr	r3, [r3, #0]
240057b4:	f042 0201 	orr.w	r2, r2, #1
240057b8:	601a      	str	r2, [r3, #0]
240057ba:	e00e      	b.n	240057da <HAL_DMAEx_MultiBufferStart+0x3ba>
240057bc:	68fb      	ldr	r3, [r7, #12]
240057be:	681b      	ldr	r3, [r3, #0]
240057c0:	681a      	ldr	r2, [r3, #0]
240057c2:	68fb      	ldr	r3, [r7, #12]
240057c4:	681b      	ldr	r3, [r3, #0]
240057c6:	f042 0201 	orr.w	r2, r2, #1
240057ca:	601a      	str	r2, [r3, #0]
240057cc:	e005      	b.n	240057da <HAL_DMAEx_MultiBufferStart+0x3ba>
    }
    else
    {
      /* Set the error code to busy */
      hdma->ErrorCode = HAL_DMA_ERROR_BUSY;
240057ce:	68fb      	ldr	r3, [r7, #12]
240057d0:	f44f 6200 	mov.w	r2, #2048	; 0x800
240057d4:	655a      	str	r2, [r3, #84]	; 0x54

      /* Return error status */
      status = HAL_ERROR;
240057d6:	2301      	movs	r3, #1
240057d8:	75fb      	strb	r3, [r7, #23]
    }
  }
  return status;
240057da:	7dfb      	ldrb	r3, [r7, #23]
}
240057dc:	4618      	mov	r0, r3
240057de:	3718      	adds	r7, #24
240057e0:	46bd      	mov	sp, r7
240057e2:	bd80      	pop	{r7, pc}
240057e4:	40020010 	.word	0x40020010
240057e8:	40020028 	.word	0x40020028
240057ec:	40020040 	.word	0x40020040
240057f0:	40020058 	.word	0x40020058
240057f4:	40020070 	.word	0x40020070
240057f8:	40020088 	.word	0x40020088
240057fc:	400200a0 	.word	0x400200a0
24005800:	400200b8 	.word	0x400200b8
24005804:	40020410 	.word	0x40020410
24005808:	40020428 	.word	0x40020428
2400580c:	40020440 	.word	0x40020440
24005810:	40020458 	.word	0x40020458
24005814:	40020470 	.word	0x40020470
24005818:	40020488 	.word	0x40020488
2400581c:	400204a0 	.word	0x400204a0
24005820:	400204b8 	.word	0x400204b8

24005824 <HAL_DMAEx_MultiBufferStart_IT>:
  * @param  SecondMemAddress: The second memory Buffer address in case of multi buffer Transfer
  * @param  DataLength: The length of data to be transferred from source to destination
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMAEx_MultiBufferStart_IT(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t SecondMemAddress, uint32_t DataLength)
{
24005824:	b580      	push	{r7, lr}
24005826:	b086      	sub	sp, #24
24005828:	af00      	add	r7, sp, #0
2400582a:	60f8      	str	r0, [r7, #12]
2400582c:	60b9      	str	r1, [r7, #8]
2400582e:	607a      	str	r2, [r7, #4]
24005830:	603b      	str	r3, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
24005832:	2300      	movs	r3, #0
24005834:	75fb      	strb	r3, [r7, #23]
  /* Check the parameters */
  assert_param(IS_DMA_BUFFER_SIZE(DataLength));
  assert_param(IS_DMA_ALL_INSTANCE(hdma->Instance));

  /* Memory-to-memory transfer not supported in double buffering mode */
  if(hdma->Init.Direction == DMA_MEMORY_TO_MEMORY)
24005836:	68fb      	ldr	r3, [r7, #12]
24005838:	689b      	ldr	r3, [r3, #8]
2400583a:	2b80      	cmp	r3, #128	; 0x80
2400583c:	d105      	bne.n	2400584a <HAL_DMAEx_MultiBufferStart_IT+0x26>
  {
    hdma->ErrorCode = HAL_DMA_ERROR_NOT_SUPPORTED;
2400583e:	68fb      	ldr	r3, [r7, #12]
24005840:	f44f 7280 	mov.w	r2, #256	; 0x100
24005844:	655a      	str	r2, [r3, #84]	; 0x54
    return HAL_ERROR;
24005846:	2301      	movs	r3, #1
24005848:	e325      	b.n	24005e96 <HAL_DMAEx_MultiBufferStart_IT+0x672>
  }

  /* Process locked */
  __HAL_LOCK(hdma);
2400584a:	68fb      	ldr	r3, [r7, #12]
2400584c:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
24005850:	2b01      	cmp	r3, #1
24005852:	d101      	bne.n	24005858 <HAL_DMAEx_MultiBufferStart_IT+0x34>
24005854:	2302      	movs	r3, #2
24005856:	e31e      	b.n	24005e96 <HAL_DMAEx_MultiBufferStart_IT+0x672>
24005858:	68fb      	ldr	r3, [r7, #12]
2400585a:	2201      	movs	r2, #1
2400585c:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

  if(HAL_DMA_STATE_READY == hdma->State)
24005860:	68fb      	ldr	r3, [r7, #12]
24005862:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
24005866:	b2db      	uxtb	r3, r3
24005868:	2b01      	cmp	r3, #1
2400586a:	f040 830d 	bne.w	24005e88 <HAL_DMAEx_MultiBufferStart_IT+0x664>
  {
    /* Change DMA peripheral state */
    hdma->State = HAL_DMA_STATE_BUSY;
2400586e:	68fb      	ldr	r3, [r7, #12]
24005870:	2202      	movs	r2, #2
24005872:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

    /* Initialize the error code */
    hdma->ErrorCode = HAL_DMA_ERROR_NONE;
24005876:	68fb      	ldr	r3, [r7, #12]
24005878:	2200      	movs	r2, #0
2400587a:	655a      	str	r2, [r3, #84]	; 0x54

    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
2400587c:	68fb      	ldr	r3, [r7, #12]
2400587e:	681b      	ldr	r3, [r3, #0]
24005880:	4a82      	ldr	r2, [pc, #520]	; (24005a8c <HAL_DMAEx_MultiBufferStart_IT+0x268>)
24005882:	4293      	cmp	r3, r2
24005884:	d04a      	beq.n	2400591c <HAL_DMAEx_MultiBufferStart_IT+0xf8>
24005886:	68fb      	ldr	r3, [r7, #12]
24005888:	681b      	ldr	r3, [r3, #0]
2400588a:	4a81      	ldr	r2, [pc, #516]	; (24005a90 <HAL_DMAEx_MultiBufferStart_IT+0x26c>)
2400588c:	4293      	cmp	r3, r2
2400588e:	d045      	beq.n	2400591c <HAL_DMAEx_MultiBufferStart_IT+0xf8>
24005890:	68fb      	ldr	r3, [r7, #12]
24005892:	681b      	ldr	r3, [r3, #0]
24005894:	4a7f      	ldr	r2, [pc, #508]	; (24005a94 <HAL_DMAEx_MultiBufferStart_IT+0x270>)
24005896:	4293      	cmp	r3, r2
24005898:	d040      	beq.n	2400591c <HAL_DMAEx_MultiBufferStart_IT+0xf8>
2400589a:	68fb      	ldr	r3, [r7, #12]
2400589c:	681b      	ldr	r3, [r3, #0]
2400589e:	4a7e      	ldr	r2, [pc, #504]	; (24005a98 <HAL_DMAEx_MultiBufferStart_IT+0x274>)
240058a0:	4293      	cmp	r3, r2
240058a2:	d03b      	beq.n	2400591c <HAL_DMAEx_MultiBufferStart_IT+0xf8>
240058a4:	68fb      	ldr	r3, [r7, #12]
240058a6:	681b      	ldr	r3, [r3, #0]
240058a8:	4a7c      	ldr	r2, [pc, #496]	; (24005a9c <HAL_DMAEx_MultiBufferStart_IT+0x278>)
240058aa:	4293      	cmp	r3, r2
240058ac:	d036      	beq.n	2400591c <HAL_DMAEx_MultiBufferStart_IT+0xf8>
240058ae:	68fb      	ldr	r3, [r7, #12]
240058b0:	681b      	ldr	r3, [r3, #0]
240058b2:	4a7b      	ldr	r2, [pc, #492]	; (24005aa0 <HAL_DMAEx_MultiBufferStart_IT+0x27c>)
240058b4:	4293      	cmp	r3, r2
240058b6:	d031      	beq.n	2400591c <HAL_DMAEx_MultiBufferStart_IT+0xf8>
240058b8:	68fb      	ldr	r3, [r7, #12]
240058ba:	681b      	ldr	r3, [r3, #0]
240058bc:	4a79      	ldr	r2, [pc, #484]	; (24005aa4 <HAL_DMAEx_MultiBufferStart_IT+0x280>)
240058be:	4293      	cmp	r3, r2
240058c0:	d02c      	beq.n	2400591c <HAL_DMAEx_MultiBufferStart_IT+0xf8>
240058c2:	68fb      	ldr	r3, [r7, #12]
240058c4:	681b      	ldr	r3, [r3, #0]
240058c6:	4a78      	ldr	r2, [pc, #480]	; (24005aa8 <HAL_DMAEx_MultiBufferStart_IT+0x284>)
240058c8:	4293      	cmp	r3, r2
240058ca:	d027      	beq.n	2400591c <HAL_DMAEx_MultiBufferStart_IT+0xf8>
240058cc:	68fb      	ldr	r3, [r7, #12]
240058ce:	681b      	ldr	r3, [r3, #0]
240058d0:	4a76      	ldr	r2, [pc, #472]	; (24005aac <HAL_DMAEx_MultiBufferStart_IT+0x288>)
240058d2:	4293      	cmp	r3, r2
240058d4:	d022      	beq.n	2400591c <HAL_DMAEx_MultiBufferStart_IT+0xf8>
240058d6:	68fb      	ldr	r3, [r7, #12]
240058d8:	681b      	ldr	r3, [r3, #0]
240058da:	4a75      	ldr	r2, [pc, #468]	; (24005ab0 <HAL_DMAEx_MultiBufferStart_IT+0x28c>)
240058dc:	4293      	cmp	r3, r2
240058de:	d01d      	beq.n	2400591c <HAL_DMAEx_MultiBufferStart_IT+0xf8>
240058e0:	68fb      	ldr	r3, [r7, #12]
240058e2:	681b      	ldr	r3, [r3, #0]
240058e4:	4a73      	ldr	r2, [pc, #460]	; (24005ab4 <HAL_DMAEx_MultiBufferStart_IT+0x290>)
240058e6:	4293      	cmp	r3, r2
240058e8:	d018      	beq.n	2400591c <HAL_DMAEx_MultiBufferStart_IT+0xf8>
240058ea:	68fb      	ldr	r3, [r7, #12]
240058ec:	681b      	ldr	r3, [r3, #0]
240058ee:	4a72      	ldr	r2, [pc, #456]	; (24005ab8 <HAL_DMAEx_MultiBufferStart_IT+0x294>)
240058f0:	4293      	cmp	r3, r2
240058f2:	d013      	beq.n	2400591c <HAL_DMAEx_MultiBufferStart_IT+0xf8>
240058f4:	68fb      	ldr	r3, [r7, #12]
240058f6:	681b      	ldr	r3, [r3, #0]
240058f8:	4a70      	ldr	r2, [pc, #448]	; (24005abc <HAL_DMAEx_MultiBufferStart_IT+0x298>)
240058fa:	4293      	cmp	r3, r2
240058fc:	d00e      	beq.n	2400591c <HAL_DMAEx_MultiBufferStart_IT+0xf8>
240058fe:	68fb      	ldr	r3, [r7, #12]
24005900:	681b      	ldr	r3, [r3, #0]
24005902:	4a6f      	ldr	r2, [pc, #444]	; (24005ac0 <HAL_DMAEx_MultiBufferStart_IT+0x29c>)
24005904:	4293      	cmp	r3, r2
24005906:	d009      	beq.n	2400591c <HAL_DMAEx_MultiBufferStart_IT+0xf8>
24005908:	68fb      	ldr	r3, [r7, #12]
2400590a:	681b      	ldr	r3, [r3, #0]
2400590c:	4a6d      	ldr	r2, [pc, #436]	; (24005ac4 <HAL_DMAEx_MultiBufferStart_IT+0x2a0>)
2400590e:	4293      	cmp	r3, r2
24005910:	d004      	beq.n	2400591c <HAL_DMAEx_MultiBufferStart_IT+0xf8>
24005912:	68fb      	ldr	r3, [r7, #12]
24005914:	681b      	ldr	r3, [r3, #0]
24005916:	4a6c      	ldr	r2, [pc, #432]	; (24005ac8 <HAL_DMAEx_MultiBufferStart_IT+0x2a4>)
24005918:	4293      	cmp	r3, r2
2400591a:	d101      	bne.n	24005920 <HAL_DMAEx_MultiBufferStart_IT+0xfc>
2400591c:	2301      	movs	r3, #1
2400591e:	e000      	b.n	24005922 <HAL_DMAEx_MultiBufferStart_IT+0xfe>
24005920:	2300      	movs	r3, #0
24005922:	2b00      	cmp	r3, #0
24005924:	d018      	beq.n	24005958 <HAL_DMAEx_MultiBufferStart_IT+0x134>
    {
      /* Enable the Double buffer mode */
      ((DMA_Stream_TypeDef   *)hdma->Instance)->CR |= DMA_SxCR_DBM;
24005926:	68fb      	ldr	r3, [r7, #12]
24005928:	681b      	ldr	r3, [r3, #0]
2400592a:	681a      	ldr	r2, [r3, #0]
2400592c:	68fb      	ldr	r3, [r7, #12]
2400592e:	681b      	ldr	r3, [r3, #0]
24005930:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
24005934:	601a      	str	r2, [r3, #0]

      /* Configure DMA Stream destination address */
      ((DMA_Stream_TypeDef   *)hdma->Instance)->M1AR = SecondMemAddress;
24005936:	68fb      	ldr	r3, [r7, #12]
24005938:	681b      	ldr	r3, [r3, #0]
2400593a:	683a      	ldr	r2, [r7, #0]
2400593c:	611a      	str	r2, [r3, #16]

      /* Calculate the interrupt clear flag register (IFCR) base address  */
      ifcRegister_Base = (uint32_t *)((uint32_t)(hdma->StreamBaseAddress + 8U));
2400593e:	68fb      	ldr	r3, [r7, #12]
24005940:	6d9b      	ldr	r3, [r3, #88]	; 0x58
24005942:	3308      	adds	r3, #8
24005944:	613b      	str	r3, [r7, #16]

      /* Clear all flags */
      *ifcRegister_Base = 0x3FUL << (hdma->StreamIndex & 0x1FU);
24005946:	68fb      	ldr	r3, [r7, #12]
24005948:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
2400594a:	f003 031f 	and.w	r3, r3, #31
2400594e:	223f      	movs	r2, #63	; 0x3f
24005950:	409a      	lsls	r2, r3
24005952:	693b      	ldr	r3, [r7, #16]
24005954:	601a      	str	r2, [r3, #0]
24005956:	e018      	b.n	2400598a <HAL_DMAEx_MultiBufferStart_IT+0x166>
    }
    else /* BDMA instance(s) */
    {
      /* Enable the Double buffer mode */
      ((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR |= (BDMA_CCR_DBM | BDMA_CCR_CIRC);
24005958:	68fb      	ldr	r3, [r7, #12]
2400595a:	681b      	ldr	r3, [r3, #0]
2400595c:	6819      	ldr	r1, [r3, #0]
2400595e:	68fb      	ldr	r3, [r7, #12]
24005960:	681a      	ldr	r2, [r3, #0]
24005962:	f248 0320 	movw	r3, #32800	; 0x8020
24005966:	430b      	orrs	r3, r1
24005968:	6013      	str	r3, [r2, #0]

      /* Configure DMA Stream destination address */
      ((BDMA_Channel_TypeDef   *)hdma->Instance)->CM1AR = SecondMemAddress;
2400596a:	68fb      	ldr	r3, [r7, #12]
2400596c:	681b      	ldr	r3, [r3, #0]
2400596e:	683a      	ldr	r2, [r7, #0]
24005970:	611a      	str	r2, [r3, #16]

      /* Calculate the interrupt clear flag register (IFCR) base address  */
      ifcRegister_Base = (uint32_t *)((uint32_t)(hdma->StreamBaseAddress + 4U));
24005972:	68fb      	ldr	r3, [r7, #12]
24005974:	6d9b      	ldr	r3, [r3, #88]	; 0x58
24005976:	3304      	adds	r3, #4
24005978:	613b      	str	r3, [r7, #16]

      /* Clear all flags */
      *ifcRegister_Base = (BDMA_ISR_GIF0) << (hdma->StreamIndex & 0x1FU);
2400597a:	68fb      	ldr	r3, [r7, #12]
2400597c:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
2400597e:	f003 031f 	and.w	r3, r3, #31
24005982:	2201      	movs	r2, #1
24005984:	409a      	lsls	r2, r3
24005986:	693b      	ldr	r3, [r7, #16]
24005988:	601a      	str	r2, [r3, #0]
    }

    /* Configure the source, destination address and the data length */
    DMA_MultiBufferSetConfig(hdma, SrcAddress, DstAddress, DataLength);
2400598a:	6a3b      	ldr	r3, [r7, #32]
2400598c:	687a      	ldr	r2, [r7, #4]
2400598e:	68b9      	ldr	r1, [r7, #8]
24005990:	68f8      	ldr	r0, [r7, #12]
24005992:	f000 fd51 	bl	24006438 <DMA_MultiBufferSetConfig>

    if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
24005996:	68fb      	ldr	r3, [r7, #12]
24005998:	681b      	ldr	r3, [r3, #0]
2400599a:	4a3c      	ldr	r2, [pc, #240]	; (24005a8c <HAL_DMAEx_MultiBufferStart_IT+0x268>)
2400599c:	4293      	cmp	r3, r2
2400599e:	d072      	beq.n	24005a86 <HAL_DMAEx_MultiBufferStart_IT+0x262>
240059a0:	68fb      	ldr	r3, [r7, #12]
240059a2:	681b      	ldr	r3, [r3, #0]
240059a4:	4a3a      	ldr	r2, [pc, #232]	; (24005a90 <HAL_DMAEx_MultiBufferStart_IT+0x26c>)
240059a6:	4293      	cmp	r3, r2
240059a8:	d06d      	beq.n	24005a86 <HAL_DMAEx_MultiBufferStart_IT+0x262>
240059aa:	68fb      	ldr	r3, [r7, #12]
240059ac:	681b      	ldr	r3, [r3, #0]
240059ae:	4a39      	ldr	r2, [pc, #228]	; (24005a94 <HAL_DMAEx_MultiBufferStart_IT+0x270>)
240059b0:	4293      	cmp	r3, r2
240059b2:	d068      	beq.n	24005a86 <HAL_DMAEx_MultiBufferStart_IT+0x262>
240059b4:	68fb      	ldr	r3, [r7, #12]
240059b6:	681b      	ldr	r3, [r3, #0]
240059b8:	4a37      	ldr	r2, [pc, #220]	; (24005a98 <HAL_DMAEx_MultiBufferStart_IT+0x274>)
240059ba:	4293      	cmp	r3, r2
240059bc:	d063      	beq.n	24005a86 <HAL_DMAEx_MultiBufferStart_IT+0x262>
240059be:	68fb      	ldr	r3, [r7, #12]
240059c0:	681b      	ldr	r3, [r3, #0]
240059c2:	4a36      	ldr	r2, [pc, #216]	; (24005a9c <HAL_DMAEx_MultiBufferStart_IT+0x278>)
240059c4:	4293      	cmp	r3, r2
240059c6:	d05e      	beq.n	24005a86 <HAL_DMAEx_MultiBufferStart_IT+0x262>
240059c8:	68fb      	ldr	r3, [r7, #12]
240059ca:	681b      	ldr	r3, [r3, #0]
240059cc:	4a34      	ldr	r2, [pc, #208]	; (24005aa0 <HAL_DMAEx_MultiBufferStart_IT+0x27c>)
240059ce:	4293      	cmp	r3, r2
240059d0:	d059      	beq.n	24005a86 <HAL_DMAEx_MultiBufferStart_IT+0x262>
240059d2:	68fb      	ldr	r3, [r7, #12]
240059d4:	681b      	ldr	r3, [r3, #0]
240059d6:	4a33      	ldr	r2, [pc, #204]	; (24005aa4 <HAL_DMAEx_MultiBufferStart_IT+0x280>)
240059d8:	4293      	cmp	r3, r2
240059da:	d054      	beq.n	24005a86 <HAL_DMAEx_MultiBufferStart_IT+0x262>
240059dc:	68fb      	ldr	r3, [r7, #12]
240059de:	681b      	ldr	r3, [r3, #0]
240059e0:	4a31      	ldr	r2, [pc, #196]	; (24005aa8 <HAL_DMAEx_MultiBufferStart_IT+0x284>)
240059e2:	4293      	cmp	r3, r2
240059e4:	d04f      	beq.n	24005a86 <HAL_DMAEx_MultiBufferStart_IT+0x262>
240059e6:	68fb      	ldr	r3, [r7, #12]
240059e8:	681b      	ldr	r3, [r3, #0]
240059ea:	4a30      	ldr	r2, [pc, #192]	; (24005aac <HAL_DMAEx_MultiBufferStart_IT+0x288>)
240059ec:	4293      	cmp	r3, r2
240059ee:	d04a      	beq.n	24005a86 <HAL_DMAEx_MultiBufferStart_IT+0x262>
240059f0:	68fb      	ldr	r3, [r7, #12]
240059f2:	681b      	ldr	r3, [r3, #0]
240059f4:	4a2e      	ldr	r2, [pc, #184]	; (24005ab0 <HAL_DMAEx_MultiBufferStart_IT+0x28c>)
240059f6:	4293      	cmp	r3, r2
240059f8:	d045      	beq.n	24005a86 <HAL_DMAEx_MultiBufferStart_IT+0x262>
240059fa:	68fb      	ldr	r3, [r7, #12]
240059fc:	681b      	ldr	r3, [r3, #0]
240059fe:	4a2d      	ldr	r2, [pc, #180]	; (24005ab4 <HAL_DMAEx_MultiBufferStart_IT+0x290>)
24005a00:	4293      	cmp	r3, r2
24005a02:	d040      	beq.n	24005a86 <HAL_DMAEx_MultiBufferStart_IT+0x262>
24005a04:	68fb      	ldr	r3, [r7, #12]
24005a06:	681b      	ldr	r3, [r3, #0]
24005a08:	4a2b      	ldr	r2, [pc, #172]	; (24005ab8 <HAL_DMAEx_MultiBufferStart_IT+0x294>)
24005a0a:	4293      	cmp	r3, r2
24005a0c:	d03b      	beq.n	24005a86 <HAL_DMAEx_MultiBufferStart_IT+0x262>
24005a0e:	68fb      	ldr	r3, [r7, #12]
24005a10:	681b      	ldr	r3, [r3, #0]
24005a12:	4a2a      	ldr	r2, [pc, #168]	; (24005abc <HAL_DMAEx_MultiBufferStart_IT+0x298>)
24005a14:	4293      	cmp	r3, r2
24005a16:	d036      	beq.n	24005a86 <HAL_DMAEx_MultiBufferStart_IT+0x262>
24005a18:	68fb      	ldr	r3, [r7, #12]
24005a1a:	681b      	ldr	r3, [r3, #0]
24005a1c:	4a28      	ldr	r2, [pc, #160]	; (24005ac0 <HAL_DMAEx_MultiBufferStart_IT+0x29c>)
24005a1e:	4293      	cmp	r3, r2
24005a20:	d031      	beq.n	24005a86 <HAL_DMAEx_MultiBufferStart_IT+0x262>
24005a22:	68fb      	ldr	r3, [r7, #12]
24005a24:	681b      	ldr	r3, [r3, #0]
24005a26:	4a27      	ldr	r2, [pc, #156]	; (24005ac4 <HAL_DMAEx_MultiBufferStart_IT+0x2a0>)
24005a28:	4293      	cmp	r3, r2
24005a2a:	d02c      	beq.n	24005a86 <HAL_DMAEx_MultiBufferStart_IT+0x262>
24005a2c:	68fb      	ldr	r3, [r7, #12]
24005a2e:	681b      	ldr	r3, [r3, #0]
24005a30:	4a25      	ldr	r2, [pc, #148]	; (24005ac8 <HAL_DMAEx_MultiBufferStart_IT+0x2a4>)
24005a32:	4293      	cmp	r3, r2
24005a34:	d027      	beq.n	24005a86 <HAL_DMAEx_MultiBufferStart_IT+0x262>
24005a36:	68fb      	ldr	r3, [r7, #12]
24005a38:	681b      	ldr	r3, [r3, #0]
24005a3a:	4a24      	ldr	r2, [pc, #144]	; (24005acc <HAL_DMAEx_MultiBufferStart_IT+0x2a8>)
24005a3c:	4293      	cmp	r3, r2
24005a3e:	d022      	beq.n	24005a86 <HAL_DMAEx_MultiBufferStart_IT+0x262>
24005a40:	68fb      	ldr	r3, [r7, #12]
24005a42:	681b      	ldr	r3, [r3, #0]
24005a44:	4a22      	ldr	r2, [pc, #136]	; (24005ad0 <HAL_DMAEx_MultiBufferStart_IT+0x2ac>)
24005a46:	4293      	cmp	r3, r2
24005a48:	d01d      	beq.n	24005a86 <HAL_DMAEx_MultiBufferStart_IT+0x262>
24005a4a:	68fb      	ldr	r3, [r7, #12]
24005a4c:	681b      	ldr	r3, [r3, #0]
24005a4e:	4a21      	ldr	r2, [pc, #132]	; (24005ad4 <HAL_DMAEx_MultiBufferStart_IT+0x2b0>)
24005a50:	4293      	cmp	r3, r2
24005a52:	d018      	beq.n	24005a86 <HAL_DMAEx_MultiBufferStart_IT+0x262>
24005a54:	68fb      	ldr	r3, [r7, #12]
24005a56:	681b      	ldr	r3, [r3, #0]
24005a58:	4a1f      	ldr	r2, [pc, #124]	; (24005ad8 <HAL_DMAEx_MultiBufferStart_IT+0x2b4>)
24005a5a:	4293      	cmp	r3, r2
24005a5c:	d013      	beq.n	24005a86 <HAL_DMAEx_MultiBufferStart_IT+0x262>
24005a5e:	68fb      	ldr	r3, [r7, #12]
24005a60:	681b      	ldr	r3, [r3, #0]
24005a62:	4a1e      	ldr	r2, [pc, #120]	; (24005adc <HAL_DMAEx_MultiBufferStart_IT+0x2b8>)
24005a64:	4293      	cmp	r3, r2
24005a66:	d00e      	beq.n	24005a86 <HAL_DMAEx_MultiBufferStart_IT+0x262>
24005a68:	68fb      	ldr	r3, [r7, #12]
24005a6a:	681b      	ldr	r3, [r3, #0]
24005a6c:	4a1c      	ldr	r2, [pc, #112]	; (24005ae0 <HAL_DMAEx_MultiBufferStart_IT+0x2bc>)
24005a6e:	4293      	cmp	r3, r2
24005a70:	d009      	beq.n	24005a86 <HAL_DMAEx_MultiBufferStart_IT+0x262>
24005a72:	68fb      	ldr	r3, [r7, #12]
24005a74:	681b      	ldr	r3, [r3, #0]
24005a76:	4a1b      	ldr	r2, [pc, #108]	; (24005ae4 <HAL_DMAEx_MultiBufferStart_IT+0x2c0>)
24005a78:	4293      	cmp	r3, r2
24005a7a:	d004      	beq.n	24005a86 <HAL_DMAEx_MultiBufferStart_IT+0x262>
24005a7c:	68fb      	ldr	r3, [r7, #12]
24005a7e:	681b      	ldr	r3, [r3, #0]
24005a80:	4a19      	ldr	r2, [pc, #100]	; (24005ae8 <HAL_DMAEx_MultiBufferStart_IT+0x2c4>)
24005a82:	4293      	cmp	r3, r2
24005a84:	d132      	bne.n	24005aec <HAL_DMAEx_MultiBufferStart_IT+0x2c8>
24005a86:	2301      	movs	r3, #1
24005a88:	e031      	b.n	24005aee <HAL_DMAEx_MultiBufferStart_IT+0x2ca>
24005a8a:	bf00      	nop
24005a8c:	40020010 	.word	0x40020010
24005a90:	40020028 	.word	0x40020028
24005a94:	40020040 	.word	0x40020040
24005a98:	40020058 	.word	0x40020058
24005a9c:	40020070 	.word	0x40020070
24005aa0:	40020088 	.word	0x40020088
24005aa4:	400200a0 	.word	0x400200a0
24005aa8:	400200b8 	.word	0x400200b8
24005aac:	40020410 	.word	0x40020410
24005ab0:	40020428 	.word	0x40020428
24005ab4:	40020440 	.word	0x40020440
24005ab8:	40020458 	.word	0x40020458
24005abc:	40020470 	.word	0x40020470
24005ac0:	40020488 	.word	0x40020488
24005ac4:	400204a0 	.word	0x400204a0
24005ac8:	400204b8 	.word	0x400204b8
24005acc:	58025408 	.word	0x58025408
24005ad0:	5802541c 	.word	0x5802541c
24005ad4:	58025430 	.word	0x58025430
24005ad8:	58025444 	.word	0x58025444
24005adc:	58025458 	.word	0x58025458
24005ae0:	5802546c 	.word	0x5802546c
24005ae4:	58025480 	.word	0x58025480
24005ae8:	58025494 	.word	0x58025494
24005aec:	2300      	movs	r3, #0
24005aee:	2b00      	cmp	r3, #0
24005af0:	d00d      	beq.n	24005b0e <HAL_DMAEx_MultiBufferStart_IT+0x2ea>
    {
      /* Clear the DMAMUX synchro overrun flag */
      hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
24005af2:	68fb      	ldr	r3, [r7, #12]
24005af4:	6e5b      	ldr	r3, [r3, #100]	; 0x64
24005af6:	68fa      	ldr	r2, [r7, #12]
24005af8:	6e92      	ldr	r2, [r2, #104]	; 0x68
24005afa:	605a      	str	r2, [r3, #4]

      if(hdma->DMAmuxRequestGen != 0U)
24005afc:	68fb      	ldr	r3, [r7, #12]
24005afe:	6edb      	ldr	r3, [r3, #108]	; 0x6c
24005b00:	2b00      	cmp	r3, #0
24005b02:	d004      	beq.n	24005b0e <HAL_DMAEx_MultiBufferStart_IT+0x2ea>
      {
        /* Clear the DMAMUX request generator overrun flag */
        hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
24005b04:	68fb      	ldr	r3, [r7, #12]
24005b06:	6f1b      	ldr	r3, [r3, #112]	; 0x70
24005b08:	68fa      	ldr	r2, [r7, #12]
24005b0a:	6f52      	ldr	r2, [r2, #116]	; 0x74
24005b0c:	605a      	str	r2, [r3, #4]
      }
    }

    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
24005b0e:	68fb      	ldr	r3, [r7, #12]
24005b10:	681b      	ldr	r3, [r3, #0]
24005b12:	4a85      	ldr	r2, [pc, #532]	; (24005d28 <HAL_DMAEx_MultiBufferStart_IT+0x504>)
24005b14:	4293      	cmp	r3, r2
24005b16:	d04a      	beq.n	24005bae <HAL_DMAEx_MultiBufferStart_IT+0x38a>
24005b18:	68fb      	ldr	r3, [r7, #12]
24005b1a:	681b      	ldr	r3, [r3, #0]
24005b1c:	4a83      	ldr	r2, [pc, #524]	; (24005d2c <HAL_DMAEx_MultiBufferStart_IT+0x508>)
24005b1e:	4293      	cmp	r3, r2
24005b20:	d045      	beq.n	24005bae <HAL_DMAEx_MultiBufferStart_IT+0x38a>
24005b22:	68fb      	ldr	r3, [r7, #12]
24005b24:	681b      	ldr	r3, [r3, #0]
24005b26:	4a82      	ldr	r2, [pc, #520]	; (24005d30 <HAL_DMAEx_MultiBufferStart_IT+0x50c>)
24005b28:	4293      	cmp	r3, r2
24005b2a:	d040      	beq.n	24005bae <HAL_DMAEx_MultiBufferStart_IT+0x38a>
24005b2c:	68fb      	ldr	r3, [r7, #12]
24005b2e:	681b      	ldr	r3, [r3, #0]
24005b30:	4a80      	ldr	r2, [pc, #512]	; (24005d34 <HAL_DMAEx_MultiBufferStart_IT+0x510>)
24005b32:	4293      	cmp	r3, r2
24005b34:	d03b      	beq.n	24005bae <HAL_DMAEx_MultiBufferStart_IT+0x38a>
24005b36:	68fb      	ldr	r3, [r7, #12]
24005b38:	681b      	ldr	r3, [r3, #0]
24005b3a:	4a7f      	ldr	r2, [pc, #508]	; (24005d38 <HAL_DMAEx_MultiBufferStart_IT+0x514>)
24005b3c:	4293      	cmp	r3, r2
24005b3e:	d036      	beq.n	24005bae <HAL_DMAEx_MultiBufferStart_IT+0x38a>
24005b40:	68fb      	ldr	r3, [r7, #12]
24005b42:	681b      	ldr	r3, [r3, #0]
24005b44:	4a7d      	ldr	r2, [pc, #500]	; (24005d3c <HAL_DMAEx_MultiBufferStart_IT+0x518>)
24005b46:	4293      	cmp	r3, r2
24005b48:	d031      	beq.n	24005bae <HAL_DMAEx_MultiBufferStart_IT+0x38a>
24005b4a:	68fb      	ldr	r3, [r7, #12]
24005b4c:	681b      	ldr	r3, [r3, #0]
24005b4e:	4a7c      	ldr	r2, [pc, #496]	; (24005d40 <HAL_DMAEx_MultiBufferStart_IT+0x51c>)
24005b50:	4293      	cmp	r3, r2
24005b52:	d02c      	beq.n	24005bae <HAL_DMAEx_MultiBufferStart_IT+0x38a>
24005b54:	68fb      	ldr	r3, [r7, #12]
24005b56:	681b      	ldr	r3, [r3, #0]
24005b58:	4a7a      	ldr	r2, [pc, #488]	; (24005d44 <HAL_DMAEx_MultiBufferStart_IT+0x520>)
24005b5a:	4293      	cmp	r3, r2
24005b5c:	d027      	beq.n	24005bae <HAL_DMAEx_MultiBufferStart_IT+0x38a>
24005b5e:	68fb      	ldr	r3, [r7, #12]
24005b60:	681b      	ldr	r3, [r3, #0]
24005b62:	4a79      	ldr	r2, [pc, #484]	; (24005d48 <HAL_DMAEx_MultiBufferStart_IT+0x524>)
24005b64:	4293      	cmp	r3, r2
24005b66:	d022      	beq.n	24005bae <HAL_DMAEx_MultiBufferStart_IT+0x38a>
24005b68:	68fb      	ldr	r3, [r7, #12]
24005b6a:	681b      	ldr	r3, [r3, #0]
24005b6c:	4a77      	ldr	r2, [pc, #476]	; (24005d4c <HAL_DMAEx_MultiBufferStart_IT+0x528>)
24005b6e:	4293      	cmp	r3, r2
24005b70:	d01d      	beq.n	24005bae <HAL_DMAEx_MultiBufferStart_IT+0x38a>
24005b72:	68fb      	ldr	r3, [r7, #12]
24005b74:	681b      	ldr	r3, [r3, #0]
24005b76:	4a76      	ldr	r2, [pc, #472]	; (24005d50 <HAL_DMAEx_MultiBufferStart_IT+0x52c>)
24005b78:	4293      	cmp	r3, r2
24005b7a:	d018      	beq.n	24005bae <HAL_DMAEx_MultiBufferStart_IT+0x38a>
24005b7c:	68fb      	ldr	r3, [r7, #12]
24005b7e:	681b      	ldr	r3, [r3, #0]
24005b80:	4a74      	ldr	r2, [pc, #464]	; (24005d54 <HAL_DMAEx_MultiBufferStart_IT+0x530>)
24005b82:	4293      	cmp	r3, r2
24005b84:	d013      	beq.n	24005bae <HAL_DMAEx_MultiBufferStart_IT+0x38a>
24005b86:	68fb      	ldr	r3, [r7, #12]
24005b88:	681b      	ldr	r3, [r3, #0]
24005b8a:	4a73      	ldr	r2, [pc, #460]	; (24005d58 <HAL_DMAEx_MultiBufferStart_IT+0x534>)
24005b8c:	4293      	cmp	r3, r2
24005b8e:	d00e      	beq.n	24005bae <HAL_DMAEx_MultiBufferStart_IT+0x38a>
24005b90:	68fb      	ldr	r3, [r7, #12]
24005b92:	681b      	ldr	r3, [r3, #0]
24005b94:	4a71      	ldr	r2, [pc, #452]	; (24005d5c <HAL_DMAEx_MultiBufferStart_IT+0x538>)
24005b96:	4293      	cmp	r3, r2
24005b98:	d009      	beq.n	24005bae <HAL_DMAEx_MultiBufferStart_IT+0x38a>
24005b9a:	68fb      	ldr	r3, [r7, #12]
24005b9c:	681b      	ldr	r3, [r3, #0]
24005b9e:	4a70      	ldr	r2, [pc, #448]	; (24005d60 <HAL_DMAEx_MultiBufferStart_IT+0x53c>)
24005ba0:	4293      	cmp	r3, r2
24005ba2:	d004      	beq.n	24005bae <HAL_DMAEx_MultiBufferStart_IT+0x38a>
24005ba4:	68fb      	ldr	r3, [r7, #12]
24005ba6:	681b      	ldr	r3, [r3, #0]
24005ba8:	4a6e      	ldr	r2, [pc, #440]	; (24005d64 <HAL_DMAEx_MultiBufferStart_IT+0x540>)
24005baa:	4293      	cmp	r3, r2
24005bac:	d101      	bne.n	24005bb2 <HAL_DMAEx_MultiBufferStart_IT+0x38e>
24005bae:	2301      	movs	r3, #1
24005bb0:	e000      	b.n	24005bb4 <HAL_DMAEx_MultiBufferStart_IT+0x390>
24005bb2:	2300      	movs	r3, #0
24005bb4:	2b00      	cmp	r3, #0
24005bb6:	d022      	beq.n	24005bfe <HAL_DMAEx_MultiBufferStart_IT+0x3da>
    {
      /* Enable Common interrupts*/
      MODIFY_REG(((DMA_Stream_TypeDef   *)hdma->Instance)->CR, (DMA_IT_TC | DMA_IT_TE | DMA_IT_DME | DMA_IT_HT), (DMA_IT_TC | DMA_IT_TE | DMA_IT_DME));
24005bb8:	68fb      	ldr	r3, [r7, #12]
24005bba:	681b      	ldr	r3, [r3, #0]
24005bbc:	681b      	ldr	r3, [r3, #0]
24005bbe:	f023 021e 	bic.w	r2, r3, #30
24005bc2:	68fb      	ldr	r3, [r7, #12]
24005bc4:	681b      	ldr	r3, [r3, #0]
24005bc6:	f042 0216 	orr.w	r2, r2, #22
24005bca:	601a      	str	r2, [r3, #0]
      ((DMA_Stream_TypeDef   *)hdma->Instance)->FCR |= DMA_IT_FE;
24005bcc:	68fb      	ldr	r3, [r7, #12]
24005bce:	681b      	ldr	r3, [r3, #0]
24005bd0:	695a      	ldr	r2, [r3, #20]
24005bd2:	68fb      	ldr	r3, [r7, #12]
24005bd4:	681b      	ldr	r3, [r3, #0]
24005bd6:	f042 0280 	orr.w	r2, r2, #128	; 0x80
24005bda:	615a      	str	r2, [r3, #20]

      if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
24005bdc:	68fb      	ldr	r3, [r7, #12]
24005bde:	6c1b      	ldr	r3, [r3, #64]	; 0x40
24005be0:	2b00      	cmp	r3, #0
24005be2:	d103      	bne.n	24005bec <HAL_DMAEx_MultiBufferStart_IT+0x3c8>
24005be4:	68fb      	ldr	r3, [r7, #12]
24005be6:	6c9b      	ldr	r3, [r3, #72]	; 0x48
24005be8:	2b00      	cmp	r3, #0
24005bea:	d022      	beq.n	24005c32 <HAL_DMAEx_MultiBufferStart_IT+0x40e>
      {
        /*Enable Half Transfer IT if corresponding Callback is set*/
        ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  |= DMA_IT_HT;
24005bec:	68fb      	ldr	r3, [r7, #12]
24005bee:	681b      	ldr	r3, [r3, #0]
24005bf0:	681a      	ldr	r2, [r3, #0]
24005bf2:	68fb      	ldr	r3, [r7, #12]
24005bf4:	681b      	ldr	r3, [r3, #0]
24005bf6:	f042 0208 	orr.w	r2, r2, #8
24005bfa:	601a      	str	r2, [r3, #0]
24005bfc:	e019      	b.n	24005c32 <HAL_DMAEx_MultiBufferStart_IT+0x40e>
      }
    }
    else /* BDMA instance(s) */
    {
      /* Enable Common interrupts*/
      MODIFY_REG(((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR, (BDMA_CCR_TCIE | BDMA_CCR_HTIE | BDMA_CCR_TEIE), (BDMA_CCR_TCIE | BDMA_CCR_TEIE));
24005bfe:	68fb      	ldr	r3, [r7, #12]
24005c00:	681b      	ldr	r3, [r3, #0]
24005c02:	681b      	ldr	r3, [r3, #0]
24005c04:	f023 020e 	bic.w	r2, r3, #14
24005c08:	68fb      	ldr	r3, [r7, #12]
24005c0a:	681b      	ldr	r3, [r3, #0]
24005c0c:	f042 020a 	orr.w	r2, r2, #10
24005c10:	601a      	str	r2, [r3, #0]

      if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
24005c12:	68fb      	ldr	r3, [r7, #12]
24005c14:	6c1b      	ldr	r3, [r3, #64]	; 0x40
24005c16:	2b00      	cmp	r3, #0
24005c18:	d103      	bne.n	24005c22 <HAL_DMAEx_MultiBufferStart_IT+0x3fe>
24005c1a:	68fb      	ldr	r3, [r7, #12]
24005c1c:	6c9b      	ldr	r3, [r3, #72]	; 0x48
24005c1e:	2b00      	cmp	r3, #0
24005c20:	d007      	beq.n	24005c32 <HAL_DMAEx_MultiBufferStart_IT+0x40e>
      {
        /*Enable Half Transfer IT if corresponding Callback is set*/
        ((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR  |= BDMA_CCR_HTIE;
24005c22:	68fb      	ldr	r3, [r7, #12]
24005c24:	681b      	ldr	r3, [r3, #0]
24005c26:	681a      	ldr	r2, [r3, #0]
24005c28:	68fb      	ldr	r3, [r7, #12]
24005c2a:	681b      	ldr	r3, [r3, #0]
24005c2c:	f042 0204 	orr.w	r2, r2, #4
24005c30:	601a      	str	r2, [r3, #0]
      }
    }

    if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
24005c32:	68fb      	ldr	r3, [r7, #12]
24005c34:	681b      	ldr	r3, [r3, #0]
24005c36:	4a3c      	ldr	r2, [pc, #240]	; (24005d28 <HAL_DMAEx_MultiBufferStart_IT+0x504>)
24005c38:	4293      	cmp	r3, r2
24005c3a:	d072      	beq.n	24005d22 <HAL_DMAEx_MultiBufferStart_IT+0x4fe>
24005c3c:	68fb      	ldr	r3, [r7, #12]
24005c3e:	681b      	ldr	r3, [r3, #0]
24005c40:	4a3a      	ldr	r2, [pc, #232]	; (24005d2c <HAL_DMAEx_MultiBufferStart_IT+0x508>)
24005c42:	4293      	cmp	r3, r2
24005c44:	d06d      	beq.n	24005d22 <HAL_DMAEx_MultiBufferStart_IT+0x4fe>
24005c46:	68fb      	ldr	r3, [r7, #12]
24005c48:	681b      	ldr	r3, [r3, #0]
24005c4a:	4a39      	ldr	r2, [pc, #228]	; (24005d30 <HAL_DMAEx_MultiBufferStart_IT+0x50c>)
24005c4c:	4293      	cmp	r3, r2
24005c4e:	d068      	beq.n	24005d22 <HAL_DMAEx_MultiBufferStart_IT+0x4fe>
24005c50:	68fb      	ldr	r3, [r7, #12]
24005c52:	681b      	ldr	r3, [r3, #0]
24005c54:	4a37      	ldr	r2, [pc, #220]	; (24005d34 <HAL_DMAEx_MultiBufferStart_IT+0x510>)
24005c56:	4293      	cmp	r3, r2
24005c58:	d063      	beq.n	24005d22 <HAL_DMAEx_MultiBufferStart_IT+0x4fe>
24005c5a:	68fb      	ldr	r3, [r7, #12]
24005c5c:	681b      	ldr	r3, [r3, #0]
24005c5e:	4a36      	ldr	r2, [pc, #216]	; (24005d38 <HAL_DMAEx_MultiBufferStart_IT+0x514>)
24005c60:	4293      	cmp	r3, r2
24005c62:	d05e      	beq.n	24005d22 <HAL_DMAEx_MultiBufferStart_IT+0x4fe>
24005c64:	68fb      	ldr	r3, [r7, #12]
24005c66:	681b      	ldr	r3, [r3, #0]
24005c68:	4a34      	ldr	r2, [pc, #208]	; (24005d3c <HAL_DMAEx_MultiBufferStart_IT+0x518>)
24005c6a:	4293      	cmp	r3, r2
24005c6c:	d059      	beq.n	24005d22 <HAL_DMAEx_MultiBufferStart_IT+0x4fe>
24005c6e:	68fb      	ldr	r3, [r7, #12]
24005c70:	681b      	ldr	r3, [r3, #0]
24005c72:	4a33      	ldr	r2, [pc, #204]	; (24005d40 <HAL_DMAEx_MultiBufferStart_IT+0x51c>)
24005c74:	4293      	cmp	r3, r2
24005c76:	d054      	beq.n	24005d22 <HAL_DMAEx_MultiBufferStart_IT+0x4fe>
24005c78:	68fb      	ldr	r3, [r7, #12]
24005c7a:	681b      	ldr	r3, [r3, #0]
24005c7c:	4a31      	ldr	r2, [pc, #196]	; (24005d44 <HAL_DMAEx_MultiBufferStart_IT+0x520>)
24005c7e:	4293      	cmp	r3, r2
24005c80:	d04f      	beq.n	24005d22 <HAL_DMAEx_MultiBufferStart_IT+0x4fe>
24005c82:	68fb      	ldr	r3, [r7, #12]
24005c84:	681b      	ldr	r3, [r3, #0]
24005c86:	4a30      	ldr	r2, [pc, #192]	; (24005d48 <HAL_DMAEx_MultiBufferStart_IT+0x524>)
24005c88:	4293      	cmp	r3, r2
24005c8a:	d04a      	beq.n	24005d22 <HAL_DMAEx_MultiBufferStart_IT+0x4fe>
24005c8c:	68fb      	ldr	r3, [r7, #12]
24005c8e:	681b      	ldr	r3, [r3, #0]
24005c90:	4a2e      	ldr	r2, [pc, #184]	; (24005d4c <HAL_DMAEx_MultiBufferStart_IT+0x528>)
24005c92:	4293      	cmp	r3, r2
24005c94:	d045      	beq.n	24005d22 <HAL_DMAEx_MultiBufferStart_IT+0x4fe>
24005c96:	68fb      	ldr	r3, [r7, #12]
24005c98:	681b      	ldr	r3, [r3, #0]
24005c9a:	4a2d      	ldr	r2, [pc, #180]	; (24005d50 <HAL_DMAEx_MultiBufferStart_IT+0x52c>)
24005c9c:	4293      	cmp	r3, r2
24005c9e:	d040      	beq.n	24005d22 <HAL_DMAEx_MultiBufferStart_IT+0x4fe>
24005ca0:	68fb      	ldr	r3, [r7, #12]
24005ca2:	681b      	ldr	r3, [r3, #0]
24005ca4:	4a2b      	ldr	r2, [pc, #172]	; (24005d54 <HAL_DMAEx_MultiBufferStart_IT+0x530>)
24005ca6:	4293      	cmp	r3, r2
24005ca8:	d03b      	beq.n	24005d22 <HAL_DMAEx_MultiBufferStart_IT+0x4fe>
24005caa:	68fb      	ldr	r3, [r7, #12]
24005cac:	681b      	ldr	r3, [r3, #0]
24005cae:	4a2a      	ldr	r2, [pc, #168]	; (24005d58 <HAL_DMAEx_MultiBufferStart_IT+0x534>)
24005cb0:	4293      	cmp	r3, r2
24005cb2:	d036      	beq.n	24005d22 <HAL_DMAEx_MultiBufferStart_IT+0x4fe>
24005cb4:	68fb      	ldr	r3, [r7, #12]
24005cb6:	681b      	ldr	r3, [r3, #0]
24005cb8:	4a28      	ldr	r2, [pc, #160]	; (24005d5c <HAL_DMAEx_MultiBufferStart_IT+0x538>)
24005cba:	4293      	cmp	r3, r2
24005cbc:	d031      	beq.n	24005d22 <HAL_DMAEx_MultiBufferStart_IT+0x4fe>
24005cbe:	68fb      	ldr	r3, [r7, #12]
24005cc0:	681b      	ldr	r3, [r3, #0]
24005cc2:	4a27      	ldr	r2, [pc, #156]	; (24005d60 <HAL_DMAEx_MultiBufferStart_IT+0x53c>)
24005cc4:	4293      	cmp	r3, r2
24005cc6:	d02c      	beq.n	24005d22 <HAL_DMAEx_MultiBufferStart_IT+0x4fe>
24005cc8:	68fb      	ldr	r3, [r7, #12]
24005cca:	681b      	ldr	r3, [r3, #0]
24005ccc:	4a25      	ldr	r2, [pc, #148]	; (24005d64 <HAL_DMAEx_MultiBufferStart_IT+0x540>)
24005cce:	4293      	cmp	r3, r2
24005cd0:	d027      	beq.n	24005d22 <HAL_DMAEx_MultiBufferStart_IT+0x4fe>
24005cd2:	68fb      	ldr	r3, [r7, #12]
24005cd4:	681b      	ldr	r3, [r3, #0]
24005cd6:	4a24      	ldr	r2, [pc, #144]	; (24005d68 <HAL_DMAEx_MultiBufferStart_IT+0x544>)
24005cd8:	4293      	cmp	r3, r2
24005cda:	d022      	beq.n	24005d22 <HAL_DMAEx_MultiBufferStart_IT+0x4fe>
24005cdc:	68fb      	ldr	r3, [r7, #12]
24005cde:	681b      	ldr	r3, [r3, #0]
24005ce0:	4a22      	ldr	r2, [pc, #136]	; (24005d6c <HAL_DMAEx_MultiBufferStart_IT+0x548>)
24005ce2:	4293      	cmp	r3, r2
24005ce4:	d01d      	beq.n	24005d22 <HAL_DMAEx_MultiBufferStart_IT+0x4fe>
24005ce6:	68fb      	ldr	r3, [r7, #12]
24005ce8:	681b      	ldr	r3, [r3, #0]
24005cea:	4a21      	ldr	r2, [pc, #132]	; (24005d70 <HAL_DMAEx_MultiBufferStart_IT+0x54c>)
24005cec:	4293      	cmp	r3, r2
24005cee:	d018      	beq.n	24005d22 <HAL_DMAEx_MultiBufferStart_IT+0x4fe>
24005cf0:	68fb      	ldr	r3, [r7, #12]
24005cf2:	681b      	ldr	r3, [r3, #0]
24005cf4:	4a1f      	ldr	r2, [pc, #124]	; (24005d74 <HAL_DMAEx_MultiBufferStart_IT+0x550>)
24005cf6:	4293      	cmp	r3, r2
24005cf8:	d013      	beq.n	24005d22 <HAL_DMAEx_MultiBufferStart_IT+0x4fe>
24005cfa:	68fb      	ldr	r3, [r7, #12]
24005cfc:	681b      	ldr	r3, [r3, #0]
24005cfe:	4a1e      	ldr	r2, [pc, #120]	; (24005d78 <HAL_DMAEx_MultiBufferStart_IT+0x554>)
24005d00:	4293      	cmp	r3, r2
24005d02:	d00e      	beq.n	24005d22 <HAL_DMAEx_MultiBufferStart_IT+0x4fe>
24005d04:	68fb      	ldr	r3, [r7, #12]
24005d06:	681b      	ldr	r3, [r3, #0]
24005d08:	4a1c      	ldr	r2, [pc, #112]	; (24005d7c <HAL_DMAEx_MultiBufferStart_IT+0x558>)
24005d0a:	4293      	cmp	r3, r2
24005d0c:	d009      	beq.n	24005d22 <HAL_DMAEx_MultiBufferStart_IT+0x4fe>
24005d0e:	68fb      	ldr	r3, [r7, #12]
24005d10:	681b      	ldr	r3, [r3, #0]
24005d12:	4a1b      	ldr	r2, [pc, #108]	; (24005d80 <HAL_DMAEx_MultiBufferStart_IT+0x55c>)
24005d14:	4293      	cmp	r3, r2
24005d16:	d004      	beq.n	24005d22 <HAL_DMAEx_MultiBufferStart_IT+0x4fe>
24005d18:	68fb      	ldr	r3, [r7, #12]
24005d1a:	681b      	ldr	r3, [r3, #0]
24005d1c:	4a19      	ldr	r2, [pc, #100]	; (24005d84 <HAL_DMAEx_MultiBufferStart_IT+0x560>)
24005d1e:	4293      	cmp	r3, r2
24005d20:	d132      	bne.n	24005d88 <HAL_DMAEx_MultiBufferStart_IT+0x564>
24005d22:	2301      	movs	r3, #1
24005d24:	e031      	b.n	24005d8a <HAL_DMAEx_MultiBufferStart_IT+0x566>
24005d26:	bf00      	nop
24005d28:	40020010 	.word	0x40020010
24005d2c:	40020028 	.word	0x40020028
24005d30:	40020040 	.word	0x40020040
24005d34:	40020058 	.word	0x40020058
24005d38:	40020070 	.word	0x40020070
24005d3c:	40020088 	.word	0x40020088
24005d40:	400200a0 	.word	0x400200a0
24005d44:	400200b8 	.word	0x400200b8
24005d48:	40020410 	.word	0x40020410
24005d4c:	40020428 	.word	0x40020428
24005d50:	40020440 	.word	0x40020440
24005d54:	40020458 	.word	0x40020458
24005d58:	40020470 	.word	0x40020470
24005d5c:	40020488 	.word	0x40020488
24005d60:	400204a0 	.word	0x400204a0
24005d64:	400204b8 	.word	0x400204b8
24005d68:	58025408 	.word	0x58025408
24005d6c:	5802541c 	.word	0x5802541c
24005d70:	58025430 	.word	0x58025430
24005d74:	58025444 	.word	0x58025444
24005d78:	58025458 	.word	0x58025458
24005d7c:	5802546c 	.word	0x5802546c
24005d80:	58025480 	.word	0x58025480
24005d84:	58025494 	.word	0x58025494
24005d88:	2300      	movs	r3, #0
24005d8a:	2b00      	cmp	r3, #0
24005d8c:	d01a      	beq.n	24005dc4 <HAL_DMAEx_MultiBufferStart_IT+0x5a0>
    {
      /* Check if DMAMUX Synchronization is enabled*/
      if((hdma->DMAmuxChannel->CCR & DMAMUX_CxCR_SE) != 0U)
24005d8e:	68fb      	ldr	r3, [r7, #12]
24005d90:	6e1b      	ldr	r3, [r3, #96]	; 0x60
24005d92:	681b      	ldr	r3, [r3, #0]
24005d94:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
24005d98:	2b00      	cmp	r3, #0
24005d9a:	d007      	beq.n	24005dac <HAL_DMAEx_MultiBufferStart_IT+0x588>
      {
        /* Enable DMAMUX sync overrun IT*/
        hdma->DMAmuxChannel->CCR |= DMAMUX_CxCR_SOIE;
24005d9c:	68fb      	ldr	r3, [r7, #12]
24005d9e:	6e1b      	ldr	r3, [r3, #96]	; 0x60
24005da0:	681a      	ldr	r2, [r3, #0]
24005da2:	68fb      	ldr	r3, [r7, #12]
24005da4:	6e1b      	ldr	r3, [r3, #96]	; 0x60
24005da6:	f442 7280 	orr.w	r2, r2, #256	; 0x100
24005daa:	601a      	str	r2, [r3, #0]
      }

      if(hdma->DMAmuxRequestGen != 0U)
24005dac:	68fb      	ldr	r3, [r7, #12]
24005dae:	6edb      	ldr	r3, [r3, #108]	; 0x6c
24005db0:	2b00      	cmp	r3, #0
24005db2:	d007      	beq.n	24005dc4 <HAL_DMAEx_MultiBufferStart_IT+0x5a0>
      {
        /* if using DMAMUX request generator, enable the DMAMUX request generator overrun IT*/
        /* enable the request gen overrun IT*/
        hdma->DMAmuxRequestGen->RGCR |= DMAMUX_RGxCR_OIE;
24005db4:	68fb      	ldr	r3, [r7, #12]
24005db6:	6edb      	ldr	r3, [r3, #108]	; 0x6c
24005db8:	681a      	ldr	r2, [r3, #0]
24005dba:	68fb      	ldr	r3, [r7, #12]
24005dbc:	6edb      	ldr	r3, [r3, #108]	; 0x6c
24005dbe:	f442 7280 	orr.w	r2, r2, #256	; 0x100
24005dc2:	601a      	str	r2, [r3, #0]
      }
    }

    /* Enable the peripheral */
    __HAL_DMA_ENABLE(hdma);
24005dc4:	68fb      	ldr	r3, [r7, #12]
24005dc6:	681b      	ldr	r3, [r3, #0]
24005dc8:	4a35      	ldr	r2, [pc, #212]	; (24005ea0 <HAL_DMAEx_MultiBufferStart_IT+0x67c>)
24005dca:	4293      	cmp	r3, r2
24005dcc:	d04a      	beq.n	24005e64 <HAL_DMAEx_MultiBufferStart_IT+0x640>
24005dce:	68fb      	ldr	r3, [r7, #12]
24005dd0:	681b      	ldr	r3, [r3, #0]
24005dd2:	4a34      	ldr	r2, [pc, #208]	; (24005ea4 <HAL_DMAEx_MultiBufferStart_IT+0x680>)
24005dd4:	4293      	cmp	r3, r2
24005dd6:	d045      	beq.n	24005e64 <HAL_DMAEx_MultiBufferStart_IT+0x640>
24005dd8:	68fb      	ldr	r3, [r7, #12]
24005dda:	681b      	ldr	r3, [r3, #0]
24005ddc:	4a32      	ldr	r2, [pc, #200]	; (24005ea8 <HAL_DMAEx_MultiBufferStart_IT+0x684>)
24005dde:	4293      	cmp	r3, r2
24005de0:	d040      	beq.n	24005e64 <HAL_DMAEx_MultiBufferStart_IT+0x640>
24005de2:	68fb      	ldr	r3, [r7, #12]
24005de4:	681b      	ldr	r3, [r3, #0]
24005de6:	4a31      	ldr	r2, [pc, #196]	; (24005eac <HAL_DMAEx_MultiBufferStart_IT+0x688>)
24005de8:	4293      	cmp	r3, r2
24005dea:	d03b      	beq.n	24005e64 <HAL_DMAEx_MultiBufferStart_IT+0x640>
24005dec:	68fb      	ldr	r3, [r7, #12]
24005dee:	681b      	ldr	r3, [r3, #0]
24005df0:	4a2f      	ldr	r2, [pc, #188]	; (24005eb0 <HAL_DMAEx_MultiBufferStart_IT+0x68c>)
24005df2:	4293      	cmp	r3, r2
24005df4:	d036      	beq.n	24005e64 <HAL_DMAEx_MultiBufferStart_IT+0x640>
24005df6:	68fb      	ldr	r3, [r7, #12]
24005df8:	681b      	ldr	r3, [r3, #0]
24005dfa:	4a2e      	ldr	r2, [pc, #184]	; (24005eb4 <HAL_DMAEx_MultiBufferStart_IT+0x690>)
24005dfc:	4293      	cmp	r3, r2
24005dfe:	d031      	beq.n	24005e64 <HAL_DMAEx_MultiBufferStart_IT+0x640>
24005e00:	68fb      	ldr	r3, [r7, #12]
24005e02:	681b      	ldr	r3, [r3, #0]
24005e04:	4a2c      	ldr	r2, [pc, #176]	; (24005eb8 <HAL_DMAEx_MultiBufferStart_IT+0x694>)
24005e06:	4293      	cmp	r3, r2
24005e08:	d02c      	beq.n	24005e64 <HAL_DMAEx_MultiBufferStart_IT+0x640>
24005e0a:	68fb      	ldr	r3, [r7, #12]
24005e0c:	681b      	ldr	r3, [r3, #0]
24005e0e:	4a2b      	ldr	r2, [pc, #172]	; (24005ebc <HAL_DMAEx_MultiBufferStart_IT+0x698>)
24005e10:	4293      	cmp	r3, r2
24005e12:	d027      	beq.n	24005e64 <HAL_DMAEx_MultiBufferStart_IT+0x640>
24005e14:	68fb      	ldr	r3, [r7, #12]
24005e16:	681b      	ldr	r3, [r3, #0]
24005e18:	4a29      	ldr	r2, [pc, #164]	; (24005ec0 <HAL_DMAEx_MultiBufferStart_IT+0x69c>)
24005e1a:	4293      	cmp	r3, r2
24005e1c:	d022      	beq.n	24005e64 <HAL_DMAEx_MultiBufferStart_IT+0x640>
24005e1e:	68fb      	ldr	r3, [r7, #12]
24005e20:	681b      	ldr	r3, [r3, #0]
24005e22:	4a28      	ldr	r2, [pc, #160]	; (24005ec4 <HAL_DMAEx_MultiBufferStart_IT+0x6a0>)
24005e24:	4293      	cmp	r3, r2
24005e26:	d01d      	beq.n	24005e64 <HAL_DMAEx_MultiBufferStart_IT+0x640>
24005e28:	68fb      	ldr	r3, [r7, #12]
24005e2a:	681b      	ldr	r3, [r3, #0]
24005e2c:	4a26      	ldr	r2, [pc, #152]	; (24005ec8 <HAL_DMAEx_MultiBufferStart_IT+0x6a4>)
24005e2e:	4293      	cmp	r3, r2
24005e30:	d018      	beq.n	24005e64 <HAL_DMAEx_MultiBufferStart_IT+0x640>
24005e32:	68fb      	ldr	r3, [r7, #12]
24005e34:	681b      	ldr	r3, [r3, #0]
24005e36:	4a25      	ldr	r2, [pc, #148]	; (24005ecc <HAL_DMAEx_MultiBufferStart_IT+0x6a8>)
24005e38:	4293      	cmp	r3, r2
24005e3a:	d013      	beq.n	24005e64 <HAL_DMAEx_MultiBufferStart_IT+0x640>
24005e3c:	68fb      	ldr	r3, [r7, #12]
24005e3e:	681b      	ldr	r3, [r3, #0]
24005e40:	4a23      	ldr	r2, [pc, #140]	; (24005ed0 <HAL_DMAEx_MultiBufferStart_IT+0x6ac>)
24005e42:	4293      	cmp	r3, r2
24005e44:	d00e      	beq.n	24005e64 <HAL_DMAEx_MultiBufferStart_IT+0x640>
24005e46:	68fb      	ldr	r3, [r7, #12]
24005e48:	681b      	ldr	r3, [r3, #0]
24005e4a:	4a22      	ldr	r2, [pc, #136]	; (24005ed4 <HAL_DMAEx_MultiBufferStart_IT+0x6b0>)
24005e4c:	4293      	cmp	r3, r2
24005e4e:	d009      	beq.n	24005e64 <HAL_DMAEx_MultiBufferStart_IT+0x640>
24005e50:	68fb      	ldr	r3, [r7, #12]
24005e52:	681b      	ldr	r3, [r3, #0]
24005e54:	4a20      	ldr	r2, [pc, #128]	; (24005ed8 <HAL_DMAEx_MultiBufferStart_IT+0x6b4>)
24005e56:	4293      	cmp	r3, r2
24005e58:	d004      	beq.n	24005e64 <HAL_DMAEx_MultiBufferStart_IT+0x640>
24005e5a:	68fb      	ldr	r3, [r7, #12]
24005e5c:	681b      	ldr	r3, [r3, #0]
24005e5e:	4a1f      	ldr	r2, [pc, #124]	; (24005edc <HAL_DMAEx_MultiBufferStart_IT+0x6b8>)
24005e60:	4293      	cmp	r3, r2
24005e62:	d108      	bne.n	24005e76 <HAL_DMAEx_MultiBufferStart_IT+0x652>
24005e64:	68fb      	ldr	r3, [r7, #12]
24005e66:	681b      	ldr	r3, [r3, #0]
24005e68:	681a      	ldr	r2, [r3, #0]
24005e6a:	68fb      	ldr	r3, [r7, #12]
24005e6c:	681b      	ldr	r3, [r3, #0]
24005e6e:	f042 0201 	orr.w	r2, r2, #1
24005e72:	601a      	str	r2, [r3, #0]
24005e74:	e00e      	b.n	24005e94 <HAL_DMAEx_MultiBufferStart_IT+0x670>
24005e76:	68fb      	ldr	r3, [r7, #12]
24005e78:	681b      	ldr	r3, [r3, #0]
24005e7a:	681a      	ldr	r2, [r3, #0]
24005e7c:	68fb      	ldr	r3, [r7, #12]
24005e7e:	681b      	ldr	r3, [r3, #0]
24005e80:	f042 0201 	orr.w	r2, r2, #1
24005e84:	601a      	str	r2, [r3, #0]
24005e86:	e005      	b.n	24005e94 <HAL_DMAEx_MultiBufferStart_IT+0x670>
  }
  else
  {
    /* Set the error code to busy */
    hdma->ErrorCode = HAL_DMA_ERROR_BUSY;
24005e88:	68fb      	ldr	r3, [r7, #12]
24005e8a:	f44f 6200 	mov.w	r2, #2048	; 0x800
24005e8e:	655a      	str	r2, [r3, #84]	; 0x54

    /* Return error status */
    status = HAL_ERROR;
24005e90:	2301      	movs	r3, #1
24005e92:	75fb      	strb	r3, [r7, #23]
  }
  return status;
24005e94:	7dfb      	ldrb	r3, [r7, #23]
}
24005e96:	4618      	mov	r0, r3
24005e98:	3718      	adds	r7, #24
24005e9a:	46bd      	mov	sp, r7
24005e9c:	bd80      	pop	{r7, pc}
24005e9e:	bf00      	nop
24005ea0:	40020010 	.word	0x40020010
24005ea4:	40020028 	.word	0x40020028
24005ea8:	40020040 	.word	0x40020040
24005eac:	40020058 	.word	0x40020058
24005eb0:	40020070 	.word	0x40020070
24005eb4:	40020088 	.word	0x40020088
24005eb8:	400200a0 	.word	0x400200a0
24005ebc:	400200b8 	.word	0x400200b8
24005ec0:	40020410 	.word	0x40020410
24005ec4:	40020428 	.word	0x40020428
24005ec8:	40020440 	.word	0x40020440
24005ecc:	40020458 	.word	0x40020458
24005ed0:	40020470 	.word	0x40020470
24005ed4:	40020488 	.word	0x40020488
24005ed8:	400204a0 	.word	0x400204a0
24005edc:	400204b8 	.word	0x400204b8

24005ee0 <HAL_DMAEx_ChangeMemory>:
  *         MEMORY1 and the MEMORY1 address can be changed only when the current
  *         transfer use MEMORY0.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMAEx_ChangeMemory(DMA_HandleTypeDef *hdma, uint32_t Address, HAL_DMA_MemoryTypeDef memory)
{
24005ee0:	b480      	push	{r7}
24005ee2:	b085      	sub	sp, #20
24005ee4:	af00      	add	r7, sp, #0
24005ee6:	60f8      	str	r0, [r7, #12]
24005ee8:	60b9      	str	r1, [r7, #8]
24005eea:	4613      	mov	r3, r2
24005eec:	71fb      	strb	r3, [r7, #7]
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
24005eee:	68fb      	ldr	r3, [r7, #12]
24005ef0:	681b      	ldr	r3, [r3, #0]
24005ef2:	4a39      	ldr	r2, [pc, #228]	; (24005fd8 <HAL_DMAEx_ChangeMemory+0xf8>)
24005ef4:	4293      	cmp	r3, r2
24005ef6:	d04a      	beq.n	24005f8e <HAL_DMAEx_ChangeMemory+0xae>
24005ef8:	68fb      	ldr	r3, [r7, #12]
24005efa:	681b      	ldr	r3, [r3, #0]
24005efc:	4a37      	ldr	r2, [pc, #220]	; (24005fdc <HAL_DMAEx_ChangeMemory+0xfc>)
24005efe:	4293      	cmp	r3, r2
24005f00:	d045      	beq.n	24005f8e <HAL_DMAEx_ChangeMemory+0xae>
24005f02:	68fb      	ldr	r3, [r7, #12]
24005f04:	681b      	ldr	r3, [r3, #0]
24005f06:	4a36      	ldr	r2, [pc, #216]	; (24005fe0 <HAL_DMAEx_ChangeMemory+0x100>)
24005f08:	4293      	cmp	r3, r2
24005f0a:	d040      	beq.n	24005f8e <HAL_DMAEx_ChangeMemory+0xae>
24005f0c:	68fb      	ldr	r3, [r7, #12]
24005f0e:	681b      	ldr	r3, [r3, #0]
24005f10:	4a34      	ldr	r2, [pc, #208]	; (24005fe4 <HAL_DMAEx_ChangeMemory+0x104>)
24005f12:	4293      	cmp	r3, r2
24005f14:	d03b      	beq.n	24005f8e <HAL_DMAEx_ChangeMemory+0xae>
24005f16:	68fb      	ldr	r3, [r7, #12]
24005f18:	681b      	ldr	r3, [r3, #0]
24005f1a:	4a33      	ldr	r2, [pc, #204]	; (24005fe8 <HAL_DMAEx_ChangeMemory+0x108>)
24005f1c:	4293      	cmp	r3, r2
24005f1e:	d036      	beq.n	24005f8e <HAL_DMAEx_ChangeMemory+0xae>
24005f20:	68fb      	ldr	r3, [r7, #12]
24005f22:	681b      	ldr	r3, [r3, #0]
24005f24:	4a31      	ldr	r2, [pc, #196]	; (24005fec <HAL_DMAEx_ChangeMemory+0x10c>)
24005f26:	4293      	cmp	r3, r2
24005f28:	d031      	beq.n	24005f8e <HAL_DMAEx_ChangeMemory+0xae>
24005f2a:	68fb      	ldr	r3, [r7, #12]
24005f2c:	681b      	ldr	r3, [r3, #0]
24005f2e:	4a30      	ldr	r2, [pc, #192]	; (24005ff0 <HAL_DMAEx_ChangeMemory+0x110>)
24005f30:	4293      	cmp	r3, r2
24005f32:	d02c      	beq.n	24005f8e <HAL_DMAEx_ChangeMemory+0xae>
24005f34:	68fb      	ldr	r3, [r7, #12]
24005f36:	681b      	ldr	r3, [r3, #0]
24005f38:	4a2e      	ldr	r2, [pc, #184]	; (24005ff4 <HAL_DMAEx_ChangeMemory+0x114>)
24005f3a:	4293      	cmp	r3, r2
24005f3c:	d027      	beq.n	24005f8e <HAL_DMAEx_ChangeMemory+0xae>
24005f3e:	68fb      	ldr	r3, [r7, #12]
24005f40:	681b      	ldr	r3, [r3, #0]
24005f42:	4a2d      	ldr	r2, [pc, #180]	; (24005ff8 <HAL_DMAEx_ChangeMemory+0x118>)
24005f44:	4293      	cmp	r3, r2
24005f46:	d022      	beq.n	24005f8e <HAL_DMAEx_ChangeMemory+0xae>
24005f48:	68fb      	ldr	r3, [r7, #12]
24005f4a:	681b      	ldr	r3, [r3, #0]
24005f4c:	4a2b      	ldr	r2, [pc, #172]	; (24005ffc <HAL_DMAEx_ChangeMemory+0x11c>)
24005f4e:	4293      	cmp	r3, r2
24005f50:	d01d      	beq.n	24005f8e <HAL_DMAEx_ChangeMemory+0xae>
24005f52:	68fb      	ldr	r3, [r7, #12]
24005f54:	681b      	ldr	r3, [r3, #0]
24005f56:	4a2a      	ldr	r2, [pc, #168]	; (24006000 <HAL_DMAEx_ChangeMemory+0x120>)
24005f58:	4293      	cmp	r3, r2
24005f5a:	d018      	beq.n	24005f8e <HAL_DMAEx_ChangeMemory+0xae>
24005f5c:	68fb      	ldr	r3, [r7, #12]
24005f5e:	681b      	ldr	r3, [r3, #0]
24005f60:	4a28      	ldr	r2, [pc, #160]	; (24006004 <HAL_DMAEx_ChangeMemory+0x124>)
24005f62:	4293      	cmp	r3, r2
24005f64:	d013      	beq.n	24005f8e <HAL_DMAEx_ChangeMemory+0xae>
24005f66:	68fb      	ldr	r3, [r7, #12]
24005f68:	681b      	ldr	r3, [r3, #0]
24005f6a:	4a27      	ldr	r2, [pc, #156]	; (24006008 <HAL_DMAEx_ChangeMemory+0x128>)
24005f6c:	4293      	cmp	r3, r2
24005f6e:	d00e      	beq.n	24005f8e <HAL_DMAEx_ChangeMemory+0xae>
24005f70:	68fb      	ldr	r3, [r7, #12]
24005f72:	681b      	ldr	r3, [r3, #0]
24005f74:	4a25      	ldr	r2, [pc, #148]	; (2400600c <HAL_DMAEx_ChangeMemory+0x12c>)
24005f76:	4293      	cmp	r3, r2
24005f78:	d009      	beq.n	24005f8e <HAL_DMAEx_ChangeMemory+0xae>
24005f7a:	68fb      	ldr	r3, [r7, #12]
24005f7c:	681b      	ldr	r3, [r3, #0]
24005f7e:	4a24      	ldr	r2, [pc, #144]	; (24006010 <HAL_DMAEx_ChangeMemory+0x130>)
24005f80:	4293      	cmp	r3, r2
24005f82:	d004      	beq.n	24005f8e <HAL_DMAEx_ChangeMemory+0xae>
24005f84:	68fb      	ldr	r3, [r7, #12]
24005f86:	681b      	ldr	r3, [r3, #0]
24005f88:	4a22      	ldr	r2, [pc, #136]	; (24006014 <HAL_DMAEx_ChangeMemory+0x134>)
24005f8a:	4293      	cmp	r3, r2
24005f8c:	d101      	bne.n	24005f92 <HAL_DMAEx_ChangeMemory+0xb2>
24005f8e:	2301      	movs	r3, #1
24005f90:	e000      	b.n	24005f94 <HAL_DMAEx_ChangeMemory+0xb4>
24005f92:	2300      	movs	r3, #0
24005f94:	2b00      	cmp	r3, #0
24005f96:	d00c      	beq.n	24005fb2 <HAL_DMAEx_ChangeMemory+0xd2>
  {
    if(memory == MEMORY0)
24005f98:	79fb      	ldrb	r3, [r7, #7]
24005f9a:	2b00      	cmp	r3, #0
24005f9c:	d104      	bne.n	24005fa8 <HAL_DMAEx_ChangeMemory+0xc8>
    {
      /* change the memory0 address */
      ((DMA_Stream_TypeDef   *)hdma->Instance)->M0AR = Address;
24005f9e:	68fb      	ldr	r3, [r7, #12]
24005fa0:	681b      	ldr	r3, [r3, #0]
24005fa2:	68ba      	ldr	r2, [r7, #8]
24005fa4:	60da      	str	r2, [r3, #12]
24005fa6:	e010      	b.n	24005fca <HAL_DMAEx_ChangeMemory+0xea>
    }
    else
    {
      /* change the memory1 address */
      ((DMA_Stream_TypeDef   *)hdma->Instance)->M1AR = Address;
24005fa8:	68fb      	ldr	r3, [r7, #12]
24005faa:	681b      	ldr	r3, [r3, #0]
24005fac:	68ba      	ldr	r2, [r7, #8]
24005fae:	611a      	str	r2, [r3, #16]
24005fb0:	e00b      	b.n	24005fca <HAL_DMAEx_ChangeMemory+0xea>
    }
  }
  else /* BDMA instance(s) */
  {
    if(memory == MEMORY0)
24005fb2:	79fb      	ldrb	r3, [r7, #7]
24005fb4:	2b00      	cmp	r3, #0
24005fb6:	d104      	bne.n	24005fc2 <HAL_DMAEx_ChangeMemory+0xe2>
    {
      /* change the memory0 address */
      ((BDMA_Channel_TypeDef   *)hdma->Instance)->CM0AR = Address;
24005fb8:	68fb      	ldr	r3, [r7, #12]
24005fba:	681b      	ldr	r3, [r3, #0]
24005fbc:	68ba      	ldr	r2, [r7, #8]
24005fbe:	60da      	str	r2, [r3, #12]
24005fc0:	e003      	b.n	24005fca <HAL_DMAEx_ChangeMemory+0xea>
    }
    else
    {
      /* change the memory1 address */
      ((BDMA_Channel_TypeDef   *)hdma->Instance)->CM1AR = Address;
24005fc2:	68fb      	ldr	r3, [r7, #12]
24005fc4:	681b      	ldr	r3, [r3, #0]
24005fc6:	68ba      	ldr	r2, [r7, #8]
24005fc8:	611a      	str	r2, [r3, #16]
    }
  }

  return HAL_OK;
24005fca:	2300      	movs	r3, #0
}
24005fcc:	4618      	mov	r0, r3
24005fce:	3714      	adds	r7, #20
24005fd0:	46bd      	mov	sp, r7
24005fd2:	f85d 7b04 	ldr.w	r7, [sp], #4
24005fd6:	4770      	bx	lr
24005fd8:	40020010 	.word	0x40020010
24005fdc:	40020028 	.word	0x40020028
24005fe0:	40020040 	.word	0x40020040
24005fe4:	40020058 	.word	0x40020058
24005fe8:	40020070 	.word	0x40020070
24005fec:	40020088 	.word	0x40020088
24005ff0:	400200a0 	.word	0x400200a0
24005ff4:	400200b8 	.word	0x400200b8
24005ff8:	40020410 	.word	0x40020410
24005ffc:	40020428 	.word	0x40020428
24006000:	40020440 	.word	0x40020440
24006004:	40020458 	.word	0x40020458
24006008:	40020470 	.word	0x40020470
2400600c:	40020488 	.word	0x40020488
24006010:	400204a0 	.word	0x400204a0
24006014:	400204b8 	.word	0x400204b8

24006018 <HAL_DMAEx_ConfigMuxSync>:
  *                     the configuration information for the specified DMA Stream.
  * @param  pSyncConfig : pointer to HAL_DMA_MuxSyncConfigTypeDef : contains the DMAMUX synchronization parameters
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMAEx_ConfigMuxSync(DMA_HandleTypeDef *hdma, HAL_DMA_MuxSyncConfigTypeDef *pSyncConfig)
{
24006018:	b480      	push	{r7}
2400601a:	b085      	sub	sp, #20
2400601c:	af00      	add	r7, sp, #0
2400601e:	6078      	str	r0, [r7, #4]
24006020:	6039      	str	r1, [r7, #0]
  uint32_t syncSignalID = 0;
24006022:	2300      	movs	r3, #0
24006024:	60fb      	str	r3, [r7, #12]
  uint32_t syncPolarity = 0;
24006026:	2300      	movs	r3, #0
24006028:	60bb      	str	r3, [r7, #8]
  assert_param(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance));
  assert_param(IS_DMAMUX_SYNC_STATE(pSyncConfig->SyncEnable));
  assert_param(IS_DMAMUX_SYNC_EVENT(pSyncConfig->EventEnable));
  assert_param(IS_DMAMUX_SYNC_REQUEST_NUMBER(pSyncConfig->RequestNumber));

  if(pSyncConfig->SyncEnable == ENABLE)
2400602a:	683b      	ldr	r3, [r7, #0]
2400602c:	7a1b      	ldrb	r3, [r3, #8]
2400602e:	2b01      	cmp	r3, #1
24006030:	d155      	bne.n	240060de <HAL_DMAEx_ConfigMuxSync+0xc6>
  {
    assert_param(IS_DMAMUX_SYNC_POLARITY(pSyncConfig->SyncPolarity));

    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
24006032:	687b      	ldr	r3, [r7, #4]
24006034:	681b      	ldr	r3, [r3, #0]
24006036:	4a4b      	ldr	r2, [pc, #300]	; (24006164 <HAL_DMAEx_ConfigMuxSync+0x14c>)
24006038:	4293      	cmp	r3, r2
2400603a:	d049      	beq.n	240060d0 <HAL_DMAEx_ConfigMuxSync+0xb8>
2400603c:	687b      	ldr	r3, [r7, #4]
2400603e:	681b      	ldr	r3, [r3, #0]
24006040:	4a49      	ldr	r2, [pc, #292]	; (24006168 <HAL_DMAEx_ConfigMuxSync+0x150>)
24006042:	4293      	cmp	r3, r2
24006044:	d044      	beq.n	240060d0 <HAL_DMAEx_ConfigMuxSync+0xb8>
24006046:	687b      	ldr	r3, [r7, #4]
24006048:	681b      	ldr	r3, [r3, #0]
2400604a:	4a48      	ldr	r2, [pc, #288]	; (2400616c <HAL_DMAEx_ConfigMuxSync+0x154>)
2400604c:	4293      	cmp	r3, r2
2400604e:	d03f      	beq.n	240060d0 <HAL_DMAEx_ConfigMuxSync+0xb8>
24006050:	687b      	ldr	r3, [r7, #4]
24006052:	681b      	ldr	r3, [r3, #0]
24006054:	4a46      	ldr	r2, [pc, #280]	; (24006170 <HAL_DMAEx_ConfigMuxSync+0x158>)
24006056:	4293      	cmp	r3, r2
24006058:	d03a      	beq.n	240060d0 <HAL_DMAEx_ConfigMuxSync+0xb8>
2400605a:	687b      	ldr	r3, [r7, #4]
2400605c:	681b      	ldr	r3, [r3, #0]
2400605e:	4a45      	ldr	r2, [pc, #276]	; (24006174 <HAL_DMAEx_ConfigMuxSync+0x15c>)
24006060:	4293      	cmp	r3, r2
24006062:	d035      	beq.n	240060d0 <HAL_DMAEx_ConfigMuxSync+0xb8>
24006064:	687b      	ldr	r3, [r7, #4]
24006066:	681b      	ldr	r3, [r3, #0]
24006068:	4a43      	ldr	r2, [pc, #268]	; (24006178 <HAL_DMAEx_ConfigMuxSync+0x160>)
2400606a:	4293      	cmp	r3, r2
2400606c:	d030      	beq.n	240060d0 <HAL_DMAEx_ConfigMuxSync+0xb8>
2400606e:	687b      	ldr	r3, [r7, #4]
24006070:	681b      	ldr	r3, [r3, #0]
24006072:	4a42      	ldr	r2, [pc, #264]	; (2400617c <HAL_DMAEx_ConfigMuxSync+0x164>)
24006074:	4293      	cmp	r3, r2
24006076:	d02b      	beq.n	240060d0 <HAL_DMAEx_ConfigMuxSync+0xb8>
24006078:	687b      	ldr	r3, [r7, #4]
2400607a:	681b      	ldr	r3, [r3, #0]
2400607c:	4a40      	ldr	r2, [pc, #256]	; (24006180 <HAL_DMAEx_ConfigMuxSync+0x168>)
2400607e:	4293      	cmp	r3, r2
24006080:	d026      	beq.n	240060d0 <HAL_DMAEx_ConfigMuxSync+0xb8>
24006082:	687b      	ldr	r3, [r7, #4]
24006084:	681b      	ldr	r3, [r3, #0]
24006086:	4a3f      	ldr	r2, [pc, #252]	; (24006184 <HAL_DMAEx_ConfigMuxSync+0x16c>)
24006088:	4293      	cmp	r3, r2
2400608a:	d021      	beq.n	240060d0 <HAL_DMAEx_ConfigMuxSync+0xb8>
2400608c:	687b      	ldr	r3, [r7, #4]
2400608e:	681b      	ldr	r3, [r3, #0]
24006090:	4a3d      	ldr	r2, [pc, #244]	; (24006188 <HAL_DMAEx_ConfigMuxSync+0x170>)
24006092:	4293      	cmp	r3, r2
24006094:	d01c      	beq.n	240060d0 <HAL_DMAEx_ConfigMuxSync+0xb8>
24006096:	687b      	ldr	r3, [r7, #4]
24006098:	681b      	ldr	r3, [r3, #0]
2400609a:	4a3c      	ldr	r2, [pc, #240]	; (2400618c <HAL_DMAEx_ConfigMuxSync+0x174>)
2400609c:	4293      	cmp	r3, r2
2400609e:	d017      	beq.n	240060d0 <HAL_DMAEx_ConfigMuxSync+0xb8>
240060a0:	687b      	ldr	r3, [r7, #4]
240060a2:	681b      	ldr	r3, [r3, #0]
240060a4:	4a3a      	ldr	r2, [pc, #232]	; (24006190 <HAL_DMAEx_ConfigMuxSync+0x178>)
240060a6:	4293      	cmp	r3, r2
240060a8:	d012      	beq.n	240060d0 <HAL_DMAEx_ConfigMuxSync+0xb8>
240060aa:	687b      	ldr	r3, [r7, #4]
240060ac:	681b      	ldr	r3, [r3, #0]
240060ae:	4a39      	ldr	r2, [pc, #228]	; (24006194 <HAL_DMAEx_ConfigMuxSync+0x17c>)
240060b0:	4293      	cmp	r3, r2
240060b2:	d00d      	beq.n	240060d0 <HAL_DMAEx_ConfigMuxSync+0xb8>
240060b4:	687b      	ldr	r3, [r7, #4]
240060b6:	681b      	ldr	r3, [r3, #0]
240060b8:	4a37      	ldr	r2, [pc, #220]	; (24006198 <HAL_DMAEx_ConfigMuxSync+0x180>)
240060ba:	4293      	cmp	r3, r2
240060bc:	d008      	beq.n	240060d0 <HAL_DMAEx_ConfigMuxSync+0xb8>
240060be:	687b      	ldr	r3, [r7, #4]
240060c0:	681b      	ldr	r3, [r3, #0]
240060c2:	4a36      	ldr	r2, [pc, #216]	; (2400619c <HAL_DMAEx_ConfigMuxSync+0x184>)
240060c4:	4293      	cmp	r3, r2
240060c6:	d003      	beq.n	240060d0 <HAL_DMAEx_ConfigMuxSync+0xb8>
240060c8:	687b      	ldr	r3, [r7, #4]
240060ca:	681b      	ldr	r3, [r3, #0]
240060cc:	4a34      	ldr	r2, [pc, #208]	; (240061a0 <HAL_DMAEx_ConfigMuxSync+0x188>)
240060ce:	4293      	cmp	r3, r2
240060d0:	bf00      	nop
    }
    else
    {
      assert_param(IS_BDMA_DMAMUX_SYNC_SIGNAL_ID(pSyncConfig->SyncSignalID));
    }
    syncSignalID = pSyncConfig->SyncSignalID;
240060d2:	683b      	ldr	r3, [r7, #0]
240060d4:	681b      	ldr	r3, [r3, #0]
240060d6:	60fb      	str	r3, [r7, #12]
    syncPolarity = pSyncConfig->SyncPolarity;
240060d8:	683b      	ldr	r3, [r7, #0]
240060da:	685b      	ldr	r3, [r3, #4]
240060dc:	60bb      	str	r3, [r7, #8]
  }

  /*Check if the DMA state is ready */
  if(hdma->State == HAL_DMA_STATE_READY)
240060de:	687b      	ldr	r3, [r7, #4]
240060e0:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
240060e4:	b2db      	uxtb	r3, r3
240060e6:	2b01      	cmp	r3, #1
240060e8:	d131      	bne.n	2400614e <HAL_DMAEx_ConfigMuxSync+0x136>
  {
    /* Process Locked */
    __HAL_LOCK(hdma);
240060ea:	687b      	ldr	r3, [r7, #4]
240060ec:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
240060f0:	2b01      	cmp	r3, #1
240060f2:	d101      	bne.n	240060f8 <HAL_DMAEx_ConfigMuxSync+0xe0>
240060f4:	2302      	movs	r3, #2
240060f6:	e02f      	b.n	24006158 <HAL_DMAEx_ConfigMuxSync+0x140>
240060f8:	687b      	ldr	r3, [r7, #4]
240060fa:	2201      	movs	r2, #1
240060fc:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

    /* Disable the synchronization and event generation before applying a new config */
    CLEAR_BIT(hdma->DMAmuxChannel->CCR,(DMAMUX_CxCR_SE | DMAMUX_CxCR_EGE));
24006100:	687b      	ldr	r3, [r7, #4]
24006102:	6e1b      	ldr	r3, [r3, #96]	; 0x60
24006104:	681a      	ldr	r2, [r3, #0]
24006106:	687b      	ldr	r3, [r7, #4]
24006108:	6e1b      	ldr	r3, [r3, #96]	; 0x60
2400610a:	f422 3281 	bic.w	r2, r2, #66048	; 0x10200
2400610e:	601a      	str	r2, [r3, #0]

    /* Set the new synchronization parameters (and keep the request ID filled during the Init)*/
    MODIFY_REG( hdma->DMAmuxChannel->CCR, \
24006110:	687b      	ldr	r3, [r7, #4]
24006112:	6e1b      	ldr	r3, [r3, #96]	; 0x60
24006114:	681b      	ldr	r3, [r3, #0]
24006116:	b2d9      	uxtb	r1, r3
24006118:	68fb      	ldr	r3, [r7, #12]
2400611a:	061a      	lsls	r2, r3, #24
2400611c:	683b      	ldr	r3, [r7, #0]
2400611e:	68db      	ldr	r3, [r3, #12]
24006120:	3b01      	subs	r3, #1
24006122:	04db      	lsls	r3, r3, #19
24006124:	431a      	orrs	r2, r3
24006126:	68bb      	ldr	r3, [r7, #8]
24006128:	431a      	orrs	r2, r3
2400612a:	683b      	ldr	r3, [r7, #0]
2400612c:	7a1b      	ldrb	r3, [r3, #8]
2400612e:	041b      	lsls	r3, r3, #16
24006130:	431a      	orrs	r2, r3
24006132:	683b      	ldr	r3, [r7, #0]
24006134:	7a5b      	ldrb	r3, [r3, #9]
24006136:	025b      	lsls	r3, r3, #9
24006138:	431a      	orrs	r2, r3
2400613a:	687b      	ldr	r3, [r7, #4]
2400613c:	6e1b      	ldr	r3, [r3, #96]	; 0x60
2400613e:	430a      	orrs	r2, r1
24006140:	601a      	str	r2, [r3, #0]
               ((pSyncConfig->RequestNumber - 1U) << DMAMUX_CxCR_NBREQ_Pos) | \
               syncPolarity | ((uint32_t)pSyncConfig->SyncEnable << DMAMUX_CxCR_SE_Pos)    | \
               ((uint32_t)pSyncConfig->EventEnable << DMAMUX_CxCR_EGE_Pos));

      /* Process Locked */
    __HAL_UNLOCK(hdma);
24006142:	687b      	ldr	r3, [r7, #4]
24006144:	2200      	movs	r2, #0
24006146:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

    return HAL_OK;
2400614a:	2300      	movs	r3, #0
2400614c:	e004      	b.n	24006158 <HAL_DMAEx_ConfigMuxSync+0x140>
  }
  else
  {
    /* Set the error code to busy */
    hdma->ErrorCode = HAL_DMA_ERROR_BUSY;
2400614e:	687b      	ldr	r3, [r7, #4]
24006150:	f44f 6200 	mov.w	r2, #2048	; 0x800
24006154:	655a      	str	r2, [r3, #84]	; 0x54

    /* Return error status */
    return HAL_ERROR;
24006156:	2301      	movs	r3, #1
  }
}
24006158:	4618      	mov	r0, r3
2400615a:	3714      	adds	r7, #20
2400615c:	46bd      	mov	sp, r7
2400615e:	f85d 7b04 	ldr.w	r7, [sp], #4
24006162:	4770      	bx	lr
24006164:	40020010 	.word	0x40020010
24006168:	40020028 	.word	0x40020028
2400616c:	40020040 	.word	0x40020040
24006170:	40020058 	.word	0x40020058
24006174:	40020070 	.word	0x40020070
24006178:	40020088 	.word	0x40020088
2400617c:	400200a0 	.word	0x400200a0
24006180:	400200b8 	.word	0x400200b8
24006184:	40020410 	.word	0x40020410
24006188:	40020428 	.word	0x40020428
2400618c:	40020440 	.word	0x40020440
24006190:	40020458 	.word	0x40020458
24006194:	40020470 	.word	0x40020470
24006198:	40020488 	.word	0x40020488
2400619c:	400204a0 	.word	0x400204a0
240061a0:	400204b8 	.word	0x400204b8

240061a4 <HAL_DMAEx_ConfigMuxRequestGenerator>:
  *         contains the request generator parameters.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMAEx_ConfigMuxRequestGenerator (DMA_HandleTypeDef *hdma, HAL_DMA_MuxRequestGeneratorConfigTypeDef *pRequestGeneratorConfig)
{
240061a4:	b480      	push	{r7}
240061a6:	b085      	sub	sp, #20
240061a8:	af00      	add	r7, sp, #0
240061aa:	6078      	str	r0, [r7, #4]
240061ac:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status;
  HAL_DMA_StateTypeDef temp_state = hdma->State;
240061ae:	687b      	ldr	r3, [r7, #4]
240061b0:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
240061b4:	73bb      	strb	r3, [r7, #14]

  /* Check the parameters */
  assert_param(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance));

  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
240061b6:	687b      	ldr	r3, [r7, #4]
240061b8:	681b      	ldr	r3, [r3, #0]
240061ba:	4a47      	ldr	r2, [pc, #284]	; (240062d8 <HAL_DMAEx_ConfigMuxRequestGenerator+0x134>)
240061bc:	4293      	cmp	r3, r2
240061be:	d049      	beq.n	24006254 <HAL_DMAEx_ConfigMuxRequestGenerator+0xb0>
240061c0:	687b      	ldr	r3, [r7, #4]
240061c2:	681b      	ldr	r3, [r3, #0]
240061c4:	4a45      	ldr	r2, [pc, #276]	; (240062dc <HAL_DMAEx_ConfigMuxRequestGenerator+0x138>)
240061c6:	4293      	cmp	r3, r2
240061c8:	d044      	beq.n	24006254 <HAL_DMAEx_ConfigMuxRequestGenerator+0xb0>
240061ca:	687b      	ldr	r3, [r7, #4]
240061cc:	681b      	ldr	r3, [r3, #0]
240061ce:	4a44      	ldr	r2, [pc, #272]	; (240062e0 <HAL_DMAEx_ConfigMuxRequestGenerator+0x13c>)
240061d0:	4293      	cmp	r3, r2
240061d2:	d03f      	beq.n	24006254 <HAL_DMAEx_ConfigMuxRequestGenerator+0xb0>
240061d4:	687b      	ldr	r3, [r7, #4]
240061d6:	681b      	ldr	r3, [r3, #0]
240061d8:	4a42      	ldr	r2, [pc, #264]	; (240062e4 <HAL_DMAEx_ConfigMuxRequestGenerator+0x140>)
240061da:	4293      	cmp	r3, r2
240061dc:	d03a      	beq.n	24006254 <HAL_DMAEx_ConfigMuxRequestGenerator+0xb0>
240061de:	687b      	ldr	r3, [r7, #4]
240061e0:	681b      	ldr	r3, [r3, #0]
240061e2:	4a41      	ldr	r2, [pc, #260]	; (240062e8 <HAL_DMAEx_ConfigMuxRequestGenerator+0x144>)
240061e4:	4293      	cmp	r3, r2
240061e6:	d035      	beq.n	24006254 <HAL_DMAEx_ConfigMuxRequestGenerator+0xb0>
240061e8:	687b      	ldr	r3, [r7, #4]
240061ea:	681b      	ldr	r3, [r3, #0]
240061ec:	4a3f      	ldr	r2, [pc, #252]	; (240062ec <HAL_DMAEx_ConfigMuxRequestGenerator+0x148>)
240061ee:	4293      	cmp	r3, r2
240061f0:	d030      	beq.n	24006254 <HAL_DMAEx_ConfigMuxRequestGenerator+0xb0>
240061f2:	687b      	ldr	r3, [r7, #4]
240061f4:	681b      	ldr	r3, [r3, #0]
240061f6:	4a3e      	ldr	r2, [pc, #248]	; (240062f0 <HAL_DMAEx_ConfigMuxRequestGenerator+0x14c>)
240061f8:	4293      	cmp	r3, r2
240061fa:	d02b      	beq.n	24006254 <HAL_DMAEx_ConfigMuxRequestGenerator+0xb0>
240061fc:	687b      	ldr	r3, [r7, #4]
240061fe:	681b      	ldr	r3, [r3, #0]
24006200:	4a3c      	ldr	r2, [pc, #240]	; (240062f4 <HAL_DMAEx_ConfigMuxRequestGenerator+0x150>)
24006202:	4293      	cmp	r3, r2
24006204:	d026      	beq.n	24006254 <HAL_DMAEx_ConfigMuxRequestGenerator+0xb0>
24006206:	687b      	ldr	r3, [r7, #4]
24006208:	681b      	ldr	r3, [r3, #0]
2400620a:	4a3b      	ldr	r2, [pc, #236]	; (240062f8 <HAL_DMAEx_ConfigMuxRequestGenerator+0x154>)
2400620c:	4293      	cmp	r3, r2
2400620e:	d021      	beq.n	24006254 <HAL_DMAEx_ConfigMuxRequestGenerator+0xb0>
24006210:	687b      	ldr	r3, [r7, #4]
24006212:	681b      	ldr	r3, [r3, #0]
24006214:	4a39      	ldr	r2, [pc, #228]	; (240062fc <HAL_DMAEx_ConfigMuxRequestGenerator+0x158>)
24006216:	4293      	cmp	r3, r2
24006218:	d01c      	beq.n	24006254 <HAL_DMAEx_ConfigMuxRequestGenerator+0xb0>
2400621a:	687b      	ldr	r3, [r7, #4]
2400621c:	681b      	ldr	r3, [r3, #0]
2400621e:	4a38      	ldr	r2, [pc, #224]	; (24006300 <HAL_DMAEx_ConfigMuxRequestGenerator+0x15c>)
24006220:	4293      	cmp	r3, r2
24006222:	d017      	beq.n	24006254 <HAL_DMAEx_ConfigMuxRequestGenerator+0xb0>
24006224:	687b      	ldr	r3, [r7, #4]
24006226:	681b      	ldr	r3, [r3, #0]
24006228:	4a36      	ldr	r2, [pc, #216]	; (24006304 <HAL_DMAEx_ConfigMuxRequestGenerator+0x160>)
2400622a:	4293      	cmp	r3, r2
2400622c:	d012      	beq.n	24006254 <HAL_DMAEx_ConfigMuxRequestGenerator+0xb0>
2400622e:	687b      	ldr	r3, [r7, #4]
24006230:	681b      	ldr	r3, [r3, #0]
24006232:	4a35      	ldr	r2, [pc, #212]	; (24006308 <HAL_DMAEx_ConfigMuxRequestGenerator+0x164>)
24006234:	4293      	cmp	r3, r2
24006236:	d00d      	beq.n	24006254 <HAL_DMAEx_ConfigMuxRequestGenerator+0xb0>
24006238:	687b      	ldr	r3, [r7, #4]
2400623a:	681b      	ldr	r3, [r3, #0]
2400623c:	4a33      	ldr	r2, [pc, #204]	; (2400630c <HAL_DMAEx_ConfigMuxRequestGenerator+0x168>)
2400623e:	4293      	cmp	r3, r2
24006240:	d008      	beq.n	24006254 <HAL_DMAEx_ConfigMuxRequestGenerator+0xb0>
24006242:	687b      	ldr	r3, [r7, #4]
24006244:	681b      	ldr	r3, [r3, #0]
24006246:	4a32      	ldr	r2, [pc, #200]	; (24006310 <HAL_DMAEx_ConfigMuxRequestGenerator+0x16c>)
24006248:	4293      	cmp	r3, r2
2400624a:	d003      	beq.n	24006254 <HAL_DMAEx_ConfigMuxRequestGenerator+0xb0>
2400624c:	687b      	ldr	r3, [r7, #4]
2400624e:	681b      	ldr	r3, [r3, #0]
24006250:	4a30      	ldr	r2, [pc, #192]	; (24006314 <HAL_DMAEx_ConfigMuxRequestGenerator+0x170>)
24006252:	4293      	cmp	r3, r2
24006254:	bf00      	nop
  assert_param(IS_DMAMUX_REQUEST_GEN_REQUEST_NUMBER(pRequestGeneratorConfig->RequestNumber));

  /* check if the DMA state is ready
     and DMA is using a DMAMUX request generator block
  */
  if(hdma->DMAmuxRequestGen == 0U)
24006256:	687b      	ldr	r3, [r7, #4]
24006258:	6edb      	ldr	r3, [r3, #108]	; 0x6c
2400625a:	2b00      	cmp	r3, #0
2400625c:	d105      	bne.n	2400626a <HAL_DMAEx_ConfigMuxRequestGenerator+0xc6>
  {
    /* Set the error code to busy */
    hdma->ErrorCode = HAL_DMA_ERROR_PARAM;
2400625e:	687b      	ldr	r3, [r7, #4]
24006260:	2240      	movs	r2, #64	; 0x40
24006262:	655a      	str	r2, [r3, #84]	; 0x54

    /* error status */
    status = HAL_ERROR;
24006264:	2301      	movs	r3, #1
24006266:	73fb      	strb	r3, [r7, #15]
24006268:	e02e      	b.n	240062c8 <HAL_DMAEx_ConfigMuxRequestGenerator+0x124>
  }
  else if(((hdma->DMAmuxRequestGen->RGCR & DMAMUX_RGxCR_GE) == 0U) && (temp_state == HAL_DMA_STATE_READY))
2400626a:	687b      	ldr	r3, [r7, #4]
2400626c:	6edb      	ldr	r3, [r3, #108]	; 0x6c
2400626e:	681b      	ldr	r3, [r3, #0]
24006270:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
24006274:	2b00      	cmp	r3, #0
24006276:	d121      	bne.n	240062bc <HAL_DMAEx_ConfigMuxRequestGenerator+0x118>
24006278:	7bbb      	ldrb	r3, [r7, #14]
2400627a:	2b01      	cmp	r3, #1
2400627c:	d11e      	bne.n	240062bc <HAL_DMAEx_ConfigMuxRequestGenerator+0x118>
  {
    /* RequestGenerator must be disable prior to the configuration i.e GE bit is 0 */

    /* Process Locked */
    __HAL_LOCK(hdma);
2400627e:	687b      	ldr	r3, [r7, #4]
24006280:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
24006284:	2b01      	cmp	r3, #1
24006286:	d101      	bne.n	2400628c <HAL_DMAEx_ConfigMuxRequestGenerator+0xe8>
24006288:	2302      	movs	r3, #2
2400628a:	e01e      	b.n	240062ca <HAL_DMAEx_ConfigMuxRequestGenerator+0x126>
2400628c:	687b      	ldr	r3, [r7, #4]
2400628e:	2201      	movs	r2, #1
24006290:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

    /* Set the request generator new parameters */
    hdma->DMAmuxRequestGen->RGCR = pRequestGeneratorConfig->SignalID | \
24006294:	683b      	ldr	r3, [r7, #0]
24006296:	681a      	ldr	r2, [r3, #0]
                                  ((pRequestGeneratorConfig->RequestNumber - 1U) << DMAMUX_RGxCR_GNBREQ_Pos)| \
24006298:	683b      	ldr	r3, [r7, #0]
2400629a:	689b      	ldr	r3, [r3, #8]
2400629c:	3b01      	subs	r3, #1
2400629e:	04db      	lsls	r3, r3, #19
    hdma->DMAmuxRequestGen->RGCR = pRequestGeneratorConfig->SignalID | \
240062a0:	ea42 0103 	orr.w	r1, r2, r3
                                  pRequestGeneratorConfig->Polarity;
240062a4:	683b      	ldr	r3, [r7, #0]
240062a6:	685a      	ldr	r2, [r3, #4]
    hdma->DMAmuxRequestGen->RGCR = pRequestGeneratorConfig->SignalID | \
240062a8:	687b      	ldr	r3, [r7, #4]
240062aa:	6edb      	ldr	r3, [r3, #108]	; 0x6c
                                  ((pRequestGeneratorConfig->RequestNumber - 1U) << DMAMUX_RGxCR_GNBREQ_Pos)| \
240062ac:	430a      	orrs	r2, r1
    hdma->DMAmuxRequestGen->RGCR = pRequestGeneratorConfig->SignalID | \
240062ae:	601a      	str	r2, [r3, #0]
    /* Process Locked */
    __HAL_UNLOCK(hdma);
240062b0:	687b      	ldr	r3, [r7, #4]
240062b2:	2200      	movs	r2, #0
240062b4:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

    return HAL_OK;
240062b8:	2300      	movs	r3, #0
240062ba:	e006      	b.n	240062ca <HAL_DMAEx_ConfigMuxRequestGenerator+0x126>
  }
  else
  {
    /* Set the error code to busy */
    hdma->ErrorCode = HAL_DMA_ERROR_BUSY;
240062bc:	687b      	ldr	r3, [r7, #4]
240062be:	f44f 6200 	mov.w	r2, #2048	; 0x800
240062c2:	655a      	str	r2, [r3, #84]	; 0x54

    /* error status */
    status = HAL_ERROR;
240062c4:	2301      	movs	r3, #1
240062c6:	73fb      	strb	r3, [r7, #15]
  }

  return status;
240062c8:	7bfb      	ldrb	r3, [r7, #15]
}
240062ca:	4618      	mov	r0, r3
240062cc:	3714      	adds	r7, #20
240062ce:	46bd      	mov	sp, r7
240062d0:	f85d 7b04 	ldr.w	r7, [sp], #4
240062d4:	4770      	bx	lr
240062d6:	bf00      	nop
240062d8:	40020010 	.word	0x40020010
240062dc:	40020028 	.word	0x40020028
240062e0:	40020040 	.word	0x40020040
240062e4:	40020058 	.word	0x40020058
240062e8:	40020070 	.word	0x40020070
240062ec:	40020088 	.word	0x40020088
240062f0:	400200a0 	.word	0x400200a0
240062f4:	400200b8 	.word	0x400200b8
240062f8:	40020410 	.word	0x40020410
240062fc:	40020428 	.word	0x40020428
24006300:	40020440 	.word	0x40020440
24006304:	40020458 	.word	0x40020458
24006308:	40020470 	.word	0x40020470
2400630c:	40020488 	.word	0x40020488
24006310:	400204a0 	.word	0x400204a0
24006314:	400204b8 	.word	0x400204b8

24006318 <HAL_DMAEx_EnableMuxRequestGenerator>:
  * @param  hdma:       pointer to a DMA_HandleTypeDef structure that contains
  *                     the configuration information for the specified DMA Stream.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMAEx_EnableMuxRequestGenerator (DMA_HandleTypeDef *hdma)
{
24006318:	b480      	push	{r7}
2400631a:	b083      	sub	sp, #12
2400631c:	af00      	add	r7, sp, #0
2400631e:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance));

  /* check if the DMA state is ready
     and DMA is using a DMAMUX request generator block */
  if((hdma->State != HAL_DMA_STATE_RESET) && (hdma->DMAmuxRequestGen != 0U))
24006320:	687b      	ldr	r3, [r7, #4]
24006322:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
24006326:	b2db      	uxtb	r3, r3
24006328:	2b00      	cmp	r3, #0
2400632a:	d00d      	beq.n	24006348 <HAL_DMAEx_EnableMuxRequestGenerator+0x30>
2400632c:	687b      	ldr	r3, [r7, #4]
2400632e:	6edb      	ldr	r3, [r3, #108]	; 0x6c
24006330:	2b00      	cmp	r3, #0
24006332:	d009      	beq.n	24006348 <HAL_DMAEx_EnableMuxRequestGenerator+0x30>
  {
    /* Enable the request generator*/
    hdma->DMAmuxRequestGen->RGCR |= DMAMUX_RGxCR_GE;
24006334:	687b      	ldr	r3, [r7, #4]
24006336:	6edb      	ldr	r3, [r3, #108]	; 0x6c
24006338:	681a      	ldr	r2, [r3, #0]
2400633a:	687b      	ldr	r3, [r7, #4]
2400633c:	6edb      	ldr	r3, [r3, #108]	; 0x6c
2400633e:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
24006342:	601a      	str	r2, [r3, #0]

   return HAL_OK;
24006344:	2300      	movs	r3, #0
24006346:	e000      	b.n	2400634a <HAL_DMAEx_EnableMuxRequestGenerator+0x32>
 }
 else
 {
   return HAL_ERROR;
24006348:	2301      	movs	r3, #1
 }
}
2400634a:	4618      	mov	r0, r3
2400634c:	370c      	adds	r7, #12
2400634e:	46bd      	mov	sp, r7
24006350:	f85d 7b04 	ldr.w	r7, [sp], #4
24006354:	4770      	bx	lr

24006356 <HAL_DMAEx_DisableMuxRequestGenerator>:
  * @param  hdma:       pointer to a DMA_HandleTypeDef structure that contains
  *                     the configuration information for the specified DMA Stream.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMAEx_DisableMuxRequestGenerator (DMA_HandleTypeDef *hdma)
{
24006356:	b480      	push	{r7}
24006358:	b083      	sub	sp, #12
2400635a:	af00      	add	r7, sp, #0
2400635c:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance));

  /* check if the DMA state is ready
     and DMA is using a DMAMUX request generator block */
  if((hdma->State != HAL_DMA_STATE_RESET) && (hdma->DMAmuxRequestGen != 0U))
2400635e:	687b      	ldr	r3, [r7, #4]
24006360:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
24006364:	b2db      	uxtb	r3, r3
24006366:	2b00      	cmp	r3, #0
24006368:	d00d      	beq.n	24006386 <HAL_DMAEx_DisableMuxRequestGenerator+0x30>
2400636a:	687b      	ldr	r3, [r7, #4]
2400636c:	6edb      	ldr	r3, [r3, #108]	; 0x6c
2400636e:	2b00      	cmp	r3, #0
24006370:	d009      	beq.n	24006386 <HAL_DMAEx_DisableMuxRequestGenerator+0x30>
  {
    /* Disable the request generator*/
    hdma->DMAmuxRequestGen->RGCR &= ~DMAMUX_RGxCR_GE;
24006372:	687b      	ldr	r3, [r7, #4]
24006374:	6edb      	ldr	r3, [r3, #108]	; 0x6c
24006376:	681a      	ldr	r2, [r3, #0]
24006378:	687b      	ldr	r3, [r7, #4]
2400637a:	6edb      	ldr	r3, [r3, #108]	; 0x6c
2400637c:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
24006380:	601a      	str	r2, [r3, #0]

   return HAL_OK;
24006382:	2300      	movs	r3, #0
24006384:	e000      	b.n	24006388 <HAL_DMAEx_DisableMuxRequestGenerator+0x32>
 }
 else
 {
   return HAL_ERROR;
24006386:	2301      	movs	r3, #1
 }
}
24006388:	4618      	mov	r0, r3
2400638a:	370c      	adds	r7, #12
2400638c:	46bd      	mov	sp, r7
2400638e:	f85d 7b04 	ldr.w	r7, [sp], #4
24006392:	4770      	bx	lr

24006394 <HAL_DMAEx_MUX_IRQHandler>:
  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Stream.
  * @retval None
  */
void HAL_DMAEx_MUX_IRQHandler(DMA_HandleTypeDef *hdma)
{
24006394:	b580      	push	{r7, lr}
24006396:	b082      	sub	sp, #8
24006398:	af00      	add	r7, sp, #0
2400639a:	6078      	str	r0, [r7, #4]
  /* Check for DMAMUX Synchronization overrun */
  if((hdma->DMAmuxChannelStatus->CSR & hdma->DMAmuxChannelStatusMask) != 0U)
2400639c:	687b      	ldr	r3, [r7, #4]
2400639e:	6e5b      	ldr	r3, [r3, #100]	; 0x64
240063a0:	681a      	ldr	r2, [r3, #0]
240063a2:	687b      	ldr	r3, [r7, #4]
240063a4:	6e9b      	ldr	r3, [r3, #104]	; 0x68
240063a6:	4013      	ands	r3, r2
240063a8:	2b00      	cmp	r3, #0
240063aa:	d01a      	beq.n	240063e2 <HAL_DMAEx_MUX_IRQHandler+0x4e>
  {
    /* Disable the synchro overrun interrupt */
    hdma->DMAmuxChannel->CCR &= ~DMAMUX_CxCR_SOIE;
240063ac:	687b      	ldr	r3, [r7, #4]
240063ae:	6e1b      	ldr	r3, [r3, #96]	; 0x60
240063b0:	681a      	ldr	r2, [r3, #0]
240063b2:	687b      	ldr	r3, [r7, #4]
240063b4:	6e1b      	ldr	r3, [r3, #96]	; 0x60
240063b6:	f422 7280 	bic.w	r2, r2, #256	; 0x100
240063ba:	601a      	str	r2, [r3, #0]

    /* Clear the DMAMUX synchro overrun flag */
    hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
240063bc:	687b      	ldr	r3, [r7, #4]
240063be:	6e5b      	ldr	r3, [r3, #100]	; 0x64
240063c0:	687a      	ldr	r2, [r7, #4]
240063c2:	6e92      	ldr	r2, [r2, #104]	; 0x68
240063c4:	605a      	str	r2, [r3, #4]

    /* Update error code */
    hdma->ErrorCode |= HAL_DMA_ERROR_SYNC;
240063c6:	687b      	ldr	r3, [r7, #4]
240063c8:	6d5b      	ldr	r3, [r3, #84]	; 0x54
240063ca:	f443 7200 	orr.w	r2, r3, #512	; 0x200
240063ce:	687b      	ldr	r3, [r7, #4]
240063d0:	655a      	str	r2, [r3, #84]	; 0x54

    if(hdma->XferErrorCallback != NULL)
240063d2:	687b      	ldr	r3, [r7, #4]
240063d4:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
240063d6:	2b00      	cmp	r3, #0
240063d8:	d003      	beq.n	240063e2 <HAL_DMAEx_MUX_IRQHandler+0x4e>
    {
      /* Transfer error callback */
      hdma->XferErrorCallback(hdma);
240063da:	687b      	ldr	r3, [r7, #4]
240063dc:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
240063de:	6878      	ldr	r0, [r7, #4]
240063e0:	4798      	blx	r3
    }
  }

  if(hdma->DMAmuxRequestGen != 0)
240063e2:	687b      	ldr	r3, [r7, #4]
240063e4:	6edb      	ldr	r3, [r3, #108]	; 0x6c
240063e6:	2b00      	cmp	r3, #0
240063e8:	d022      	beq.n	24006430 <HAL_DMAEx_MUX_IRQHandler+0x9c>
  {
   /* if using a DMAMUX request generator block Check for DMAMUX request generator overrun */
    if((hdma->DMAmuxRequestGenStatus->RGSR & hdma->DMAmuxRequestGenStatusMask) != 0U)
240063ea:	687b      	ldr	r3, [r7, #4]
240063ec:	6f1b      	ldr	r3, [r3, #112]	; 0x70
240063ee:	681a      	ldr	r2, [r3, #0]
240063f0:	687b      	ldr	r3, [r7, #4]
240063f2:	6f5b      	ldr	r3, [r3, #116]	; 0x74
240063f4:	4013      	ands	r3, r2
240063f6:	2b00      	cmp	r3, #0
240063f8:	d01a      	beq.n	24006430 <HAL_DMAEx_MUX_IRQHandler+0x9c>
    {
      /* Disable the request gen overrun interrupt */
      hdma->DMAmuxRequestGen->RGCR &= ~DMAMUX_RGxCR_OIE;
240063fa:	687b      	ldr	r3, [r7, #4]
240063fc:	6edb      	ldr	r3, [r3, #108]	; 0x6c
240063fe:	681a      	ldr	r2, [r3, #0]
24006400:	687b      	ldr	r3, [r7, #4]
24006402:	6edb      	ldr	r3, [r3, #108]	; 0x6c
24006404:	f422 7280 	bic.w	r2, r2, #256	; 0x100
24006408:	601a      	str	r2, [r3, #0]

      /* Clear the DMAMUX request generator overrun flag */
      hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
2400640a:	687b      	ldr	r3, [r7, #4]
2400640c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
2400640e:	687a      	ldr	r2, [r7, #4]
24006410:	6f52      	ldr	r2, [r2, #116]	; 0x74
24006412:	605a      	str	r2, [r3, #4]

      /* Update error code */
      hdma->ErrorCode |= HAL_DMA_ERROR_REQGEN;
24006414:	687b      	ldr	r3, [r7, #4]
24006416:	6d5b      	ldr	r3, [r3, #84]	; 0x54
24006418:	f443 6280 	orr.w	r2, r3, #1024	; 0x400
2400641c:	687b      	ldr	r3, [r7, #4]
2400641e:	655a      	str	r2, [r3, #84]	; 0x54

      if(hdma->XferErrorCallback != NULL)
24006420:	687b      	ldr	r3, [r7, #4]
24006422:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
24006424:	2b00      	cmp	r3, #0
24006426:	d003      	beq.n	24006430 <HAL_DMAEx_MUX_IRQHandler+0x9c>
      {
        /* Transfer error callback */
        hdma->XferErrorCallback(hdma);
24006428:	687b      	ldr	r3, [r7, #4]
2400642a:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
2400642c:	6878      	ldr	r0, [r7, #4]
2400642e:	4798      	blx	r3
      }
    }
  }
}
24006430:	bf00      	nop
24006432:	3708      	adds	r7, #8
24006434:	46bd      	mov	sp, r7
24006436:	bd80      	pop	{r7, pc}

24006438 <DMA_MultiBufferSetConfig>:
  * @param  DstAddress: The destination memory Buffer address
  * @param  DataLength: The length of data to be transferred from source to destination
  * @retval HAL status
  */
static void DMA_MultiBufferSetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{
24006438:	b480      	push	{r7}
2400643a:	b085      	sub	sp, #20
2400643c:	af00      	add	r7, sp, #0
2400643e:	60f8      	str	r0, [r7, #12]
24006440:	60b9      	str	r1, [r7, #8]
24006442:	607a      	str	r2, [r7, #4]
24006444:	603b      	str	r3, [r7, #0]
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
24006446:	68fb      	ldr	r3, [r7, #12]
24006448:	681b      	ldr	r3, [r3, #0]
2400644a:	4a46      	ldr	r2, [pc, #280]	; (24006564 <DMA_MultiBufferSetConfig+0x12c>)
2400644c:	4293      	cmp	r3, r2
2400644e:	d04a      	beq.n	240064e6 <DMA_MultiBufferSetConfig+0xae>
24006450:	68fb      	ldr	r3, [r7, #12]
24006452:	681b      	ldr	r3, [r3, #0]
24006454:	4a44      	ldr	r2, [pc, #272]	; (24006568 <DMA_MultiBufferSetConfig+0x130>)
24006456:	4293      	cmp	r3, r2
24006458:	d045      	beq.n	240064e6 <DMA_MultiBufferSetConfig+0xae>
2400645a:	68fb      	ldr	r3, [r7, #12]
2400645c:	681b      	ldr	r3, [r3, #0]
2400645e:	4a43      	ldr	r2, [pc, #268]	; (2400656c <DMA_MultiBufferSetConfig+0x134>)
24006460:	4293      	cmp	r3, r2
24006462:	d040      	beq.n	240064e6 <DMA_MultiBufferSetConfig+0xae>
24006464:	68fb      	ldr	r3, [r7, #12]
24006466:	681b      	ldr	r3, [r3, #0]
24006468:	4a41      	ldr	r2, [pc, #260]	; (24006570 <DMA_MultiBufferSetConfig+0x138>)
2400646a:	4293      	cmp	r3, r2
2400646c:	d03b      	beq.n	240064e6 <DMA_MultiBufferSetConfig+0xae>
2400646e:	68fb      	ldr	r3, [r7, #12]
24006470:	681b      	ldr	r3, [r3, #0]
24006472:	4a40      	ldr	r2, [pc, #256]	; (24006574 <DMA_MultiBufferSetConfig+0x13c>)
24006474:	4293      	cmp	r3, r2
24006476:	d036      	beq.n	240064e6 <DMA_MultiBufferSetConfig+0xae>
24006478:	68fb      	ldr	r3, [r7, #12]
2400647a:	681b      	ldr	r3, [r3, #0]
2400647c:	4a3e      	ldr	r2, [pc, #248]	; (24006578 <DMA_MultiBufferSetConfig+0x140>)
2400647e:	4293      	cmp	r3, r2
24006480:	d031      	beq.n	240064e6 <DMA_MultiBufferSetConfig+0xae>
24006482:	68fb      	ldr	r3, [r7, #12]
24006484:	681b      	ldr	r3, [r3, #0]
24006486:	4a3d      	ldr	r2, [pc, #244]	; (2400657c <DMA_MultiBufferSetConfig+0x144>)
24006488:	4293      	cmp	r3, r2
2400648a:	d02c      	beq.n	240064e6 <DMA_MultiBufferSetConfig+0xae>
2400648c:	68fb      	ldr	r3, [r7, #12]
2400648e:	681b      	ldr	r3, [r3, #0]
24006490:	4a3b      	ldr	r2, [pc, #236]	; (24006580 <DMA_MultiBufferSetConfig+0x148>)
24006492:	4293      	cmp	r3, r2
24006494:	d027      	beq.n	240064e6 <DMA_MultiBufferSetConfig+0xae>
24006496:	68fb      	ldr	r3, [r7, #12]
24006498:	681b      	ldr	r3, [r3, #0]
2400649a:	4a3a      	ldr	r2, [pc, #232]	; (24006584 <DMA_MultiBufferSetConfig+0x14c>)
2400649c:	4293      	cmp	r3, r2
2400649e:	d022      	beq.n	240064e6 <DMA_MultiBufferSetConfig+0xae>
240064a0:	68fb      	ldr	r3, [r7, #12]
240064a2:	681b      	ldr	r3, [r3, #0]
240064a4:	4a38      	ldr	r2, [pc, #224]	; (24006588 <DMA_MultiBufferSetConfig+0x150>)
240064a6:	4293      	cmp	r3, r2
240064a8:	d01d      	beq.n	240064e6 <DMA_MultiBufferSetConfig+0xae>
240064aa:	68fb      	ldr	r3, [r7, #12]
240064ac:	681b      	ldr	r3, [r3, #0]
240064ae:	4a37      	ldr	r2, [pc, #220]	; (2400658c <DMA_MultiBufferSetConfig+0x154>)
240064b0:	4293      	cmp	r3, r2
240064b2:	d018      	beq.n	240064e6 <DMA_MultiBufferSetConfig+0xae>
240064b4:	68fb      	ldr	r3, [r7, #12]
240064b6:	681b      	ldr	r3, [r3, #0]
240064b8:	4a35      	ldr	r2, [pc, #212]	; (24006590 <DMA_MultiBufferSetConfig+0x158>)
240064ba:	4293      	cmp	r3, r2
240064bc:	d013      	beq.n	240064e6 <DMA_MultiBufferSetConfig+0xae>
240064be:	68fb      	ldr	r3, [r7, #12]
240064c0:	681b      	ldr	r3, [r3, #0]
240064c2:	4a34      	ldr	r2, [pc, #208]	; (24006594 <DMA_MultiBufferSetConfig+0x15c>)
240064c4:	4293      	cmp	r3, r2
240064c6:	d00e      	beq.n	240064e6 <DMA_MultiBufferSetConfig+0xae>
240064c8:	68fb      	ldr	r3, [r7, #12]
240064ca:	681b      	ldr	r3, [r3, #0]
240064cc:	4a32      	ldr	r2, [pc, #200]	; (24006598 <DMA_MultiBufferSetConfig+0x160>)
240064ce:	4293      	cmp	r3, r2
240064d0:	d009      	beq.n	240064e6 <DMA_MultiBufferSetConfig+0xae>
240064d2:	68fb      	ldr	r3, [r7, #12]
240064d4:	681b      	ldr	r3, [r3, #0]
240064d6:	4a31      	ldr	r2, [pc, #196]	; (2400659c <DMA_MultiBufferSetConfig+0x164>)
240064d8:	4293      	cmp	r3, r2
240064da:	d004      	beq.n	240064e6 <DMA_MultiBufferSetConfig+0xae>
240064dc:	68fb      	ldr	r3, [r7, #12]
240064de:	681b      	ldr	r3, [r3, #0]
240064e0:	4a2f      	ldr	r2, [pc, #188]	; (240065a0 <DMA_MultiBufferSetConfig+0x168>)
240064e2:	4293      	cmp	r3, r2
240064e4:	d101      	bne.n	240064ea <DMA_MultiBufferSetConfig+0xb2>
240064e6:	2301      	movs	r3, #1
240064e8:	e000      	b.n	240064ec <DMA_MultiBufferSetConfig+0xb4>
240064ea:	2300      	movs	r3, #0
240064ec:	2b00      	cmp	r3, #0
240064ee:	d019      	beq.n	24006524 <DMA_MultiBufferSetConfig+0xec>
  {
    /* Configure DMA Stream data length */
    ((DMA_Stream_TypeDef   *)hdma->Instance)->NDTR = DataLength;
240064f0:	68fb      	ldr	r3, [r7, #12]
240064f2:	681b      	ldr	r3, [r3, #0]
240064f4:	683a      	ldr	r2, [r7, #0]
240064f6:	605a      	str	r2, [r3, #4]

    /* Peripheral to Memory */
    if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
240064f8:	68fb      	ldr	r3, [r7, #12]
240064fa:	689b      	ldr	r3, [r3, #8]
240064fc:	2b40      	cmp	r3, #64	; 0x40
240064fe:	d108      	bne.n	24006512 <DMA_MultiBufferSetConfig+0xda>
    {
      /* Configure DMA Stream destination address */
      ((DMA_Stream_TypeDef   *)hdma->Instance)->PAR = DstAddress;
24006500:	68fb      	ldr	r3, [r7, #12]
24006502:	681b      	ldr	r3, [r3, #0]
24006504:	687a      	ldr	r2, [r7, #4]
24006506:	609a      	str	r2, [r3, #8]

      /* Configure DMA Stream source address */
      ((DMA_Stream_TypeDef   *)hdma->Instance)->M0AR = SrcAddress;
24006508:	68fb      	ldr	r3, [r7, #12]
2400650a:	681b      	ldr	r3, [r3, #0]
2400650c:	68ba      	ldr	r2, [r7, #8]
2400650e:	60da      	str	r2, [r3, #12]

      /* Configure DMA Stream destination address */
      ((BDMA_Channel_TypeDef   *)hdma->Instance)->CM0AR = DstAddress;
    }
  }
}
24006510:	e021      	b.n	24006556 <DMA_MultiBufferSetConfig+0x11e>
      ((DMA_Stream_TypeDef   *)hdma->Instance)->PAR = SrcAddress;
24006512:	68fb      	ldr	r3, [r7, #12]
24006514:	681b      	ldr	r3, [r3, #0]
24006516:	68ba      	ldr	r2, [r7, #8]
24006518:	609a      	str	r2, [r3, #8]
      ((DMA_Stream_TypeDef   *)hdma->Instance)->M0AR = DstAddress;
2400651a:	68fb      	ldr	r3, [r7, #12]
2400651c:	681b      	ldr	r3, [r3, #0]
2400651e:	687a      	ldr	r2, [r7, #4]
24006520:	60da      	str	r2, [r3, #12]
}
24006522:	e018      	b.n	24006556 <DMA_MultiBufferSetConfig+0x11e>
    ((BDMA_Channel_TypeDef   *)hdma->Instance)->CNDTR = DataLength;
24006524:	68fb      	ldr	r3, [r7, #12]
24006526:	681b      	ldr	r3, [r3, #0]
24006528:	683a      	ldr	r2, [r7, #0]
2400652a:	605a      	str	r2, [r3, #4]
    if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
2400652c:	68fb      	ldr	r3, [r7, #12]
2400652e:	689b      	ldr	r3, [r3, #8]
24006530:	2b40      	cmp	r3, #64	; 0x40
24006532:	d108      	bne.n	24006546 <DMA_MultiBufferSetConfig+0x10e>
      ((BDMA_Channel_TypeDef   *)hdma->Instance)->CPAR = DstAddress;
24006534:	68fb      	ldr	r3, [r7, #12]
24006536:	681b      	ldr	r3, [r3, #0]
24006538:	687a      	ldr	r2, [r7, #4]
2400653a:	609a      	str	r2, [r3, #8]
      ((BDMA_Channel_TypeDef   *)hdma->Instance)->CM0AR = SrcAddress;
2400653c:	68fb      	ldr	r3, [r7, #12]
2400653e:	681b      	ldr	r3, [r3, #0]
24006540:	68ba      	ldr	r2, [r7, #8]
24006542:	60da      	str	r2, [r3, #12]
}
24006544:	e007      	b.n	24006556 <DMA_MultiBufferSetConfig+0x11e>
      ((BDMA_Channel_TypeDef   *)hdma->Instance)->CPAR = SrcAddress;
24006546:	68fb      	ldr	r3, [r7, #12]
24006548:	681b      	ldr	r3, [r3, #0]
2400654a:	68ba      	ldr	r2, [r7, #8]
2400654c:	609a      	str	r2, [r3, #8]
      ((BDMA_Channel_TypeDef   *)hdma->Instance)->CM0AR = DstAddress;
2400654e:	68fb      	ldr	r3, [r7, #12]
24006550:	681b      	ldr	r3, [r3, #0]
24006552:	687a      	ldr	r2, [r7, #4]
24006554:	60da      	str	r2, [r3, #12]
}
24006556:	bf00      	nop
24006558:	3714      	adds	r7, #20
2400655a:	46bd      	mov	sp, r7
2400655c:	f85d 7b04 	ldr.w	r7, [sp], #4
24006560:	4770      	bx	lr
24006562:	bf00      	nop
24006564:	40020010 	.word	0x40020010
24006568:	40020028 	.word	0x40020028
2400656c:	40020040 	.word	0x40020040
24006570:	40020058 	.word	0x40020058
24006574:	40020070 	.word	0x40020070
24006578:	40020088 	.word	0x40020088
2400657c:	400200a0 	.word	0x400200a0
24006580:	400200b8 	.word	0x400200b8
24006584:	40020410 	.word	0x40020410
24006588:	40020428 	.word	0x40020428
2400658c:	40020440 	.word	0x40020440
24006590:	40020458 	.word	0x40020458
24006594:	40020470 	.word	0x40020470
24006598:	40020488 	.word	0x40020488
2400659c:	400204a0 	.word	0x400204a0
240065a0:	400204b8 	.word	0x400204b8

240065a4 <HAL_EXTI_SetConfigLine>:
  * @param  hexti Exti handle.
  * @param  pExtiConfig Pointer on EXTI configuration to be set.
  * @retval HAL Status.
  */
HAL_StatusTypeDef HAL_EXTI_SetConfigLine(EXTI_HandleTypeDef *hexti, EXTI_ConfigTypeDef *pExtiConfig)
{
240065a4:	b480      	push	{r7}
240065a6:	b089      	sub	sp, #36	; 0x24
240065a8:	af00      	add	r7, sp, #0
240065aa:	6078      	str	r0, [r7, #4]
240065ac:	6039      	str	r1, [r7, #0]
  uint32_t maskline;
  uint32_t offset;
  uint32_t pcrlinepos;

  /* Check null pointer */
  if ((hexti == NULL) || (pExtiConfig == NULL))
240065ae:	687b      	ldr	r3, [r7, #4]
240065b0:	2b00      	cmp	r3, #0
240065b2:	d002      	beq.n	240065ba <HAL_EXTI_SetConfigLine+0x16>
240065b4:	683b      	ldr	r3, [r7, #0]
240065b6:	2b00      	cmp	r3, #0
240065b8:	d101      	bne.n	240065be <HAL_EXTI_SetConfigLine+0x1a>
  {
    return HAL_ERROR;
240065ba:	2301      	movs	r3, #1
240065bc:	e10b      	b.n	240067d6 <HAL_EXTI_SetConfigLine+0x232>
  /* Check the parameters */
  assert_param(IS_EXTI_LINE(pExtiConfig->Line));
  assert_param(IS_EXTI_MODE(pExtiConfig->Mode));

  /* Assign line number to handle */
  hexti->Line = pExtiConfig->Line;
240065be:	683b      	ldr	r3, [r7, #0]
240065c0:	681a      	ldr	r2, [r3, #0]
240065c2:	687b      	ldr	r3, [r7, #4]
240065c4:	601a      	str	r2, [r3, #0]

  /* compute line register offset and line mask */
  offset = ((pExtiConfig->Line & EXTI_REG_MASK) >> EXTI_REG_SHIFT);
240065c6:	683b      	ldr	r3, [r7, #0]
240065c8:	681b      	ldr	r3, [r3, #0]
240065ca:	0c1b      	lsrs	r3, r3, #16
240065cc:	f003 0303 	and.w	r3, r3, #3
240065d0:	613b      	str	r3, [r7, #16]
  linepos = (pExtiConfig->Line & EXTI_PIN_MASK);
240065d2:	683b      	ldr	r3, [r7, #0]
240065d4:	681b      	ldr	r3, [r3, #0]
240065d6:	f003 031f 	and.w	r3, r3, #31
240065da:	60fb      	str	r3, [r7, #12]
  maskline = (1UL << linepos);
240065dc:	2201      	movs	r2, #1
240065de:	68fb      	ldr	r3, [r7, #12]
240065e0:	fa02 f303 	lsl.w	r3, r2, r3
240065e4:	60bb      	str	r3, [r7, #8]

  /* Configure triggers for configurable lines */
  if ((pExtiConfig->Line & EXTI_CONFIG) != 0x00U)
240065e6:	683b      	ldr	r3, [r7, #0]
240065e8:	681b      	ldr	r3, [r3, #0]
240065ea:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
240065ee:	2b00      	cmp	r3, #0
240065f0:	d064      	beq.n	240066bc <HAL_EXTI_SetConfigLine+0x118>
  {
    assert_param(IS_EXTI_TRIGGER(pExtiConfig->Trigger));

    /* Configure rising trigger */
    regaddr = (__IO uint32_t *)(&EXTI->RTSR1 + (EXTI_CONFIG_OFFSET * offset));
240065f2:	693b      	ldr	r3, [r7, #16]
240065f4:	015b      	lsls	r3, r3, #5
240065f6:	f103 43b0 	add.w	r3, r3, #1476395008	; 0x58000000
240065fa:	61fb      	str	r3, [r7, #28]
    regval = *regaddr;
240065fc:	69fb      	ldr	r3, [r7, #28]
240065fe:	681b      	ldr	r3, [r3, #0]
24006600:	61bb      	str	r3, [r7, #24]

    /* Mask or set line */
    if ((pExtiConfig->Trigger & EXTI_TRIGGER_RISING) != 0x00U)
24006602:	683b      	ldr	r3, [r7, #0]
24006604:	689b      	ldr	r3, [r3, #8]
24006606:	f003 0301 	and.w	r3, r3, #1
2400660a:	2b00      	cmp	r3, #0
2400660c:	d004      	beq.n	24006618 <HAL_EXTI_SetConfigLine+0x74>
    {
      regval |= maskline;
2400660e:	69ba      	ldr	r2, [r7, #24]
24006610:	68bb      	ldr	r3, [r7, #8]
24006612:	4313      	orrs	r3, r2
24006614:	61bb      	str	r3, [r7, #24]
24006616:	e004      	b.n	24006622 <HAL_EXTI_SetConfigLine+0x7e>
    }
    else
    {
      regval &= ~maskline;
24006618:	68bb      	ldr	r3, [r7, #8]
2400661a:	43db      	mvns	r3, r3
2400661c:	69ba      	ldr	r2, [r7, #24]
2400661e:	4013      	ands	r3, r2
24006620:	61bb      	str	r3, [r7, #24]
    }

    /* Store rising trigger mode */
    *regaddr = regval;
24006622:	69fb      	ldr	r3, [r7, #28]
24006624:	69ba      	ldr	r2, [r7, #24]
24006626:	601a      	str	r2, [r3, #0]

    /* Configure falling trigger */
    regaddr = (__IO uint32_t *)(&EXTI->FTSR1 + (EXTI_CONFIG_OFFSET * offset));
24006628:	693b      	ldr	r3, [r7, #16]
2400662a:	015a      	lsls	r2, r3, #5
2400662c:	4b6d      	ldr	r3, [pc, #436]	; (240067e4 <HAL_EXTI_SetConfigLine+0x240>)
2400662e:	4413      	add	r3, r2
24006630:	61fb      	str	r3, [r7, #28]
    regval = *regaddr;
24006632:	69fb      	ldr	r3, [r7, #28]
24006634:	681b      	ldr	r3, [r3, #0]
24006636:	61bb      	str	r3, [r7, #24]

    /* Mask or set line */
    if ((pExtiConfig->Trigger & EXTI_TRIGGER_FALLING) != 0x00U)
24006638:	683b      	ldr	r3, [r7, #0]
2400663a:	689b      	ldr	r3, [r3, #8]
2400663c:	f003 0302 	and.w	r3, r3, #2
24006640:	2b00      	cmp	r3, #0
24006642:	d004      	beq.n	2400664e <HAL_EXTI_SetConfigLine+0xaa>
    {
      regval |= maskline;
24006644:	69ba      	ldr	r2, [r7, #24]
24006646:	68bb      	ldr	r3, [r7, #8]
24006648:	4313      	orrs	r3, r2
2400664a:	61bb      	str	r3, [r7, #24]
2400664c:	e004      	b.n	24006658 <HAL_EXTI_SetConfigLine+0xb4>
    }
    else
    {
      regval &= ~maskline;
2400664e:	68bb      	ldr	r3, [r7, #8]
24006650:	43db      	mvns	r3, r3
24006652:	69ba      	ldr	r2, [r7, #24]
24006654:	4013      	ands	r3, r2
24006656:	61bb      	str	r3, [r7, #24]
    }

    /* Store falling trigger mode */
    *regaddr = regval;
24006658:	69fb      	ldr	r3, [r7, #28]
2400665a:	69ba      	ldr	r2, [r7, #24]
2400665c:	601a      	str	r2, [r3, #0]

    /* Configure gpio port selection in case of gpio exti line */
    if ((pExtiConfig->Line & EXTI_GPIO) == EXTI_GPIO)
2400665e:	683b      	ldr	r3, [r7, #0]
24006660:	681b      	ldr	r3, [r3, #0]
24006662:	f003 63c0 	and.w	r3, r3, #100663296	; 0x6000000
24006666:	f1b3 6fc0 	cmp.w	r3, #100663296	; 0x6000000
2400666a:	d127      	bne.n	240066bc <HAL_EXTI_SetConfigLine+0x118>
    {
      assert_param(IS_EXTI_GPIO_PORT(pExtiConfig->GPIOSel));
      assert_param(IS_EXTI_GPIO_PIN(linepos));

      regval = SYSCFG->EXTICR[(linepos >> 2U) & 0x03UL];
2400666c:	4a5e      	ldr	r2, [pc, #376]	; (240067e8 <HAL_EXTI_SetConfigLine+0x244>)
2400666e:	68fb      	ldr	r3, [r7, #12]
24006670:	089b      	lsrs	r3, r3, #2
24006672:	f003 0303 	and.w	r3, r3, #3
24006676:	3302      	adds	r3, #2
24006678:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
2400667c:	61bb      	str	r3, [r7, #24]
      regval &= ~(SYSCFG_EXTICR1_EXTI0 << (SYSCFG_EXTICR1_EXTI1_Pos * (linepos & 0x03U)));
2400667e:	68fb      	ldr	r3, [r7, #12]
24006680:	f003 0303 	and.w	r3, r3, #3
24006684:	009b      	lsls	r3, r3, #2
24006686:	220f      	movs	r2, #15
24006688:	fa02 f303 	lsl.w	r3, r2, r3
2400668c:	43db      	mvns	r3, r3
2400668e:	69ba      	ldr	r2, [r7, #24]
24006690:	4013      	ands	r3, r2
24006692:	61bb      	str	r3, [r7, #24]
      regval |= (pExtiConfig->GPIOSel << (SYSCFG_EXTICR1_EXTI1_Pos * (linepos & 0x03U)));
24006694:	683b      	ldr	r3, [r7, #0]
24006696:	68da      	ldr	r2, [r3, #12]
24006698:	68fb      	ldr	r3, [r7, #12]
2400669a:	f003 0303 	and.w	r3, r3, #3
2400669e:	009b      	lsls	r3, r3, #2
240066a0:	fa02 f303 	lsl.w	r3, r2, r3
240066a4:	69ba      	ldr	r2, [r7, #24]
240066a6:	4313      	orrs	r3, r2
240066a8:	61bb      	str	r3, [r7, #24]
      SYSCFG->EXTICR[(linepos >> 2U) & 0x03UL] = regval;
240066aa:	494f      	ldr	r1, [pc, #316]	; (240067e8 <HAL_EXTI_SetConfigLine+0x244>)
240066ac:	68fb      	ldr	r3, [r7, #12]
240066ae:	089b      	lsrs	r3, r3, #2
240066b0:	f003 0303 	and.w	r3, r3, #3
240066b4:	3302      	adds	r3, #2
240066b6:	69ba      	ldr	r2, [r7, #24]
240066b8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
  }

  /* Configure interrupt mode : read current mode */
  regaddr = (__IO uint32_t *)(&EXTI->IMR1 + (EXTI_MODE_OFFSET * offset));
240066bc:	693b      	ldr	r3, [r7, #16]
240066be:	011a      	lsls	r2, r3, #4
240066c0:	4b4a      	ldr	r3, [pc, #296]	; (240067ec <HAL_EXTI_SetConfigLine+0x248>)
240066c2:	4413      	add	r3, r2
240066c4:	61fb      	str	r3, [r7, #28]
  regval = *regaddr;
240066c6:	69fb      	ldr	r3, [r7, #28]
240066c8:	681b      	ldr	r3, [r3, #0]
240066ca:	61bb      	str	r3, [r7, #24]

  /* Mask or set line */
  if ((pExtiConfig->Mode & EXTI_MODE_INTERRUPT) != 0x00U)
240066cc:	683b      	ldr	r3, [r7, #0]
240066ce:	685b      	ldr	r3, [r3, #4]
240066d0:	f003 0301 	and.w	r3, r3, #1
240066d4:	2b00      	cmp	r3, #0
240066d6:	d004      	beq.n	240066e2 <HAL_EXTI_SetConfigLine+0x13e>
  {
    regval |= maskline;
240066d8:	69ba      	ldr	r2, [r7, #24]
240066da:	68bb      	ldr	r3, [r7, #8]
240066dc:	4313      	orrs	r3, r2
240066de:	61bb      	str	r3, [r7, #24]
240066e0:	e004      	b.n	240066ec <HAL_EXTI_SetConfigLine+0x148>
  }
  else
  {
    regval &= ~maskline;
240066e2:	68bb      	ldr	r3, [r7, #8]
240066e4:	43db      	mvns	r3, r3
240066e6:	69ba      	ldr	r2, [r7, #24]
240066e8:	4013      	ands	r3, r2
240066ea:	61bb      	str	r3, [r7, #24]
  }

  /* Store interrupt mode */
  *regaddr = regval;
240066ec:	69fb      	ldr	r3, [r7, #28]
240066ee:	69ba      	ldr	r2, [r7, #24]
240066f0:	601a      	str	r2, [r3, #0]

  /* The event mode cannot be configured if the line does not support it */
  assert_param(((pExtiConfig->Line & EXTI_EVENT) == EXTI_EVENT) || ((pExtiConfig->Mode & EXTI_MODE_EVENT) != EXTI_MODE_EVENT));

  /* Configure event mode : read current mode */
  regaddr = (__IO uint32_t *)(&EXTI->EMR1 + (EXTI_MODE_OFFSET * offset));
240066f2:	693b      	ldr	r3, [r7, #16]
240066f4:	011a      	lsls	r2, r3, #4
240066f6:	4b3e      	ldr	r3, [pc, #248]	; (240067f0 <HAL_EXTI_SetConfigLine+0x24c>)
240066f8:	4413      	add	r3, r2
240066fa:	61fb      	str	r3, [r7, #28]
  regval = *regaddr;
240066fc:	69fb      	ldr	r3, [r7, #28]
240066fe:	681b      	ldr	r3, [r3, #0]
24006700:	61bb      	str	r3, [r7, #24]

  /* Mask or set line */
  if ((pExtiConfig->Mode & EXTI_MODE_EVENT) != 0x00U)
24006702:	683b      	ldr	r3, [r7, #0]
24006704:	685b      	ldr	r3, [r3, #4]
24006706:	f003 0302 	and.w	r3, r3, #2
2400670a:	2b00      	cmp	r3, #0
2400670c:	d004      	beq.n	24006718 <HAL_EXTI_SetConfigLine+0x174>
  {
    regval |= maskline;
2400670e:	69ba      	ldr	r2, [r7, #24]
24006710:	68bb      	ldr	r3, [r7, #8]
24006712:	4313      	orrs	r3, r2
24006714:	61bb      	str	r3, [r7, #24]
24006716:	e004      	b.n	24006722 <HAL_EXTI_SetConfigLine+0x17e>
  }
  else
  {
    regval &= ~maskline;
24006718:	68bb      	ldr	r3, [r7, #8]
2400671a:	43db      	mvns	r3, r3
2400671c:	69ba      	ldr	r2, [r7, #24]
2400671e:	4013      	ands	r3, r2
24006720:	61bb      	str	r3, [r7, #24]
  }

  /* Store event mode */
  *regaddr = regval;
24006722:	69fb      	ldr	r3, [r7, #28]
24006724:	69ba      	ldr	r2, [r7, #24]
24006726:	601a      	str	r2, [r3, #0]
  /* Store event mode */
  *regaddr = regval;
#endif /* DUAL_CORE */

  /* Configure the D3 PendClear source in case of Wakeup target is Any */
  if ((pExtiConfig->Line & EXTI_TARGET_MASK) == EXTI_TARGET_MSK_ALL)
24006728:	683b      	ldr	r3, [r7, #0]
2400672a:	681b      	ldr	r3, [r3, #0]
2400672c:	f403 1340 	and.w	r3, r3, #3145728	; 0x300000
24006730:	f5b3 1f40 	cmp.w	r3, #3145728	; 0x300000
24006734:	d14e      	bne.n	240067d4 <HAL_EXTI_SetConfigLine+0x230>
  {
    assert_param(IS_EXTI_D3_PENDCLR_SRC(pExtiConfig->PendClearSource));

    /*Calc the PMR register address for the given line */
    regaddr = (__IO uint32_t *)(&EXTI->D3PMR1 + (EXTI_CONFIG_OFFSET * offset));
24006736:	693b      	ldr	r3, [r7, #16]
24006738:	015a      	lsls	r2, r3, #5
2400673a:	4b2e      	ldr	r3, [pc, #184]	; (240067f4 <HAL_EXTI_SetConfigLine+0x250>)
2400673c:	4413      	add	r3, r2
2400673e:	61fb      	str	r3, [r7, #28]
    regval = *regaddr;
24006740:	69fb      	ldr	r3, [r7, #28]
24006742:	681b      	ldr	r3, [r3, #0]
24006744:	61bb      	str	r3, [r7, #24]

    if(pExtiConfig->PendClearSource == EXTI_D3_PENDCLR_SRC_NONE)
24006746:	683b      	ldr	r3, [r7, #0]
24006748:	691b      	ldr	r3, [r3, #16]
2400674a:	2b00      	cmp	r3, #0
2400674c:	d108      	bne.n	24006760 <HAL_EXTI_SetConfigLine+0x1bc>
    {
      /* Clear D3PMRx register for the given line */
      regval &= ~maskline;
2400674e:	68bb      	ldr	r3, [r7, #8]
24006750:	43db      	mvns	r3, r3
24006752:	69ba      	ldr	r2, [r7, #24]
24006754:	4013      	ands	r3, r2
24006756:	61bb      	str	r3, [r7, #24]
      /* Store D3PMRx register value */
      *regaddr = regval;
24006758:	69fb      	ldr	r3, [r7, #28]
2400675a:	69ba      	ldr	r2, [r7, #24]
2400675c:	601a      	str	r2, [r3, #0]
2400675e:	e039      	b.n	240067d4 <HAL_EXTI_SetConfigLine+0x230>
    }
    else
    {
      /* Set D3PMRx register to 1 for the given line */
      regval |= maskline;
24006760:	69ba      	ldr	r2, [r7, #24]
24006762:	68bb      	ldr	r3, [r7, #8]
24006764:	4313      	orrs	r3, r2
24006766:	61bb      	str	r3, [r7, #24]
      /* Store D3PMRx register value */
      *regaddr = regval;
24006768:	69fb      	ldr	r3, [r7, #28]
2400676a:	69ba      	ldr	r2, [r7, #24]
2400676c:	601a      	str	r2, [r3, #0]

      if(linepos < 16UL)
2400676e:	68fb      	ldr	r3, [r7, #12]
24006770:	2b0f      	cmp	r3, #15
24006772:	d80a      	bhi.n	2400678a <HAL_EXTI_SetConfigLine+0x1e6>
      {
        regaddr = (__IO uint32_t *)(&EXTI->D3PCR1L + (EXTI_CONFIG_OFFSET * offset));
24006774:	693b      	ldr	r3, [r7, #16]
24006776:	015a      	lsls	r2, r3, #5
24006778:	4b1f      	ldr	r3, [pc, #124]	; (240067f8 <HAL_EXTI_SetConfigLine+0x254>)
2400677a:	4413      	add	r3, r2
2400677c:	61fb      	str	r3, [r7, #28]
        pcrlinepos = 1UL << linepos;
2400677e:	2201      	movs	r2, #1
24006780:	68fb      	ldr	r3, [r7, #12]
24006782:	fa02 f303 	lsl.w	r3, r2, r3
24006786:	617b      	str	r3, [r7, #20]
24006788:	e00a      	b.n	240067a0 <HAL_EXTI_SetConfigLine+0x1fc>
      }
      else
      {
        regaddr = (__IO uint32_t *)(&EXTI->D3PCR1H + (EXTI_CONFIG_OFFSET * offset));
2400678a:	693b      	ldr	r3, [r7, #16]
2400678c:	015a      	lsls	r2, r3, #5
2400678e:	4b1b      	ldr	r3, [pc, #108]	; (240067fc <HAL_EXTI_SetConfigLine+0x258>)
24006790:	4413      	add	r3, r2
24006792:	61fb      	str	r3, [r7, #28]
        pcrlinepos = 1UL << (linepos - 16UL);
24006794:	68fb      	ldr	r3, [r7, #12]
24006796:	3b10      	subs	r3, #16
24006798:	2201      	movs	r2, #1
2400679a:	fa02 f303 	lsl.w	r3, r2, r3
2400679e:	617b      	str	r3, [r7, #20]
      }

      regval = (*regaddr & (~(pcrlinepos * pcrlinepos * 3UL))) | (pcrlinepos * pcrlinepos * (pExtiConfig->PendClearSource - 1UL));
240067a0:	69fb      	ldr	r3, [r7, #28]
240067a2:	6819      	ldr	r1, [r3, #0]
240067a4:	697b      	ldr	r3, [r7, #20]
240067a6:	697a      	ldr	r2, [r7, #20]
240067a8:	fb02 f203 	mul.w	r2, r2, r3
240067ac:	4613      	mov	r3, r2
240067ae:	005b      	lsls	r3, r3, #1
240067b0:	4413      	add	r3, r2
240067b2:	43db      	mvns	r3, r3
240067b4:	ea01 0203 	and.w	r2, r1, r3
240067b8:	697b      	ldr	r3, [r7, #20]
240067ba:	6979      	ldr	r1, [r7, #20]
240067bc:	fb01 f303 	mul.w	r3, r1, r3
240067c0:	6839      	ldr	r1, [r7, #0]
240067c2:	6909      	ldr	r1, [r1, #16]
240067c4:	3901      	subs	r1, #1
240067c6:	fb01 f303 	mul.w	r3, r1, r3
240067ca:	4313      	orrs	r3, r2
240067cc:	61bb      	str	r3, [r7, #24]
      *regaddr = regval;
240067ce:	69fb      	ldr	r3, [r7, #28]
240067d0:	69ba      	ldr	r2, [r7, #24]
240067d2:	601a      	str	r2, [r3, #0]
    }
  }

  return HAL_OK;
240067d4:	2300      	movs	r3, #0
}
240067d6:	4618      	mov	r0, r3
240067d8:	3724      	adds	r7, #36	; 0x24
240067da:	46bd      	mov	sp, r7
240067dc:	f85d 7b04 	ldr.w	r7, [sp], #4
240067e0:	4770      	bx	lr
240067e2:	bf00      	nop
240067e4:	58000004 	.word	0x58000004
240067e8:	58000400 	.word	0x58000400
240067ec:	58000080 	.word	0x58000080
240067f0:	58000084 	.word	0x58000084
240067f4:	5800000c 	.word	0x5800000c
240067f8:	58000010 	.word	0x58000010
240067fc:	58000014 	.word	0x58000014

24006800 <HAL_EXTI_GetConfigLine>:
  * @param  hexti Exti handle.
  * @param  pExtiConfig Pointer on structure to store Exti configuration.
  * @retval HAL Status.
  */
HAL_StatusTypeDef HAL_EXTI_GetConfigLine(EXTI_HandleTypeDef *hexti, EXTI_ConfigTypeDef *pExtiConfig)
{
24006800:	b480      	push	{r7}
24006802:	b089      	sub	sp, #36	; 0x24
24006804:	af00      	add	r7, sp, #0
24006806:	6078      	str	r0, [r7, #4]
24006808:	6039      	str	r1, [r7, #0]
  uint32_t maskline;
  uint32_t offset;
  uint32_t pcrlinepos;

  /* Check null pointer */
  if ((hexti == NULL) || (pExtiConfig == NULL))
2400680a:	687b      	ldr	r3, [r7, #4]
2400680c:	2b00      	cmp	r3, #0
2400680e:	d002      	beq.n	24006816 <HAL_EXTI_GetConfigLine+0x16>
24006810:	683b      	ldr	r3, [r7, #0]
24006812:	2b00      	cmp	r3, #0
24006814:	d101      	bne.n	2400681a <HAL_EXTI_GetConfigLine+0x1a>
  {
    return HAL_ERROR;
24006816:	2301      	movs	r3, #1
24006818:	e0d4      	b.n	240069c4 <HAL_EXTI_GetConfigLine+0x1c4>

  /* Check the parameter */
  assert_param(IS_EXTI_LINE(hexti->Line));

  /* Store handle line number to configuration structure */
  pExtiConfig->Line = hexti->Line;
2400681a:	687b      	ldr	r3, [r7, #4]
2400681c:	681a      	ldr	r2, [r3, #0]
2400681e:	683b      	ldr	r3, [r7, #0]
24006820:	601a      	str	r2, [r3, #0]

  /* compute line register offset and line mask */
  offset = ((pExtiConfig->Line & EXTI_REG_MASK) >> EXTI_REG_SHIFT);
24006822:	683b      	ldr	r3, [r7, #0]
24006824:	681b      	ldr	r3, [r3, #0]
24006826:	0c1b      	lsrs	r3, r3, #16
24006828:	f003 0303 	and.w	r3, r3, #3
2400682c:	617b      	str	r3, [r7, #20]
  linepos = (pExtiConfig->Line & EXTI_PIN_MASK);
2400682e:	683b      	ldr	r3, [r7, #0]
24006830:	681b      	ldr	r3, [r3, #0]
24006832:	f003 031f 	and.w	r3, r3, #31
24006836:	613b      	str	r3, [r7, #16]
  maskline = (1UL << linepos);
24006838:	2201      	movs	r2, #1
2400683a:	693b      	ldr	r3, [r7, #16]
2400683c:	fa02 f303 	lsl.w	r3, r2, r3
24006840:	60fb      	str	r3, [r7, #12]

  /* 1] Get core mode : interrupt */
  regaddr = (__IO uint32_t *)(&EXTI->IMR1 + (EXTI_MODE_OFFSET * offset));
24006842:	697b      	ldr	r3, [r7, #20]
24006844:	011a      	lsls	r2, r3, #4
24006846:	4b62      	ldr	r3, [pc, #392]	; (240069d0 <HAL_EXTI_GetConfigLine+0x1d0>)
24006848:	4413      	add	r3, r2
2400684a:	61fb      	str	r3, [r7, #28]
  regval = *regaddr;
2400684c:	69fb      	ldr	r3, [r7, #28]
2400684e:	681b      	ldr	r3, [r3, #0]
24006850:	60bb      	str	r3, [r7, #8]

  pExtiConfig->Mode = EXTI_MODE_NONE;
24006852:	683b      	ldr	r3, [r7, #0]
24006854:	2200      	movs	r2, #0
24006856:	605a      	str	r2, [r3, #4]

  /* Check if selected line is enable */
  if ((regval & maskline) != 0x00U)
24006858:	68ba      	ldr	r2, [r7, #8]
2400685a:	68fb      	ldr	r3, [r7, #12]
2400685c:	4013      	ands	r3, r2
2400685e:	2b00      	cmp	r3, #0
24006860:	d002      	beq.n	24006868 <HAL_EXTI_GetConfigLine+0x68>
  {
    pExtiConfig->Mode = EXTI_MODE_INTERRUPT;
24006862:	683b      	ldr	r3, [r7, #0]
24006864:	2201      	movs	r2, #1
24006866:	605a      	str	r2, [r3, #4]
  }

  /* Get event mode */
  regaddr = (__IO uint32_t *)(&EXTI->EMR1 + (EXTI_MODE_OFFSET * offset));
24006868:	697b      	ldr	r3, [r7, #20]
2400686a:	011a      	lsls	r2, r3, #4
2400686c:	4b59      	ldr	r3, [pc, #356]	; (240069d4 <HAL_EXTI_GetConfigLine+0x1d4>)
2400686e:	4413      	add	r3, r2
24006870:	61fb      	str	r3, [r7, #28]
  regval = *regaddr;
24006872:	69fb      	ldr	r3, [r7, #28]
24006874:	681b      	ldr	r3, [r3, #0]
24006876:	60bb      	str	r3, [r7, #8]

  /* Check if selected line is enable */
  if ((regval & maskline) != 0x00U)
24006878:	68ba      	ldr	r2, [r7, #8]
2400687a:	68fb      	ldr	r3, [r7, #12]
2400687c:	4013      	ands	r3, r2
2400687e:	2b00      	cmp	r3, #0
24006880:	d005      	beq.n	2400688e <HAL_EXTI_GetConfigLine+0x8e>
  {
    pExtiConfig->Mode |= EXTI_MODE_EVENT;
24006882:	683b      	ldr	r3, [r7, #0]
24006884:	685b      	ldr	r3, [r3, #4]
24006886:	f043 0202 	orr.w	r2, r3, #2
2400688a:	683b      	ldr	r3, [r7, #0]
2400688c:	605a      	str	r2, [r3, #4]
    pExtiConfig->Mode |= EXTI_MODE_CORE2_EVENT;
  }
#endif /*DUAL_CORE*/

  /* 2] Get trigger for configurable lines : rising */
  if ((pExtiConfig->Line & EXTI_CONFIG) != 0x00U)
2400688e:	683b      	ldr	r3, [r7, #0]
24006890:	681b      	ldr	r3, [r3, #0]
24006892:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
24006896:	2b00      	cmp	r3, #0
24006898:	d046      	beq.n	24006928 <HAL_EXTI_GetConfigLine+0x128>
  {
    regaddr = (__IO uint32_t *)(&EXTI->RTSR1 + (EXTI_CONFIG_OFFSET * offset));
2400689a:	697b      	ldr	r3, [r7, #20]
2400689c:	015b      	lsls	r3, r3, #5
2400689e:	f103 43b0 	add.w	r3, r3, #1476395008	; 0x58000000
240068a2:	61fb      	str	r3, [r7, #28]
    regval = *regaddr;
240068a4:	69fb      	ldr	r3, [r7, #28]
240068a6:	681b      	ldr	r3, [r3, #0]
240068a8:	60bb      	str	r3, [r7, #8]

    /* Check if configuration of selected line is enable */
    if ((regval & maskline) != 0x00U)
240068aa:	68ba      	ldr	r2, [r7, #8]
240068ac:	68fb      	ldr	r3, [r7, #12]
240068ae:	4013      	ands	r3, r2
240068b0:	2b00      	cmp	r3, #0
240068b2:	d003      	beq.n	240068bc <HAL_EXTI_GetConfigLine+0xbc>
    {
      pExtiConfig->Trigger = EXTI_TRIGGER_RISING;
240068b4:	683b      	ldr	r3, [r7, #0]
240068b6:	2201      	movs	r2, #1
240068b8:	609a      	str	r2, [r3, #8]
240068ba:	e002      	b.n	240068c2 <HAL_EXTI_GetConfigLine+0xc2>
    }
    else
    {
      pExtiConfig->Trigger = EXTI_TRIGGER_NONE;
240068bc:	683b      	ldr	r3, [r7, #0]
240068be:	2200      	movs	r2, #0
240068c0:	609a      	str	r2, [r3, #8]
    }

    /* Get falling configuration */
    regaddr = (__IO uint32_t *)(&EXTI->FTSR1 + (EXTI_CONFIG_OFFSET * offset));
240068c2:	697b      	ldr	r3, [r7, #20]
240068c4:	015a      	lsls	r2, r3, #5
240068c6:	4b44      	ldr	r3, [pc, #272]	; (240069d8 <HAL_EXTI_GetConfigLine+0x1d8>)
240068c8:	4413      	add	r3, r2
240068ca:	61fb      	str	r3, [r7, #28]
    regval = *regaddr;
240068cc:	69fb      	ldr	r3, [r7, #28]
240068ce:	681b      	ldr	r3, [r3, #0]
240068d0:	60bb      	str	r3, [r7, #8]

    /* Check if configuration of selected line is enable */
    if ((regval & maskline) != 0x00U)
240068d2:	68ba      	ldr	r2, [r7, #8]
240068d4:	68fb      	ldr	r3, [r7, #12]
240068d6:	4013      	ands	r3, r2
240068d8:	2b00      	cmp	r3, #0
240068da:	d005      	beq.n	240068e8 <HAL_EXTI_GetConfigLine+0xe8>
    {
      pExtiConfig->Trigger |= EXTI_TRIGGER_FALLING;
240068dc:	683b      	ldr	r3, [r7, #0]
240068de:	689b      	ldr	r3, [r3, #8]
240068e0:	f043 0202 	orr.w	r2, r3, #2
240068e4:	683b      	ldr	r3, [r7, #0]
240068e6:	609a      	str	r2, [r3, #8]
    }

    /* Get Gpio port selection for gpio lines */
    if ((pExtiConfig->Line & EXTI_GPIO) == EXTI_GPIO)
240068e8:	683b      	ldr	r3, [r7, #0]
240068ea:	681b      	ldr	r3, [r3, #0]
240068ec:	f003 63c0 	and.w	r3, r3, #100663296	; 0x6000000
240068f0:	f1b3 6fc0 	cmp.w	r3, #100663296	; 0x6000000
240068f4:	d114      	bne.n	24006920 <HAL_EXTI_GetConfigLine+0x120>
    {
      assert_param(IS_EXTI_GPIO_PIN(linepos));

      regval = SYSCFG->EXTICR[(linepos >> 2U) & 0x03UL];
240068f6:	4a39      	ldr	r2, [pc, #228]	; (240069dc <HAL_EXTI_GetConfigLine+0x1dc>)
240068f8:	693b      	ldr	r3, [r7, #16]
240068fa:	089b      	lsrs	r3, r3, #2
240068fc:	f003 0303 	and.w	r3, r3, #3
24006900:	3302      	adds	r3, #2
24006902:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
24006906:	60bb      	str	r3, [r7, #8]
      pExtiConfig->GPIOSel = ((regval << (SYSCFG_EXTICR1_EXTI1_Pos * (3UL - (linepos & 0x03UL)))) >> 24U);
24006908:	693b      	ldr	r3, [r7, #16]
2400690a:	43db      	mvns	r3, r3
2400690c:	f003 0303 	and.w	r3, r3, #3
24006910:	009b      	lsls	r3, r3, #2
24006912:	68ba      	ldr	r2, [r7, #8]
24006914:	fa02 f303 	lsl.w	r3, r2, r3
24006918:	0e1a      	lsrs	r2, r3, #24
2400691a:	683b      	ldr	r3, [r7, #0]
2400691c:	60da      	str	r2, [r3, #12]
2400691e:	e009      	b.n	24006934 <HAL_EXTI_GetConfigLine+0x134>
    }
    else
    {
      pExtiConfig->GPIOSel = 0x00U;
24006920:	683b      	ldr	r3, [r7, #0]
24006922:	2200      	movs	r2, #0
24006924:	60da      	str	r2, [r3, #12]
24006926:	e005      	b.n	24006934 <HAL_EXTI_GetConfigLine+0x134>
    }
  }
  else
  {
    pExtiConfig->Trigger = EXTI_TRIGGER_NONE;
24006928:	683b      	ldr	r3, [r7, #0]
2400692a:	2200      	movs	r2, #0
2400692c:	609a      	str	r2, [r3, #8]
    pExtiConfig->GPIOSel = 0x00U;
2400692e:	683b      	ldr	r3, [r7, #0]
24006930:	2200      	movs	r2, #0
24006932:	60da      	str	r2, [r3, #12]
  }

  /* 3] Get D3 Pend Clear source */
  if ((pExtiConfig->Line & EXTI_TARGET_MASK) == EXTI_TARGET_MSK_ALL)
24006934:	683b      	ldr	r3, [r7, #0]
24006936:	681b      	ldr	r3, [r3, #0]
24006938:	f403 1340 	and.w	r3, r3, #3145728	; 0x300000
2400693c:	f5b3 1f40 	cmp.w	r3, #3145728	; 0x300000
24006940:	d13c      	bne.n	240069bc <HAL_EXTI_GetConfigLine+0x1bc>
  {
    regaddr = (__IO uint32_t *)(&EXTI->D3PMR1 + (EXTI_CONFIG_OFFSET * offset));
24006942:	697b      	ldr	r3, [r7, #20]
24006944:	015a      	lsls	r2, r3, #5
24006946:	4b26      	ldr	r3, [pc, #152]	; (240069e0 <HAL_EXTI_GetConfigLine+0x1e0>)
24006948:	4413      	add	r3, r2
2400694a:	61fb      	str	r3, [r7, #28]
    if(((*regaddr) & linepos) == 0UL)
2400694c:	69fb      	ldr	r3, [r7, #28]
2400694e:	681a      	ldr	r2, [r3, #0]
24006950:	693b      	ldr	r3, [r7, #16]
24006952:	4013      	ands	r3, r2
24006954:	2b00      	cmp	r3, #0
24006956:	d103      	bne.n	24006960 <HAL_EXTI_GetConfigLine+0x160>
    {
      /* if PMR unset, then no pend clear source is used */
      pExtiConfig->PendClearSource = EXTI_D3_PENDCLR_SRC_NONE;
24006958:	683b      	ldr	r3, [r7, #0]
2400695a:	2200      	movs	r2, #0
2400695c:	611a      	str	r2, [r3, #16]
2400695e:	e030      	b.n	240069c2 <HAL_EXTI_GetConfigLine+0x1c2>
    }
    else
    {
      /* if wakeup target is any and PMR set, the read pend clear source from  D3PCRxL/H */
      if(linepos < 16UL)
24006960:	693b      	ldr	r3, [r7, #16]
24006962:	2b0f      	cmp	r3, #15
24006964:	d80a      	bhi.n	2400697c <HAL_EXTI_GetConfigLine+0x17c>
      {
        regaddr = (__IO uint32_t *)(&EXTI->D3PCR1L + (EXTI_CONFIG_OFFSET * offset));
24006966:	697b      	ldr	r3, [r7, #20]
24006968:	015a      	lsls	r2, r3, #5
2400696a:	4b1e      	ldr	r3, [pc, #120]	; (240069e4 <HAL_EXTI_GetConfigLine+0x1e4>)
2400696c:	4413      	add	r3, r2
2400696e:	61fb      	str	r3, [r7, #28]
        pcrlinepos = 1UL << linepos;
24006970:	2201      	movs	r2, #1
24006972:	693b      	ldr	r3, [r7, #16]
24006974:	fa02 f303 	lsl.w	r3, r2, r3
24006978:	61bb      	str	r3, [r7, #24]
2400697a:	e00a      	b.n	24006992 <HAL_EXTI_GetConfigLine+0x192>
      }
      else
      {
        regaddr = (__IO uint32_t *)(&EXTI->D3PCR1H + (EXTI_CONFIG_OFFSET * offset));
2400697c:	697b      	ldr	r3, [r7, #20]
2400697e:	015a      	lsls	r2, r3, #5
24006980:	4b19      	ldr	r3, [pc, #100]	; (240069e8 <HAL_EXTI_GetConfigLine+0x1e8>)
24006982:	4413      	add	r3, r2
24006984:	61fb      	str	r3, [r7, #28]
        pcrlinepos = 1UL << (linepos - 16UL);
24006986:	693b      	ldr	r3, [r7, #16]
24006988:	3b10      	subs	r3, #16
2400698a:	2201      	movs	r2, #1
2400698c:	fa02 f303 	lsl.w	r3, r2, r3
24006990:	61bb      	str	r3, [r7, #24]
      }

      pExtiConfig->PendClearSource = 1UL + ((*regaddr & (pcrlinepos * pcrlinepos * 3UL)) / (pcrlinepos * pcrlinepos));
24006992:	69fb      	ldr	r3, [r7, #28]
24006994:	6819      	ldr	r1, [r3, #0]
24006996:	69bb      	ldr	r3, [r7, #24]
24006998:	69ba      	ldr	r2, [r7, #24]
2400699a:	fb02 f203 	mul.w	r2, r2, r3
2400699e:	4613      	mov	r3, r2
240069a0:	005b      	lsls	r3, r3, #1
240069a2:	4413      	add	r3, r2
240069a4:	ea01 0203 	and.w	r2, r1, r3
240069a8:	69bb      	ldr	r3, [r7, #24]
240069aa:	69b9      	ldr	r1, [r7, #24]
240069ac:	fb01 f303 	mul.w	r3, r1, r3
240069b0:	fbb2 f3f3 	udiv	r3, r2, r3
240069b4:	1c5a      	adds	r2, r3, #1
240069b6:	683b      	ldr	r3, [r7, #0]
240069b8:	611a      	str	r2, [r3, #16]
240069ba:	e002      	b.n	240069c2 <HAL_EXTI_GetConfigLine+0x1c2>
    }
  }
  else
  {
    /* if line wakeup target is not any, then no pend clear source is used  */
    pExtiConfig->PendClearSource = EXTI_D3_PENDCLR_SRC_NONE;
240069bc:	683b      	ldr	r3, [r7, #0]
240069be:	2200      	movs	r2, #0
240069c0:	611a      	str	r2, [r3, #16]
  }

  return HAL_OK;
240069c2:	2300      	movs	r3, #0
}
240069c4:	4618      	mov	r0, r3
240069c6:	3724      	adds	r7, #36	; 0x24
240069c8:	46bd      	mov	sp, r7
240069ca:	f85d 7b04 	ldr.w	r7, [sp], #4
240069ce:	4770      	bx	lr
240069d0:	58000080 	.word	0x58000080
240069d4:	58000084 	.word	0x58000084
240069d8:	58000004 	.word	0x58000004
240069dc:	58000400 	.word	0x58000400
240069e0:	5800000c 	.word	0x5800000c
240069e4:	58000010 	.word	0x58000010
240069e8:	58000014 	.word	0x58000014

240069ec <HAL_EXTI_ClearConfigLine>:
  * @brief  Clear whole configuration of a dedicated Exti line.
  * @param  hexti Exti handle.
  * @retval HAL Status.
  */
HAL_StatusTypeDef HAL_EXTI_ClearConfigLine(EXTI_HandleTypeDef *hexti)
{
240069ec:	b480      	push	{r7}
240069ee:	b089      	sub	sp, #36	; 0x24
240069f0:	af00      	add	r7, sp, #0
240069f2:	6078      	str	r0, [r7, #4]
  uint32_t maskline;
  uint32_t offset;
  uint32_t pcrlinepos;

  /* Check null pointer */
  if (hexti == NULL)
240069f4:	687b      	ldr	r3, [r7, #4]
240069f6:	2b00      	cmp	r3, #0
240069f8:	d101      	bne.n	240069fe <HAL_EXTI_ClearConfigLine+0x12>
  {
    return HAL_ERROR;
240069fa:	2301      	movs	r3, #1
240069fc:	e0ac      	b.n	24006b58 <HAL_EXTI_ClearConfigLine+0x16c>

  /* Check the parameter */
  assert_param(IS_EXTI_LINE(hexti->Line));

  /* compute line register offset and line mask */
  offset = ((hexti->Line & EXTI_REG_MASK) >> EXTI_REG_SHIFT);
240069fe:	687b      	ldr	r3, [r7, #4]
24006a00:	681b      	ldr	r3, [r3, #0]
24006a02:	0c1b      	lsrs	r3, r3, #16
24006a04:	f003 0303 	and.w	r3, r3, #3
24006a08:	617b      	str	r3, [r7, #20]
  linepos = (hexti->Line & EXTI_PIN_MASK);
24006a0a:	687b      	ldr	r3, [r7, #4]
24006a0c:	681b      	ldr	r3, [r3, #0]
24006a0e:	f003 031f 	and.w	r3, r3, #31
24006a12:	613b      	str	r3, [r7, #16]
  maskline = (1UL << linepos);
24006a14:	2201      	movs	r2, #1
24006a16:	693b      	ldr	r3, [r7, #16]
24006a18:	fa02 f303 	lsl.w	r3, r2, r3
24006a1c:	60fb      	str	r3, [r7, #12]

  /* 1] Clear interrupt mode */
  regaddr = (__IO uint32_t *)(&EXTI->IMR1 + (EXTI_MODE_OFFSET * offset));
24006a1e:	697b      	ldr	r3, [r7, #20]
24006a20:	011a      	lsls	r2, r3, #4
24006a22:	4b50      	ldr	r3, [pc, #320]	; (24006b64 <HAL_EXTI_ClearConfigLine+0x178>)
24006a24:	4413      	add	r3, r2
24006a26:	61fb      	str	r3, [r7, #28]
  regval = (*regaddr & ~maskline);
24006a28:	69fb      	ldr	r3, [r7, #28]
24006a2a:	681a      	ldr	r2, [r3, #0]
24006a2c:	68fb      	ldr	r3, [r7, #12]
24006a2e:	43db      	mvns	r3, r3
24006a30:	4013      	ands	r3, r2
24006a32:	60bb      	str	r3, [r7, #8]
  *regaddr = regval;
24006a34:	69fb      	ldr	r3, [r7, #28]
24006a36:	68ba      	ldr	r2, [r7, #8]
24006a38:	601a      	str	r2, [r3, #0]

  /* 2] Clear event mode */
  regaddr = (__IO uint32_t *)(&EXTI->EMR1 + (EXTI_MODE_OFFSET * offset));
24006a3a:	697b      	ldr	r3, [r7, #20]
24006a3c:	011a      	lsls	r2, r3, #4
24006a3e:	4b4a      	ldr	r3, [pc, #296]	; (24006b68 <HAL_EXTI_ClearConfigLine+0x17c>)
24006a40:	4413      	add	r3, r2
24006a42:	61fb      	str	r3, [r7, #28]
  regval = (*regaddr & ~maskline);
24006a44:	69fb      	ldr	r3, [r7, #28]
24006a46:	681a      	ldr	r2, [r3, #0]
24006a48:	68fb      	ldr	r3, [r7, #12]
24006a4a:	43db      	mvns	r3, r3
24006a4c:	4013      	ands	r3, r2
24006a4e:	60bb      	str	r3, [r7, #8]
  *regaddr = regval;
24006a50:	69fb      	ldr	r3, [r7, #28]
24006a52:	68ba      	ldr	r2, [r7, #8]
24006a54:	601a      	str	r2, [r3, #0]
  regval = (*regaddr & ~maskline);
  *regaddr = regval;
#endif /* DUAL_CORE */

  /* 3] Clear triggers in case of configurable lines */
  if ((hexti->Line & EXTI_CONFIG) != 0x00U)
24006a56:	687b      	ldr	r3, [r7, #4]
24006a58:	681b      	ldr	r3, [r3, #0]
24006a5a:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
24006a5e:	2b00      	cmp	r3, #0
24006a60:	d03f      	beq.n	24006ae2 <HAL_EXTI_ClearConfigLine+0xf6>
  {
    regaddr = (__IO uint32_t *)(&EXTI->RTSR1 + (EXTI_CONFIG_OFFSET * offset));
24006a62:	697b      	ldr	r3, [r7, #20]
24006a64:	015b      	lsls	r3, r3, #5
24006a66:	f103 43b0 	add.w	r3, r3, #1476395008	; 0x58000000
24006a6a:	61fb      	str	r3, [r7, #28]
    regval = (*regaddr & ~maskline);
24006a6c:	69fb      	ldr	r3, [r7, #28]
24006a6e:	681a      	ldr	r2, [r3, #0]
24006a70:	68fb      	ldr	r3, [r7, #12]
24006a72:	43db      	mvns	r3, r3
24006a74:	4013      	ands	r3, r2
24006a76:	60bb      	str	r3, [r7, #8]
    *regaddr = regval;
24006a78:	69fb      	ldr	r3, [r7, #28]
24006a7a:	68ba      	ldr	r2, [r7, #8]
24006a7c:	601a      	str	r2, [r3, #0]

    regaddr = (__IO uint32_t *)(&EXTI->FTSR1 + (EXTI_CONFIG_OFFSET * offset));
24006a7e:	697b      	ldr	r3, [r7, #20]
24006a80:	015a      	lsls	r2, r3, #5
24006a82:	4b3a      	ldr	r3, [pc, #232]	; (24006b6c <HAL_EXTI_ClearConfigLine+0x180>)
24006a84:	4413      	add	r3, r2
24006a86:	61fb      	str	r3, [r7, #28]
    regval = (*regaddr & ~maskline);
24006a88:	69fb      	ldr	r3, [r7, #28]
24006a8a:	681a      	ldr	r2, [r3, #0]
24006a8c:	68fb      	ldr	r3, [r7, #12]
24006a8e:	43db      	mvns	r3, r3
24006a90:	4013      	ands	r3, r2
24006a92:	60bb      	str	r3, [r7, #8]
    *regaddr = regval;
24006a94:	69fb      	ldr	r3, [r7, #28]
24006a96:	68ba      	ldr	r2, [r7, #8]
24006a98:	601a      	str	r2, [r3, #0]

    /* Get Gpio port selection for gpio lines */
    if ((hexti->Line & EXTI_GPIO) == EXTI_GPIO)
24006a9a:	687b      	ldr	r3, [r7, #4]
24006a9c:	681b      	ldr	r3, [r3, #0]
24006a9e:	f003 63c0 	and.w	r3, r3, #100663296	; 0x6000000
24006aa2:	f1b3 6fc0 	cmp.w	r3, #100663296	; 0x6000000
24006aa6:	d11c      	bne.n	24006ae2 <HAL_EXTI_ClearConfigLine+0xf6>
    {
      assert_param(IS_EXTI_GPIO_PIN(linepos));

      regval = SYSCFG->EXTICR[(linepos >> 2U) & 0x03UL];
24006aa8:	4a31      	ldr	r2, [pc, #196]	; (24006b70 <HAL_EXTI_ClearConfigLine+0x184>)
24006aaa:	693b      	ldr	r3, [r7, #16]
24006aac:	089b      	lsrs	r3, r3, #2
24006aae:	f003 0303 	and.w	r3, r3, #3
24006ab2:	3302      	adds	r3, #2
24006ab4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
24006ab8:	60bb      	str	r3, [r7, #8]
      regval &= ~(SYSCFG_EXTICR1_EXTI0 << (SYSCFG_EXTICR1_EXTI1_Pos * (linepos & 0x03UL)));
24006aba:	693b      	ldr	r3, [r7, #16]
24006abc:	f003 0303 	and.w	r3, r3, #3
24006ac0:	009b      	lsls	r3, r3, #2
24006ac2:	220f      	movs	r2, #15
24006ac4:	fa02 f303 	lsl.w	r3, r2, r3
24006ac8:	43db      	mvns	r3, r3
24006aca:	68ba      	ldr	r2, [r7, #8]
24006acc:	4013      	ands	r3, r2
24006ace:	60bb      	str	r3, [r7, #8]
      SYSCFG->EXTICR[(linepos >> 2U) & 0x03UL] = regval;
24006ad0:	4927      	ldr	r1, [pc, #156]	; (24006b70 <HAL_EXTI_ClearConfigLine+0x184>)
24006ad2:	693b      	ldr	r3, [r7, #16]
24006ad4:	089b      	lsrs	r3, r3, #2
24006ad6:	f003 0303 	and.w	r3, r3, #3
24006ada:	3302      	adds	r3, #2
24006adc:	68ba      	ldr	r2, [r7, #8]
24006ade:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
  }

  /* 4] Clear D3 Config lines */
  if ((hexti->Line & EXTI_TARGET_MASK) == EXTI_TARGET_MSK_ALL)
24006ae2:	687b      	ldr	r3, [r7, #4]
24006ae4:	681b      	ldr	r3, [r3, #0]
24006ae6:	f403 1340 	and.w	r3, r3, #3145728	; 0x300000
24006aea:	f5b3 1f40 	cmp.w	r3, #3145728	; 0x300000
24006aee:	d132      	bne.n	24006b56 <HAL_EXTI_ClearConfigLine+0x16a>
  {
    regaddr = (__IO uint32_t *)(&EXTI->D3PMR1 + (EXTI_CONFIG_OFFSET * offset));
24006af0:	697b      	ldr	r3, [r7, #20]
24006af2:	015a      	lsls	r2, r3, #5
24006af4:	4b1f      	ldr	r3, [pc, #124]	; (24006b74 <HAL_EXTI_ClearConfigLine+0x188>)
24006af6:	4413      	add	r3, r2
24006af8:	61fb      	str	r3, [r7, #28]
    *regaddr = (*regaddr & ~maskline);
24006afa:	69fb      	ldr	r3, [r7, #28]
24006afc:	681a      	ldr	r2, [r3, #0]
24006afe:	68fb      	ldr	r3, [r7, #12]
24006b00:	43db      	mvns	r3, r3
24006b02:	401a      	ands	r2, r3
24006b04:	69fb      	ldr	r3, [r7, #28]
24006b06:	601a      	str	r2, [r3, #0]

    if(linepos < 16UL)
24006b08:	693b      	ldr	r3, [r7, #16]
24006b0a:	2b0f      	cmp	r3, #15
24006b0c:	d80a      	bhi.n	24006b24 <HAL_EXTI_ClearConfigLine+0x138>
    {
      regaddr = (__IO uint32_t *)(&EXTI->D3PCR1L + (EXTI_CONFIG_OFFSET * offset));
24006b0e:	697b      	ldr	r3, [r7, #20]
24006b10:	015a      	lsls	r2, r3, #5
24006b12:	4b19      	ldr	r3, [pc, #100]	; (24006b78 <HAL_EXTI_ClearConfigLine+0x18c>)
24006b14:	4413      	add	r3, r2
24006b16:	61fb      	str	r3, [r7, #28]
      pcrlinepos = 1UL << linepos;
24006b18:	2201      	movs	r2, #1
24006b1a:	693b      	ldr	r3, [r7, #16]
24006b1c:	fa02 f303 	lsl.w	r3, r2, r3
24006b20:	61bb      	str	r3, [r7, #24]
24006b22:	e00a      	b.n	24006b3a <HAL_EXTI_ClearConfigLine+0x14e>
    }
    else
    {
      regaddr = (__IO uint32_t *)(&EXTI->D3PCR1H + (EXTI_CONFIG_OFFSET * offset));
24006b24:	697b      	ldr	r3, [r7, #20]
24006b26:	015a      	lsls	r2, r3, #5
24006b28:	4b14      	ldr	r3, [pc, #80]	; (24006b7c <HAL_EXTI_ClearConfigLine+0x190>)
24006b2a:	4413      	add	r3, r2
24006b2c:	61fb      	str	r3, [r7, #28]
      pcrlinepos = 1UL << (linepos - 16UL);
24006b2e:	693b      	ldr	r3, [r7, #16]
24006b30:	3b10      	subs	r3, #16
24006b32:	2201      	movs	r2, #1
24006b34:	fa02 f303 	lsl.w	r3, r2, r3
24006b38:	61bb      	str	r3, [r7, #24]
    }

    /*Clear D3 PendClear source */
    *regaddr &= (~(pcrlinepos * pcrlinepos * 3UL));
24006b3a:	69fb      	ldr	r3, [r7, #28]
24006b3c:	6819      	ldr	r1, [r3, #0]
24006b3e:	69bb      	ldr	r3, [r7, #24]
24006b40:	69ba      	ldr	r2, [r7, #24]
24006b42:	fb02 f203 	mul.w	r2, r2, r3
24006b46:	4613      	mov	r3, r2
24006b48:	005b      	lsls	r3, r3, #1
24006b4a:	4413      	add	r3, r2
24006b4c:	43db      	mvns	r3, r3
24006b4e:	ea01 0203 	and.w	r2, r1, r3
24006b52:	69fb      	ldr	r3, [r7, #28]
24006b54:	601a      	str	r2, [r3, #0]
  }

  return HAL_OK;
24006b56:	2300      	movs	r3, #0
}
24006b58:	4618      	mov	r0, r3
24006b5a:	3724      	adds	r7, #36	; 0x24
24006b5c:	46bd      	mov	sp, r7
24006b5e:	f85d 7b04 	ldr.w	r7, [sp], #4
24006b62:	4770      	bx	lr
24006b64:	58000080 	.word	0x58000080
24006b68:	58000084 	.word	0x58000084
24006b6c:	58000004 	.word	0x58000004
24006b70:	58000400 	.word	0x58000400
24006b74:	5800000c 	.word	0x5800000c
24006b78:	58000010 	.word	0x58000010
24006b7c:	58000014 	.word	0x58000014

24006b80 <HAL_EXTI_RegisterCallback>:
  *         This parameter can be one of @arg @ref EXTI_CallbackIDTypeDef values.
  * @param  pPendingCbfn function pointer to be stored as callback.
  * @retval HAL Status.
  */
HAL_StatusTypeDef HAL_EXTI_RegisterCallback(EXTI_HandleTypeDef *hexti, EXTI_CallbackIDTypeDef CallbackID, void (*pPendingCbfn)(void))
{
24006b80:	b480      	push	{r7}
24006b82:	b087      	sub	sp, #28
24006b84:	af00      	add	r7, sp, #0
24006b86:	60f8      	str	r0, [r7, #12]
24006b88:	460b      	mov	r3, r1
24006b8a:	607a      	str	r2, [r7, #4]
24006b8c:	72fb      	strb	r3, [r7, #11]
  HAL_StatusTypeDef status = HAL_OK;
24006b8e:	2300      	movs	r3, #0
24006b90:	75fb      	strb	r3, [r7, #23]

  /* Check null pointer */
  if (hexti == NULL)
24006b92:	68fb      	ldr	r3, [r7, #12]
24006b94:	2b00      	cmp	r3, #0
24006b96:	d101      	bne.n	24006b9c <HAL_EXTI_RegisterCallback+0x1c>
  {
    return HAL_ERROR;
24006b98:	2301      	movs	r3, #1
24006b9a:	e00a      	b.n	24006bb2 <HAL_EXTI_RegisterCallback+0x32>
  }

  switch (CallbackID)
24006b9c:	7afb      	ldrb	r3, [r7, #11]
24006b9e:	2b00      	cmp	r3, #0
24006ba0:	d103      	bne.n	24006baa <HAL_EXTI_RegisterCallback+0x2a>
  {
    case  HAL_EXTI_COMMON_CB_ID:
      hexti->PendingCallback = pPendingCbfn;
24006ba2:	68fb      	ldr	r3, [r7, #12]
24006ba4:	687a      	ldr	r2, [r7, #4]
24006ba6:	605a      	str	r2, [r3, #4]
      break;
24006ba8:	e002      	b.n	24006bb0 <HAL_EXTI_RegisterCallback+0x30>

    default:
      status = HAL_ERROR;
24006baa:	2301      	movs	r3, #1
24006bac:	75fb      	strb	r3, [r7, #23]
      break;
24006bae:	bf00      	nop
  }

  return status;
24006bb0:	7dfb      	ldrb	r3, [r7, #23]
}
24006bb2:	4618      	mov	r0, r3
24006bb4:	371c      	adds	r7, #28
24006bb6:	46bd      	mov	sp, r7
24006bb8:	f85d 7b04 	ldr.w	r7, [sp], #4
24006bbc:	4770      	bx	lr

24006bbe <HAL_EXTI_GetHandle>:
  * @param  ExtiLine Exti line number.
  *         This parameter can be from 0 to @ref EXTI_LINE_NB.
  * @retval HAL Status.
  */
HAL_StatusTypeDef HAL_EXTI_GetHandle(EXTI_HandleTypeDef *hexti, uint32_t ExtiLine)
{
24006bbe:	b480      	push	{r7}
24006bc0:	b083      	sub	sp, #12
24006bc2:	af00      	add	r7, sp, #0
24006bc4:	6078      	str	r0, [r7, #4]
24006bc6:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_EXTI_LINE(ExtiLine));

  /* Check null pointer */
  if (hexti == NULL)
24006bc8:	687b      	ldr	r3, [r7, #4]
24006bca:	2b00      	cmp	r3, #0
24006bcc:	d101      	bne.n	24006bd2 <HAL_EXTI_GetHandle+0x14>
  {
    return HAL_ERROR;
24006bce:	2301      	movs	r3, #1
24006bd0:	e003      	b.n	24006bda <HAL_EXTI_GetHandle+0x1c>
  }
  else
  {
    /* Store line number as handle private field */
    hexti->Line = ExtiLine;
24006bd2:	687b      	ldr	r3, [r7, #4]
24006bd4:	683a      	ldr	r2, [r7, #0]
24006bd6:	601a      	str	r2, [r3, #0]

    return HAL_OK;
24006bd8:	2300      	movs	r3, #0
  }
}
24006bda:	4618      	mov	r0, r3
24006bdc:	370c      	adds	r7, #12
24006bde:	46bd      	mov	sp, r7
24006be0:	f85d 7b04 	ldr.w	r7, [sp], #4
24006be4:	4770      	bx	lr
	...

24006be8 <HAL_EXTI_IRQHandler>:
  * @brief  Handle EXTI interrupt request.
  * @param  hexti Exti handle.
  * @retval none.
  */
void HAL_EXTI_IRQHandler(EXTI_HandleTypeDef *hexti)
{
24006be8:	b580      	push	{r7, lr}
24006bea:	b086      	sub	sp, #24
24006bec:	af00      	add	r7, sp, #0
24006bee:	6078      	str	r0, [r7, #4]
  uint32_t regval;
  uint32_t maskline;
  uint32_t offset;

  /* Compute line register offset and line mask */
  offset = ((hexti->Line & EXTI_REG_MASK) >> EXTI_REG_SHIFT);
24006bf0:	687b      	ldr	r3, [r7, #4]
24006bf2:	681b      	ldr	r3, [r3, #0]
24006bf4:	0c1b      	lsrs	r3, r3, #16
24006bf6:	f003 0303 	and.w	r3, r3, #3
24006bfa:	617b      	str	r3, [r7, #20]
  maskline = (1UL << (hexti->Line & EXTI_PIN_MASK));
24006bfc:	687b      	ldr	r3, [r7, #4]
24006bfe:	681b      	ldr	r3, [r3, #0]
24006c00:	f003 031f 	and.w	r3, r3, #31
24006c04:	2201      	movs	r2, #1
24006c06:	fa02 f303 	lsl.w	r3, r2, r3
24006c0a:	613b      	str	r3, [r7, #16]
  {
    /* Get pending register address */
    regaddr = (__IO uint32_t *)(&EXTI->C2PR1 + (EXTI_MODE_OFFSET * offset));
  }
#else
  regaddr = (__IO uint32_t *)(&EXTI->PR1 + (EXTI_MODE_OFFSET * offset));
24006c0c:	697b      	ldr	r3, [r7, #20]
24006c0e:	011a      	lsls	r2, r3, #4
24006c10:	4b0c      	ldr	r3, [pc, #48]	; (24006c44 <HAL_EXTI_IRQHandler+0x5c>)
24006c12:	4413      	add	r3, r2
24006c14:	60fb      	str	r3, [r7, #12]
#endif /* DUAL_CORE */

  /* Get pending bit  */
  regval = (*regaddr & maskline);
24006c16:	68fb      	ldr	r3, [r7, #12]
24006c18:	681b      	ldr	r3, [r3, #0]
24006c1a:	693a      	ldr	r2, [r7, #16]
24006c1c:	4013      	ands	r3, r2
24006c1e:	60bb      	str	r3, [r7, #8]

  if (regval != 0x00U)
24006c20:	68bb      	ldr	r3, [r7, #8]
24006c22:	2b00      	cmp	r3, #0
24006c24:	d009      	beq.n	24006c3a <HAL_EXTI_IRQHandler+0x52>
  {
    /* Clear pending bit */
    *regaddr = maskline;
24006c26:	68fb      	ldr	r3, [r7, #12]
24006c28:	693a      	ldr	r2, [r7, #16]
24006c2a:	601a      	str	r2, [r3, #0]

    /* Call callback */
    if (hexti->PendingCallback != NULL)
24006c2c:	687b      	ldr	r3, [r7, #4]
24006c2e:	685b      	ldr	r3, [r3, #4]
24006c30:	2b00      	cmp	r3, #0
24006c32:	d002      	beq.n	24006c3a <HAL_EXTI_IRQHandler+0x52>
    {
      hexti->PendingCallback();
24006c34:	687b      	ldr	r3, [r7, #4]
24006c36:	685b      	ldr	r3, [r3, #4]
24006c38:	4798      	blx	r3
    }
  }
}
24006c3a:	bf00      	nop
24006c3c:	3718      	adds	r7, #24
24006c3e:	46bd      	mov	sp, r7
24006c40:	bd80      	pop	{r7, pc}
24006c42:	bf00      	nop
24006c44:	58000088 	.word	0x58000088

24006c48 <HAL_EXTI_GetPending>:
  *           @arg @ref EXTI_TRIGGER_RISING_FALLING
  *         This parameter is kept for compatibility with other series.
  * @retval 1 if interrupt is pending else 0.
  */
uint32_t HAL_EXTI_GetPending(EXTI_HandleTypeDef *hexti, uint32_t Edge)
{
24006c48:	b480      	push	{r7}
24006c4a:	b089      	sub	sp, #36	; 0x24
24006c4c:	af00      	add	r7, sp, #0
24006c4e:	6078      	str	r0, [r7, #4]
24006c50:	6039      	str	r1, [r7, #0]
  assert_param(IS_EXTI_LINE(hexti->Line));
  assert_param(IS_EXTI_CONFIG_LINE(hexti->Line));
  assert_param(IS_EXTI_PENDING_EDGE(Edge));

  /* compute line register offset and line mask */
  offset = ((hexti->Line & EXTI_REG_MASK) >> EXTI_REG_SHIFT);
24006c52:	687b      	ldr	r3, [r7, #4]
24006c54:	681b      	ldr	r3, [r3, #0]
24006c56:	0c1b      	lsrs	r3, r3, #16
24006c58:	f003 0303 	and.w	r3, r3, #3
24006c5c:	61fb      	str	r3, [r7, #28]
  linepos = (hexti->Line & EXTI_PIN_MASK);
24006c5e:	687b      	ldr	r3, [r7, #4]
24006c60:	681b      	ldr	r3, [r3, #0]
24006c62:	f003 031f 	and.w	r3, r3, #31
24006c66:	61bb      	str	r3, [r7, #24]
  maskline = (1UL << linepos);
24006c68:	2201      	movs	r2, #1
24006c6a:	69bb      	ldr	r3, [r7, #24]
24006c6c:	fa02 f303 	lsl.w	r3, r2, r3
24006c70:	617b      	str	r3, [r7, #20]
  {
    /* Get pending register address */
    regaddr = (__IO uint32_t *)(&EXTI->C2PR1 + (EXTI_MODE_OFFSET * offset));
  }
#else
  regaddr = (__IO uint32_t *)(&EXTI->PR1 + (EXTI_MODE_OFFSET * offset));
24006c72:	69fb      	ldr	r3, [r7, #28]
24006c74:	011a      	lsls	r2, r3, #4
24006c76:	4b09      	ldr	r3, [pc, #36]	; (24006c9c <HAL_EXTI_GetPending+0x54>)
24006c78:	4413      	add	r3, r2
24006c7a:	613b      	str	r3, [r7, #16]
#endif /* DUAL_CORE */

  /* return 1 if bit is set else 0 */
  regval = ((*regaddr & maskline) >> linepos);
24006c7c:	693b      	ldr	r3, [r7, #16]
24006c7e:	681a      	ldr	r2, [r3, #0]
24006c80:	697b      	ldr	r3, [r7, #20]
24006c82:	401a      	ands	r2, r3
24006c84:	69bb      	ldr	r3, [r7, #24]
24006c86:	fa22 f303 	lsr.w	r3, r2, r3
24006c8a:	60fb      	str	r3, [r7, #12]
  return regval;
24006c8c:	68fb      	ldr	r3, [r7, #12]
}
24006c8e:	4618      	mov	r0, r3
24006c90:	3724      	adds	r7, #36	; 0x24
24006c92:	46bd      	mov	sp, r7
24006c94:	f85d 7b04 	ldr.w	r7, [sp], #4
24006c98:	4770      	bx	lr
24006c9a:	bf00      	nop
24006c9c:	58000088 	.word	0x58000088

24006ca0 <HAL_EXTI_ClearPending>:
  *           @arg @ref EXTI_TRIGGER_RISING_FALLING
  *         This parameter is kept for compatibility with other series.
  * @retval None.
  */
void HAL_EXTI_ClearPending(EXTI_HandleTypeDef *hexti, uint32_t Edge)
{
24006ca0:	b480      	push	{r7}
24006ca2:	b087      	sub	sp, #28
24006ca4:	af00      	add	r7, sp, #0
24006ca6:	6078      	str	r0, [r7, #4]
24006ca8:	6039      	str	r1, [r7, #0]
  assert_param(IS_EXTI_LINE(hexti->Line));
  assert_param(IS_EXTI_CONFIG_LINE(hexti->Line));
  assert_param(IS_EXTI_PENDING_EDGE(Edge));

  /* compute line register offset and line mask */
  offset = ((hexti->Line & EXTI_REG_MASK) >> EXTI_REG_SHIFT);
24006caa:	687b      	ldr	r3, [r7, #4]
24006cac:	681b      	ldr	r3, [r3, #0]
24006cae:	0c1b      	lsrs	r3, r3, #16
24006cb0:	f003 0303 	and.w	r3, r3, #3
24006cb4:	617b      	str	r3, [r7, #20]
  maskline = (1UL << (hexti->Line & EXTI_PIN_MASK));
24006cb6:	687b      	ldr	r3, [r7, #4]
24006cb8:	681b      	ldr	r3, [r3, #0]
24006cba:	f003 031f 	and.w	r3, r3, #31
24006cbe:	2201      	movs	r2, #1
24006cc0:	fa02 f303 	lsl.w	r3, r2, r3
24006cc4:	613b      	str	r3, [r7, #16]
  {
    /* Get pending register address */
    regaddr = (__IO uint32_t *)(&EXTI->C2PR1 + (EXTI_MODE_OFFSET * offset));
  }
#else
  regaddr = (__IO uint32_t *)(&EXTI->PR1 + (EXTI_MODE_OFFSET * offset));
24006cc6:	697b      	ldr	r3, [r7, #20]
24006cc8:	011a      	lsls	r2, r3, #4
24006cca:	4b06      	ldr	r3, [pc, #24]	; (24006ce4 <HAL_EXTI_ClearPending+0x44>)
24006ccc:	4413      	add	r3, r2
24006cce:	60fb      	str	r3, [r7, #12]
#endif /* DUAL_CORE */

  /* Clear Pending bit */
  *regaddr =  maskline;
24006cd0:	68fb      	ldr	r3, [r7, #12]
24006cd2:	693a      	ldr	r2, [r7, #16]
24006cd4:	601a      	str	r2, [r3, #0]
}
24006cd6:	bf00      	nop
24006cd8:	371c      	adds	r7, #28
24006cda:	46bd      	mov	sp, r7
24006cdc:	f85d 7b04 	ldr.w	r7, [sp], #4
24006ce0:	4770      	bx	lr
24006ce2:	bf00      	nop
24006ce4:	58000088 	.word	0x58000088

24006ce8 <HAL_EXTI_GenerateSWI>:
  * @brief  Generate a software interrupt for a dedicated line.
  * @param  hexti Exti handle.
  * @retval None.
  */
void HAL_EXTI_GenerateSWI(EXTI_HandleTypeDef *hexti)
{
24006ce8:	b480      	push	{r7}
24006cea:	b087      	sub	sp, #28
24006cec:	af00      	add	r7, sp, #0
24006cee:	6078      	str	r0, [r7, #4]
  /* Check parameters */
  assert_param(IS_EXTI_LINE(hexti->Line));
  assert_param(IS_EXTI_CONFIG_LINE(hexti->Line));

  /* compute line register offset and line mask */
  offset = ((hexti->Line & EXTI_REG_MASK) >> EXTI_REG_SHIFT);
24006cf0:	687b      	ldr	r3, [r7, #4]
24006cf2:	681b      	ldr	r3, [r3, #0]
24006cf4:	0c1b      	lsrs	r3, r3, #16
24006cf6:	f003 0303 	and.w	r3, r3, #3
24006cfa:	617b      	str	r3, [r7, #20]
  maskline = (1UL << (hexti->Line & EXTI_PIN_MASK));
24006cfc:	687b      	ldr	r3, [r7, #4]
24006cfe:	681b      	ldr	r3, [r3, #0]
24006d00:	f003 031f 	and.w	r3, r3, #31
24006d04:	2201      	movs	r2, #1
24006d06:	fa02 f303 	lsl.w	r3, r2, r3
24006d0a:	613b      	str	r3, [r7, #16]

  regaddr = (__IO uint32_t *)(&EXTI->SWIER1 + (EXTI_CONFIG_OFFSET * offset));
24006d0c:	697b      	ldr	r3, [r7, #20]
24006d0e:	015a      	lsls	r2, r3, #5
24006d10:	4b05      	ldr	r3, [pc, #20]	; (24006d28 <HAL_EXTI_GenerateSWI+0x40>)
24006d12:	4413      	add	r3, r2
24006d14:	60fb      	str	r3, [r7, #12]
  *regaddr = maskline;
24006d16:	68fb      	ldr	r3, [r7, #12]
24006d18:	693a      	ldr	r2, [r7, #16]
24006d1a:	601a      	str	r2, [r3, #0]
}
24006d1c:	bf00      	nop
24006d1e:	371c      	adds	r7, #28
24006d20:	46bd      	mov	sp, r7
24006d22:	f85d 7b04 	ldr.w	r7, [sp], #4
24006d26:	4770      	bx	lr
24006d28:	58000008 	.word	0x58000008

24006d2c <HAL_FLASH_Program>:
  * @param  DataAddress specifies the address of data to be programmed
  *
  * @retval HAL_StatusTypeDef HAL Status
  */
HAL_StatusTypeDef HAL_FLASH_Program(uint32_t TypeProgram, uint32_t FlashAddress, uint32_t DataAddress)
{
24006d2c:	b580      	push	{r7, lr}
24006d2e:	b08a      	sub	sp, #40	; 0x28
24006d30:	af00      	add	r7, sp, #0
24006d32:	60f8      	str	r0, [r7, #12]
24006d34:	60b9      	str	r1, [r7, #8]
24006d36:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status;
  __IO uint32_t *dest_addr = (__IO uint32_t *)FlashAddress;
24006d38:	68bb      	ldr	r3, [r7, #8]
24006d3a:	623b      	str	r3, [r7, #32]
  __IO uint32_t *src_addr = (__IO uint32_t*)DataAddress;
24006d3c:	687b      	ldr	r3, [r7, #4]
24006d3e:	61fb      	str	r3, [r7, #28]
  uint32_t bank;
  uint8_t row_index = FLASH_NB_32BITWORD_IN_FLASHWORD;
24006d40:	2308      	movs	r3, #8
24006d42:	75fb      	strb	r3, [r7, #23]
  /* Check the parameters */
  assert_param(IS_FLASH_TYPEPROGRAM(TypeProgram));
  assert_param(IS_FLASH_PROGRAM_ADDRESS(FlashAddress));

  /* Process Locked */
  __HAL_LOCK(&pFlash);
24006d44:	4b38      	ldr	r3, [pc, #224]	; (24006e28 <HAL_FLASH_Program+0xfc>)
24006d46:	7d1b      	ldrb	r3, [r3, #20]
24006d48:	2b01      	cmp	r3, #1
24006d4a:	d101      	bne.n	24006d50 <HAL_FLASH_Program+0x24>
24006d4c:	2302      	movs	r3, #2
24006d4e:	e067      	b.n	24006e20 <HAL_FLASH_Program+0xf4>
24006d50:	4b35      	ldr	r3, [pc, #212]	; (24006e28 <HAL_FLASH_Program+0xfc>)
24006d52:	2201      	movs	r2, #1
24006d54:	751a      	strb	r2, [r3, #20]

#if defined (FLASH_OPTCR_PG_OTP)
  if((IS_FLASH_PROGRAM_ADDRESS_BANK1(FlashAddress)) || (IS_FLASH_PROGRAM_ADDRESS_OTP(FlashAddress)))
#else
  if(IS_FLASH_PROGRAM_ADDRESS_BANK1(FlashAddress))
24006d56:	68bb      	ldr	r3, [r7, #8]
24006d58:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
24006d5c:	d306      	bcc.n	24006d6c <HAL_FLASH_Program+0x40>
24006d5e:	68bb      	ldr	r3, [r7, #8]
24006d60:	f1b3 6f01 	cmp.w	r3, #135266304	; 0x8100000
24006d64:	d202      	bcs.n	24006d6c <HAL_FLASH_Program+0x40>
#endif /* FLASH_OPTCR_PG_OTP */
  {
    bank = FLASH_BANK_1;
24006d66:	2301      	movs	r3, #1
24006d68:	61bb      	str	r3, [r7, #24]
24006d6a:	e001      	b.n	24006d70 <HAL_FLASH_Program+0x44>
  }
  else
  {
    bank = FLASH_BANK_2;
24006d6c:	2302      	movs	r3, #2
24006d6e:	61bb      	str	r3, [r7, #24]
  }

  /* Reset error code */
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
24006d70:	4b2d      	ldr	r3, [pc, #180]	; (24006e28 <HAL_FLASH_Program+0xfc>)
24006d72:	2200      	movs	r2, #0
24006d74:	619a      	str	r2, [r3, #24]

  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, bank);
24006d76:	69b9      	ldr	r1, [r7, #24]
24006d78:	f24c 3050 	movw	r0, #50000	; 0xc350
24006d7c:	f000 fb20 	bl	240073c0 <FLASH_WaitForLastOperation>
24006d80:	4603      	mov	r3, r0
24006d82:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27

  if(status == HAL_OK)
24006d86:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
24006d8a:	2b00      	cmp	r3, #0
24006d8c:	d143      	bne.n	24006e16 <HAL_FLASH_Program+0xea>
  {
    if(bank == FLASH_BANK_1)
24006d8e:	69bb      	ldr	r3, [r7, #24]
24006d90:	2b01      	cmp	r3, #1
24006d92:	d106      	bne.n	24006da2 <HAL_FLASH_Program+0x76>
      }
      else
#endif /* FLASH_OPTCR_PG_OTP */
      {
        /* Set PG bit */
        SET_BIT(FLASH->CR1, FLASH_CR_PG);
24006d94:	4b25      	ldr	r3, [pc, #148]	; (24006e2c <HAL_FLASH_Program+0x100>)
24006d96:	68db      	ldr	r3, [r3, #12]
24006d98:	4a24      	ldr	r2, [pc, #144]	; (24006e2c <HAL_FLASH_Program+0x100>)
24006d9a:	f043 0302 	orr.w	r3, r3, #2
24006d9e:	60d3      	str	r3, [r2, #12]
24006da0:	e007      	b.n	24006db2 <HAL_FLASH_Program+0x86>
      }
    }
    else
    {
      /* Set PG bit */
      SET_BIT(FLASH->CR2, FLASH_CR_PG);
24006da2:	4b22      	ldr	r3, [pc, #136]	; (24006e2c <HAL_FLASH_Program+0x100>)
24006da4:	f8d3 310c 	ldr.w	r3, [r3, #268]	; 0x10c
24006da8:	4a20      	ldr	r2, [pc, #128]	; (24006e2c <HAL_FLASH_Program+0x100>)
24006daa:	f043 0302 	orr.w	r3, r3, #2
24006dae:	f8c2 310c 	str.w	r3, [r2, #268]	; 0x10c
24006db2:	f3bf 8f6f 	isb	sy
  __ASM volatile ("dsb 0xF":::"memory");
24006db6:	f3bf 8f4f 	dsb	sy
#endif /* FLASH_OPTCR_PG_OTP */
    {
      /* Program the flash word */
      do
      {
        *dest_addr = *src_addr;
24006dba:	69fb      	ldr	r3, [r7, #28]
24006dbc:	681a      	ldr	r2, [r3, #0]
24006dbe:	6a3b      	ldr	r3, [r7, #32]
24006dc0:	601a      	str	r2, [r3, #0]
        dest_addr++;
24006dc2:	6a3b      	ldr	r3, [r7, #32]
24006dc4:	3304      	adds	r3, #4
24006dc6:	623b      	str	r3, [r7, #32]
        src_addr++;
24006dc8:	69fb      	ldr	r3, [r7, #28]
24006dca:	3304      	adds	r3, #4
24006dcc:	61fb      	str	r3, [r7, #28]
        row_index--;
24006dce:	7dfb      	ldrb	r3, [r7, #23]
24006dd0:	3b01      	subs	r3, #1
24006dd2:	75fb      	strb	r3, [r7, #23]
     } while (row_index != 0U);
24006dd4:	7dfb      	ldrb	r3, [r7, #23]
24006dd6:	2b00      	cmp	r3, #0
24006dd8:	d1ef      	bne.n	24006dba <HAL_FLASH_Program+0x8e>
  __ASM volatile ("isb 0xF":::"memory");
24006dda:	f3bf 8f6f 	isb	sy
  __ASM volatile ("dsb 0xF":::"memory");
24006dde:	f3bf 8f4f 	dsb	sy

    __ISB();
    __DSB();

    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, bank);
24006de2:	69b9      	ldr	r1, [r7, #24]
24006de4:	f24c 3050 	movw	r0, #50000	; 0xc350
24006de8:	f000 faea 	bl	240073c0 <FLASH_WaitForLastOperation>
24006dec:	4603      	mov	r3, r0
24006dee:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
      CLEAR_BIT(FLASH->OPTCR, FLASH_OPTCR_PG_OTP);
    }
    else
#endif /* FLASH_OPTCR_PG_OTP */
    {
      if(bank == FLASH_BANK_1)
24006df2:	69bb      	ldr	r3, [r7, #24]
24006df4:	2b01      	cmp	r3, #1
24006df6:	d106      	bne.n	24006e06 <HAL_FLASH_Program+0xda>
      {
        /* If the program operation is completed, disable the PG */
        CLEAR_BIT(FLASH->CR1, FLASH_CR_PG);
24006df8:	4b0c      	ldr	r3, [pc, #48]	; (24006e2c <HAL_FLASH_Program+0x100>)
24006dfa:	68db      	ldr	r3, [r3, #12]
24006dfc:	4a0b      	ldr	r2, [pc, #44]	; (24006e2c <HAL_FLASH_Program+0x100>)
24006dfe:	f023 0302 	bic.w	r3, r3, #2
24006e02:	60d3      	str	r3, [r2, #12]
24006e04:	e007      	b.n	24006e16 <HAL_FLASH_Program+0xea>
      }
      else
      {
        /* If the program operation is completed, disable the PG */
        CLEAR_BIT(FLASH->CR2, FLASH_CR_PG);
24006e06:	4b09      	ldr	r3, [pc, #36]	; (24006e2c <HAL_FLASH_Program+0x100>)
24006e08:	f8d3 310c 	ldr.w	r3, [r3, #268]	; 0x10c
24006e0c:	4a07      	ldr	r2, [pc, #28]	; (24006e2c <HAL_FLASH_Program+0x100>)
24006e0e:	f023 0302 	bic.w	r3, r3, #2
24006e12:	f8c2 310c 	str.w	r3, [r2, #268]	; 0x10c
      }
    }
  }

  /* Process Unlocked */
  __HAL_UNLOCK(&pFlash);
24006e16:	4b04      	ldr	r3, [pc, #16]	; (24006e28 <HAL_FLASH_Program+0xfc>)
24006e18:	2200      	movs	r2, #0
24006e1a:	751a      	strb	r2, [r3, #20]

  return status;
24006e1c:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
}
24006e20:	4618      	mov	r0, r3
24006e22:	3728      	adds	r7, #40	; 0x28
24006e24:	46bd      	mov	sp, r7
24006e26:	bd80      	pop	{r7, pc}
24006e28:	24000548 	.word	0x24000548
24006e2c:	52002000 	.word	0x52002000

24006e30 <HAL_FLASH_Program_IT>:
  * @param  DataAddress specifies the address of data (256 bits) to be programmed
  *
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASH_Program_IT(uint32_t TypeProgram, uint32_t FlashAddress, uint32_t DataAddress)
{
24006e30:	b580      	push	{r7, lr}
24006e32:	b088      	sub	sp, #32
24006e34:	af00      	add	r7, sp, #0
24006e36:	60f8      	str	r0, [r7, #12]
24006e38:	60b9      	str	r1, [r7, #8]
24006e3a:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status;
  __IO uint32_t *dest_addr = (__IO uint32_t*)FlashAddress;
24006e3c:	68bb      	ldr	r3, [r7, #8]
24006e3e:	61fb      	str	r3, [r7, #28]
  __IO uint32_t *src_addr = (__IO uint32_t*)DataAddress;
24006e40:	687b      	ldr	r3, [r7, #4]
24006e42:	61bb      	str	r3, [r7, #24]
  uint32_t bank;
  uint8_t row_index = FLASH_NB_32BITWORD_IN_FLASHWORD;
24006e44:	2308      	movs	r3, #8
24006e46:	74fb      	strb	r3, [r7, #19]
  /* Check the parameters */
  assert_param(IS_FLASH_TYPEPROGRAM(TypeProgram));
  assert_param(IS_FLASH_PROGRAM_ADDRESS(FlashAddress));

  /* Process Locked */
  __HAL_LOCK(&pFlash);
24006e48:	4b36      	ldr	r3, [pc, #216]	; (24006f24 <HAL_FLASH_Program_IT+0xf4>)
24006e4a:	7d1b      	ldrb	r3, [r3, #20]
24006e4c:	2b01      	cmp	r3, #1
24006e4e:	d101      	bne.n	24006e54 <HAL_FLASH_Program_IT+0x24>
24006e50:	2302      	movs	r3, #2
24006e52:	e062      	b.n	24006f1a <HAL_FLASH_Program_IT+0xea>
24006e54:	4b33      	ldr	r3, [pc, #204]	; (24006f24 <HAL_FLASH_Program_IT+0xf4>)
24006e56:	2201      	movs	r2, #1
24006e58:	751a      	strb	r2, [r3, #20]

  /* Reset error code */
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
24006e5a:	4b32      	ldr	r3, [pc, #200]	; (24006f24 <HAL_FLASH_Program_IT+0xf4>)
24006e5c:	2200      	movs	r2, #0
24006e5e:	619a      	str	r2, [r3, #24]

#if defined (FLASH_OPTCR_PG_OTP)
  if((IS_FLASH_PROGRAM_ADDRESS_BANK1(FlashAddress)) || (IS_FLASH_PROGRAM_ADDRESS_OTP(FlashAddress)))
#else
  if(IS_FLASH_PROGRAM_ADDRESS_BANK1(FlashAddress))
24006e60:	68bb      	ldr	r3, [r7, #8]
24006e62:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
24006e66:	d306      	bcc.n	24006e76 <HAL_FLASH_Program_IT+0x46>
24006e68:	68bb      	ldr	r3, [r7, #8]
24006e6a:	f1b3 6f01 	cmp.w	r3, #135266304	; 0x8100000
24006e6e:	d202      	bcs.n	24006e76 <HAL_FLASH_Program_IT+0x46>
#endif /* FLASH_OPTCR_PG_OTP */
  {
    bank = FLASH_BANK_1;
24006e70:	2301      	movs	r3, #1
24006e72:	617b      	str	r3, [r7, #20]
24006e74:	e001      	b.n	24006e7a <HAL_FLASH_Program_IT+0x4a>
  }
  else
  {
    bank = FLASH_BANK_2;
24006e76:	2302      	movs	r3, #2
24006e78:	617b      	str	r3, [r7, #20]
  }

  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, bank);
24006e7a:	6979      	ldr	r1, [r7, #20]
24006e7c:	f24c 3050 	movw	r0, #50000	; 0xc350
24006e80:	f000 fa9e 	bl	240073c0 <FLASH_WaitForLastOperation>
24006e84:	4603      	mov	r3, r0
24006e86:	74bb      	strb	r3, [r7, #18]

  if (status != HAL_OK)
24006e88:	7cbb      	ldrb	r3, [r7, #18]
24006e8a:	2b00      	cmp	r3, #0
24006e8c:	d003      	beq.n	24006e96 <HAL_FLASH_Program_IT+0x66>
  {
    /* Process Unlocked */
    __HAL_UNLOCK(&pFlash);
24006e8e:	4b25      	ldr	r3, [pc, #148]	; (24006f24 <HAL_FLASH_Program_IT+0xf4>)
24006e90:	2200      	movs	r2, #0
24006e92:	751a      	strb	r2, [r3, #20]
24006e94:	e040      	b.n	24006f18 <HAL_FLASH_Program_IT+0xe8>
  }
  else
  {
    pFlash.Address = FlashAddress;
24006e96:	4a23      	ldr	r2, [pc, #140]	; (24006f24 <HAL_FLASH_Program_IT+0xf4>)
24006e98:	68bb      	ldr	r3, [r7, #8]
24006e9a:	6113      	str	r3, [r2, #16]

    if(bank == FLASH_BANK_1)
24006e9c:	697b      	ldr	r3, [r7, #20]
24006e9e:	2b01      	cmp	r3, #1
24006ea0:	d10f      	bne.n	24006ec2 <HAL_FLASH_Program_IT+0x92>
    {
      /* Set internal variables used by the IRQ handler */
      pFlash.ProcedureOnGoing = FLASH_PROC_PROGRAM_BANK1;
24006ea2:	4b20      	ldr	r3, [pc, #128]	; (24006f24 <HAL_FLASH_Program_IT+0xf4>)
24006ea4:	2203      	movs	r2, #3
24006ea6:	701a      	strb	r2, [r3, #0]
      }
      else
#endif /* FLASH_OPTCR_PG_OTP */
      {
        /* Set PG bit */
        SET_BIT(FLASH->CR1, FLASH_CR_PG);
24006ea8:	4b1f      	ldr	r3, [pc, #124]	; (24006f28 <HAL_FLASH_Program_IT+0xf8>)
24006eaa:	68db      	ldr	r3, [r3, #12]
24006eac:	4a1e      	ldr	r2, [pc, #120]	; (24006f28 <HAL_FLASH_Program_IT+0xf8>)
24006eae:	f043 0302 	orr.w	r3, r3, #2
24006eb2:	60d3      	str	r3, [r2, #12]
      }

      /* Enable End of Operation and Error interrupts for Bank 1 */
#if defined (FLASH_CR_OPERRIE)
      __HAL_FLASH_ENABLE_IT_BANK1(FLASH_IT_EOP_BANK1     | FLASH_IT_WRPERR_BANK1 | FLASH_IT_PGSERR_BANK1 | \
24006eb4:	4b1c      	ldr	r3, [pc, #112]	; (24006f28 <HAL_FLASH_Program_IT+0xf8>)
24006eb6:	68db      	ldr	r3, [r3, #12]
24006eb8:	4a1b      	ldr	r2, [pc, #108]	; (24006f28 <HAL_FLASH_Program_IT+0xf8>)
24006eba:	f443 03de 	orr.w	r3, r3, #7274496	; 0x6f0000
24006ebe:	60d3      	str	r3, [r2, #12]
24006ec0:	e012      	b.n	24006ee8 <HAL_FLASH_Program_IT+0xb8>
#endif /* FLASH_CR_OPERRIE */
    }
    else
    {
      /* Set internal variables used by the IRQ handler */
      pFlash.ProcedureOnGoing = FLASH_PROC_PROGRAM_BANK2;
24006ec2:	4b18      	ldr	r3, [pc, #96]	; (24006f24 <HAL_FLASH_Program_IT+0xf4>)
24006ec4:	2206      	movs	r2, #6
24006ec6:	701a      	strb	r2, [r3, #0]

      /* Set PG bit */
      SET_BIT(FLASH->CR2, FLASH_CR_PG);
24006ec8:	4b17      	ldr	r3, [pc, #92]	; (24006f28 <HAL_FLASH_Program_IT+0xf8>)
24006eca:	f8d3 310c 	ldr.w	r3, [r3, #268]	; 0x10c
24006ece:	4a16      	ldr	r2, [pc, #88]	; (24006f28 <HAL_FLASH_Program_IT+0xf8>)
24006ed0:	f043 0302 	orr.w	r3, r3, #2
24006ed4:	f8c2 310c 	str.w	r3, [r2, #268]	; 0x10c

      /* Enable End of Operation and Error interrupts for Bank2 */
#if defined (FLASH_CR_OPERRIE)
      __HAL_FLASH_ENABLE_IT_BANK2(FLASH_IT_EOP_BANK2     | FLASH_IT_WRPERR_BANK2 | FLASH_IT_PGSERR_BANK2 | \
24006ed8:	4b13      	ldr	r3, [pc, #76]	; (24006f28 <HAL_FLASH_Program_IT+0xf8>)
24006eda:	f8d3 310c 	ldr.w	r3, [r3, #268]	; 0x10c
24006ede:	4a12      	ldr	r2, [pc, #72]	; (24006f28 <HAL_FLASH_Program_IT+0xf8>)
24006ee0:	f443 03de 	orr.w	r3, r3, #7274496	; 0x6f0000
24006ee4:	f8c2 310c 	str.w	r3, [r2, #268]	; 0x10c
  __ASM volatile ("isb 0xF":::"memory");
24006ee8:	f3bf 8f6f 	isb	sy
  __ASM volatile ("dsb 0xF":::"memory");
24006eec:	f3bf 8f4f 	dsb	sy
#endif /* FLASH_OPTCR_PG_OTP */
    {
      /* Program the flash word */
      do
      {
        *dest_addr = *src_addr;
24006ef0:	69bb      	ldr	r3, [r7, #24]
24006ef2:	681a      	ldr	r2, [r3, #0]
24006ef4:	69fb      	ldr	r3, [r7, #28]
24006ef6:	601a      	str	r2, [r3, #0]
        dest_addr++;
24006ef8:	69fb      	ldr	r3, [r7, #28]
24006efa:	3304      	adds	r3, #4
24006efc:	61fb      	str	r3, [r7, #28]
        src_addr++;
24006efe:	69bb      	ldr	r3, [r7, #24]
24006f00:	3304      	adds	r3, #4
24006f02:	61bb      	str	r3, [r7, #24]
        row_index--;
24006f04:	7cfb      	ldrb	r3, [r7, #19]
24006f06:	3b01      	subs	r3, #1
24006f08:	74fb      	strb	r3, [r7, #19]
      } while (row_index != 0U);
24006f0a:	7cfb      	ldrb	r3, [r7, #19]
24006f0c:	2b00      	cmp	r3, #0
24006f0e:	d1ef      	bne.n	24006ef0 <HAL_FLASH_Program_IT+0xc0>
  __ASM volatile ("isb 0xF":::"memory");
24006f10:	f3bf 8f6f 	isb	sy
  __ASM volatile ("dsb 0xF":::"memory");
24006f14:	f3bf 8f4f 	dsb	sy

    __ISB();
    __DSB();
  }

  return status;
24006f18:	7cbb      	ldrb	r3, [r7, #18]
}
24006f1a:	4618      	mov	r0, r3
24006f1c:	3720      	adds	r7, #32
24006f1e:	46bd      	mov	sp, r7
24006f20:	bd80      	pop	{r7, pc}
24006f22:	bf00      	nop
24006f24:	24000548 	.word	0x24000548
24006f28:	52002000 	.word	0x52002000

24006f2c <HAL_FLASH_IRQHandler>:
/**
  * @brief This function handles FLASH interrupt request.
  * @retval None
  */
void HAL_FLASH_IRQHandler(void)
{
24006f2c:	b580      	push	{r7, lr}
24006f2e:	b084      	sub	sp, #16
24006f30:	af00      	add	r7, sp, #0
  uint32_t temp;
  uint32_t errorflag;
  FLASH_ProcedureTypeDef procedure;

  /* Check FLASH Bank1 End of Operation flag  */
  if(__HAL_FLASH_GET_FLAG_BANK1(FLASH_SR_EOP) != RESET)
24006f32:	4b95      	ldr	r3, [pc, #596]	; (24007188 <HAL_FLASH_IRQHandler+0x25c>)
24006f34:	691b      	ldr	r3, [r3, #16]
24006f36:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
24006f3a:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
24006f3e:	d15c      	bne.n	24006ffa <HAL_FLASH_IRQHandler+0xce>
  {
    if(pFlash.ProcedureOnGoing == FLASH_PROC_SECTERASE_BANK1)
24006f40:	4b92      	ldr	r3, [pc, #584]	; (2400718c <HAL_FLASH_IRQHandler+0x260>)
24006f42:	781b      	ldrb	r3, [r3, #0]
24006f44:	b2db      	uxtb	r3, r3
24006f46:	2b01      	cmp	r3, #1
24006f48:	d132      	bne.n	24006fb0 <HAL_FLASH_IRQHandler+0x84>
    {
      /* Nb of sector to erased can be decreased */
      pFlash.NbSectorsToErase--;
24006f4a:	4b90      	ldr	r3, [pc, #576]	; (2400718c <HAL_FLASH_IRQHandler+0x260>)
24006f4c:	685b      	ldr	r3, [r3, #4]
24006f4e:	3b01      	subs	r3, #1
24006f50:	4a8e      	ldr	r2, [pc, #568]	; (2400718c <HAL_FLASH_IRQHandler+0x260>)
24006f52:	6053      	str	r3, [r2, #4]

      /* Check if there are still sectors to erase */
      if(pFlash.NbSectorsToErase != 0U)
24006f54:	4b8d      	ldr	r3, [pc, #564]	; (2400718c <HAL_FLASH_IRQHandler+0x260>)
24006f56:	685b      	ldr	r3, [r3, #4]
24006f58:	2b00      	cmp	r3, #0
24006f5a:	d018      	beq.n	24006f8e <HAL_FLASH_IRQHandler+0x62>
      {
        /* Indicate user which sector has been erased */
        HAL_FLASH_EndOfOperationCallback(pFlash.Sector);
24006f5c:	4b8b      	ldr	r3, [pc, #556]	; (2400718c <HAL_FLASH_IRQHandler+0x260>)
24006f5e:	68db      	ldr	r3, [r3, #12]
24006f60:	4618      	mov	r0, r3
24006f62:	f000 f93d 	bl	240071e0 <HAL_FLASH_EndOfOperationCallback>

        /* Clear bank 1 End of Operation pending bit */
        __HAL_FLASH_CLEAR_FLAG_BANK1(FLASH_FLAG_EOP_BANK1);
24006f66:	4b88      	ldr	r3, [pc, #544]	; (24007188 <HAL_FLASH_IRQHandler+0x25c>)
24006f68:	f44f 3280 	mov.w	r2, #65536	; 0x10000
24006f6c:	615a      	str	r2, [r3, #20]

        /* Increment sector number */
        pFlash.Sector++;
24006f6e:	4b87      	ldr	r3, [pc, #540]	; (2400718c <HAL_FLASH_IRQHandler+0x260>)
24006f70:	68db      	ldr	r3, [r3, #12]
24006f72:	3301      	adds	r3, #1
24006f74:	4a85      	ldr	r2, [pc, #532]	; (2400718c <HAL_FLASH_IRQHandler+0x260>)
24006f76:	60d3      	str	r3, [r2, #12]
        temp = pFlash.Sector;
24006f78:	4b84      	ldr	r3, [pc, #528]	; (2400718c <HAL_FLASH_IRQHandler+0x260>)
24006f7a:	68db      	ldr	r3, [r3, #12]
24006f7c:	60fb      	str	r3, [r7, #12]
        FLASH_Erase_Sector(temp, FLASH_BANK_1, pFlash.VoltageForErase);
24006f7e:	4b83      	ldr	r3, [pc, #524]	; (2400718c <HAL_FLASH_IRQHandler+0x260>)
24006f80:	689b      	ldr	r3, [r3, #8]
24006f82:	461a      	mov	r2, r3
24006f84:	2101      	movs	r1, #1
24006f86:	68f8      	ldr	r0, [r7, #12]
24006f88:	f000 ff9e 	bl	24007ec8 <FLASH_Erase_Sector>
24006f8c:	e035      	b.n	24006ffa <HAL_FLASH_IRQHandler+0xce>
      }
      else
      {
        /* No more sectors to Erase, user callback can be called */
        /* Reset Sector and stop Erase sectors procedure */
        pFlash.Sector = 0xFFFFFFFFU;
24006f8e:	4b7f      	ldr	r3, [pc, #508]	; (2400718c <HAL_FLASH_IRQHandler+0x260>)
24006f90:	f04f 32ff 	mov.w	r2, #4294967295
24006f94:	60da      	str	r2, [r3, #12]
        pFlash.ProcedureOnGoing = FLASH_PROC_NONE;
24006f96:	4b7d      	ldr	r3, [pc, #500]	; (2400718c <HAL_FLASH_IRQHandler+0x260>)
24006f98:	2200      	movs	r2, #0
24006f9a:	701a      	strb	r2, [r3, #0]

        /* FLASH EOP interrupt user callback */
        HAL_FLASH_EndOfOperationCallback(pFlash.Sector);
24006f9c:	4b7b      	ldr	r3, [pc, #492]	; (2400718c <HAL_FLASH_IRQHandler+0x260>)
24006f9e:	68db      	ldr	r3, [r3, #12]
24006fa0:	4618      	mov	r0, r3
24006fa2:	f000 f91d 	bl	240071e0 <HAL_FLASH_EndOfOperationCallback>

        /* Clear FLASH End of Operation pending bit */
        __HAL_FLASH_CLEAR_FLAG_BANK1(FLASH_FLAG_EOP_BANK1);
24006fa6:	4b78      	ldr	r3, [pc, #480]	; (24007188 <HAL_FLASH_IRQHandler+0x25c>)
24006fa8:	f44f 3280 	mov.w	r2, #65536	; 0x10000
24006fac:	615a      	str	r2, [r3, #20]
24006fae:	e024      	b.n	24006ffa <HAL_FLASH_IRQHandler+0xce>
      }
    }
    else
    {
      procedure = pFlash.ProcedureOnGoing;
24006fb0:	4b76      	ldr	r3, [pc, #472]	; (2400718c <HAL_FLASH_IRQHandler+0x260>)
24006fb2:	781b      	ldrb	r3, [r3, #0]
24006fb4:	72fb      	strb	r3, [r7, #11]

      if((procedure == FLASH_PROC_MASSERASE_BANK1) || (procedure == FLASH_PROC_ALLBANK_MASSERASE))
24006fb6:	7afb      	ldrb	r3, [r7, #11]
24006fb8:	2b02      	cmp	r3, #2
24006fba:	d002      	beq.n	24006fc2 <HAL_FLASH_IRQHandler+0x96>
24006fbc:	7afb      	ldrb	r3, [r7, #11]
24006fbe:	2b07      	cmp	r3, #7
24006fc0:	d103      	bne.n	24006fca <HAL_FLASH_IRQHandler+0x9e>
      {
        /* MassErase ended. Return the selected bank */
        /* FLASH EOP interrupt user callback */
        HAL_FLASH_EndOfOperationCallback(FLASH_BANK_1);
24006fc2:	2001      	movs	r0, #1
24006fc4:	f000 f90c 	bl	240071e0 <HAL_FLASH_EndOfOperationCallback>
24006fc8:	e007      	b.n	24006fda <HAL_FLASH_IRQHandler+0xae>
      }
      else if(procedure == FLASH_PROC_PROGRAM_BANK1)
24006fca:	7afb      	ldrb	r3, [r7, #11]
24006fcc:	2b03      	cmp	r3, #3
24006fce:	d104      	bne.n	24006fda <HAL_FLASH_IRQHandler+0xae>
      {
        /* Program ended. Return the selected address */
        /* FLASH EOP interrupt user callback */
        HAL_FLASH_EndOfOperationCallback(pFlash.Address);
24006fd0:	4b6e      	ldr	r3, [pc, #440]	; (2400718c <HAL_FLASH_IRQHandler+0x260>)
24006fd2:	691b      	ldr	r3, [r3, #16]
24006fd4:	4618      	mov	r0, r3
24006fd6:	f000 f903 	bl	240071e0 <HAL_FLASH_EndOfOperationCallback>
      else
      {
        /* Nothing to do */
      }

      if((procedure != FLASH_PROC_SECTERASE_BANK2) && \
24006fda:	7afb      	ldrb	r3, [r7, #11]
24006fdc:	2b04      	cmp	r3, #4
24006fde:	d00c      	beq.n	24006ffa <HAL_FLASH_IRQHandler+0xce>
24006fe0:	7afb      	ldrb	r3, [r7, #11]
24006fe2:	2b05      	cmp	r3, #5
24006fe4:	d009      	beq.n	24006ffa <HAL_FLASH_IRQHandler+0xce>
         (procedure != FLASH_PROC_MASSERASE_BANK2) && \
24006fe6:	7afb      	ldrb	r3, [r7, #11]
24006fe8:	2b06      	cmp	r3, #6
24006fea:	d006      	beq.n	24006ffa <HAL_FLASH_IRQHandler+0xce>
         (procedure != FLASH_PROC_PROGRAM_BANK2))
      {
        pFlash.ProcedureOnGoing = FLASH_PROC_NONE;
24006fec:	4b67      	ldr	r3, [pc, #412]	; (2400718c <HAL_FLASH_IRQHandler+0x260>)
24006fee:	2200      	movs	r2, #0
24006ff0:	701a      	strb	r2, [r3, #0]
        /* Clear FLASH End of Operation pending bit */
        __HAL_FLASH_CLEAR_FLAG_BANK1(FLASH_FLAG_EOP_BANK1);
24006ff2:	4b65      	ldr	r3, [pc, #404]	; (24007188 <HAL_FLASH_IRQHandler+0x25c>)
24006ff4:	f44f 3280 	mov.w	r2, #65536	; 0x10000
24006ff8:	615a      	str	r2, [r3, #20]
      }
    }
  }

  /* Check FLASH Bank2 End of Operation flag  */
  if(__HAL_FLASH_GET_FLAG_BANK2(FLASH_SR_EOP) != RESET)
24006ffa:	4b63      	ldr	r3, [pc, #396]	; (24007188 <HAL_FLASH_IRQHandler+0x25c>)
24006ffc:	f8d3 3110 	ldr.w	r3, [r3, #272]	; 0x110
24007000:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
24007004:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
24007008:	d15f      	bne.n	240070ca <HAL_FLASH_IRQHandler+0x19e>
  {
    if(pFlash.ProcedureOnGoing == FLASH_PROC_SECTERASE_BANK2)
2400700a:	4b60      	ldr	r3, [pc, #384]	; (2400718c <HAL_FLASH_IRQHandler+0x260>)
2400700c:	781b      	ldrb	r3, [r3, #0]
2400700e:	b2db      	uxtb	r3, r3
24007010:	2b04      	cmp	r3, #4
24007012:	d134      	bne.n	2400707e <HAL_FLASH_IRQHandler+0x152>
    {
      /*Nb of sector to erased can be decreased*/
      pFlash.NbSectorsToErase--;
24007014:	4b5d      	ldr	r3, [pc, #372]	; (2400718c <HAL_FLASH_IRQHandler+0x260>)
24007016:	685b      	ldr	r3, [r3, #4]
24007018:	3b01      	subs	r3, #1
2400701a:	4a5c      	ldr	r2, [pc, #368]	; (2400718c <HAL_FLASH_IRQHandler+0x260>)
2400701c:	6053      	str	r3, [r2, #4]

      /* Check if there are still sectors to erase*/
      if(pFlash.NbSectorsToErase != 0U)
2400701e:	4b5b      	ldr	r3, [pc, #364]	; (2400718c <HAL_FLASH_IRQHandler+0x260>)
24007020:	685b      	ldr	r3, [r3, #4]
24007022:	2b00      	cmp	r3, #0
24007024:	d019      	beq.n	2400705a <HAL_FLASH_IRQHandler+0x12e>
      {
        /*Indicate user which sector has been erased*/
        HAL_FLASH_EndOfOperationCallback(pFlash.Sector);
24007026:	4b59      	ldr	r3, [pc, #356]	; (2400718c <HAL_FLASH_IRQHandler+0x260>)
24007028:	68db      	ldr	r3, [r3, #12]
2400702a:	4618      	mov	r0, r3
2400702c:	f000 f8d8 	bl	240071e0 <HAL_FLASH_EndOfOperationCallback>

        /* Clear bank 2 End of Operation pending bit */
        __HAL_FLASH_CLEAR_FLAG_BANK2(FLASH_FLAG_EOP_BANK2);
24007030:	4b55      	ldr	r3, [pc, #340]	; (24007188 <HAL_FLASH_IRQHandler+0x25c>)
24007032:	f44f 3280 	mov.w	r2, #65536	; 0x10000
24007036:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114

        /*Increment sector number*/
        pFlash.Sector++;
2400703a:	4b54      	ldr	r3, [pc, #336]	; (2400718c <HAL_FLASH_IRQHandler+0x260>)
2400703c:	68db      	ldr	r3, [r3, #12]
2400703e:	3301      	adds	r3, #1
24007040:	4a52      	ldr	r2, [pc, #328]	; (2400718c <HAL_FLASH_IRQHandler+0x260>)
24007042:	60d3      	str	r3, [r2, #12]
        temp = pFlash.Sector;
24007044:	4b51      	ldr	r3, [pc, #324]	; (2400718c <HAL_FLASH_IRQHandler+0x260>)
24007046:	68db      	ldr	r3, [r3, #12]
24007048:	60fb      	str	r3, [r7, #12]
        FLASH_Erase_Sector(temp, FLASH_BANK_2, pFlash.VoltageForErase);
2400704a:	4b50      	ldr	r3, [pc, #320]	; (2400718c <HAL_FLASH_IRQHandler+0x260>)
2400704c:	689b      	ldr	r3, [r3, #8]
2400704e:	461a      	mov	r2, r3
24007050:	2102      	movs	r1, #2
24007052:	68f8      	ldr	r0, [r7, #12]
24007054:	f000 ff38 	bl	24007ec8 <FLASH_Erase_Sector>
24007058:	e037      	b.n	240070ca <HAL_FLASH_IRQHandler+0x19e>
      }
      else
      {
        /* No more sectors to Erase, user callback can be called */
        /* Reset Sector and stop Erase sectors procedure */
        pFlash.Sector = 0xFFFFFFFFU;
2400705a:	4b4c      	ldr	r3, [pc, #304]	; (2400718c <HAL_FLASH_IRQHandler+0x260>)
2400705c:	f04f 32ff 	mov.w	r2, #4294967295
24007060:	60da      	str	r2, [r3, #12]
        pFlash.ProcedureOnGoing = FLASH_PROC_NONE;
24007062:	4b4a      	ldr	r3, [pc, #296]	; (2400718c <HAL_FLASH_IRQHandler+0x260>)
24007064:	2200      	movs	r2, #0
24007066:	701a      	strb	r2, [r3, #0]

        /* FLASH EOP interrupt user callback */
        HAL_FLASH_EndOfOperationCallback(pFlash.Sector);
24007068:	4b48      	ldr	r3, [pc, #288]	; (2400718c <HAL_FLASH_IRQHandler+0x260>)
2400706a:	68db      	ldr	r3, [r3, #12]
2400706c:	4618      	mov	r0, r3
2400706e:	f000 f8b7 	bl	240071e0 <HAL_FLASH_EndOfOperationCallback>

        /* Clear FLASH End of Operation pending bit */
        __HAL_FLASH_CLEAR_FLAG_BANK2(FLASH_FLAG_EOP_BANK2);
24007072:	4b45      	ldr	r3, [pc, #276]	; (24007188 <HAL_FLASH_IRQHandler+0x25c>)
24007074:	f44f 3280 	mov.w	r2, #65536	; 0x10000
24007078:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
2400707c:	e025      	b.n	240070ca <HAL_FLASH_IRQHandler+0x19e>
      }
    }
    else
    {
      procedure = pFlash.ProcedureOnGoing;
2400707e:	4b43      	ldr	r3, [pc, #268]	; (2400718c <HAL_FLASH_IRQHandler+0x260>)
24007080:	781b      	ldrb	r3, [r3, #0]
24007082:	72fb      	strb	r3, [r7, #11]

      if((procedure == FLASH_PROC_MASSERASE_BANK2) || (procedure == FLASH_PROC_ALLBANK_MASSERASE))
24007084:	7afb      	ldrb	r3, [r7, #11]
24007086:	2b05      	cmp	r3, #5
24007088:	d002      	beq.n	24007090 <HAL_FLASH_IRQHandler+0x164>
2400708a:	7afb      	ldrb	r3, [r7, #11]
2400708c:	2b07      	cmp	r3, #7
2400708e:	d103      	bne.n	24007098 <HAL_FLASH_IRQHandler+0x16c>
      {
        /*MassErase ended. Return the selected bank*/
        /* FLASH EOP interrupt user callback */
        HAL_FLASH_EndOfOperationCallback(FLASH_BANK_2);
24007090:	2002      	movs	r0, #2
24007092:	f000 f8a5 	bl	240071e0 <HAL_FLASH_EndOfOperationCallback>
24007096:	e007      	b.n	240070a8 <HAL_FLASH_IRQHandler+0x17c>
      }
      else if(procedure == FLASH_PROC_PROGRAM_BANK2)
24007098:	7afb      	ldrb	r3, [r7, #11]
2400709a:	2b06      	cmp	r3, #6
2400709c:	d104      	bne.n	240070a8 <HAL_FLASH_IRQHandler+0x17c>
      {
        /* Program ended. Return the selected address */
        /* FLASH EOP interrupt user callback */
        HAL_FLASH_EndOfOperationCallback(pFlash.Address);
2400709e:	4b3b      	ldr	r3, [pc, #236]	; (2400718c <HAL_FLASH_IRQHandler+0x260>)
240070a0:	691b      	ldr	r3, [r3, #16]
240070a2:	4618      	mov	r0, r3
240070a4:	f000 f89c 	bl	240071e0 <HAL_FLASH_EndOfOperationCallback>
      else
      {
        /* Nothing to do */
      }

      if((procedure != FLASH_PROC_SECTERASE_BANK1) && \
240070a8:	7afb      	ldrb	r3, [r7, #11]
240070aa:	2b01      	cmp	r3, #1
240070ac:	d00d      	beq.n	240070ca <HAL_FLASH_IRQHandler+0x19e>
240070ae:	7afb      	ldrb	r3, [r7, #11]
240070b0:	2b02      	cmp	r3, #2
240070b2:	d00a      	beq.n	240070ca <HAL_FLASH_IRQHandler+0x19e>
         (procedure != FLASH_PROC_MASSERASE_BANK1) && \
240070b4:	7afb      	ldrb	r3, [r7, #11]
240070b6:	2b03      	cmp	r3, #3
240070b8:	d007      	beq.n	240070ca <HAL_FLASH_IRQHandler+0x19e>
         (procedure != FLASH_PROC_PROGRAM_BANK1))
      {
        pFlash.ProcedureOnGoing = FLASH_PROC_NONE;
240070ba:	4b34      	ldr	r3, [pc, #208]	; (2400718c <HAL_FLASH_IRQHandler+0x260>)
240070bc:	2200      	movs	r2, #0
240070be:	701a      	strb	r2, [r3, #0]
        /* Clear FLASH End of Operation pending bit */
        __HAL_FLASH_CLEAR_FLAG_BANK2(FLASH_FLAG_EOP_BANK2);
240070c0:	4b31      	ldr	r3, [pc, #196]	; (24007188 <HAL_FLASH_IRQHandler+0x25c>)
240070c2:	f44f 3280 	mov.w	r2, #65536	; 0x10000
240070c6:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
    }
  }

  /* Check FLASH Bank1 operation error flags */
#if defined (FLASH_SR_OPERR)
  errorflag = FLASH->SR1 & (FLASH_FLAG_WRPERR_BANK1 | FLASH_FLAG_PGSERR_BANK1 | FLASH_FLAG_STRBERR_BANK1 | \
240070ca:	4b2f      	ldr	r3, [pc, #188]	; (24007188 <HAL_FLASH_IRQHandler+0x25c>)
240070cc:	691b      	ldr	r3, [r3, #16]
240070ce:	f403 03dc 	and.w	r3, r3, #7208960	; 0x6e0000
240070d2:	607b      	str	r3, [r7, #4]
#else
  errorflag = FLASH->SR1 & (FLASH_FLAG_WRPERR_BANK1 | FLASH_FLAG_PGSERR_BANK1 | FLASH_FLAG_STRBERR_BANK1 | \
                            FLASH_FLAG_INCERR_BANK1);
#endif /* FLASH_SR_OPERR */

  if(errorflag != 0U)
240070d4:	687b      	ldr	r3, [r7, #4]
240070d6:	2b00      	cmp	r3, #0
240070d8:	d028      	beq.n	2400712c <HAL_FLASH_IRQHandler+0x200>
  {
    /* Save the error code */
    pFlash.ErrorCode |= errorflag;
240070da:	4b2c      	ldr	r3, [pc, #176]	; (2400718c <HAL_FLASH_IRQHandler+0x260>)
240070dc:	699a      	ldr	r2, [r3, #24]
240070de:	687b      	ldr	r3, [r7, #4]
240070e0:	4313      	orrs	r3, r2
240070e2:	4a2a      	ldr	r2, [pc, #168]	; (2400718c <HAL_FLASH_IRQHandler+0x260>)
240070e4:	6193      	str	r3, [r2, #24]

    /* Clear error programming flags */
    __HAL_FLASH_CLEAR_FLAG_BANK1(errorflag);
240070e6:	4a28      	ldr	r2, [pc, #160]	; (24007188 <HAL_FLASH_IRQHandler+0x25c>)
240070e8:	687b      	ldr	r3, [r7, #4]
240070ea:	6153      	str	r3, [r2, #20]

    procedure = pFlash.ProcedureOnGoing;
240070ec:	4b27      	ldr	r3, [pc, #156]	; (2400718c <HAL_FLASH_IRQHandler+0x260>)
240070ee:	781b      	ldrb	r3, [r3, #0]
240070f0:	72fb      	strb	r3, [r7, #11]

    if(procedure == FLASH_PROC_SECTERASE_BANK1)
240070f2:	7afb      	ldrb	r3, [r7, #11]
240070f4:	2b01      	cmp	r3, #1
240070f6:	d107      	bne.n	24007108 <HAL_FLASH_IRQHandler+0x1dc>
    {
      /* Return the faulty sector */
      temp = pFlash.Sector;
240070f8:	4b24      	ldr	r3, [pc, #144]	; (2400718c <HAL_FLASH_IRQHandler+0x260>)
240070fa:	68db      	ldr	r3, [r3, #12]
240070fc:	60fb      	str	r3, [r7, #12]
      pFlash.Sector = 0xFFFFFFFFU;
240070fe:	4b23      	ldr	r3, [pc, #140]	; (2400718c <HAL_FLASH_IRQHandler+0x260>)
24007100:	f04f 32ff 	mov.w	r2, #4294967295
24007104:	60da      	str	r2, [r3, #12]
24007106:	e00b      	b.n	24007120 <HAL_FLASH_IRQHandler+0x1f4>
    }
    else if((procedure == FLASH_PROC_MASSERASE_BANK1) || (procedure == FLASH_PROC_ALLBANK_MASSERASE))
24007108:	7afb      	ldrb	r3, [r7, #11]
2400710a:	2b02      	cmp	r3, #2
2400710c:	d002      	beq.n	24007114 <HAL_FLASH_IRQHandler+0x1e8>
2400710e:	7afb      	ldrb	r3, [r7, #11]
24007110:	2b07      	cmp	r3, #7
24007112:	d102      	bne.n	2400711a <HAL_FLASH_IRQHandler+0x1ee>
    {
      /* Return the faulty bank */
      temp = FLASH_BANK_1;
24007114:	2301      	movs	r3, #1
24007116:	60fb      	str	r3, [r7, #12]
24007118:	e002      	b.n	24007120 <HAL_FLASH_IRQHandler+0x1f4>
    }
    else
    {
      /* Return the faulty address */
      temp = pFlash.Address;
2400711a:	4b1c      	ldr	r3, [pc, #112]	; (2400718c <HAL_FLASH_IRQHandler+0x260>)
2400711c:	691b      	ldr	r3, [r3, #16]
2400711e:	60fb      	str	r3, [r7, #12]
    }

    /* Stop the procedure ongoing*/
    pFlash.ProcedureOnGoing = FLASH_PROC_NONE;
24007120:	4b1a      	ldr	r3, [pc, #104]	; (2400718c <HAL_FLASH_IRQHandler+0x260>)
24007122:	2200      	movs	r2, #0
24007124:	701a      	strb	r2, [r3, #0]

    /* FLASH error interrupt user callback */
    HAL_FLASH_OperationErrorCallback(temp);
24007126:	68f8      	ldr	r0, [r7, #12]
24007128:	f000 f864 	bl	240071f4 <HAL_FLASH_OperationErrorCallback>
  }

  /* Check FLASH Bank2 operation error flags */
#if defined (FLASH_SR_OPERR)
  errorflag = FLASH->SR2 & ((FLASH_FLAG_WRPERR_BANK2 | FLASH_FLAG_PGSERR_BANK2 | FLASH_FLAG_STRBERR_BANK2 | \
2400712c:	4b16      	ldr	r3, [pc, #88]	; (24007188 <HAL_FLASH_IRQHandler+0x25c>)
2400712e:	f8d3 3110 	ldr.w	r3, [r3, #272]	; 0x110
24007132:	f403 03dc 	and.w	r3, r3, #7208960	; 0x6e0000
24007136:	607b      	str	r3, [r7, #4]
#else
  errorflag = FLASH->SR2 & ((FLASH_FLAG_WRPERR_BANK2 | FLASH_FLAG_PGSERR_BANK2 | FLASH_FLAG_STRBERR_BANK2 | \
                             FLASH_FLAG_INCERR_BANK2) & 0x7FFFFFFFU);
#endif /* FLASH_SR_OPERR */

  if(errorflag != 0U)
24007138:	687b      	ldr	r3, [r7, #4]
2400713a:	2b00      	cmp	r3, #0
2400713c:	d031      	beq.n	240071a2 <HAL_FLASH_IRQHandler+0x276>
  {
    /* Save the error code */
    pFlash.ErrorCode |= (errorflag | 0x80000000U);
2400713e:	4b13      	ldr	r3, [pc, #76]	; (2400718c <HAL_FLASH_IRQHandler+0x260>)
24007140:	699a      	ldr	r2, [r3, #24]
24007142:	687b      	ldr	r3, [r7, #4]
24007144:	4313      	orrs	r3, r2
24007146:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
2400714a:	4a10      	ldr	r2, [pc, #64]	; (2400718c <HAL_FLASH_IRQHandler+0x260>)
2400714c:	6193      	str	r3, [r2, #24]

    /* Clear error programming flags */
    __HAL_FLASH_CLEAR_FLAG_BANK2(errorflag);
2400714e:	4a0e      	ldr	r2, [pc, #56]	; (24007188 <HAL_FLASH_IRQHandler+0x25c>)
24007150:	687b      	ldr	r3, [r7, #4]
24007152:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
24007156:	f8c2 3114 	str.w	r3, [r2, #276]	; 0x114

    procedure = pFlash.ProcedureOnGoing;
2400715a:	4b0c      	ldr	r3, [pc, #48]	; (2400718c <HAL_FLASH_IRQHandler+0x260>)
2400715c:	781b      	ldrb	r3, [r3, #0]
2400715e:	72fb      	strb	r3, [r7, #11]

    if(procedure== FLASH_PROC_SECTERASE_BANK2)
24007160:	7afb      	ldrb	r3, [r7, #11]
24007162:	2b04      	cmp	r3, #4
24007164:	d107      	bne.n	24007176 <HAL_FLASH_IRQHandler+0x24a>
    {
      /*return the faulty sector*/
      temp = pFlash.Sector;
24007166:	4b09      	ldr	r3, [pc, #36]	; (2400718c <HAL_FLASH_IRQHandler+0x260>)
24007168:	68db      	ldr	r3, [r3, #12]
2400716a:	60fb      	str	r3, [r7, #12]
      pFlash.Sector = 0xFFFFFFFFU;
2400716c:	4b07      	ldr	r3, [pc, #28]	; (2400718c <HAL_FLASH_IRQHandler+0x260>)
2400716e:	f04f 32ff 	mov.w	r2, #4294967295
24007172:	60da      	str	r2, [r3, #12]
24007174:	e00f      	b.n	24007196 <HAL_FLASH_IRQHandler+0x26a>
    }
    else if((procedure == FLASH_PROC_MASSERASE_BANK2) || (procedure == FLASH_PROC_ALLBANK_MASSERASE))
24007176:	7afb      	ldrb	r3, [r7, #11]
24007178:	2b05      	cmp	r3, #5
2400717a:	d002      	beq.n	24007182 <HAL_FLASH_IRQHandler+0x256>
2400717c:	7afb      	ldrb	r3, [r7, #11]
2400717e:	2b07      	cmp	r3, #7
24007180:	d106      	bne.n	24007190 <HAL_FLASH_IRQHandler+0x264>
    {
      /*return the faulty bank*/
      temp = FLASH_BANK_2;
24007182:	2302      	movs	r3, #2
24007184:	60fb      	str	r3, [r7, #12]
24007186:	e006      	b.n	24007196 <HAL_FLASH_IRQHandler+0x26a>
24007188:	52002000 	.word	0x52002000
2400718c:	24000548 	.word	0x24000548
    }
    else
    {
      /*return the faulty address*/
      temp = pFlash.Address;
24007190:	4b11      	ldr	r3, [pc, #68]	; (240071d8 <HAL_FLASH_IRQHandler+0x2ac>)
24007192:	691b      	ldr	r3, [r3, #16]
24007194:	60fb      	str	r3, [r7, #12]
    }

    /*Stop the procedure ongoing*/
    pFlash.ProcedureOnGoing = FLASH_PROC_NONE;
24007196:	4b10      	ldr	r3, [pc, #64]	; (240071d8 <HAL_FLASH_IRQHandler+0x2ac>)
24007198:	2200      	movs	r2, #0
2400719a:	701a      	strb	r2, [r3, #0]

    /* FLASH error interrupt user callback */
    HAL_FLASH_OperationErrorCallback(temp);
2400719c:	68f8      	ldr	r0, [r7, #12]
2400719e:	f000 f829 	bl	240071f4 <HAL_FLASH_OperationErrorCallback>
  }

  if(pFlash.ProcedureOnGoing == FLASH_PROC_NONE)
240071a2:	4b0d      	ldr	r3, [pc, #52]	; (240071d8 <HAL_FLASH_IRQHandler+0x2ac>)
240071a4:	781b      	ldrb	r3, [r3, #0]
240071a6:	b2db      	uxtb	r3, r3
240071a8:	2b00      	cmp	r3, #0
240071aa:	d110      	bne.n	240071ce <HAL_FLASH_IRQHandler+0x2a2>
  {
#if defined (FLASH_CR_OPERRIE)
    /* Disable Bank1 Operation and Error source interrupt */
    __HAL_FLASH_DISABLE_IT_BANK1(FLASH_IT_EOP_BANK1    | FLASH_IT_WRPERR_BANK1 | FLASH_IT_PGSERR_BANK1 | \
240071ac:	4b0b      	ldr	r3, [pc, #44]	; (240071dc <HAL_FLASH_IRQHandler+0x2b0>)
240071ae:	68db      	ldr	r3, [r3, #12]
240071b0:	4a0a      	ldr	r2, [pc, #40]	; (240071dc <HAL_FLASH_IRQHandler+0x2b0>)
240071b2:	f423 03de 	bic.w	r3, r3, #7274496	; 0x6f0000
240071b6:	60d3      	str	r3, [r2, #12]
                                 FLASH_IT_STRBERR_BANK1 | FLASH_IT_INCERR_BANK1 | FLASH_IT_OPERR_BANK1);

    /* Disable Bank2 Operation and Error source interrupt */
    __HAL_FLASH_DISABLE_IT_BANK2(FLASH_IT_EOP_BANK2    | FLASH_IT_WRPERR_BANK2 | FLASH_IT_PGSERR_BANK2 | \
240071b8:	4b08      	ldr	r3, [pc, #32]	; (240071dc <HAL_FLASH_IRQHandler+0x2b0>)
240071ba:	f8d3 310c 	ldr.w	r3, [r3, #268]	; 0x10c
240071be:	4a07      	ldr	r2, [pc, #28]	; (240071dc <HAL_FLASH_IRQHandler+0x2b0>)
240071c0:	f423 03de 	bic.w	r3, r3, #7274496	; 0x6f0000
240071c4:	f8c2 310c 	str.w	r3, [r2, #268]	; 0x10c
    __HAL_FLASH_DISABLE_IT_BANK2(FLASH_IT_EOP_BANK2    | FLASH_IT_WRPERR_BANK2 | FLASH_IT_PGSERR_BANK2 | \
                                 FLASH_IT_STRBERR_BANK2 | FLASH_IT_INCERR_BANK2);
#endif /* FLASH_CR_OPERRIE */

    /* Process Unlocked */
    __HAL_UNLOCK(&pFlash);
240071c8:	4b03      	ldr	r3, [pc, #12]	; (240071d8 <HAL_FLASH_IRQHandler+0x2ac>)
240071ca:	2200      	movs	r2, #0
240071cc:	751a      	strb	r2, [r3, #20]
  }
}
240071ce:	bf00      	nop
240071d0:	3710      	adds	r7, #16
240071d2:	46bd      	mov	sp, r7
240071d4:	bd80      	pop	{r7, pc}
240071d6:	bf00      	nop
240071d8:	24000548 	.word	0x24000548
240071dc:	52002000 	.word	0x52002000

240071e0 <HAL_FLASH_EndOfOperationCallback>:
  *                    (if 0xFFFFFFFF, it means that all the selected sectors have been erased)
  *                  Program: Address which was selected for data program
  * @retval None
  */
__weak void HAL_FLASH_EndOfOperationCallback(uint32_t ReturnValue)
{
240071e0:	b480      	push	{r7}
240071e2:	b083      	sub	sp, #12
240071e4:	af00      	add	r7, sp, #0
240071e6:	6078      	str	r0, [r7, #4]
  UNUSED(ReturnValue);

  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_FLASH_EndOfOperationCallback could be implemented in the user file
   */
}
240071e8:	bf00      	nop
240071ea:	370c      	adds	r7, #12
240071ec:	46bd      	mov	sp, r7
240071ee:	f85d 7b04 	ldr.w	r7, [sp], #4
240071f2:	4770      	bx	lr

240071f4 <HAL_FLASH_OperationErrorCallback>:
  *                 Sectors Erase: Sector number which returned an error
  *                 Program: Address which was selected for data program
  * @retval None
  */
__weak void HAL_FLASH_OperationErrorCallback(uint32_t ReturnValue)
{
240071f4:	b480      	push	{r7}
240071f6:	b083      	sub	sp, #12
240071f8:	af00      	add	r7, sp, #0
240071fa:	6078      	str	r0, [r7, #4]
  UNUSED(ReturnValue);

  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_FLASH_OperationErrorCallback could be implemented in the user file
   */
}
240071fc:	bf00      	nop
240071fe:	370c      	adds	r7, #12
24007200:	46bd      	mov	sp, r7
24007202:	f85d 7b04 	ldr.w	r7, [sp], #4
24007206:	4770      	bx	lr

24007208 <HAL_FLASH_Unlock>:
/**
  * @brief  Unlock the FLASH control registers access
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASH_Unlock(void)
{
24007208:	b480      	push	{r7}
2400720a:	af00      	add	r7, sp, #0
  if(READ_BIT(FLASH->CR1, FLASH_CR_LOCK) != 0U)
2400720c:	4b18      	ldr	r3, [pc, #96]	; (24007270 <HAL_FLASH_Unlock+0x68>)
2400720e:	68db      	ldr	r3, [r3, #12]
24007210:	f003 0301 	and.w	r3, r3, #1
24007214:	2b00      	cmp	r3, #0
24007216:	d00d      	beq.n	24007234 <HAL_FLASH_Unlock+0x2c>
  {
    /* Authorize the FLASH Bank1 Registers access */
    WRITE_REG(FLASH->KEYR1, FLASH_KEY1);
24007218:	4b15      	ldr	r3, [pc, #84]	; (24007270 <HAL_FLASH_Unlock+0x68>)
2400721a:	4a16      	ldr	r2, [pc, #88]	; (24007274 <HAL_FLASH_Unlock+0x6c>)
2400721c:	605a      	str	r2, [r3, #4]
    WRITE_REG(FLASH->KEYR1, FLASH_KEY2);
2400721e:	4b14      	ldr	r3, [pc, #80]	; (24007270 <HAL_FLASH_Unlock+0x68>)
24007220:	4a15      	ldr	r2, [pc, #84]	; (24007278 <HAL_FLASH_Unlock+0x70>)
24007222:	605a      	str	r2, [r3, #4]

    /* Verify Flash Bank1 is unlocked */
    if (READ_BIT(FLASH->CR1, FLASH_CR_LOCK) != 0U)
24007224:	4b12      	ldr	r3, [pc, #72]	; (24007270 <HAL_FLASH_Unlock+0x68>)
24007226:	68db      	ldr	r3, [r3, #12]
24007228:	f003 0301 	and.w	r3, r3, #1
2400722c:	2b00      	cmp	r3, #0
2400722e:	d001      	beq.n	24007234 <HAL_FLASH_Unlock+0x2c>
    {
      return HAL_ERROR;
24007230:	2301      	movs	r3, #1
24007232:	e018      	b.n	24007266 <HAL_FLASH_Unlock+0x5e>
    }
  }

  if(READ_BIT(FLASH->CR2, FLASH_CR_LOCK) != 0U)
24007234:	4b0e      	ldr	r3, [pc, #56]	; (24007270 <HAL_FLASH_Unlock+0x68>)
24007236:	f8d3 310c 	ldr.w	r3, [r3, #268]	; 0x10c
2400723a:	f003 0301 	and.w	r3, r3, #1
2400723e:	2b00      	cmp	r3, #0
24007240:	d010      	beq.n	24007264 <HAL_FLASH_Unlock+0x5c>
  {
    /* Authorize the FLASH Bank2 Registers access */
    WRITE_REG(FLASH->KEYR2, FLASH_KEY1);
24007242:	4b0b      	ldr	r3, [pc, #44]	; (24007270 <HAL_FLASH_Unlock+0x68>)
24007244:	4a0b      	ldr	r2, [pc, #44]	; (24007274 <HAL_FLASH_Unlock+0x6c>)
24007246:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
    WRITE_REG(FLASH->KEYR2, FLASH_KEY2);
2400724a:	4b09      	ldr	r3, [pc, #36]	; (24007270 <HAL_FLASH_Unlock+0x68>)
2400724c:	4a0a      	ldr	r2, [pc, #40]	; (24007278 <HAL_FLASH_Unlock+0x70>)
2400724e:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104

    /* Verify Flash Bank2 is unlocked */
    if (READ_BIT(FLASH->CR2, FLASH_CR_LOCK) != 0U)
24007252:	4b07      	ldr	r3, [pc, #28]	; (24007270 <HAL_FLASH_Unlock+0x68>)
24007254:	f8d3 310c 	ldr.w	r3, [r3, #268]	; 0x10c
24007258:	f003 0301 	and.w	r3, r3, #1
2400725c:	2b00      	cmp	r3, #0
2400725e:	d001      	beq.n	24007264 <HAL_FLASH_Unlock+0x5c>
    {
      return HAL_ERROR;
24007260:	2301      	movs	r3, #1
24007262:	e000      	b.n	24007266 <HAL_FLASH_Unlock+0x5e>
    }
  }

  return HAL_OK;
24007264:	2300      	movs	r3, #0
}
24007266:	4618      	mov	r0, r3
24007268:	46bd      	mov	sp, r7
2400726a:	f85d 7b04 	ldr.w	r7, [sp], #4
2400726e:	4770      	bx	lr
24007270:	52002000 	.word	0x52002000
24007274:	45670123 	.word	0x45670123
24007278:	cdef89ab 	.word	0xcdef89ab

2400727c <HAL_FLASH_Lock>:
/**
  * @brief  Locks the FLASH control registers access
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASH_Lock(void)
{
2400727c:	b480      	push	{r7}
2400727e:	af00      	add	r7, sp, #0
  /* Set the LOCK Bit to lock the FLASH Bank1 Control Register access */
  SET_BIT(FLASH->CR1, FLASH_CR_LOCK);
24007280:	4b12      	ldr	r3, [pc, #72]	; (240072cc <HAL_FLASH_Lock+0x50>)
24007282:	68db      	ldr	r3, [r3, #12]
24007284:	4a11      	ldr	r2, [pc, #68]	; (240072cc <HAL_FLASH_Lock+0x50>)
24007286:	f043 0301 	orr.w	r3, r3, #1
2400728a:	60d3      	str	r3, [r2, #12]

  /* Verify Flash Bank1 is locked */
  if (READ_BIT(FLASH->CR1, FLASH_CR_LOCK) == 0U)
2400728c:	4b0f      	ldr	r3, [pc, #60]	; (240072cc <HAL_FLASH_Lock+0x50>)
2400728e:	68db      	ldr	r3, [r3, #12]
24007290:	f003 0301 	and.w	r3, r3, #1
24007294:	2b00      	cmp	r3, #0
24007296:	d101      	bne.n	2400729c <HAL_FLASH_Lock+0x20>
  {
    return HAL_ERROR;
24007298:	2301      	movs	r3, #1
2400729a:	e011      	b.n	240072c0 <HAL_FLASH_Lock+0x44>
  }

  /* Set the LOCK Bit to lock the FLASH Bank2 Control Register access */
  SET_BIT(FLASH->CR2, FLASH_CR_LOCK);
2400729c:	4b0b      	ldr	r3, [pc, #44]	; (240072cc <HAL_FLASH_Lock+0x50>)
2400729e:	f8d3 310c 	ldr.w	r3, [r3, #268]	; 0x10c
240072a2:	4a0a      	ldr	r2, [pc, #40]	; (240072cc <HAL_FLASH_Lock+0x50>)
240072a4:	f043 0301 	orr.w	r3, r3, #1
240072a8:	f8c2 310c 	str.w	r3, [r2, #268]	; 0x10c

  /* Verify Flash Bank2 is locked */
  if (READ_BIT(FLASH->CR2, FLASH_CR_LOCK) == 0U)
240072ac:	4b07      	ldr	r3, [pc, #28]	; (240072cc <HAL_FLASH_Lock+0x50>)
240072ae:	f8d3 310c 	ldr.w	r3, [r3, #268]	; 0x10c
240072b2:	f003 0301 	and.w	r3, r3, #1
240072b6:	2b00      	cmp	r3, #0
240072b8:	d101      	bne.n	240072be <HAL_FLASH_Lock+0x42>
  {
    return HAL_ERROR;
240072ba:	2301      	movs	r3, #1
240072bc:	e000      	b.n	240072c0 <HAL_FLASH_Lock+0x44>
  }

  return HAL_OK;
240072be:	2300      	movs	r3, #0
}
240072c0:	4618      	mov	r0, r3
240072c2:	46bd      	mov	sp, r7
240072c4:	f85d 7b04 	ldr.w	r7, [sp], #4
240072c8:	4770      	bx	lr
240072ca:	bf00      	nop
240072cc:	52002000 	.word	0x52002000

240072d0 <HAL_FLASH_OB_Unlock>:
/**
  * @brief  Unlock the FLASH Option Control Registers access.
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASH_OB_Unlock(void)
{
240072d0:	b480      	push	{r7}
240072d2:	af00      	add	r7, sp, #0
  if(READ_BIT(FLASH->OPTCR, FLASH_OPTCR_OPTLOCK) != 0U)
240072d4:	4b0c      	ldr	r3, [pc, #48]	; (24007308 <HAL_FLASH_OB_Unlock+0x38>)
240072d6:	699b      	ldr	r3, [r3, #24]
240072d8:	f003 0301 	and.w	r3, r3, #1
240072dc:	2b00      	cmp	r3, #0
240072de:	d00d      	beq.n	240072fc <HAL_FLASH_OB_Unlock+0x2c>
  {
    /* Authorizes the Option Byte registers programming */
    WRITE_REG(FLASH->OPTKEYR, FLASH_OPT_KEY1);
240072e0:	4b09      	ldr	r3, [pc, #36]	; (24007308 <HAL_FLASH_OB_Unlock+0x38>)
240072e2:	4a0a      	ldr	r2, [pc, #40]	; (2400730c <HAL_FLASH_OB_Unlock+0x3c>)
240072e4:	609a      	str	r2, [r3, #8]
    WRITE_REG(FLASH->OPTKEYR, FLASH_OPT_KEY2);
240072e6:	4b08      	ldr	r3, [pc, #32]	; (24007308 <HAL_FLASH_OB_Unlock+0x38>)
240072e8:	4a09      	ldr	r2, [pc, #36]	; (24007310 <HAL_FLASH_OB_Unlock+0x40>)
240072ea:	609a      	str	r2, [r3, #8]

    /* Verify that the Option Bytes are unlocked */
    if (READ_BIT(FLASH->OPTCR, FLASH_OPTCR_OPTLOCK) != 0U)
240072ec:	4b06      	ldr	r3, [pc, #24]	; (24007308 <HAL_FLASH_OB_Unlock+0x38>)
240072ee:	699b      	ldr	r3, [r3, #24]
240072f0:	f003 0301 	and.w	r3, r3, #1
240072f4:	2b00      	cmp	r3, #0
240072f6:	d001      	beq.n	240072fc <HAL_FLASH_OB_Unlock+0x2c>
    {
      return HAL_ERROR;
240072f8:	2301      	movs	r3, #1
240072fa:	e000      	b.n	240072fe <HAL_FLASH_OB_Unlock+0x2e>
    }
  }

  return HAL_OK;
240072fc:	2300      	movs	r3, #0
}
240072fe:	4618      	mov	r0, r3
24007300:	46bd      	mov	sp, r7
24007302:	f85d 7b04 	ldr.w	r7, [sp], #4
24007306:	4770      	bx	lr
24007308:	52002000 	.word	0x52002000
2400730c:	08192a3b 	.word	0x08192a3b
24007310:	4c5d6e7f 	.word	0x4c5d6e7f

24007314 <HAL_FLASH_OB_Lock>:
/**
  * @brief  Lock the FLASH Option Control Registers access.
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASH_OB_Lock(void)
{
24007314:	b480      	push	{r7}
24007316:	af00      	add	r7, sp, #0
  /* Set the OPTLOCK Bit to lock the FLASH Option Byte Registers access */
  SET_BIT(FLASH->OPTCR, FLASH_OPTCR_OPTLOCK);
24007318:	4b09      	ldr	r3, [pc, #36]	; (24007340 <HAL_FLASH_OB_Lock+0x2c>)
2400731a:	699b      	ldr	r3, [r3, #24]
2400731c:	4a08      	ldr	r2, [pc, #32]	; (24007340 <HAL_FLASH_OB_Lock+0x2c>)
2400731e:	f043 0301 	orr.w	r3, r3, #1
24007322:	6193      	str	r3, [r2, #24]

  /* Verify that the Option Bytes are locked */
  if (READ_BIT(FLASH->OPTCR, FLASH_OPTCR_OPTLOCK) == 0U)
24007324:	4b06      	ldr	r3, [pc, #24]	; (24007340 <HAL_FLASH_OB_Lock+0x2c>)
24007326:	699b      	ldr	r3, [r3, #24]
24007328:	f003 0301 	and.w	r3, r3, #1
2400732c:	2b00      	cmp	r3, #0
2400732e:	d101      	bne.n	24007334 <HAL_FLASH_OB_Lock+0x20>
  {
    return HAL_ERROR;
24007330:	2301      	movs	r3, #1
24007332:	e000      	b.n	24007336 <HAL_FLASH_OB_Lock+0x22>
  }

  return HAL_OK;
24007334:	2300      	movs	r3, #0
}
24007336:	4618      	mov	r0, r3
24007338:	46bd      	mov	sp, r7
2400733a:	f85d 7b04 	ldr.w	r7, [sp], #4
2400733e:	4770      	bx	lr
24007340:	52002000 	.word	0x52002000

24007344 <HAL_FLASH_OB_Launch>:
/**
  * @brief  Launch the option bytes loading.
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASH_OB_Launch(void)
{
24007344:	b580      	push	{r7, lr}
24007346:	b082      	sub	sp, #8
24007348:	af00      	add	r7, sp, #0
  HAL_StatusTypeDef status;

  /* Wait for CRC computation to be completed */
  if (FLASH_CRC_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_1) != HAL_OK)
2400734a:	2101      	movs	r1, #1
2400734c:	f24c 3050 	movw	r0, #50000	; 0xc350
24007350:	f000 f90e 	bl	24007570 <FLASH_CRC_WaitForLastOperation>
24007354:	4603      	mov	r3, r0
24007356:	2b00      	cmp	r3, #0
24007358:	d002      	beq.n	24007360 <HAL_FLASH_OB_Launch+0x1c>
  {
    status = HAL_ERROR;
2400735a:	2301      	movs	r3, #1
2400735c:	71fb      	strb	r3, [r7, #7]
2400735e:	e00c      	b.n	2400737a <HAL_FLASH_OB_Launch+0x36>
  }
  else if (FLASH_CRC_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_2) != HAL_OK)
24007360:	2102      	movs	r1, #2
24007362:	f24c 3050 	movw	r0, #50000	; 0xc350
24007366:	f000 f903 	bl	24007570 <FLASH_CRC_WaitForLastOperation>
2400736a:	4603      	mov	r3, r0
2400736c:	2b00      	cmp	r3, #0
2400736e:	d002      	beq.n	24007376 <HAL_FLASH_OB_Launch+0x32>
  {
    status = HAL_ERROR;
24007370:	2301      	movs	r3, #1
24007372:	71fb      	strb	r3, [r7, #7]
24007374:	e001      	b.n	2400737a <HAL_FLASH_OB_Launch+0x36>
  }
  else
  {
    status = HAL_OK;
24007376:	2300      	movs	r3, #0
24007378:	71fb      	strb	r3, [r7, #7]
  }

  if (status == HAL_OK)
2400737a:	79fb      	ldrb	r3, [r7, #7]
2400737c:	2b00      	cmp	r3, #0
2400737e:	d10b      	bne.n	24007398 <HAL_FLASH_OB_Launch+0x54>
  {
    /* Set OPTSTRT Bit */
    SET_BIT(FLASH->OPTCR, FLASH_OPTCR_OPTSTART);
24007380:	4b08      	ldr	r3, [pc, #32]	; (240073a4 <HAL_FLASH_OB_Launch+0x60>)
24007382:	699b      	ldr	r3, [r3, #24]
24007384:	4a07      	ldr	r2, [pc, #28]	; (240073a4 <HAL_FLASH_OB_Launch+0x60>)
24007386:	f043 0302 	orr.w	r3, r3, #2
2400738a:	6193      	str	r3, [r2, #24]

    /* Wait for OB change operation to be completed */
    status = FLASH_OB_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
2400738c:	f24c 3050 	movw	r0, #50000	; 0xc350
24007390:	f000 f8b2 	bl	240074f8 <FLASH_OB_WaitForLastOperation>
24007394:	4603      	mov	r3, r0
24007396:	71fb      	strb	r3, [r7, #7]
  }

  return status;
24007398:	79fb      	ldrb	r3, [r7, #7]
}
2400739a:	4618      	mov	r0, r3
2400739c:	3708      	adds	r7, #8
2400739e:	46bd      	mov	sp, r7
240073a0:	bd80      	pop	{r7, pc}
240073a2:	bf00      	nop
240073a4:	52002000 	.word	0x52002000

240073a8 <HAL_FLASH_GetError>:
  *            @arg HAL_FLASH_ERROR_DBECC_BANK2: Double Detection ECC on Bank 2
  *            @arg HAL_FLASH_ERROR_CRCRD_BANK2: CRC Read Error on Bank 2
*/

uint32_t HAL_FLASH_GetError(void)
{
240073a8:	b480      	push	{r7}
240073aa:	af00      	add	r7, sp, #0
   return pFlash.ErrorCode;
240073ac:	4b03      	ldr	r3, [pc, #12]	; (240073bc <HAL_FLASH_GetError+0x14>)
240073ae:	699b      	ldr	r3, [r3, #24]
}
240073b0:	4618      	mov	r0, r3
240073b2:	46bd      	mov	sp, r7
240073b4:	f85d 7b04 	ldr.w	r7, [sp], #4
240073b8:	4770      	bx	lr
240073ba:	bf00      	nop
240073bc:	24000548 	.word	0x24000548

240073c0 <FLASH_WaitForLastOperation>:
  * @param  Timeout maximum flash operation timeout
  * @param  Bank flash FLASH_BANK_1 or FLASH_BANK_2
  * @retval HAL_StatusTypeDef HAL Status
  */
HAL_StatusTypeDef FLASH_WaitForLastOperation(uint32_t Timeout, uint32_t Bank)
{
240073c0:	b580      	push	{r7, lr}
240073c2:	b086      	sub	sp, #24
240073c4:	af00      	add	r7, sp, #0
240073c6:	6078      	str	r0, [r7, #4]
240073c8:	6039      	str	r1, [r7, #0]
  /* Wait for the FLASH operation to complete by polling on QW flag to be reset.
     Even if the FLASH operation fails, the QW flag will be reset and an error
     flag will be set */

  uint32_t bsyflag, errorflag;
  uint32_t tickstart = HAL_GetTick();
240073ca:	f7f9 fa41 	bl	24000850 <HAL_GetTick>
240073ce:	60f8      	str	r0, [r7, #12]

  assert_param(IS_FLASH_BANK_EXCLUSIVE(Bank));

  /* Select bsyflag depending on Bank */
  if(Bank == FLASH_BANK_1)
240073d0:	683b      	ldr	r3, [r7, #0]
240073d2:	2b01      	cmp	r3, #1
240073d4:	d102      	bne.n	240073dc <FLASH_WaitForLastOperation+0x1c>
  {
    bsyflag = FLASH_FLAG_QW_BANK1;
240073d6:	2304      	movs	r3, #4
240073d8:	617b      	str	r3, [r7, #20]
240073da:	e013      	b.n	24007404 <FLASH_WaitForLastOperation+0x44>
  }
  else
  {
    bsyflag = FLASH_FLAG_QW_BANK2;
240073dc:	4b41      	ldr	r3, [pc, #260]	; (240074e4 <FLASH_WaitForLastOperation+0x124>)
240073de:	617b      	str	r3, [r7, #20]
  }

  while(__HAL_FLASH_GET_FLAG(bsyflag))
240073e0:	e010      	b.n	24007404 <FLASH_WaitForLastOperation+0x44>
  {
    if(Timeout != HAL_MAX_DELAY)
240073e2:	687b      	ldr	r3, [r7, #4]
240073e4:	f1b3 3fff 	cmp.w	r3, #4294967295
240073e8:	d00c      	beq.n	24007404 <FLASH_WaitForLastOperation+0x44>
    {
      if(((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
240073ea:	f7f9 fa31 	bl	24000850 <HAL_GetTick>
240073ee:	4602      	mov	r2, r0
240073f0:	68fb      	ldr	r3, [r7, #12]
240073f2:	1ad3      	subs	r3, r2, r3
240073f4:	687a      	ldr	r2, [r7, #4]
240073f6:	429a      	cmp	r2, r3
240073f8:	d302      	bcc.n	24007400 <FLASH_WaitForLastOperation+0x40>
240073fa:	687b      	ldr	r3, [r7, #4]
240073fc:	2b00      	cmp	r3, #0
240073fe:	d101      	bne.n	24007404 <FLASH_WaitForLastOperation+0x44>
      {
        return HAL_TIMEOUT;
24007400:	2303      	movs	r3, #3
24007402:	e06a      	b.n	240074da <FLASH_WaitForLastOperation+0x11a>
  while(__HAL_FLASH_GET_FLAG(bsyflag))
24007404:	697a      	ldr	r2, [r7, #20]
24007406:	4b38      	ldr	r3, [pc, #224]	; (240074e8 <FLASH_WaitForLastOperation+0x128>)
24007408:	4013      	ands	r3, r2
2400740a:	697a      	ldr	r2, [r7, #20]
2400740c:	429a      	cmp	r2, r3
2400740e:	d10a      	bne.n	24007426 <FLASH_WaitForLastOperation+0x66>
24007410:	4b36      	ldr	r3, [pc, #216]	; (240074ec <FLASH_WaitForLastOperation+0x12c>)
24007412:	691a      	ldr	r2, [r3, #16]
24007414:	697b      	ldr	r3, [r7, #20]
24007416:	4013      	ands	r3, r2
24007418:	697a      	ldr	r2, [r7, #20]
2400741a:	429a      	cmp	r2, r3
2400741c:	bf0c      	ite	eq
2400741e:	2301      	moveq	r3, #1
24007420:	2300      	movne	r3, #0
24007422:	b2db      	uxtb	r3, r3
24007424:	e00c      	b.n	24007440 <FLASH_WaitForLastOperation+0x80>
24007426:	4b31      	ldr	r3, [pc, #196]	; (240074ec <FLASH_WaitForLastOperation+0x12c>)
24007428:	f8d3 3110 	ldr.w	r3, [r3, #272]	; 0x110
2400742c:	43da      	mvns	r2, r3
2400742e:	697b      	ldr	r3, [r7, #20]
24007430:	4013      	ands	r3, r2
24007432:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
24007436:	2b00      	cmp	r3, #0
24007438:	bf0c      	ite	eq
2400743a:	2301      	moveq	r3, #1
2400743c:	2300      	movne	r3, #0
2400743e:	b2db      	uxtb	r3, r3
24007440:	2b00      	cmp	r3, #0
24007442:	d1ce      	bne.n	240073e2 <FLASH_WaitForLastOperation+0x22>
      }
    }
  }

  /* Get Error Flags */
  if (Bank == FLASH_BANK_1)
24007444:	683b      	ldr	r3, [r7, #0]
24007446:	2b01      	cmp	r3, #1
24007448:	d105      	bne.n	24007456 <FLASH_WaitForLastOperation+0x96>
  {
    errorflag = FLASH->SR1 & FLASH_FLAG_ALL_ERRORS_BANK1;
2400744a:	4b28      	ldr	r3, [pc, #160]	; (240074ec <FLASH_WaitForLastOperation+0x12c>)
2400744c:	691a      	ldr	r2, [r3, #16]
2400744e:	4b28      	ldr	r3, [pc, #160]	; (240074f0 <FLASH_WaitForLastOperation+0x130>)
24007450:	4013      	ands	r3, r2
24007452:	613b      	str	r3, [r7, #16]
24007454:	e007      	b.n	24007466 <FLASH_WaitForLastOperation+0xa6>
  }
  else
  {
    errorflag = (FLASH->SR2 & FLASH_FLAG_ALL_ERRORS_BANK2) | 0x80000000U;
24007456:	4b25      	ldr	r3, [pc, #148]	; (240074ec <FLASH_WaitForLastOperation+0x12c>)
24007458:	f8d3 2110 	ldr.w	r2, [r3, #272]	; 0x110
2400745c:	4b24      	ldr	r3, [pc, #144]	; (240074f0 <FLASH_WaitForLastOperation+0x130>)
2400745e:	4013      	ands	r3, r2
24007460:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
24007464:	613b      	str	r3, [r7, #16]
  }

  /* In case of error reported in Flash SR1 or SR2 registers (ECCC not managed as an error) */
  if((errorflag & 0x7DFFFFFFU) != 0U)
24007466:	693b      	ldr	r3, [r7, #16]
24007468:	f023 4302 	bic.w	r3, r3, #2181038080	; 0x82000000
2400746c:	2b00      	cmp	r3, #0
2400746e:	d017      	beq.n	240074a0 <FLASH_WaitForLastOperation+0xe0>
  {
    /*Save the error code*/
    pFlash.ErrorCode |= errorflag;
24007470:	4b20      	ldr	r3, [pc, #128]	; (240074f4 <FLASH_WaitForLastOperation+0x134>)
24007472:	699a      	ldr	r2, [r3, #24]
24007474:	693b      	ldr	r3, [r7, #16]
24007476:	4313      	orrs	r3, r2
24007478:	4a1e      	ldr	r2, [pc, #120]	; (240074f4 <FLASH_WaitForLastOperation+0x134>)
2400747a:	6193      	str	r3, [r2, #24]

    /* Clear error programming flags */
    __HAL_FLASH_CLEAR_FLAG(errorflag);
2400747c:	693a      	ldr	r2, [r7, #16]
2400747e:	4b1a      	ldr	r3, [pc, #104]	; (240074e8 <FLASH_WaitForLastOperation+0x128>)
24007480:	4013      	ands	r3, r2
24007482:	693a      	ldr	r2, [r7, #16]
24007484:	429a      	cmp	r2, r3
24007486:	d103      	bne.n	24007490 <FLASH_WaitForLastOperation+0xd0>
24007488:	4a18      	ldr	r2, [pc, #96]	; (240074ec <FLASH_WaitForLastOperation+0x12c>)
2400748a:	693b      	ldr	r3, [r7, #16]
2400748c:	6153      	str	r3, [r2, #20]
2400748e:	e005      	b.n	2400749c <FLASH_WaitForLastOperation+0xdc>
24007490:	4a16      	ldr	r2, [pc, #88]	; (240074ec <FLASH_WaitForLastOperation+0x12c>)
24007492:	693b      	ldr	r3, [r7, #16]
24007494:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
24007498:	f8c2 3114 	str.w	r3, [r2, #276]	; 0x114

    return HAL_ERROR;
2400749c:	2301      	movs	r3, #1
2400749e:	e01c      	b.n	240074da <FLASH_WaitForLastOperation+0x11a>
  }

  /* Check FLASH End of Operation flag  */
  if(Bank == FLASH_BANK_1)
240074a0:	683b      	ldr	r3, [r7, #0]
240074a2:	2b01      	cmp	r3, #1
240074a4:	d10b      	bne.n	240074be <FLASH_WaitForLastOperation+0xfe>
  {
    if (__HAL_FLASH_GET_FLAG_BANK1(FLASH_FLAG_EOP_BANK1))
240074a6:	4b11      	ldr	r3, [pc, #68]	; (240074ec <FLASH_WaitForLastOperation+0x12c>)
240074a8:	691b      	ldr	r3, [r3, #16]
240074aa:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
240074ae:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
240074b2:	d111      	bne.n	240074d8 <FLASH_WaitForLastOperation+0x118>
    {
      /* Clear FLASH End of Operation pending bit */
      __HAL_FLASH_CLEAR_FLAG_BANK1(FLASH_FLAG_EOP_BANK1);
240074b4:	4b0d      	ldr	r3, [pc, #52]	; (240074ec <FLASH_WaitForLastOperation+0x12c>)
240074b6:	f44f 3280 	mov.w	r2, #65536	; 0x10000
240074ba:	615a      	str	r2, [r3, #20]
240074bc:	e00c      	b.n	240074d8 <FLASH_WaitForLastOperation+0x118>
    }
  }
  else
  {
    if (__HAL_FLASH_GET_FLAG_BANK2(FLASH_FLAG_EOP_BANK2))
240074be:	4b0b      	ldr	r3, [pc, #44]	; (240074ec <FLASH_WaitForLastOperation+0x12c>)
240074c0:	f8d3 3110 	ldr.w	r3, [r3, #272]	; 0x110
240074c4:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
240074c8:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
240074cc:	d104      	bne.n	240074d8 <FLASH_WaitForLastOperation+0x118>
    {
      /* Clear FLASH End of Operation pending bit */
      __HAL_FLASH_CLEAR_FLAG_BANK2(FLASH_FLAG_EOP_BANK2);
240074ce:	4b07      	ldr	r3, [pc, #28]	; (240074ec <FLASH_WaitForLastOperation+0x12c>)
240074d0:	f44f 3280 	mov.w	r2, #65536	; 0x10000
240074d4:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
    }
  }

  return HAL_OK;
240074d8:	2300      	movs	r3, #0
}
240074da:	4618      	mov	r0, r3
240074dc:	3718      	adds	r7, #24
240074de:	46bd      	mov	sp, r7
240074e0:	bd80      	pop	{r7, pc}
240074e2:	bf00      	nop
240074e4:	80000004 	.word	0x80000004
240074e8:	1fef000f 	.word	0x1fef000f
240074ec:	52002000 	.word	0x52002000
240074f0:	17ee0000 	.word	0x17ee0000
240074f4:	24000548 	.word	0x24000548

240074f8 <FLASH_OB_WaitForLastOperation>:
  * @brief  Wait for a FLASH Option Bytes change operation to complete.
  * @param  Timeout maximum flash operation timeout
  * @retval HAL_StatusTypeDef HAL Status
  */
HAL_StatusTypeDef FLASH_OB_WaitForLastOperation(uint32_t Timeout)
{
240074f8:	b580      	push	{r7, lr}
240074fa:	b084      	sub	sp, #16
240074fc:	af00      	add	r7, sp, #0
240074fe:	6078      	str	r0, [r7, #4]
  /* Get timeout */
  uint32_t tickstart = HAL_GetTick();
24007500:	f7f9 f9a6 	bl	24000850 <HAL_GetTick>
24007504:	60f8      	str	r0, [r7, #12]

  /* Wait for the FLASH Option Bytes change operation to complete by polling on OPT_BUSY flag to be reset */
  while(READ_BIT(FLASH->OPTSR_CUR, FLASH_OPTSR_OPT_BUSY) != 0U)
24007506:	e010      	b.n	2400752a <FLASH_OB_WaitForLastOperation+0x32>
  {
    if(Timeout != HAL_MAX_DELAY)
24007508:	687b      	ldr	r3, [r7, #4]
2400750a:	f1b3 3fff 	cmp.w	r3, #4294967295
2400750e:	d00c      	beq.n	2400752a <FLASH_OB_WaitForLastOperation+0x32>
    {
      if(((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
24007510:	f7f9 f99e 	bl	24000850 <HAL_GetTick>
24007514:	4602      	mov	r2, r0
24007516:	68fb      	ldr	r3, [r7, #12]
24007518:	1ad3      	subs	r3, r2, r3
2400751a:	687a      	ldr	r2, [r7, #4]
2400751c:	429a      	cmp	r2, r3
2400751e:	d302      	bcc.n	24007526 <FLASH_OB_WaitForLastOperation+0x2e>
24007520:	687b      	ldr	r3, [r7, #4]
24007522:	2b00      	cmp	r3, #0
24007524:	d101      	bne.n	2400752a <FLASH_OB_WaitForLastOperation+0x32>
      {
        return HAL_TIMEOUT;
24007526:	2303      	movs	r3, #3
24007528:	e01a      	b.n	24007560 <FLASH_OB_WaitForLastOperation+0x68>
  while(READ_BIT(FLASH->OPTSR_CUR, FLASH_OPTSR_OPT_BUSY) != 0U)
2400752a:	4b0f      	ldr	r3, [pc, #60]	; (24007568 <FLASH_OB_WaitForLastOperation+0x70>)
2400752c:	69db      	ldr	r3, [r3, #28]
2400752e:	f003 0301 	and.w	r3, r3, #1
24007532:	2b00      	cmp	r3, #0
24007534:	d1e8      	bne.n	24007508 <FLASH_OB_WaitForLastOperation+0x10>
      }
    }
  }

  /* Check option byte change error */
  if(READ_BIT(FLASH->OPTSR_CUR, FLASH_OPTSR_OPTCHANGEERR) != 0U)
24007536:	4b0c      	ldr	r3, [pc, #48]	; (24007568 <FLASH_OB_WaitForLastOperation+0x70>)
24007538:	69db      	ldr	r3, [r3, #28]
2400753a:	f003 4380 	and.w	r3, r3, #1073741824	; 0x40000000
2400753e:	2b00      	cmp	r3, #0
24007540:	d00d      	beq.n	2400755e <FLASH_OB_WaitForLastOperation+0x66>
  {
    /* Save the error code */
    pFlash.ErrorCode |= HAL_FLASH_ERROR_OB_CHANGE;
24007542:	4b0a      	ldr	r3, [pc, #40]	; (2400756c <FLASH_OB_WaitForLastOperation+0x74>)
24007544:	699b      	ldr	r3, [r3, #24]
24007546:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
2400754a:	4a08      	ldr	r2, [pc, #32]	; (2400756c <FLASH_OB_WaitForLastOperation+0x74>)
2400754c:	6193      	str	r3, [r2, #24]

    /* Clear the OB error flag */
    FLASH->OPTCCR |= FLASH_OPTCCR_CLR_OPTCHANGEERR;
2400754e:	4b06      	ldr	r3, [pc, #24]	; (24007568 <FLASH_OB_WaitForLastOperation+0x70>)
24007550:	6a5b      	ldr	r3, [r3, #36]	; 0x24
24007552:	4a05      	ldr	r2, [pc, #20]	; (24007568 <FLASH_OB_WaitForLastOperation+0x70>)
24007554:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
24007558:	6253      	str	r3, [r2, #36]	; 0x24

    return HAL_ERROR;
2400755a:	2301      	movs	r3, #1
2400755c:	e000      	b.n	24007560 <FLASH_OB_WaitForLastOperation+0x68>
  }

  /* If there is no error flag set */
  return HAL_OK;
2400755e:	2300      	movs	r3, #0
}
24007560:	4618      	mov	r0, r3
24007562:	3710      	adds	r7, #16
24007564:	46bd      	mov	sp, r7
24007566:	bd80      	pop	{r7, pc}
24007568:	52002000 	.word	0x52002000
2400756c:	24000548 	.word	0x24000548

24007570 <FLASH_CRC_WaitForLastOperation>:
  * @param  Timeout maximum flash operation timeout
  * @param  Bank flash FLASH_BANK_1 or FLASH_BANK_2
  * @retval HAL_StatusTypeDef HAL Status
  */
HAL_StatusTypeDef FLASH_CRC_WaitForLastOperation(uint32_t Timeout, uint32_t Bank)
{
24007570:	b580      	push	{r7, lr}
24007572:	b084      	sub	sp, #16
24007574:	af00      	add	r7, sp, #0
24007576:	6078      	str	r0, [r7, #4]
24007578:	6039      	str	r1, [r7, #0]
  uint32_t bsyflag;
  uint32_t tickstart = HAL_GetTick();
2400757a:	f7f9 f969 	bl	24000850 <HAL_GetTick>
2400757e:	60b8      	str	r0, [r7, #8]

  assert_param(IS_FLASH_BANK_EXCLUSIVE(Bank));

  /* Select bsyflag depending on Bank */
  if(Bank == FLASH_BANK_1)
24007580:	683b      	ldr	r3, [r7, #0]
24007582:	2b01      	cmp	r3, #1
24007584:	d102      	bne.n	2400758c <FLASH_CRC_WaitForLastOperation+0x1c>
  {
    bsyflag = FLASH_FLAG_CRC_BUSY_BANK1;
24007586:	2308      	movs	r3, #8
24007588:	60fb      	str	r3, [r7, #12]
2400758a:	e013      	b.n	240075b4 <FLASH_CRC_WaitForLastOperation+0x44>
  }
  else
  {
    bsyflag = FLASH_FLAG_CRC_BUSY_BANK2;
2400758c:	4b31      	ldr	r3, [pc, #196]	; (24007654 <FLASH_CRC_WaitForLastOperation+0xe4>)
2400758e:	60fb      	str	r3, [r7, #12]
  }

  /* Wait for the FLASH CRC computation to complete by polling on CRC_BUSY flag to be reset */
  while(__HAL_FLASH_GET_FLAG(bsyflag))
24007590:	e010      	b.n	240075b4 <FLASH_CRC_WaitForLastOperation+0x44>
  {
    if(Timeout != HAL_MAX_DELAY)
24007592:	687b      	ldr	r3, [r7, #4]
24007594:	f1b3 3fff 	cmp.w	r3, #4294967295
24007598:	d00c      	beq.n	240075b4 <FLASH_CRC_WaitForLastOperation+0x44>
    {
      if(((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
2400759a:	f7f9 f959 	bl	24000850 <HAL_GetTick>
2400759e:	4602      	mov	r2, r0
240075a0:	68bb      	ldr	r3, [r7, #8]
240075a2:	1ad3      	subs	r3, r2, r3
240075a4:	687a      	ldr	r2, [r7, #4]
240075a6:	429a      	cmp	r2, r3
240075a8:	d302      	bcc.n	240075b0 <FLASH_CRC_WaitForLastOperation+0x40>
240075aa:	687b      	ldr	r3, [r7, #4]
240075ac:	2b00      	cmp	r3, #0
240075ae:	d101      	bne.n	240075b4 <FLASH_CRC_WaitForLastOperation+0x44>
      {
        return HAL_TIMEOUT;
240075b0:	2303      	movs	r3, #3
240075b2:	e04b      	b.n	2400764c <FLASH_CRC_WaitForLastOperation+0xdc>
  while(__HAL_FLASH_GET_FLAG(bsyflag))
240075b4:	68fa      	ldr	r2, [r7, #12]
240075b6:	4b28      	ldr	r3, [pc, #160]	; (24007658 <FLASH_CRC_WaitForLastOperation+0xe8>)
240075b8:	4013      	ands	r3, r2
240075ba:	68fa      	ldr	r2, [r7, #12]
240075bc:	429a      	cmp	r2, r3
240075be:	d10a      	bne.n	240075d6 <FLASH_CRC_WaitForLastOperation+0x66>
240075c0:	4b26      	ldr	r3, [pc, #152]	; (2400765c <FLASH_CRC_WaitForLastOperation+0xec>)
240075c2:	691a      	ldr	r2, [r3, #16]
240075c4:	68fb      	ldr	r3, [r7, #12]
240075c6:	4013      	ands	r3, r2
240075c8:	68fa      	ldr	r2, [r7, #12]
240075ca:	429a      	cmp	r2, r3
240075cc:	bf0c      	ite	eq
240075ce:	2301      	moveq	r3, #1
240075d0:	2300      	movne	r3, #0
240075d2:	b2db      	uxtb	r3, r3
240075d4:	e00c      	b.n	240075f0 <FLASH_CRC_WaitForLastOperation+0x80>
240075d6:	4b21      	ldr	r3, [pc, #132]	; (2400765c <FLASH_CRC_WaitForLastOperation+0xec>)
240075d8:	f8d3 3110 	ldr.w	r3, [r3, #272]	; 0x110
240075dc:	43da      	mvns	r2, r3
240075de:	68fb      	ldr	r3, [r7, #12]
240075e0:	4013      	ands	r3, r2
240075e2:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
240075e6:	2b00      	cmp	r3, #0
240075e8:	bf0c      	ite	eq
240075ea:	2301      	moveq	r3, #1
240075ec:	2300      	movne	r3, #0
240075ee:	b2db      	uxtb	r3, r3
240075f0:	2b00      	cmp	r3, #0
240075f2:	d1ce      	bne.n	24007592 <FLASH_CRC_WaitForLastOperation+0x22>
      }
    }
  }

  /* Check FLASH CRC read error flag  */
  if(Bank == FLASH_BANK_1)
240075f4:	683b      	ldr	r3, [r7, #0]
240075f6:	2b01      	cmp	r3, #1
240075f8:	d112      	bne.n	24007620 <FLASH_CRC_WaitForLastOperation+0xb0>
  {
    if (__HAL_FLASH_GET_FLAG_BANK1(FLASH_FLAG_CRCRDERR_BANK1))
240075fa:	4b18      	ldr	r3, [pc, #96]	; (2400765c <FLASH_CRC_WaitForLastOperation+0xec>)
240075fc:	691b      	ldr	r3, [r3, #16]
240075fe:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
24007602:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
24007606:	d120      	bne.n	2400764a <FLASH_CRC_WaitForLastOperation+0xda>
    {
      /* Save the error code */
      pFlash.ErrorCode |= HAL_FLASH_ERROR_CRCRD_BANK1;
24007608:	4b15      	ldr	r3, [pc, #84]	; (24007660 <FLASH_CRC_WaitForLastOperation+0xf0>)
2400760a:	699b      	ldr	r3, [r3, #24]
2400760c:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
24007610:	4a13      	ldr	r2, [pc, #76]	; (24007660 <FLASH_CRC_WaitForLastOperation+0xf0>)
24007612:	6193      	str	r3, [r2, #24]

      /* Clear FLASH CRC read error pending bit */
      __HAL_FLASH_CLEAR_FLAG_BANK1(FLASH_FLAG_CRCRDERR_BANK1);
24007614:	4b11      	ldr	r3, [pc, #68]	; (2400765c <FLASH_CRC_WaitForLastOperation+0xec>)
24007616:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
2400761a:	615a      	str	r2, [r3, #20]

      return HAL_ERROR;
2400761c:	2301      	movs	r3, #1
2400761e:	e015      	b.n	2400764c <FLASH_CRC_WaitForLastOperation+0xdc>
    }
  }
  else
  {
    if (__HAL_FLASH_GET_FLAG_BANK2(FLASH_FLAG_CRCRDERR_BANK2))
24007620:	4b0e      	ldr	r3, [pc, #56]	; (2400765c <FLASH_CRC_WaitForLastOperation+0xec>)
24007622:	f8d3 3110 	ldr.w	r3, [r3, #272]	; 0x110
24007626:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
2400762a:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
2400762e:	d10c      	bne.n	2400764a <FLASH_CRC_WaitForLastOperation+0xda>
    {
      /* Save the error code */
      pFlash.ErrorCode |= HAL_FLASH_ERROR_CRCRD_BANK2;
24007630:	4b0b      	ldr	r3, [pc, #44]	; (24007660 <FLASH_CRC_WaitForLastOperation+0xf0>)
24007632:	699b      	ldr	r3, [r3, #24]
24007634:	f043 4310 	orr.w	r3, r3, #2415919104	; 0x90000000
24007638:	4a09      	ldr	r2, [pc, #36]	; (24007660 <FLASH_CRC_WaitForLastOperation+0xf0>)
2400763a:	6193      	str	r3, [r2, #24]

      /* Clear FLASH CRC read error pending bit */
      __HAL_FLASH_CLEAR_FLAG_BANK2(FLASH_FLAG_CRCRDERR_BANK2);
2400763c:	4b07      	ldr	r3, [pc, #28]	; (2400765c <FLASH_CRC_WaitForLastOperation+0xec>)
2400763e:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
24007642:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114

      return HAL_ERROR;
24007646:	2301      	movs	r3, #1
24007648:	e000      	b.n	2400764c <FLASH_CRC_WaitForLastOperation+0xdc>
    }
  }

  /* If there is no error flag set */
  return HAL_OK;
2400764a:	2300      	movs	r3, #0
}
2400764c:	4618      	mov	r0, r3
2400764e:	3710      	adds	r7, #16
24007650:	46bd      	mov	sp, r7
24007652:	bd80      	pop	{r7, pc}
24007654:	80000008 	.word	0x80000008
24007658:	1fef000f 	.word	0x1fef000f
2400765c:	52002000 	.word	0x52002000
24007660:	24000548 	.word	0x24000548

24007664 <HAL_FLASHEx_Erase>:
  *          the sectors have been correctly erased)
  *
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASHEx_Erase(FLASH_EraseInitTypeDef *pEraseInit, uint32_t *SectorError)
{
24007664:	b580      	push	{r7, lr}
24007666:	b084      	sub	sp, #16
24007668:	af00      	add	r7, sp, #0
2400766a:	6078      	str	r0, [r7, #4]
2400766c:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
2400766e:	2300      	movs	r3, #0
24007670:	73fb      	strb	r3, [r7, #15]
  /* Check the parameters */
  assert_param(IS_FLASH_TYPEERASE(pEraseInit->TypeErase));
  assert_param(IS_FLASH_BANK(pEraseInit->Banks));

  /* Process Locked */
  __HAL_LOCK(&pFlash);
24007672:	4b5e      	ldr	r3, [pc, #376]	; (240077ec <HAL_FLASHEx_Erase+0x188>)
24007674:	7d1b      	ldrb	r3, [r3, #20]
24007676:	2b01      	cmp	r3, #1
24007678:	d101      	bne.n	2400767e <HAL_FLASHEx_Erase+0x1a>
2400767a:	2302      	movs	r3, #2
2400767c:	e0b2      	b.n	240077e4 <HAL_FLASHEx_Erase+0x180>
2400767e:	4b5b      	ldr	r3, [pc, #364]	; (240077ec <HAL_FLASHEx_Erase+0x188>)
24007680:	2201      	movs	r2, #1
24007682:	751a      	strb	r2, [r3, #20]

  /* Reset error code */
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
24007684:	4b59      	ldr	r3, [pc, #356]	; (240077ec <HAL_FLASHEx_Erase+0x188>)
24007686:	2200      	movs	r2, #0
24007688:	619a      	str	r2, [r3, #24]

  /* Wait for last operation to be completed on Bank1 */
  if((pEraseInit->Banks & FLASH_BANK_1) == FLASH_BANK_1)
2400768a:	687b      	ldr	r3, [r7, #4]
2400768c:	685b      	ldr	r3, [r3, #4]
2400768e:	f003 0301 	and.w	r3, r3, #1
24007692:	2b00      	cmp	r3, #0
24007694:	d009      	beq.n	240076aa <HAL_FLASHEx_Erase+0x46>
  {
    if(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_1) != HAL_OK)
24007696:	2101      	movs	r1, #1
24007698:	f24c 3050 	movw	r0, #50000	; 0xc350
2400769c:	f7ff fe90 	bl	240073c0 <FLASH_WaitForLastOperation>
240076a0:	4603      	mov	r3, r0
240076a2:	2b00      	cmp	r3, #0
240076a4:	d001      	beq.n	240076aa <HAL_FLASHEx_Erase+0x46>
    {
      status = HAL_ERROR;
240076a6:	2301      	movs	r3, #1
240076a8:	73fb      	strb	r3, [r7, #15]
    }
  }

  /* Wait for last operation to be completed on Bank2 */
  if((pEraseInit->Banks & FLASH_BANK_2) == FLASH_BANK_2)
240076aa:	687b      	ldr	r3, [r7, #4]
240076ac:	685b      	ldr	r3, [r3, #4]
240076ae:	f003 0302 	and.w	r3, r3, #2
240076b2:	2b00      	cmp	r3, #0
240076b4:	d009      	beq.n	240076ca <HAL_FLASHEx_Erase+0x66>
  {
    if(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_2) != HAL_OK)
240076b6:	2102      	movs	r1, #2
240076b8:	f24c 3050 	movw	r0, #50000	; 0xc350
240076bc:	f7ff fe80 	bl	240073c0 <FLASH_WaitForLastOperation>
240076c0:	4603      	mov	r3, r0
240076c2:	2b00      	cmp	r3, #0
240076c4:	d001      	beq.n	240076ca <HAL_FLASHEx_Erase+0x66>
    {
      status = HAL_ERROR;
240076c6:	2301      	movs	r3, #1
240076c8:	73fb      	strb	r3, [r7, #15]
    }
  }

  if(status == HAL_OK)
240076ca:	7bfb      	ldrb	r3, [r7, #15]
240076cc:	2b00      	cmp	r3, #0
240076ce:	f040 8085 	bne.w	240077dc <HAL_FLASHEx_Erase+0x178>
  {
    if(pEraseInit->TypeErase == FLASH_TYPEERASE_MASSERASE)
240076d2:	687b      	ldr	r3, [r7, #4]
240076d4:	681b      	ldr	r3, [r3, #0]
240076d6:	2b01      	cmp	r3, #1
240076d8:	d136      	bne.n	24007748 <HAL_FLASHEx_Erase+0xe4>
    {
      /* Mass erase to be done */
      FLASH_MassErase(pEraseInit->VoltageRange, pEraseInit->Banks);
240076da:	687b      	ldr	r3, [r7, #4]
240076dc:	691a      	ldr	r2, [r3, #16]
240076de:	687b      	ldr	r3, [r7, #4]
240076e0:	685b      	ldr	r3, [r3, #4]
240076e2:	4619      	mov	r1, r3
240076e4:	4610      	mov	r0, r2
240076e6:	f000 fb85 	bl	24007df4 <FLASH_MassErase>

      /* Wait for last operation to be completed */
      if((pEraseInit->Banks & FLASH_BANK_1) == FLASH_BANK_1)
240076ea:	687b      	ldr	r3, [r7, #4]
240076ec:	685b      	ldr	r3, [r3, #4]
240076ee:	f003 0301 	and.w	r3, r3, #1
240076f2:	2b00      	cmp	r3, #0
240076f4:	d00f      	beq.n	24007716 <HAL_FLASHEx_Erase+0xb2>
      {
        if(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_1) != HAL_OK)
240076f6:	2101      	movs	r1, #1
240076f8:	f24c 3050 	movw	r0, #50000	; 0xc350
240076fc:	f7ff fe60 	bl	240073c0 <FLASH_WaitForLastOperation>
24007700:	4603      	mov	r3, r0
24007702:	2b00      	cmp	r3, #0
24007704:	d001      	beq.n	2400770a <HAL_FLASHEx_Erase+0xa6>
        {
          status = HAL_ERROR;
24007706:	2301      	movs	r3, #1
24007708:	73fb      	strb	r3, [r7, #15]
        }
        /* if the erase operation is completed, disable the Bank1 BER Bit */
        FLASH->CR1 &= (~FLASH_CR_BER);
2400770a:	4b39      	ldr	r3, [pc, #228]	; (240077f0 <HAL_FLASHEx_Erase+0x18c>)
2400770c:	68db      	ldr	r3, [r3, #12]
2400770e:	4a38      	ldr	r2, [pc, #224]	; (240077f0 <HAL_FLASHEx_Erase+0x18c>)
24007710:	f023 0308 	bic.w	r3, r3, #8
24007714:	60d3      	str	r3, [r2, #12]
      }
      if((pEraseInit->Banks & FLASH_BANK_2) == FLASH_BANK_2)
24007716:	687b      	ldr	r3, [r7, #4]
24007718:	685b      	ldr	r3, [r3, #4]
2400771a:	f003 0302 	and.w	r3, r3, #2
2400771e:	2b00      	cmp	r3, #0
24007720:	d05c      	beq.n	240077dc <HAL_FLASHEx_Erase+0x178>
      {
        if(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_2) != HAL_OK)
24007722:	2102      	movs	r1, #2
24007724:	f24c 3050 	movw	r0, #50000	; 0xc350
24007728:	f7ff fe4a 	bl	240073c0 <FLASH_WaitForLastOperation>
2400772c:	4603      	mov	r3, r0
2400772e:	2b00      	cmp	r3, #0
24007730:	d001      	beq.n	24007736 <HAL_FLASHEx_Erase+0xd2>
        {
          status = HAL_ERROR;
24007732:	2301      	movs	r3, #1
24007734:	73fb      	strb	r3, [r7, #15]
        }
        /* if the erase operation is completed, disable the Bank2 BER Bit */
        FLASH->CR2 &= (~FLASH_CR_BER);
24007736:	4b2e      	ldr	r3, [pc, #184]	; (240077f0 <HAL_FLASHEx_Erase+0x18c>)
24007738:	f8d3 310c 	ldr.w	r3, [r3, #268]	; 0x10c
2400773c:	4a2c      	ldr	r2, [pc, #176]	; (240077f0 <HAL_FLASHEx_Erase+0x18c>)
2400773e:	f023 0308 	bic.w	r3, r3, #8
24007742:	f8c2 310c 	str.w	r3, [r2, #268]	; 0x10c
24007746:	e049      	b.n	240077dc <HAL_FLASHEx_Erase+0x178>
      }
    }
    else
    {
      /*Initialization of SectorError variable*/
      *SectorError = 0xFFFFFFFFU;
24007748:	683b      	ldr	r3, [r7, #0]
2400774a:	f04f 32ff 	mov.w	r2, #4294967295
2400774e:	601a      	str	r2, [r3, #0]

      /* Erase by sector by sector to be done*/
      for(sector_index = pEraseInit->Sector; sector_index < (pEraseInit->NbSectors + pEraseInit->Sector); sector_index++)
24007750:	687b      	ldr	r3, [r7, #4]
24007752:	689b      	ldr	r3, [r3, #8]
24007754:	60bb      	str	r3, [r7, #8]
24007756:	e039      	b.n	240077cc <HAL_FLASHEx_Erase+0x168>
      {
        FLASH_Erase_Sector(sector_index, pEraseInit->Banks, pEraseInit->VoltageRange);
24007758:	687b      	ldr	r3, [r7, #4]
2400775a:	6859      	ldr	r1, [r3, #4]
2400775c:	687b      	ldr	r3, [r7, #4]
2400775e:	691b      	ldr	r3, [r3, #16]
24007760:	461a      	mov	r2, r3
24007762:	68b8      	ldr	r0, [r7, #8]
24007764:	f000 fbb0 	bl	24007ec8 <FLASH_Erase_Sector>

        if((pEraseInit->Banks & FLASH_BANK_1) == FLASH_BANK_1)
24007768:	687b      	ldr	r3, [r7, #4]
2400776a:	685b      	ldr	r3, [r3, #4]
2400776c:	f003 0301 	and.w	r3, r3, #1
24007770:	2b00      	cmp	r3, #0
24007772:	d00c      	beq.n	2400778e <HAL_FLASHEx_Erase+0x12a>
        {
          /* Wait for last operation to be completed */
          status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_1);
24007774:	2101      	movs	r1, #1
24007776:	f24c 3050 	movw	r0, #50000	; 0xc350
2400777a:	f7ff fe21 	bl	240073c0 <FLASH_WaitForLastOperation>
2400777e:	4603      	mov	r3, r0
24007780:	73fb      	strb	r3, [r7, #15]

          /* If the erase operation is completed, disable the SER Bit */
          FLASH->CR1 &= (~(FLASH_CR_SER | FLASH_CR_SNB));
24007782:	4b1b      	ldr	r3, [pc, #108]	; (240077f0 <HAL_FLASHEx_Erase+0x18c>)
24007784:	68da      	ldr	r2, [r3, #12]
24007786:	491a      	ldr	r1, [pc, #104]	; (240077f0 <HAL_FLASHEx_Erase+0x18c>)
24007788:	4b1a      	ldr	r3, [pc, #104]	; (240077f4 <HAL_FLASHEx_Erase+0x190>)
2400778a:	4013      	ands	r3, r2
2400778c:	60cb      	str	r3, [r1, #12]
        }
        if((pEraseInit->Banks & FLASH_BANK_2) == FLASH_BANK_2)
2400778e:	687b      	ldr	r3, [r7, #4]
24007790:	685b      	ldr	r3, [r3, #4]
24007792:	f003 0302 	and.w	r3, r3, #2
24007796:	2b00      	cmp	r3, #0
24007798:	d00e      	beq.n	240077b8 <HAL_FLASHEx_Erase+0x154>
        {
          /* Wait for last operation to be completed */
          status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_2);
2400779a:	2102      	movs	r1, #2
2400779c:	f24c 3050 	movw	r0, #50000	; 0xc350
240077a0:	f7ff fe0e 	bl	240073c0 <FLASH_WaitForLastOperation>
240077a4:	4603      	mov	r3, r0
240077a6:	73fb      	strb	r3, [r7, #15]

          /* If the erase operation is completed, disable the SER Bit */
          FLASH->CR2 &= (~(FLASH_CR_SER | FLASH_CR_SNB));
240077a8:	4b11      	ldr	r3, [pc, #68]	; (240077f0 <HAL_FLASHEx_Erase+0x18c>)
240077aa:	f8d3 210c 	ldr.w	r2, [r3, #268]	; 0x10c
240077ae:	4910      	ldr	r1, [pc, #64]	; (240077f0 <HAL_FLASHEx_Erase+0x18c>)
240077b0:	4b10      	ldr	r3, [pc, #64]	; (240077f4 <HAL_FLASHEx_Erase+0x190>)
240077b2:	4013      	ands	r3, r2
240077b4:	f8c1 310c 	str.w	r3, [r1, #268]	; 0x10c
        }

        if(status != HAL_OK)
240077b8:	7bfb      	ldrb	r3, [r7, #15]
240077ba:	2b00      	cmp	r3, #0
240077bc:	d003      	beq.n	240077c6 <HAL_FLASHEx_Erase+0x162>
        {
          /* In case of error, stop erase procedure and return the faulty sector */
          *SectorError = sector_index;
240077be:	683b      	ldr	r3, [r7, #0]
240077c0:	68ba      	ldr	r2, [r7, #8]
240077c2:	601a      	str	r2, [r3, #0]
          break;
240077c4:	e00a      	b.n	240077dc <HAL_FLASHEx_Erase+0x178>
      for(sector_index = pEraseInit->Sector; sector_index < (pEraseInit->NbSectors + pEraseInit->Sector); sector_index++)
240077c6:	68bb      	ldr	r3, [r7, #8]
240077c8:	3301      	adds	r3, #1
240077ca:	60bb      	str	r3, [r7, #8]
240077cc:	687b      	ldr	r3, [r7, #4]
240077ce:	68da      	ldr	r2, [r3, #12]
240077d0:	687b      	ldr	r3, [r7, #4]
240077d2:	689b      	ldr	r3, [r3, #8]
240077d4:	4413      	add	r3, r2
240077d6:	68ba      	ldr	r2, [r7, #8]
240077d8:	429a      	cmp	r2, r3
240077da:	d3bd      	bcc.n	24007758 <HAL_FLASHEx_Erase+0xf4>
      }
    }
  }

  /* Process Unlocked */
  __HAL_UNLOCK(&pFlash);
240077dc:	4b03      	ldr	r3, [pc, #12]	; (240077ec <HAL_FLASHEx_Erase+0x188>)
240077de:	2200      	movs	r2, #0
240077e0:	751a      	strb	r2, [r3, #20]

  return status;
240077e2:	7bfb      	ldrb	r3, [r7, #15]
}
240077e4:	4618      	mov	r0, r3
240077e6:	3710      	adds	r7, #16
240077e8:	46bd      	mov	sp, r7
240077ea:	bd80      	pop	{r7, pc}
240077ec:	24000548 	.word	0x24000548
240077f0:	52002000 	.word	0x52002000
240077f4:	fffff8fb 	.word	0xfffff8fb

240077f8 <HAL_FLASHEx_Erase_IT>:
  *         contains the configuration information for the erasing.
  *
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASHEx_Erase_IT(FLASH_EraseInitTypeDef *pEraseInit)
{
240077f8:	b580      	push	{r7, lr}
240077fa:	b084      	sub	sp, #16
240077fc:	af00      	add	r7, sp, #0
240077fe:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
24007800:	2300      	movs	r3, #0
24007802:	73fb      	strb	r3, [r7, #15]
  /* Check the parameters */
  assert_param(IS_FLASH_TYPEERASE(pEraseInit->TypeErase));
  assert_param(IS_FLASH_BANK(pEraseInit->Banks));

  /* Process Locked */
  __HAL_LOCK(&pFlash);
24007804:	4b48      	ldr	r3, [pc, #288]	; (24007928 <HAL_FLASHEx_Erase_IT+0x130>)
24007806:	7d1b      	ldrb	r3, [r3, #20]
24007808:	2b01      	cmp	r3, #1
2400780a:	d101      	bne.n	24007810 <HAL_FLASHEx_Erase_IT+0x18>
2400780c:	2302      	movs	r3, #2
2400780e:	e087      	b.n	24007920 <HAL_FLASHEx_Erase_IT+0x128>
24007810:	4b45      	ldr	r3, [pc, #276]	; (24007928 <HAL_FLASHEx_Erase_IT+0x130>)
24007812:	2201      	movs	r2, #1
24007814:	751a      	strb	r2, [r3, #20]

  /* Reset error code */
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
24007816:	4b44      	ldr	r3, [pc, #272]	; (24007928 <HAL_FLASHEx_Erase_IT+0x130>)
24007818:	2200      	movs	r2, #0
2400781a:	619a      	str	r2, [r3, #24]

  /* Wait for last operation to be completed */
  if((pEraseInit->Banks & FLASH_BANK_1) == FLASH_BANK_1)
2400781c:	687b      	ldr	r3, [r7, #4]
2400781e:	685b      	ldr	r3, [r3, #4]
24007820:	f003 0301 	and.w	r3, r3, #1
24007824:	2b00      	cmp	r3, #0
24007826:	d009      	beq.n	2400783c <HAL_FLASHEx_Erase_IT+0x44>
  {
    if(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_1) != HAL_OK)
24007828:	2101      	movs	r1, #1
2400782a:	f24c 3050 	movw	r0, #50000	; 0xc350
2400782e:	f7ff fdc7 	bl	240073c0 <FLASH_WaitForLastOperation>
24007832:	4603      	mov	r3, r0
24007834:	2b00      	cmp	r3, #0
24007836:	d001      	beq.n	2400783c <HAL_FLASHEx_Erase_IT+0x44>
    {
      status = HAL_ERROR;
24007838:	2301      	movs	r3, #1
2400783a:	73fb      	strb	r3, [r7, #15]
    }
  }

  if((pEraseInit->Banks & FLASH_BANK_2) == FLASH_BANK_2)
2400783c:	687b      	ldr	r3, [r7, #4]
2400783e:	685b      	ldr	r3, [r3, #4]
24007840:	f003 0302 	and.w	r3, r3, #2
24007844:	2b00      	cmp	r3, #0
24007846:	d009      	beq.n	2400785c <HAL_FLASHEx_Erase_IT+0x64>
  {
    if(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_2) != HAL_OK)
24007848:	2102      	movs	r1, #2
2400784a:	f24c 3050 	movw	r0, #50000	; 0xc350
2400784e:	f7ff fdb7 	bl	240073c0 <FLASH_WaitForLastOperation>
24007852:	4603      	mov	r3, r0
24007854:	2b00      	cmp	r3, #0
24007856:	d001      	beq.n	2400785c <HAL_FLASHEx_Erase_IT+0x64>
    {
      status = HAL_ERROR;
24007858:	2301      	movs	r3, #1
2400785a:	73fb      	strb	r3, [r7, #15]
    }
  }

  if (status != HAL_OK)
2400785c:	7bfb      	ldrb	r3, [r7, #15]
2400785e:	2b00      	cmp	r3, #0
24007860:	d003      	beq.n	2400786a <HAL_FLASHEx_Erase_IT+0x72>
  {
    /* Process Unlocked */
    __HAL_UNLOCK(&pFlash);
24007862:	4b31      	ldr	r3, [pc, #196]	; (24007928 <HAL_FLASHEx_Erase_IT+0x130>)
24007864:	2200      	movs	r2, #0
24007866:	751a      	strb	r2, [r3, #20]
24007868:	e059      	b.n	2400791e <HAL_FLASHEx_Erase_IT+0x126>
  }
  else
  {
    if((pEraseInit->Banks & FLASH_BANK_1) == FLASH_BANK_1)
2400786a:	687b      	ldr	r3, [r7, #4]
2400786c:	685b      	ldr	r3, [r3, #4]
2400786e:	f003 0301 	and.w	r3, r3, #1
24007872:	2b00      	cmp	r3, #0
24007874:	d005      	beq.n	24007882 <HAL_FLASHEx_Erase_IT+0x8a>
    {
      /* Enable End of Operation and Error interrupts for Bank 1 */
#if defined (FLASH_CR_OPERRIE)
      __HAL_FLASH_ENABLE_IT_BANK1(FLASH_IT_EOP_BANK1     | FLASH_IT_WRPERR_BANK1 | FLASH_IT_PGSERR_BANK1 | \
24007876:	4b2d      	ldr	r3, [pc, #180]	; (2400792c <HAL_FLASHEx_Erase_IT+0x134>)
24007878:	68db      	ldr	r3, [r3, #12]
2400787a:	4a2c      	ldr	r2, [pc, #176]	; (2400792c <HAL_FLASHEx_Erase_IT+0x134>)
2400787c:	f443 03de 	orr.w	r3, r3, #7274496	; 0x6f0000
24007880:	60d3      	str	r3, [r2, #12]
#else
      __HAL_FLASH_ENABLE_IT_BANK1(FLASH_IT_EOP_BANK1     | FLASH_IT_WRPERR_BANK1 | FLASH_IT_PGSERR_BANK1 | \
                                  FLASH_IT_STRBERR_BANK1 | FLASH_IT_INCERR_BANK1);
#endif /* FLASH_CR_OPERRIE */
    }
    if((pEraseInit->Banks & FLASH_BANK_2) == FLASH_BANK_2)
24007882:	687b      	ldr	r3, [r7, #4]
24007884:	685b      	ldr	r3, [r3, #4]
24007886:	f003 0302 	and.w	r3, r3, #2
2400788a:	2b00      	cmp	r3, #0
2400788c:	d007      	beq.n	2400789e <HAL_FLASHEx_Erase_IT+0xa6>
    {
      /* Enable End of Operation and Error interrupts for Bank 2 */
#if defined (FLASH_CR_OPERRIE)
      __HAL_FLASH_ENABLE_IT_BANK2(FLASH_IT_EOP_BANK2     | FLASH_IT_WRPERR_BANK2 | FLASH_IT_PGSERR_BANK2 | \
2400788e:	4b27      	ldr	r3, [pc, #156]	; (2400792c <HAL_FLASHEx_Erase_IT+0x134>)
24007890:	f8d3 310c 	ldr.w	r3, [r3, #268]	; 0x10c
24007894:	4a25      	ldr	r2, [pc, #148]	; (2400792c <HAL_FLASHEx_Erase_IT+0x134>)
24007896:	f443 03de 	orr.w	r3, r3, #7274496	; 0x6f0000
2400789a:	f8c2 310c 	str.w	r3, [r2, #268]	; 0x10c
      __HAL_FLASH_ENABLE_IT_BANK2(FLASH_IT_EOP_BANK2     | FLASH_IT_WRPERR_BANK2 | FLASH_IT_PGSERR_BANK2 | \
                                  FLASH_IT_STRBERR_BANK2 | FLASH_IT_INCERR_BANK2);
#endif /* FLASH_CR_OPERRIE */
    }

    if(pEraseInit->TypeErase == FLASH_TYPEERASE_MASSERASE)
2400789e:	687b      	ldr	r3, [r7, #4]
240078a0:	681b      	ldr	r3, [r3, #0]
240078a2:	2b01      	cmp	r3, #1
240078a4:	d11b      	bne.n	240078de <HAL_FLASHEx_Erase_IT+0xe6>
    {
      /*Mass erase to be done*/
      if(pEraseInit->Banks == FLASH_BANK_1)
240078a6:	687b      	ldr	r3, [r7, #4]
240078a8:	685b      	ldr	r3, [r3, #4]
240078aa:	2b01      	cmp	r3, #1
240078ac:	d103      	bne.n	240078b6 <HAL_FLASHEx_Erase_IT+0xbe>
      {
        pFlash.ProcedureOnGoing = FLASH_PROC_MASSERASE_BANK1;
240078ae:	4b1e      	ldr	r3, [pc, #120]	; (24007928 <HAL_FLASHEx_Erase_IT+0x130>)
240078b0:	2202      	movs	r2, #2
240078b2:	701a      	strb	r2, [r3, #0]
240078b4:	e00a      	b.n	240078cc <HAL_FLASHEx_Erase_IT+0xd4>
      }
      else if(pEraseInit->Banks == FLASH_BANK_2)
240078b6:	687b      	ldr	r3, [r7, #4]
240078b8:	685b      	ldr	r3, [r3, #4]
240078ba:	2b02      	cmp	r3, #2
240078bc:	d103      	bne.n	240078c6 <HAL_FLASHEx_Erase_IT+0xce>
      {
        pFlash.ProcedureOnGoing = FLASH_PROC_MASSERASE_BANK2;
240078be:	4b1a      	ldr	r3, [pc, #104]	; (24007928 <HAL_FLASHEx_Erase_IT+0x130>)
240078c0:	2205      	movs	r2, #5
240078c2:	701a      	strb	r2, [r3, #0]
240078c4:	e002      	b.n	240078cc <HAL_FLASHEx_Erase_IT+0xd4>
      }
      else
      {
        pFlash.ProcedureOnGoing = FLASH_PROC_ALLBANK_MASSERASE;
240078c6:	4b18      	ldr	r3, [pc, #96]	; (24007928 <HAL_FLASHEx_Erase_IT+0x130>)
240078c8:	2207      	movs	r2, #7
240078ca:	701a      	strb	r2, [r3, #0]
      }

      FLASH_MassErase(pEraseInit->VoltageRange, pEraseInit->Banks);
240078cc:	687b      	ldr	r3, [r7, #4]
240078ce:	691a      	ldr	r2, [r3, #16]
240078d0:	687b      	ldr	r3, [r7, #4]
240078d2:	685b      	ldr	r3, [r3, #4]
240078d4:	4619      	mov	r1, r3
240078d6:	4610      	mov	r0, r2
240078d8:	f000 fa8c 	bl	24007df4 <FLASH_MassErase>
240078dc:	e01f      	b.n	2400791e <HAL_FLASHEx_Erase_IT+0x126>
    }
    else
    {
      /* Erase by sector to be done */
      if(pEraseInit->Banks == FLASH_BANK_1)
240078de:	687b      	ldr	r3, [r7, #4]
240078e0:	685b      	ldr	r3, [r3, #4]
240078e2:	2b01      	cmp	r3, #1
240078e4:	d103      	bne.n	240078ee <HAL_FLASHEx_Erase_IT+0xf6>
      {
        pFlash.ProcedureOnGoing = FLASH_PROC_SECTERASE_BANK1;
240078e6:	4b10      	ldr	r3, [pc, #64]	; (24007928 <HAL_FLASHEx_Erase_IT+0x130>)
240078e8:	2201      	movs	r2, #1
240078ea:	701a      	strb	r2, [r3, #0]
240078ec:	e002      	b.n	240078f4 <HAL_FLASHEx_Erase_IT+0xfc>
      }
      else
      {
        pFlash.ProcedureOnGoing = FLASH_PROC_SECTERASE_BANK2;
240078ee:	4b0e      	ldr	r3, [pc, #56]	; (24007928 <HAL_FLASHEx_Erase_IT+0x130>)
240078f0:	2204      	movs	r2, #4
240078f2:	701a      	strb	r2, [r3, #0]
      }

      pFlash.NbSectorsToErase = pEraseInit->NbSectors;
240078f4:	687b      	ldr	r3, [r7, #4]
240078f6:	68db      	ldr	r3, [r3, #12]
240078f8:	4a0b      	ldr	r2, [pc, #44]	; (24007928 <HAL_FLASHEx_Erase_IT+0x130>)
240078fa:	6053      	str	r3, [r2, #4]
      pFlash.Sector = pEraseInit->Sector;
240078fc:	687b      	ldr	r3, [r7, #4]
240078fe:	689b      	ldr	r3, [r3, #8]
24007900:	4a09      	ldr	r2, [pc, #36]	; (24007928 <HAL_FLASHEx_Erase_IT+0x130>)
24007902:	60d3      	str	r3, [r2, #12]
      pFlash.VoltageForErase = pEraseInit->VoltageRange;
24007904:	687b      	ldr	r3, [r7, #4]
24007906:	691b      	ldr	r3, [r3, #16]
24007908:	4a07      	ldr	r2, [pc, #28]	; (24007928 <HAL_FLASHEx_Erase_IT+0x130>)
2400790a:	6093      	str	r3, [r2, #8]

      /* Erase first sector and wait for IT */
      FLASH_Erase_Sector(pEraseInit->Sector, pEraseInit->Banks, pEraseInit->VoltageRange);
2400790c:	687b      	ldr	r3, [r7, #4]
2400790e:	6898      	ldr	r0, [r3, #8]
24007910:	687b      	ldr	r3, [r7, #4]
24007912:	6859      	ldr	r1, [r3, #4]
24007914:	687b      	ldr	r3, [r7, #4]
24007916:	691b      	ldr	r3, [r3, #16]
24007918:	461a      	mov	r2, r3
2400791a:	f000 fad5 	bl	24007ec8 <FLASH_Erase_Sector>
    }
  }

  return status;
2400791e:	7bfb      	ldrb	r3, [r7, #15]
}
24007920:	4618      	mov	r0, r3
24007922:	3710      	adds	r7, #16
24007924:	46bd      	mov	sp, r7
24007926:	bd80      	pop	{r7, pc}
24007928:	24000548 	.word	0x24000548
2400792c:	52002000 	.word	0x52002000

24007930 <HAL_FLASHEx_OBProgram>:
  *         contains the configuration information for the programming.
  *
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASHEx_OBProgram(FLASH_OBProgramInitTypeDef *pOBInit)
{
24007930:	b580      	push	{r7, lr}
24007932:	b084      	sub	sp, #16
24007934:	af00      	add	r7, sp, #0
24007936:	6078      	str	r0, [r7, #4]

  /* Check the parameters */
  assert_param(IS_OPTIONBYTE(pOBInit->OptionType));

  /* Process Locked */
  __HAL_LOCK(&pFlash);
24007938:	4b4e      	ldr	r3, [pc, #312]	; (24007a74 <HAL_FLASHEx_OBProgram+0x144>)
2400793a:	7d1b      	ldrb	r3, [r3, #20]
2400793c:	2b01      	cmp	r3, #1
2400793e:	d101      	bne.n	24007944 <HAL_FLASHEx_OBProgram+0x14>
24007940:	2302      	movs	r3, #2
24007942:	e092      	b.n	24007a6a <HAL_FLASHEx_OBProgram+0x13a>
24007944:	4b4b      	ldr	r3, [pc, #300]	; (24007a74 <HAL_FLASHEx_OBProgram+0x144>)
24007946:	2201      	movs	r2, #1
24007948:	751a      	strb	r2, [r3, #20]

  /* Reset Error Code */
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
2400794a:	4b4a      	ldr	r3, [pc, #296]	; (24007a74 <HAL_FLASHEx_OBProgram+0x144>)
2400794c:	2200      	movs	r2, #0
2400794e:	619a      	str	r2, [r3, #24]

  /* Wait for last operation to be completed */
  if(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_1) != HAL_OK)
24007950:	2101      	movs	r1, #1
24007952:	f24c 3050 	movw	r0, #50000	; 0xc350
24007956:	f7ff fd33 	bl	240073c0 <FLASH_WaitForLastOperation>
2400795a:	4603      	mov	r3, r0
2400795c:	2b00      	cmp	r3, #0
2400795e:	d002      	beq.n	24007966 <HAL_FLASHEx_OBProgram+0x36>
  {
    status = HAL_ERROR;
24007960:	2301      	movs	r3, #1
24007962:	73fb      	strb	r3, [r7, #15]
24007964:	e00c      	b.n	24007980 <HAL_FLASHEx_OBProgram+0x50>
  }
  else if(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_2) != HAL_OK)
24007966:	2102      	movs	r1, #2
24007968:	f24c 3050 	movw	r0, #50000	; 0xc350
2400796c:	f7ff fd28 	bl	240073c0 <FLASH_WaitForLastOperation>
24007970:	4603      	mov	r3, r0
24007972:	2b00      	cmp	r3, #0
24007974:	d002      	beq.n	2400797c <HAL_FLASHEx_OBProgram+0x4c>
  {
    status = HAL_ERROR;
24007976:	2301      	movs	r3, #1
24007978:	73fb      	strb	r3, [r7, #15]
2400797a:	e001      	b.n	24007980 <HAL_FLASHEx_OBProgram+0x50>
  }
  else
  {
    status = HAL_OK;
2400797c:	2300      	movs	r3, #0
2400797e:	73fb      	strb	r3, [r7, #15]
  }

  if(status == HAL_OK)
24007980:	7bfb      	ldrb	r3, [r7, #15]
24007982:	2b00      	cmp	r3, #0
24007984:	d16d      	bne.n	24007a62 <HAL_FLASHEx_OBProgram+0x132>
  {
    /*Write protection configuration*/
    if((pOBInit->OptionType & OPTIONBYTE_WRP) == OPTIONBYTE_WRP)
24007986:	687b      	ldr	r3, [r7, #4]
24007988:	681b      	ldr	r3, [r3, #0]
2400798a:	f003 0301 	and.w	r3, r3, #1
2400798e:	2b00      	cmp	r3, #0
24007990:	d014      	beq.n	240079bc <HAL_FLASHEx_OBProgram+0x8c>
    {
      assert_param(IS_WRPSTATE(pOBInit->WRPState));

      if(pOBInit->WRPState == OB_WRPSTATE_ENABLE)
24007992:	687b      	ldr	r3, [r7, #4]
24007994:	685b      	ldr	r3, [r3, #4]
24007996:	2b01      	cmp	r3, #1
24007998:	d108      	bne.n	240079ac <HAL_FLASHEx_OBProgram+0x7c>
      {
        /*Enable of Write protection on the selected Sector*/
        FLASH_OB_EnableWRP(pOBInit->WRPSector,pOBInit->Banks);
2400799a:	687b      	ldr	r3, [r7, #4]
2400799c:	689a      	ldr	r2, [r3, #8]
2400799e:	687b      	ldr	r3, [r7, #4]
240079a0:	69db      	ldr	r3, [r3, #28]
240079a2:	4619      	mov	r1, r3
240079a4:	4610      	mov	r0, r2
240079a6:	f000 facd 	bl	24007f44 <FLASH_OB_EnableWRP>
240079aa:	e007      	b.n	240079bc <HAL_FLASHEx_OBProgram+0x8c>
      }
      else
      {
        /*Disable of Write protection on the selected Sector*/
        FLASH_OB_DisableWRP(pOBInit->WRPSector, pOBInit->Banks);
240079ac:	687b      	ldr	r3, [r7, #4]
240079ae:	689a      	ldr	r2, [r3, #8]
240079b0:	687b      	ldr	r3, [r7, #4]
240079b2:	69db      	ldr	r3, [r3, #28]
240079b4:	4619      	mov	r1, r3
240079b6:	4610      	mov	r0, r2
240079b8:	f000 faee 	bl	24007f98 <FLASH_OB_DisableWRP>
      }
    }

    /* Read protection configuration */
    if((pOBInit->OptionType & OPTIONBYTE_RDP) != 0U)
240079bc:	687b      	ldr	r3, [r7, #4]
240079be:	681b      	ldr	r3, [r3, #0]
240079c0:	f003 0302 	and.w	r3, r3, #2
240079c4:	2b00      	cmp	r3, #0
240079c6:	d004      	beq.n	240079d2 <HAL_FLASHEx_OBProgram+0xa2>
    {
      /* Configure the Read protection level */
      FLASH_OB_RDPConfig(pOBInit->RDPLevel);
240079c8:	687b      	ldr	r3, [r7, #4]
240079ca:	68db      	ldr	r3, [r3, #12]
240079cc:	4618      	mov	r0, r3
240079ce:	f000 fb3d 	bl	2400804c <FLASH_OB_RDPConfig>
    }

    /* User Configuration */
    if((pOBInit->OptionType & OPTIONBYTE_USER) != 0U)
240079d2:	687b      	ldr	r3, [r7, #4]
240079d4:	681b      	ldr	r3, [r3, #0]
240079d6:	f003 0304 	and.w	r3, r3, #4
240079da:	2b00      	cmp	r3, #0
240079dc:	d007      	beq.n	240079ee <HAL_FLASHEx_OBProgram+0xbe>
    {
      /* Configure the user option bytes */
      FLASH_OB_UserConfig(pOBInit->USERType, pOBInit->USERConfig);
240079de:	687b      	ldr	r3, [r7, #4]
240079e0:	695a      	ldr	r2, [r3, #20]
240079e2:	687b      	ldr	r3, [r7, #4]
240079e4:	699b      	ldr	r3, [r3, #24]
240079e6:	4619      	mov	r1, r3
240079e8:	4610      	mov	r0, r2
240079ea:	f000 fb5f 	bl	240080ac <FLASH_OB_UserConfig>
    }

    /* PCROP Configuration */
    if((pOBInit->OptionType & OPTIONBYTE_PCROP) != 0U)
240079ee:	687b      	ldr	r3, [r7, #4]
240079f0:	681b      	ldr	r3, [r3, #0]
240079f2:	f003 0308 	and.w	r3, r3, #8
240079f6:	2b00      	cmp	r3, #0
240079f8:	d009      	beq.n	24007a0e <HAL_FLASHEx_OBProgram+0xde>
    {
      assert_param(IS_FLASH_BANK(pOBInit->Banks));

      /*Configure the Proprietary code readout protection */
      FLASH_OB_PCROPConfig(pOBInit->PCROPConfig, pOBInit->PCROPStartAddr, pOBInit->PCROPEndAddr, pOBInit->Banks);
240079fa:	687b      	ldr	r3, [r7, #4]
240079fc:	6a18      	ldr	r0, [r3, #32]
240079fe:	687b      	ldr	r3, [r7, #4]
24007a00:	6a59      	ldr	r1, [r3, #36]	; 0x24
24007a02:	687b      	ldr	r3, [r7, #4]
24007a04:	6a9a      	ldr	r2, [r3, #40]	; 0x28
24007a06:	687b      	ldr	r3, [r7, #4]
24007a08:	69db      	ldr	r3, [r3, #28]
24007a0a:	f000 fc07 	bl	2400821c <FLASH_OB_PCROPConfig>
    }

    /* BOR Level configuration */
    if((pOBInit->OptionType & OPTIONBYTE_BOR) == OPTIONBYTE_BOR)
24007a0e:	687b      	ldr	r3, [r7, #4]
24007a10:	681b      	ldr	r3, [r3, #0]
24007a12:	f003 0310 	and.w	r3, r3, #16
24007a16:	2b00      	cmp	r3, #0
24007a18:	d004      	beq.n	24007a24 <HAL_FLASHEx_OBProgram+0xf4>
    {
      FLASH_OB_BOR_LevelConfig(pOBInit->BORLevel);
24007a1a:	687b      	ldr	r3, [r7, #4]
24007a1c:	691b      	ldr	r3, [r3, #16]
24007a1e:	4618      	mov	r0, r3
24007a20:	f000 fc78 	bl	24008314 <FLASH_OB_BOR_LevelConfig>
    {
      FLASH_OB_CM4BootAddConfig(pOBInit->CM4BootConfig, pOBInit->CM4BootAddr0, pOBInit->CM4BootAddr1);
    }
#else /* Single Core*/
    /* Boot Address  configuration */
    if((pOBInit->OptionType & OPTIONBYTE_BOOTADD) == OPTIONBYTE_BOOTADD)
24007a24:	687b      	ldr	r3, [r7, #4]
24007a26:	681b      	ldr	r3, [r3, #0]
24007a28:	f003 0340 	and.w	r3, r3, #64	; 0x40
24007a2c:	2b00      	cmp	r3, #0
24007a2e:	d008      	beq.n	24007a42 <HAL_FLASHEx_OBProgram+0x112>
    {
      FLASH_OB_BootAddConfig(pOBInit->BootConfig, pOBInit->BootAddr0, pOBInit->BootAddr1);
24007a30:	687b      	ldr	r3, [r7, #4]
24007a32:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
24007a34:	687b      	ldr	r3, [r7, #4]
24007a36:	6b19      	ldr	r1, [r3, #48]	; 0x30
24007a38:	687b      	ldr	r3, [r7, #4]
24007a3a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
24007a3c:	461a      	mov	r2, r3
24007a3e:	f000 fc8b 	bl	24008358 <FLASH_OB_BootAddConfig>
    }
#endif /*DUAL_CORE*/

    /* Secure area configuration */
    if((pOBInit->OptionType & OPTIONBYTE_SECURE_AREA) == OPTIONBYTE_SECURE_AREA)
24007a42:	687b      	ldr	r3, [r7, #4]
24007a44:	681b      	ldr	r3, [r3, #0]
24007a46:	f003 0320 	and.w	r3, r3, #32
24007a4a:	2b00      	cmp	r3, #0
24007a4c:	d009      	beq.n	24007a62 <HAL_FLASHEx_OBProgram+0x132>
    {
      FLASH_OB_SecureAreaConfig(pOBInit->SecureAreaConfig, pOBInit->SecureAreaStartAddr, pOBInit->SecureAreaEndAddr,pOBInit->Banks);
24007a4e:	687b      	ldr	r3, [r7, #4]
24007a50:	6b98      	ldr	r0, [r3, #56]	; 0x38
24007a52:	687b      	ldr	r3, [r7, #4]
24007a54:	6bd9      	ldr	r1, [r3, #60]	; 0x3c
24007a56:	687b      	ldr	r3, [r7, #4]
24007a58:	6c1a      	ldr	r2, [r3, #64]	; 0x40
24007a5a:	687b      	ldr	r3, [r7, #4]
24007a5c:	69db      	ldr	r3, [r3, #28]
24007a5e:	f000 fcc1 	bl	240083e4 <FLASH_OB_SecureAreaConfig>
    }
#endif /* FLASH_OTPBL_LOCKBL */
  }

  /* Process Unlocked */
  __HAL_UNLOCK(&pFlash);
24007a62:	4b04      	ldr	r3, [pc, #16]	; (24007a74 <HAL_FLASHEx_OBProgram+0x144>)
24007a64:	2200      	movs	r2, #0
24007a66:	751a      	strb	r2, [r3, #20]

  return status;
24007a68:	7bfb      	ldrb	r3, [r7, #15]
}
24007a6a:	4618      	mov	r0, r3
24007a6c:	3710      	adds	r7, #16
24007a6e:	46bd      	mov	sp, r7
24007a70:	bd80      	pop	{r7, pc}
24007a72:	bf00      	nop
24007a74:	24000548 	.word	0x24000548

24007a78 <HAL_FLASHEx_OBGetConfig>:
  *         as this parameter is use to get the given Bank WRP, PCROP and secured area configuration.
  *
  * @retval None
  */
void HAL_FLASHEx_OBGetConfig(FLASH_OBProgramInitTypeDef *pOBInit)
{
24007a78:	b580      	push	{r7, lr}
24007a7a:	b082      	sub	sp, #8
24007a7c:	af00      	add	r7, sp, #0
24007a7e:	6078      	str	r0, [r7, #4]
  pOBInit->OptionType = (OPTIONBYTE_USER | OPTIONBYTE_RDP | OPTIONBYTE_BOR);
24007a80:	687b      	ldr	r3, [r7, #4]
24007a82:	2216      	movs	r2, #22
24007a84:	601a      	str	r2, [r3, #0]

  /* Get Read protection level */
  pOBInit->RDPLevel = FLASH_OB_GetRDP();
24007a86:	f000 faf5 	bl	24008074 <FLASH_OB_GetRDP>
24007a8a:	4602      	mov	r2, r0
24007a8c:	687b      	ldr	r3, [r7, #4]
24007a8e:	60da      	str	r2, [r3, #12]

  /* Get the user option bytes */
  pOBInit->USERConfig = FLASH_OB_GetUser();
24007a90:	f000 fbae 	bl	240081f0 <FLASH_OB_GetUser>
24007a94:	4602      	mov	r2, r0
24007a96:	687b      	ldr	r3, [r7, #4]
24007a98:	619a      	str	r2, [r3, #24]

  /*Get BOR Level*/
  pOBInit->BORLevel = FLASH_OB_GetBOR();
24007a9a:	f000 fc4f 	bl	2400833c <FLASH_OB_GetBOR>
24007a9e:	4602      	mov	r2, r0
24007aa0:	687b      	ldr	r3, [r7, #4]
24007aa2:	611a      	str	r2, [r3, #16]

  if ((pOBInit->Banks == FLASH_BANK_1) || (pOBInit->Banks == FLASH_BANK_2))
24007aa4:	687b      	ldr	r3, [r7, #4]
24007aa6:	69db      	ldr	r3, [r3, #28]
24007aa8:	2b01      	cmp	r3, #1
24007aaa:	d003      	beq.n	24007ab4 <HAL_FLASHEx_OBGetConfig+0x3c>
24007aac:	687b      	ldr	r3, [r7, #4]
24007aae:	69db      	ldr	r3, [r3, #28]
24007ab0:	2b02      	cmp	r3, #2
24007ab2:	d129      	bne.n	24007b08 <HAL_FLASHEx_OBGetConfig+0x90>
  {
    pOBInit->OptionType |= (OPTIONBYTE_WRP | OPTIONBYTE_PCROP | OPTIONBYTE_SECURE_AREA);
24007ab4:	687b      	ldr	r3, [r7, #4]
24007ab6:	681b      	ldr	r3, [r3, #0]
24007ab8:	f043 0229 	orr.w	r2, r3, #41	; 0x29
24007abc:	687b      	ldr	r3, [r7, #4]
24007abe:	601a      	str	r2, [r3, #0]

    /* Get write protection on the selected area */
    FLASH_OB_GetWRP(&(pOBInit->WRPState), &(pOBInit->WRPSector), pOBInit->Banks);
24007ac0:	687b      	ldr	r3, [r7, #4]
24007ac2:	1d18      	adds	r0, r3, #4
24007ac4:	687b      	ldr	r3, [r7, #4]
24007ac6:	f103 0108 	add.w	r1, r3, #8
24007aca:	687b      	ldr	r3, [r7, #4]
24007acc:	69db      	ldr	r3, [r3, #28]
24007ace:	461a      	mov	r2, r3
24007ad0:	f000 fa8a 	bl	24007fe8 <FLASH_OB_GetWRP>

    /* Get the Proprietary code readout protection */
    FLASH_OB_GetPCROP(&(pOBInit->PCROPConfig), &(pOBInit->PCROPStartAddr), &(pOBInit->PCROPEndAddr), pOBInit->Banks);
24007ad4:	687b      	ldr	r3, [r7, #4]
24007ad6:	f103 0020 	add.w	r0, r3, #32
24007ada:	687b      	ldr	r3, [r7, #4]
24007adc:	f103 0124 	add.w	r1, r3, #36	; 0x24
24007ae0:	687b      	ldr	r3, [r7, #4]
24007ae2:	f103 0228 	add.w	r2, r3, #40	; 0x28
24007ae6:	687b      	ldr	r3, [r7, #4]
24007ae8:	69db      	ldr	r3, [r3, #28]
24007aea:	f000 fbcd 	bl	24008288 <FLASH_OB_GetPCROP>

    /*Get Bank Secure area*/
    FLASH_OB_GetSecureArea(&(pOBInit->SecureAreaConfig), &(pOBInit->SecureAreaStartAddr), &(pOBInit->SecureAreaEndAddr), pOBInit->Banks);
24007aee:	687b      	ldr	r3, [r7, #4]
24007af0:	f103 0038 	add.w	r0, r3, #56	; 0x38
24007af4:	687b      	ldr	r3, [r7, #4]
24007af6:	f103 013c 	add.w	r1, r3, #60	; 0x3c
24007afa:	687b      	ldr	r3, [r7, #4]
24007afc:	f103 0240 	add.w	r2, r3, #64	; 0x40
24007b00:	687b      	ldr	r3, [r7, #4]
24007b02:	69db      	ldr	r3, [r3, #28]
24007b04:	f000 fca8 	bl	24008458 <FLASH_OB_GetSecureArea>
  }

  /*Get Boot Address*/
  FLASH_OB_GetBootAdd(&(pOBInit->BootAddr0), &(pOBInit->BootAddr1));
24007b08:	687b      	ldr	r3, [r7, #4]
24007b0a:	f103 0230 	add.w	r2, r3, #48	; 0x30
24007b0e:	687b      	ldr	r3, [r7, #4]
24007b10:	3334      	adds	r3, #52	; 0x34
24007b12:	4619      	mov	r1, r3
24007b14:	4610      	mov	r0, r2
24007b16:	f000 fc49 	bl	240083ac <FLASH_OB_GetBootAdd>
  pOBInit->OptionType |= OPTIONBYTE_CM7_BOOTADD | OPTIONBYTE_CM4_BOOTADD;

  /*Get CM4 Boot Address*/
  FLASH_OB_GetCM4BootAdd(&(pOBInit->CM4BootAddr0), &(pOBInit->CM4BootAddr1));
#else
  pOBInit->OptionType |= OPTIONBYTE_BOOTADD;
24007b1a:	687b      	ldr	r3, [r7, #4]
24007b1c:	681b      	ldr	r3, [r3, #0]
24007b1e:	f043 0240 	orr.w	r2, r3, #64	; 0x40
24007b22:	687b      	ldr	r3, [r7, #4]
24007b24:	601a      	str	r2, [r3, #0]
  pOBInit->OptionType |= OPTIONBYTE_OTP_LOCK;

  /* Get OTP Block Lock */
  pOBInit->OTPBlockLock = FLASH_OB_OTP_GetLock();
#endif /* FLASH_OTPBL_LOCKBL */
}
24007b26:	bf00      	nop
24007b28:	3708      	adds	r7, #8
24007b2a:	46bd      	mov	sp, r7
24007b2c:	bd80      	pop	{r7, pc}
	...

24007b30 <HAL_FLASHEx_Unlock_Bank1>:
/**
  * @brief  Unlock the FLASH Bank1 control registers access
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASHEx_Unlock_Bank1(void)
{
24007b30:	b480      	push	{r7}
24007b32:	af00      	add	r7, sp, #0
  if(READ_BIT(FLASH->CR1, FLASH_CR_LOCK) != 0U)
24007b34:	4b0c      	ldr	r3, [pc, #48]	; (24007b68 <HAL_FLASHEx_Unlock_Bank1+0x38>)
24007b36:	68db      	ldr	r3, [r3, #12]
24007b38:	f003 0301 	and.w	r3, r3, #1
24007b3c:	2b00      	cmp	r3, #0
24007b3e:	d00d      	beq.n	24007b5c <HAL_FLASHEx_Unlock_Bank1+0x2c>
  {
    /* Authorize the FLASH Bank1 Registers access */
    WRITE_REG(FLASH->KEYR1, FLASH_KEY1);
24007b40:	4b09      	ldr	r3, [pc, #36]	; (24007b68 <HAL_FLASHEx_Unlock_Bank1+0x38>)
24007b42:	4a0a      	ldr	r2, [pc, #40]	; (24007b6c <HAL_FLASHEx_Unlock_Bank1+0x3c>)
24007b44:	605a      	str	r2, [r3, #4]
    WRITE_REG(FLASH->KEYR1, FLASH_KEY2);
24007b46:	4b08      	ldr	r3, [pc, #32]	; (24007b68 <HAL_FLASHEx_Unlock_Bank1+0x38>)
24007b48:	4a09      	ldr	r2, [pc, #36]	; (24007b70 <HAL_FLASHEx_Unlock_Bank1+0x40>)
24007b4a:	605a      	str	r2, [r3, #4]

    /* Verify Flash Bank1 is unlocked */
    if (READ_BIT(FLASH->CR1, FLASH_CR_LOCK) != 0U)
24007b4c:	4b06      	ldr	r3, [pc, #24]	; (24007b68 <HAL_FLASHEx_Unlock_Bank1+0x38>)
24007b4e:	68db      	ldr	r3, [r3, #12]
24007b50:	f003 0301 	and.w	r3, r3, #1
24007b54:	2b00      	cmp	r3, #0
24007b56:	d001      	beq.n	24007b5c <HAL_FLASHEx_Unlock_Bank1+0x2c>
    {
      return HAL_ERROR;
24007b58:	2301      	movs	r3, #1
24007b5a:	e000      	b.n	24007b5e <HAL_FLASHEx_Unlock_Bank1+0x2e>
    }
  }

  return HAL_OK;
24007b5c:	2300      	movs	r3, #0
}
24007b5e:	4618      	mov	r0, r3
24007b60:	46bd      	mov	sp, r7
24007b62:	f85d 7b04 	ldr.w	r7, [sp], #4
24007b66:	4770      	bx	lr
24007b68:	52002000 	.word	0x52002000
24007b6c:	45670123 	.word	0x45670123
24007b70:	cdef89ab 	.word	0xcdef89ab

24007b74 <HAL_FLASHEx_Lock_Bank1>:
/**
  * @brief  Locks the FLASH Bank1 control registers access
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASHEx_Lock_Bank1(void)
{
24007b74:	b480      	push	{r7}
24007b76:	af00      	add	r7, sp, #0
  /* Set the LOCK Bit to lock the FLASH Bank1 Registers access */
  SET_BIT(FLASH->CR1, FLASH_CR_LOCK);
24007b78:	4b05      	ldr	r3, [pc, #20]	; (24007b90 <HAL_FLASHEx_Lock_Bank1+0x1c>)
24007b7a:	68db      	ldr	r3, [r3, #12]
24007b7c:	4a04      	ldr	r2, [pc, #16]	; (24007b90 <HAL_FLASHEx_Lock_Bank1+0x1c>)
24007b7e:	f043 0301 	orr.w	r3, r3, #1
24007b82:	60d3      	str	r3, [r2, #12]
  return HAL_OK;
24007b84:	2300      	movs	r3, #0
}
24007b86:	4618      	mov	r0, r3
24007b88:	46bd      	mov	sp, r7
24007b8a:	f85d 7b04 	ldr.w	r7, [sp], #4
24007b8e:	4770      	bx	lr
24007b90:	52002000 	.word	0x52002000

24007b94 <HAL_FLASHEx_Unlock_Bank2>:
/**
  * @brief  Unlock the FLASH Bank2 control registers access
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASHEx_Unlock_Bank2(void)
{
24007b94:	b480      	push	{r7}
24007b96:	af00      	add	r7, sp, #0
  if(READ_BIT(FLASH->CR2, FLASH_CR_LOCK) != 0U)
24007b98:	4b0e      	ldr	r3, [pc, #56]	; (24007bd4 <HAL_FLASHEx_Unlock_Bank2+0x40>)
24007b9a:	f8d3 310c 	ldr.w	r3, [r3, #268]	; 0x10c
24007b9e:	f003 0301 	and.w	r3, r3, #1
24007ba2:	2b00      	cmp	r3, #0
24007ba4:	d010      	beq.n	24007bc8 <HAL_FLASHEx_Unlock_Bank2+0x34>
  {
    /* Authorize the FLASH Bank2 Registers access */
    WRITE_REG(FLASH->KEYR2, FLASH_KEY1);
24007ba6:	4b0b      	ldr	r3, [pc, #44]	; (24007bd4 <HAL_FLASHEx_Unlock_Bank2+0x40>)
24007ba8:	4a0b      	ldr	r2, [pc, #44]	; (24007bd8 <HAL_FLASHEx_Unlock_Bank2+0x44>)
24007baa:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
    WRITE_REG(FLASH->KEYR2, FLASH_KEY2);
24007bae:	4b09      	ldr	r3, [pc, #36]	; (24007bd4 <HAL_FLASHEx_Unlock_Bank2+0x40>)
24007bb0:	4a0a      	ldr	r2, [pc, #40]	; (24007bdc <HAL_FLASHEx_Unlock_Bank2+0x48>)
24007bb2:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104

    /* Verify Flash Bank1 is unlocked */
    if (READ_BIT(FLASH->CR2, FLASH_CR_LOCK) != 0U)
24007bb6:	4b07      	ldr	r3, [pc, #28]	; (24007bd4 <HAL_FLASHEx_Unlock_Bank2+0x40>)
24007bb8:	f8d3 310c 	ldr.w	r3, [r3, #268]	; 0x10c
24007bbc:	f003 0301 	and.w	r3, r3, #1
24007bc0:	2b00      	cmp	r3, #0
24007bc2:	d001      	beq.n	24007bc8 <HAL_FLASHEx_Unlock_Bank2+0x34>
    {
      return HAL_ERROR;
24007bc4:	2301      	movs	r3, #1
24007bc6:	e000      	b.n	24007bca <HAL_FLASHEx_Unlock_Bank2+0x36>
    }
  }

  return HAL_OK;
24007bc8:	2300      	movs	r3, #0
}
24007bca:	4618      	mov	r0, r3
24007bcc:	46bd      	mov	sp, r7
24007bce:	f85d 7b04 	ldr.w	r7, [sp], #4
24007bd2:	4770      	bx	lr
24007bd4:	52002000 	.word	0x52002000
24007bd8:	45670123 	.word	0x45670123
24007bdc:	cdef89ab 	.word	0xcdef89ab

24007be0 <HAL_FLASHEx_Lock_Bank2>:
/**
  * @brief  Locks the FLASH Bank2 control registers access
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASHEx_Lock_Bank2(void)
{
24007be0:	b480      	push	{r7}
24007be2:	af00      	add	r7, sp, #0
  /* Set the LOCK Bit to lock the FLASH Bank2 Registers access */
  SET_BIT(FLASH->CR2, FLASH_CR_LOCK);
24007be4:	4b06      	ldr	r3, [pc, #24]	; (24007c00 <HAL_FLASHEx_Lock_Bank2+0x20>)
24007be6:	f8d3 310c 	ldr.w	r3, [r3, #268]	; 0x10c
24007bea:	4a05      	ldr	r2, [pc, #20]	; (24007c00 <HAL_FLASHEx_Lock_Bank2+0x20>)
24007bec:	f043 0301 	orr.w	r3, r3, #1
24007bf0:	f8c2 310c 	str.w	r3, [r2, #268]	; 0x10c
  return HAL_OK;
24007bf4:	2300      	movs	r3, #0
}
24007bf6:	4618      	mov	r0, r3
24007bf8:	46bd      	mov	sp, r7
24007bfa:	f85d 7b04 	ldr.w	r7, [sp], #4
24007bfe:	4770      	bx	lr
24007c00:	52002000 	.word	0x52002000

24007c04 <HAL_FLASHEx_ComputeCRC>:
  *         A special error flag (CRC read error: CRCRDERR) can be used to
  *         detect such a case.
  * @retval HAL Status
*/
HAL_StatusTypeDef HAL_FLASHEx_ComputeCRC(FLASH_CRCInitTypeDef *pCRCInit, uint32_t *CRC_Result)
{
24007c04:	b580      	push	{r7, lr}
24007c06:	b084      	sub	sp, #16
24007c08:	af00      	add	r7, sp, #0
24007c0a:	6078      	str	r0, [r7, #4]
24007c0c:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_FLASH_BANK_EXCLUSIVE(pCRCInit->Bank));
  assert_param(IS_FLASH_TYPECRC(pCRCInit->TypeCRC));

  /* Wait for OB change operation to be completed */
  status = FLASH_OB_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
24007c0e:	f24c 3050 	movw	r0, #50000	; 0xc350
24007c12:	f7ff fc71 	bl	240074f8 <FLASH_OB_WaitForLastOperation>
24007c16:	4603      	mov	r3, r0
24007c18:	73fb      	strb	r3, [r7, #15]

  if (status == HAL_OK)
24007c1a:	7bfb      	ldrb	r3, [r7, #15]
24007c1c:	2b00      	cmp	r3, #0
24007c1e:	f040 80e0 	bne.w	24007de2 <HAL_FLASHEx_ComputeCRC+0x1de>
  {
    if (pCRCInit->Bank == FLASH_BANK_1)
24007c22:	687b      	ldr	r3, [r7, #4]
24007c24:	689b      	ldr	r3, [r3, #8]
24007c26:	2b01      	cmp	r3, #1
24007c28:	d166      	bne.n	24007cf8 <HAL_FLASHEx_ComputeCRC+0xf4>
    {
      /* Enable CRC feature */
      FLASH->CR1 |= FLASH_CR_CRC_EN;
24007c2a:	4b70      	ldr	r3, [pc, #448]	; (24007dec <HAL_FLASHEx_ComputeCRC+0x1e8>)
24007c2c:	68db      	ldr	r3, [r3, #12]
24007c2e:	4a6f      	ldr	r2, [pc, #444]	; (24007dec <HAL_FLASHEx_ComputeCRC+0x1e8>)
24007c30:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
24007c34:	60d3      	str	r3, [r2, #12]

      /* Clear CRC flags in Status Register: CRC end of calculation and CRC read error */
      FLASH->CCR1 |= (FLASH_CCR_CLR_CRCEND | FLASH_CCR_CLR_CRCRDERR);
24007c36:	4b6d      	ldr	r3, [pc, #436]	; (24007dec <HAL_FLASHEx_ComputeCRC+0x1e8>)
24007c38:	695b      	ldr	r3, [r3, #20]
24007c3a:	4a6c      	ldr	r2, [pc, #432]	; (24007dec <HAL_FLASHEx_ComputeCRC+0x1e8>)
24007c3c:	f043 53c0 	orr.w	r3, r3, #402653184	; 0x18000000
24007c40:	6153      	str	r3, [r2, #20]

      /* Clear current CRC result, program burst size and define memory area on which CRC has to be computed */
      FLASH->CRCCR1 |= FLASH_CRCCR_CLEAN_CRC | pCRCInit->BurstSize | pCRCInit->TypeCRC;
24007c42:	4b6a      	ldr	r3, [pc, #424]	; (24007dec <HAL_FLASHEx_ComputeCRC+0x1e8>)
24007c44:	6d1a      	ldr	r2, [r3, #80]	; 0x50
24007c46:	687b      	ldr	r3, [r7, #4]
24007c48:	6859      	ldr	r1, [r3, #4]
24007c4a:	687b      	ldr	r3, [r7, #4]
24007c4c:	681b      	ldr	r3, [r3, #0]
24007c4e:	430b      	orrs	r3, r1
24007c50:	4313      	orrs	r3, r2
24007c52:	4a66      	ldr	r2, [pc, #408]	; (24007dec <HAL_FLASHEx_ComputeCRC+0x1e8>)
24007c54:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
24007c58:	6513      	str	r3, [r2, #80]	; 0x50

      if (pCRCInit->TypeCRC == FLASH_CRC_SECTORS)
24007c5a:	687b      	ldr	r3, [r7, #4]
24007c5c:	681b      	ldr	r3, [r3, #0]
24007c5e:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
24007c62:	d119      	bne.n	24007c98 <HAL_FLASHEx_ComputeCRC+0x94>
      {
        /* Clear sectors list */
        FLASH->CRCCR1 |= FLASH_CRCCR_CLEAN_SECT;
24007c64:	4b61      	ldr	r3, [pc, #388]	; (24007dec <HAL_FLASHEx_ComputeCRC+0x1e8>)
24007c66:	6d1b      	ldr	r3, [r3, #80]	; 0x50
24007c68:	4a60      	ldr	r2, [pc, #384]	; (24007dec <HAL_FLASHEx_ComputeCRC+0x1e8>)
24007c6a:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
24007c6e:	6513      	str	r3, [r2, #80]	; 0x50

        /* Select CRC sectors */
        for(sector_index = pCRCInit->Sector; sector_index < (pCRCInit->NbSectors + pCRCInit->Sector); sector_index++)
24007c70:	687b      	ldr	r3, [r7, #4]
24007c72:	68db      	ldr	r3, [r3, #12]
24007c74:	60bb      	str	r3, [r7, #8]
24007c76:	e006      	b.n	24007c86 <HAL_FLASHEx_ComputeCRC+0x82>
        {
          FLASH_CRC_AddSector(sector_index, FLASH_BANK_1);
24007c78:	2101      	movs	r1, #1
24007c7a:	68b8      	ldr	r0, [r7, #8]
24007c7c:	f000 fc32 	bl	240084e4 <FLASH_CRC_AddSector>
        for(sector_index = pCRCInit->Sector; sector_index < (pCRCInit->NbSectors + pCRCInit->Sector); sector_index++)
24007c80:	68bb      	ldr	r3, [r7, #8]
24007c82:	3301      	adds	r3, #1
24007c84:	60bb      	str	r3, [r7, #8]
24007c86:	687b      	ldr	r3, [r7, #4]
24007c88:	691a      	ldr	r2, [r3, #16]
24007c8a:	687b      	ldr	r3, [r7, #4]
24007c8c:	68db      	ldr	r3, [r3, #12]
24007c8e:	4413      	add	r3, r2
24007c90:	68ba      	ldr	r2, [r7, #8]
24007c92:	429a      	cmp	r2, r3
24007c94:	d3f0      	bcc.n	24007c78 <HAL_FLASHEx_ComputeCRC+0x74>
24007c96:	e013      	b.n	24007cc0 <HAL_FLASHEx_ComputeCRC+0xbc>
        }
      }
      else if (pCRCInit->TypeCRC == FLASH_CRC_BANK)
24007c98:	687b      	ldr	r3, [r7, #4]
24007c9a:	681b      	ldr	r3, [r3, #0]
24007c9c:	4a54      	ldr	r2, [pc, #336]	; (24007df0 <HAL_FLASHEx_ComputeCRC+0x1ec>)
24007c9e:	4293      	cmp	r3, r2
24007ca0:	d106      	bne.n	24007cb0 <HAL_FLASHEx_ComputeCRC+0xac>
      {
        /* Enable Bank 1 CRC select bit */
        FLASH->CRCCR1 |= FLASH_CRCCR_ALL_BANK;
24007ca2:	4b52      	ldr	r3, [pc, #328]	; (24007dec <HAL_FLASHEx_ComputeCRC+0x1e8>)
24007ca4:	6d1b      	ldr	r3, [r3, #80]	; 0x50
24007ca6:	4a51      	ldr	r2, [pc, #324]	; (24007dec <HAL_FLASHEx_ComputeCRC+0x1e8>)
24007ca8:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
24007cac:	6513      	str	r3, [r2, #80]	; 0x50
24007cae:	e007      	b.n	24007cc0 <HAL_FLASHEx_ComputeCRC+0xbc>
      }
      else
      {
        /* Select CRC start and end addresses */
        FLASH_CRC_SelectAddress(pCRCInit->CRCStartAddr, pCRCInit->CRCEndAddr, FLASH_BANK_1);
24007cb0:	687b      	ldr	r3, [r7, #4]
24007cb2:	6958      	ldr	r0, [r3, #20]
24007cb4:	687b      	ldr	r3, [r7, #4]
24007cb6:	699b      	ldr	r3, [r3, #24]
24007cb8:	2201      	movs	r2, #1
24007cba:	4619      	mov	r1, r3
24007cbc:	f000 fc44 	bl	24008548 <FLASH_CRC_SelectAddress>
      }

      /* Start the CRC calculation */
      FLASH->CRCCR1 |= FLASH_CRCCR_START_CRC;
24007cc0:	4b4a      	ldr	r3, [pc, #296]	; (24007dec <HAL_FLASHEx_ComputeCRC+0x1e8>)
24007cc2:	6d1b      	ldr	r3, [r3, #80]	; 0x50
24007cc4:	4a49      	ldr	r2, [pc, #292]	; (24007dec <HAL_FLASHEx_ComputeCRC+0x1e8>)
24007cc6:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
24007cca:	6513      	str	r3, [r2, #80]	; 0x50

      /* Wait on CRC busy flag */
      status = FLASH_CRC_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_1);
24007ccc:	2101      	movs	r1, #1
24007cce:	f24c 3050 	movw	r0, #50000	; 0xc350
24007cd2:	f7ff fc4d 	bl	24007570 <FLASH_CRC_WaitForLastOperation>
24007cd6:	4603      	mov	r3, r0
24007cd8:	73fb      	strb	r3, [r7, #15]

      /* Return CRC result */
      (*CRC_Result) = FLASH->CRCDATA;
24007cda:	4b44      	ldr	r3, [pc, #272]	; (24007dec <HAL_FLASHEx_ComputeCRC+0x1e8>)
24007cdc:	6dda      	ldr	r2, [r3, #92]	; 0x5c
24007cde:	683b      	ldr	r3, [r7, #0]
24007ce0:	601a      	str	r2, [r3, #0]

      /* Disable CRC feature */
      FLASH->CR1 &= (~FLASH_CR_CRC_EN);
24007ce2:	4b42      	ldr	r3, [pc, #264]	; (24007dec <HAL_FLASHEx_ComputeCRC+0x1e8>)
24007ce4:	68db      	ldr	r3, [r3, #12]
24007ce6:	4a41      	ldr	r2, [pc, #260]	; (24007dec <HAL_FLASHEx_ComputeCRC+0x1e8>)
24007ce8:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
24007cec:	60d3      	str	r3, [r2, #12]

      /* Clear CRC flags */
      __HAL_FLASH_CLEAR_FLAG_BANK1(FLASH_FLAG_CRCEND_BANK1 | FLASH_FLAG_CRCRDERR_BANK1);
24007cee:	4b3f      	ldr	r3, [pc, #252]	; (24007dec <HAL_FLASHEx_ComputeCRC+0x1e8>)
24007cf0:	f04f 52c0 	mov.w	r2, #402653184	; 0x18000000
24007cf4:	615a      	str	r2, [r3, #20]
24007cf6:	e074      	b.n	24007de2 <HAL_FLASHEx_ComputeCRC+0x1de>
    }
    else
    {
      /* Enable CRC feature */
      FLASH->CR2 |= FLASH_CR_CRC_EN;
24007cf8:	4b3c      	ldr	r3, [pc, #240]	; (24007dec <HAL_FLASHEx_ComputeCRC+0x1e8>)
24007cfa:	f8d3 310c 	ldr.w	r3, [r3, #268]	; 0x10c
24007cfe:	4a3b      	ldr	r2, [pc, #236]	; (24007dec <HAL_FLASHEx_ComputeCRC+0x1e8>)
24007d00:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
24007d04:	f8c2 310c 	str.w	r3, [r2, #268]	; 0x10c

      /* Clear CRC flags in Status Register: CRC end of calculation and CRC read error */
      FLASH->CCR2 |= (FLASH_CCR_CLR_CRCEND | FLASH_CCR_CLR_CRCRDERR);
24007d08:	4b38      	ldr	r3, [pc, #224]	; (24007dec <HAL_FLASHEx_ComputeCRC+0x1e8>)
24007d0a:	f8d3 3114 	ldr.w	r3, [r3, #276]	; 0x114
24007d0e:	4a37      	ldr	r2, [pc, #220]	; (24007dec <HAL_FLASHEx_ComputeCRC+0x1e8>)
24007d10:	f043 53c0 	orr.w	r3, r3, #402653184	; 0x18000000
24007d14:	f8c2 3114 	str.w	r3, [r2, #276]	; 0x114

      /* Clear current CRC result, program burst size and define memory area on which CRC has to be computed */
      FLASH->CRCCR2 |= FLASH_CRCCR_CLEAN_CRC | pCRCInit->BurstSize | pCRCInit->TypeCRC;
24007d18:	4b34      	ldr	r3, [pc, #208]	; (24007dec <HAL_FLASHEx_ComputeCRC+0x1e8>)
24007d1a:	f8d3 2150 	ldr.w	r2, [r3, #336]	; 0x150
24007d1e:	687b      	ldr	r3, [r7, #4]
24007d20:	6859      	ldr	r1, [r3, #4]
24007d22:	687b      	ldr	r3, [r7, #4]
24007d24:	681b      	ldr	r3, [r3, #0]
24007d26:	430b      	orrs	r3, r1
24007d28:	4313      	orrs	r3, r2
24007d2a:	4a30      	ldr	r2, [pc, #192]	; (24007dec <HAL_FLASHEx_ComputeCRC+0x1e8>)
24007d2c:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
24007d30:	f8c2 3150 	str.w	r3, [r2, #336]	; 0x150

      if (pCRCInit->TypeCRC == FLASH_CRC_SECTORS)
24007d34:	687b      	ldr	r3, [r7, #4]
24007d36:	681b      	ldr	r3, [r3, #0]
24007d38:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
24007d3c:	d11b      	bne.n	24007d76 <HAL_FLASHEx_ComputeCRC+0x172>
      {
        /* Clear sectors list */
        FLASH->CRCCR2 |= FLASH_CRCCR_CLEAN_SECT;
24007d3e:	4b2b      	ldr	r3, [pc, #172]	; (24007dec <HAL_FLASHEx_ComputeCRC+0x1e8>)
24007d40:	f8d3 3150 	ldr.w	r3, [r3, #336]	; 0x150
24007d44:	4a29      	ldr	r2, [pc, #164]	; (24007dec <HAL_FLASHEx_ComputeCRC+0x1e8>)
24007d46:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
24007d4a:	f8c2 3150 	str.w	r3, [r2, #336]	; 0x150

        /* Add CRC sectors */
        for(sector_index = pCRCInit->Sector; sector_index < (pCRCInit->NbSectors + pCRCInit->Sector); sector_index++)
24007d4e:	687b      	ldr	r3, [r7, #4]
24007d50:	68db      	ldr	r3, [r3, #12]
24007d52:	60bb      	str	r3, [r7, #8]
24007d54:	e006      	b.n	24007d64 <HAL_FLASHEx_ComputeCRC+0x160>
        {
          FLASH_CRC_AddSector(sector_index, FLASH_BANK_2);
24007d56:	2102      	movs	r1, #2
24007d58:	68b8      	ldr	r0, [r7, #8]
24007d5a:	f000 fbc3 	bl	240084e4 <FLASH_CRC_AddSector>
        for(sector_index = pCRCInit->Sector; sector_index < (pCRCInit->NbSectors + pCRCInit->Sector); sector_index++)
24007d5e:	68bb      	ldr	r3, [r7, #8]
24007d60:	3301      	adds	r3, #1
24007d62:	60bb      	str	r3, [r7, #8]
24007d64:	687b      	ldr	r3, [r7, #4]
24007d66:	691a      	ldr	r2, [r3, #16]
24007d68:	687b      	ldr	r3, [r7, #4]
24007d6a:	68db      	ldr	r3, [r3, #12]
24007d6c:	4413      	add	r3, r2
24007d6e:	68ba      	ldr	r2, [r7, #8]
24007d70:	429a      	cmp	r2, r3
24007d72:	d3f0      	bcc.n	24007d56 <HAL_FLASHEx_ComputeCRC+0x152>
24007d74:	e015      	b.n	24007da2 <HAL_FLASHEx_ComputeCRC+0x19e>
        }
      }
      else if (pCRCInit->TypeCRC == FLASH_CRC_BANK)
24007d76:	687b      	ldr	r3, [r7, #4]
24007d78:	681b      	ldr	r3, [r3, #0]
24007d7a:	4a1d      	ldr	r2, [pc, #116]	; (24007df0 <HAL_FLASHEx_ComputeCRC+0x1ec>)
24007d7c:	4293      	cmp	r3, r2
24007d7e:	d108      	bne.n	24007d92 <HAL_FLASHEx_ComputeCRC+0x18e>
      {
        /* Enable Bank 2 CRC select bit */
        FLASH->CRCCR2 |= FLASH_CRCCR_ALL_BANK;
24007d80:	4b1a      	ldr	r3, [pc, #104]	; (24007dec <HAL_FLASHEx_ComputeCRC+0x1e8>)
24007d82:	f8d3 3150 	ldr.w	r3, [r3, #336]	; 0x150
24007d86:	4a19      	ldr	r2, [pc, #100]	; (24007dec <HAL_FLASHEx_ComputeCRC+0x1e8>)
24007d88:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
24007d8c:	f8c2 3150 	str.w	r3, [r2, #336]	; 0x150
24007d90:	e007      	b.n	24007da2 <HAL_FLASHEx_ComputeCRC+0x19e>
      }
      else
      {
        /* Select CRC start and end addresses */
        FLASH_CRC_SelectAddress(pCRCInit->CRCStartAddr, pCRCInit->CRCEndAddr, FLASH_BANK_2);
24007d92:	687b      	ldr	r3, [r7, #4]
24007d94:	6958      	ldr	r0, [r3, #20]
24007d96:	687b      	ldr	r3, [r7, #4]
24007d98:	699b      	ldr	r3, [r3, #24]
24007d9a:	2202      	movs	r2, #2
24007d9c:	4619      	mov	r1, r3
24007d9e:	f000 fbd3 	bl	24008548 <FLASH_CRC_SelectAddress>
      }

      /* Start the CRC calculation */
      FLASH->CRCCR2 |= FLASH_CRCCR_START_CRC;
24007da2:	4b12      	ldr	r3, [pc, #72]	; (24007dec <HAL_FLASHEx_ComputeCRC+0x1e8>)
24007da4:	f8d3 3150 	ldr.w	r3, [r3, #336]	; 0x150
24007da8:	4a10      	ldr	r2, [pc, #64]	; (24007dec <HAL_FLASHEx_ComputeCRC+0x1e8>)
24007daa:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
24007dae:	f8c2 3150 	str.w	r3, [r2, #336]	; 0x150

      /* Wait on CRC busy flag */
      status = FLASH_CRC_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_2);
24007db2:	2102      	movs	r1, #2
24007db4:	f24c 3050 	movw	r0, #50000	; 0xc350
24007db8:	f7ff fbda 	bl	24007570 <FLASH_CRC_WaitForLastOperation>
24007dbc:	4603      	mov	r3, r0
24007dbe:	73fb      	strb	r3, [r7, #15]

      /* Return CRC result */
      (*CRC_Result) = FLASH->CRCDATA;
24007dc0:	4b0a      	ldr	r3, [pc, #40]	; (24007dec <HAL_FLASHEx_ComputeCRC+0x1e8>)
24007dc2:	6dda      	ldr	r2, [r3, #92]	; 0x5c
24007dc4:	683b      	ldr	r3, [r7, #0]
24007dc6:	601a      	str	r2, [r3, #0]

      /* Disable CRC feature */
      FLASH->CR2 &= (~FLASH_CR_CRC_EN);
24007dc8:	4b08      	ldr	r3, [pc, #32]	; (24007dec <HAL_FLASHEx_ComputeCRC+0x1e8>)
24007dca:	f8d3 310c 	ldr.w	r3, [r3, #268]	; 0x10c
24007dce:	4a07      	ldr	r2, [pc, #28]	; (24007dec <HAL_FLASHEx_ComputeCRC+0x1e8>)
24007dd0:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
24007dd4:	f8c2 310c 	str.w	r3, [r2, #268]	; 0x10c

      /* Clear CRC flags */
      __HAL_FLASH_CLEAR_FLAG_BANK2(FLASH_FLAG_CRCEND_BANK2 | FLASH_FLAG_CRCRDERR_BANK2);
24007dd8:	4b04      	ldr	r3, [pc, #16]	; (24007dec <HAL_FLASHEx_ComputeCRC+0x1e8>)
24007dda:	f04f 52c0 	mov.w	r2, #402653184	; 0x18000000
24007dde:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
    }
  }

  return status;
24007de2:	7bfb      	ldrb	r3, [r7, #15]
}
24007de4:	4618      	mov	r0, r3
24007de6:	3710      	adds	r7, #16
24007de8:	46bd      	mov	sp, r7
24007dea:	bd80      	pop	{r7, pc}
24007dec:	52002000 	.word	0x52002000
24007df0:	00400100 	.word	0x00400100

24007df4 <FLASH_MassErase>:
  *            @arg FLASH_BANK_BOTH: Bank1 and Bank2 to be erased
  *
  * @retval HAL Status
  */
static void FLASH_MassErase(uint32_t VoltageRange, uint32_t Banks)
{
24007df4:	b480      	push	{r7}
24007df6:	b083      	sub	sp, #12
24007df8:	af00      	add	r7, sp, #0
24007dfa:	6078      	str	r0, [r7, #4]
24007dfc:	6039      	str	r1, [r7, #0]
  UNUSED(VoltageRange);
#endif /* FLASH_CR_PSIZE */
  assert_param(IS_FLASH_BANK(Banks));

  /* Flash Mass Erase */
  if((Banks & FLASH_BANK_BOTH) == FLASH_BANK_BOTH)
24007dfe:	683b      	ldr	r3, [r7, #0]
24007e00:	f003 0303 	and.w	r3, r3, #3
24007e04:	2b03      	cmp	r3, #3
24007e06:	d122      	bne.n	24007e4e <FLASH_MassErase+0x5a>
  {
#if defined (FLASH_CR_PSIZE)
    /* Reset Program/erase VoltageRange for Bank1 and Bank2 */
    FLASH->CR1 &= (~FLASH_CR_PSIZE);
24007e08:	4b2e      	ldr	r3, [pc, #184]	; (24007ec4 <FLASH_MassErase+0xd0>)
24007e0a:	68db      	ldr	r3, [r3, #12]
24007e0c:	4a2d      	ldr	r2, [pc, #180]	; (24007ec4 <FLASH_MassErase+0xd0>)
24007e0e:	f023 0330 	bic.w	r3, r3, #48	; 0x30
24007e12:	60d3      	str	r3, [r2, #12]
    FLASH->CR2 &= (~FLASH_CR_PSIZE);
24007e14:	4b2b      	ldr	r3, [pc, #172]	; (24007ec4 <FLASH_MassErase+0xd0>)
24007e16:	f8d3 310c 	ldr.w	r3, [r3, #268]	; 0x10c
24007e1a:	4a2a      	ldr	r2, [pc, #168]	; (24007ec4 <FLASH_MassErase+0xd0>)
24007e1c:	f023 0330 	bic.w	r3, r3, #48	; 0x30
24007e20:	f8c2 310c 	str.w	r3, [r2, #268]	; 0x10c

    /* Set voltage range */
    FLASH->CR1 |= VoltageRange;
24007e24:	4b27      	ldr	r3, [pc, #156]	; (24007ec4 <FLASH_MassErase+0xd0>)
24007e26:	68da      	ldr	r2, [r3, #12]
24007e28:	4926      	ldr	r1, [pc, #152]	; (24007ec4 <FLASH_MassErase+0xd0>)
24007e2a:	687b      	ldr	r3, [r7, #4]
24007e2c:	4313      	orrs	r3, r2
24007e2e:	60cb      	str	r3, [r1, #12]
    FLASH->CR2 |= VoltageRange;
24007e30:	4b24      	ldr	r3, [pc, #144]	; (24007ec4 <FLASH_MassErase+0xd0>)
24007e32:	f8d3 210c 	ldr.w	r2, [r3, #268]	; 0x10c
24007e36:	4923      	ldr	r1, [pc, #140]	; (24007ec4 <FLASH_MassErase+0xd0>)
24007e38:	687b      	ldr	r3, [r7, #4]
24007e3a:	4313      	orrs	r3, r2
24007e3c:	f8c1 310c 	str.w	r3, [r1, #268]	; 0x10c
#endif /* FLASH_CR_PSIZE */

    /* Set Mass Erase Bit */
    FLASH->OPTCR |= FLASH_OPTCR_MER;
24007e40:	4b20      	ldr	r3, [pc, #128]	; (24007ec4 <FLASH_MassErase+0xd0>)
24007e42:	699b      	ldr	r3, [r3, #24]
24007e44:	4a1f      	ldr	r2, [pc, #124]	; (24007ec4 <FLASH_MassErase+0xd0>)
24007e46:	f043 0310 	orr.w	r3, r3, #16
24007e4a:	6193      	str	r3, [r2, #24]

      /* Erase Bank2 */
      FLASH->CR2 |= (FLASH_CR_BER | FLASH_CR_START);
    }
  }
}
24007e4c:	e033      	b.n	24007eb6 <FLASH_MassErase+0xc2>
    if((Banks & FLASH_BANK_1) == FLASH_BANK_1)
24007e4e:	683b      	ldr	r3, [r7, #0]
24007e50:	f003 0301 	and.w	r3, r3, #1
24007e54:	2b00      	cmp	r3, #0
24007e56:	d011      	beq.n	24007e7c <FLASH_MassErase+0x88>
      FLASH->CR1 &= (~FLASH_CR_PSIZE);
24007e58:	4b1a      	ldr	r3, [pc, #104]	; (24007ec4 <FLASH_MassErase+0xd0>)
24007e5a:	68db      	ldr	r3, [r3, #12]
24007e5c:	4a19      	ldr	r2, [pc, #100]	; (24007ec4 <FLASH_MassErase+0xd0>)
24007e5e:	f023 0330 	bic.w	r3, r3, #48	; 0x30
24007e62:	60d3      	str	r3, [r2, #12]
      FLASH->CR1 |=  VoltageRange;
24007e64:	4b17      	ldr	r3, [pc, #92]	; (24007ec4 <FLASH_MassErase+0xd0>)
24007e66:	68da      	ldr	r2, [r3, #12]
24007e68:	4916      	ldr	r1, [pc, #88]	; (24007ec4 <FLASH_MassErase+0xd0>)
24007e6a:	687b      	ldr	r3, [r7, #4]
24007e6c:	4313      	orrs	r3, r2
24007e6e:	60cb      	str	r3, [r1, #12]
      FLASH->CR1 |= (FLASH_CR_BER | FLASH_CR_START);
24007e70:	4b14      	ldr	r3, [pc, #80]	; (24007ec4 <FLASH_MassErase+0xd0>)
24007e72:	68db      	ldr	r3, [r3, #12]
24007e74:	4a13      	ldr	r2, [pc, #76]	; (24007ec4 <FLASH_MassErase+0xd0>)
24007e76:	f043 0388 	orr.w	r3, r3, #136	; 0x88
24007e7a:	60d3      	str	r3, [r2, #12]
    if((Banks & FLASH_BANK_2) == FLASH_BANK_2)
24007e7c:	683b      	ldr	r3, [r7, #0]
24007e7e:	f003 0302 	and.w	r3, r3, #2
24007e82:	2b00      	cmp	r3, #0
24007e84:	d017      	beq.n	24007eb6 <FLASH_MassErase+0xc2>
      FLASH->CR2 &= (~FLASH_CR_PSIZE);
24007e86:	4b0f      	ldr	r3, [pc, #60]	; (24007ec4 <FLASH_MassErase+0xd0>)
24007e88:	f8d3 310c 	ldr.w	r3, [r3, #268]	; 0x10c
24007e8c:	4a0d      	ldr	r2, [pc, #52]	; (24007ec4 <FLASH_MassErase+0xd0>)
24007e8e:	f023 0330 	bic.w	r3, r3, #48	; 0x30
24007e92:	f8c2 310c 	str.w	r3, [r2, #268]	; 0x10c
      FLASH->CR2 |= VoltageRange;
24007e96:	4b0b      	ldr	r3, [pc, #44]	; (24007ec4 <FLASH_MassErase+0xd0>)
24007e98:	f8d3 210c 	ldr.w	r2, [r3, #268]	; 0x10c
24007e9c:	4909      	ldr	r1, [pc, #36]	; (24007ec4 <FLASH_MassErase+0xd0>)
24007e9e:	687b      	ldr	r3, [r7, #4]
24007ea0:	4313      	orrs	r3, r2
24007ea2:	f8c1 310c 	str.w	r3, [r1, #268]	; 0x10c
      FLASH->CR2 |= (FLASH_CR_BER | FLASH_CR_START);
24007ea6:	4b07      	ldr	r3, [pc, #28]	; (24007ec4 <FLASH_MassErase+0xd0>)
24007ea8:	f8d3 310c 	ldr.w	r3, [r3, #268]	; 0x10c
24007eac:	4a05      	ldr	r2, [pc, #20]	; (24007ec4 <FLASH_MassErase+0xd0>)
24007eae:	f043 0388 	orr.w	r3, r3, #136	; 0x88
24007eb2:	f8c2 310c 	str.w	r3, [r2, #268]	; 0x10c
}
24007eb6:	bf00      	nop
24007eb8:	370c      	adds	r7, #12
24007eba:	46bd      	mov	sp, r7
24007ebc:	f85d 7b04 	ldr.w	r7, [sp], #4
24007ec0:	4770      	bx	lr
24007ec2:	bf00      	nop
24007ec4:	52002000 	.word	0x52002000

24007ec8 <FLASH_Erase_Sector>:
  *            @arg FLASH_VOLTAGE_RANGE_4 : Flash program/erase by 64 bits
  *
  * @retval None
  */
void FLASH_Erase_Sector(uint32_t Sector, uint32_t Banks, uint32_t VoltageRange)
{
24007ec8:	b480      	push	{r7}
24007eca:	b085      	sub	sp, #20
24007ecc:	af00      	add	r7, sp, #0
24007ece:	60f8      	str	r0, [r7, #12]
24007ed0:	60b9      	str	r1, [r7, #8]
24007ed2:	607a      	str	r2, [r7, #4]
  assert_param(IS_VOLTAGERANGE(VoltageRange));
#else
  UNUSED(VoltageRange);
#endif /* FLASH_CR_PSIZE */

  if((Banks & FLASH_BANK_1) == FLASH_BANK_1)
24007ed4:	68bb      	ldr	r3, [r7, #8]
24007ed6:	f003 0301 	and.w	r3, r3, #1
24007eda:	2b00      	cmp	r3, #0
24007edc:	d010      	beq.n	24007f00 <FLASH_Erase_Sector+0x38>
  {
#if defined (FLASH_CR_PSIZE)
    /* Reset Program/erase VoltageRange and Sector Number for Bank1 */
    FLASH->CR1 &= ~(FLASH_CR_PSIZE | FLASH_CR_SNB);
24007ede:	4b18      	ldr	r3, [pc, #96]	; (24007f40 <FLASH_Erase_Sector+0x78>)
24007ee0:	68db      	ldr	r3, [r3, #12]
24007ee2:	4a17      	ldr	r2, [pc, #92]	; (24007f40 <FLASH_Erase_Sector+0x78>)
24007ee4:	f423 63e6 	bic.w	r3, r3, #1840	; 0x730
24007ee8:	60d3      	str	r3, [r2, #12]

    FLASH->CR1 |= (FLASH_CR_SER | VoltageRange | (Sector << FLASH_CR_SNB_Pos) | FLASH_CR_START);
24007eea:	4b15      	ldr	r3, [pc, #84]	; (24007f40 <FLASH_Erase_Sector+0x78>)
24007eec:	68da      	ldr	r2, [r3, #12]
24007eee:	68fb      	ldr	r3, [r7, #12]
24007ef0:	0219      	lsls	r1, r3, #8
24007ef2:	687b      	ldr	r3, [r7, #4]
24007ef4:	430b      	orrs	r3, r1
24007ef6:	4313      	orrs	r3, r2
24007ef8:	4a11      	ldr	r2, [pc, #68]	; (24007f40 <FLASH_Erase_Sector+0x78>)
24007efa:	f043 0384 	orr.w	r3, r3, #132	; 0x84
24007efe:	60d3      	str	r3, [r2, #12]

    FLASH->CR1 |= (FLASH_CR_SER | (Sector << FLASH_CR_SNB_Pos) | FLASH_CR_START);
#endif /* FLASH_CR_PSIZE */
  }

  if((Banks & FLASH_BANK_2) == FLASH_BANK_2)
24007f00:	68bb      	ldr	r3, [r7, #8]
24007f02:	f003 0302 	and.w	r3, r3, #2
24007f06:	2b00      	cmp	r3, #0
24007f08:	d014      	beq.n	24007f34 <FLASH_Erase_Sector+0x6c>
  {
#if defined (FLASH_CR_PSIZE)
    /* Reset Program/erase VoltageRange and Sector Number for Bank2 */
    FLASH->CR2 &= ~(FLASH_CR_PSIZE | FLASH_CR_SNB);
24007f0a:	4b0d      	ldr	r3, [pc, #52]	; (24007f40 <FLASH_Erase_Sector+0x78>)
24007f0c:	f8d3 310c 	ldr.w	r3, [r3, #268]	; 0x10c
24007f10:	4a0b      	ldr	r2, [pc, #44]	; (24007f40 <FLASH_Erase_Sector+0x78>)
24007f12:	f423 63e6 	bic.w	r3, r3, #1840	; 0x730
24007f16:	f8c2 310c 	str.w	r3, [r2, #268]	; 0x10c

    FLASH->CR2 |= (FLASH_CR_SER | VoltageRange  | (Sector << FLASH_CR_SNB_Pos) | FLASH_CR_START);
24007f1a:	4b09      	ldr	r3, [pc, #36]	; (24007f40 <FLASH_Erase_Sector+0x78>)
24007f1c:	f8d3 210c 	ldr.w	r2, [r3, #268]	; 0x10c
24007f20:	68fb      	ldr	r3, [r7, #12]
24007f22:	0219      	lsls	r1, r3, #8
24007f24:	687b      	ldr	r3, [r7, #4]
24007f26:	430b      	orrs	r3, r1
24007f28:	4313      	orrs	r3, r2
24007f2a:	4a05      	ldr	r2, [pc, #20]	; (24007f40 <FLASH_Erase_Sector+0x78>)
24007f2c:	f043 0384 	orr.w	r3, r3, #132	; 0x84
24007f30:	f8c2 310c 	str.w	r3, [r2, #268]	; 0x10c
    FLASH->CR2 &= ~(FLASH_CR_SNB);

    FLASH->CR2 |= (FLASH_CR_SER | (Sector << FLASH_CR_SNB_Pos) | FLASH_CR_START);
#endif /* FLASH_CR_PSIZE */
  }
}
24007f34:	bf00      	nop
24007f36:	3714      	adds	r7, #20
24007f38:	46bd      	mov	sp, r7
24007f3a:	f85d 7b04 	ldr.w	r7, [sp], #4
24007f3e:	4770      	bx	lr
24007f40:	52002000 	.word	0x52002000

24007f44 <FLASH_OB_EnableWRP>:
  *            @arg FLASH_BANK_BOTH: enable WRP on both bank1 and bank2 specified sectors
  *
  * @retval HAL FLASH State
  */
static void FLASH_OB_EnableWRP(uint32_t WRPSector, uint32_t Banks)
{
24007f44:	b480      	push	{r7}
24007f46:	b083      	sub	sp, #12
24007f48:	af00      	add	r7, sp, #0
24007f4a:	6078      	str	r0, [r7, #4]
24007f4c:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_OB_WRP_SECTOR(WRPSector));
  assert_param(IS_FLASH_BANK(Banks));

  if((Banks & FLASH_BANK_1) == FLASH_BANK_1)
24007f4e:	683b      	ldr	r3, [r7, #0]
24007f50:	f003 0301 	and.w	r3, r3, #1
24007f54:	2b00      	cmp	r3, #0
24007f56:	d007      	beq.n	24007f68 <FLASH_OB_EnableWRP+0x24>
  {
    /* Enable Write Protection for bank 1 */
    FLASH->WPSN_PRG1 &= (~(WRPSector & FLASH_WPSN_WRPSN));
24007f58:	4b0e      	ldr	r3, [pc, #56]	; (24007f94 <FLASH_OB_EnableWRP+0x50>)
24007f5a:	6bda      	ldr	r2, [r3, #60]	; 0x3c
24007f5c:	687b      	ldr	r3, [r7, #4]
24007f5e:	b2db      	uxtb	r3, r3
24007f60:	43db      	mvns	r3, r3
24007f62:	490c      	ldr	r1, [pc, #48]	; (24007f94 <FLASH_OB_EnableWRP+0x50>)
24007f64:	4013      	ands	r3, r2
24007f66:	63cb      	str	r3, [r1, #60]	; 0x3c
  }

  if((Banks & FLASH_BANK_2) == FLASH_BANK_2)
24007f68:	683b      	ldr	r3, [r7, #0]
24007f6a:	f003 0302 	and.w	r3, r3, #2
24007f6e:	2b00      	cmp	r3, #0
24007f70:	d009      	beq.n	24007f86 <FLASH_OB_EnableWRP+0x42>
  {
    /* Enable Write Protection for bank 2 */
    FLASH->WPSN_PRG2 &= (~(WRPSector & FLASH_WPSN_WRPSN));
24007f72:	4b08      	ldr	r3, [pc, #32]	; (24007f94 <FLASH_OB_EnableWRP+0x50>)
24007f74:	f8d3 213c 	ldr.w	r2, [r3, #316]	; 0x13c
24007f78:	687b      	ldr	r3, [r7, #4]
24007f7a:	b2db      	uxtb	r3, r3
24007f7c:	43db      	mvns	r3, r3
24007f7e:	4905      	ldr	r1, [pc, #20]	; (24007f94 <FLASH_OB_EnableWRP+0x50>)
24007f80:	4013      	ands	r3, r2
24007f82:	f8c1 313c 	str.w	r3, [r1, #316]	; 0x13c
  }
}
24007f86:	bf00      	nop
24007f88:	370c      	adds	r7, #12
24007f8a:	46bd      	mov	sp, r7
24007f8c:	f85d 7b04 	ldr.w	r7, [sp], #4
24007f90:	4770      	bx	lr
24007f92:	bf00      	nop
24007f94:	52002000 	.word	0x52002000

24007f98 <FLASH_OB_DisableWRP>:
  *            @arg FLASH_BANK_BOTH: disable WRP on both bank1 and bank2 specified sectors
  *
  * @retval HAL FLASH State
  */
static void FLASH_OB_DisableWRP(uint32_t WRPSector, uint32_t Banks)
{
24007f98:	b480      	push	{r7}
24007f9a:	b083      	sub	sp, #12
24007f9c:	af00      	add	r7, sp, #0
24007f9e:	6078      	str	r0, [r7, #4]
24007fa0:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_OB_WRP_SECTOR(WRPSector));
  assert_param(IS_FLASH_BANK(Banks));

  if((Banks & FLASH_BANK_1) == FLASH_BANK_1)
24007fa2:	683b      	ldr	r3, [r7, #0]
24007fa4:	f003 0301 	and.w	r3, r3, #1
24007fa8:	2b00      	cmp	r3, #0
24007faa:	d006      	beq.n	24007fba <FLASH_OB_DisableWRP+0x22>
  {
    /* Disable Write Protection for bank 1 */
    FLASH->WPSN_PRG1 |= (WRPSector & FLASH_WPSN_WRPSN);
24007fac:	4b0d      	ldr	r3, [pc, #52]	; (24007fe4 <FLASH_OB_DisableWRP+0x4c>)
24007fae:	6bda      	ldr	r2, [r3, #60]	; 0x3c
24007fb0:	687b      	ldr	r3, [r7, #4]
24007fb2:	b2db      	uxtb	r3, r3
24007fb4:	490b      	ldr	r1, [pc, #44]	; (24007fe4 <FLASH_OB_DisableWRP+0x4c>)
24007fb6:	4313      	orrs	r3, r2
24007fb8:	63cb      	str	r3, [r1, #60]	; 0x3c
  }

  if((Banks & FLASH_BANK_2) == FLASH_BANK_2)
24007fba:	683b      	ldr	r3, [r7, #0]
24007fbc:	f003 0302 	and.w	r3, r3, #2
24007fc0:	2b00      	cmp	r3, #0
24007fc2:	d008      	beq.n	24007fd6 <FLASH_OB_DisableWRP+0x3e>
  {
    /* Disable Write Protection for bank 2 */
    FLASH->WPSN_PRG2 |= (WRPSector & FLASH_WPSN_WRPSN);
24007fc4:	4b07      	ldr	r3, [pc, #28]	; (24007fe4 <FLASH_OB_DisableWRP+0x4c>)
24007fc6:	f8d3 213c 	ldr.w	r2, [r3, #316]	; 0x13c
24007fca:	687b      	ldr	r3, [r7, #4]
24007fcc:	b2db      	uxtb	r3, r3
24007fce:	4905      	ldr	r1, [pc, #20]	; (24007fe4 <FLASH_OB_DisableWRP+0x4c>)
24007fd0:	4313      	orrs	r3, r2
24007fd2:	f8c1 313c 	str.w	r3, [r1, #316]	; 0x13c
  }
}
24007fd6:	bf00      	nop
24007fd8:	370c      	adds	r7, #12
24007fda:	46bd      	mov	sp, r7
24007fdc:	f85d 7b04 	ldr.w	r7, [sp], #4
24007fe0:	4770      	bx	lr
24007fe2:	bf00      	nop
24007fe4:	52002000 	.word	0x52002000

24007fe8 <FLASH_OB_GetWRP>:
  *            @arg FLASH_BANK_BOTH: note allowed in this functions
  *
  * @retval HAL FLASH State
  */
static void FLASH_OB_GetWRP(uint32_t *WRPState, uint32_t *WRPSector, uint32_t Bank)
{
24007fe8:	b480      	push	{r7}
24007fea:	b087      	sub	sp, #28
24007fec:	af00      	add	r7, sp, #0
24007fee:	60f8      	str	r0, [r7, #12]
24007ff0:	60b9      	str	r1, [r7, #8]
24007ff2:	607a      	str	r2, [r7, #4]
  uint32_t regvalue = 0U;
24007ff4:	2300      	movs	r3, #0
24007ff6:	617b      	str	r3, [r7, #20]

  if((Bank & FLASH_BANK_BOTH) == FLASH_BANK_1)
24007ff8:	687b      	ldr	r3, [r7, #4]
24007ffa:	f003 0303 	and.w	r3, r3, #3
24007ffe:	2b01      	cmp	r3, #1
24008000:	d102      	bne.n	24008008 <FLASH_OB_GetWRP+0x20>
  {
    regvalue = FLASH->WPSN_CUR1;
24008002:	4b11      	ldr	r3, [pc, #68]	; (24008048 <FLASH_OB_GetWRP+0x60>)
24008004:	6b9b      	ldr	r3, [r3, #56]	; 0x38
24008006:	617b      	str	r3, [r7, #20]
  }

  if((Bank & FLASH_BANK_BOTH) == FLASH_BANK_2)
24008008:	687b      	ldr	r3, [r7, #4]
2400800a:	f003 0303 	and.w	r3, r3, #3
2400800e:	2b02      	cmp	r3, #2
24008010:	d103      	bne.n	2400801a <FLASH_OB_GetWRP+0x32>
  {
    regvalue = FLASH->WPSN_CUR2;
24008012:	4b0d      	ldr	r3, [pc, #52]	; (24008048 <FLASH_OB_GetWRP+0x60>)
24008014:	f8d3 3138 	ldr.w	r3, [r3, #312]	; 0x138
24008018:	617b      	str	r3, [r7, #20]
  }

  (*WRPSector) = (~regvalue) & FLASH_WPSN_WRPSN;
2400801a:	697b      	ldr	r3, [r7, #20]
2400801c:	43db      	mvns	r3, r3
2400801e:	b2da      	uxtb	r2, r3
24008020:	68bb      	ldr	r3, [r7, #8]
24008022:	601a      	str	r2, [r3, #0]

  if(*WRPSector == 0U)
24008024:	68bb      	ldr	r3, [r7, #8]
24008026:	681b      	ldr	r3, [r3, #0]
24008028:	2b00      	cmp	r3, #0
2400802a:	d103      	bne.n	24008034 <FLASH_OB_GetWRP+0x4c>
  {
    (*WRPState) = OB_WRPSTATE_DISABLE;
2400802c:	68fb      	ldr	r3, [r7, #12]
2400802e:	2200      	movs	r2, #0
24008030:	601a      	str	r2, [r3, #0]
  }
  else
  {
    (*WRPState) = OB_WRPSTATE_ENABLE;
  }
}
24008032:	e002      	b.n	2400803a <FLASH_OB_GetWRP+0x52>
    (*WRPState) = OB_WRPSTATE_ENABLE;
24008034:	68fb      	ldr	r3, [r7, #12]
24008036:	2201      	movs	r2, #1
24008038:	601a      	str	r2, [r3, #0]
}
2400803a:	bf00      	nop
2400803c:	371c      	adds	r7, #28
2400803e:	46bd      	mov	sp, r7
24008040:	f85d 7b04 	ldr.w	r7, [sp], #4
24008044:	4770      	bx	lr
24008046:	bf00      	nop
24008048:	52002000 	.word	0x52002000

2400804c <FLASH_OB_RDPConfig>:
  *            @arg OB_RDP_LEVEL_2: Full chip protection
  *
  * @retval HAL status
  */
static void FLASH_OB_RDPConfig(uint32_t RDPLevel)
{
2400804c:	b480      	push	{r7}
2400804e:	b083      	sub	sp, #12
24008050:	af00      	add	r7, sp, #0
24008052:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_OB_RDP_LEVEL(RDPLevel));

  /* Configure the RDP level in the option bytes register */
  MODIFY_REG(FLASH->OPTSR_PRG, FLASH_OPTSR_RDP, RDPLevel);
24008054:	4b06      	ldr	r3, [pc, #24]	; (24008070 <FLASH_OB_RDPConfig+0x24>)
24008056:	6a1b      	ldr	r3, [r3, #32]
24008058:	f423 427f 	bic.w	r2, r3, #65280	; 0xff00
2400805c:	4904      	ldr	r1, [pc, #16]	; (24008070 <FLASH_OB_RDPConfig+0x24>)
2400805e:	687b      	ldr	r3, [r7, #4]
24008060:	4313      	orrs	r3, r2
24008062:	620b      	str	r3, [r1, #32]
}
24008064:	bf00      	nop
24008066:	370c      	adds	r7, #12
24008068:	46bd      	mov	sp, r7
2400806a:	f85d 7b04 	ldr.w	r7, [sp], #4
2400806e:	4770      	bx	lr
24008070:	52002000 	.word	0x52002000

24008074 <FLASH_OB_GetRDP>:
  *            @arg OB_RDP_LEVEL_0: No protection
  *            @arg OB_RDP_LEVEL_1: Read protection of the memory
  *            @arg OB_RDP_LEVEL_2: Full chip protection
  */
static uint32_t FLASH_OB_GetRDP(void)
{
24008074:	b480      	push	{r7}
24008076:	b083      	sub	sp, #12
24008078:	af00      	add	r7, sp, #0
  uint32_t rdp_level = READ_BIT(FLASH->OPTSR_CUR, FLASH_OPTSR_RDP);
2400807a:	4b0b      	ldr	r3, [pc, #44]	; (240080a8 <FLASH_OB_GetRDP+0x34>)
2400807c:	69db      	ldr	r3, [r3, #28]
2400807e:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
24008082:	607b      	str	r3, [r7, #4]
  
  if ((rdp_level != OB_RDP_LEVEL_0) && (rdp_level != OB_RDP_LEVEL_2))
24008084:	687b      	ldr	r3, [r7, #4]
24008086:	f5b3 4f2a 	cmp.w	r3, #43520	; 0xaa00
2400808a:	d006      	beq.n	2400809a <FLASH_OB_GetRDP+0x26>
2400808c:	687b      	ldr	r3, [r7, #4]
2400808e:	f5b3 4f4c 	cmp.w	r3, #52224	; 0xcc00
24008092:	d002      	beq.n	2400809a <FLASH_OB_GetRDP+0x26>
  {
    return (OB_RDP_LEVEL_1);
24008094:	f44f 43aa 	mov.w	r3, #21760	; 0x5500
24008098:	e000      	b.n	2400809c <FLASH_OB_GetRDP+0x28>
  }
  else
  {
    return rdp_level;
2400809a:	687b      	ldr	r3, [r7, #4]
  }
}
2400809c:	4618      	mov	r0, r3
2400809e:	370c      	adds	r7, #12
240080a0:	46bd      	mov	sp, r7
240080a2:	f85d 7b04 	ldr.w	r7, [sp], #4
240080a6:	4770      	bx	lr
240080a8:	52002000 	.word	0x52002000

240080ac <FLASH_OB_UserConfig>:
  *
  * @retval HAL status
  */
#endif /*DUAL_CORE*/
static void FLASH_OB_UserConfig(uint32_t UserType, uint32_t UserConfig)
{
240080ac:	b480      	push	{r7}
240080ae:	b085      	sub	sp, #20
240080b0:	af00      	add	r7, sp, #0
240080b2:	6078      	str	r0, [r7, #4]
240080b4:	6039      	str	r1, [r7, #0]
  uint32_t optr_reg_val = 0;
240080b6:	2300      	movs	r3, #0
240080b8:	60fb      	str	r3, [r7, #12]
  uint32_t optr_reg_mask = 0;
240080ba:	2300      	movs	r3, #0
240080bc:	60bb      	str	r3, [r7, #8]

  /* Check the parameters */
  assert_param(IS_OB_USER_TYPE(UserType));

  if((UserType & OB_USER_IWDG1_SW) != 0U)
240080be:	687b      	ldr	r3, [r7, #4]
240080c0:	f003 0301 	and.w	r3, r3, #1
240080c4:	2b00      	cmp	r3, #0
240080c6:	d009      	beq.n	240080dc <FLASH_OB_UserConfig+0x30>
  {
    /* IWDG_HW option byte should be modified */
    assert_param(IS_OB_IWDG1_SOURCE(UserConfig & FLASH_OPTSR_IWDG1_SW));

    /* Set value and mask for IWDG_HW option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTSR_IWDG1_SW);
240080c8:	683b      	ldr	r3, [r7, #0]
240080ca:	f003 0310 	and.w	r3, r3, #16
240080ce:	68fa      	ldr	r2, [r7, #12]
240080d0:	4313      	orrs	r3, r2
240080d2:	60fb      	str	r3, [r7, #12]
    optr_reg_mask |= FLASH_OPTSR_IWDG1_SW;
240080d4:	68bb      	ldr	r3, [r7, #8]
240080d6:	f043 0310 	orr.w	r3, r3, #16
240080da:	60bb      	str	r3, [r7, #8]
    /* Set value and mask for IWDG2_SW option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTSR_IWDG2_SW);
    optr_reg_mask |= FLASH_OPTSR_IWDG2_SW;
  }
#endif /*DUAL_CORE*/
  if((UserType & OB_USER_NRST_STOP_D1) != 0U)
240080dc:	687b      	ldr	r3, [r7, #4]
240080de:	f003 0302 	and.w	r3, r3, #2
240080e2:	2b00      	cmp	r3, #0
240080e4:	d009      	beq.n	240080fa <FLASH_OB_UserConfig+0x4e>
  {
    /* NRST_STOP option byte should be modified */
    assert_param(IS_OB_STOP_D1_RESET(UserConfig & FLASH_OPTSR_NRST_STOP_D1));

    /* Set value and mask for NRST_STOP option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTSR_NRST_STOP_D1);
240080e6:	683b      	ldr	r3, [r7, #0]
240080e8:	f003 0340 	and.w	r3, r3, #64	; 0x40
240080ec:	68fa      	ldr	r2, [r7, #12]
240080ee:	4313      	orrs	r3, r2
240080f0:	60fb      	str	r3, [r7, #12]
    optr_reg_mask |= FLASH_OPTSR_NRST_STOP_D1;
240080f2:	68bb      	ldr	r3, [r7, #8]
240080f4:	f043 0340 	orr.w	r3, r3, #64	; 0x40
240080f8:	60bb      	str	r3, [r7, #8]
  }

  if((UserType & OB_USER_NRST_STDBY_D1) != 0U)
240080fa:	687b      	ldr	r3, [r7, #4]
240080fc:	f003 0304 	and.w	r3, r3, #4
24008100:	2b00      	cmp	r3, #0
24008102:	d009      	beq.n	24008118 <FLASH_OB_UserConfig+0x6c>
  {
    /* NRST_STDBY option byte should be modified */
    assert_param(IS_OB_STDBY_D1_RESET(UserConfig & FLASH_OPTSR_NRST_STBY_D1));

    /* Set value and mask for NRST_STDBY option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTSR_NRST_STBY_D1);
24008104:	683b      	ldr	r3, [r7, #0]
24008106:	f003 0380 	and.w	r3, r3, #128	; 0x80
2400810a:	68fa      	ldr	r2, [r7, #12]
2400810c:	4313      	orrs	r3, r2
2400810e:	60fb      	str	r3, [r7, #12]
    optr_reg_mask |= FLASH_OPTSR_NRST_STBY_D1;
24008110:	68bb      	ldr	r3, [r7, #8]
24008112:	f043 0380 	orr.w	r3, r3, #128	; 0x80
24008116:	60bb      	str	r3, [r7, #8]
  }

  if((UserType & OB_USER_IWDG_STOP) != 0U)
24008118:	687b      	ldr	r3, [r7, #4]
2400811a:	f003 0308 	and.w	r3, r3, #8
2400811e:	2b00      	cmp	r3, #0
24008120:	d009      	beq.n	24008136 <FLASH_OB_UserConfig+0x8a>
  {
    /* IWDG_STOP option byte should be modified */
    assert_param(IS_OB_USER_IWDG_STOP(UserConfig & FLASH_OPTSR_FZ_IWDG_STOP));

    /* Set value and mask for IWDG_STOP option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTSR_FZ_IWDG_STOP);
24008122:	683b      	ldr	r3, [r7, #0]
24008124:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
24008128:	68fa      	ldr	r2, [r7, #12]
2400812a:	4313      	orrs	r3, r2
2400812c:	60fb      	str	r3, [r7, #12]
    optr_reg_mask |= FLASH_OPTSR_FZ_IWDG_STOP;
2400812e:	68bb      	ldr	r3, [r7, #8]
24008130:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
24008134:	60bb      	str	r3, [r7, #8]
  }

  if((UserType & OB_USER_IWDG_STDBY) != 0U)
24008136:	687b      	ldr	r3, [r7, #4]
24008138:	f003 0310 	and.w	r3, r3, #16
2400813c:	2b00      	cmp	r3, #0
2400813e:	d009      	beq.n	24008154 <FLASH_OB_UserConfig+0xa8>
  {
    /* IWDG_STDBY option byte should be modified */
    assert_param(IS_OB_USER_IWDG_STDBY(UserConfig & FLASH_OPTSR_FZ_IWDG_SDBY));

    /* Set value and mask for IWDG_STDBY option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTSR_FZ_IWDG_SDBY);
24008140:	683b      	ldr	r3, [r7, #0]
24008142:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
24008146:	68fa      	ldr	r2, [r7, #12]
24008148:	4313      	orrs	r3, r2
2400814a:	60fb      	str	r3, [r7, #12]
    optr_reg_mask |= FLASH_OPTSR_FZ_IWDG_SDBY;
2400814c:	68bb      	ldr	r3, [r7, #8]
2400814e:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
24008152:	60bb      	str	r3, [r7, #8]
  }

  if((UserType & OB_USER_ST_RAM_SIZE) != 0U)
24008154:	687b      	ldr	r3, [r7, #4]
24008156:	f003 0320 	and.w	r3, r3, #32
2400815a:	2b00      	cmp	r3, #0
2400815c:	d009      	beq.n	24008172 <FLASH_OB_UserConfig+0xc6>
  {
    /* ST_RAM_SIZE option byte should be modified */
    assert_param(IS_OB_USER_ST_RAM_SIZE(UserConfig & FLASH_OPTSR_ST_RAM_SIZE));

    /* Set value and mask for ST_RAM_SIZE option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTSR_ST_RAM_SIZE);
2400815e:	683b      	ldr	r3, [r7, #0]
24008160:	f403 13c0 	and.w	r3, r3, #1572864	; 0x180000
24008164:	68fa      	ldr	r2, [r7, #12]
24008166:	4313      	orrs	r3, r2
24008168:	60fb      	str	r3, [r7, #12]
    optr_reg_mask |= FLASH_OPTSR_ST_RAM_SIZE;
2400816a:	68bb      	ldr	r3, [r7, #8]
2400816c:	f443 13c0 	orr.w	r3, r3, #1572864	; 0x180000
24008170:	60bb      	str	r3, [r7, #8]
  }

  if((UserType & OB_USER_SECURITY) != 0U)
24008172:	687b      	ldr	r3, [r7, #4]
24008174:	f003 0340 	and.w	r3, r3, #64	; 0x40
24008178:	2b00      	cmp	r3, #0
2400817a:	d009      	beq.n	24008190 <FLASH_OB_UserConfig+0xe4>
  {
    /* SECURITY option byte should be modified */
    assert_param(IS_OB_USER_SECURITY(UserConfig & FLASH_OPTSR_SECURITY));

    /* Set value and mask for SECURITY option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTSR_SECURITY);
2400817c:	683b      	ldr	r3, [r7, #0]
2400817e:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
24008182:	68fa      	ldr	r2, [r7, #12]
24008184:	4313      	orrs	r3, r2
24008186:	60fb      	str	r3, [r7, #12]
    optr_reg_mask |= FLASH_OPTSR_SECURITY;
24008188:	68bb      	ldr	r3, [r7, #8]
2400818a:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
2400818e:	60bb      	str	r3, [r7, #8]
    /* Set value and mask for NRST_STDBY option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTSR_NRST_STBY_D2);
    optr_reg_mask |= FLASH_OPTSR_NRST_STBY_D2;
  }
#endif /* DUAL_CORE */
  if((UserType & OB_USER_SWAP_BANK) != 0U)
24008190:	687b      	ldr	r3, [r7, #4]
24008192:	f403 7380 	and.w	r3, r3, #256	; 0x100
24008196:	2b00      	cmp	r3, #0
24008198:	d009      	beq.n	240081ae <FLASH_OB_UserConfig+0x102>
  {
    /* SWAP_BANK_OPT option byte should be modified */
    assert_param(IS_OB_USER_SWAP_BANK(UserConfig & FLASH_OPTSR_SWAP_BANK_OPT));

    /* Set value and mask for SWAP_BANK_OPT option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTSR_SWAP_BANK_OPT);
2400819a:	683b      	ldr	r3, [r7, #0]
2400819c:	f003 4300 	and.w	r3, r3, #2147483648	; 0x80000000
240081a0:	68fa      	ldr	r2, [r7, #12]
240081a2:	4313      	orrs	r3, r2
240081a4:	60fb      	str	r3, [r7, #12]
    optr_reg_mask |= FLASH_OPTSR_SWAP_BANK_OPT;
240081a6:	68bb      	ldr	r3, [r7, #8]
240081a8:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
240081ac:	60bb      	str	r3, [r7, #8]
  }

  if((UserType & OB_USER_IOHSLV) != 0U)
240081ae:	687b      	ldr	r3, [r7, #4]
240081b0:	f003 0380 	and.w	r3, r3, #128	; 0x80
240081b4:	2b00      	cmp	r3, #0
240081b6:	d009      	beq.n	240081cc <FLASH_OB_UserConfig+0x120>
  {
    /* IOHSLV_OPT option byte should be modified */
    assert_param(IS_OB_USER_IOHSLV(UserConfig & FLASH_OPTSR_IO_HSLV));

    /* Set value and mask for IOHSLV_OPT option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTSR_IO_HSLV);
240081b8:	683b      	ldr	r3, [r7, #0]
240081ba:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
240081be:	68fa      	ldr	r2, [r7, #12]
240081c0:	4313      	orrs	r3, r2
240081c2:	60fb      	str	r3, [r7, #12]
    optr_reg_mask |= FLASH_OPTSR_IO_HSLV;
240081c4:	68bb      	ldr	r3, [r7, #8]
240081c6:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
240081ca:	60bb      	str	r3, [r7, #8]
    optr_reg_mask |= FLASH_OPTSR_VDDMMC_HSLV;
  }
#endif /* FLASH_OPTSR_VDDMMC_HSLV */

  /* Configure the option bytes register */
  MODIFY_REG(FLASH->OPTSR_PRG, optr_reg_mask, optr_reg_val);
240081cc:	4b07      	ldr	r3, [pc, #28]	; (240081ec <FLASH_OB_UserConfig+0x140>)
240081ce:	6a1a      	ldr	r2, [r3, #32]
240081d0:	68bb      	ldr	r3, [r7, #8]
240081d2:	43db      	mvns	r3, r3
240081d4:	401a      	ands	r2, r3
240081d6:	4905      	ldr	r1, [pc, #20]	; (240081ec <FLASH_OB_UserConfig+0x140>)
240081d8:	68fb      	ldr	r3, [r7, #12]
240081da:	4313      	orrs	r3, r2
240081dc:	620b      	str	r3, [r1, #32]
}
240081de:	bf00      	nop
240081e0:	3714      	adds	r7, #20
240081e2:	46bd      	mov	sp, r7
240081e4:	f85d 7b04 	ldr.w	r7, [sp], #4
240081e8:	4770      	bx	lr
240081ea:	bf00      	nop
240081ec:	52002000 	.word	0x52002000

240081f0 <FLASH_OB_GetUser>:
  *         FZ_IWDG_STOP(Bit 17), FZ_IWDG_SDBY(Bit 18), ST_RAM_SIZE(Bit[19:20]),
  *         SECURITY(Bit 21), IO_HSLV (Bit 29) and SWAP_BANK_OPT(Bit 31).
  */
#endif /*DUAL_CORE*/
static uint32_t FLASH_OB_GetUser(void)
{
240081f0:	b480      	push	{r7}
240081f2:	b083      	sub	sp, #12
240081f4:	af00      	add	r7, sp, #0
  uint32_t userConfig = READ_REG(FLASH->OPTSR_CUR);
240081f6:	4b07      	ldr	r3, [pc, #28]	; (24008214 <FLASH_OB_GetUser+0x24>)
240081f8:	69db      	ldr	r3, [r3, #28]
240081fa:	607b      	str	r3, [r7, #4]
  userConfig &= (~(FLASH_OPTSR_BOR_LEV | FLASH_OPTSR_RDP));
240081fc:	687a      	ldr	r2, [r7, #4]
240081fe:	4b06      	ldr	r3, [pc, #24]	; (24008218 <FLASH_OB_GetUser+0x28>)
24008200:	4013      	ands	r3, r2
24008202:	607b      	str	r3, [r7, #4]

  return userConfig;
24008204:	687b      	ldr	r3, [r7, #4]
}
24008206:	4618      	mov	r0, r3
24008208:	370c      	adds	r7, #12
2400820a:	46bd      	mov	sp, r7
2400820c:	f85d 7b04 	ldr.w	r7, [sp], #4
24008210:	4770      	bx	lr
24008212:	bf00      	nop
24008214:	52002000 	.word	0x52002000
24008218:	ffff00f3 	.word	0xffff00f3

2400821c <FLASH_OB_PCROPConfig>:
  *            @arg FLASH_BANK_BOTH: PCROP on specified bank1 and bank2 area (same config will be applied on both banks)
  *
  * @retval None
  */
static void FLASH_OB_PCROPConfig(uint32_t PCROPConfig, uint32_t PCROPStartAddr, uint32_t PCROPEndAddr, uint32_t Banks)
{
2400821c:	b480      	push	{r7}
2400821e:	b085      	sub	sp, #20
24008220:	af00      	add	r7, sp, #0
24008222:	60f8      	str	r0, [r7, #12]
24008224:	60b9      	str	r1, [r7, #8]
24008226:	607a      	str	r2, [r7, #4]
24008228:	603b      	str	r3, [r7, #0]
  /* Check the parameters */
  assert_param(IS_FLASH_BANK(Banks));
  assert_param(IS_OB_PCROP_RDP(PCROPConfig));

  if((Banks & FLASH_BANK_1) == FLASH_BANK_1)
2400822a:	683b      	ldr	r3, [r7, #0]
2400822c:	f003 0301 	and.w	r3, r3, #1
24008230:	2b00      	cmp	r3, #0
24008232:	d00d      	beq.n	24008250 <FLASH_OB_PCROPConfig+0x34>
  {
    assert_param(IS_FLASH_PROGRAM_ADDRESS_BANK1(PCROPStartAddr));
    assert_param(IS_FLASH_PROGRAM_ADDRESS_BANK1(PCROPEndAddr));

    /* Configure the Proprietary code readout protection */
    FLASH->PRAR_PRG1 = ((PCROPStartAddr - FLASH_BANK1_BASE) >> 8)                                 | \
24008234:	68bb      	ldr	r3, [r7, #8]
24008236:	f103 4378 	add.w	r3, r3, #4160749568	; 0xf8000000
2400823a:	0a1a      	lsrs	r2, r3, #8
                       (((PCROPEndAddr - FLASH_BANK1_BASE) >> 8) << FLASH_PRAR_PROT_AREA_END_Pos) | \
2400823c:	687b      	ldr	r3, [r7, #4]
2400823e:	f103 4378 	add.w	r3, r3, #4160749568	; 0xf8000000
24008242:	0a1b      	lsrs	r3, r3, #8
24008244:	041b      	lsls	r3, r3, #16
    FLASH->PRAR_PRG1 = ((PCROPStartAddr - FLASH_BANK1_BASE) >> 8)                                 | \
24008246:	431a      	orrs	r2, r3
24008248:	490e      	ldr	r1, [pc, #56]	; (24008284 <FLASH_OB_PCROPConfig+0x68>)
                       (((PCROPEndAddr - FLASH_BANK1_BASE) >> 8) << FLASH_PRAR_PROT_AREA_END_Pos) | \
2400824a:	68fb      	ldr	r3, [r7, #12]
2400824c:	4313      	orrs	r3, r2
    FLASH->PRAR_PRG1 = ((PCROPStartAddr - FLASH_BANK1_BASE) >> 8)                                 | \
2400824e:	62cb      	str	r3, [r1, #44]	; 0x2c
                       PCROPConfig;
  }

  if((Banks & FLASH_BANK_2) == FLASH_BANK_2)
24008250:	683b      	ldr	r3, [r7, #0]
24008252:	f003 0302 	and.w	r3, r3, #2
24008256:	2b00      	cmp	r3, #0
24008258:	d00e      	beq.n	24008278 <FLASH_OB_PCROPConfig+0x5c>
  {
    assert_param(IS_FLASH_PROGRAM_ADDRESS_BANK2(PCROPStartAddr));
    assert_param(IS_FLASH_PROGRAM_ADDRESS_BANK2(PCROPEndAddr));

    /* Configure the Proprietary code readout protection */
    FLASH->PRAR_PRG2 = ((PCROPStartAddr - FLASH_BANK2_BASE) >> 8)                                 | \
2400825a:	68bb      	ldr	r3, [r7, #8]
2400825c:	f1a3 6301 	sub.w	r3, r3, #135266304	; 0x8100000
24008260:	0a1a      	lsrs	r2, r3, #8
                       (((PCROPEndAddr - FLASH_BANK2_BASE) >> 8) << FLASH_PRAR_PROT_AREA_END_Pos) | \
24008262:	687b      	ldr	r3, [r7, #4]
24008264:	f1a3 6301 	sub.w	r3, r3, #135266304	; 0x8100000
24008268:	0a1b      	lsrs	r3, r3, #8
2400826a:	041b      	lsls	r3, r3, #16
    FLASH->PRAR_PRG2 = ((PCROPStartAddr - FLASH_BANK2_BASE) >> 8)                                 | \
2400826c:	431a      	orrs	r2, r3
2400826e:	4905      	ldr	r1, [pc, #20]	; (24008284 <FLASH_OB_PCROPConfig+0x68>)
                       (((PCROPEndAddr - FLASH_BANK2_BASE) >> 8) << FLASH_PRAR_PROT_AREA_END_Pos) | \
24008270:	68fb      	ldr	r3, [r7, #12]
24008272:	4313      	orrs	r3, r2
    FLASH->PRAR_PRG2 = ((PCROPStartAddr - FLASH_BANK2_BASE) >> 8)                                 | \
24008274:	f8c1 312c 	str.w	r3, [r1, #300]	; 0x12c
                       PCROPConfig;
  }
}
24008278:	bf00      	nop
2400827a:	3714      	adds	r7, #20
2400827c:	46bd      	mov	sp, r7
2400827e:	f85d 7b04 	ldr.w	r7, [sp], #4
24008282:	4770      	bx	lr
24008284:	52002000 	.word	0x52002000

24008288 <FLASH_OB_GetPCROP>:
  *            @arg FLASH_BANK_BOTH: is  not allowed here
  *
  * @retval None
  */
static void FLASH_OB_GetPCROP(uint32_t *PCROPConfig, uint32_t *PCROPStartAddr, uint32_t *PCROPEndAddr, uint32_t Bank)
{
24008288:	b480      	push	{r7}
2400828a:	b087      	sub	sp, #28
2400828c:	af00      	add	r7, sp, #0
2400828e:	60f8      	str	r0, [r7, #12]
24008290:	60b9      	str	r1, [r7, #8]
24008292:	607a      	str	r2, [r7, #4]
24008294:	603b      	str	r3, [r7, #0]
  uint32_t regvalue = 0;
24008296:	2300      	movs	r3, #0
24008298:	617b      	str	r3, [r7, #20]
  uint32_t bankBase = 0;
2400829a:	2300      	movs	r3, #0
2400829c:	613b      	str	r3, [r7, #16]

  if((Bank & FLASH_BANK_BOTH) == FLASH_BANK_1)
2400829e:	683b      	ldr	r3, [r7, #0]
240082a0:	f003 0303 	and.w	r3, r3, #3
240082a4:	2b01      	cmp	r3, #1
240082a6:	d105      	bne.n	240082b4 <FLASH_OB_GetPCROP+0x2c>
  {
    regvalue = FLASH->PRAR_CUR1;
240082a8:	4b18      	ldr	r3, [pc, #96]	; (2400830c <FLASH_OB_GetPCROP+0x84>)
240082aa:	6a9b      	ldr	r3, [r3, #40]	; 0x28
240082ac:	617b      	str	r3, [r7, #20]
    bankBase = FLASH_BANK1_BASE;
240082ae:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
240082b2:	613b      	str	r3, [r7, #16]
  }

  if((Bank & FLASH_BANK_BOTH) == FLASH_BANK_2)
240082b4:	683b      	ldr	r3, [r7, #0]
240082b6:	f003 0303 	and.w	r3, r3, #3
240082ba:	2b02      	cmp	r3, #2
240082bc:	d106      	bne.n	240082cc <FLASH_OB_GetPCROP+0x44>
  {
    regvalue = FLASH->PRAR_CUR2;
240082be:	4b13      	ldr	r3, [pc, #76]	; (2400830c <FLASH_OB_GetPCROP+0x84>)
240082c0:	f8d3 3128 	ldr.w	r3, [r3, #296]	; 0x128
240082c4:	617b      	str	r3, [r7, #20]
    bankBase = FLASH_BANK2_BASE;
240082c6:	f04f 6301 	mov.w	r3, #135266304	; 0x8100000
240082ca:	613b      	str	r3, [r7, #16]
  }

  (*PCROPConfig) =  (regvalue & FLASH_PRAR_DMEP);
240082cc:	697b      	ldr	r3, [r7, #20]
240082ce:	f003 4200 	and.w	r2, r3, #2147483648	; 0x80000000
240082d2:	68fb      	ldr	r3, [r7, #12]
240082d4:	601a      	str	r2, [r3, #0]

  (*PCROPStartAddr) = ((regvalue & FLASH_PRAR_PROT_AREA_START) << 8) + bankBase;
240082d6:	697b      	ldr	r3, [r7, #20]
240082d8:	021a      	lsls	r2, r3, #8
240082da:	4b0d      	ldr	r3, [pc, #52]	; (24008310 <FLASH_OB_GetPCROP+0x88>)
240082dc:	4013      	ands	r3, r2
240082de:	693a      	ldr	r2, [r7, #16]
240082e0:	441a      	add	r2, r3
240082e2:	68bb      	ldr	r3, [r7, #8]
240082e4:	601a      	str	r2, [r3, #0]
  (*PCROPEndAddr) = (regvalue & FLASH_PRAR_PROT_AREA_END) >> FLASH_PRAR_PROT_AREA_END_Pos;
240082e6:	697b      	ldr	r3, [r7, #20]
240082e8:	0c1b      	lsrs	r3, r3, #16
240082ea:	f3c3 020b 	ubfx	r2, r3, #0, #12
240082ee:	687b      	ldr	r3, [r7, #4]
240082f0:	601a      	str	r2, [r3, #0]
  (*PCROPEndAddr) = ((*PCROPEndAddr) << 8) + bankBase;
240082f2:	687b      	ldr	r3, [r7, #4]
240082f4:	681b      	ldr	r3, [r3, #0]
240082f6:	021a      	lsls	r2, r3, #8
240082f8:	693b      	ldr	r3, [r7, #16]
240082fa:	441a      	add	r2, r3
240082fc:	687b      	ldr	r3, [r7, #4]
240082fe:	601a      	str	r2, [r3, #0]
}
24008300:	bf00      	nop
24008302:	371c      	adds	r7, #28
24008304:	46bd      	mov	sp, r7
24008306:	f85d 7b04 	ldr.w	r7, [sp], #4
2400830a:	4770      	bx	lr
2400830c:	52002000 	.word	0x52002000
24008310:	000fff00 	.word	0x000fff00

24008314 <FLASH_OB_BOR_LevelConfig>:
  *            @arg OB_BOR_LEVEL2: Reset level threshold is set to 2.4V
  *            @arg OB_BOR_LEVEL3: Reset level threshold is set to 2.7V
  * @retval None
  */
static void FLASH_OB_BOR_LevelConfig(uint32_t Level)
{
24008314:	b480      	push	{r7}
24008316:	b083      	sub	sp, #12
24008318:	af00      	add	r7, sp, #0
2400831a:	6078      	str	r0, [r7, #4]
  assert_param(IS_OB_BOR_LEVEL(Level));

  /* Configure BOR_LEV option byte */
  MODIFY_REG(FLASH->OPTSR_PRG, FLASH_OPTSR_BOR_LEV, Level);
2400831c:	4b06      	ldr	r3, [pc, #24]	; (24008338 <FLASH_OB_BOR_LevelConfig+0x24>)
2400831e:	6a1b      	ldr	r3, [r3, #32]
24008320:	f023 020c 	bic.w	r2, r3, #12
24008324:	4904      	ldr	r1, [pc, #16]	; (24008338 <FLASH_OB_BOR_LevelConfig+0x24>)
24008326:	687b      	ldr	r3, [r7, #4]
24008328:	4313      	orrs	r3, r2
2400832a:	620b      	str	r3, [r1, #32]
}
2400832c:	bf00      	nop
2400832e:	370c      	adds	r7, #12
24008330:	46bd      	mov	sp, r7
24008332:	f85d 7b04 	ldr.w	r7, [sp], #4
24008336:	4770      	bx	lr
24008338:	52002000 	.word	0x52002000

2400833c <FLASH_OB_GetBOR>:
  *            @arg OB_BOR_LEVEL1: Reset level threshold is set to 2.1V
  *            @arg OB_BOR_LEVEL2: Reset level threshold is set to 2.4V
  *            @arg OB_BOR_LEVEL3: Reset level threshold is set to 2.7V
  */
static uint32_t FLASH_OB_GetBOR(void)
{
2400833c:	b480      	push	{r7}
2400833e:	af00      	add	r7, sp, #0
  return (FLASH->OPTSR_CUR & FLASH_OPTSR_BOR_LEV);
24008340:	4b04      	ldr	r3, [pc, #16]	; (24008354 <FLASH_OB_GetBOR+0x18>)
24008342:	69db      	ldr	r3, [r3, #28]
24008344:	f003 030c 	and.w	r3, r3, #12
}
24008348:	4618      	mov	r0, r3
2400834a:	46bd      	mov	sp, r7
2400834c:	f85d 7b04 	ldr.w	r7, [sp], #4
24008350:	4770      	bx	lr
24008352:	bf00      	nop
24008354:	52002000 	.word	0x52002000

24008358 <FLASH_OB_BootAddConfig>:
  * @param  BootAddress0 Specifies the Boot Address 0
  * @param  BootAddress1 Specifies the Boot Address 1
  * @retval HAL Status
  */
static void FLASH_OB_BootAddConfig(uint32_t BootOption, uint32_t BootAddress0, uint32_t BootAddress1)
{
24008358:	b480      	push	{r7}
2400835a:	b085      	sub	sp, #20
2400835c:	af00      	add	r7, sp, #0
2400835e:	60f8      	str	r0, [r7, #12]
24008360:	60b9      	str	r1, [r7, #8]
24008362:	607a      	str	r2, [r7, #4]
  /* Check the parameters */
  assert_param(IS_OB_BOOT_ADD_OPTION(BootOption));

  if((BootOption & OB_BOOT_ADD0) == OB_BOOT_ADD0)
24008364:	68fb      	ldr	r3, [r7, #12]
24008366:	f003 0301 	and.w	r3, r3, #1
2400836a:	2b00      	cmp	r3, #0
2400836c:	d008      	beq.n	24008380 <FLASH_OB_BootAddConfig+0x28>

    /* Configure CM7 BOOT ADD0 */
#if defined(DUAL_CORE)
    MODIFY_REG(FLASH->BOOT7_PRG, FLASH_BOOT7_BCM7_ADD0, (BootAddress0 >> 16));
#else /* Single Core*/
    MODIFY_REG(FLASH->BOOT_PRG, FLASH_BOOT_ADD0, (BootAddress0 >> 16));
2400836e:	4b0d      	ldr	r3, [pc, #52]	; (240083a4 <FLASH_OB_BootAddConfig+0x4c>)
24008370:	6c5a      	ldr	r2, [r3, #68]	; 0x44
24008372:	4b0d      	ldr	r3, [pc, #52]	; (240083a8 <FLASH_OB_BootAddConfig+0x50>)
24008374:	4013      	ands	r3, r2
24008376:	68ba      	ldr	r2, [r7, #8]
24008378:	0c12      	lsrs	r2, r2, #16
2400837a:	490a      	ldr	r1, [pc, #40]	; (240083a4 <FLASH_OB_BootAddConfig+0x4c>)
2400837c:	4313      	orrs	r3, r2
2400837e:	644b      	str	r3, [r1, #68]	; 0x44
#endif /* DUAL_CORE */
  }

  if((BootOption & OB_BOOT_ADD1) == OB_BOOT_ADD1)
24008380:	68fb      	ldr	r3, [r7, #12]
24008382:	f003 0302 	and.w	r3, r3, #2
24008386:	2b00      	cmp	r3, #0
24008388:	d006      	beq.n	24008398 <FLASH_OB_BootAddConfig+0x40>

    /* Configure CM7 BOOT ADD1 */
#if defined(DUAL_CORE)
    MODIFY_REG(FLASH->BOOT7_PRG, FLASH_BOOT7_BCM7_ADD1, BootAddress1);
#else /* Single Core*/
    MODIFY_REG(FLASH->BOOT_PRG, FLASH_BOOT_ADD1, BootAddress1);
2400838a:	4b06      	ldr	r3, [pc, #24]	; (240083a4 <FLASH_OB_BootAddConfig+0x4c>)
2400838c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400838e:	b29a      	uxth	r2, r3
24008390:	4904      	ldr	r1, [pc, #16]	; (240083a4 <FLASH_OB_BootAddConfig+0x4c>)
24008392:	687b      	ldr	r3, [r7, #4]
24008394:	4313      	orrs	r3, r2
24008396:	644b      	str	r3, [r1, #68]	; 0x44
#endif /* DUAL_CORE */
  }
}
24008398:	bf00      	nop
2400839a:	3714      	adds	r7, #20
2400839c:	46bd      	mov	sp, r7
2400839e:	f85d 7b04 	ldr.w	r7, [sp], #4
240083a2:	4770      	bx	lr
240083a4:	52002000 	.word	0x52002000
240083a8:	ffff0000 	.word	0xffff0000

240083ac <FLASH_OB_GetBootAdd>:
  * @param  BootAddress0 Specifies the Boot Address 0.
  * @param  BootAddress1 Specifies the Boot Address 1.
  * @retval HAL Status
  */
static void FLASH_OB_GetBootAdd(uint32_t *BootAddress0, uint32_t *BootAddress1)
{
240083ac:	b480      	push	{r7}
240083ae:	b085      	sub	sp, #20
240083b0:	af00      	add	r7, sp, #0
240083b2:	6078      	str	r0, [r7, #4]
240083b4:	6039      	str	r1, [r7, #0]
  regvalue = FLASH->BOOT7_CUR;

  (*BootAddress0) = (regvalue & FLASH_BOOT7_BCM7_ADD0) << 16;
  (*BootAddress1) = (regvalue & FLASH_BOOT7_BCM7_ADD1);
#else /* Single Core */
  regvalue = FLASH->BOOT_CUR;
240083b6:	4b09      	ldr	r3, [pc, #36]	; (240083dc <FLASH_OB_GetBootAdd+0x30>)
240083b8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
240083ba:	60fb      	str	r3, [r7, #12]

  (*BootAddress0) = (regvalue & FLASH_BOOT_ADD0) << 16;
240083bc:	68fb      	ldr	r3, [r7, #12]
240083be:	041a      	lsls	r2, r3, #16
240083c0:	687b      	ldr	r3, [r7, #4]
240083c2:	601a      	str	r2, [r3, #0]
  (*BootAddress1) = (regvalue & FLASH_BOOT_ADD1);
240083c4:	68fa      	ldr	r2, [r7, #12]
240083c6:	4b06      	ldr	r3, [pc, #24]	; (240083e0 <FLASH_OB_GetBootAdd+0x34>)
240083c8:	4013      	ands	r3, r2
240083ca:	683a      	ldr	r2, [r7, #0]
240083cc:	6013      	str	r3, [r2, #0]
#endif /* DUAL_CORE */
}
240083ce:	bf00      	nop
240083d0:	3714      	adds	r7, #20
240083d2:	46bd      	mov	sp, r7
240083d4:	f85d 7b04 	ldr.w	r7, [sp], #4
240083d8:	4770      	bx	lr
240083da:	bf00      	nop
240083dc:	52002000 	.word	0x52002000
240083e0:	ffff0000 	.word	0xffff0000

240083e4 <FLASH_OB_SecureAreaConfig>:
  *            @arg FLASH_BANK_2: Secure area on specified bank2 area
  *            @arg FLASH_BANK_BOTH: Secure area on specified bank1 and bank2 area (same config will be applied on both banks)
  * @retval None
  */
static void FLASH_OB_SecureAreaConfig(uint32_t SecureAreaConfig, uint32_t SecureAreaStartAddr, uint32_t SecureAreaEndAddr, uint32_t Banks)
{
240083e4:	b480      	push	{r7}
240083e6:	b085      	sub	sp, #20
240083e8:	af00      	add	r7, sp, #0
240083ea:	60f8      	str	r0, [r7, #12]
240083ec:	60b9      	str	r1, [r7, #8]
240083ee:	607a      	str	r2, [r7, #4]
240083f0:	603b      	str	r3, [r7, #0]
  /* Check the parameters */
  assert_param(IS_FLASH_BANK(Banks));
  assert_param(IS_OB_SECURE_RDP(SecureAreaConfig));

  if((Banks & FLASH_BANK_1) == FLASH_BANK_1)
240083f2:	683b      	ldr	r3, [r7, #0]
240083f4:	f003 0301 	and.w	r3, r3, #1
240083f8:	2b00      	cmp	r3, #0
240083fa:	d00f      	beq.n	2400841c <FLASH_OB_SecureAreaConfig+0x38>
    /* Check the parameters */
    assert_param(IS_FLASH_PROGRAM_ADDRESS_BANK1(SecureAreaStartAddr));
    assert_param(IS_FLASH_PROGRAM_ADDRESS_BANK1(SecureAreaEndAddr));

    /* Configure the secure area */
    FLASH->SCAR_PRG1 = ((SecureAreaStartAddr - FLASH_BANK1_BASE) >> 8)                                | \
240083fc:	68bb      	ldr	r3, [r7, #8]
240083fe:	f103 4378 	add.w	r3, r3, #4160749568	; 0xf8000000
24008402:	0a1a      	lsrs	r2, r3, #8
                       (((SecureAreaEndAddr - FLASH_BANK1_BASE) >> 8) << FLASH_SCAR_SEC_AREA_END_Pos) | \
24008404:	687b      	ldr	r3, [r7, #4]
24008406:	f103 4378 	add.w	r3, r3, #4160749568	; 0xf8000000
2400840a:	0a1b      	lsrs	r3, r3, #8
2400840c:	041b      	lsls	r3, r3, #16
    FLASH->SCAR_PRG1 = ((SecureAreaStartAddr - FLASH_BANK1_BASE) >> 8)                                | \
2400840e:	431a      	orrs	r2, r3
                       (SecureAreaConfig & FLASH_SCAR_DMES);
24008410:	68fb      	ldr	r3, [r7, #12]
24008412:	f003 4300 	and.w	r3, r3, #2147483648	; 0x80000000
    FLASH->SCAR_PRG1 = ((SecureAreaStartAddr - FLASH_BANK1_BASE) >> 8)                                | \
24008416:	490f      	ldr	r1, [pc, #60]	; (24008454 <FLASH_OB_SecureAreaConfig+0x70>)
                       (((SecureAreaEndAddr - FLASH_BANK1_BASE) >> 8) << FLASH_SCAR_SEC_AREA_END_Pos) | \
24008418:	4313      	orrs	r3, r2
    FLASH->SCAR_PRG1 = ((SecureAreaStartAddr - FLASH_BANK1_BASE) >> 8)                                | \
2400841a:	634b      	str	r3, [r1, #52]	; 0x34
  }

  if((Banks & FLASH_BANK_2) == FLASH_BANK_2)
2400841c:	683b      	ldr	r3, [r7, #0]
2400841e:	f003 0302 	and.w	r3, r3, #2
24008422:	2b00      	cmp	r3, #0
24008424:	d010      	beq.n	24008448 <FLASH_OB_SecureAreaConfig+0x64>
    /* Check the parameters */
    assert_param(IS_FLASH_PROGRAM_ADDRESS_BANK2(SecureAreaStartAddr));
    assert_param(IS_FLASH_PROGRAM_ADDRESS_BANK2(SecureAreaEndAddr));

    /* Configure the secure area */
    FLASH->SCAR_PRG2 = ((SecureAreaStartAddr - FLASH_BANK2_BASE) >> 8)                                | \
24008426:	68bb      	ldr	r3, [r7, #8]
24008428:	f1a3 6301 	sub.w	r3, r3, #135266304	; 0x8100000
2400842c:	0a1a      	lsrs	r2, r3, #8
                       (((SecureAreaEndAddr - FLASH_BANK2_BASE) >> 8) << FLASH_SCAR_SEC_AREA_END_Pos) | \
2400842e:	687b      	ldr	r3, [r7, #4]
24008430:	f1a3 6301 	sub.w	r3, r3, #135266304	; 0x8100000
24008434:	0a1b      	lsrs	r3, r3, #8
24008436:	041b      	lsls	r3, r3, #16
    FLASH->SCAR_PRG2 = ((SecureAreaStartAddr - FLASH_BANK2_BASE) >> 8)                                | \
24008438:	431a      	orrs	r2, r3
                       (SecureAreaConfig & FLASH_SCAR_DMES);
2400843a:	68fb      	ldr	r3, [r7, #12]
2400843c:	f003 4300 	and.w	r3, r3, #2147483648	; 0x80000000
    FLASH->SCAR_PRG2 = ((SecureAreaStartAddr - FLASH_BANK2_BASE) >> 8)                                | \
24008440:	4904      	ldr	r1, [pc, #16]	; (24008454 <FLASH_OB_SecureAreaConfig+0x70>)
                       (((SecureAreaEndAddr - FLASH_BANK2_BASE) >> 8) << FLASH_SCAR_SEC_AREA_END_Pos) | \
24008442:	4313      	orrs	r3, r2
    FLASH->SCAR_PRG2 = ((SecureAreaStartAddr - FLASH_BANK2_BASE) >> 8)                                | \
24008444:	f8c1 3134 	str.w	r3, [r1, #308]	; 0x134
  }
}
24008448:	bf00      	nop
2400844a:	3714      	adds	r7, #20
2400844c:	46bd      	mov	sp, r7
2400844e:	f85d 7b04 	ldr.w	r7, [sp], #4
24008452:	4770      	bx	lr
24008454:	52002000 	.word	0x52002000

24008458 <FLASH_OB_GetSecureArea>:
  * @param  SecureAreaEndAddr gives the secure area end address
  * @param  Bank Specifies the Bank
  * @retval None
  */
static void FLASH_OB_GetSecureArea(uint32_t *SecureAreaConfig, uint32_t *SecureAreaStartAddr, uint32_t *SecureAreaEndAddr, uint32_t Bank)
{
24008458:	b480      	push	{r7}
2400845a:	b087      	sub	sp, #28
2400845c:	af00      	add	r7, sp, #0
2400845e:	60f8      	str	r0, [r7, #12]
24008460:	60b9      	str	r1, [r7, #8]
24008462:	607a      	str	r2, [r7, #4]
24008464:	603b      	str	r3, [r7, #0]
  uint32_t regvalue = 0;
24008466:	2300      	movs	r3, #0
24008468:	617b      	str	r3, [r7, #20]
  uint32_t bankBase = 0;
2400846a:	2300      	movs	r3, #0
2400846c:	613b      	str	r3, [r7, #16]

  /* Check Bank parameter value */
  if((Bank & FLASH_BANK_BOTH) == FLASH_BANK_1)
2400846e:	683b      	ldr	r3, [r7, #0]
24008470:	f003 0303 	and.w	r3, r3, #3
24008474:	2b01      	cmp	r3, #1
24008476:	d105      	bne.n	24008484 <FLASH_OB_GetSecureArea+0x2c>
  {
    regvalue = FLASH->SCAR_CUR1;
24008478:	4b18      	ldr	r3, [pc, #96]	; (240084dc <FLASH_OB_GetSecureArea+0x84>)
2400847a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2400847c:	617b      	str	r3, [r7, #20]
    bankBase = FLASH_BANK1_BASE;
2400847e:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
24008482:	613b      	str	r3, [r7, #16]
  }

  if((Bank & FLASH_BANK_BOTH) == FLASH_BANK_2)
24008484:	683b      	ldr	r3, [r7, #0]
24008486:	f003 0303 	and.w	r3, r3, #3
2400848a:	2b02      	cmp	r3, #2
2400848c:	d106      	bne.n	2400849c <FLASH_OB_GetSecureArea+0x44>
  {
    regvalue = FLASH->SCAR_CUR2;
2400848e:	4b13      	ldr	r3, [pc, #76]	; (240084dc <FLASH_OB_GetSecureArea+0x84>)
24008490:	f8d3 3130 	ldr.w	r3, [r3, #304]	; 0x130
24008494:	617b      	str	r3, [r7, #20]
    bankBase = FLASH_BANK2_BASE;
24008496:	f04f 6301 	mov.w	r3, #135266304	; 0x8100000
2400849a:	613b      	str	r3, [r7, #16]
  }

  /* Get the secure area settings */
  (*SecureAreaConfig) = (regvalue & FLASH_SCAR_DMES);
2400849c:	697b      	ldr	r3, [r7, #20]
2400849e:	f003 4200 	and.w	r2, r3, #2147483648	; 0x80000000
240084a2:	68fb      	ldr	r3, [r7, #12]
240084a4:	601a      	str	r2, [r3, #0]
  (*SecureAreaStartAddr) = ((regvalue & FLASH_SCAR_SEC_AREA_START) << 8) + bankBase;
240084a6:	697b      	ldr	r3, [r7, #20]
240084a8:	021a      	lsls	r2, r3, #8
240084aa:	4b0d      	ldr	r3, [pc, #52]	; (240084e0 <FLASH_OB_GetSecureArea+0x88>)
240084ac:	4013      	ands	r3, r2
240084ae:	693a      	ldr	r2, [r7, #16]
240084b0:	441a      	add	r2, r3
240084b2:	68bb      	ldr	r3, [r7, #8]
240084b4:	601a      	str	r2, [r3, #0]
  (*SecureAreaEndAddr) = (regvalue & FLASH_SCAR_SEC_AREA_END) >> FLASH_SCAR_SEC_AREA_END_Pos;
240084b6:	697b      	ldr	r3, [r7, #20]
240084b8:	0c1b      	lsrs	r3, r3, #16
240084ba:	f3c3 020b 	ubfx	r2, r3, #0, #12
240084be:	687b      	ldr	r3, [r7, #4]
240084c0:	601a      	str	r2, [r3, #0]
  (*SecureAreaEndAddr) = ((*SecureAreaEndAddr) << 8) + bankBase;
240084c2:	687b      	ldr	r3, [r7, #4]
240084c4:	681b      	ldr	r3, [r3, #0]
240084c6:	021a      	lsls	r2, r3, #8
240084c8:	693b      	ldr	r3, [r7, #16]
240084ca:	441a      	add	r2, r3
240084cc:	687b      	ldr	r3, [r7, #4]
240084ce:	601a      	str	r2, [r3, #0]
}
240084d0:	bf00      	nop
240084d2:	371c      	adds	r7, #28
240084d4:	46bd      	mov	sp, r7
240084d6:	f85d 7b04 	ldr.w	r7, [sp], #4
240084da:	4770      	bx	lr
240084dc:	52002000 	.word	0x52002000
240084e0:	000fff00 	.word	0x000fff00

240084e4 <FLASH_CRC_AddSector>:
  * @param  Sector Specifies the CRC sector number
  * @param  Bank Specifies the Bank
  * @retval None
  */
static void FLASH_CRC_AddSector(uint32_t Sector, uint32_t Bank)
{
240084e4:	b480      	push	{r7}
240084e6:	b083      	sub	sp, #12
240084e8:	af00      	add	r7, sp, #0
240084ea:	6078      	str	r0, [r7, #4]
240084ec:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_FLASH_SECTOR(Sector));

  if (Bank == FLASH_BANK_1)
240084ee:	683b      	ldr	r3, [r7, #0]
240084f0:	2b01      	cmp	r3, #1
240084f2:	d10e      	bne.n	24008512 <FLASH_CRC_AddSector+0x2e>
  {
    /* Clear CRC sector */
    FLASH->CRCCR1 &= (~FLASH_CRCCR_CRC_SECT);
240084f4:	4b13      	ldr	r3, [pc, #76]	; (24008544 <FLASH_CRC_AddSector+0x60>)
240084f6:	6d1b      	ldr	r3, [r3, #80]	; 0x50
240084f8:	4a12      	ldr	r2, [pc, #72]	; (24008544 <FLASH_CRC_AddSector+0x60>)
240084fa:	f023 0307 	bic.w	r3, r3, #7
240084fe:	6513      	str	r3, [r2, #80]	; 0x50

    /* Select CRC Sector and activate ADD_SECT bit */
    FLASH->CRCCR1 |= Sector | FLASH_CRCCR_ADD_SECT;
24008500:	4b10      	ldr	r3, [pc, #64]	; (24008544 <FLASH_CRC_AddSector+0x60>)
24008502:	6d1a      	ldr	r2, [r3, #80]	; 0x50
24008504:	687b      	ldr	r3, [r7, #4]
24008506:	4313      	orrs	r3, r2
24008508:	4a0e      	ldr	r2, [pc, #56]	; (24008544 <FLASH_CRC_AddSector+0x60>)
2400850a:	f443 7300 	orr.w	r3, r3, #512	; 0x200
2400850e:	6513      	str	r3, [r2, #80]	; 0x50
    FLASH->CRCCR2 &= (~FLASH_CRCCR_CRC_SECT);

    /* Select CRC Sector and activate ADD_SECT bit */
    FLASH->CRCCR2 |= Sector | FLASH_CRCCR_ADD_SECT;
  }
}
24008510:	e011      	b.n	24008536 <FLASH_CRC_AddSector+0x52>
    FLASH->CRCCR2 &= (~FLASH_CRCCR_CRC_SECT);
24008512:	4b0c      	ldr	r3, [pc, #48]	; (24008544 <FLASH_CRC_AddSector+0x60>)
24008514:	f8d3 3150 	ldr.w	r3, [r3, #336]	; 0x150
24008518:	4a0a      	ldr	r2, [pc, #40]	; (24008544 <FLASH_CRC_AddSector+0x60>)
2400851a:	f023 0307 	bic.w	r3, r3, #7
2400851e:	f8c2 3150 	str.w	r3, [r2, #336]	; 0x150
    FLASH->CRCCR2 |= Sector | FLASH_CRCCR_ADD_SECT;
24008522:	4b08      	ldr	r3, [pc, #32]	; (24008544 <FLASH_CRC_AddSector+0x60>)
24008524:	f8d3 2150 	ldr.w	r2, [r3, #336]	; 0x150
24008528:	687b      	ldr	r3, [r7, #4]
2400852a:	4313      	orrs	r3, r2
2400852c:	4a05      	ldr	r2, [pc, #20]	; (24008544 <FLASH_CRC_AddSector+0x60>)
2400852e:	f443 7300 	orr.w	r3, r3, #512	; 0x200
24008532:	f8c2 3150 	str.w	r3, [r2, #336]	; 0x150
}
24008536:	bf00      	nop
24008538:	370c      	adds	r7, #12
2400853a:	46bd      	mov	sp, r7
2400853c:	f85d 7b04 	ldr.w	r7, [sp], #4
24008540:	4770      	bx	lr
24008542:	bf00      	nop
24008544:	52002000 	.word	0x52002000

24008548 <FLASH_CRC_SelectAddress>:
  * @param  CRCEndAddr Specifies the CRC end address
  * @param  Bank Specifies the Bank
  * @retval None
  */
static void FLASH_CRC_SelectAddress(uint32_t CRCStartAddr, uint32_t CRCEndAddr, uint32_t Bank)
{
24008548:	b480      	push	{r7}
2400854a:	b085      	sub	sp, #20
2400854c:	af00      	add	r7, sp, #0
2400854e:	60f8      	str	r0, [r7, #12]
24008550:	60b9      	str	r1, [r7, #8]
24008552:	607a      	str	r2, [r7, #4]
  if (Bank == FLASH_BANK_1)
24008554:	687b      	ldr	r3, [r7, #4]
24008556:	2b01      	cmp	r3, #1
24008558:	d106      	bne.n	24008568 <FLASH_CRC_SelectAddress+0x20>
  {
    assert_param(IS_FLASH_PROGRAM_ADDRESS_BANK1(CRCStartAddr));
    assert_param(IS_FLASH_PROGRAM_ADDRESS_BANK1(CRCEndAddr));

    /* Write CRC Start and End addresses */
    FLASH->CRCSADD1 = CRCStartAddr;
2400855a:	4a0a      	ldr	r2, [pc, #40]	; (24008584 <FLASH_CRC_SelectAddress+0x3c>)
2400855c:	68fb      	ldr	r3, [r7, #12]
2400855e:	6553      	str	r3, [r2, #84]	; 0x54
    FLASH->CRCEADD1 = CRCEndAddr;
24008560:	4a08      	ldr	r2, [pc, #32]	; (24008584 <FLASH_CRC_SelectAddress+0x3c>)
24008562:	68bb      	ldr	r3, [r7, #8]
24008564:	6593      	str	r3, [r2, #88]	; 0x58

    /* Write CRC Start and End addresses */
    FLASH->CRCSADD2 = CRCStartAddr;
    FLASH->CRCEADD2 = CRCEndAddr;
  }
}
24008566:	e007      	b.n	24008578 <FLASH_CRC_SelectAddress+0x30>
    FLASH->CRCSADD2 = CRCStartAddr;
24008568:	4a06      	ldr	r2, [pc, #24]	; (24008584 <FLASH_CRC_SelectAddress+0x3c>)
2400856a:	68fb      	ldr	r3, [r7, #12]
2400856c:	f8c2 3154 	str.w	r3, [r2, #340]	; 0x154
    FLASH->CRCEADD2 = CRCEndAddr;
24008570:	4a04      	ldr	r2, [pc, #16]	; (24008584 <FLASH_CRC_SelectAddress+0x3c>)
24008572:	68bb      	ldr	r3, [r7, #8]
24008574:	f8c2 3158 	str.w	r3, [r2, #344]	; 0x158
}
24008578:	bf00      	nop
2400857a:	3714      	adds	r7, #20
2400857c:	46bd      	mov	sp, r7
2400857e:	f85d 7b04 	ldr.w	r7, [sp], #4
24008582:	4770      	bx	lr
24008584:	52002000 	.word	0x52002000

24008588 <HAL_GPIO_Init>:
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
24008588:	b480      	push	{r7}
2400858a:	b089      	sub	sp, #36	; 0x24
2400858c:	af00      	add	r7, sp, #0
2400858e:	6078      	str	r0, [r7, #4]
24008590:	6039      	str	r1, [r7, #0]
  uint32_t position = 0x00U;
24008592:	2300      	movs	r3, #0
24008594:	61fb      	str	r3, [r7, #28]
  EXTI_Core_TypeDef *EXTI_CurrentCPU;

#if defined(DUAL_CORE) && defined(CORE_CM4)
  EXTI_CurrentCPU = EXTI_D2; /* EXTI for CM4 CPU */
#else
  EXTI_CurrentCPU = EXTI_D1; /* EXTI for CM7 CPU */
24008596:	4b89      	ldr	r3, [pc, #548]	; (240087bc <HAL_GPIO_Init+0x234>)
24008598:	617b      	str	r3, [r7, #20]
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0x00U)
2400859a:	e194      	b.n	240088c6 <HAL_GPIO_Init+0x33e>
  {
    /* Get current io position */
    iocurrent = (GPIO_Init->Pin) & (1UL << position);
2400859c:	683b      	ldr	r3, [r7, #0]
2400859e:	681a      	ldr	r2, [r3, #0]
240085a0:	2101      	movs	r1, #1
240085a2:	69fb      	ldr	r3, [r7, #28]
240085a4:	fa01 f303 	lsl.w	r3, r1, r3
240085a8:	4013      	ands	r3, r2
240085aa:	613b      	str	r3, [r7, #16]

    if (iocurrent != 0x00U)
240085ac:	693b      	ldr	r3, [r7, #16]
240085ae:	2b00      	cmp	r3, #0
240085b0:	f000 8186 	beq.w	240088c0 <HAL_GPIO_Init+0x338>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Output or Alternate function mode selection */
      if ((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
240085b4:	683b      	ldr	r3, [r7, #0]
240085b6:	685b      	ldr	r3, [r3, #4]
240085b8:	2b01      	cmp	r3, #1
240085ba:	d00b      	beq.n	240085d4 <HAL_GPIO_Init+0x4c>
240085bc:	683b      	ldr	r3, [r7, #0]
240085be:	685b      	ldr	r3, [r3, #4]
240085c0:	2b02      	cmp	r3, #2
240085c2:	d007      	beq.n	240085d4 <HAL_GPIO_Init+0x4c>
          (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
240085c4:	683b      	ldr	r3, [r7, #0]
240085c6:	685b      	ldr	r3, [r3, #4]
      if ((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
240085c8:	2b11      	cmp	r3, #17
240085ca:	d003      	beq.n	240085d4 <HAL_GPIO_Init+0x4c>
          (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
240085cc:	683b      	ldr	r3, [r7, #0]
240085ce:	685b      	ldr	r3, [r3, #4]
240085d0:	2b12      	cmp	r3, #18
240085d2:	d130      	bne.n	24008636 <HAL_GPIO_Init+0xae>
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR;
240085d4:	687b      	ldr	r3, [r7, #4]
240085d6:	689b      	ldr	r3, [r3, #8]
240085d8:	61bb      	str	r3, [r7, #24]
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
240085da:	69fb      	ldr	r3, [r7, #28]
240085dc:	005b      	lsls	r3, r3, #1
240085de:	2203      	movs	r2, #3
240085e0:	fa02 f303 	lsl.w	r3, r2, r3
240085e4:	43db      	mvns	r3, r3
240085e6:	69ba      	ldr	r2, [r7, #24]
240085e8:	4013      	ands	r3, r2
240085ea:	61bb      	str	r3, [r7, #24]
        temp |= (GPIO_Init->Speed << (position * 2U));
240085ec:	683b      	ldr	r3, [r7, #0]
240085ee:	68da      	ldr	r2, [r3, #12]
240085f0:	69fb      	ldr	r3, [r7, #28]
240085f2:	005b      	lsls	r3, r3, #1
240085f4:	fa02 f303 	lsl.w	r3, r2, r3
240085f8:	69ba      	ldr	r2, [r7, #24]
240085fa:	4313      	orrs	r3, r2
240085fc:	61bb      	str	r3, [r7, #24]
        GPIOx->OSPEEDR = temp;
240085fe:	687b      	ldr	r3, [r7, #4]
24008600:	69ba      	ldr	r2, [r7, #24]
24008602:	609a      	str	r2, [r3, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
24008604:	687b      	ldr	r3, [r7, #4]
24008606:	685b      	ldr	r3, [r3, #4]
24008608:	61bb      	str	r3, [r7, #24]
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
2400860a:	2201      	movs	r2, #1
2400860c:	69fb      	ldr	r3, [r7, #28]
2400860e:	fa02 f303 	lsl.w	r3, r2, r3
24008612:	43db      	mvns	r3, r3
24008614:	69ba      	ldr	r2, [r7, #24]
24008616:	4013      	ands	r3, r2
24008618:	61bb      	str	r3, [r7, #24]
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4U) << position);
2400861a:	683b      	ldr	r3, [r7, #0]
2400861c:	685b      	ldr	r3, [r3, #4]
2400861e:	091b      	lsrs	r3, r3, #4
24008620:	f003 0201 	and.w	r2, r3, #1
24008624:	69fb      	ldr	r3, [r7, #28]
24008626:	fa02 f303 	lsl.w	r3, r2, r3
2400862a:	69ba      	ldr	r2, [r7, #24]
2400862c:	4313      	orrs	r3, r2
2400862e:	61bb      	str	r3, [r7, #24]
        GPIOx->OTYPER = temp;
24008630:	687b      	ldr	r3, [r7, #4]
24008632:	69ba      	ldr	r2, [r7, #24]
24008634:	605a      	str	r2, [r3, #4]
      }

      /* Activate the Pull-up or Pull down resistor for the current IO */
      temp = GPIOx->PUPDR;
24008636:	687b      	ldr	r3, [r7, #4]
24008638:	68db      	ldr	r3, [r3, #12]
2400863a:	61bb      	str	r3, [r7, #24]
      temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
2400863c:	69fb      	ldr	r3, [r7, #28]
2400863e:	005b      	lsls	r3, r3, #1
24008640:	2203      	movs	r2, #3
24008642:	fa02 f303 	lsl.w	r3, r2, r3
24008646:	43db      	mvns	r3, r3
24008648:	69ba      	ldr	r2, [r7, #24]
2400864a:	4013      	ands	r3, r2
2400864c:	61bb      	str	r3, [r7, #24]
      temp |= ((GPIO_Init->Pull) << (position * 2U));
2400864e:	683b      	ldr	r3, [r7, #0]
24008650:	689a      	ldr	r2, [r3, #8]
24008652:	69fb      	ldr	r3, [r7, #28]
24008654:	005b      	lsls	r3, r3, #1
24008656:	fa02 f303 	lsl.w	r3, r2, r3
2400865a:	69ba      	ldr	r2, [r7, #24]
2400865c:	4313      	orrs	r3, r2
2400865e:	61bb      	str	r3, [r7, #24]
      GPIOx->PUPDR = temp;
24008660:	687b      	ldr	r3, [r7, #4]
24008662:	69ba      	ldr	r2, [r7, #24]
24008664:	60da      	str	r2, [r3, #12]

      /* In case of Alternate function mode selection */
      if ((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
24008666:	683b      	ldr	r3, [r7, #0]
24008668:	685b      	ldr	r3, [r3, #4]
2400866a:	2b02      	cmp	r3, #2
2400866c:	d003      	beq.n	24008676 <HAL_GPIO_Init+0xee>
2400866e:	683b      	ldr	r3, [r7, #0]
24008670:	685b      	ldr	r3, [r3, #4]
24008672:	2b12      	cmp	r3, #18
24008674:	d123      	bne.n	240086be <HAL_GPIO_Init+0x136>
        /* Check the Alternate function parameters */
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));

        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3U];
24008676:	69fb      	ldr	r3, [r7, #28]
24008678:	08da      	lsrs	r2, r3, #3
2400867a:	687b      	ldr	r3, [r7, #4]
2400867c:	3208      	adds	r2, #8
2400867e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
24008682:	61bb      	str	r3, [r7, #24]
        temp &= ~(0xFU << ((position & 0x07U) * 4U));
24008684:	69fb      	ldr	r3, [r7, #28]
24008686:	f003 0307 	and.w	r3, r3, #7
2400868a:	009b      	lsls	r3, r3, #2
2400868c:	220f      	movs	r2, #15
2400868e:	fa02 f303 	lsl.w	r3, r2, r3
24008692:	43db      	mvns	r3, r3
24008694:	69ba      	ldr	r2, [r7, #24]
24008696:	4013      	ands	r3, r2
24008698:	61bb      	str	r3, [r7, #24]
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07U) * 4U));
2400869a:	683b      	ldr	r3, [r7, #0]
2400869c:	691a      	ldr	r2, [r3, #16]
2400869e:	69fb      	ldr	r3, [r7, #28]
240086a0:	f003 0307 	and.w	r3, r3, #7
240086a4:	009b      	lsls	r3, r3, #2
240086a6:	fa02 f303 	lsl.w	r3, r2, r3
240086aa:	69ba      	ldr	r2, [r7, #24]
240086ac:	4313      	orrs	r3, r2
240086ae:	61bb      	str	r3, [r7, #24]
        GPIOx->AFR[position >> 3U] = temp;
240086b0:	69fb      	ldr	r3, [r7, #28]
240086b2:	08da      	lsrs	r2, r3, #3
240086b4:	687b      	ldr	r3, [r7, #4]
240086b6:	3208      	adds	r2, #8
240086b8:	69b9      	ldr	r1, [r7, #24]
240086ba:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
240086be:	687b      	ldr	r3, [r7, #4]
240086c0:	681b      	ldr	r3, [r3, #0]
240086c2:	61bb      	str	r3, [r7, #24]
      temp &= ~(GPIO_MODER_MODE0 << (position * 2U));
240086c4:	69fb      	ldr	r3, [r7, #28]
240086c6:	005b      	lsls	r3, r3, #1
240086c8:	2203      	movs	r2, #3
240086ca:	fa02 f303 	lsl.w	r3, r2, r3
240086ce:	43db      	mvns	r3, r3
240086d0:	69ba      	ldr	r2, [r7, #24]
240086d2:	4013      	ands	r3, r2
240086d4:	61bb      	str	r3, [r7, #24]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
240086d6:	683b      	ldr	r3, [r7, #0]
240086d8:	685b      	ldr	r3, [r3, #4]
240086da:	f003 0203 	and.w	r2, r3, #3
240086de:	69fb      	ldr	r3, [r7, #28]
240086e0:	005b      	lsls	r3, r3, #1
240086e2:	fa02 f303 	lsl.w	r3, r2, r3
240086e6:	69ba      	ldr	r2, [r7, #24]
240086e8:	4313      	orrs	r3, r2
240086ea:	61bb      	str	r3, [r7, #24]
      GPIOx->MODER = temp;
240086ec:	687b      	ldr	r3, [r7, #4]
240086ee:	69ba      	ldr	r2, [r7, #24]
240086f0:	601a      	str	r2, [r3, #0]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if ((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
240086f2:	683b      	ldr	r3, [r7, #0]
240086f4:	685b      	ldr	r3, [r3, #4]
240086f6:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
240086fa:	2b00      	cmp	r3, #0
240086fc:	f000 80e0 	beq.w	240088c0 <HAL_GPIO_Init+0x338>
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
24008700:	4b2f      	ldr	r3, [pc, #188]	; (240087c0 <HAL_GPIO_Init+0x238>)
24008702:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
24008706:	4a2e      	ldr	r2, [pc, #184]	; (240087c0 <HAL_GPIO_Init+0x238>)
24008708:	f043 0302 	orr.w	r3, r3, #2
2400870c:	f8c2 30f4 	str.w	r3, [r2, #244]	; 0xf4
24008710:	4b2b      	ldr	r3, [pc, #172]	; (240087c0 <HAL_GPIO_Init+0x238>)
24008712:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
24008716:	f003 0302 	and.w	r3, r3, #2
2400871a:	60fb      	str	r3, [r7, #12]
2400871c:	68fb      	ldr	r3, [r7, #12]

        temp = SYSCFG->EXTICR[position >> 2U];
2400871e:	4a29      	ldr	r2, [pc, #164]	; (240087c4 <HAL_GPIO_Init+0x23c>)
24008720:	69fb      	ldr	r3, [r7, #28]
24008722:	089b      	lsrs	r3, r3, #2
24008724:	3302      	adds	r3, #2
24008726:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
2400872a:	61bb      	str	r3, [r7, #24]
        temp &= ~(0x0FUL << (4U * (position & 0x03U)));
2400872c:	69fb      	ldr	r3, [r7, #28]
2400872e:	f003 0303 	and.w	r3, r3, #3
24008732:	009b      	lsls	r3, r3, #2
24008734:	220f      	movs	r2, #15
24008736:	fa02 f303 	lsl.w	r3, r2, r3
2400873a:	43db      	mvns	r3, r3
2400873c:	69ba      	ldr	r2, [r7, #24]
2400873e:	4013      	ands	r3, r2
24008740:	61bb      	str	r3, [r7, #24]
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
24008742:	687b      	ldr	r3, [r7, #4]
24008744:	4a20      	ldr	r2, [pc, #128]	; (240087c8 <HAL_GPIO_Init+0x240>)
24008746:	4293      	cmp	r3, r2
24008748:	d052      	beq.n	240087f0 <HAL_GPIO_Init+0x268>
2400874a:	687b      	ldr	r3, [r7, #4]
2400874c:	4a1f      	ldr	r2, [pc, #124]	; (240087cc <HAL_GPIO_Init+0x244>)
2400874e:	4293      	cmp	r3, r2
24008750:	d031      	beq.n	240087b6 <HAL_GPIO_Init+0x22e>
24008752:	687b      	ldr	r3, [r7, #4]
24008754:	4a1e      	ldr	r2, [pc, #120]	; (240087d0 <HAL_GPIO_Init+0x248>)
24008756:	4293      	cmp	r3, r2
24008758:	d02b      	beq.n	240087b2 <HAL_GPIO_Init+0x22a>
2400875a:	687b      	ldr	r3, [r7, #4]
2400875c:	4a1d      	ldr	r2, [pc, #116]	; (240087d4 <HAL_GPIO_Init+0x24c>)
2400875e:	4293      	cmp	r3, r2
24008760:	d025      	beq.n	240087ae <HAL_GPIO_Init+0x226>
24008762:	687b      	ldr	r3, [r7, #4]
24008764:	4a1c      	ldr	r2, [pc, #112]	; (240087d8 <HAL_GPIO_Init+0x250>)
24008766:	4293      	cmp	r3, r2
24008768:	d01f      	beq.n	240087aa <HAL_GPIO_Init+0x222>
2400876a:	687b      	ldr	r3, [r7, #4]
2400876c:	4a1b      	ldr	r2, [pc, #108]	; (240087dc <HAL_GPIO_Init+0x254>)
2400876e:	4293      	cmp	r3, r2
24008770:	d019      	beq.n	240087a6 <HAL_GPIO_Init+0x21e>
24008772:	687b      	ldr	r3, [r7, #4]
24008774:	4a1a      	ldr	r2, [pc, #104]	; (240087e0 <HAL_GPIO_Init+0x258>)
24008776:	4293      	cmp	r3, r2
24008778:	d013      	beq.n	240087a2 <HAL_GPIO_Init+0x21a>
2400877a:	687b      	ldr	r3, [r7, #4]
2400877c:	4a19      	ldr	r2, [pc, #100]	; (240087e4 <HAL_GPIO_Init+0x25c>)
2400877e:	4293      	cmp	r3, r2
24008780:	d00d      	beq.n	2400879e <HAL_GPIO_Init+0x216>
24008782:	687b      	ldr	r3, [r7, #4]
24008784:	4a18      	ldr	r2, [pc, #96]	; (240087e8 <HAL_GPIO_Init+0x260>)
24008786:	4293      	cmp	r3, r2
24008788:	d007      	beq.n	2400879a <HAL_GPIO_Init+0x212>
2400878a:	687b      	ldr	r3, [r7, #4]
2400878c:	4a17      	ldr	r2, [pc, #92]	; (240087ec <HAL_GPIO_Init+0x264>)
2400878e:	4293      	cmp	r3, r2
24008790:	d101      	bne.n	24008796 <HAL_GPIO_Init+0x20e>
24008792:	2309      	movs	r3, #9
24008794:	e02d      	b.n	240087f2 <HAL_GPIO_Init+0x26a>
24008796:	230a      	movs	r3, #10
24008798:	e02b      	b.n	240087f2 <HAL_GPIO_Init+0x26a>
2400879a:	2308      	movs	r3, #8
2400879c:	e029      	b.n	240087f2 <HAL_GPIO_Init+0x26a>
2400879e:	2307      	movs	r3, #7
240087a0:	e027      	b.n	240087f2 <HAL_GPIO_Init+0x26a>
240087a2:	2306      	movs	r3, #6
240087a4:	e025      	b.n	240087f2 <HAL_GPIO_Init+0x26a>
240087a6:	2305      	movs	r3, #5
240087a8:	e023      	b.n	240087f2 <HAL_GPIO_Init+0x26a>
240087aa:	2304      	movs	r3, #4
240087ac:	e021      	b.n	240087f2 <HAL_GPIO_Init+0x26a>
240087ae:	2303      	movs	r3, #3
240087b0:	e01f      	b.n	240087f2 <HAL_GPIO_Init+0x26a>
240087b2:	2302      	movs	r3, #2
240087b4:	e01d      	b.n	240087f2 <HAL_GPIO_Init+0x26a>
240087b6:	2301      	movs	r3, #1
240087b8:	e01b      	b.n	240087f2 <HAL_GPIO_Init+0x26a>
240087ba:	bf00      	nop
240087bc:	58000080 	.word	0x58000080
240087c0:	58024400 	.word	0x58024400
240087c4:	58000400 	.word	0x58000400
240087c8:	58020000 	.word	0x58020000
240087cc:	58020400 	.word	0x58020400
240087d0:	58020800 	.word	0x58020800
240087d4:	58020c00 	.word	0x58020c00
240087d8:	58021000 	.word	0x58021000
240087dc:	58021400 	.word	0x58021400
240087e0:	58021800 	.word	0x58021800
240087e4:	58021c00 	.word	0x58021c00
240087e8:	58022000 	.word	0x58022000
240087ec:	58022400 	.word	0x58022400
240087f0:	2300      	movs	r3, #0
240087f2:	69fa      	ldr	r2, [r7, #28]
240087f4:	f002 0203 	and.w	r2, r2, #3
240087f8:	0092      	lsls	r2, r2, #2
240087fa:	4093      	lsls	r3, r2
240087fc:	69ba      	ldr	r2, [r7, #24]
240087fe:	4313      	orrs	r3, r2
24008800:	61bb      	str	r3, [r7, #24]
        SYSCFG->EXTICR[position >> 2U] = temp;
24008802:	4938      	ldr	r1, [pc, #224]	; (240088e4 <HAL_GPIO_Init+0x35c>)
24008804:	69fb      	ldr	r3, [r7, #28]
24008806:	089b      	lsrs	r3, r3, #2
24008808:	3302      	adds	r3, #2
2400880a:	69ba      	ldr	r2, [r7, #24]
2400880c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

        /* Clear EXTI line configuration */
        temp = EXTI_CurrentCPU->IMR1;
24008810:	697b      	ldr	r3, [r7, #20]
24008812:	681b      	ldr	r3, [r3, #0]
24008814:	61bb      	str	r3, [r7, #24]
        temp &= ~(iocurrent);
24008816:	693b      	ldr	r3, [r7, #16]
24008818:	43db      	mvns	r3, r3
2400881a:	69ba      	ldr	r2, [r7, #24]
2400881c:	4013      	ands	r3, r2
2400881e:	61bb      	str	r3, [r7, #24]
        if ((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
24008820:	683b      	ldr	r3, [r7, #0]
24008822:	685b      	ldr	r3, [r3, #4]
24008824:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
24008828:	2b00      	cmp	r3, #0
2400882a:	d003      	beq.n	24008834 <HAL_GPIO_Init+0x2ac>
        {
          temp |= iocurrent;
2400882c:	69ba      	ldr	r2, [r7, #24]
2400882e:	693b      	ldr	r3, [r7, #16]
24008830:	4313      	orrs	r3, r2
24008832:	61bb      	str	r3, [r7, #24]
        }
        EXTI_CurrentCPU->IMR1 = temp;
24008834:	697b      	ldr	r3, [r7, #20]
24008836:	69ba      	ldr	r2, [r7, #24]
24008838:	601a      	str	r2, [r3, #0]

        temp = EXTI_CurrentCPU->EMR1;
2400883a:	697b      	ldr	r3, [r7, #20]
2400883c:	685b      	ldr	r3, [r3, #4]
2400883e:	61bb      	str	r3, [r7, #24]
        temp &= ~(iocurrent);
24008840:	693b      	ldr	r3, [r7, #16]
24008842:	43db      	mvns	r3, r3
24008844:	69ba      	ldr	r2, [r7, #24]
24008846:	4013      	ands	r3, r2
24008848:	61bb      	str	r3, [r7, #24]
        if ((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
2400884a:	683b      	ldr	r3, [r7, #0]
2400884c:	685b      	ldr	r3, [r3, #4]
2400884e:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
24008852:	2b00      	cmp	r3, #0
24008854:	d003      	beq.n	2400885e <HAL_GPIO_Init+0x2d6>
        {
          temp |= iocurrent;
24008856:	69ba      	ldr	r2, [r7, #24]
24008858:	693b      	ldr	r3, [r7, #16]
2400885a:	4313      	orrs	r3, r2
2400885c:	61bb      	str	r3, [r7, #24]
        }
        EXTI_CurrentCPU->EMR1 = temp;
2400885e:	697b      	ldr	r3, [r7, #20]
24008860:	69ba      	ldr	r2, [r7, #24]
24008862:	605a      	str	r2, [r3, #4]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR1;
24008864:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
24008868:	681b      	ldr	r3, [r3, #0]
2400886a:	61bb      	str	r3, [r7, #24]
        temp &= ~(iocurrent);
2400886c:	693b      	ldr	r3, [r7, #16]
2400886e:	43db      	mvns	r3, r3
24008870:	69ba      	ldr	r2, [r7, #24]
24008872:	4013      	ands	r3, r2
24008874:	61bb      	str	r3, [r7, #24]
        if ((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
24008876:	683b      	ldr	r3, [r7, #0]
24008878:	685b      	ldr	r3, [r3, #4]
2400887a:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
2400887e:	2b00      	cmp	r3, #0
24008880:	d003      	beq.n	2400888a <HAL_GPIO_Init+0x302>
        {
          temp |= iocurrent;
24008882:	69ba      	ldr	r2, [r7, #24]
24008884:	693b      	ldr	r3, [r7, #16]
24008886:	4313      	orrs	r3, r2
24008888:	61bb      	str	r3, [r7, #24]
        }
        EXTI->RTSR1 = temp;
2400888a:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
2400888e:	69bb      	ldr	r3, [r7, #24]
24008890:	6013      	str	r3, [r2, #0]

        temp = EXTI->FTSR1;
24008892:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
24008896:	685b      	ldr	r3, [r3, #4]
24008898:	61bb      	str	r3, [r7, #24]
        temp &= ~(iocurrent);
2400889a:	693b      	ldr	r3, [r7, #16]
2400889c:	43db      	mvns	r3, r3
2400889e:	69ba      	ldr	r2, [r7, #24]
240088a0:	4013      	ands	r3, r2
240088a2:	61bb      	str	r3, [r7, #24]
        if ((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
240088a4:	683b      	ldr	r3, [r7, #0]
240088a6:	685b      	ldr	r3, [r3, #4]
240088a8:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
240088ac:	2b00      	cmp	r3, #0
240088ae:	d003      	beq.n	240088b8 <HAL_GPIO_Init+0x330>
        {
          temp |= iocurrent;
240088b0:	69ba      	ldr	r2, [r7, #24]
240088b2:	693b      	ldr	r3, [r7, #16]
240088b4:	4313      	orrs	r3, r2
240088b6:	61bb      	str	r3, [r7, #24]
        }
        EXTI->FTSR1 = temp;
240088b8:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
240088bc:	69bb      	ldr	r3, [r7, #24]
240088be:	6053      	str	r3, [r2, #4]
      }
    }

    position++;
240088c0:	69fb      	ldr	r3, [r7, #28]
240088c2:	3301      	adds	r3, #1
240088c4:	61fb      	str	r3, [r7, #28]
  while (((GPIO_Init->Pin) >> position) != 0x00U)
240088c6:	683b      	ldr	r3, [r7, #0]
240088c8:	681a      	ldr	r2, [r3, #0]
240088ca:	69fb      	ldr	r3, [r7, #28]
240088cc:	fa22 f303 	lsr.w	r3, r2, r3
240088d0:	2b00      	cmp	r3, #0
240088d2:	f47f ae63 	bne.w	2400859c <HAL_GPIO_Init+0x14>
  }
}
240088d6:	bf00      	nop
240088d8:	3724      	adds	r7, #36	; 0x24
240088da:	46bd      	mov	sp, r7
240088dc:	f85d 7b04 	ldr.w	r7, [sp], #4
240088e0:	4770      	bx	lr
240088e2:	bf00      	nop
240088e4:	58000400 	.word	0x58000400

240088e8 <HAL_GPIO_DeInit>:
  * @param  GPIO_Pin: specifies the port bit to be written.
  *          This parameter can be one of GPIO_PIN_x where x can be (0..15).
  * @retval None
  */
void HAL_GPIO_DeInit(GPIO_TypeDef  *GPIOx, uint32_t GPIO_Pin)
{
240088e8:	b480      	push	{r7}
240088ea:	b087      	sub	sp, #28
240088ec:	af00      	add	r7, sp, #0
240088ee:	6078      	str	r0, [r7, #4]
240088f0:	6039      	str	r1, [r7, #0]
  uint32_t position = 0x00U;
240088f2:	2300      	movs	r3, #0
240088f4:	617b      	str	r3, [r7, #20]
  EXTI_Core_TypeDef *EXTI_CurrentCPU;

#if defined(DUAL_CORE) && defined(CORE_CM4)
  EXTI_CurrentCPU = EXTI_D2; /* EXTI for CM4 CPU */
#else
  EXTI_CurrentCPU = EXTI_D1; /* EXTI for CM7 CPU */
240088f6:	4b75      	ldr	r3, [pc, #468]	; (24008acc <HAL_GPIO_DeInit+0x1e4>)
240088f8:	613b      	str	r3, [r7, #16]
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  /* Configure the port pins */
  while ((GPIO_Pin >> position) != 0x00U)
240088fa:	e0d9      	b.n	24008ab0 <HAL_GPIO_DeInit+0x1c8>
  {
    /* Get current io position */
    iocurrent = GPIO_Pin & (1UL << position) ;
240088fc:	2201      	movs	r2, #1
240088fe:	697b      	ldr	r3, [r7, #20]
24008900:	fa02 f303 	lsl.w	r3, r2, r3
24008904:	683a      	ldr	r2, [r7, #0]
24008906:	4013      	ands	r3, r2
24008908:	60fb      	str	r3, [r7, #12]

    if (iocurrent != 0x00U)
2400890a:	68fb      	ldr	r3, [r7, #12]
2400890c:	2b00      	cmp	r3, #0
2400890e:	f000 80cc 	beq.w	24008aaa <HAL_GPIO_DeInit+0x1c2>
    {
      /*------------------------- EXTI Mode Configuration --------------------*/
      /* Clear the External Interrupt or Event for the current IO */
      tmp = SYSCFG->EXTICR[position >> 2U];
24008912:	4a6f      	ldr	r2, [pc, #444]	; (24008ad0 <HAL_GPIO_DeInit+0x1e8>)
24008914:	697b      	ldr	r3, [r7, #20]
24008916:	089b      	lsrs	r3, r3, #2
24008918:	3302      	adds	r3, #2
2400891a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
2400891e:	60bb      	str	r3, [r7, #8]
      tmp &= (0x0FUL << (4U * (position & 0x03U)));
24008920:	697b      	ldr	r3, [r7, #20]
24008922:	f003 0303 	and.w	r3, r3, #3
24008926:	009b      	lsls	r3, r3, #2
24008928:	220f      	movs	r2, #15
2400892a:	fa02 f303 	lsl.w	r3, r2, r3
2400892e:	68ba      	ldr	r2, [r7, #8]
24008930:	4013      	ands	r3, r2
24008932:	60bb      	str	r3, [r7, #8]
      if (tmp == (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U))))
24008934:	687b      	ldr	r3, [r7, #4]
24008936:	4a67      	ldr	r2, [pc, #412]	; (24008ad4 <HAL_GPIO_DeInit+0x1ec>)
24008938:	4293      	cmp	r3, r2
2400893a:	d037      	beq.n	240089ac <HAL_GPIO_DeInit+0xc4>
2400893c:	687b      	ldr	r3, [r7, #4]
2400893e:	4a66      	ldr	r2, [pc, #408]	; (24008ad8 <HAL_GPIO_DeInit+0x1f0>)
24008940:	4293      	cmp	r3, r2
24008942:	d031      	beq.n	240089a8 <HAL_GPIO_DeInit+0xc0>
24008944:	687b      	ldr	r3, [r7, #4]
24008946:	4a65      	ldr	r2, [pc, #404]	; (24008adc <HAL_GPIO_DeInit+0x1f4>)
24008948:	4293      	cmp	r3, r2
2400894a:	d02b      	beq.n	240089a4 <HAL_GPIO_DeInit+0xbc>
2400894c:	687b      	ldr	r3, [r7, #4]
2400894e:	4a64      	ldr	r2, [pc, #400]	; (24008ae0 <HAL_GPIO_DeInit+0x1f8>)
24008950:	4293      	cmp	r3, r2
24008952:	d025      	beq.n	240089a0 <HAL_GPIO_DeInit+0xb8>
24008954:	687b      	ldr	r3, [r7, #4]
24008956:	4a63      	ldr	r2, [pc, #396]	; (24008ae4 <HAL_GPIO_DeInit+0x1fc>)
24008958:	4293      	cmp	r3, r2
2400895a:	d01f      	beq.n	2400899c <HAL_GPIO_DeInit+0xb4>
2400895c:	687b      	ldr	r3, [r7, #4]
2400895e:	4a62      	ldr	r2, [pc, #392]	; (24008ae8 <HAL_GPIO_DeInit+0x200>)
24008960:	4293      	cmp	r3, r2
24008962:	d019      	beq.n	24008998 <HAL_GPIO_DeInit+0xb0>
24008964:	687b      	ldr	r3, [r7, #4]
24008966:	4a61      	ldr	r2, [pc, #388]	; (24008aec <HAL_GPIO_DeInit+0x204>)
24008968:	4293      	cmp	r3, r2
2400896a:	d013      	beq.n	24008994 <HAL_GPIO_DeInit+0xac>
2400896c:	687b      	ldr	r3, [r7, #4]
2400896e:	4a60      	ldr	r2, [pc, #384]	; (24008af0 <HAL_GPIO_DeInit+0x208>)
24008970:	4293      	cmp	r3, r2
24008972:	d00d      	beq.n	24008990 <HAL_GPIO_DeInit+0xa8>
24008974:	687b      	ldr	r3, [r7, #4]
24008976:	4a5f      	ldr	r2, [pc, #380]	; (24008af4 <HAL_GPIO_DeInit+0x20c>)
24008978:	4293      	cmp	r3, r2
2400897a:	d007      	beq.n	2400898c <HAL_GPIO_DeInit+0xa4>
2400897c:	687b      	ldr	r3, [r7, #4]
2400897e:	4a5e      	ldr	r2, [pc, #376]	; (24008af8 <HAL_GPIO_DeInit+0x210>)
24008980:	4293      	cmp	r3, r2
24008982:	d101      	bne.n	24008988 <HAL_GPIO_DeInit+0xa0>
24008984:	2309      	movs	r3, #9
24008986:	e012      	b.n	240089ae <HAL_GPIO_DeInit+0xc6>
24008988:	230a      	movs	r3, #10
2400898a:	e010      	b.n	240089ae <HAL_GPIO_DeInit+0xc6>
2400898c:	2308      	movs	r3, #8
2400898e:	e00e      	b.n	240089ae <HAL_GPIO_DeInit+0xc6>
24008990:	2307      	movs	r3, #7
24008992:	e00c      	b.n	240089ae <HAL_GPIO_DeInit+0xc6>
24008994:	2306      	movs	r3, #6
24008996:	e00a      	b.n	240089ae <HAL_GPIO_DeInit+0xc6>
24008998:	2305      	movs	r3, #5
2400899a:	e008      	b.n	240089ae <HAL_GPIO_DeInit+0xc6>
2400899c:	2304      	movs	r3, #4
2400899e:	e006      	b.n	240089ae <HAL_GPIO_DeInit+0xc6>
240089a0:	2303      	movs	r3, #3
240089a2:	e004      	b.n	240089ae <HAL_GPIO_DeInit+0xc6>
240089a4:	2302      	movs	r3, #2
240089a6:	e002      	b.n	240089ae <HAL_GPIO_DeInit+0xc6>
240089a8:	2301      	movs	r3, #1
240089aa:	e000      	b.n	240089ae <HAL_GPIO_DeInit+0xc6>
240089ac:	2300      	movs	r3, #0
240089ae:	697a      	ldr	r2, [r7, #20]
240089b0:	f002 0203 	and.w	r2, r2, #3
240089b4:	0092      	lsls	r2, r2, #2
240089b6:	4093      	lsls	r3, r2
240089b8:	68ba      	ldr	r2, [r7, #8]
240089ba:	429a      	cmp	r2, r3
240089bc:	d136      	bne.n	24008a2c <HAL_GPIO_DeInit+0x144>
      {
        /* Clear EXTI line configuration for Current CPU */
        EXTI_CurrentCPU->IMR1 &= ~(iocurrent);
240089be:	693b      	ldr	r3, [r7, #16]
240089c0:	681a      	ldr	r2, [r3, #0]
240089c2:	68fb      	ldr	r3, [r7, #12]
240089c4:	43db      	mvns	r3, r3
240089c6:	401a      	ands	r2, r3
240089c8:	693b      	ldr	r3, [r7, #16]
240089ca:	601a      	str	r2, [r3, #0]
        EXTI_CurrentCPU->EMR1 &= ~(iocurrent);
240089cc:	693b      	ldr	r3, [r7, #16]
240089ce:	685a      	ldr	r2, [r3, #4]
240089d0:	68fb      	ldr	r3, [r7, #12]
240089d2:	43db      	mvns	r3, r3
240089d4:	401a      	ands	r2, r3
240089d6:	693b      	ldr	r3, [r7, #16]
240089d8:	605a      	str	r2, [r3, #4]

        /* Clear Rising Falling edge configuration */
        EXTI->RTSR1 &= ~(iocurrent);
240089da:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
240089de:	681a      	ldr	r2, [r3, #0]
240089e0:	68fb      	ldr	r3, [r7, #12]
240089e2:	43db      	mvns	r3, r3
240089e4:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
240089e8:	4013      	ands	r3, r2
240089ea:	600b      	str	r3, [r1, #0]
        EXTI->FTSR1 &= ~(iocurrent);
240089ec:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
240089f0:	685a      	ldr	r2, [r3, #4]
240089f2:	68fb      	ldr	r3, [r7, #12]
240089f4:	43db      	mvns	r3, r3
240089f6:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
240089fa:	4013      	ands	r3, r2
240089fc:	604b      	str	r3, [r1, #4]

        tmp = 0x0FUL << (4U * (position & 0x03U));
240089fe:	697b      	ldr	r3, [r7, #20]
24008a00:	f003 0303 	and.w	r3, r3, #3
24008a04:	009b      	lsls	r3, r3, #2
24008a06:	220f      	movs	r2, #15
24008a08:	fa02 f303 	lsl.w	r3, r2, r3
24008a0c:	60bb      	str	r3, [r7, #8]
        SYSCFG->EXTICR[position >> 2U] &= ~tmp;
24008a0e:	4a30      	ldr	r2, [pc, #192]	; (24008ad0 <HAL_GPIO_DeInit+0x1e8>)
24008a10:	697b      	ldr	r3, [r7, #20]
24008a12:	089b      	lsrs	r3, r3, #2
24008a14:	3302      	adds	r3, #2
24008a16:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
24008a1a:	68bb      	ldr	r3, [r7, #8]
24008a1c:	43da      	mvns	r2, r3
24008a1e:	482c      	ldr	r0, [pc, #176]	; (24008ad0 <HAL_GPIO_DeInit+0x1e8>)
24008a20:	697b      	ldr	r3, [r7, #20]
24008a22:	089b      	lsrs	r3, r3, #2
24008a24:	400a      	ands	r2, r1
24008a26:	3302      	adds	r3, #2
24008a28:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
      }

      /*------------------------- GPIO Mode Configuration --------------------*/
      /* Configure IO in Analog Mode */
      GPIOx->MODER |= (GPIO_MODER_MODE0 << (position * 2U));
24008a2c:	687b      	ldr	r3, [r7, #4]
24008a2e:	681a      	ldr	r2, [r3, #0]
24008a30:	697b      	ldr	r3, [r7, #20]
24008a32:	005b      	lsls	r3, r3, #1
24008a34:	2103      	movs	r1, #3
24008a36:	fa01 f303 	lsl.w	r3, r1, r3
24008a3a:	431a      	orrs	r2, r3
24008a3c:	687b      	ldr	r3, [r7, #4]
24008a3e:	601a      	str	r2, [r3, #0]

      /* Configure the default Alternate Function in current IO */
      GPIOx->AFR[position >> 3U] &= ~(0xFU << ((position & 0x07U) * 4U)) ;
24008a40:	697b      	ldr	r3, [r7, #20]
24008a42:	08da      	lsrs	r2, r3, #3
24008a44:	687b      	ldr	r3, [r7, #4]
24008a46:	3208      	adds	r2, #8
24008a48:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
24008a4c:	697b      	ldr	r3, [r7, #20]
24008a4e:	f003 0307 	and.w	r3, r3, #7
24008a52:	009b      	lsls	r3, r3, #2
24008a54:	220f      	movs	r2, #15
24008a56:	fa02 f303 	lsl.w	r3, r2, r3
24008a5a:	43db      	mvns	r3, r3
24008a5c:	697a      	ldr	r2, [r7, #20]
24008a5e:	08d2      	lsrs	r2, r2, #3
24008a60:	4019      	ands	r1, r3
24008a62:	687b      	ldr	r3, [r7, #4]
24008a64:	3208      	adds	r2, #8
24008a66:	f843 1022 	str.w	r1, [r3, r2, lsl #2]

      /* Deactivate the Pull-up and Pull-down resistor for the current IO */
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
24008a6a:	687b      	ldr	r3, [r7, #4]
24008a6c:	68da      	ldr	r2, [r3, #12]
24008a6e:	697b      	ldr	r3, [r7, #20]
24008a70:	005b      	lsls	r3, r3, #1
24008a72:	2103      	movs	r1, #3
24008a74:	fa01 f303 	lsl.w	r3, r1, r3
24008a78:	43db      	mvns	r3, r3
24008a7a:	401a      	ands	r2, r3
24008a7c:	687b      	ldr	r3, [r7, #4]
24008a7e:	60da      	str	r2, [r3, #12]

      /* Configure the default value IO Output Type */
      GPIOx->OTYPER  &= ~(GPIO_OTYPER_OT0 << position) ;
24008a80:	687b      	ldr	r3, [r7, #4]
24008a82:	685a      	ldr	r2, [r3, #4]
24008a84:	2101      	movs	r1, #1
24008a86:	697b      	ldr	r3, [r7, #20]
24008a88:	fa01 f303 	lsl.w	r3, r1, r3
24008a8c:	43db      	mvns	r3, r3
24008a8e:	401a      	ands	r2, r3
24008a90:	687b      	ldr	r3, [r7, #4]
24008a92:	605a      	str	r2, [r3, #4]

      /* Configure the default value for IO Speed */
      GPIOx->OSPEEDR &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
24008a94:	687b      	ldr	r3, [r7, #4]
24008a96:	689a      	ldr	r2, [r3, #8]
24008a98:	697b      	ldr	r3, [r7, #20]
24008a9a:	005b      	lsls	r3, r3, #1
24008a9c:	2103      	movs	r1, #3
24008a9e:	fa01 f303 	lsl.w	r3, r1, r3
24008aa2:	43db      	mvns	r3, r3
24008aa4:	401a      	ands	r2, r3
24008aa6:	687b      	ldr	r3, [r7, #4]
24008aa8:	609a      	str	r2, [r3, #8]
    }

    position++;
24008aaa:	697b      	ldr	r3, [r7, #20]
24008aac:	3301      	adds	r3, #1
24008aae:	617b      	str	r3, [r7, #20]
  while ((GPIO_Pin >> position) != 0x00U)
24008ab0:	683a      	ldr	r2, [r7, #0]
24008ab2:	697b      	ldr	r3, [r7, #20]
24008ab4:	fa22 f303 	lsr.w	r3, r2, r3
24008ab8:	2b00      	cmp	r3, #0
24008aba:	f47f af1f 	bne.w	240088fc <HAL_GPIO_DeInit+0x14>
  }
}
24008abe:	bf00      	nop
24008ac0:	371c      	adds	r7, #28
24008ac2:	46bd      	mov	sp, r7
24008ac4:	f85d 7b04 	ldr.w	r7, [sp], #4
24008ac8:	4770      	bx	lr
24008aca:	bf00      	nop
24008acc:	58000080 	.word	0x58000080
24008ad0:	58000400 	.word	0x58000400
24008ad4:	58020000 	.word	0x58020000
24008ad8:	58020400 	.word	0x58020400
24008adc:	58020800 	.word	0x58020800
24008ae0:	58020c00 	.word	0x58020c00
24008ae4:	58021000 	.word	0x58021000
24008ae8:	58021400 	.word	0x58021400
24008aec:	58021800 	.word	0x58021800
24008af0:	58021c00 	.word	0x58021c00
24008af4:	58022000 	.word	0x58022000
24008af8:	58022400 	.word	0x58022400

24008afc <HAL_GPIO_ReadPin>:
  * @param  GPIO_Pin: specifies the port bit to read.
  *         This parameter can be GPIO_PIN_x where x can be (0..15).
  * @retval The input port pin value.
  */
GPIO_PinState HAL_GPIO_ReadPin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin)
{
24008afc:	b480      	push	{r7}
24008afe:	b085      	sub	sp, #20
24008b00:	af00      	add	r7, sp, #0
24008b02:	6078      	str	r0, [r7, #4]
24008b04:	460b      	mov	r3, r1
24008b06:	807b      	strh	r3, [r7, #2]
  GPIO_PinState bitstatus;

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  if ((GPIOx->IDR & GPIO_Pin) != 0x00U)
24008b08:	687b      	ldr	r3, [r7, #4]
24008b0a:	691a      	ldr	r2, [r3, #16]
24008b0c:	887b      	ldrh	r3, [r7, #2]
24008b0e:	4013      	ands	r3, r2
24008b10:	2b00      	cmp	r3, #0
24008b12:	d002      	beq.n	24008b1a <HAL_GPIO_ReadPin+0x1e>
  {
    bitstatus = GPIO_PIN_SET;
24008b14:	2301      	movs	r3, #1
24008b16:	73fb      	strb	r3, [r7, #15]
24008b18:	e001      	b.n	24008b1e <HAL_GPIO_ReadPin+0x22>
  }
  else
  {
    bitstatus = GPIO_PIN_RESET;
24008b1a:	2300      	movs	r3, #0
24008b1c:	73fb      	strb	r3, [r7, #15]
  }
  return bitstatus;
24008b1e:	7bfb      	ldrb	r3, [r7, #15]
}
24008b20:	4618      	mov	r0, r3
24008b22:	3714      	adds	r7, #20
24008b24:	46bd      	mov	sp, r7
24008b26:	f85d 7b04 	ldr.w	r7, [sp], #4
24008b2a:	4770      	bx	lr

24008b2c <HAL_GPIO_WritePin>:
  *            @arg GPIO_PIN_RESET: to clear the port pin
  *            @arg GPIO_PIN_SET: to set the port pin
  * @retval None
  */
void HAL_GPIO_WritePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
{
24008b2c:	b480      	push	{r7}
24008b2e:	b083      	sub	sp, #12
24008b30:	af00      	add	r7, sp, #0
24008b32:	6078      	str	r0, [r7, #4]
24008b34:	460b      	mov	r3, r1
24008b36:	807b      	strh	r3, [r7, #2]
24008b38:	4613      	mov	r3, r2
24008b3a:	707b      	strb	r3, [r7, #1]
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if (PinState != GPIO_PIN_RESET)
24008b3c:	787b      	ldrb	r3, [r7, #1]
24008b3e:	2b00      	cmp	r3, #0
24008b40:	d003      	beq.n	24008b4a <HAL_GPIO_WritePin+0x1e>
  {
    GPIOx->BSRR = GPIO_Pin;
24008b42:	887a      	ldrh	r2, [r7, #2]
24008b44:	687b      	ldr	r3, [r7, #4]
24008b46:	619a      	str	r2, [r3, #24]
  }
  else
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << GPIO_NUMBER;
  }
}
24008b48:	e003      	b.n	24008b52 <HAL_GPIO_WritePin+0x26>
    GPIOx->BSRR = (uint32_t)GPIO_Pin << GPIO_NUMBER;
24008b4a:	887b      	ldrh	r3, [r7, #2]
24008b4c:	041a      	lsls	r2, r3, #16
24008b4e:	687b      	ldr	r3, [r7, #4]
24008b50:	619a      	str	r2, [r3, #24]
}
24008b52:	bf00      	nop
24008b54:	370c      	adds	r7, #12
24008b56:	46bd      	mov	sp, r7
24008b58:	f85d 7b04 	ldr.w	r7, [sp], #4
24008b5c:	4770      	bx	lr

24008b5e <HAL_GPIO_TogglePin>:
  * @param  GPIOx: Where x can be (A..K) to select the GPIO peripheral.
  * @param  GPIO_Pin: Specifies the pins to be toggled.
  * @retval None
  */
void HAL_GPIO_TogglePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin)
{
24008b5e:	b480      	push	{r7}
24008b60:	b083      	sub	sp, #12
24008b62:	af00      	add	r7, sp, #0
24008b64:	6078      	str	r0, [r7, #4]
24008b66:	460b      	mov	r3, r1
24008b68:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  if ((GPIOx->ODR & GPIO_Pin) == GPIO_Pin)
24008b6a:	687b      	ldr	r3, [r7, #4]
24008b6c:	695a      	ldr	r2, [r3, #20]
24008b6e:	887b      	ldrh	r3, [r7, #2]
24008b70:	401a      	ands	r2, r3
24008b72:	887b      	ldrh	r3, [r7, #2]
24008b74:	429a      	cmp	r2, r3
24008b76:	d104      	bne.n	24008b82 <HAL_GPIO_TogglePin+0x24>
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << GPIO_NUMBER;
24008b78:	887b      	ldrh	r3, [r7, #2]
24008b7a:	041a      	lsls	r2, r3, #16
24008b7c:	687b      	ldr	r3, [r7, #4]
24008b7e:	619a      	str	r2, [r3, #24]
  }
  else
  {
    GPIOx->BSRR = GPIO_Pin;
  }
}
24008b80:	e002      	b.n	24008b88 <HAL_GPIO_TogglePin+0x2a>
    GPIOx->BSRR = GPIO_Pin;
24008b82:	887a      	ldrh	r2, [r7, #2]
24008b84:	687b      	ldr	r3, [r7, #4]
24008b86:	619a      	str	r2, [r3, #24]
}
24008b88:	bf00      	nop
24008b8a:	370c      	adds	r7, #12
24008b8c:	46bd      	mov	sp, r7
24008b8e:	f85d 7b04 	ldr.w	r7, [sp], #4
24008b92:	4770      	bx	lr

24008b94 <HAL_GPIO_LockPin>:
  * @param  GPIO_Pin: specifies the port bit to be locked.
  *         This parameter can be any combination of GPIO_PIN_x where x can be (0..15).
  * @retval None
  */
HAL_StatusTypeDef HAL_GPIO_LockPin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin)
{
24008b94:	b480      	push	{r7}
24008b96:	b085      	sub	sp, #20
24008b98:	af00      	add	r7, sp, #0
24008b9a:	6078      	str	r0, [r7, #4]
24008b9c:	460b      	mov	r3, r1
24008b9e:	807b      	strh	r3, [r7, #2]
  __IO uint32_t tmp = GPIO_LCKR_LCKK;
24008ba0:	f44f 3380 	mov.w	r3, #65536	; 0x10000
24008ba4:	60fb      	str	r3, [r7, #12]
  /* Check the parameters */
  assert_param(IS_GPIO_LOCK_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  /* Apply lock key write sequence */
  tmp |= GPIO_Pin;
24008ba6:	887a      	ldrh	r2, [r7, #2]
24008ba8:	68fb      	ldr	r3, [r7, #12]
24008baa:	4313      	orrs	r3, r2
24008bac:	60fb      	str	r3, [r7, #12]
  /* Set LCKx bit(s): LCKK='1' + LCK[15-0] */
  GPIOx->LCKR = tmp;
24008bae:	68fa      	ldr	r2, [r7, #12]
24008bb0:	687b      	ldr	r3, [r7, #4]
24008bb2:	61da      	str	r2, [r3, #28]
  /* Reset LCKx bit(s): LCKK='0' + LCK[15-0] */
  GPIOx->LCKR = GPIO_Pin;
24008bb4:	887a      	ldrh	r2, [r7, #2]
24008bb6:	687b      	ldr	r3, [r7, #4]
24008bb8:	61da      	str	r2, [r3, #28]
  /* Set LCKx bit(s): LCKK='1' + LCK[15-0] */
  GPIOx->LCKR = tmp;
24008bba:	68fa      	ldr	r2, [r7, #12]
24008bbc:	687b      	ldr	r3, [r7, #4]
24008bbe:	61da      	str	r2, [r3, #28]
  /* Read LCKK register. This read is mandatory to complete key lock sequence*/
  tmp = GPIOx->LCKR;
24008bc0:	687b      	ldr	r3, [r7, #4]
24008bc2:	69db      	ldr	r3, [r3, #28]
24008bc4:	60fb      	str	r3, [r7, #12]

  /* read again in order to confirm lock is active */
  if ((GPIOx->LCKR & GPIO_LCKR_LCKK) != 0x00U)
24008bc6:	687b      	ldr	r3, [r7, #4]
24008bc8:	69db      	ldr	r3, [r3, #28]
24008bca:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
24008bce:	2b00      	cmp	r3, #0
24008bd0:	d001      	beq.n	24008bd6 <HAL_GPIO_LockPin+0x42>
  {
    return HAL_OK;
24008bd2:	2300      	movs	r3, #0
24008bd4:	e000      	b.n	24008bd8 <HAL_GPIO_LockPin+0x44>
  }
  else
  {
    return HAL_ERROR;
24008bd6:	2301      	movs	r3, #1
  }
}
24008bd8:	4618      	mov	r0, r3
24008bda:	3714      	adds	r7, #20
24008bdc:	46bd      	mov	sp, r7
24008bde:	f85d 7b04 	ldr.w	r7, [sp], #4
24008be2:	4770      	bx	lr

24008be4 <HAL_GPIO_EXTI_IRQHandler>:
  * @brief  Handle EXTI interrupt request.
  * @param  GPIO_Pin: Specifies the port pin connected to corresponding EXTI line.
  * @retval None
  */
void HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin)
{
24008be4:	b580      	push	{r7, lr}
24008be6:	b082      	sub	sp, #8
24008be8:	af00      	add	r7, sp, #0
24008bea:	4603      	mov	r3, r0
24008bec:	80fb      	strh	r3, [r7, #6]
    __HAL_GPIO_EXTID2_CLEAR_IT(GPIO_Pin);
    HAL_GPIO_EXTI_Callback(GPIO_Pin);
  }
#else
  /* EXTI line interrupt detected */
  if (__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != 0x00U)
24008bee:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
24008bf2:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
24008bf6:	88fb      	ldrh	r3, [r7, #6]
24008bf8:	4013      	ands	r3, r2
24008bfa:	2b00      	cmp	r3, #0
24008bfc:	d008      	beq.n	24008c10 <HAL_GPIO_EXTI_IRQHandler+0x2c>
  {
    __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);
24008bfe:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
24008c02:	88fb      	ldrh	r3, [r7, #6]
24008c04:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
    HAL_GPIO_EXTI_Callback(GPIO_Pin);
24008c08:	88fb      	ldrh	r3, [r7, #6]
24008c0a:	4618      	mov	r0, r3
24008c0c:	f000 f804 	bl	24008c18 <HAL_GPIO_EXTI_Callback>
  }
#endif
}
24008c10:	bf00      	nop
24008c12:	3708      	adds	r7, #8
24008c14:	46bd      	mov	sp, r7
24008c16:	bd80      	pop	{r7, pc}

24008c18 <HAL_GPIO_EXTI_Callback>:
  * @brief  EXTI line detection callback.
  * @param  GPIO_Pin: Specifies the port pin connected to corresponding EXTI line.
  * @retval None
  */
__weak void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
{
24008c18:	b480      	push	{r7}
24008c1a:	b083      	sub	sp, #12
24008c1c:	af00      	add	r7, sp, #0
24008c1e:	4603      	mov	r3, r0
24008c20:	80fb      	strh	r3, [r7, #6]
  UNUSED(GPIO_Pin);

  /* NOTE: This function Should not be modified, when the callback is needed,
           the HAL_GPIO_EXTI_Callback could be implemented in the user file
   */
}
24008c22:	bf00      	nop
24008c24:	370c      	adds	r7, #12
24008c26:	46bd      	mov	sp, r7
24008c28:	f85d 7b04 	ldr.w	r7, [sp], #4
24008c2c:	4770      	bx	lr
	...

24008c30 <HAL_HSEM_Take>:
  * @param  SemID: semaphore ID from 0 to 31
  * @param  ProcessID: Process ID from 0 to 255
  * @retval HAL status
  */
HAL_StatusTypeDef  HAL_HSEM_Take(uint32_t SemID, uint32_t ProcessID)
{
24008c30:	b480      	push	{r7}
24008c32:	b083      	sub	sp, #12
24008c34:	af00      	add	r7, sp, #0
24008c36:	6078      	str	r0, [r7, #4]
24008c38:	6039      	str	r1, [r7, #0]
    /*take success when MasterID and ProcessID match and take bit set*/
    return HAL_OK;
  }
#else
  /* First step  write R register with MasterID, processID and take bit=1*/
  HSEM->R[SemID] = (ProcessID | HSEM_CR_COREID_CURRENT | HSEM_R_LOCK);
24008c3a:	490c      	ldr	r1, [pc, #48]	; (24008c6c <HAL_HSEM_Take+0x3c>)
24008c3c:	683a      	ldr	r2, [r7, #0]
24008c3e:	4b0c      	ldr	r3, [pc, #48]	; (24008c70 <HAL_HSEM_Take+0x40>)
24008c40:	4313      	orrs	r3, r2
24008c42:	687a      	ldr	r2, [r7, #4]
24008c44:	f841 3022 	str.w	r3, [r1, r2, lsl #2]

  /* second step : read the R register . Take achieved if MasterID and processID match and take bit set to 1 */
  if (HSEM->R[SemID] == (ProcessID | HSEM_CR_COREID_CURRENT | HSEM_R_LOCK))
24008c48:	4a08      	ldr	r2, [pc, #32]	; (24008c6c <HAL_HSEM_Take+0x3c>)
24008c4a:	687b      	ldr	r3, [r7, #4]
24008c4c:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
24008c50:	6839      	ldr	r1, [r7, #0]
24008c52:	4b07      	ldr	r3, [pc, #28]	; (24008c70 <HAL_HSEM_Take+0x40>)
24008c54:	430b      	orrs	r3, r1
24008c56:	429a      	cmp	r2, r3
24008c58:	d101      	bne.n	24008c5e <HAL_HSEM_Take+0x2e>
  {
    /*take success when MasterID and ProcessID match and take bit set*/
    return HAL_OK;
24008c5a:	2300      	movs	r3, #0
24008c5c:	e000      	b.n	24008c60 <HAL_HSEM_Take+0x30>
  }
#endif

  /* Semaphore take fails*/
  return HAL_ERROR;
24008c5e:	2301      	movs	r3, #1
}
24008c60:	4618      	mov	r0, r3
24008c62:	370c      	adds	r7, #12
24008c64:	46bd      	mov	sp, r7
24008c66:	f85d 7b04 	ldr.w	r7, [sp], #4
24008c6a:	4770      	bx	lr
24008c6c:	58026400 	.word	0x58026400
24008c70:	80000300 	.word	0x80000300

24008c74 <HAL_HSEM_FastTake>:
  * @brief  Fast Take a semaphore with 1 Step mode.
  * @param  SemID: semaphore ID from 0 to 31
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_HSEM_FastTake(uint32_t SemID)
{
24008c74:	b480      	push	{r7}
24008c76:	b083      	sub	sp, #12
24008c78:	af00      	add	r7, sp, #0
24008c7a:	6078      	str	r0, [r7, #4]
    /*take success when MasterID match and take bit set*/
    return HAL_OK;
  }
#else
  /* Read the RLR register to take the semaphore */
  if (HSEM->RLR[SemID] == (HSEM_CR_COREID_CURRENT | HSEM_RLR_LOCK))
24008c7c:	4a08      	ldr	r2, [pc, #32]	; (24008ca0 <HAL_HSEM_FastTake+0x2c>)
24008c7e:	687b      	ldr	r3, [r7, #4]
24008c80:	3320      	adds	r3, #32
24008c82:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
24008c86:	4a07      	ldr	r2, [pc, #28]	; (24008ca4 <HAL_HSEM_FastTake+0x30>)
24008c88:	4293      	cmp	r3, r2
24008c8a:	d101      	bne.n	24008c90 <HAL_HSEM_FastTake+0x1c>
  {
    /*take success when MasterID match and take bit set*/
    return HAL_OK;
24008c8c:	2300      	movs	r3, #0
24008c8e:	e000      	b.n	24008c92 <HAL_HSEM_FastTake+0x1e>
  }
#endif

  /* Semaphore take fails */
  return HAL_ERROR;
24008c90:	2301      	movs	r3, #1
}
24008c92:	4618      	mov	r0, r3
24008c94:	370c      	adds	r7, #12
24008c96:	46bd      	mov	sp, r7
24008c98:	f85d 7b04 	ldr.w	r7, [sp], #4
24008c9c:	4770      	bx	lr
24008c9e:	bf00      	nop
24008ca0:	58026400 	.word	0x58026400
24008ca4:	80000300 	.word	0x80000300

24008ca8 <HAL_HSEM_IsSemTaken>:
  * @brief  Check semaphore state Taken or not.
  * @param  SemID: semaphore ID
  * @retval HAL HSEM state
  */
uint32_t HAL_HSEM_IsSemTaken(uint32_t SemID)
{
24008ca8:	b480      	push	{r7}
24008caa:	b083      	sub	sp, #12
24008cac:	af00      	add	r7, sp, #0
24008cae:	6078      	str	r0, [r7, #4]
  return (((HSEM->R[SemID] & HSEM_R_LOCK) != 0U) ? 1UL : 0UL);
24008cb0:	4a07      	ldr	r2, [pc, #28]	; (24008cd0 <HAL_HSEM_IsSemTaken+0x28>)
24008cb2:	687b      	ldr	r3, [r7, #4]
24008cb4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
24008cb8:	2b00      	cmp	r3, #0
24008cba:	da01      	bge.n	24008cc0 <HAL_HSEM_IsSemTaken+0x18>
24008cbc:	2301      	movs	r3, #1
24008cbe:	e000      	b.n	24008cc2 <HAL_HSEM_IsSemTaken+0x1a>
24008cc0:	2300      	movs	r3, #0
}
24008cc2:	4618      	mov	r0, r3
24008cc4:	370c      	adds	r7, #12
24008cc6:	46bd      	mov	sp, r7
24008cc8:	f85d 7b04 	ldr.w	r7, [sp], #4
24008ccc:	4770      	bx	lr
24008cce:	bf00      	nop
24008cd0:	58026400 	.word	0x58026400

24008cd4 <HAL_HSEM_Release>:
  * @param  SemID: semaphore ID from 0 to 31
  * @param  ProcessID: Process ID from 0 to 255
  * @retval None
  */
void  HAL_HSEM_Release(uint32_t SemID, uint32_t ProcessID)
{
24008cd4:	b480      	push	{r7}
24008cd6:	b083      	sub	sp, #12
24008cd8:	af00      	add	r7, sp, #0
24008cda:	6078      	str	r0, [r7, #4]
24008cdc:	6039      	str	r1, [r7, #0]

  /* Clear the semaphore by writing to the R register : the MasterID , the processID and take bit = 0  */
#if  USE_MULTI_CORE_SHARED_CODE != 0U
  HSEM->R[SemID] = (ProcessID | ((HAL_GetCurrentCPUID() << POSITION_VAL(HSEM_R_MASTERID)) & HSEM_R_MASTERID));
#else
  HSEM->R[SemID] = (ProcessID | HSEM_CR_COREID_CURRENT);
24008cde:	4906      	ldr	r1, [pc, #24]	; (24008cf8 <HAL_HSEM_Release+0x24>)
24008ce0:	683b      	ldr	r3, [r7, #0]
24008ce2:	f443 7240 	orr.w	r2, r3, #768	; 0x300
24008ce6:	687b      	ldr	r3, [r7, #4]
24008ce8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
#endif

}
24008cec:	bf00      	nop
24008cee:	370c      	adds	r7, #12
24008cf0:	46bd      	mov	sp, r7
24008cf2:	f85d 7b04 	ldr.w	r7, [sp], #4
24008cf6:	4770      	bx	lr
24008cf8:	58026400 	.word	0x58026400

24008cfc <HAL_HSEM_ReleaseAll>:
  * @param  Key: Semaphore Key , value from 0 to 0xFFFF
  * @param  CoreID: CoreID of the CPU that is using semaphores to be released
  * @retval None
  */
void HAL_HSEM_ReleaseAll(uint32_t Key, uint32_t CoreID)
{
24008cfc:	b480      	push	{r7}
24008cfe:	b083      	sub	sp, #12
24008d00:	af00      	add	r7, sp, #0
24008d02:	6078      	str	r0, [r7, #4]
24008d04:	6039      	str	r1, [r7, #0]
  assert_param(IS_HSEM_KEY(Key));
  assert_param(IS_HSEM_COREID(CoreID));

  HSEM->CR = ((Key << HSEM_CR_KEY_Pos) | (CoreID << HSEM_CR_COREID_Pos));
24008d06:	687b      	ldr	r3, [r7, #4]
24008d08:	041a      	lsls	r2, r3, #16
24008d0a:	683b      	ldr	r3, [r7, #0]
24008d0c:	021b      	lsls	r3, r3, #8
24008d0e:	4905      	ldr	r1, [pc, #20]	; (24008d24 <HAL_HSEM_ReleaseAll+0x28>)
24008d10:	4313      	orrs	r3, r2
24008d12:	f8c1 3140 	str.w	r3, [r1, #320]	; 0x140
}
24008d16:	bf00      	nop
24008d18:	370c      	adds	r7, #12
24008d1a:	46bd      	mov	sp, r7
24008d1c:	f85d 7b04 	ldr.w	r7, [sp], #4
24008d20:	4770      	bx	lr
24008d22:	bf00      	nop
24008d24:	58026400 	.word	0x58026400

24008d28 <HAL_HSEM_SetClearKey>:
  * @brief  Set semaphore Key .
  * @param  Key: Semaphore Key , value from 0 to 0xFFFF
  * @retval None
  */
void  HAL_HSEM_SetClearKey(uint32_t Key)
{
24008d28:	b480      	push	{r7}
24008d2a:	b083      	sub	sp, #12
24008d2c:	af00      	add	r7, sp, #0
24008d2e:	6078      	str	r0, [r7, #4]
  assert_param(IS_HSEM_KEY(Key));

  MODIFY_REG(HSEM->KEYR, HSEM_KEYR_KEY, (Key << HSEM_KEYR_KEY_Pos));
24008d30:	4b07      	ldr	r3, [pc, #28]	; (24008d50 <HAL_HSEM_SetClearKey+0x28>)
24008d32:	f8d3 3144 	ldr.w	r3, [r3, #324]	; 0x144
24008d36:	b29a      	uxth	r2, r3
24008d38:	687b      	ldr	r3, [r7, #4]
24008d3a:	041b      	lsls	r3, r3, #16
24008d3c:	4904      	ldr	r1, [pc, #16]	; (24008d50 <HAL_HSEM_SetClearKey+0x28>)
24008d3e:	4313      	orrs	r3, r2
24008d40:	f8c1 3144 	str.w	r3, [r1, #324]	; 0x144

}
24008d44:	bf00      	nop
24008d46:	370c      	adds	r7, #12
24008d48:	46bd      	mov	sp, r7
24008d4a:	f85d 7b04 	ldr.w	r7, [sp], #4
24008d4e:	4770      	bx	lr
24008d50:	58026400 	.word	0x58026400

24008d54 <HAL_HSEM_GetClearKey>:
/**
  * @brief  Get semaphore Key .
  * @retval Semaphore Key , value from 0 to 0xFFFF
  */
uint32_t HAL_HSEM_GetClearKey(void)
{
24008d54:	b480      	push	{r7}
24008d56:	af00      	add	r7, sp, #0
  return (HSEM->KEYR >> HSEM_KEYR_KEY_Pos);
24008d58:	4b04      	ldr	r3, [pc, #16]	; (24008d6c <HAL_HSEM_GetClearKey+0x18>)
24008d5a:	f8d3 3144 	ldr.w	r3, [r3, #324]	; 0x144
24008d5e:	0c1b      	lsrs	r3, r3, #16
}
24008d60:	4618      	mov	r0, r3
24008d62:	46bd      	mov	sp, r7
24008d64:	f85d 7b04 	ldr.w	r7, [sp], #4
24008d68:	4770      	bx	lr
24008d6a:	bf00      	nop
24008d6c:	58026400 	.word	0x58026400

24008d70 <HAL_HSEM_ActivateNotification>:
  * @brief  Activate Semaphore release Notification for a given Semaphores Mask .
  * @param  SemMask: Mask of Released semaphores
  * @retval Semaphore Key
  */
void HAL_HSEM_ActivateNotification(uint32_t SemMask)
{
24008d70:	b480      	push	{r7}
24008d72:	b083      	sub	sp, #12
24008d74:	af00      	add	r7, sp, #0
24008d76:	6078      	str	r0, [r7, #4]
  {
    /*Use interrupt line 1 for CPU2 Master*/
    HSEM->C2IER |= SemMask;
  }
#else
  HSEM_COMMON->IER |= SemMask;
24008d78:	4b05      	ldr	r3, [pc, #20]	; (24008d90 <HAL_HSEM_ActivateNotification+0x20>)
24008d7a:	681a      	ldr	r2, [r3, #0]
24008d7c:	4904      	ldr	r1, [pc, #16]	; (24008d90 <HAL_HSEM_ActivateNotification+0x20>)
24008d7e:	687b      	ldr	r3, [r7, #4]
24008d80:	4313      	orrs	r3, r2
24008d82:	600b      	str	r3, [r1, #0]
#endif
}
24008d84:	bf00      	nop
24008d86:	370c      	adds	r7, #12
24008d88:	46bd      	mov	sp, r7
24008d8a:	f85d 7b04 	ldr.w	r7, [sp], #4
24008d8e:	4770      	bx	lr
24008d90:	58026500 	.word	0x58026500

24008d94 <HAL_HSEM_DeactivateNotification>:
  * @brief  Deactivate Semaphore release Notification for a given Semaphores Mask .
  * @param  SemMask: Mask of Released semaphores
  * @retval Semaphore Key
  */
void HAL_HSEM_DeactivateNotification(uint32_t SemMask)
{
24008d94:	b480      	push	{r7}
24008d96:	b083      	sub	sp, #12
24008d98:	af00      	add	r7, sp, #0
24008d9a:	6078      	str	r0, [r7, #4]
  {
    /*Use interrupt line 1 for CPU2 Master*/
    HSEM->C2IER &= ~SemMask;
  }
#else
  HSEM_COMMON->IER &= ~SemMask;
24008d9c:	4b06      	ldr	r3, [pc, #24]	; (24008db8 <HAL_HSEM_DeactivateNotification+0x24>)
24008d9e:	681a      	ldr	r2, [r3, #0]
24008da0:	687b      	ldr	r3, [r7, #4]
24008da2:	43db      	mvns	r3, r3
24008da4:	4904      	ldr	r1, [pc, #16]	; (24008db8 <HAL_HSEM_DeactivateNotification+0x24>)
24008da6:	4013      	ands	r3, r2
24008da8:	600b      	str	r3, [r1, #0]
#endif
}
24008daa:	bf00      	nop
24008dac:	370c      	adds	r7, #12
24008dae:	46bd      	mov	sp, r7
24008db0:	f85d 7b04 	ldr.w	r7, [sp], #4
24008db4:	4770      	bx	lr
24008db6:	bf00      	nop
24008db8:	58026500 	.word	0x58026500

24008dbc <HAL_HSEM_IRQHandler>:
/**
  * @brief  This function handles HSEM interrupt request
  * @retval None
  */
void HAL_HSEM_IRQHandler(void)
{
24008dbc:	b580      	push	{r7, lr}
24008dbe:	b082      	sub	sp, #8
24008dc0:	af00      	add	r7, sp, #0
    /*Clear Flags*/
    HSEM->C2ICR = ((uint32_t)statusreg);
  }
#else
  /* Get the list of masked freed semaphores*/
  statusreg = HSEM_COMMON->MISR;
24008dc2:	4b0a      	ldr	r3, [pc, #40]	; (24008dec <HAL_HSEM_IRQHandler+0x30>)
24008dc4:	68db      	ldr	r3, [r3, #12]
24008dc6:	607b      	str	r3, [r7, #4]

  /*Disable Interrupts*/
  HSEM_COMMON->IER &= ~((uint32_t)statusreg);
24008dc8:	4b08      	ldr	r3, [pc, #32]	; (24008dec <HAL_HSEM_IRQHandler+0x30>)
24008dca:	681a      	ldr	r2, [r3, #0]
24008dcc:	687b      	ldr	r3, [r7, #4]
24008dce:	43db      	mvns	r3, r3
24008dd0:	4906      	ldr	r1, [pc, #24]	; (24008dec <HAL_HSEM_IRQHandler+0x30>)
24008dd2:	4013      	ands	r3, r2
24008dd4:	600b      	str	r3, [r1, #0]

  /*Clear Flags*/
  HSEM_COMMON->ICR = ((uint32_t)statusreg);
24008dd6:	4a05      	ldr	r2, [pc, #20]	; (24008dec <HAL_HSEM_IRQHandler+0x30>)
24008dd8:	687b      	ldr	r3, [r7, #4]
24008dda:	6053      	str	r3, [r2, #4]

#endif
  /* Call FreeCallback */
  HAL_HSEM_FreeCallback(statusreg);
24008ddc:	6878      	ldr	r0, [r7, #4]
24008dde:	f000 f807 	bl	24008df0 <HAL_HSEM_FreeCallback>
}
24008de2:	bf00      	nop
24008de4:	3708      	adds	r7, #8
24008de6:	46bd      	mov	sp, r7
24008de8:	bd80      	pop	{r7, pc}
24008dea:	bf00      	nop
24008dec:	58026500 	.word	0x58026500

24008df0 <HAL_HSEM_FreeCallback>:
  * @brief Semaphore Released Callback.
  * @param SemMask: Mask of Released semaphores
  * @retval None
  */
__weak void HAL_HSEM_FreeCallback(uint32_t SemMask)
{
24008df0:	b480      	push	{r7}
24008df2:	b083      	sub	sp, #12
24008df4:	af00      	add	r7, sp, #0
24008df6:	6078      	str	r0, [r7, #4]
  UNUSED(SemMask);

  /* NOTE : This function should not be modified, when the callback is needed,
  the HAL_HSEM_FreeCallback can be implemented in the user file
    */
}
24008df8:	bf00      	nop
24008dfa:	370c      	adds	r7, #12
24008dfc:	46bd      	mov	sp, r7
24008dfe:	f85d 7b04 	ldr.w	r7, [sp], #4
24008e02:	4770      	bx	lr

24008e04 <HAL_I2C_Init>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Init(I2C_HandleTypeDef *hi2c)
{
24008e04:	b580      	push	{r7, lr}
24008e06:	b082      	sub	sp, #8
24008e08:	af00      	add	r7, sp, #0
24008e0a:	6078      	str	r0, [r7, #4]
  /* Check the I2C handle allocation */
  if (hi2c == NULL)
24008e0c:	687b      	ldr	r3, [r7, #4]
24008e0e:	2b00      	cmp	r3, #0
24008e10:	d101      	bne.n	24008e16 <HAL_I2C_Init+0x12>
  {
    return HAL_ERROR;
24008e12:	2301      	movs	r3, #1
24008e14:	e07f      	b.n	24008f16 <HAL_I2C_Init+0x112>
  assert_param(IS_I2C_OWN_ADDRESS2(hi2c->Init.OwnAddress2));
  assert_param(IS_I2C_OWN_ADDRESS2_MASK(hi2c->Init.OwnAddress2Masks));
  assert_param(IS_I2C_GENERAL_CALL(hi2c->Init.GeneralCallMode));
  assert_param(IS_I2C_NO_STRETCH(hi2c->Init.NoStretchMode));

  if (hi2c->State == HAL_I2C_STATE_RESET)
24008e16:	687b      	ldr	r3, [r7, #4]
24008e18:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
24008e1c:	b2db      	uxtb	r3, r3
24008e1e:	2b00      	cmp	r3, #0
24008e20:	d106      	bne.n	24008e30 <HAL_I2C_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    hi2c->Lock = HAL_UNLOCKED;
24008e22:	687b      	ldr	r3, [r7, #4]
24008e24:	2200      	movs	r2, #0
24008e26:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Init the low level hardware : GPIO, CLOCK, CORTEX...etc */
    hi2c->MspInitCallback(hi2c);
#else
    /* Init the low level hardware : GPIO, CLOCK, CORTEX...etc */
    HAL_I2C_MspInit(hi2c);
24008e2a:	6878      	ldr	r0, [r7, #4]
24008e2c:	f000 f8a9 	bl	24008f82 <HAL_I2C_MspInit>
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
  }

  hi2c->State = HAL_I2C_STATE_BUSY;
24008e30:	687b      	ldr	r3, [r7, #4]
24008e32:	2224      	movs	r2, #36	; 0x24
24008e34:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

  /* Disable the selected I2C peripheral */
  __HAL_I2C_DISABLE(hi2c);
24008e38:	687b      	ldr	r3, [r7, #4]
24008e3a:	681b      	ldr	r3, [r3, #0]
24008e3c:	681a      	ldr	r2, [r3, #0]
24008e3e:	687b      	ldr	r3, [r7, #4]
24008e40:	681b      	ldr	r3, [r3, #0]
24008e42:	f022 0201 	bic.w	r2, r2, #1
24008e46:	601a      	str	r2, [r3, #0]

  /*---------------------------- I2Cx TIMINGR Configuration ------------------*/
  /* Configure I2Cx: Frequency range */
  hi2c->Instance->TIMINGR = hi2c->Init.Timing & TIMING_CLEAR_MASK;
24008e48:	687b      	ldr	r3, [r7, #4]
24008e4a:	685a      	ldr	r2, [r3, #4]
24008e4c:	687b      	ldr	r3, [r7, #4]
24008e4e:	681b      	ldr	r3, [r3, #0]
24008e50:	f022 6270 	bic.w	r2, r2, #251658240	; 0xf000000
24008e54:	611a      	str	r2, [r3, #16]

  /*---------------------------- I2Cx OAR1 Configuration ---------------------*/
  /* Disable Own Address1 before set the Own Address1 configuration */
  hi2c->Instance->OAR1 &= ~I2C_OAR1_OA1EN;
24008e56:	687b      	ldr	r3, [r7, #4]
24008e58:	681b      	ldr	r3, [r3, #0]
24008e5a:	689a      	ldr	r2, [r3, #8]
24008e5c:	687b      	ldr	r3, [r7, #4]
24008e5e:	681b      	ldr	r3, [r3, #0]
24008e60:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
24008e64:	609a      	str	r2, [r3, #8]

  /* Configure I2Cx: Own Address1 and ack own address1 mode */
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
24008e66:	687b      	ldr	r3, [r7, #4]
24008e68:	68db      	ldr	r3, [r3, #12]
24008e6a:	2b01      	cmp	r3, #1
24008e6c:	d107      	bne.n	24008e7e <HAL_I2C_Init+0x7a>
  {
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | hi2c->Init.OwnAddress1);
24008e6e:	687b      	ldr	r3, [r7, #4]
24008e70:	689a      	ldr	r2, [r3, #8]
24008e72:	687b      	ldr	r3, [r7, #4]
24008e74:	681b      	ldr	r3, [r3, #0]
24008e76:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
24008e7a:	609a      	str	r2, [r3, #8]
24008e7c:	e006      	b.n	24008e8c <HAL_I2C_Init+0x88>
  }
  else /* I2C_ADDRESSINGMODE_10BIT */
  {
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | I2C_OAR1_OA1MODE | hi2c->Init.OwnAddress1);
24008e7e:	687b      	ldr	r3, [r7, #4]
24008e80:	689a      	ldr	r2, [r3, #8]
24008e82:	687b      	ldr	r3, [r7, #4]
24008e84:	681b      	ldr	r3, [r3, #0]
24008e86:	f442 4204 	orr.w	r2, r2, #33792	; 0x8400
24008e8a:	609a      	str	r2, [r3, #8]
  }

  /*---------------------------- I2Cx CR2 Configuration ----------------------*/
  /* Configure I2Cx: Addressing Master mode */
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
24008e8c:	687b      	ldr	r3, [r7, #4]
24008e8e:	68db      	ldr	r3, [r3, #12]
24008e90:	2b02      	cmp	r3, #2
24008e92:	d104      	bne.n	24008e9e <HAL_I2C_Init+0x9a>
  {
    hi2c->Instance->CR2 = (I2C_CR2_ADD10);
24008e94:	687b      	ldr	r3, [r7, #4]
24008e96:	681b      	ldr	r3, [r3, #0]
24008e98:	f44f 6200 	mov.w	r2, #2048	; 0x800
24008e9c:	605a      	str	r2, [r3, #4]
  }
  /* Enable the AUTOEND by default, and enable NACK (should be disable only during Slave process */
  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
24008e9e:	687b      	ldr	r3, [r7, #4]
24008ea0:	681b      	ldr	r3, [r3, #0]
24008ea2:	6859      	ldr	r1, [r3, #4]
24008ea4:	687b      	ldr	r3, [r7, #4]
24008ea6:	681a      	ldr	r2, [r3, #0]
24008ea8:	4b1d      	ldr	r3, [pc, #116]	; (24008f20 <HAL_I2C_Init+0x11c>)
24008eaa:	430b      	orrs	r3, r1
24008eac:	6053      	str	r3, [r2, #4]

  /*---------------------------- I2Cx OAR2 Configuration ---------------------*/
  /* Disable Own Address2 before set the Own Address2 configuration */
  hi2c->Instance->OAR2 &= ~I2C_DUALADDRESS_ENABLE;
24008eae:	687b      	ldr	r3, [r7, #4]
24008eb0:	681b      	ldr	r3, [r3, #0]
24008eb2:	68da      	ldr	r2, [r3, #12]
24008eb4:	687b      	ldr	r3, [r7, #4]
24008eb6:	681b      	ldr	r3, [r3, #0]
24008eb8:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
24008ebc:	60da      	str	r2, [r3, #12]

  /* Configure I2Cx: Dual mode and Own Address2 */
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | (hi2c->Init.OwnAddress2Masks << 8));
24008ebe:	687b      	ldr	r3, [r7, #4]
24008ec0:	691a      	ldr	r2, [r3, #16]
24008ec2:	687b      	ldr	r3, [r7, #4]
24008ec4:	695b      	ldr	r3, [r3, #20]
24008ec6:	ea42 0103 	orr.w	r1, r2, r3
24008eca:	687b      	ldr	r3, [r7, #4]
24008ecc:	699b      	ldr	r3, [r3, #24]
24008ece:	021a      	lsls	r2, r3, #8
24008ed0:	687b      	ldr	r3, [r7, #4]
24008ed2:	681b      	ldr	r3, [r3, #0]
24008ed4:	430a      	orrs	r2, r1
24008ed6:	60da      	str	r2, [r3, #12]

  /*---------------------------- I2Cx CR1 Configuration ----------------------*/
  /* Configure I2Cx: Generalcall and NoStretch mode */
  hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
24008ed8:	687b      	ldr	r3, [r7, #4]
24008eda:	69d9      	ldr	r1, [r3, #28]
24008edc:	687b      	ldr	r3, [r7, #4]
24008ede:	6a1a      	ldr	r2, [r3, #32]
24008ee0:	687b      	ldr	r3, [r7, #4]
24008ee2:	681b      	ldr	r3, [r3, #0]
24008ee4:	430a      	orrs	r2, r1
24008ee6:	601a      	str	r2, [r3, #0]

  /* Enable the selected I2C peripheral */
  __HAL_I2C_ENABLE(hi2c);
24008ee8:	687b      	ldr	r3, [r7, #4]
24008eea:	681b      	ldr	r3, [r3, #0]
24008eec:	681a      	ldr	r2, [r3, #0]
24008eee:	687b      	ldr	r3, [r7, #4]
24008ef0:	681b      	ldr	r3, [r3, #0]
24008ef2:	f042 0201 	orr.w	r2, r2, #1
24008ef6:	601a      	str	r2, [r3, #0]

  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
24008ef8:	687b      	ldr	r3, [r7, #4]
24008efa:	2200      	movs	r2, #0
24008efc:	645a      	str	r2, [r3, #68]	; 0x44
  hi2c->State = HAL_I2C_STATE_READY;
24008efe:	687b      	ldr	r3, [r7, #4]
24008f00:	2220      	movs	r2, #32
24008f02:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
  hi2c->PreviousState = I2C_STATE_NONE;
24008f06:	687b      	ldr	r3, [r7, #4]
24008f08:	2200      	movs	r2, #0
24008f0a:	631a      	str	r2, [r3, #48]	; 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
24008f0c:	687b      	ldr	r3, [r7, #4]
24008f0e:	2200      	movs	r2, #0
24008f10:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

  return HAL_OK;
24008f14:	2300      	movs	r3, #0
}
24008f16:	4618      	mov	r0, r3
24008f18:	3708      	adds	r7, #8
24008f1a:	46bd      	mov	sp, r7
24008f1c:	bd80      	pop	{r7, pc}
24008f1e:	bf00      	nop
24008f20:	02008000 	.word	0x02008000

24008f24 <HAL_I2C_DeInit>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_DeInit(I2C_HandleTypeDef *hi2c)
{
24008f24:	b580      	push	{r7, lr}
24008f26:	b082      	sub	sp, #8
24008f28:	af00      	add	r7, sp, #0
24008f2a:	6078      	str	r0, [r7, #4]
  /* Check the I2C handle allocation */
  if (hi2c == NULL)
24008f2c:	687b      	ldr	r3, [r7, #4]
24008f2e:	2b00      	cmp	r3, #0
24008f30:	d101      	bne.n	24008f36 <HAL_I2C_DeInit+0x12>
  {
    return HAL_ERROR;
24008f32:	2301      	movs	r3, #1
24008f34:	e021      	b.n	24008f7a <HAL_I2C_DeInit+0x56>
  }

  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));

  hi2c->State = HAL_I2C_STATE_BUSY;
24008f36:	687b      	ldr	r3, [r7, #4]
24008f38:	2224      	movs	r2, #36	; 0x24
24008f3a:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

  /* Disable the I2C Peripheral Clock */
  __HAL_I2C_DISABLE(hi2c);
24008f3e:	687b      	ldr	r3, [r7, #4]
24008f40:	681b      	ldr	r3, [r3, #0]
24008f42:	681a      	ldr	r2, [r3, #0]
24008f44:	687b      	ldr	r3, [r7, #4]
24008f46:	681b      	ldr	r3, [r3, #0]
24008f48:	f022 0201 	bic.w	r2, r2, #1
24008f4c:	601a      	str	r2, [r3, #0]

  /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
  hi2c->MspDeInitCallback(hi2c);
#else
  /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
  HAL_I2C_MspDeInit(hi2c);
24008f4e:	6878      	ldr	r0, [r7, #4]
24008f50:	f000 f821 	bl	24008f96 <HAL_I2C_MspDeInit>
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */

  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
24008f54:	687b      	ldr	r3, [r7, #4]
24008f56:	2200      	movs	r2, #0
24008f58:	645a      	str	r2, [r3, #68]	; 0x44
  hi2c->State = HAL_I2C_STATE_RESET;
24008f5a:	687b      	ldr	r3, [r7, #4]
24008f5c:	2200      	movs	r2, #0
24008f5e:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
  hi2c->PreviousState = I2C_STATE_NONE;
24008f62:	687b      	ldr	r3, [r7, #4]
24008f64:	2200      	movs	r2, #0
24008f66:	631a      	str	r2, [r3, #48]	; 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
24008f68:	687b      	ldr	r3, [r7, #4]
24008f6a:	2200      	movs	r2, #0
24008f6c:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

  /* Release Lock */
  __HAL_UNLOCK(hi2c);
24008f70:	687b      	ldr	r3, [r7, #4]
24008f72:	2200      	movs	r2, #0
24008f74:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  return HAL_OK;
24008f78:	2300      	movs	r3, #0
}
24008f7a:	4618      	mov	r0, r3
24008f7c:	3708      	adds	r7, #8
24008f7e:	46bd      	mov	sp, r7
24008f80:	bd80      	pop	{r7, pc}

24008f82 <HAL_I2C_MspInit>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_MspInit(I2C_HandleTypeDef *hi2c)
{
24008f82:	b480      	push	{r7}
24008f84:	b083      	sub	sp, #12
24008f86:	af00      	add	r7, sp, #0
24008f88:	6078      	str	r0, [r7, #4]
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_MspInit could be implemented in the user file
   */
}
24008f8a:	bf00      	nop
24008f8c:	370c      	adds	r7, #12
24008f8e:	46bd      	mov	sp, r7
24008f90:	f85d 7b04 	ldr.w	r7, [sp], #4
24008f94:	4770      	bx	lr

24008f96 <HAL_I2C_MspDeInit>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_MspDeInit(I2C_HandleTypeDef *hi2c)
{
24008f96:	b480      	push	{r7}
24008f98:	b083      	sub	sp, #12
24008f9a:	af00      	add	r7, sp, #0
24008f9c:	6078      	str	r0, [r7, #4]
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_MspDeInit could be implemented in the user file
   */
}
24008f9e:	bf00      	nop
24008fa0:	370c      	adds	r7, #12
24008fa2:	46bd      	mov	sp, r7
24008fa4:	f85d 7b04 	ldr.w	r7, [sp], #4
24008fa8:	4770      	bx	lr
	...

24008fac <HAL_I2C_Master_Transmit>:
  * @param  Size Amount of data to be sent
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Master_Transmit(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
24008fac:	b580      	push	{r7, lr}
24008fae:	b088      	sub	sp, #32
24008fb0:	af02      	add	r7, sp, #8
24008fb2:	60f8      	str	r0, [r7, #12]
24008fb4:	607a      	str	r2, [r7, #4]
24008fb6:	461a      	mov	r2, r3
24008fb8:	460b      	mov	r3, r1
24008fba:	817b      	strh	r3, [r7, #10]
24008fbc:	4613      	mov	r3, r2
24008fbe:	813b      	strh	r3, [r7, #8]
  uint32_t tickstart;

  if (hi2c->State == HAL_I2C_STATE_READY)
24008fc0:	68fb      	ldr	r3, [r7, #12]
24008fc2:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
24008fc6:	b2db      	uxtb	r3, r3
24008fc8:	2b20      	cmp	r3, #32
24008fca:	f040 80da 	bne.w	24009182 <HAL_I2C_Master_Transmit+0x1d6>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
24008fce:	68fb      	ldr	r3, [r7, #12]
24008fd0:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
24008fd4:	2b01      	cmp	r3, #1
24008fd6:	d101      	bne.n	24008fdc <HAL_I2C_Master_Transmit+0x30>
24008fd8:	2302      	movs	r3, #2
24008fda:	e0d3      	b.n	24009184 <HAL_I2C_Master_Transmit+0x1d8>
24008fdc:	68fb      	ldr	r3, [r7, #12]
24008fde:	2201      	movs	r2, #1
24008fe0:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Init tickstart for timeout management*/
    tickstart = HAL_GetTick();
24008fe4:	f7f7 fc34 	bl	24000850 <HAL_GetTick>
24008fe8:	6178      	str	r0, [r7, #20]

    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
24008fea:	697b      	ldr	r3, [r7, #20]
24008fec:	9300      	str	r3, [sp, #0]
24008fee:	2319      	movs	r3, #25
24008ff0:	2201      	movs	r2, #1
24008ff2:	f44f 4100 	mov.w	r1, #32768	; 0x8000
24008ff6:	68f8      	ldr	r0, [r7, #12]
24008ff8:	f004 fd10 	bl	2400da1c <I2C_WaitOnFlagUntilTimeout>
24008ffc:	4603      	mov	r3, r0
24008ffe:	2b00      	cmp	r3, #0
24009000:	d001      	beq.n	24009006 <HAL_I2C_Master_Transmit+0x5a>
    {
      return HAL_ERROR;
24009002:	2301      	movs	r3, #1
24009004:	e0be      	b.n	24009184 <HAL_I2C_Master_Transmit+0x1d8>
    }

    hi2c->State     = HAL_I2C_STATE_BUSY_TX;
24009006:	68fb      	ldr	r3, [r7, #12]
24009008:	2221      	movs	r2, #33	; 0x21
2400900a:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_MASTER;
2400900e:	68fb      	ldr	r3, [r7, #12]
24009010:	2210      	movs	r2, #16
24009012:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
24009016:	68fb      	ldr	r3, [r7, #12]
24009018:	2200      	movs	r2, #0
2400901a:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr  = pData;
2400901c:	68fb      	ldr	r3, [r7, #12]
2400901e:	687a      	ldr	r2, [r7, #4]
24009020:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount = Size;
24009022:	68fb      	ldr	r3, [r7, #12]
24009024:	893a      	ldrh	r2, [r7, #8]
24009026:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferISR   = NULL;
24009028:	68fb      	ldr	r3, [r7, #12]
2400902a:	2200      	movs	r2, #0
2400902c:	635a      	str	r2, [r3, #52]	; 0x34

    /* Send Slave Address */
    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
2400902e:	68fb      	ldr	r3, [r7, #12]
24009030:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
24009032:	b29b      	uxth	r3, r3
24009034:	2bff      	cmp	r3, #255	; 0xff
24009036:	d90e      	bls.n	24009056 <HAL_I2C_Master_Transmit+0xaa>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
24009038:	68fb      	ldr	r3, [r7, #12]
2400903a:	22ff      	movs	r2, #255	; 0xff
2400903c:	851a      	strh	r2, [r3, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_GENERATE_START_WRITE);
2400903e:	68fb      	ldr	r3, [r7, #12]
24009040:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
24009042:	b2da      	uxtb	r2, r3
24009044:	8979      	ldrh	r1, [r7, #10]
24009046:	4b51      	ldr	r3, [pc, #324]	; (2400918c <HAL_I2C_Master_Transmit+0x1e0>)
24009048:	9300      	str	r3, [sp, #0]
2400904a:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2400904e:	68f8      	ldr	r0, [r7, #12]
24009050:	f004 fe72 	bl	2400dd38 <I2C_TransferConfig>
24009054:	e06c      	b.n	24009130 <HAL_I2C_Master_Transmit+0x184>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
24009056:	68fb      	ldr	r3, [r7, #12]
24009058:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400905a:	b29a      	uxth	r2, r3
2400905c:	68fb      	ldr	r3, [r7, #12]
2400905e:	851a      	strh	r2, [r3, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_WRITE);
24009060:	68fb      	ldr	r3, [r7, #12]
24009062:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
24009064:	b2da      	uxtb	r2, r3
24009066:	8979      	ldrh	r1, [r7, #10]
24009068:	4b48      	ldr	r3, [pc, #288]	; (2400918c <HAL_I2C_Master_Transmit+0x1e0>)
2400906a:	9300      	str	r3, [sp, #0]
2400906c:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
24009070:	68f8      	ldr	r0, [r7, #12]
24009072:	f004 fe61 	bl	2400dd38 <I2C_TransferConfig>
    }

    while (hi2c->XferCount > 0U)
24009076:	e05b      	b.n	24009130 <HAL_I2C_Master_Transmit+0x184>
    {
      /* Wait until TXIS flag is set */
      if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
24009078:	697a      	ldr	r2, [r7, #20]
2400907a:	6a39      	ldr	r1, [r7, #32]
2400907c:	68f8      	ldr	r0, [r7, #12]
2400907e:	f004 fd0d 	bl	2400da9c <I2C_WaitOnTXISFlagUntilTimeout>
24009082:	4603      	mov	r3, r0
24009084:	2b00      	cmp	r3, #0
24009086:	d001      	beq.n	2400908c <HAL_I2C_Master_Transmit+0xe0>
      {
        return HAL_ERROR;
24009088:	2301      	movs	r3, #1
2400908a:	e07b      	b.n	24009184 <HAL_I2C_Master_Transmit+0x1d8>
      }
      /* Write data to TXDR */
      hi2c->Instance->TXDR = *hi2c->pBuffPtr;
2400908c:	68fb      	ldr	r3, [r7, #12]
2400908e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
24009090:	781a      	ldrb	r2, [r3, #0]
24009092:	68fb      	ldr	r3, [r7, #12]
24009094:	681b      	ldr	r3, [r3, #0]
24009096:	629a      	str	r2, [r3, #40]	; 0x28

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
24009098:	68fb      	ldr	r3, [r7, #12]
2400909a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400909c:	1c5a      	adds	r2, r3, #1
2400909e:	68fb      	ldr	r3, [r7, #12]
240090a0:	625a      	str	r2, [r3, #36]	; 0x24

      hi2c->XferCount--;
240090a2:	68fb      	ldr	r3, [r7, #12]
240090a4:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
240090a6:	b29b      	uxth	r3, r3
240090a8:	3b01      	subs	r3, #1
240090aa:	b29a      	uxth	r2, r3
240090ac:	68fb      	ldr	r3, [r7, #12]
240090ae:	855a      	strh	r2, [r3, #42]	; 0x2a
      hi2c->XferSize--;
240090b0:	68fb      	ldr	r3, [r7, #12]
240090b2:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
240090b4:	3b01      	subs	r3, #1
240090b6:	b29a      	uxth	r2, r3
240090b8:	68fb      	ldr	r3, [r7, #12]
240090ba:	851a      	strh	r2, [r3, #40]	; 0x28

      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
240090bc:	68fb      	ldr	r3, [r7, #12]
240090be:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
240090c0:	b29b      	uxth	r3, r3
240090c2:	2b00      	cmp	r3, #0
240090c4:	d034      	beq.n	24009130 <HAL_I2C_Master_Transmit+0x184>
240090c6:	68fb      	ldr	r3, [r7, #12]
240090c8:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
240090ca:	2b00      	cmp	r3, #0
240090cc:	d130      	bne.n	24009130 <HAL_I2C_Master_Transmit+0x184>
      {
        /* Wait until TCR flag is set */
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
240090ce:	697b      	ldr	r3, [r7, #20]
240090d0:	9300      	str	r3, [sp, #0]
240090d2:	6a3b      	ldr	r3, [r7, #32]
240090d4:	2200      	movs	r2, #0
240090d6:	2180      	movs	r1, #128	; 0x80
240090d8:	68f8      	ldr	r0, [r7, #12]
240090da:	f004 fc9f 	bl	2400da1c <I2C_WaitOnFlagUntilTimeout>
240090de:	4603      	mov	r3, r0
240090e0:	2b00      	cmp	r3, #0
240090e2:	d001      	beq.n	240090e8 <HAL_I2C_Master_Transmit+0x13c>
        {
          return HAL_ERROR;
240090e4:	2301      	movs	r3, #1
240090e6:	e04d      	b.n	24009184 <HAL_I2C_Master_Transmit+0x1d8>
        }

        if (hi2c->XferCount > MAX_NBYTE_SIZE)
240090e8:	68fb      	ldr	r3, [r7, #12]
240090ea:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
240090ec:	b29b      	uxth	r3, r3
240090ee:	2bff      	cmp	r3, #255	; 0xff
240090f0:	d90e      	bls.n	24009110 <HAL_I2C_Master_Transmit+0x164>
        {
          hi2c->XferSize = MAX_NBYTE_SIZE;
240090f2:	68fb      	ldr	r3, [r7, #12]
240090f4:	22ff      	movs	r2, #255	; 0xff
240090f6:	851a      	strh	r2, [r3, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
240090f8:	68fb      	ldr	r3, [r7, #12]
240090fa:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
240090fc:	b2da      	uxtb	r2, r3
240090fe:	8979      	ldrh	r1, [r7, #10]
24009100:	2300      	movs	r3, #0
24009102:	9300      	str	r3, [sp, #0]
24009104:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
24009108:	68f8      	ldr	r0, [r7, #12]
2400910a:	f004 fe15 	bl	2400dd38 <I2C_TransferConfig>
2400910e:	e00f      	b.n	24009130 <HAL_I2C_Master_Transmit+0x184>
        }
        else
        {
          hi2c->XferSize = hi2c->XferCount;
24009110:	68fb      	ldr	r3, [r7, #12]
24009112:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
24009114:	b29a      	uxth	r2, r3
24009116:	68fb      	ldr	r3, [r7, #12]
24009118:	851a      	strh	r2, [r3, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
2400911a:	68fb      	ldr	r3, [r7, #12]
2400911c:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400911e:	b2da      	uxtb	r2, r3
24009120:	8979      	ldrh	r1, [r7, #10]
24009122:	2300      	movs	r3, #0
24009124:	9300      	str	r3, [sp, #0]
24009126:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
2400912a:	68f8      	ldr	r0, [r7, #12]
2400912c:	f004 fe04 	bl	2400dd38 <I2C_TransferConfig>
    while (hi2c->XferCount > 0U)
24009130:	68fb      	ldr	r3, [r7, #12]
24009132:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
24009134:	b29b      	uxth	r3, r3
24009136:	2b00      	cmp	r3, #0
24009138:	d19e      	bne.n	24009078 <HAL_I2C_Master_Transmit+0xcc>
      }
    }

    /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
    /* Wait until STOPF flag is set */
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
2400913a:	697a      	ldr	r2, [r7, #20]
2400913c:	6a39      	ldr	r1, [r7, #32]
2400913e:	68f8      	ldr	r0, [r7, #12]
24009140:	f004 fcec 	bl	2400db1c <I2C_WaitOnSTOPFlagUntilTimeout>
24009144:	4603      	mov	r3, r0
24009146:	2b00      	cmp	r3, #0
24009148:	d001      	beq.n	2400914e <HAL_I2C_Master_Transmit+0x1a2>
    {
      return HAL_ERROR;
2400914a:	2301      	movs	r3, #1
2400914c:	e01a      	b.n	24009184 <HAL_I2C_Master_Transmit+0x1d8>
    }

    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
2400914e:	68fb      	ldr	r3, [r7, #12]
24009150:	681b      	ldr	r3, [r3, #0]
24009152:	2220      	movs	r2, #32
24009154:	61da      	str	r2, [r3, #28]

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
24009156:	68fb      	ldr	r3, [r7, #12]
24009158:	681b      	ldr	r3, [r3, #0]
2400915a:	6859      	ldr	r1, [r3, #4]
2400915c:	68fb      	ldr	r3, [r7, #12]
2400915e:	681a      	ldr	r2, [r3, #0]
24009160:	4b0b      	ldr	r3, [pc, #44]	; (24009190 <HAL_I2C_Master_Transmit+0x1e4>)
24009162:	400b      	ands	r3, r1
24009164:	6053      	str	r3, [r2, #4]

    hi2c->State = HAL_I2C_STATE_READY;
24009166:	68fb      	ldr	r3, [r7, #12]
24009168:	2220      	movs	r2, #32
2400916a:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode  = HAL_I2C_MODE_NONE;
2400916e:	68fb      	ldr	r3, [r7, #12]
24009170:	2200      	movs	r2, #0
24009172:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
24009176:	68fb      	ldr	r3, [r7, #12]
24009178:	2200      	movs	r2, #0
2400917a:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    return HAL_OK;
2400917e:	2300      	movs	r3, #0
24009180:	e000      	b.n	24009184 <HAL_I2C_Master_Transmit+0x1d8>
  }
  else
  {
    return HAL_BUSY;
24009182:	2302      	movs	r3, #2
  }
}
24009184:	4618      	mov	r0, r3
24009186:	3718      	adds	r7, #24
24009188:	46bd      	mov	sp, r7
2400918a:	bd80      	pop	{r7, pc}
2400918c:	80002000 	.word	0x80002000
24009190:	fe00e800 	.word	0xfe00e800

24009194 <HAL_I2C_Master_Receive>:
  * @param  Size Amount of data to be sent
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Master_Receive(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
24009194:	b580      	push	{r7, lr}
24009196:	b088      	sub	sp, #32
24009198:	af02      	add	r7, sp, #8
2400919a:	60f8      	str	r0, [r7, #12]
2400919c:	607a      	str	r2, [r7, #4]
2400919e:	461a      	mov	r2, r3
240091a0:	460b      	mov	r3, r1
240091a2:	817b      	strh	r3, [r7, #10]
240091a4:	4613      	mov	r3, r2
240091a6:	813b      	strh	r3, [r7, #8]
  uint32_t tickstart;

  if (hi2c->State == HAL_I2C_STATE_READY)
240091a8:	68fb      	ldr	r3, [r7, #12]
240091aa:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
240091ae:	b2db      	uxtb	r3, r3
240091b0:	2b20      	cmp	r3, #32
240091b2:	f040 80db 	bne.w	2400936c <HAL_I2C_Master_Receive+0x1d8>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
240091b6:	68fb      	ldr	r3, [r7, #12]
240091b8:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
240091bc:	2b01      	cmp	r3, #1
240091be:	d101      	bne.n	240091c4 <HAL_I2C_Master_Receive+0x30>
240091c0:	2302      	movs	r3, #2
240091c2:	e0d4      	b.n	2400936e <HAL_I2C_Master_Receive+0x1da>
240091c4:	68fb      	ldr	r3, [r7, #12]
240091c6:	2201      	movs	r2, #1
240091c8:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Init tickstart for timeout management*/
    tickstart = HAL_GetTick();
240091cc:	f7f7 fb40 	bl	24000850 <HAL_GetTick>
240091d0:	6178      	str	r0, [r7, #20]

    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
240091d2:	697b      	ldr	r3, [r7, #20]
240091d4:	9300      	str	r3, [sp, #0]
240091d6:	2319      	movs	r3, #25
240091d8:	2201      	movs	r2, #1
240091da:	f44f 4100 	mov.w	r1, #32768	; 0x8000
240091de:	68f8      	ldr	r0, [r7, #12]
240091e0:	f004 fc1c 	bl	2400da1c <I2C_WaitOnFlagUntilTimeout>
240091e4:	4603      	mov	r3, r0
240091e6:	2b00      	cmp	r3, #0
240091e8:	d001      	beq.n	240091ee <HAL_I2C_Master_Receive+0x5a>
    {
      return HAL_ERROR;
240091ea:	2301      	movs	r3, #1
240091ec:	e0bf      	b.n	2400936e <HAL_I2C_Master_Receive+0x1da>
    }

    hi2c->State     = HAL_I2C_STATE_BUSY_RX;
240091ee:	68fb      	ldr	r3, [r7, #12]
240091f0:	2222      	movs	r2, #34	; 0x22
240091f2:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_MASTER;
240091f6:	68fb      	ldr	r3, [r7, #12]
240091f8:	2210      	movs	r2, #16
240091fa:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
240091fe:	68fb      	ldr	r3, [r7, #12]
24009200:	2200      	movs	r2, #0
24009202:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr  = pData;
24009204:	68fb      	ldr	r3, [r7, #12]
24009206:	687a      	ldr	r2, [r7, #4]
24009208:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount = Size;
2400920a:	68fb      	ldr	r3, [r7, #12]
2400920c:	893a      	ldrh	r2, [r7, #8]
2400920e:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferISR   = NULL;
24009210:	68fb      	ldr	r3, [r7, #12]
24009212:	2200      	movs	r2, #0
24009214:	635a      	str	r2, [r3, #52]	; 0x34

    /* Send Slave Address */
    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
24009216:	68fb      	ldr	r3, [r7, #12]
24009218:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400921a:	b29b      	uxth	r3, r3
2400921c:	2bff      	cmp	r3, #255	; 0xff
2400921e:	d90e      	bls.n	2400923e <HAL_I2C_Master_Receive+0xaa>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
24009220:	68fb      	ldr	r3, [r7, #12]
24009222:	22ff      	movs	r2, #255	; 0xff
24009224:	851a      	strh	r2, [r3, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_GENERATE_START_READ);
24009226:	68fb      	ldr	r3, [r7, #12]
24009228:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400922a:	b2da      	uxtb	r2, r3
2400922c:	8979      	ldrh	r1, [r7, #10]
2400922e:	4b52      	ldr	r3, [pc, #328]	; (24009378 <HAL_I2C_Master_Receive+0x1e4>)
24009230:	9300      	str	r3, [sp, #0]
24009232:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
24009236:	68f8      	ldr	r0, [r7, #12]
24009238:	f004 fd7e 	bl	2400dd38 <I2C_TransferConfig>
2400923c:	e06d      	b.n	2400931a <HAL_I2C_Master_Receive+0x186>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
2400923e:	68fb      	ldr	r3, [r7, #12]
24009240:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
24009242:	b29a      	uxth	r2, r3
24009244:	68fb      	ldr	r3, [r7, #12]
24009246:	851a      	strh	r2, [r3, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_READ);
24009248:	68fb      	ldr	r3, [r7, #12]
2400924a:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400924c:	b2da      	uxtb	r2, r3
2400924e:	8979      	ldrh	r1, [r7, #10]
24009250:	4b49      	ldr	r3, [pc, #292]	; (24009378 <HAL_I2C_Master_Receive+0x1e4>)
24009252:	9300      	str	r3, [sp, #0]
24009254:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
24009258:	68f8      	ldr	r0, [r7, #12]
2400925a:	f004 fd6d 	bl	2400dd38 <I2C_TransferConfig>
    }

    while (hi2c->XferCount > 0U)
2400925e:	e05c      	b.n	2400931a <HAL_I2C_Master_Receive+0x186>
    {
      /* Wait until RXNE flag is set */
      if (I2C_WaitOnRXNEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
24009260:	697a      	ldr	r2, [r7, #20]
24009262:	6a39      	ldr	r1, [r7, #32]
24009264:	68f8      	ldr	r0, [r7, #12]
24009266:	f004 fc95 	bl	2400db94 <I2C_WaitOnRXNEFlagUntilTimeout>
2400926a:	4603      	mov	r3, r0
2400926c:	2b00      	cmp	r3, #0
2400926e:	d001      	beq.n	24009274 <HAL_I2C_Master_Receive+0xe0>
      {
        return HAL_ERROR;
24009270:	2301      	movs	r3, #1
24009272:	e07c      	b.n	2400936e <HAL_I2C_Master_Receive+0x1da>
      }

      /* Read data from RXDR */
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
24009274:	68fb      	ldr	r3, [r7, #12]
24009276:	681b      	ldr	r3, [r3, #0]
24009278:	6a5a      	ldr	r2, [r3, #36]	; 0x24
2400927a:	68fb      	ldr	r3, [r7, #12]
2400927c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400927e:	b2d2      	uxtb	r2, r2
24009280:	701a      	strb	r2, [r3, #0]

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
24009282:	68fb      	ldr	r3, [r7, #12]
24009284:	6a5b      	ldr	r3, [r3, #36]	; 0x24
24009286:	1c5a      	adds	r2, r3, #1
24009288:	68fb      	ldr	r3, [r7, #12]
2400928a:	625a      	str	r2, [r3, #36]	; 0x24

      hi2c->XferSize--;
2400928c:	68fb      	ldr	r3, [r7, #12]
2400928e:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
24009290:	3b01      	subs	r3, #1
24009292:	b29a      	uxth	r2, r3
24009294:	68fb      	ldr	r3, [r7, #12]
24009296:	851a      	strh	r2, [r3, #40]	; 0x28
      hi2c->XferCount--;
24009298:	68fb      	ldr	r3, [r7, #12]
2400929a:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400929c:	b29b      	uxth	r3, r3
2400929e:	3b01      	subs	r3, #1
240092a0:	b29a      	uxth	r2, r3
240092a2:	68fb      	ldr	r3, [r7, #12]
240092a4:	855a      	strh	r2, [r3, #42]	; 0x2a

      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
240092a6:	68fb      	ldr	r3, [r7, #12]
240092a8:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
240092aa:	b29b      	uxth	r3, r3
240092ac:	2b00      	cmp	r3, #0
240092ae:	d034      	beq.n	2400931a <HAL_I2C_Master_Receive+0x186>
240092b0:	68fb      	ldr	r3, [r7, #12]
240092b2:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
240092b4:	2b00      	cmp	r3, #0
240092b6:	d130      	bne.n	2400931a <HAL_I2C_Master_Receive+0x186>
      {
        /* Wait until TCR flag is set */
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
240092b8:	697b      	ldr	r3, [r7, #20]
240092ba:	9300      	str	r3, [sp, #0]
240092bc:	6a3b      	ldr	r3, [r7, #32]
240092be:	2200      	movs	r2, #0
240092c0:	2180      	movs	r1, #128	; 0x80
240092c2:	68f8      	ldr	r0, [r7, #12]
240092c4:	f004 fbaa 	bl	2400da1c <I2C_WaitOnFlagUntilTimeout>
240092c8:	4603      	mov	r3, r0
240092ca:	2b00      	cmp	r3, #0
240092cc:	d001      	beq.n	240092d2 <HAL_I2C_Master_Receive+0x13e>
        {
          return HAL_ERROR;
240092ce:	2301      	movs	r3, #1
240092d0:	e04d      	b.n	2400936e <HAL_I2C_Master_Receive+0x1da>
        }

        if (hi2c->XferCount > MAX_NBYTE_SIZE)
240092d2:	68fb      	ldr	r3, [r7, #12]
240092d4:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
240092d6:	b29b      	uxth	r3, r3
240092d8:	2bff      	cmp	r3, #255	; 0xff
240092da:	d90e      	bls.n	240092fa <HAL_I2C_Master_Receive+0x166>
        {
          hi2c->XferSize = MAX_NBYTE_SIZE;
240092dc:	68fb      	ldr	r3, [r7, #12]
240092de:	22ff      	movs	r2, #255	; 0xff
240092e0:	851a      	strh	r2, [r3, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
240092e2:	68fb      	ldr	r3, [r7, #12]
240092e4:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
240092e6:	b2da      	uxtb	r2, r3
240092e8:	8979      	ldrh	r1, [r7, #10]
240092ea:	2300      	movs	r3, #0
240092ec:	9300      	str	r3, [sp, #0]
240092ee:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
240092f2:	68f8      	ldr	r0, [r7, #12]
240092f4:	f004 fd20 	bl	2400dd38 <I2C_TransferConfig>
240092f8:	e00f      	b.n	2400931a <HAL_I2C_Master_Receive+0x186>
        }
        else
        {
          hi2c->XferSize = hi2c->XferCount;
240092fa:	68fb      	ldr	r3, [r7, #12]
240092fc:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
240092fe:	b29a      	uxth	r2, r3
24009300:	68fb      	ldr	r3, [r7, #12]
24009302:	851a      	strh	r2, [r3, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
24009304:	68fb      	ldr	r3, [r7, #12]
24009306:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
24009308:	b2da      	uxtb	r2, r3
2400930a:	8979      	ldrh	r1, [r7, #10]
2400930c:	2300      	movs	r3, #0
2400930e:	9300      	str	r3, [sp, #0]
24009310:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
24009314:	68f8      	ldr	r0, [r7, #12]
24009316:	f004 fd0f 	bl	2400dd38 <I2C_TransferConfig>
    while (hi2c->XferCount > 0U)
2400931a:	68fb      	ldr	r3, [r7, #12]
2400931c:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400931e:	b29b      	uxth	r3, r3
24009320:	2b00      	cmp	r3, #0
24009322:	d19d      	bne.n	24009260 <HAL_I2C_Master_Receive+0xcc>
      }
    }

    /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
    /* Wait until STOPF flag is set */
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
24009324:	697a      	ldr	r2, [r7, #20]
24009326:	6a39      	ldr	r1, [r7, #32]
24009328:	68f8      	ldr	r0, [r7, #12]
2400932a:	f004 fbf7 	bl	2400db1c <I2C_WaitOnSTOPFlagUntilTimeout>
2400932e:	4603      	mov	r3, r0
24009330:	2b00      	cmp	r3, #0
24009332:	d001      	beq.n	24009338 <HAL_I2C_Master_Receive+0x1a4>
    {
      return HAL_ERROR;
24009334:	2301      	movs	r3, #1
24009336:	e01a      	b.n	2400936e <HAL_I2C_Master_Receive+0x1da>
    }

    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
24009338:	68fb      	ldr	r3, [r7, #12]
2400933a:	681b      	ldr	r3, [r3, #0]
2400933c:	2220      	movs	r2, #32
2400933e:	61da      	str	r2, [r3, #28]

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
24009340:	68fb      	ldr	r3, [r7, #12]
24009342:	681b      	ldr	r3, [r3, #0]
24009344:	6859      	ldr	r1, [r3, #4]
24009346:	68fb      	ldr	r3, [r7, #12]
24009348:	681a      	ldr	r2, [r3, #0]
2400934a:	4b0c      	ldr	r3, [pc, #48]	; (2400937c <HAL_I2C_Master_Receive+0x1e8>)
2400934c:	400b      	ands	r3, r1
2400934e:	6053      	str	r3, [r2, #4]

    hi2c->State = HAL_I2C_STATE_READY;
24009350:	68fb      	ldr	r3, [r7, #12]
24009352:	2220      	movs	r2, #32
24009354:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode  = HAL_I2C_MODE_NONE;
24009358:	68fb      	ldr	r3, [r7, #12]
2400935a:	2200      	movs	r2, #0
2400935c:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
24009360:	68fb      	ldr	r3, [r7, #12]
24009362:	2200      	movs	r2, #0
24009364:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    return HAL_OK;
24009368:	2300      	movs	r3, #0
2400936a:	e000      	b.n	2400936e <HAL_I2C_Master_Receive+0x1da>
  }
  else
  {
    return HAL_BUSY;
2400936c:	2302      	movs	r3, #2
  }
}
2400936e:	4618      	mov	r0, r3
24009370:	3718      	adds	r7, #24
24009372:	46bd      	mov	sp, r7
24009374:	bd80      	pop	{r7, pc}
24009376:	bf00      	nop
24009378:	80002400 	.word	0x80002400
2400937c:	fe00e800 	.word	0xfe00e800

24009380 <HAL_I2C_Slave_Transmit>:
  * @param  Size Amount of data to be sent
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Slave_Transmit(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
24009380:	b580      	push	{r7, lr}
24009382:	b088      	sub	sp, #32
24009384:	af02      	add	r7, sp, #8
24009386:	60f8      	str	r0, [r7, #12]
24009388:	60b9      	str	r1, [r7, #8]
2400938a:	603b      	str	r3, [r7, #0]
2400938c:	4613      	mov	r3, r2
2400938e:	80fb      	strh	r3, [r7, #6]
  uint32_t tickstart;

  if (hi2c->State == HAL_I2C_STATE_READY)
24009390:	68fb      	ldr	r3, [r7, #12]
24009392:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
24009396:	b2db      	uxtb	r3, r3
24009398:	2b20      	cmp	r3, #32
2400939a:	f040 80f5 	bne.w	24009588 <HAL_I2C_Slave_Transmit+0x208>
  {
    if ((pData == NULL) || (Size == 0U))
2400939e:	68bb      	ldr	r3, [r7, #8]
240093a0:	2b00      	cmp	r3, #0
240093a2:	d002      	beq.n	240093aa <HAL_I2C_Slave_Transmit+0x2a>
240093a4:	88fb      	ldrh	r3, [r7, #6]
240093a6:	2b00      	cmp	r3, #0
240093a8:	d105      	bne.n	240093b6 <HAL_I2C_Slave_Transmit+0x36>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
240093aa:	68fb      	ldr	r3, [r7, #12]
240093ac:	f44f 7200 	mov.w	r2, #512	; 0x200
240093b0:	645a      	str	r2, [r3, #68]	; 0x44
      return  HAL_ERROR;
240093b2:	2301      	movs	r3, #1
240093b4:	e0e9      	b.n	2400958a <HAL_I2C_Slave_Transmit+0x20a>
    }
    /* Process Locked */
    __HAL_LOCK(hi2c);
240093b6:	68fb      	ldr	r3, [r7, #12]
240093b8:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
240093bc:	2b01      	cmp	r3, #1
240093be:	d101      	bne.n	240093c4 <HAL_I2C_Slave_Transmit+0x44>
240093c0:	2302      	movs	r3, #2
240093c2:	e0e2      	b.n	2400958a <HAL_I2C_Slave_Transmit+0x20a>
240093c4:	68fb      	ldr	r3, [r7, #12]
240093c6:	2201      	movs	r2, #1
240093c8:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Init tickstart for timeout management*/
    tickstart = HAL_GetTick();
240093cc:	f7f7 fa40 	bl	24000850 <HAL_GetTick>
240093d0:	6178      	str	r0, [r7, #20]

    hi2c->State     = HAL_I2C_STATE_BUSY_TX;
240093d2:	68fb      	ldr	r3, [r7, #12]
240093d4:	2221      	movs	r2, #33	; 0x21
240093d6:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_SLAVE;
240093da:	68fb      	ldr	r3, [r7, #12]
240093dc:	2220      	movs	r2, #32
240093de:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
240093e2:	68fb      	ldr	r3, [r7, #12]
240093e4:	2200      	movs	r2, #0
240093e6:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr  = pData;
240093e8:	68fb      	ldr	r3, [r7, #12]
240093ea:	68ba      	ldr	r2, [r7, #8]
240093ec:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount = Size;
240093ee:	68fb      	ldr	r3, [r7, #12]
240093f0:	88fa      	ldrh	r2, [r7, #6]
240093f2:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferISR   = NULL;
240093f4:	68fb      	ldr	r3, [r7, #12]
240093f6:	2200      	movs	r2, #0
240093f8:	635a      	str	r2, [r3, #52]	; 0x34

    /* Enable Address Acknowledge */
    hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
240093fa:	68fb      	ldr	r3, [r7, #12]
240093fc:	681b      	ldr	r3, [r3, #0]
240093fe:	685a      	ldr	r2, [r3, #4]
24009400:	68fb      	ldr	r3, [r7, #12]
24009402:	681b      	ldr	r3, [r3, #0]
24009404:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
24009408:	605a      	str	r2, [r3, #4]

    /* Wait until ADDR flag is set */
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, RESET, Timeout, tickstart) != HAL_OK)
2400940a:	697b      	ldr	r3, [r7, #20]
2400940c:	9300      	str	r3, [sp, #0]
2400940e:	683b      	ldr	r3, [r7, #0]
24009410:	2200      	movs	r2, #0
24009412:	2108      	movs	r1, #8
24009414:	68f8      	ldr	r0, [r7, #12]
24009416:	f004 fb01 	bl	2400da1c <I2C_WaitOnFlagUntilTimeout>
2400941a:	4603      	mov	r3, r0
2400941c:	2b00      	cmp	r3, #0
2400941e:	d009      	beq.n	24009434 <HAL_I2C_Slave_Transmit+0xb4>
    {
      /* Disable Address Acknowledge */
      hi2c->Instance->CR2 |= I2C_CR2_NACK;
24009420:	68fb      	ldr	r3, [r7, #12]
24009422:	681b      	ldr	r3, [r3, #0]
24009424:	685a      	ldr	r2, [r3, #4]
24009426:	68fb      	ldr	r3, [r7, #12]
24009428:	681b      	ldr	r3, [r3, #0]
2400942a:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
2400942e:	605a      	str	r2, [r3, #4]
      return HAL_ERROR;
24009430:	2301      	movs	r3, #1
24009432:	e0aa      	b.n	2400958a <HAL_I2C_Slave_Transmit+0x20a>
    }

    /* Clear ADDR flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
24009434:	68fb      	ldr	r3, [r7, #12]
24009436:	681b      	ldr	r3, [r3, #0]
24009438:	2208      	movs	r2, #8
2400943a:	61da      	str	r2, [r3, #28]

    /* If 10bit addressing mode is selected */
    if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
2400943c:	68fb      	ldr	r3, [r7, #12]
2400943e:	68db      	ldr	r3, [r3, #12]
24009440:	2b02      	cmp	r3, #2
24009442:	d118      	bne.n	24009476 <HAL_I2C_Slave_Transmit+0xf6>
    {
      /* Wait until ADDR flag is set */
      if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, RESET, Timeout, tickstart) != HAL_OK)
24009444:	697b      	ldr	r3, [r7, #20]
24009446:	9300      	str	r3, [sp, #0]
24009448:	683b      	ldr	r3, [r7, #0]
2400944a:	2200      	movs	r2, #0
2400944c:	2108      	movs	r1, #8
2400944e:	68f8      	ldr	r0, [r7, #12]
24009450:	f004 fae4 	bl	2400da1c <I2C_WaitOnFlagUntilTimeout>
24009454:	4603      	mov	r3, r0
24009456:	2b00      	cmp	r3, #0
24009458:	d009      	beq.n	2400946e <HAL_I2C_Slave_Transmit+0xee>
      {
        /* Disable Address Acknowledge */
        hi2c->Instance->CR2 |= I2C_CR2_NACK;
2400945a:	68fb      	ldr	r3, [r7, #12]
2400945c:	681b      	ldr	r3, [r3, #0]
2400945e:	685a      	ldr	r2, [r3, #4]
24009460:	68fb      	ldr	r3, [r7, #12]
24009462:	681b      	ldr	r3, [r3, #0]
24009464:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
24009468:	605a      	str	r2, [r3, #4]
        return HAL_ERROR;
2400946a:	2301      	movs	r3, #1
2400946c:	e08d      	b.n	2400958a <HAL_I2C_Slave_Transmit+0x20a>
      }

      /* Clear ADDR flag */
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
2400946e:	68fb      	ldr	r3, [r7, #12]
24009470:	681b      	ldr	r3, [r3, #0]
24009472:	2208      	movs	r2, #8
24009474:	61da      	str	r2, [r3, #28]
    }

    /* Wait until DIR flag is set Transmitter mode */
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_DIR, RESET, Timeout, tickstart) != HAL_OK)
24009476:	697b      	ldr	r3, [r7, #20]
24009478:	9300      	str	r3, [sp, #0]
2400947a:	683b      	ldr	r3, [r7, #0]
2400947c:	2200      	movs	r2, #0
2400947e:	f44f 3180 	mov.w	r1, #65536	; 0x10000
24009482:	68f8      	ldr	r0, [r7, #12]
24009484:	f004 faca 	bl	2400da1c <I2C_WaitOnFlagUntilTimeout>
24009488:	4603      	mov	r3, r0
2400948a:	2b00      	cmp	r3, #0
2400948c:	d02d      	beq.n	240094ea <HAL_I2C_Slave_Transmit+0x16a>
    {
      /* Disable Address Acknowledge */
      hi2c->Instance->CR2 |= I2C_CR2_NACK;
2400948e:	68fb      	ldr	r3, [r7, #12]
24009490:	681b      	ldr	r3, [r3, #0]
24009492:	685a      	ldr	r2, [r3, #4]
24009494:	68fb      	ldr	r3, [r7, #12]
24009496:	681b      	ldr	r3, [r3, #0]
24009498:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
2400949c:	605a      	str	r2, [r3, #4]
      return HAL_ERROR;
2400949e:	2301      	movs	r3, #1
240094a0:	e073      	b.n	2400958a <HAL_I2C_Slave_Transmit+0x20a>
    }

    while (hi2c->XferCount > 0U)
    {
      /* Wait until TXIS flag is set */
      if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
240094a2:	697a      	ldr	r2, [r7, #20]
240094a4:	6839      	ldr	r1, [r7, #0]
240094a6:	68f8      	ldr	r0, [r7, #12]
240094a8:	f004 faf8 	bl	2400da9c <I2C_WaitOnTXISFlagUntilTimeout>
240094ac:	4603      	mov	r3, r0
240094ae:	2b00      	cmp	r3, #0
240094b0:	d009      	beq.n	240094c6 <HAL_I2C_Slave_Transmit+0x146>
      {
        /* Disable Address Acknowledge */
        hi2c->Instance->CR2 |= I2C_CR2_NACK;
240094b2:	68fb      	ldr	r3, [r7, #12]
240094b4:	681b      	ldr	r3, [r3, #0]
240094b6:	685a      	ldr	r2, [r3, #4]
240094b8:	68fb      	ldr	r3, [r7, #12]
240094ba:	681b      	ldr	r3, [r3, #0]
240094bc:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
240094c0:	605a      	str	r2, [r3, #4]
        return HAL_ERROR;
240094c2:	2301      	movs	r3, #1
240094c4:	e061      	b.n	2400958a <HAL_I2C_Slave_Transmit+0x20a>
      }

      /* Write data to TXDR */
      hi2c->Instance->TXDR = *hi2c->pBuffPtr;
240094c6:	68fb      	ldr	r3, [r7, #12]
240094c8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
240094ca:	781a      	ldrb	r2, [r3, #0]
240094cc:	68fb      	ldr	r3, [r7, #12]
240094ce:	681b      	ldr	r3, [r3, #0]
240094d0:	629a      	str	r2, [r3, #40]	; 0x28

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
240094d2:	68fb      	ldr	r3, [r7, #12]
240094d4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
240094d6:	1c5a      	adds	r2, r3, #1
240094d8:	68fb      	ldr	r3, [r7, #12]
240094da:	625a      	str	r2, [r3, #36]	; 0x24

      hi2c->XferCount--;
240094dc:	68fb      	ldr	r3, [r7, #12]
240094de:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
240094e0:	b29b      	uxth	r3, r3
240094e2:	3b01      	subs	r3, #1
240094e4:	b29a      	uxth	r2, r3
240094e6:	68fb      	ldr	r3, [r7, #12]
240094e8:	855a      	strh	r2, [r3, #42]	; 0x2a
    while (hi2c->XferCount > 0U)
240094ea:	68fb      	ldr	r3, [r7, #12]
240094ec:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
240094ee:	b29b      	uxth	r3, r3
240094f0:	2b00      	cmp	r3, #0
240094f2:	d1d6      	bne.n	240094a2 <HAL_I2C_Slave_Transmit+0x122>
    }

    /* Wait until STOP flag is set */
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
240094f4:	697a      	ldr	r2, [r7, #20]
240094f6:	6839      	ldr	r1, [r7, #0]
240094f8:	68f8      	ldr	r0, [r7, #12]
240094fa:	f004 fb0f 	bl	2400db1c <I2C_WaitOnSTOPFlagUntilTimeout>
240094fe:	4603      	mov	r3, r0
24009500:	2b00      	cmp	r3, #0
24009502:	d011      	beq.n	24009528 <HAL_I2C_Slave_Transmit+0x1a8>
    {
      /* Disable Address Acknowledge */
      hi2c->Instance->CR2 |= I2C_CR2_NACK;
24009504:	68fb      	ldr	r3, [r7, #12]
24009506:	681b      	ldr	r3, [r3, #0]
24009508:	685a      	ldr	r2, [r3, #4]
2400950a:	68fb      	ldr	r3, [r7, #12]
2400950c:	681b      	ldr	r3, [r3, #0]
2400950e:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
24009512:	605a      	str	r2, [r3, #4]

      if (hi2c->ErrorCode == HAL_I2C_ERROR_AF)
24009514:	68fb      	ldr	r3, [r7, #12]
24009516:	6c5b      	ldr	r3, [r3, #68]	; 0x44
24009518:	2b04      	cmp	r3, #4
2400951a:	d103      	bne.n	24009524 <HAL_I2C_Slave_Transmit+0x1a4>
      {
        /* Normal use case for Transmitter mode */
        /* A NACK is generated to confirm the end of transfer */
        hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
2400951c:	68fb      	ldr	r3, [r7, #12]
2400951e:	2200      	movs	r2, #0
24009520:	645a      	str	r2, [r3, #68]	; 0x44
24009522:	e001      	b.n	24009528 <HAL_I2C_Slave_Transmit+0x1a8>
      }
      else
      {
        return HAL_ERROR;
24009524:	2301      	movs	r3, #1
24009526:	e030      	b.n	2400958a <HAL_I2C_Slave_Transmit+0x20a>
      }
    }

    /* Clear STOP flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
24009528:	68fb      	ldr	r3, [r7, #12]
2400952a:	681b      	ldr	r3, [r3, #0]
2400952c:	2220      	movs	r2, #32
2400952e:	61da      	str	r2, [r3, #28]

    /* Wait until BUSY flag is reset */
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, Timeout, tickstart) != HAL_OK)
24009530:	697b      	ldr	r3, [r7, #20]
24009532:	9300      	str	r3, [sp, #0]
24009534:	683b      	ldr	r3, [r7, #0]
24009536:	2201      	movs	r2, #1
24009538:	f44f 4100 	mov.w	r1, #32768	; 0x8000
2400953c:	68f8      	ldr	r0, [r7, #12]
2400953e:	f004 fa6d 	bl	2400da1c <I2C_WaitOnFlagUntilTimeout>
24009542:	4603      	mov	r3, r0
24009544:	2b00      	cmp	r3, #0
24009546:	d009      	beq.n	2400955c <HAL_I2C_Slave_Transmit+0x1dc>
    {
      /* Disable Address Acknowledge */
      hi2c->Instance->CR2 |= I2C_CR2_NACK;
24009548:	68fb      	ldr	r3, [r7, #12]
2400954a:	681b      	ldr	r3, [r3, #0]
2400954c:	685a      	ldr	r2, [r3, #4]
2400954e:	68fb      	ldr	r3, [r7, #12]
24009550:	681b      	ldr	r3, [r3, #0]
24009552:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
24009556:	605a      	str	r2, [r3, #4]
      return HAL_ERROR;
24009558:	2301      	movs	r3, #1
2400955a:	e016      	b.n	2400958a <HAL_I2C_Slave_Transmit+0x20a>
    }

    /* Disable Address Acknowledge */
    hi2c->Instance->CR2 |= I2C_CR2_NACK;
2400955c:	68fb      	ldr	r3, [r7, #12]
2400955e:	681b      	ldr	r3, [r3, #0]
24009560:	685a      	ldr	r2, [r3, #4]
24009562:	68fb      	ldr	r3, [r7, #12]
24009564:	681b      	ldr	r3, [r3, #0]
24009566:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
2400956a:	605a      	str	r2, [r3, #4]

    hi2c->State = HAL_I2C_STATE_READY;
2400956c:	68fb      	ldr	r3, [r7, #12]
2400956e:	2220      	movs	r2, #32
24009570:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode  = HAL_I2C_MODE_NONE;
24009574:	68fb      	ldr	r3, [r7, #12]
24009576:	2200      	movs	r2, #0
24009578:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2400957c:	68fb      	ldr	r3, [r7, #12]
2400957e:	2200      	movs	r2, #0
24009580:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    return HAL_OK;
24009584:	2300      	movs	r3, #0
24009586:	e000      	b.n	2400958a <HAL_I2C_Slave_Transmit+0x20a>
  }
  else
  {
    return HAL_BUSY;
24009588:	2302      	movs	r3, #2
  }
}
2400958a:	4618      	mov	r0, r3
2400958c:	3718      	adds	r7, #24
2400958e:	46bd      	mov	sp, r7
24009590:	bd80      	pop	{r7, pc}

24009592 <HAL_I2C_Slave_Receive>:
  * @param  Size Amount of data to be sent
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Slave_Receive(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
24009592:	b580      	push	{r7, lr}
24009594:	b088      	sub	sp, #32
24009596:	af02      	add	r7, sp, #8
24009598:	60f8      	str	r0, [r7, #12]
2400959a:	60b9      	str	r1, [r7, #8]
2400959c:	603b      	str	r3, [r7, #0]
2400959e:	4613      	mov	r3, r2
240095a0:	80fb      	strh	r3, [r7, #6]
  uint32_t tickstart;

  if (hi2c->State == HAL_I2C_STATE_READY)
240095a2:	68fb      	ldr	r3, [r7, #12]
240095a4:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
240095a8:	b2db      	uxtb	r3, r3
240095aa:	2b20      	cmp	r3, #32
240095ac:	f040 80eb 	bne.w	24009786 <HAL_I2C_Slave_Receive+0x1f4>
  {
    if ((pData == NULL) || (Size == 0U))
240095b0:	68bb      	ldr	r3, [r7, #8]
240095b2:	2b00      	cmp	r3, #0
240095b4:	d002      	beq.n	240095bc <HAL_I2C_Slave_Receive+0x2a>
240095b6:	88fb      	ldrh	r3, [r7, #6]
240095b8:	2b00      	cmp	r3, #0
240095ba:	d105      	bne.n	240095c8 <HAL_I2C_Slave_Receive+0x36>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
240095bc:	68fb      	ldr	r3, [r7, #12]
240095be:	f44f 7200 	mov.w	r2, #512	; 0x200
240095c2:	645a      	str	r2, [r3, #68]	; 0x44
      return  HAL_ERROR;
240095c4:	2301      	movs	r3, #1
240095c6:	e0df      	b.n	24009788 <HAL_I2C_Slave_Receive+0x1f6>
    }
    /* Process Locked */
    __HAL_LOCK(hi2c);
240095c8:	68fb      	ldr	r3, [r7, #12]
240095ca:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
240095ce:	2b01      	cmp	r3, #1
240095d0:	d101      	bne.n	240095d6 <HAL_I2C_Slave_Receive+0x44>
240095d2:	2302      	movs	r3, #2
240095d4:	e0d8      	b.n	24009788 <HAL_I2C_Slave_Receive+0x1f6>
240095d6:	68fb      	ldr	r3, [r7, #12]
240095d8:	2201      	movs	r2, #1
240095da:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Init tickstart for timeout management*/
    tickstart = HAL_GetTick();
240095de:	f7f7 f937 	bl	24000850 <HAL_GetTick>
240095e2:	6178      	str	r0, [r7, #20]

    hi2c->State     = HAL_I2C_STATE_BUSY_RX;
240095e4:	68fb      	ldr	r3, [r7, #12]
240095e6:	2222      	movs	r2, #34	; 0x22
240095e8:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_SLAVE;
240095ec:	68fb      	ldr	r3, [r7, #12]
240095ee:	2220      	movs	r2, #32
240095f0:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
240095f4:	68fb      	ldr	r3, [r7, #12]
240095f6:	2200      	movs	r2, #0
240095f8:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr  = pData;
240095fa:	68fb      	ldr	r3, [r7, #12]
240095fc:	68ba      	ldr	r2, [r7, #8]
240095fe:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount = Size;
24009600:	68fb      	ldr	r3, [r7, #12]
24009602:	88fa      	ldrh	r2, [r7, #6]
24009604:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferISR   = NULL;
24009606:	68fb      	ldr	r3, [r7, #12]
24009608:	2200      	movs	r2, #0
2400960a:	635a      	str	r2, [r3, #52]	; 0x34

    /* Enable Address Acknowledge */
    hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
2400960c:	68fb      	ldr	r3, [r7, #12]
2400960e:	681b      	ldr	r3, [r3, #0]
24009610:	685a      	ldr	r2, [r3, #4]
24009612:	68fb      	ldr	r3, [r7, #12]
24009614:	681b      	ldr	r3, [r3, #0]
24009616:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
2400961a:	605a      	str	r2, [r3, #4]

    /* Wait until ADDR flag is set */
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, RESET, Timeout, tickstart) != HAL_OK)
2400961c:	697b      	ldr	r3, [r7, #20]
2400961e:	9300      	str	r3, [sp, #0]
24009620:	683b      	ldr	r3, [r7, #0]
24009622:	2200      	movs	r2, #0
24009624:	2108      	movs	r1, #8
24009626:	68f8      	ldr	r0, [r7, #12]
24009628:	f004 f9f8 	bl	2400da1c <I2C_WaitOnFlagUntilTimeout>
2400962c:	4603      	mov	r3, r0
2400962e:	2b00      	cmp	r3, #0
24009630:	d009      	beq.n	24009646 <HAL_I2C_Slave_Receive+0xb4>
    {
      /* Disable Address Acknowledge */
      hi2c->Instance->CR2 |= I2C_CR2_NACK;
24009632:	68fb      	ldr	r3, [r7, #12]
24009634:	681b      	ldr	r3, [r3, #0]
24009636:	685a      	ldr	r2, [r3, #4]
24009638:	68fb      	ldr	r3, [r7, #12]
2400963a:	681b      	ldr	r3, [r3, #0]
2400963c:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
24009640:	605a      	str	r2, [r3, #4]
      return HAL_ERROR;
24009642:	2301      	movs	r3, #1
24009644:	e0a0      	b.n	24009788 <HAL_I2C_Slave_Receive+0x1f6>
    }

    /* Clear ADDR flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
24009646:	68fb      	ldr	r3, [r7, #12]
24009648:	681b      	ldr	r3, [r3, #0]
2400964a:	2208      	movs	r2, #8
2400964c:	61da      	str	r2, [r3, #28]

    /* Wait until DIR flag is reset Receiver mode */
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_DIR, SET, Timeout, tickstart) != HAL_OK)
2400964e:	697b      	ldr	r3, [r7, #20]
24009650:	9300      	str	r3, [sp, #0]
24009652:	683b      	ldr	r3, [r7, #0]
24009654:	2201      	movs	r2, #1
24009656:	f44f 3180 	mov.w	r1, #65536	; 0x10000
2400965a:	68f8      	ldr	r0, [r7, #12]
2400965c:	f004 f9de 	bl	2400da1c <I2C_WaitOnFlagUntilTimeout>
24009660:	4603      	mov	r3, r0
24009662:	2b00      	cmp	r3, #0
24009664:	d048      	beq.n	240096f8 <HAL_I2C_Slave_Receive+0x166>
    {
      /* Disable Address Acknowledge */
      hi2c->Instance->CR2 |= I2C_CR2_NACK;
24009666:	68fb      	ldr	r3, [r7, #12]
24009668:	681b      	ldr	r3, [r3, #0]
2400966a:	685a      	ldr	r2, [r3, #4]
2400966c:	68fb      	ldr	r3, [r7, #12]
2400966e:	681b      	ldr	r3, [r3, #0]
24009670:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
24009674:	605a      	str	r2, [r3, #4]
      return HAL_ERROR;
24009676:	2301      	movs	r3, #1
24009678:	e086      	b.n	24009788 <HAL_I2C_Slave_Receive+0x1f6>
    }

    while (hi2c->XferCount > 0U)
    {
      /* Wait until RXNE flag is set */
      if (I2C_WaitOnRXNEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
2400967a:	697a      	ldr	r2, [r7, #20]
2400967c:	6839      	ldr	r1, [r7, #0]
2400967e:	68f8      	ldr	r0, [r7, #12]
24009680:	f004 fa88 	bl	2400db94 <I2C_WaitOnRXNEFlagUntilTimeout>
24009684:	4603      	mov	r3, r0
24009686:	2b00      	cmp	r3, #0
24009688:	d023      	beq.n	240096d2 <HAL_I2C_Slave_Receive+0x140>
      {
        /* Disable Address Acknowledge */
        hi2c->Instance->CR2 |= I2C_CR2_NACK;
2400968a:	68fb      	ldr	r3, [r7, #12]
2400968c:	681b      	ldr	r3, [r3, #0]
2400968e:	685a      	ldr	r2, [r3, #4]
24009690:	68fb      	ldr	r3, [r7, #12]
24009692:	681b      	ldr	r3, [r3, #0]
24009694:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
24009698:	605a      	str	r2, [r3, #4]

        /* Store Last receive data if any */
        if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET)
2400969a:	68fb      	ldr	r3, [r7, #12]
2400969c:	681b      	ldr	r3, [r3, #0]
2400969e:	699b      	ldr	r3, [r3, #24]
240096a0:	f003 0304 	and.w	r3, r3, #4
240096a4:	2b04      	cmp	r3, #4
240096a6:	d112      	bne.n	240096ce <HAL_I2C_Slave_Receive+0x13c>
        {
          /* Read data from RXDR */
          *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
240096a8:	68fb      	ldr	r3, [r7, #12]
240096aa:	681b      	ldr	r3, [r3, #0]
240096ac:	6a5a      	ldr	r2, [r3, #36]	; 0x24
240096ae:	68fb      	ldr	r3, [r7, #12]
240096b0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
240096b2:	b2d2      	uxtb	r2, r2
240096b4:	701a      	strb	r2, [r3, #0]

          /* Increment Buffer pointer */
          hi2c->pBuffPtr++;
240096b6:	68fb      	ldr	r3, [r7, #12]
240096b8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
240096ba:	1c5a      	adds	r2, r3, #1
240096bc:	68fb      	ldr	r3, [r7, #12]
240096be:	625a      	str	r2, [r3, #36]	; 0x24

          hi2c->XferCount--;
240096c0:	68fb      	ldr	r3, [r7, #12]
240096c2:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
240096c4:	b29b      	uxth	r3, r3
240096c6:	3b01      	subs	r3, #1
240096c8:	b29a      	uxth	r2, r3
240096ca:	68fb      	ldr	r3, [r7, #12]
240096cc:	855a      	strh	r2, [r3, #42]	; 0x2a
        }

        return HAL_ERROR;
240096ce:	2301      	movs	r3, #1
240096d0:	e05a      	b.n	24009788 <HAL_I2C_Slave_Receive+0x1f6>
      }

      /* Read data from RXDR */
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
240096d2:	68fb      	ldr	r3, [r7, #12]
240096d4:	681b      	ldr	r3, [r3, #0]
240096d6:	6a5a      	ldr	r2, [r3, #36]	; 0x24
240096d8:	68fb      	ldr	r3, [r7, #12]
240096da:	6a5b      	ldr	r3, [r3, #36]	; 0x24
240096dc:	b2d2      	uxtb	r2, r2
240096de:	701a      	strb	r2, [r3, #0]

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
240096e0:	68fb      	ldr	r3, [r7, #12]
240096e2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
240096e4:	1c5a      	adds	r2, r3, #1
240096e6:	68fb      	ldr	r3, [r7, #12]
240096e8:	625a      	str	r2, [r3, #36]	; 0x24

      hi2c->XferCount--;
240096ea:	68fb      	ldr	r3, [r7, #12]
240096ec:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
240096ee:	b29b      	uxth	r3, r3
240096f0:	3b01      	subs	r3, #1
240096f2:	b29a      	uxth	r2, r3
240096f4:	68fb      	ldr	r3, [r7, #12]
240096f6:	855a      	strh	r2, [r3, #42]	; 0x2a
    while (hi2c->XferCount > 0U)
240096f8:	68fb      	ldr	r3, [r7, #12]
240096fa:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
240096fc:	b29b      	uxth	r3, r3
240096fe:	2b00      	cmp	r3, #0
24009700:	d1bb      	bne.n	2400967a <HAL_I2C_Slave_Receive+0xe8>
    }

    /* Wait until STOP flag is set */
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
24009702:	697a      	ldr	r2, [r7, #20]
24009704:	6839      	ldr	r1, [r7, #0]
24009706:	68f8      	ldr	r0, [r7, #12]
24009708:	f004 fa08 	bl	2400db1c <I2C_WaitOnSTOPFlagUntilTimeout>
2400970c:	4603      	mov	r3, r0
2400970e:	2b00      	cmp	r3, #0
24009710:	d009      	beq.n	24009726 <HAL_I2C_Slave_Receive+0x194>
    {
      /* Disable Address Acknowledge */
      hi2c->Instance->CR2 |= I2C_CR2_NACK;
24009712:	68fb      	ldr	r3, [r7, #12]
24009714:	681b      	ldr	r3, [r3, #0]
24009716:	685a      	ldr	r2, [r3, #4]
24009718:	68fb      	ldr	r3, [r7, #12]
2400971a:	681b      	ldr	r3, [r3, #0]
2400971c:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
24009720:	605a      	str	r2, [r3, #4]
      return HAL_ERROR;
24009722:	2301      	movs	r3, #1
24009724:	e030      	b.n	24009788 <HAL_I2C_Slave_Receive+0x1f6>
    }

    /* Clear STOP flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
24009726:	68fb      	ldr	r3, [r7, #12]
24009728:	681b      	ldr	r3, [r3, #0]
2400972a:	2220      	movs	r2, #32
2400972c:	61da      	str	r2, [r3, #28]

    /* Wait until BUSY flag is reset */
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, Timeout, tickstart) != HAL_OK)
2400972e:	697b      	ldr	r3, [r7, #20]
24009730:	9300      	str	r3, [sp, #0]
24009732:	683b      	ldr	r3, [r7, #0]
24009734:	2201      	movs	r2, #1
24009736:	f44f 4100 	mov.w	r1, #32768	; 0x8000
2400973a:	68f8      	ldr	r0, [r7, #12]
2400973c:	f004 f96e 	bl	2400da1c <I2C_WaitOnFlagUntilTimeout>
24009740:	4603      	mov	r3, r0
24009742:	2b00      	cmp	r3, #0
24009744:	d009      	beq.n	2400975a <HAL_I2C_Slave_Receive+0x1c8>
    {
      /* Disable Address Acknowledge */
      hi2c->Instance->CR2 |= I2C_CR2_NACK;
24009746:	68fb      	ldr	r3, [r7, #12]
24009748:	681b      	ldr	r3, [r3, #0]
2400974a:	685a      	ldr	r2, [r3, #4]
2400974c:	68fb      	ldr	r3, [r7, #12]
2400974e:	681b      	ldr	r3, [r3, #0]
24009750:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
24009754:	605a      	str	r2, [r3, #4]
      return HAL_ERROR;
24009756:	2301      	movs	r3, #1
24009758:	e016      	b.n	24009788 <HAL_I2C_Slave_Receive+0x1f6>
    }

    /* Disable Address Acknowledge */
    hi2c->Instance->CR2 |= I2C_CR2_NACK;
2400975a:	68fb      	ldr	r3, [r7, #12]
2400975c:	681b      	ldr	r3, [r3, #0]
2400975e:	685a      	ldr	r2, [r3, #4]
24009760:	68fb      	ldr	r3, [r7, #12]
24009762:	681b      	ldr	r3, [r3, #0]
24009764:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
24009768:	605a      	str	r2, [r3, #4]

    hi2c->State = HAL_I2C_STATE_READY;
2400976a:	68fb      	ldr	r3, [r7, #12]
2400976c:	2220      	movs	r2, #32
2400976e:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode  = HAL_I2C_MODE_NONE;
24009772:	68fb      	ldr	r3, [r7, #12]
24009774:	2200      	movs	r2, #0
24009776:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2400977a:	68fb      	ldr	r3, [r7, #12]
2400977c:	2200      	movs	r2, #0
2400977e:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    return HAL_OK;
24009782:	2300      	movs	r3, #0
24009784:	e000      	b.n	24009788 <HAL_I2C_Slave_Receive+0x1f6>
  }
  else
  {
    return HAL_BUSY;
24009786:	2302      	movs	r3, #2
  }
}
24009788:	4618      	mov	r0, r3
2400978a:	3718      	adds	r7, #24
2400978c:	46bd      	mov	sp, r7
2400978e:	bd80      	pop	{r7, pc}

24009790 <HAL_I2C_Master_Transmit_IT>:
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Master_Transmit_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size)
{
24009790:	b580      	push	{r7, lr}
24009792:	b088      	sub	sp, #32
24009794:	af02      	add	r7, sp, #8
24009796:	60f8      	str	r0, [r7, #12]
24009798:	607a      	str	r2, [r7, #4]
2400979a:	461a      	mov	r2, r3
2400979c:	460b      	mov	r3, r1
2400979e:	817b      	strh	r3, [r7, #10]
240097a0:	4613      	mov	r3, r2
240097a2:	813b      	strh	r3, [r7, #8]
  uint32_t xfermode;

  if (hi2c->State == HAL_I2C_STATE_READY)
240097a4:	68fb      	ldr	r3, [r7, #12]
240097a6:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
240097aa:	b2db      	uxtb	r3, r3
240097ac:	2b20      	cmp	r3, #32
240097ae:	d153      	bne.n	24009858 <HAL_I2C_Master_Transmit_IT+0xc8>
  {
    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
240097b0:	68fb      	ldr	r3, [r7, #12]
240097b2:	681b      	ldr	r3, [r3, #0]
240097b4:	699b      	ldr	r3, [r3, #24]
240097b6:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
240097ba:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
240097be:	d101      	bne.n	240097c4 <HAL_I2C_Master_Transmit_IT+0x34>
    {
      return HAL_BUSY;
240097c0:	2302      	movs	r3, #2
240097c2:	e04a      	b.n	2400985a <HAL_I2C_Master_Transmit_IT+0xca>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
240097c4:	68fb      	ldr	r3, [r7, #12]
240097c6:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
240097ca:	2b01      	cmp	r3, #1
240097cc:	d101      	bne.n	240097d2 <HAL_I2C_Master_Transmit_IT+0x42>
240097ce:	2302      	movs	r3, #2
240097d0:	e043      	b.n	2400985a <HAL_I2C_Master_Transmit_IT+0xca>
240097d2:	68fb      	ldr	r3, [r7, #12]
240097d4:	2201      	movs	r2, #1
240097d6:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State       = HAL_I2C_STATE_BUSY_TX;
240097da:	68fb      	ldr	r3, [r7, #12]
240097dc:	2221      	movs	r2, #33	; 0x21
240097de:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode        = HAL_I2C_MODE_MASTER;
240097e2:	68fb      	ldr	r3, [r7, #12]
240097e4:	2210      	movs	r2, #16
240097e6:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
240097ea:	68fb      	ldr	r3, [r7, #12]
240097ec:	2200      	movs	r2, #0
240097ee:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
240097f0:	68fb      	ldr	r3, [r7, #12]
240097f2:	687a      	ldr	r2, [r7, #4]
240097f4:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
240097f6:	68fb      	ldr	r3, [r7, #12]
240097f8:	893a      	ldrh	r2, [r7, #8]
240097fa:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
240097fc:	68fb      	ldr	r3, [r7, #12]
240097fe:	4a19      	ldr	r2, [pc, #100]	; (24009864 <HAL_I2C_Master_Transmit_IT+0xd4>)
24009800:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Master_ISR_IT;
24009802:	68fb      	ldr	r3, [r7, #12]
24009804:	4a18      	ldr	r2, [pc, #96]	; (24009868 <HAL_I2C_Master_Transmit_IT+0xd8>)
24009806:	635a      	str	r2, [r3, #52]	; 0x34

    if (hi2c->XferCount > MAX_NBYTE_SIZE)
24009808:	68fb      	ldr	r3, [r7, #12]
2400980a:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400980c:	b29b      	uxth	r3, r3
2400980e:	2bff      	cmp	r3, #255	; 0xff
24009810:	d906      	bls.n	24009820 <HAL_I2C_Master_Transmit_IT+0x90>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
24009812:	68fb      	ldr	r3, [r7, #12]
24009814:	22ff      	movs	r2, #255	; 0xff
24009816:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_RELOAD_MODE;
24009818:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2400981c:	617b      	str	r3, [r7, #20]
2400981e:	e007      	b.n	24009830 <HAL_I2C_Master_Transmit_IT+0xa0>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
24009820:	68fb      	ldr	r3, [r7, #12]
24009822:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
24009824:	b29a      	uxth	r2, r3
24009826:	68fb      	ldr	r3, [r7, #12]
24009828:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_AUTOEND_MODE;
2400982a:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
2400982e:	617b      	str	r3, [r7, #20]
    }

    /* Send Slave Address */
    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE */
    I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, I2C_GENERATE_START_WRITE);
24009830:	68fb      	ldr	r3, [r7, #12]
24009832:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
24009834:	b2da      	uxtb	r2, r3
24009836:	8979      	ldrh	r1, [r7, #10]
24009838:	4b0c      	ldr	r3, [pc, #48]	; (2400986c <HAL_I2C_Master_Transmit_IT+0xdc>)
2400983a:	9300      	str	r3, [sp, #0]
2400983c:	697b      	ldr	r3, [r7, #20]
2400983e:	68f8      	ldr	r0, [r7, #12]
24009840:	f004 fa7a 	bl	2400dd38 <I2C_TransferConfig>

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
24009844:	68fb      	ldr	r3, [r7, #12]
24009846:	2200      	movs	r2, #0
24009848:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
              process unlock */

    /* Enable ERR, TC, STOP, NACK, TXI interrupt */
    /* possible to enable all of these */
    /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
    I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT);
2400984c:	2101      	movs	r1, #1
2400984e:	68f8      	ldr	r0, [r7, #12]
24009850:	f004 faa0 	bl	2400dd94 <I2C_Enable_IRQ>

    return HAL_OK;
24009854:	2300      	movs	r3, #0
24009856:	e000      	b.n	2400985a <HAL_I2C_Master_Transmit_IT+0xca>
  }
  else
  {
    return HAL_BUSY;
24009858:	2302      	movs	r3, #2
  }
}
2400985a:	4618      	mov	r0, r3
2400985c:	3718      	adds	r7, #24
2400985e:	46bd      	mov	sp, r7
24009860:	bd80      	pop	{r7, pc}
24009862:	bf00      	nop
24009864:	ffff0000 	.word	0xffff0000
24009868:	2400beaf 	.word	0x2400beaf
2400986c:	80002000 	.word	0x80002000

24009870 <HAL_I2C_Master_Receive_IT>:
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Master_Receive_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size)
{
24009870:	b580      	push	{r7, lr}
24009872:	b088      	sub	sp, #32
24009874:	af02      	add	r7, sp, #8
24009876:	60f8      	str	r0, [r7, #12]
24009878:	607a      	str	r2, [r7, #4]
2400987a:	461a      	mov	r2, r3
2400987c:	460b      	mov	r3, r1
2400987e:	817b      	strh	r3, [r7, #10]
24009880:	4613      	mov	r3, r2
24009882:	813b      	strh	r3, [r7, #8]
  uint32_t xfermode;

  if (hi2c->State == HAL_I2C_STATE_READY)
24009884:	68fb      	ldr	r3, [r7, #12]
24009886:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400988a:	b2db      	uxtb	r3, r3
2400988c:	2b20      	cmp	r3, #32
2400988e:	d153      	bne.n	24009938 <HAL_I2C_Master_Receive_IT+0xc8>
  {
    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
24009890:	68fb      	ldr	r3, [r7, #12]
24009892:	681b      	ldr	r3, [r3, #0]
24009894:	699b      	ldr	r3, [r3, #24]
24009896:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
2400989a:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
2400989e:	d101      	bne.n	240098a4 <HAL_I2C_Master_Receive_IT+0x34>
    {
      return HAL_BUSY;
240098a0:	2302      	movs	r3, #2
240098a2:	e04a      	b.n	2400993a <HAL_I2C_Master_Receive_IT+0xca>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
240098a4:	68fb      	ldr	r3, [r7, #12]
240098a6:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
240098aa:	2b01      	cmp	r3, #1
240098ac:	d101      	bne.n	240098b2 <HAL_I2C_Master_Receive_IT+0x42>
240098ae:	2302      	movs	r3, #2
240098b0:	e043      	b.n	2400993a <HAL_I2C_Master_Receive_IT+0xca>
240098b2:	68fb      	ldr	r3, [r7, #12]
240098b4:	2201      	movs	r2, #1
240098b6:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State       = HAL_I2C_STATE_BUSY_RX;
240098ba:	68fb      	ldr	r3, [r7, #12]
240098bc:	2222      	movs	r2, #34	; 0x22
240098be:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode        = HAL_I2C_MODE_MASTER;
240098c2:	68fb      	ldr	r3, [r7, #12]
240098c4:	2210      	movs	r2, #16
240098c6:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
240098ca:	68fb      	ldr	r3, [r7, #12]
240098cc:	2200      	movs	r2, #0
240098ce:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
240098d0:	68fb      	ldr	r3, [r7, #12]
240098d2:	687a      	ldr	r2, [r7, #4]
240098d4:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
240098d6:	68fb      	ldr	r3, [r7, #12]
240098d8:	893a      	ldrh	r2, [r7, #8]
240098da:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
240098dc:	68fb      	ldr	r3, [r7, #12]
240098de:	4a19      	ldr	r2, [pc, #100]	; (24009944 <HAL_I2C_Master_Receive_IT+0xd4>)
240098e0:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Master_ISR_IT;
240098e2:	68fb      	ldr	r3, [r7, #12]
240098e4:	4a18      	ldr	r2, [pc, #96]	; (24009948 <HAL_I2C_Master_Receive_IT+0xd8>)
240098e6:	635a      	str	r2, [r3, #52]	; 0x34

    if (hi2c->XferCount > MAX_NBYTE_SIZE)
240098e8:	68fb      	ldr	r3, [r7, #12]
240098ea:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
240098ec:	b29b      	uxth	r3, r3
240098ee:	2bff      	cmp	r3, #255	; 0xff
240098f0:	d906      	bls.n	24009900 <HAL_I2C_Master_Receive_IT+0x90>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
240098f2:	68fb      	ldr	r3, [r7, #12]
240098f4:	22ff      	movs	r2, #255	; 0xff
240098f6:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_RELOAD_MODE;
240098f8:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
240098fc:	617b      	str	r3, [r7, #20]
240098fe:	e007      	b.n	24009910 <HAL_I2C_Master_Receive_IT+0xa0>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
24009900:	68fb      	ldr	r3, [r7, #12]
24009902:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
24009904:	b29a      	uxth	r2, r3
24009906:	68fb      	ldr	r3, [r7, #12]
24009908:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_AUTOEND_MODE;
2400990a:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
2400990e:	617b      	str	r3, [r7, #20]
    }

    /* Send Slave Address */
    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE */
    I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, I2C_GENERATE_START_READ);
24009910:	68fb      	ldr	r3, [r7, #12]
24009912:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
24009914:	b2da      	uxtb	r2, r3
24009916:	8979      	ldrh	r1, [r7, #10]
24009918:	4b0c      	ldr	r3, [pc, #48]	; (2400994c <HAL_I2C_Master_Receive_IT+0xdc>)
2400991a:	9300      	str	r3, [sp, #0]
2400991c:	697b      	ldr	r3, [r7, #20]
2400991e:	68f8      	ldr	r0, [r7, #12]
24009920:	f004 fa0a 	bl	2400dd38 <I2C_TransferConfig>

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
24009924:	68fb      	ldr	r3, [r7, #12]
24009926:	2200      	movs	r2, #0
24009928:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
              process unlock */

    /* Enable ERR, TC, STOP, NACK, RXI interrupt */
    /* possible to enable all of these */
    /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
    I2C_Enable_IRQ(hi2c, I2C_XFER_RX_IT);
2400992c:	2102      	movs	r1, #2
2400992e:	68f8      	ldr	r0, [r7, #12]
24009930:	f004 fa30 	bl	2400dd94 <I2C_Enable_IRQ>

    return HAL_OK;
24009934:	2300      	movs	r3, #0
24009936:	e000      	b.n	2400993a <HAL_I2C_Master_Receive_IT+0xca>
  }
  else
  {
    return HAL_BUSY;
24009938:	2302      	movs	r3, #2
  }
}
2400993a:	4618      	mov	r0, r3
2400993c:	3718      	adds	r7, #24
2400993e:	46bd      	mov	sp, r7
24009940:	bd80      	pop	{r7, pc}
24009942:	bf00      	nop
24009944:	ffff0000 	.word	0xffff0000
24009948:	2400beaf 	.word	0x2400beaf
2400994c:	80002400 	.word	0x80002400

24009950 <HAL_I2C_Slave_Transmit_IT>:
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Slave_Transmit_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)
{
24009950:	b580      	push	{r7, lr}
24009952:	b084      	sub	sp, #16
24009954:	af00      	add	r7, sp, #0
24009956:	60f8      	str	r0, [r7, #12]
24009958:	60b9      	str	r1, [r7, #8]
2400995a:	4613      	mov	r3, r2
2400995c:	80fb      	strh	r3, [r7, #6]
  if (hi2c->State == HAL_I2C_STATE_READY)
2400995e:	68fb      	ldr	r3, [r7, #12]
24009960:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
24009964:	b2db      	uxtb	r3, r3
24009966:	2b20      	cmp	r3, #32
24009968:	d139      	bne.n	240099de <HAL_I2C_Slave_Transmit_IT+0x8e>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
2400996a:	68fb      	ldr	r3, [r7, #12]
2400996c:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
24009970:	2b01      	cmp	r3, #1
24009972:	d101      	bne.n	24009978 <HAL_I2C_Slave_Transmit_IT+0x28>
24009974:	2302      	movs	r3, #2
24009976:	e033      	b.n	240099e0 <HAL_I2C_Slave_Transmit_IT+0x90>
24009978:	68fb      	ldr	r3, [r7, #12]
2400997a:	2201      	movs	r2, #1
2400997c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State       = HAL_I2C_STATE_BUSY_TX;
24009980:	68fb      	ldr	r3, [r7, #12]
24009982:	2221      	movs	r2, #33	; 0x21
24009984:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode        = HAL_I2C_MODE_SLAVE;
24009988:	68fb      	ldr	r3, [r7, #12]
2400998a:	2220      	movs	r2, #32
2400998c:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
24009990:	68fb      	ldr	r3, [r7, #12]
24009992:	2200      	movs	r2, #0
24009994:	645a      	str	r2, [r3, #68]	; 0x44

    /* Enable Address Acknowledge */
    hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
24009996:	68fb      	ldr	r3, [r7, #12]
24009998:	681b      	ldr	r3, [r3, #0]
2400999a:	685a      	ldr	r2, [r3, #4]
2400999c:	68fb      	ldr	r3, [r7, #12]
2400999e:	681b      	ldr	r3, [r3, #0]
240099a0:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
240099a4:	605a      	str	r2, [r3, #4]

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
240099a6:	68fb      	ldr	r3, [r7, #12]
240099a8:	68ba      	ldr	r2, [r7, #8]
240099aa:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
240099ac:	68fb      	ldr	r3, [r7, #12]
240099ae:	88fa      	ldrh	r2, [r7, #6]
240099b0:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferSize    = hi2c->XferCount;
240099b2:	68fb      	ldr	r3, [r7, #12]
240099b4:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
240099b6:	b29a      	uxth	r2, r3
240099b8:	68fb      	ldr	r3, [r7, #12]
240099ba:	851a      	strh	r2, [r3, #40]	; 0x28
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
240099bc:	68fb      	ldr	r3, [r7, #12]
240099be:	4a0a      	ldr	r2, [pc, #40]	; (240099e8 <HAL_I2C_Slave_Transmit_IT+0x98>)
240099c0:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Slave_ISR_IT;
240099c2:	68fb      	ldr	r3, [r7, #12]
240099c4:	4a09      	ldr	r2, [pc, #36]	; (240099ec <HAL_I2C_Slave_Transmit_IT+0x9c>)
240099c6:	635a      	str	r2, [r3, #52]	; 0x34

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
240099c8:	68fb      	ldr	r3, [r7, #12]
240099ca:	2200      	movs	r2, #0
240099cc:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
              process unlock */

    /* Enable ERR, TC, STOP, NACK, TXI interrupt */
    /* possible to enable all of these */
    /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
    I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT | I2C_XFER_LISTEN_IT);
240099d0:	f248 0101 	movw	r1, #32769	; 0x8001
240099d4:	68f8      	ldr	r0, [r7, #12]
240099d6:	f004 f9dd 	bl	2400dd94 <I2C_Enable_IRQ>

    return HAL_OK;
240099da:	2300      	movs	r3, #0
240099dc:	e000      	b.n	240099e0 <HAL_I2C_Slave_Transmit_IT+0x90>
  }
  else
  {
    return HAL_BUSY;
240099de:	2302      	movs	r3, #2
  }
}
240099e0:	4618      	mov	r0, r3
240099e2:	3710      	adds	r7, #16
240099e4:	46bd      	mov	sp, r7
240099e6:	bd80      	pop	{r7, pc}
240099e8:	ffff0000 	.word	0xffff0000
240099ec:	2400c101 	.word	0x2400c101

240099f0 <HAL_I2C_Slave_Receive_IT>:
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Slave_Receive_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)
{
240099f0:	b580      	push	{r7, lr}
240099f2:	b084      	sub	sp, #16
240099f4:	af00      	add	r7, sp, #0
240099f6:	60f8      	str	r0, [r7, #12]
240099f8:	60b9      	str	r1, [r7, #8]
240099fa:	4613      	mov	r3, r2
240099fc:	80fb      	strh	r3, [r7, #6]
  if (hi2c->State == HAL_I2C_STATE_READY)
240099fe:	68fb      	ldr	r3, [r7, #12]
24009a00:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
24009a04:	b2db      	uxtb	r3, r3
24009a06:	2b20      	cmp	r3, #32
24009a08:	d139      	bne.n	24009a7e <HAL_I2C_Slave_Receive_IT+0x8e>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
24009a0a:	68fb      	ldr	r3, [r7, #12]
24009a0c:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
24009a10:	2b01      	cmp	r3, #1
24009a12:	d101      	bne.n	24009a18 <HAL_I2C_Slave_Receive_IT+0x28>
24009a14:	2302      	movs	r3, #2
24009a16:	e033      	b.n	24009a80 <HAL_I2C_Slave_Receive_IT+0x90>
24009a18:	68fb      	ldr	r3, [r7, #12]
24009a1a:	2201      	movs	r2, #1
24009a1c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State       = HAL_I2C_STATE_BUSY_RX;
24009a20:	68fb      	ldr	r3, [r7, #12]
24009a22:	2222      	movs	r2, #34	; 0x22
24009a24:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode        = HAL_I2C_MODE_SLAVE;
24009a28:	68fb      	ldr	r3, [r7, #12]
24009a2a:	2220      	movs	r2, #32
24009a2c:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
24009a30:	68fb      	ldr	r3, [r7, #12]
24009a32:	2200      	movs	r2, #0
24009a34:	645a      	str	r2, [r3, #68]	; 0x44

    /* Enable Address Acknowledge */
    hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
24009a36:	68fb      	ldr	r3, [r7, #12]
24009a38:	681b      	ldr	r3, [r3, #0]
24009a3a:	685a      	ldr	r2, [r3, #4]
24009a3c:	68fb      	ldr	r3, [r7, #12]
24009a3e:	681b      	ldr	r3, [r3, #0]
24009a40:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
24009a44:	605a      	str	r2, [r3, #4]

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
24009a46:	68fb      	ldr	r3, [r7, #12]
24009a48:	68ba      	ldr	r2, [r7, #8]
24009a4a:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
24009a4c:	68fb      	ldr	r3, [r7, #12]
24009a4e:	88fa      	ldrh	r2, [r7, #6]
24009a50:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferSize    = hi2c->XferCount;
24009a52:	68fb      	ldr	r3, [r7, #12]
24009a54:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
24009a56:	b29a      	uxth	r2, r3
24009a58:	68fb      	ldr	r3, [r7, #12]
24009a5a:	851a      	strh	r2, [r3, #40]	; 0x28
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
24009a5c:	68fb      	ldr	r3, [r7, #12]
24009a5e:	4a0a      	ldr	r2, [pc, #40]	; (24009a88 <HAL_I2C_Slave_Receive_IT+0x98>)
24009a60:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Slave_ISR_IT;
24009a62:	68fb      	ldr	r3, [r7, #12]
24009a64:	4a09      	ldr	r2, [pc, #36]	; (24009a8c <HAL_I2C_Slave_Receive_IT+0x9c>)
24009a66:	635a      	str	r2, [r3, #52]	; 0x34

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
24009a68:	68fb      	ldr	r3, [r7, #12]
24009a6a:	2200      	movs	r2, #0
24009a6c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
              process unlock */

    /* Enable ERR, TC, STOP, NACK, RXI interrupt */
    /* possible to enable all of these */
    /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
    I2C_Enable_IRQ(hi2c, I2C_XFER_RX_IT | I2C_XFER_LISTEN_IT);
24009a70:	f248 0102 	movw	r1, #32770	; 0x8002
24009a74:	68f8      	ldr	r0, [r7, #12]
24009a76:	f004 f98d 	bl	2400dd94 <I2C_Enable_IRQ>

    return HAL_OK;
24009a7a:	2300      	movs	r3, #0
24009a7c:	e000      	b.n	24009a80 <HAL_I2C_Slave_Receive_IT+0x90>
  }
  else
  {
    return HAL_BUSY;
24009a7e:	2302      	movs	r3, #2
  }
}
24009a80:	4618      	mov	r0, r3
24009a82:	3710      	adds	r7, #16
24009a84:	46bd      	mov	sp, r7
24009a86:	bd80      	pop	{r7, pc}
24009a88:	ffff0000 	.word	0xffff0000
24009a8c:	2400c101 	.word	0x2400c101

24009a90 <HAL_I2C_Master_Transmit_DMA>:
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Master_Transmit_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size)
{
24009a90:	b580      	push	{r7, lr}
24009a92:	b088      	sub	sp, #32
24009a94:	af02      	add	r7, sp, #8
24009a96:	60f8      	str	r0, [r7, #12]
24009a98:	607a      	str	r2, [r7, #4]
24009a9a:	461a      	mov	r2, r3
24009a9c:	460b      	mov	r3, r1
24009a9e:	817b      	strh	r3, [r7, #10]
24009aa0:	4613      	mov	r3, r2
24009aa2:	813b      	strh	r3, [r7, #8]
  uint32_t xfermode;
  HAL_StatusTypeDef dmaxferstatus;

  if (hi2c->State == HAL_I2C_STATE_READY)
24009aa4:	68fb      	ldr	r3, [r7, #12]
24009aa6:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
24009aaa:	b2db      	uxtb	r3, r3
24009aac:	2b20      	cmp	r3, #32
24009aae:	f040 80cd 	bne.w	24009c4c <HAL_I2C_Master_Transmit_DMA+0x1bc>
  {
    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
24009ab2:	68fb      	ldr	r3, [r7, #12]
24009ab4:	681b      	ldr	r3, [r3, #0]
24009ab6:	699b      	ldr	r3, [r3, #24]
24009ab8:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
24009abc:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
24009ac0:	d101      	bne.n	24009ac6 <HAL_I2C_Master_Transmit_DMA+0x36>
    {
      return HAL_BUSY;
24009ac2:	2302      	movs	r3, #2
24009ac4:	e0c3      	b.n	24009c4e <HAL_I2C_Master_Transmit_DMA+0x1be>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
24009ac6:	68fb      	ldr	r3, [r7, #12]
24009ac8:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
24009acc:	2b01      	cmp	r3, #1
24009ace:	d101      	bne.n	24009ad4 <HAL_I2C_Master_Transmit_DMA+0x44>
24009ad0:	2302      	movs	r3, #2
24009ad2:	e0bc      	b.n	24009c4e <HAL_I2C_Master_Transmit_DMA+0x1be>
24009ad4:	68fb      	ldr	r3, [r7, #12]
24009ad6:	2201      	movs	r2, #1
24009ad8:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State       = HAL_I2C_STATE_BUSY_TX;
24009adc:	68fb      	ldr	r3, [r7, #12]
24009ade:	2221      	movs	r2, #33	; 0x21
24009ae0:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode        = HAL_I2C_MODE_MASTER;
24009ae4:	68fb      	ldr	r3, [r7, #12]
24009ae6:	2210      	movs	r2, #16
24009ae8:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
24009aec:	68fb      	ldr	r3, [r7, #12]
24009aee:	2200      	movs	r2, #0
24009af0:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
24009af2:	68fb      	ldr	r3, [r7, #12]
24009af4:	687a      	ldr	r2, [r7, #4]
24009af6:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
24009af8:	68fb      	ldr	r3, [r7, #12]
24009afa:	893a      	ldrh	r2, [r7, #8]
24009afc:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
24009afe:	68fb      	ldr	r3, [r7, #12]
24009b00:	4a55      	ldr	r2, [pc, #340]	; (24009c58 <HAL_I2C_Master_Transmit_DMA+0x1c8>)
24009b02:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Master_ISR_DMA;
24009b04:	68fb      	ldr	r3, [r7, #12]
24009b06:	4a55      	ldr	r2, [pc, #340]	; (24009c5c <HAL_I2C_Master_Transmit_DMA+0x1cc>)
24009b08:	635a      	str	r2, [r3, #52]	; 0x34

    if (hi2c->XferCount > MAX_NBYTE_SIZE)
24009b0a:	68fb      	ldr	r3, [r7, #12]
24009b0c:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
24009b0e:	b29b      	uxth	r3, r3
24009b10:	2bff      	cmp	r3, #255	; 0xff
24009b12:	d906      	bls.n	24009b22 <HAL_I2C_Master_Transmit_DMA+0x92>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
24009b14:	68fb      	ldr	r3, [r7, #12]
24009b16:	22ff      	movs	r2, #255	; 0xff
24009b18:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_RELOAD_MODE;
24009b1a:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
24009b1e:	617b      	str	r3, [r7, #20]
24009b20:	e007      	b.n	24009b32 <HAL_I2C_Master_Transmit_DMA+0xa2>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
24009b22:	68fb      	ldr	r3, [r7, #12]
24009b24:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
24009b26:	b29a      	uxth	r2, r3
24009b28:	68fb      	ldr	r3, [r7, #12]
24009b2a:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_AUTOEND_MODE;
24009b2c:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
24009b30:	617b      	str	r3, [r7, #20]
    }

    if (hi2c->XferSize > 0U)
24009b32:	68fb      	ldr	r3, [r7, #12]
24009b34:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
24009b36:	2b00      	cmp	r3, #0
24009b38:	d070      	beq.n	24009c1c <HAL_I2C_Master_Transmit_DMA+0x18c>
    {
      if (hi2c->hdmatx != NULL)
24009b3a:	68fb      	ldr	r3, [r7, #12]
24009b3c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
24009b3e:	2b00      	cmp	r3, #0
24009b40:	d020      	beq.n	24009b84 <HAL_I2C_Master_Transmit_DMA+0xf4>
      {
        /* Set the I2C DMA transfer complete callback */
        hi2c->hdmatx->XferCpltCallback = I2C_DMAMasterTransmitCplt;
24009b42:	68fb      	ldr	r3, [r7, #12]
24009b44:	6b9b      	ldr	r3, [r3, #56]	; 0x38
24009b46:	4a46      	ldr	r2, [pc, #280]	; (24009c60 <HAL_I2C_Master_Transmit_DMA+0x1d0>)
24009b48:	63da      	str	r2, [r3, #60]	; 0x3c

        /* Set the DMA error callback */
        hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
24009b4a:	68fb      	ldr	r3, [r7, #12]
24009b4c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
24009b4e:	4a45      	ldr	r2, [pc, #276]	; (24009c64 <HAL_I2C_Master_Transmit_DMA+0x1d4>)
24009b50:	64da      	str	r2, [r3, #76]	; 0x4c

        /* Set the unused DMA callbacks to NULL */
        hi2c->hdmatx->XferHalfCpltCallback = NULL;
24009b52:	68fb      	ldr	r3, [r7, #12]
24009b54:	6b9b      	ldr	r3, [r3, #56]	; 0x38
24009b56:	2200      	movs	r2, #0
24009b58:	641a      	str	r2, [r3, #64]	; 0x40
        hi2c->hdmatx->XferAbortCallback = NULL;
24009b5a:	68fb      	ldr	r3, [r7, #12]
24009b5c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
24009b5e:	2200      	movs	r2, #0
24009b60:	651a      	str	r2, [r3, #80]	; 0x50

        /* Enable the DMA stream or channel depends on Instance */
        dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->TXDR, hi2c->XferSize);
24009b62:	68fb      	ldr	r3, [r7, #12]
24009b64:	6b98      	ldr	r0, [r3, #56]	; 0x38
24009b66:	6879      	ldr	r1, [r7, #4]
24009b68:	68fb      	ldr	r3, [r7, #12]
24009b6a:	681b      	ldr	r3, [r3, #0]
24009b6c:	3328      	adds	r3, #40	; 0x28
24009b6e:	461a      	mov	r2, r3
24009b70:	68fb      	ldr	r3, [r7, #12]
24009b72:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
24009b74:	f7f8 fcea 	bl	2400254c <HAL_DMA_Start_IT>
24009b78:	4603      	mov	r3, r0
24009b7a:	74fb      	strb	r3, [r7, #19]
        __HAL_UNLOCK(hi2c);

        return HAL_ERROR;
      }

      if (dmaxferstatus == HAL_OK)
24009b7c:	7cfb      	ldrb	r3, [r7, #19]
24009b7e:	2b00      	cmp	r3, #0
24009b80:	d138      	bne.n	24009bf4 <HAL_I2C_Master_Transmit_DMA+0x164>
24009b82:	e013      	b.n	24009bac <HAL_I2C_Master_Transmit_DMA+0x11c>
        hi2c->State     = HAL_I2C_STATE_READY;
24009b84:	68fb      	ldr	r3, [r7, #12]
24009b86:	2220      	movs	r2, #32
24009b88:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
        hi2c->Mode      = HAL_I2C_MODE_NONE;
24009b8c:	68fb      	ldr	r3, [r7, #12]
24009b8e:	2200      	movs	r2, #0
24009b90:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
        hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
24009b94:	68fb      	ldr	r3, [r7, #12]
24009b96:	6c5b      	ldr	r3, [r3, #68]	; 0x44
24009b98:	f043 0280 	orr.w	r2, r3, #128	; 0x80
24009b9c:	68fb      	ldr	r3, [r7, #12]
24009b9e:	645a      	str	r2, [r3, #68]	; 0x44
        __HAL_UNLOCK(hi2c);
24009ba0:	68fb      	ldr	r3, [r7, #12]
24009ba2:	2200      	movs	r2, #0
24009ba4:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
        return HAL_ERROR;
24009ba8:	2301      	movs	r3, #1
24009baa:	e050      	b.n	24009c4e <HAL_I2C_Master_Transmit_DMA+0x1be>
      {
        /* Send Slave Address */
        /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
        I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, I2C_GENERATE_START_WRITE);
24009bac:	68fb      	ldr	r3, [r7, #12]
24009bae:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
24009bb0:	b2da      	uxtb	r2, r3
24009bb2:	8979      	ldrh	r1, [r7, #10]
24009bb4:	4b2c      	ldr	r3, [pc, #176]	; (24009c68 <HAL_I2C_Master_Transmit_DMA+0x1d8>)
24009bb6:	9300      	str	r3, [sp, #0]
24009bb8:	697b      	ldr	r3, [r7, #20]
24009bba:	68f8      	ldr	r0, [r7, #12]
24009bbc:	f004 f8bc 	bl	2400dd38 <I2C_TransferConfig>

        /* Update XferCount value */
        hi2c->XferCount -= hi2c->XferSize;
24009bc0:	68fb      	ldr	r3, [r7, #12]
24009bc2:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
24009bc4:	b29a      	uxth	r2, r3
24009bc6:	68fb      	ldr	r3, [r7, #12]
24009bc8:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
24009bca:	1ad3      	subs	r3, r2, r3
24009bcc:	b29a      	uxth	r2, r3
24009bce:	68fb      	ldr	r3, [r7, #12]
24009bd0:	855a      	strh	r2, [r3, #42]	; 0x2a

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
24009bd2:	68fb      	ldr	r3, [r7, #12]
24009bd4:	2200      	movs	r2, #0
24009bd6:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

        /* Note : The I2C interrupts must be enabled after unlocking current process
                  to avoid the risk of I2C interrupt handle execution before current
                  process unlock */
        /* Enable ERR and NACK interrupts */
        I2C_Enable_IRQ(hi2c, I2C_XFER_ERROR_IT);
24009bda:	2110      	movs	r1, #16
24009bdc:	68f8      	ldr	r0, [r7, #12]
24009bde:	f004 f8d9 	bl	2400dd94 <I2C_Enable_IRQ>

        /* Enable DMA Request */
        hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN;
24009be2:	68fb      	ldr	r3, [r7, #12]
24009be4:	681b      	ldr	r3, [r3, #0]
24009be6:	681a      	ldr	r2, [r3, #0]
24009be8:	68fb      	ldr	r3, [r7, #12]
24009bea:	681b      	ldr	r3, [r3, #0]
24009bec:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
24009bf0:	601a      	str	r2, [r3, #0]
24009bf2:	e029      	b.n	24009c48 <HAL_I2C_Master_Transmit_DMA+0x1b8>
      }
      else
      {
        /* Update I2C state */
        hi2c->State     = HAL_I2C_STATE_READY;
24009bf4:	68fb      	ldr	r3, [r7, #12]
24009bf6:	2220      	movs	r2, #32
24009bf8:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
        hi2c->Mode      = HAL_I2C_MODE_NONE;
24009bfc:	68fb      	ldr	r3, [r7, #12]
24009bfe:	2200      	movs	r2, #0
24009c00:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

        /* Update I2C error code */
        hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
24009c04:	68fb      	ldr	r3, [r7, #12]
24009c06:	6c5b      	ldr	r3, [r3, #68]	; 0x44
24009c08:	f043 0210 	orr.w	r2, r3, #16
24009c0c:	68fb      	ldr	r3, [r7, #12]
24009c0e:	645a      	str	r2, [r3, #68]	; 0x44

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
24009c10:	68fb      	ldr	r3, [r7, #12]
24009c12:	2200      	movs	r2, #0
24009c14:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

        return HAL_ERROR;
24009c18:	2301      	movs	r3, #1
24009c1a:	e018      	b.n	24009c4e <HAL_I2C_Master_Transmit_DMA+0x1be>
      }
    }
    else
    {
      /* Update Transfer ISR function pointer */
      hi2c->XferISR = I2C_Master_ISR_IT;
24009c1c:	68fb      	ldr	r3, [r7, #12]
24009c1e:	4a13      	ldr	r2, [pc, #76]	; (24009c6c <HAL_I2C_Master_Transmit_DMA+0x1dc>)
24009c20:	635a      	str	r2, [r3, #52]	; 0x34

      /* Send Slave Address */
      /* Set NBYTES to write and generate START condition */
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_WRITE);
24009c22:	68fb      	ldr	r3, [r7, #12]
24009c24:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
24009c26:	b2da      	uxtb	r2, r3
24009c28:	8979      	ldrh	r1, [r7, #10]
24009c2a:	4b0f      	ldr	r3, [pc, #60]	; (24009c68 <HAL_I2C_Master_Transmit_DMA+0x1d8>)
24009c2c:	9300      	str	r3, [sp, #0]
24009c2e:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
24009c32:	68f8      	ldr	r0, [r7, #12]
24009c34:	f004 f880 	bl	2400dd38 <I2C_TransferConfig>

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
24009c38:	68fb      	ldr	r3, [r7, #12]
24009c3a:	2200      	movs	r2, #0
24009c3c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
                to avoid the risk of I2C interrupt handle execution before current
                process unlock */
      /* Enable ERR, TC, STOP, NACK, TXI interrupt */
      /* possible to enable all of these */
      /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
      I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT);
24009c40:	2101      	movs	r1, #1
24009c42:	68f8      	ldr	r0, [r7, #12]
24009c44:	f004 f8a6 	bl	2400dd94 <I2C_Enable_IRQ>
    }

    return HAL_OK;
24009c48:	2300      	movs	r3, #0
24009c4a:	e000      	b.n	24009c4e <HAL_I2C_Master_Transmit_DMA+0x1be>
  }
  else
  {
    return HAL_BUSY;
24009c4c:	2302      	movs	r3, #2
  }
}
24009c4e:	4618      	mov	r0, r3
24009c50:	3718      	adds	r7, #24
24009c52:	46bd      	mov	sp, r7
24009c54:	bd80      	pop	{r7, pc}
24009c56:	bf00      	nop
24009c58:	ffff0000 	.word	0xffff0000
24009c5c:	2400c307 	.word	0x2400c307
24009c60:	2400d49f 	.word	0x2400d49f
24009c64:	2400d771 	.word	0x2400d771
24009c68:	80002000 	.word	0x80002000
24009c6c:	2400beaf 	.word	0x2400beaf

24009c70 <HAL_I2C_Master_Receive_DMA>:
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Master_Receive_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size)
{
24009c70:	b580      	push	{r7, lr}
24009c72:	b088      	sub	sp, #32
24009c74:	af02      	add	r7, sp, #8
24009c76:	60f8      	str	r0, [r7, #12]
24009c78:	607a      	str	r2, [r7, #4]
24009c7a:	461a      	mov	r2, r3
24009c7c:	460b      	mov	r3, r1
24009c7e:	817b      	strh	r3, [r7, #10]
24009c80:	4613      	mov	r3, r2
24009c82:	813b      	strh	r3, [r7, #8]
  uint32_t xfermode;
  HAL_StatusTypeDef dmaxferstatus;

  if (hi2c->State == HAL_I2C_STATE_READY)
24009c84:	68fb      	ldr	r3, [r7, #12]
24009c86:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
24009c8a:	b2db      	uxtb	r3, r3
24009c8c:	2b20      	cmp	r3, #32
24009c8e:	f040 80cd 	bne.w	24009e2c <HAL_I2C_Master_Receive_DMA+0x1bc>
  {
    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
24009c92:	68fb      	ldr	r3, [r7, #12]
24009c94:	681b      	ldr	r3, [r3, #0]
24009c96:	699b      	ldr	r3, [r3, #24]
24009c98:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
24009c9c:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
24009ca0:	d101      	bne.n	24009ca6 <HAL_I2C_Master_Receive_DMA+0x36>
    {
      return HAL_BUSY;
24009ca2:	2302      	movs	r3, #2
24009ca4:	e0c3      	b.n	24009e2e <HAL_I2C_Master_Receive_DMA+0x1be>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
24009ca6:	68fb      	ldr	r3, [r7, #12]
24009ca8:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
24009cac:	2b01      	cmp	r3, #1
24009cae:	d101      	bne.n	24009cb4 <HAL_I2C_Master_Receive_DMA+0x44>
24009cb0:	2302      	movs	r3, #2
24009cb2:	e0bc      	b.n	24009e2e <HAL_I2C_Master_Receive_DMA+0x1be>
24009cb4:	68fb      	ldr	r3, [r7, #12]
24009cb6:	2201      	movs	r2, #1
24009cb8:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State       = HAL_I2C_STATE_BUSY_RX;
24009cbc:	68fb      	ldr	r3, [r7, #12]
24009cbe:	2222      	movs	r2, #34	; 0x22
24009cc0:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode        = HAL_I2C_MODE_MASTER;
24009cc4:	68fb      	ldr	r3, [r7, #12]
24009cc6:	2210      	movs	r2, #16
24009cc8:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
24009ccc:	68fb      	ldr	r3, [r7, #12]
24009cce:	2200      	movs	r2, #0
24009cd0:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
24009cd2:	68fb      	ldr	r3, [r7, #12]
24009cd4:	687a      	ldr	r2, [r7, #4]
24009cd6:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
24009cd8:	68fb      	ldr	r3, [r7, #12]
24009cda:	893a      	ldrh	r2, [r7, #8]
24009cdc:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
24009cde:	68fb      	ldr	r3, [r7, #12]
24009ce0:	4a55      	ldr	r2, [pc, #340]	; (24009e38 <HAL_I2C_Master_Receive_DMA+0x1c8>)
24009ce2:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Master_ISR_DMA;
24009ce4:	68fb      	ldr	r3, [r7, #12]
24009ce6:	4a55      	ldr	r2, [pc, #340]	; (24009e3c <HAL_I2C_Master_Receive_DMA+0x1cc>)
24009ce8:	635a      	str	r2, [r3, #52]	; 0x34

    if (hi2c->XferCount > MAX_NBYTE_SIZE)
24009cea:	68fb      	ldr	r3, [r7, #12]
24009cec:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
24009cee:	b29b      	uxth	r3, r3
24009cf0:	2bff      	cmp	r3, #255	; 0xff
24009cf2:	d906      	bls.n	24009d02 <HAL_I2C_Master_Receive_DMA+0x92>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
24009cf4:	68fb      	ldr	r3, [r7, #12]
24009cf6:	22ff      	movs	r2, #255	; 0xff
24009cf8:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_RELOAD_MODE;
24009cfa:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
24009cfe:	617b      	str	r3, [r7, #20]
24009d00:	e007      	b.n	24009d12 <HAL_I2C_Master_Receive_DMA+0xa2>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
24009d02:	68fb      	ldr	r3, [r7, #12]
24009d04:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
24009d06:	b29a      	uxth	r2, r3
24009d08:	68fb      	ldr	r3, [r7, #12]
24009d0a:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_AUTOEND_MODE;
24009d0c:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
24009d10:	617b      	str	r3, [r7, #20]
    }

    if (hi2c->XferSize > 0U)
24009d12:	68fb      	ldr	r3, [r7, #12]
24009d14:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
24009d16:	2b00      	cmp	r3, #0
24009d18:	d070      	beq.n	24009dfc <HAL_I2C_Master_Receive_DMA+0x18c>
    {
      if (hi2c->hdmarx != NULL)
24009d1a:	68fb      	ldr	r3, [r7, #12]
24009d1c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24009d1e:	2b00      	cmp	r3, #0
24009d20:	d020      	beq.n	24009d64 <HAL_I2C_Master_Receive_DMA+0xf4>
      {
        /* Set the I2C DMA transfer complete callback */
        hi2c->hdmarx->XferCpltCallback = I2C_DMAMasterReceiveCplt;
24009d22:	68fb      	ldr	r3, [r7, #12]
24009d24:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24009d26:	4a46      	ldr	r2, [pc, #280]	; (24009e40 <HAL_I2C_Master_Receive_DMA+0x1d0>)
24009d28:	63da      	str	r2, [r3, #60]	; 0x3c

        /* Set the DMA error callback */
        hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
24009d2a:	68fb      	ldr	r3, [r7, #12]
24009d2c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24009d2e:	4a45      	ldr	r2, [pc, #276]	; (24009e44 <HAL_I2C_Master_Receive_DMA+0x1d4>)
24009d30:	64da      	str	r2, [r3, #76]	; 0x4c

        /* Set the unused DMA callbacks to NULL */
        hi2c->hdmarx->XferHalfCpltCallback = NULL;
24009d32:	68fb      	ldr	r3, [r7, #12]
24009d34:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24009d36:	2200      	movs	r2, #0
24009d38:	641a      	str	r2, [r3, #64]	; 0x40
        hi2c->hdmarx->XferAbortCallback = NULL;
24009d3a:	68fb      	ldr	r3, [r7, #12]
24009d3c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24009d3e:	2200      	movs	r2, #0
24009d40:	651a      	str	r2, [r3, #80]	; 0x50

        /* Enable the DMA stream or channel depends on Instance */
        dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)pData, hi2c->XferSize);
24009d42:	68fb      	ldr	r3, [r7, #12]
24009d44:	6bd8      	ldr	r0, [r3, #60]	; 0x3c
24009d46:	68fb      	ldr	r3, [r7, #12]
24009d48:	681b      	ldr	r3, [r3, #0]
24009d4a:	3324      	adds	r3, #36	; 0x24
24009d4c:	4619      	mov	r1, r3
24009d4e:	687a      	ldr	r2, [r7, #4]
24009d50:	68fb      	ldr	r3, [r7, #12]
24009d52:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
24009d54:	f7f8 fbfa 	bl	2400254c <HAL_DMA_Start_IT>
24009d58:	4603      	mov	r3, r0
24009d5a:	74fb      	strb	r3, [r7, #19]
        __HAL_UNLOCK(hi2c);

        return HAL_ERROR;
      }

      if (dmaxferstatus == HAL_OK)
24009d5c:	7cfb      	ldrb	r3, [r7, #19]
24009d5e:	2b00      	cmp	r3, #0
24009d60:	d138      	bne.n	24009dd4 <HAL_I2C_Master_Receive_DMA+0x164>
24009d62:	e013      	b.n	24009d8c <HAL_I2C_Master_Receive_DMA+0x11c>
        hi2c->State     = HAL_I2C_STATE_READY;
24009d64:	68fb      	ldr	r3, [r7, #12]
24009d66:	2220      	movs	r2, #32
24009d68:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
        hi2c->Mode      = HAL_I2C_MODE_NONE;
24009d6c:	68fb      	ldr	r3, [r7, #12]
24009d6e:	2200      	movs	r2, #0
24009d70:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
        hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
24009d74:	68fb      	ldr	r3, [r7, #12]
24009d76:	6c5b      	ldr	r3, [r3, #68]	; 0x44
24009d78:	f043 0280 	orr.w	r2, r3, #128	; 0x80
24009d7c:	68fb      	ldr	r3, [r7, #12]
24009d7e:	645a      	str	r2, [r3, #68]	; 0x44
        __HAL_UNLOCK(hi2c);
24009d80:	68fb      	ldr	r3, [r7, #12]
24009d82:	2200      	movs	r2, #0
24009d84:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
        return HAL_ERROR;
24009d88:	2301      	movs	r3, #1
24009d8a:	e050      	b.n	24009e2e <HAL_I2C_Master_Receive_DMA+0x1be>
      {
        /* Send Slave Address */
        /* Set NBYTES to read and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
        I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, I2C_GENERATE_START_READ);
24009d8c:	68fb      	ldr	r3, [r7, #12]
24009d8e:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
24009d90:	b2da      	uxtb	r2, r3
24009d92:	8979      	ldrh	r1, [r7, #10]
24009d94:	4b2c      	ldr	r3, [pc, #176]	; (24009e48 <HAL_I2C_Master_Receive_DMA+0x1d8>)
24009d96:	9300      	str	r3, [sp, #0]
24009d98:	697b      	ldr	r3, [r7, #20]
24009d9a:	68f8      	ldr	r0, [r7, #12]
24009d9c:	f003 ffcc 	bl	2400dd38 <I2C_TransferConfig>

        /* Update XferCount value */
        hi2c->XferCount -= hi2c->XferSize;
24009da0:	68fb      	ldr	r3, [r7, #12]
24009da2:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
24009da4:	b29a      	uxth	r2, r3
24009da6:	68fb      	ldr	r3, [r7, #12]
24009da8:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
24009daa:	1ad3      	subs	r3, r2, r3
24009dac:	b29a      	uxth	r2, r3
24009dae:	68fb      	ldr	r3, [r7, #12]
24009db0:	855a      	strh	r2, [r3, #42]	; 0x2a

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
24009db2:	68fb      	ldr	r3, [r7, #12]
24009db4:	2200      	movs	r2, #0
24009db6:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

        /* Note : The I2C interrupts must be enabled after unlocking current process
                  to avoid the risk of I2C interrupt handle execution before current
                  process unlock */
        /* Enable ERR and NACK interrupts */
        I2C_Enable_IRQ(hi2c, I2C_XFER_ERROR_IT);
24009dba:	2110      	movs	r1, #16
24009dbc:	68f8      	ldr	r0, [r7, #12]
24009dbe:	f003 ffe9 	bl	2400dd94 <I2C_Enable_IRQ>

        /* Enable DMA Request */
        hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;
24009dc2:	68fb      	ldr	r3, [r7, #12]
24009dc4:	681b      	ldr	r3, [r3, #0]
24009dc6:	681a      	ldr	r2, [r3, #0]
24009dc8:	68fb      	ldr	r3, [r7, #12]
24009dca:	681b      	ldr	r3, [r3, #0]
24009dcc:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
24009dd0:	601a      	str	r2, [r3, #0]
24009dd2:	e029      	b.n	24009e28 <HAL_I2C_Master_Receive_DMA+0x1b8>
      }
      else
      {
        /* Update I2C state */
        hi2c->State     = HAL_I2C_STATE_READY;
24009dd4:	68fb      	ldr	r3, [r7, #12]
24009dd6:	2220      	movs	r2, #32
24009dd8:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
        hi2c->Mode      = HAL_I2C_MODE_NONE;
24009ddc:	68fb      	ldr	r3, [r7, #12]
24009dde:	2200      	movs	r2, #0
24009de0:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

        /* Update I2C error code */
        hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
24009de4:	68fb      	ldr	r3, [r7, #12]
24009de6:	6c5b      	ldr	r3, [r3, #68]	; 0x44
24009de8:	f043 0210 	orr.w	r2, r3, #16
24009dec:	68fb      	ldr	r3, [r7, #12]
24009dee:	645a      	str	r2, [r3, #68]	; 0x44

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
24009df0:	68fb      	ldr	r3, [r7, #12]
24009df2:	2200      	movs	r2, #0
24009df4:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

        return HAL_ERROR;
24009df8:	2301      	movs	r3, #1
24009dfa:	e018      	b.n	24009e2e <HAL_I2C_Master_Receive_DMA+0x1be>
      }
    }
    else
    {
      /* Update Transfer ISR function pointer */
      hi2c->XferISR = I2C_Master_ISR_IT;
24009dfc:	68fb      	ldr	r3, [r7, #12]
24009dfe:	4a13      	ldr	r2, [pc, #76]	; (24009e4c <HAL_I2C_Master_Receive_DMA+0x1dc>)
24009e00:	635a      	str	r2, [r3, #52]	; 0x34

      /* Send Slave Address */
      /* Set NBYTES to read and generate START condition */
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_READ);
24009e02:	68fb      	ldr	r3, [r7, #12]
24009e04:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
24009e06:	b2da      	uxtb	r2, r3
24009e08:	8979      	ldrh	r1, [r7, #10]
24009e0a:	4b0f      	ldr	r3, [pc, #60]	; (24009e48 <HAL_I2C_Master_Receive_DMA+0x1d8>)
24009e0c:	9300      	str	r3, [sp, #0]
24009e0e:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
24009e12:	68f8      	ldr	r0, [r7, #12]
24009e14:	f003 ff90 	bl	2400dd38 <I2C_TransferConfig>

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
24009e18:	68fb      	ldr	r3, [r7, #12]
24009e1a:	2200      	movs	r2, #0
24009e1c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
                to avoid the risk of I2C interrupt handle execution before current
                process unlock */
      /* Enable ERR, TC, STOP, NACK, TXI interrupt */
      /* possible to enable all of these */
      /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
      I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT);
24009e20:	2101      	movs	r1, #1
24009e22:	68f8      	ldr	r0, [r7, #12]
24009e24:	f003 ffb6 	bl	2400dd94 <I2C_Enable_IRQ>
    }

    return HAL_OK;
24009e28:	2300      	movs	r3, #0
24009e2a:	e000      	b.n	24009e2e <HAL_I2C_Master_Receive_DMA+0x1be>
  }
  else
  {
    return HAL_BUSY;
24009e2c:	2302      	movs	r3, #2
  }
}
24009e2e:	4618      	mov	r0, r3
24009e30:	3718      	adds	r7, #24
24009e32:	46bd      	mov	sp, r7
24009e34:	bd80      	pop	{r7, pc}
24009e36:	bf00      	nop
24009e38:	ffff0000 	.word	0xffff0000
24009e3c:	2400c307 	.word	0x2400c307
24009e40:	2400d575 	.word	0x2400d575
24009e44:	2400d771 	.word	0x2400d771
24009e48:	80002400 	.word	0x80002400
24009e4c:	2400beaf 	.word	0x2400beaf

24009e50 <HAL_I2C_Slave_Transmit_DMA>:
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Slave_Transmit_DMA(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)
{
24009e50:	b580      	push	{r7, lr}
24009e52:	b086      	sub	sp, #24
24009e54:	af00      	add	r7, sp, #0
24009e56:	60f8      	str	r0, [r7, #12]
24009e58:	60b9      	str	r1, [r7, #8]
24009e5a:	4613      	mov	r3, r2
24009e5c:	80fb      	strh	r3, [r7, #6]
  HAL_StatusTypeDef dmaxferstatus;

  if (hi2c->State == HAL_I2C_STATE_READY)
24009e5e:	68fb      	ldr	r3, [r7, #12]
24009e60:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
24009e64:	b2db      	uxtb	r3, r3
24009e66:	2b20      	cmp	r3, #32
24009e68:	f040 809b 	bne.w	24009fa2 <HAL_I2C_Slave_Transmit_DMA+0x152>
  {
    if ((pData == NULL) || (Size == 0U))
24009e6c:	68bb      	ldr	r3, [r7, #8]
24009e6e:	2b00      	cmp	r3, #0
24009e70:	d002      	beq.n	24009e78 <HAL_I2C_Slave_Transmit_DMA+0x28>
24009e72:	88fb      	ldrh	r3, [r7, #6]
24009e74:	2b00      	cmp	r3, #0
24009e76:	d105      	bne.n	24009e84 <HAL_I2C_Slave_Transmit_DMA+0x34>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
24009e78:	68fb      	ldr	r3, [r7, #12]
24009e7a:	f44f 7200 	mov.w	r2, #512	; 0x200
24009e7e:	645a      	str	r2, [r3, #68]	; 0x44
      return  HAL_ERROR;
24009e80:	2301      	movs	r3, #1
24009e82:	e08f      	b.n	24009fa4 <HAL_I2C_Slave_Transmit_DMA+0x154>
    }
    /* Process Locked */
    __HAL_LOCK(hi2c);
24009e84:	68fb      	ldr	r3, [r7, #12]
24009e86:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
24009e8a:	2b01      	cmp	r3, #1
24009e8c:	d101      	bne.n	24009e92 <HAL_I2C_Slave_Transmit_DMA+0x42>
24009e8e:	2302      	movs	r3, #2
24009e90:	e088      	b.n	24009fa4 <HAL_I2C_Slave_Transmit_DMA+0x154>
24009e92:	68fb      	ldr	r3, [r7, #12]
24009e94:	2201      	movs	r2, #1
24009e96:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State       = HAL_I2C_STATE_BUSY_TX;
24009e9a:	68fb      	ldr	r3, [r7, #12]
24009e9c:	2221      	movs	r2, #33	; 0x21
24009e9e:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode        = HAL_I2C_MODE_SLAVE;
24009ea2:	68fb      	ldr	r3, [r7, #12]
24009ea4:	2220      	movs	r2, #32
24009ea6:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
24009eaa:	68fb      	ldr	r3, [r7, #12]
24009eac:	2200      	movs	r2, #0
24009eae:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
24009eb0:	68fb      	ldr	r3, [r7, #12]
24009eb2:	68ba      	ldr	r2, [r7, #8]
24009eb4:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
24009eb6:	68fb      	ldr	r3, [r7, #12]
24009eb8:	88fa      	ldrh	r2, [r7, #6]
24009eba:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferSize    = hi2c->XferCount;
24009ebc:	68fb      	ldr	r3, [r7, #12]
24009ebe:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
24009ec0:	b29a      	uxth	r2, r3
24009ec2:	68fb      	ldr	r3, [r7, #12]
24009ec4:	851a      	strh	r2, [r3, #40]	; 0x28
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
24009ec6:	68fb      	ldr	r3, [r7, #12]
24009ec8:	4a38      	ldr	r2, [pc, #224]	; (24009fac <HAL_I2C_Slave_Transmit_DMA+0x15c>)
24009eca:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Slave_ISR_DMA;
24009ecc:	68fb      	ldr	r3, [r7, #12]
24009ece:	4a38      	ldr	r2, [pc, #224]	; (24009fb0 <HAL_I2C_Slave_Transmit_DMA+0x160>)
24009ed0:	635a      	str	r2, [r3, #52]	; 0x34

    if (hi2c->hdmatx != NULL)
24009ed2:	68fb      	ldr	r3, [r7, #12]
24009ed4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
24009ed6:	2b00      	cmp	r3, #0
24009ed8:	d020      	beq.n	24009f1c <HAL_I2C_Slave_Transmit_DMA+0xcc>
    {
      /* Set the I2C DMA transfer complete callback */
      hi2c->hdmatx->XferCpltCallback = I2C_DMASlaveTransmitCplt;
24009eda:	68fb      	ldr	r3, [r7, #12]
24009edc:	6b9b      	ldr	r3, [r3, #56]	; 0x38
24009ede:	4a35      	ldr	r2, [pc, #212]	; (24009fb4 <HAL_I2C_Slave_Transmit_DMA+0x164>)
24009ee0:	63da      	str	r2, [r3, #60]	; 0x3c

      /* Set the DMA error callback */
      hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
24009ee2:	68fb      	ldr	r3, [r7, #12]
24009ee4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
24009ee6:	4a34      	ldr	r2, [pc, #208]	; (24009fb8 <HAL_I2C_Slave_Transmit_DMA+0x168>)
24009ee8:	64da      	str	r2, [r3, #76]	; 0x4c

      /* Set the unused DMA callbacks to NULL */
      hi2c->hdmatx->XferHalfCpltCallback = NULL;
24009eea:	68fb      	ldr	r3, [r7, #12]
24009eec:	6b9b      	ldr	r3, [r3, #56]	; 0x38
24009eee:	2200      	movs	r2, #0
24009ef0:	641a      	str	r2, [r3, #64]	; 0x40
      hi2c->hdmatx->XferAbortCallback = NULL;
24009ef2:	68fb      	ldr	r3, [r7, #12]
24009ef4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
24009ef6:	2200      	movs	r2, #0
24009ef8:	651a      	str	r2, [r3, #80]	; 0x50

      /* Enable the DMA stream or channel depends on Instance */
      dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->TXDR, hi2c->XferSize);
24009efa:	68fb      	ldr	r3, [r7, #12]
24009efc:	6b98      	ldr	r0, [r3, #56]	; 0x38
24009efe:	68b9      	ldr	r1, [r7, #8]
24009f00:	68fb      	ldr	r3, [r7, #12]
24009f02:	681b      	ldr	r3, [r3, #0]
24009f04:	3328      	adds	r3, #40	; 0x28
24009f06:	461a      	mov	r2, r3
24009f08:	68fb      	ldr	r3, [r7, #12]
24009f0a:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
24009f0c:	f7f8 fb1e 	bl	2400254c <HAL_DMA_Start_IT>
24009f10:	4603      	mov	r3, r0
24009f12:	75fb      	strb	r3, [r7, #23]
      __HAL_UNLOCK(hi2c);

      return HAL_ERROR;
    }

    if (dmaxferstatus == HAL_OK)
24009f14:	7dfb      	ldrb	r3, [r7, #23]
24009f16:	2b00      	cmp	r3, #0
24009f18:	d12f      	bne.n	24009f7a <HAL_I2C_Slave_Transmit_DMA+0x12a>
24009f1a:	e013      	b.n	24009f44 <HAL_I2C_Slave_Transmit_DMA+0xf4>
      hi2c->State     = HAL_I2C_STATE_LISTEN;
24009f1c:	68fb      	ldr	r3, [r7, #12]
24009f1e:	2228      	movs	r2, #40	; 0x28
24009f20:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
      hi2c->Mode      = HAL_I2C_MODE_NONE;
24009f24:	68fb      	ldr	r3, [r7, #12]
24009f26:	2200      	movs	r2, #0
24009f28:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
      hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
24009f2c:	68fb      	ldr	r3, [r7, #12]
24009f2e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
24009f30:	f043 0280 	orr.w	r2, r3, #128	; 0x80
24009f34:	68fb      	ldr	r3, [r7, #12]
24009f36:	645a      	str	r2, [r3, #68]	; 0x44
      __HAL_UNLOCK(hi2c);
24009f38:	68fb      	ldr	r3, [r7, #12]
24009f3a:	2200      	movs	r2, #0
24009f3c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
24009f40:	2301      	movs	r3, #1
24009f42:	e02f      	b.n	24009fa4 <HAL_I2C_Slave_Transmit_DMA+0x154>
    {
      /* Enable Address Acknowledge */
      hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
24009f44:	68fb      	ldr	r3, [r7, #12]
24009f46:	681b      	ldr	r3, [r3, #0]
24009f48:	685a      	ldr	r2, [r3, #4]
24009f4a:	68fb      	ldr	r3, [r7, #12]
24009f4c:	681b      	ldr	r3, [r3, #0]
24009f4e:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
24009f52:	605a      	str	r2, [r3, #4]

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
24009f54:	68fb      	ldr	r3, [r7, #12]
24009f56:	2200      	movs	r2, #0
24009f58:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

      /* Note : The I2C interrupts must be enabled after unlocking current process
                to avoid the risk of I2C interrupt handle execution before current
                process unlock */
      /* Enable ERR, STOP, NACK, ADDR interrupts */
      I2C_Enable_IRQ(hi2c, I2C_XFER_LISTEN_IT);
24009f5c:	f44f 4100 	mov.w	r1, #32768	; 0x8000
24009f60:	68f8      	ldr	r0, [r7, #12]
24009f62:	f003 ff17 	bl	2400dd94 <I2C_Enable_IRQ>

      /* Enable DMA Request */
      hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN;
24009f66:	68fb      	ldr	r3, [r7, #12]
24009f68:	681b      	ldr	r3, [r3, #0]
24009f6a:	681a      	ldr	r2, [r3, #0]
24009f6c:	68fb      	ldr	r3, [r7, #12]
24009f6e:	681b      	ldr	r3, [r3, #0]
24009f70:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
24009f74:	601a      	str	r2, [r3, #0]
      __HAL_UNLOCK(hi2c);

      return HAL_ERROR;
    }

    return HAL_OK;
24009f76:	2300      	movs	r3, #0
24009f78:	e014      	b.n	24009fa4 <HAL_I2C_Slave_Transmit_DMA+0x154>
      hi2c->State     = HAL_I2C_STATE_LISTEN;
24009f7a:	68fb      	ldr	r3, [r7, #12]
24009f7c:	2228      	movs	r2, #40	; 0x28
24009f7e:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
      hi2c->Mode      = HAL_I2C_MODE_NONE;
24009f82:	68fb      	ldr	r3, [r7, #12]
24009f84:	2200      	movs	r2, #0
24009f86:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
      hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
24009f8a:	68fb      	ldr	r3, [r7, #12]
24009f8c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
24009f8e:	f043 0210 	orr.w	r2, r3, #16
24009f92:	68fb      	ldr	r3, [r7, #12]
24009f94:	645a      	str	r2, [r3, #68]	; 0x44
      __HAL_UNLOCK(hi2c);
24009f96:	68fb      	ldr	r3, [r7, #12]
24009f98:	2200      	movs	r2, #0
24009f9a:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
24009f9e:	2301      	movs	r3, #1
24009fa0:	e000      	b.n	24009fa4 <HAL_I2C_Slave_Transmit_DMA+0x154>
  }
  else
  {
    return HAL_BUSY;
24009fa2:	2302      	movs	r3, #2
  }
}
24009fa4:	4618      	mov	r0, r3
24009fa6:	3718      	adds	r7, #24
24009fa8:	46bd      	mov	sp, r7
24009faa:	bd80      	pop	{r7, pc}
24009fac:	ffff0000 	.word	0xffff0000
24009fb0:	2400c4ed 	.word	0x2400c4ed
24009fb4:	2400d535 	.word	0x2400d535
24009fb8:	2400d771 	.word	0x2400d771

24009fbc <HAL_I2C_Slave_Receive_DMA>:
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Slave_Receive_DMA(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)
{
24009fbc:	b580      	push	{r7, lr}
24009fbe:	b086      	sub	sp, #24
24009fc0:	af00      	add	r7, sp, #0
24009fc2:	60f8      	str	r0, [r7, #12]
24009fc4:	60b9      	str	r1, [r7, #8]
24009fc6:	4613      	mov	r3, r2
24009fc8:	80fb      	strh	r3, [r7, #6]
  HAL_StatusTypeDef dmaxferstatus;

  if (hi2c->State == HAL_I2C_STATE_READY)
24009fca:	68fb      	ldr	r3, [r7, #12]
24009fcc:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
24009fd0:	b2db      	uxtb	r3, r3
24009fd2:	2b20      	cmp	r3, #32
24009fd4:	f040 809b 	bne.w	2400a10e <HAL_I2C_Slave_Receive_DMA+0x152>
  {
    if ((pData == NULL) || (Size == 0U))
24009fd8:	68bb      	ldr	r3, [r7, #8]
24009fda:	2b00      	cmp	r3, #0
24009fdc:	d002      	beq.n	24009fe4 <HAL_I2C_Slave_Receive_DMA+0x28>
24009fde:	88fb      	ldrh	r3, [r7, #6]
24009fe0:	2b00      	cmp	r3, #0
24009fe2:	d105      	bne.n	24009ff0 <HAL_I2C_Slave_Receive_DMA+0x34>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
24009fe4:	68fb      	ldr	r3, [r7, #12]
24009fe6:	f44f 7200 	mov.w	r2, #512	; 0x200
24009fea:	645a      	str	r2, [r3, #68]	; 0x44
      return  HAL_ERROR;
24009fec:	2301      	movs	r3, #1
24009fee:	e08f      	b.n	2400a110 <HAL_I2C_Slave_Receive_DMA+0x154>
    }
    /* Process Locked */
    __HAL_LOCK(hi2c);
24009ff0:	68fb      	ldr	r3, [r7, #12]
24009ff2:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
24009ff6:	2b01      	cmp	r3, #1
24009ff8:	d101      	bne.n	24009ffe <HAL_I2C_Slave_Receive_DMA+0x42>
24009ffa:	2302      	movs	r3, #2
24009ffc:	e088      	b.n	2400a110 <HAL_I2C_Slave_Receive_DMA+0x154>
24009ffe:	68fb      	ldr	r3, [r7, #12]
2400a000:	2201      	movs	r2, #1
2400a002:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State       = HAL_I2C_STATE_BUSY_RX;
2400a006:	68fb      	ldr	r3, [r7, #12]
2400a008:	2222      	movs	r2, #34	; 0x22
2400a00a:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode        = HAL_I2C_MODE_SLAVE;
2400a00e:	68fb      	ldr	r3, [r7, #12]
2400a010:	2220      	movs	r2, #32
2400a012:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
2400a016:	68fb      	ldr	r3, [r7, #12]
2400a018:	2200      	movs	r2, #0
2400a01a:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
2400a01c:	68fb      	ldr	r3, [r7, #12]
2400a01e:	68ba      	ldr	r2, [r7, #8]
2400a020:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
2400a022:	68fb      	ldr	r3, [r7, #12]
2400a024:	88fa      	ldrh	r2, [r7, #6]
2400a026:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferSize    = hi2c->XferCount;
2400a028:	68fb      	ldr	r3, [r7, #12]
2400a02a:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400a02c:	b29a      	uxth	r2, r3
2400a02e:	68fb      	ldr	r3, [r7, #12]
2400a030:	851a      	strh	r2, [r3, #40]	; 0x28
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
2400a032:	68fb      	ldr	r3, [r7, #12]
2400a034:	4a38      	ldr	r2, [pc, #224]	; (2400a118 <HAL_I2C_Slave_Receive_DMA+0x15c>)
2400a036:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Slave_ISR_DMA;
2400a038:	68fb      	ldr	r3, [r7, #12]
2400a03a:	4a38      	ldr	r2, [pc, #224]	; (2400a11c <HAL_I2C_Slave_Receive_DMA+0x160>)
2400a03c:	635a      	str	r2, [r3, #52]	; 0x34

    if (hi2c->hdmarx != NULL)
2400a03e:	68fb      	ldr	r3, [r7, #12]
2400a040:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400a042:	2b00      	cmp	r3, #0
2400a044:	d020      	beq.n	2400a088 <HAL_I2C_Slave_Receive_DMA+0xcc>
    {
      /* Set the I2C DMA transfer complete callback */
      hi2c->hdmarx->XferCpltCallback = I2C_DMASlaveReceiveCplt;
2400a046:	68fb      	ldr	r3, [r7, #12]
2400a048:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400a04a:	4a35      	ldr	r2, [pc, #212]	; (2400a120 <HAL_I2C_Slave_Receive_DMA+0x164>)
2400a04c:	63da      	str	r2, [r3, #60]	; 0x3c

      /* Set the DMA error callback */
      hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
2400a04e:	68fb      	ldr	r3, [r7, #12]
2400a050:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400a052:	4a34      	ldr	r2, [pc, #208]	; (2400a124 <HAL_I2C_Slave_Receive_DMA+0x168>)
2400a054:	64da      	str	r2, [r3, #76]	; 0x4c

      /* Set the unused DMA callbacks to NULL */
      hi2c->hdmarx->XferHalfCpltCallback = NULL;
2400a056:	68fb      	ldr	r3, [r7, #12]
2400a058:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400a05a:	2200      	movs	r2, #0
2400a05c:	641a      	str	r2, [r3, #64]	; 0x40
      hi2c->hdmarx->XferAbortCallback = NULL;
2400a05e:	68fb      	ldr	r3, [r7, #12]
2400a060:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400a062:	2200      	movs	r2, #0
2400a064:	651a      	str	r2, [r3, #80]	; 0x50

      /* Enable the DMA stream or channel depends on Instance */
      dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)pData, hi2c->XferSize);
2400a066:	68fb      	ldr	r3, [r7, #12]
2400a068:	6bd8      	ldr	r0, [r3, #60]	; 0x3c
2400a06a:	68fb      	ldr	r3, [r7, #12]
2400a06c:	681b      	ldr	r3, [r3, #0]
2400a06e:	3324      	adds	r3, #36	; 0x24
2400a070:	4619      	mov	r1, r3
2400a072:	68ba      	ldr	r2, [r7, #8]
2400a074:	68fb      	ldr	r3, [r7, #12]
2400a076:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400a078:	f7f8 fa68 	bl	2400254c <HAL_DMA_Start_IT>
2400a07c:	4603      	mov	r3, r0
2400a07e:	75fb      	strb	r3, [r7, #23]
      __HAL_UNLOCK(hi2c);

      return HAL_ERROR;
    }

    if (dmaxferstatus == HAL_OK)
2400a080:	7dfb      	ldrb	r3, [r7, #23]
2400a082:	2b00      	cmp	r3, #0
2400a084:	d12f      	bne.n	2400a0e6 <HAL_I2C_Slave_Receive_DMA+0x12a>
2400a086:	e013      	b.n	2400a0b0 <HAL_I2C_Slave_Receive_DMA+0xf4>
      hi2c->State     = HAL_I2C_STATE_LISTEN;
2400a088:	68fb      	ldr	r3, [r7, #12]
2400a08a:	2228      	movs	r2, #40	; 0x28
2400a08c:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
      hi2c->Mode      = HAL_I2C_MODE_NONE;
2400a090:	68fb      	ldr	r3, [r7, #12]
2400a092:	2200      	movs	r2, #0
2400a094:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
      hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
2400a098:	68fb      	ldr	r3, [r7, #12]
2400a09a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400a09c:	f043 0280 	orr.w	r2, r3, #128	; 0x80
2400a0a0:	68fb      	ldr	r3, [r7, #12]
2400a0a2:	645a      	str	r2, [r3, #68]	; 0x44
      __HAL_UNLOCK(hi2c);
2400a0a4:	68fb      	ldr	r3, [r7, #12]
2400a0a6:	2200      	movs	r2, #0
2400a0a8:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
2400a0ac:	2301      	movs	r3, #1
2400a0ae:	e02f      	b.n	2400a110 <HAL_I2C_Slave_Receive_DMA+0x154>
    {
      /* Enable Address Acknowledge */
      hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
2400a0b0:	68fb      	ldr	r3, [r7, #12]
2400a0b2:	681b      	ldr	r3, [r3, #0]
2400a0b4:	685a      	ldr	r2, [r3, #4]
2400a0b6:	68fb      	ldr	r3, [r7, #12]
2400a0b8:	681b      	ldr	r3, [r3, #0]
2400a0ba:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
2400a0be:	605a      	str	r2, [r3, #4]

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
2400a0c0:	68fb      	ldr	r3, [r7, #12]
2400a0c2:	2200      	movs	r2, #0
2400a0c4:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

      /* Note : The I2C interrupts must be enabled after unlocking current process
                to avoid the risk of I2C interrupt handle execution before current
                process unlock */
      /* Enable ERR, STOP, NACK, ADDR interrupts */
      I2C_Enable_IRQ(hi2c, I2C_XFER_LISTEN_IT);
2400a0c8:	f44f 4100 	mov.w	r1, #32768	; 0x8000
2400a0cc:	68f8      	ldr	r0, [r7, #12]
2400a0ce:	f003 fe61 	bl	2400dd94 <I2C_Enable_IRQ>

      /* Enable DMA Request */
      hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;
2400a0d2:	68fb      	ldr	r3, [r7, #12]
2400a0d4:	681b      	ldr	r3, [r3, #0]
2400a0d6:	681a      	ldr	r2, [r3, #0]
2400a0d8:	68fb      	ldr	r3, [r7, #12]
2400a0da:	681b      	ldr	r3, [r3, #0]
2400a0dc:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
2400a0e0:	601a      	str	r2, [r3, #0]
      __HAL_UNLOCK(hi2c);

      return HAL_ERROR;
    }

    return HAL_OK;
2400a0e2:	2300      	movs	r3, #0
2400a0e4:	e014      	b.n	2400a110 <HAL_I2C_Slave_Receive_DMA+0x154>
      hi2c->State     = HAL_I2C_STATE_LISTEN;
2400a0e6:	68fb      	ldr	r3, [r7, #12]
2400a0e8:	2228      	movs	r2, #40	; 0x28
2400a0ea:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
      hi2c->Mode      = HAL_I2C_MODE_NONE;
2400a0ee:	68fb      	ldr	r3, [r7, #12]
2400a0f0:	2200      	movs	r2, #0
2400a0f2:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
      hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
2400a0f6:	68fb      	ldr	r3, [r7, #12]
2400a0f8:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400a0fa:	f043 0210 	orr.w	r2, r3, #16
2400a0fe:	68fb      	ldr	r3, [r7, #12]
2400a100:	645a      	str	r2, [r3, #68]	; 0x44
      __HAL_UNLOCK(hi2c);
2400a102:	68fb      	ldr	r3, [r7, #12]
2400a104:	2200      	movs	r2, #0
2400a106:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
2400a10a:	2301      	movs	r3, #1
2400a10c:	e000      	b.n	2400a110 <HAL_I2C_Slave_Receive_DMA+0x154>
  }
  else
  {
    return HAL_BUSY;
2400a10e:	2302      	movs	r3, #2
  }
}
2400a110:	4618      	mov	r0, r3
2400a112:	3718      	adds	r7, #24
2400a114:	46bd      	mov	sp, r7
2400a116:	bd80      	pop	{r7, pc}
2400a118:	ffff0000 	.word	0xffff0000
2400a11c:	2400c4ed 	.word	0x2400c4ed
2400a120:	2400d60d 	.word	0x2400d60d
2400a124:	2400d771 	.word	0x2400d771

2400a128 <HAL_I2C_Mem_Write>:
  * @param  Size Amount of data to be sent
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Mem_Write(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
2400a128:	b580      	push	{r7, lr}
2400a12a:	b088      	sub	sp, #32
2400a12c:	af02      	add	r7, sp, #8
2400a12e:	60f8      	str	r0, [r7, #12]
2400a130:	4608      	mov	r0, r1
2400a132:	4611      	mov	r1, r2
2400a134:	461a      	mov	r2, r3
2400a136:	4603      	mov	r3, r0
2400a138:	817b      	strh	r3, [r7, #10]
2400a13a:	460b      	mov	r3, r1
2400a13c:	813b      	strh	r3, [r7, #8]
2400a13e:	4613      	mov	r3, r2
2400a140:	80fb      	strh	r3, [r7, #6]
  uint32_t tickstart;

  /* Check the parameters */
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));

  if (hi2c->State == HAL_I2C_STATE_READY)
2400a142:	68fb      	ldr	r3, [r7, #12]
2400a144:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400a148:	b2db      	uxtb	r3, r3
2400a14a:	2b20      	cmp	r3, #32
2400a14c:	f040 80f9 	bne.w	2400a342 <HAL_I2C_Mem_Write+0x21a>
  {
    if ((pData == NULL) || (Size == 0U))
2400a150:	6a3b      	ldr	r3, [r7, #32]
2400a152:	2b00      	cmp	r3, #0
2400a154:	d002      	beq.n	2400a15c <HAL_I2C_Mem_Write+0x34>
2400a156:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
2400a158:	2b00      	cmp	r3, #0
2400a15a:	d105      	bne.n	2400a168 <HAL_I2C_Mem_Write+0x40>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
2400a15c:	68fb      	ldr	r3, [r7, #12]
2400a15e:	f44f 7200 	mov.w	r2, #512	; 0x200
2400a162:	645a      	str	r2, [r3, #68]	; 0x44
      return  HAL_ERROR;
2400a164:	2301      	movs	r3, #1
2400a166:	e0ed      	b.n	2400a344 <HAL_I2C_Mem_Write+0x21c>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
2400a168:	68fb      	ldr	r3, [r7, #12]
2400a16a:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400a16e:	2b01      	cmp	r3, #1
2400a170:	d101      	bne.n	2400a176 <HAL_I2C_Mem_Write+0x4e>
2400a172:	2302      	movs	r3, #2
2400a174:	e0e6      	b.n	2400a344 <HAL_I2C_Mem_Write+0x21c>
2400a176:	68fb      	ldr	r3, [r7, #12]
2400a178:	2201      	movs	r2, #1
2400a17a:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Init tickstart for timeout management*/
    tickstart = HAL_GetTick();
2400a17e:	f7f6 fb67 	bl	24000850 <HAL_GetTick>
2400a182:	6178      	str	r0, [r7, #20]

    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
2400a184:	697b      	ldr	r3, [r7, #20]
2400a186:	9300      	str	r3, [sp, #0]
2400a188:	2319      	movs	r3, #25
2400a18a:	2201      	movs	r2, #1
2400a18c:	f44f 4100 	mov.w	r1, #32768	; 0x8000
2400a190:	68f8      	ldr	r0, [r7, #12]
2400a192:	f003 fc43 	bl	2400da1c <I2C_WaitOnFlagUntilTimeout>
2400a196:	4603      	mov	r3, r0
2400a198:	2b00      	cmp	r3, #0
2400a19a:	d001      	beq.n	2400a1a0 <HAL_I2C_Mem_Write+0x78>
    {
      return HAL_ERROR;
2400a19c:	2301      	movs	r3, #1
2400a19e:	e0d1      	b.n	2400a344 <HAL_I2C_Mem_Write+0x21c>
    }

    hi2c->State     = HAL_I2C_STATE_BUSY_TX;
2400a1a0:	68fb      	ldr	r3, [r7, #12]
2400a1a2:	2221      	movs	r2, #33	; 0x21
2400a1a4:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_MEM;
2400a1a8:	68fb      	ldr	r3, [r7, #12]
2400a1aa:	2240      	movs	r2, #64	; 0x40
2400a1ac:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
2400a1b0:	68fb      	ldr	r3, [r7, #12]
2400a1b2:	2200      	movs	r2, #0
2400a1b4:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr  = pData;
2400a1b6:	68fb      	ldr	r3, [r7, #12]
2400a1b8:	6a3a      	ldr	r2, [r7, #32]
2400a1ba:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount = Size;
2400a1bc:	68fb      	ldr	r3, [r7, #12]
2400a1be:	8cba      	ldrh	r2, [r7, #36]	; 0x24
2400a1c0:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferISR   = NULL;
2400a1c2:	68fb      	ldr	r3, [r7, #12]
2400a1c4:	2200      	movs	r2, #0
2400a1c6:	635a      	str	r2, [r3, #52]	; 0x34

    /* Send Slave Address and Memory Address */
    if (I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
2400a1c8:	88f8      	ldrh	r0, [r7, #6]
2400a1ca:	893a      	ldrh	r2, [r7, #8]
2400a1cc:	8979      	ldrh	r1, [r7, #10]
2400a1ce:	697b      	ldr	r3, [r7, #20]
2400a1d0:	9301      	str	r3, [sp, #4]
2400a1d2:	6abb      	ldr	r3, [r7, #40]	; 0x28
2400a1d4:	9300      	str	r3, [sp, #0]
2400a1d6:	4603      	mov	r3, r0
2400a1d8:	68f8      	ldr	r0, [r7, #12]
2400a1da:	f002 fb67 	bl	2400c8ac <I2C_RequestMemoryWrite>
2400a1de:	4603      	mov	r3, r0
2400a1e0:	2b00      	cmp	r3, #0
2400a1e2:	d005      	beq.n	2400a1f0 <HAL_I2C_Mem_Write+0xc8>
    {
      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
2400a1e4:	68fb      	ldr	r3, [r7, #12]
2400a1e6:	2200      	movs	r2, #0
2400a1e8:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
2400a1ec:	2301      	movs	r3, #1
2400a1ee:	e0a9      	b.n	2400a344 <HAL_I2C_Mem_Write+0x21c>
    }

    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE */
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
2400a1f0:	68fb      	ldr	r3, [r7, #12]
2400a1f2:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400a1f4:	b29b      	uxth	r3, r3
2400a1f6:	2bff      	cmp	r3, #255	; 0xff
2400a1f8:	d90e      	bls.n	2400a218 <HAL_I2C_Mem_Write+0xf0>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
2400a1fa:	68fb      	ldr	r3, [r7, #12]
2400a1fc:	22ff      	movs	r2, #255	; 0xff
2400a1fe:	851a      	strh	r2, [r3, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
2400a200:	68fb      	ldr	r3, [r7, #12]
2400a202:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400a204:	b2da      	uxtb	r2, r3
2400a206:	8979      	ldrh	r1, [r7, #10]
2400a208:	2300      	movs	r3, #0
2400a20a:	9300      	str	r3, [sp, #0]
2400a20c:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2400a210:	68f8      	ldr	r0, [r7, #12]
2400a212:	f003 fd91 	bl	2400dd38 <I2C_TransferConfig>
2400a216:	e00f      	b.n	2400a238 <HAL_I2C_Mem_Write+0x110>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
2400a218:	68fb      	ldr	r3, [r7, #12]
2400a21a:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400a21c:	b29a      	uxth	r2, r3
2400a21e:	68fb      	ldr	r3, [r7, #12]
2400a220:	851a      	strh	r2, [r3, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
2400a222:	68fb      	ldr	r3, [r7, #12]
2400a224:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400a226:	b2da      	uxtb	r2, r3
2400a228:	8979      	ldrh	r1, [r7, #10]
2400a22a:	2300      	movs	r3, #0
2400a22c:	9300      	str	r3, [sp, #0]
2400a22e:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
2400a232:	68f8      	ldr	r0, [r7, #12]
2400a234:	f003 fd80 	bl	2400dd38 <I2C_TransferConfig>
    }

    do
    {
      /* Wait until TXIS flag is set */
      if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
2400a238:	697a      	ldr	r2, [r7, #20]
2400a23a:	6ab9      	ldr	r1, [r7, #40]	; 0x28
2400a23c:	68f8      	ldr	r0, [r7, #12]
2400a23e:	f003 fc2d 	bl	2400da9c <I2C_WaitOnTXISFlagUntilTimeout>
2400a242:	4603      	mov	r3, r0
2400a244:	2b00      	cmp	r3, #0
2400a246:	d001      	beq.n	2400a24c <HAL_I2C_Mem_Write+0x124>
      {
        return HAL_ERROR;
2400a248:	2301      	movs	r3, #1
2400a24a:	e07b      	b.n	2400a344 <HAL_I2C_Mem_Write+0x21c>
      }

      /* Write data to TXDR */
      hi2c->Instance->TXDR = *hi2c->pBuffPtr;
2400a24c:	68fb      	ldr	r3, [r7, #12]
2400a24e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400a250:	781a      	ldrb	r2, [r3, #0]
2400a252:	68fb      	ldr	r3, [r7, #12]
2400a254:	681b      	ldr	r3, [r3, #0]
2400a256:	629a      	str	r2, [r3, #40]	; 0x28

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
2400a258:	68fb      	ldr	r3, [r7, #12]
2400a25a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400a25c:	1c5a      	adds	r2, r3, #1
2400a25e:	68fb      	ldr	r3, [r7, #12]
2400a260:	625a      	str	r2, [r3, #36]	; 0x24

      hi2c->XferCount--;
2400a262:	68fb      	ldr	r3, [r7, #12]
2400a264:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400a266:	b29b      	uxth	r3, r3
2400a268:	3b01      	subs	r3, #1
2400a26a:	b29a      	uxth	r2, r3
2400a26c:	68fb      	ldr	r3, [r7, #12]
2400a26e:	855a      	strh	r2, [r3, #42]	; 0x2a
      hi2c->XferSize--;
2400a270:	68fb      	ldr	r3, [r7, #12]
2400a272:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400a274:	3b01      	subs	r3, #1
2400a276:	b29a      	uxth	r2, r3
2400a278:	68fb      	ldr	r3, [r7, #12]
2400a27a:	851a      	strh	r2, [r3, #40]	; 0x28

      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
2400a27c:	68fb      	ldr	r3, [r7, #12]
2400a27e:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400a280:	b29b      	uxth	r3, r3
2400a282:	2b00      	cmp	r3, #0
2400a284:	d034      	beq.n	2400a2f0 <HAL_I2C_Mem_Write+0x1c8>
2400a286:	68fb      	ldr	r3, [r7, #12]
2400a288:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400a28a:	2b00      	cmp	r3, #0
2400a28c:	d130      	bne.n	2400a2f0 <HAL_I2C_Mem_Write+0x1c8>
      {
        /* Wait until TCR flag is set */
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
2400a28e:	697b      	ldr	r3, [r7, #20]
2400a290:	9300      	str	r3, [sp, #0]
2400a292:	6abb      	ldr	r3, [r7, #40]	; 0x28
2400a294:	2200      	movs	r2, #0
2400a296:	2180      	movs	r1, #128	; 0x80
2400a298:	68f8      	ldr	r0, [r7, #12]
2400a29a:	f003 fbbf 	bl	2400da1c <I2C_WaitOnFlagUntilTimeout>
2400a29e:	4603      	mov	r3, r0
2400a2a0:	2b00      	cmp	r3, #0
2400a2a2:	d001      	beq.n	2400a2a8 <HAL_I2C_Mem_Write+0x180>
        {
          return HAL_ERROR;
2400a2a4:	2301      	movs	r3, #1
2400a2a6:	e04d      	b.n	2400a344 <HAL_I2C_Mem_Write+0x21c>
        }

        if (hi2c->XferCount > MAX_NBYTE_SIZE)
2400a2a8:	68fb      	ldr	r3, [r7, #12]
2400a2aa:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400a2ac:	b29b      	uxth	r3, r3
2400a2ae:	2bff      	cmp	r3, #255	; 0xff
2400a2b0:	d90e      	bls.n	2400a2d0 <HAL_I2C_Mem_Write+0x1a8>
        {
          hi2c->XferSize = MAX_NBYTE_SIZE;
2400a2b2:	68fb      	ldr	r3, [r7, #12]
2400a2b4:	22ff      	movs	r2, #255	; 0xff
2400a2b6:	851a      	strh	r2, [r3, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
2400a2b8:	68fb      	ldr	r3, [r7, #12]
2400a2ba:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400a2bc:	b2da      	uxtb	r2, r3
2400a2be:	8979      	ldrh	r1, [r7, #10]
2400a2c0:	2300      	movs	r3, #0
2400a2c2:	9300      	str	r3, [sp, #0]
2400a2c4:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2400a2c8:	68f8      	ldr	r0, [r7, #12]
2400a2ca:	f003 fd35 	bl	2400dd38 <I2C_TransferConfig>
2400a2ce:	e00f      	b.n	2400a2f0 <HAL_I2C_Mem_Write+0x1c8>
        }
        else
        {
          hi2c->XferSize = hi2c->XferCount;
2400a2d0:	68fb      	ldr	r3, [r7, #12]
2400a2d2:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400a2d4:	b29a      	uxth	r2, r3
2400a2d6:	68fb      	ldr	r3, [r7, #12]
2400a2d8:	851a      	strh	r2, [r3, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
2400a2da:	68fb      	ldr	r3, [r7, #12]
2400a2dc:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400a2de:	b2da      	uxtb	r2, r3
2400a2e0:	8979      	ldrh	r1, [r7, #10]
2400a2e2:	2300      	movs	r3, #0
2400a2e4:	9300      	str	r3, [sp, #0]
2400a2e6:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
2400a2ea:	68f8      	ldr	r0, [r7, #12]
2400a2ec:	f003 fd24 	bl	2400dd38 <I2C_TransferConfig>
        }
      }

    }
    while (hi2c->XferCount > 0U);
2400a2f0:	68fb      	ldr	r3, [r7, #12]
2400a2f2:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400a2f4:	b29b      	uxth	r3, r3
2400a2f6:	2b00      	cmp	r3, #0
2400a2f8:	d19e      	bne.n	2400a238 <HAL_I2C_Mem_Write+0x110>

    /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
    /* Wait until STOPF flag is reset */
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
2400a2fa:	697a      	ldr	r2, [r7, #20]
2400a2fc:	6ab9      	ldr	r1, [r7, #40]	; 0x28
2400a2fe:	68f8      	ldr	r0, [r7, #12]
2400a300:	f003 fc0c 	bl	2400db1c <I2C_WaitOnSTOPFlagUntilTimeout>
2400a304:	4603      	mov	r3, r0
2400a306:	2b00      	cmp	r3, #0
2400a308:	d001      	beq.n	2400a30e <HAL_I2C_Mem_Write+0x1e6>
    {
      return HAL_ERROR;
2400a30a:	2301      	movs	r3, #1
2400a30c:	e01a      	b.n	2400a344 <HAL_I2C_Mem_Write+0x21c>
    }

    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
2400a30e:	68fb      	ldr	r3, [r7, #12]
2400a310:	681b      	ldr	r3, [r3, #0]
2400a312:	2220      	movs	r2, #32
2400a314:	61da      	str	r2, [r3, #28]

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
2400a316:	68fb      	ldr	r3, [r7, #12]
2400a318:	681b      	ldr	r3, [r3, #0]
2400a31a:	6859      	ldr	r1, [r3, #4]
2400a31c:	68fb      	ldr	r3, [r7, #12]
2400a31e:	681a      	ldr	r2, [r3, #0]
2400a320:	4b0a      	ldr	r3, [pc, #40]	; (2400a34c <HAL_I2C_Mem_Write+0x224>)
2400a322:	400b      	ands	r3, r1
2400a324:	6053      	str	r3, [r2, #4]

    hi2c->State = HAL_I2C_STATE_READY;
2400a326:	68fb      	ldr	r3, [r7, #12]
2400a328:	2220      	movs	r2, #32
2400a32a:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode  = HAL_I2C_MODE_NONE;
2400a32e:	68fb      	ldr	r3, [r7, #12]
2400a330:	2200      	movs	r2, #0
2400a332:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2400a336:	68fb      	ldr	r3, [r7, #12]
2400a338:	2200      	movs	r2, #0
2400a33a:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    return HAL_OK;
2400a33e:	2300      	movs	r3, #0
2400a340:	e000      	b.n	2400a344 <HAL_I2C_Mem_Write+0x21c>
  }
  else
  {
    return HAL_BUSY;
2400a342:	2302      	movs	r3, #2
  }
}
2400a344:	4618      	mov	r0, r3
2400a346:	3718      	adds	r7, #24
2400a348:	46bd      	mov	sp, r7
2400a34a:	bd80      	pop	{r7, pc}
2400a34c:	fe00e800 	.word	0xfe00e800

2400a350 <HAL_I2C_Mem_Read>:
  * @param  Size Amount of data to be sent
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Mem_Read(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
2400a350:	b580      	push	{r7, lr}
2400a352:	b088      	sub	sp, #32
2400a354:	af02      	add	r7, sp, #8
2400a356:	60f8      	str	r0, [r7, #12]
2400a358:	4608      	mov	r0, r1
2400a35a:	4611      	mov	r1, r2
2400a35c:	461a      	mov	r2, r3
2400a35e:	4603      	mov	r3, r0
2400a360:	817b      	strh	r3, [r7, #10]
2400a362:	460b      	mov	r3, r1
2400a364:	813b      	strh	r3, [r7, #8]
2400a366:	4613      	mov	r3, r2
2400a368:	80fb      	strh	r3, [r7, #6]
  uint32_t tickstart;

  /* Check the parameters */
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));

  if (hi2c->State == HAL_I2C_STATE_READY)
2400a36a:	68fb      	ldr	r3, [r7, #12]
2400a36c:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400a370:	b2db      	uxtb	r3, r3
2400a372:	2b20      	cmp	r3, #32
2400a374:	f040 80fd 	bne.w	2400a572 <HAL_I2C_Mem_Read+0x222>
  {
    if ((pData == NULL) || (Size == 0U))
2400a378:	6a3b      	ldr	r3, [r7, #32]
2400a37a:	2b00      	cmp	r3, #0
2400a37c:	d002      	beq.n	2400a384 <HAL_I2C_Mem_Read+0x34>
2400a37e:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
2400a380:	2b00      	cmp	r3, #0
2400a382:	d105      	bne.n	2400a390 <HAL_I2C_Mem_Read+0x40>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
2400a384:	68fb      	ldr	r3, [r7, #12]
2400a386:	f44f 7200 	mov.w	r2, #512	; 0x200
2400a38a:	645a      	str	r2, [r3, #68]	; 0x44
      return  HAL_ERROR;
2400a38c:	2301      	movs	r3, #1
2400a38e:	e0f1      	b.n	2400a574 <HAL_I2C_Mem_Read+0x224>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
2400a390:	68fb      	ldr	r3, [r7, #12]
2400a392:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400a396:	2b01      	cmp	r3, #1
2400a398:	d101      	bne.n	2400a39e <HAL_I2C_Mem_Read+0x4e>
2400a39a:	2302      	movs	r3, #2
2400a39c:	e0ea      	b.n	2400a574 <HAL_I2C_Mem_Read+0x224>
2400a39e:	68fb      	ldr	r3, [r7, #12]
2400a3a0:	2201      	movs	r2, #1
2400a3a2:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Init tickstart for timeout management*/
    tickstart = HAL_GetTick();
2400a3a6:	f7f6 fa53 	bl	24000850 <HAL_GetTick>
2400a3aa:	6178      	str	r0, [r7, #20]

    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
2400a3ac:	697b      	ldr	r3, [r7, #20]
2400a3ae:	9300      	str	r3, [sp, #0]
2400a3b0:	2319      	movs	r3, #25
2400a3b2:	2201      	movs	r2, #1
2400a3b4:	f44f 4100 	mov.w	r1, #32768	; 0x8000
2400a3b8:	68f8      	ldr	r0, [r7, #12]
2400a3ba:	f003 fb2f 	bl	2400da1c <I2C_WaitOnFlagUntilTimeout>
2400a3be:	4603      	mov	r3, r0
2400a3c0:	2b00      	cmp	r3, #0
2400a3c2:	d001      	beq.n	2400a3c8 <HAL_I2C_Mem_Read+0x78>
    {
      return HAL_ERROR;
2400a3c4:	2301      	movs	r3, #1
2400a3c6:	e0d5      	b.n	2400a574 <HAL_I2C_Mem_Read+0x224>
    }

    hi2c->State     = HAL_I2C_STATE_BUSY_RX;
2400a3c8:	68fb      	ldr	r3, [r7, #12]
2400a3ca:	2222      	movs	r2, #34	; 0x22
2400a3cc:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_MEM;
2400a3d0:	68fb      	ldr	r3, [r7, #12]
2400a3d2:	2240      	movs	r2, #64	; 0x40
2400a3d4:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
2400a3d8:	68fb      	ldr	r3, [r7, #12]
2400a3da:	2200      	movs	r2, #0
2400a3dc:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr  = pData;
2400a3de:	68fb      	ldr	r3, [r7, #12]
2400a3e0:	6a3a      	ldr	r2, [r7, #32]
2400a3e2:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount = Size;
2400a3e4:	68fb      	ldr	r3, [r7, #12]
2400a3e6:	8cba      	ldrh	r2, [r7, #36]	; 0x24
2400a3e8:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferISR   = NULL;
2400a3ea:	68fb      	ldr	r3, [r7, #12]
2400a3ec:	2200      	movs	r2, #0
2400a3ee:	635a      	str	r2, [r3, #52]	; 0x34

    /* Send Slave Address and Memory Address */
    if (I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
2400a3f0:	88f8      	ldrh	r0, [r7, #6]
2400a3f2:	893a      	ldrh	r2, [r7, #8]
2400a3f4:	8979      	ldrh	r1, [r7, #10]
2400a3f6:	697b      	ldr	r3, [r7, #20]
2400a3f8:	9301      	str	r3, [sp, #4]
2400a3fa:	6abb      	ldr	r3, [r7, #40]	; 0x28
2400a3fc:	9300      	str	r3, [sp, #0]
2400a3fe:	4603      	mov	r3, r0
2400a400:	68f8      	ldr	r0, [r7, #12]
2400a402:	f002 faa7 	bl	2400c954 <I2C_RequestMemoryRead>
2400a406:	4603      	mov	r3, r0
2400a408:	2b00      	cmp	r3, #0
2400a40a:	d005      	beq.n	2400a418 <HAL_I2C_Mem_Read+0xc8>
    {
      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
2400a40c:	68fb      	ldr	r3, [r7, #12]
2400a40e:	2200      	movs	r2, #0
2400a410:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
2400a414:	2301      	movs	r3, #1
2400a416:	e0ad      	b.n	2400a574 <HAL_I2C_Mem_Read+0x224>
    }

    /* Send Slave Address */
    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
2400a418:	68fb      	ldr	r3, [r7, #12]
2400a41a:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400a41c:	b29b      	uxth	r3, r3
2400a41e:	2bff      	cmp	r3, #255	; 0xff
2400a420:	d90e      	bls.n	2400a440 <HAL_I2C_Mem_Read+0xf0>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
2400a422:	68fb      	ldr	r3, [r7, #12]
2400a424:	22ff      	movs	r2, #255	; 0xff
2400a426:	851a      	strh	r2, [r3, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_GENERATE_START_READ);
2400a428:	68fb      	ldr	r3, [r7, #12]
2400a42a:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400a42c:	b2da      	uxtb	r2, r3
2400a42e:	8979      	ldrh	r1, [r7, #10]
2400a430:	4b52      	ldr	r3, [pc, #328]	; (2400a57c <HAL_I2C_Mem_Read+0x22c>)
2400a432:	9300      	str	r3, [sp, #0]
2400a434:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2400a438:	68f8      	ldr	r0, [r7, #12]
2400a43a:	f003 fc7d 	bl	2400dd38 <I2C_TransferConfig>
2400a43e:	e00f      	b.n	2400a460 <HAL_I2C_Mem_Read+0x110>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
2400a440:	68fb      	ldr	r3, [r7, #12]
2400a442:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400a444:	b29a      	uxth	r2, r3
2400a446:	68fb      	ldr	r3, [r7, #12]
2400a448:	851a      	strh	r2, [r3, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_READ);
2400a44a:	68fb      	ldr	r3, [r7, #12]
2400a44c:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400a44e:	b2da      	uxtb	r2, r3
2400a450:	8979      	ldrh	r1, [r7, #10]
2400a452:	4b4a      	ldr	r3, [pc, #296]	; (2400a57c <HAL_I2C_Mem_Read+0x22c>)
2400a454:	9300      	str	r3, [sp, #0]
2400a456:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
2400a45a:	68f8      	ldr	r0, [r7, #12]
2400a45c:	f003 fc6c 	bl	2400dd38 <I2C_TransferConfig>
    }

    do
    {
      /* Wait until RXNE flag is set */
      if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_RXNE, RESET, Timeout, tickstart) != HAL_OK)
2400a460:	697b      	ldr	r3, [r7, #20]
2400a462:	9300      	str	r3, [sp, #0]
2400a464:	6abb      	ldr	r3, [r7, #40]	; 0x28
2400a466:	2200      	movs	r2, #0
2400a468:	2104      	movs	r1, #4
2400a46a:	68f8      	ldr	r0, [r7, #12]
2400a46c:	f003 fad6 	bl	2400da1c <I2C_WaitOnFlagUntilTimeout>
2400a470:	4603      	mov	r3, r0
2400a472:	2b00      	cmp	r3, #0
2400a474:	d001      	beq.n	2400a47a <HAL_I2C_Mem_Read+0x12a>
      {
        return HAL_ERROR;
2400a476:	2301      	movs	r3, #1
2400a478:	e07c      	b.n	2400a574 <HAL_I2C_Mem_Read+0x224>
      }

      /* Read data from RXDR */
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
2400a47a:	68fb      	ldr	r3, [r7, #12]
2400a47c:	681b      	ldr	r3, [r3, #0]
2400a47e:	6a5a      	ldr	r2, [r3, #36]	; 0x24
2400a480:	68fb      	ldr	r3, [r7, #12]
2400a482:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400a484:	b2d2      	uxtb	r2, r2
2400a486:	701a      	strb	r2, [r3, #0]

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
2400a488:	68fb      	ldr	r3, [r7, #12]
2400a48a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400a48c:	1c5a      	adds	r2, r3, #1
2400a48e:	68fb      	ldr	r3, [r7, #12]
2400a490:	625a      	str	r2, [r3, #36]	; 0x24

      hi2c->XferSize--;
2400a492:	68fb      	ldr	r3, [r7, #12]
2400a494:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400a496:	3b01      	subs	r3, #1
2400a498:	b29a      	uxth	r2, r3
2400a49a:	68fb      	ldr	r3, [r7, #12]
2400a49c:	851a      	strh	r2, [r3, #40]	; 0x28
      hi2c->XferCount--;
2400a49e:	68fb      	ldr	r3, [r7, #12]
2400a4a0:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400a4a2:	b29b      	uxth	r3, r3
2400a4a4:	3b01      	subs	r3, #1
2400a4a6:	b29a      	uxth	r2, r3
2400a4a8:	68fb      	ldr	r3, [r7, #12]
2400a4aa:	855a      	strh	r2, [r3, #42]	; 0x2a

      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
2400a4ac:	68fb      	ldr	r3, [r7, #12]
2400a4ae:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400a4b0:	b29b      	uxth	r3, r3
2400a4b2:	2b00      	cmp	r3, #0
2400a4b4:	d034      	beq.n	2400a520 <HAL_I2C_Mem_Read+0x1d0>
2400a4b6:	68fb      	ldr	r3, [r7, #12]
2400a4b8:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400a4ba:	2b00      	cmp	r3, #0
2400a4bc:	d130      	bne.n	2400a520 <HAL_I2C_Mem_Read+0x1d0>
      {
        /* Wait until TCR flag is set */
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
2400a4be:	697b      	ldr	r3, [r7, #20]
2400a4c0:	9300      	str	r3, [sp, #0]
2400a4c2:	6abb      	ldr	r3, [r7, #40]	; 0x28
2400a4c4:	2200      	movs	r2, #0
2400a4c6:	2180      	movs	r1, #128	; 0x80
2400a4c8:	68f8      	ldr	r0, [r7, #12]
2400a4ca:	f003 faa7 	bl	2400da1c <I2C_WaitOnFlagUntilTimeout>
2400a4ce:	4603      	mov	r3, r0
2400a4d0:	2b00      	cmp	r3, #0
2400a4d2:	d001      	beq.n	2400a4d8 <HAL_I2C_Mem_Read+0x188>
        {
          return HAL_ERROR;
2400a4d4:	2301      	movs	r3, #1
2400a4d6:	e04d      	b.n	2400a574 <HAL_I2C_Mem_Read+0x224>
        }

        if (hi2c->XferCount > MAX_NBYTE_SIZE)
2400a4d8:	68fb      	ldr	r3, [r7, #12]
2400a4da:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400a4dc:	b29b      	uxth	r3, r3
2400a4de:	2bff      	cmp	r3, #255	; 0xff
2400a4e0:	d90e      	bls.n	2400a500 <HAL_I2C_Mem_Read+0x1b0>
        {
          hi2c->XferSize = MAX_NBYTE_SIZE;
2400a4e2:	68fb      	ldr	r3, [r7, #12]
2400a4e4:	22ff      	movs	r2, #255	; 0xff
2400a4e6:	851a      	strh	r2, [r3, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t) hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
2400a4e8:	68fb      	ldr	r3, [r7, #12]
2400a4ea:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400a4ec:	b2da      	uxtb	r2, r3
2400a4ee:	8979      	ldrh	r1, [r7, #10]
2400a4f0:	2300      	movs	r3, #0
2400a4f2:	9300      	str	r3, [sp, #0]
2400a4f4:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2400a4f8:	68f8      	ldr	r0, [r7, #12]
2400a4fa:	f003 fc1d 	bl	2400dd38 <I2C_TransferConfig>
2400a4fe:	e00f      	b.n	2400a520 <HAL_I2C_Mem_Read+0x1d0>
        }
        else
        {
          hi2c->XferSize = hi2c->XferCount;
2400a500:	68fb      	ldr	r3, [r7, #12]
2400a502:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400a504:	b29a      	uxth	r2, r3
2400a506:	68fb      	ldr	r3, [r7, #12]
2400a508:	851a      	strh	r2, [r3, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
2400a50a:	68fb      	ldr	r3, [r7, #12]
2400a50c:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400a50e:	b2da      	uxtb	r2, r3
2400a510:	8979      	ldrh	r1, [r7, #10]
2400a512:	2300      	movs	r3, #0
2400a514:	9300      	str	r3, [sp, #0]
2400a516:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
2400a51a:	68f8      	ldr	r0, [r7, #12]
2400a51c:	f003 fc0c 	bl	2400dd38 <I2C_TransferConfig>
        }
      }
    }
    while (hi2c->XferCount > 0U);
2400a520:	68fb      	ldr	r3, [r7, #12]
2400a522:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400a524:	b29b      	uxth	r3, r3
2400a526:	2b00      	cmp	r3, #0
2400a528:	d19a      	bne.n	2400a460 <HAL_I2C_Mem_Read+0x110>

    /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
    /* Wait until STOPF flag is reset */
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
2400a52a:	697a      	ldr	r2, [r7, #20]
2400a52c:	6ab9      	ldr	r1, [r7, #40]	; 0x28
2400a52e:	68f8      	ldr	r0, [r7, #12]
2400a530:	f003 faf4 	bl	2400db1c <I2C_WaitOnSTOPFlagUntilTimeout>
2400a534:	4603      	mov	r3, r0
2400a536:	2b00      	cmp	r3, #0
2400a538:	d001      	beq.n	2400a53e <HAL_I2C_Mem_Read+0x1ee>
    {
      return HAL_ERROR;
2400a53a:	2301      	movs	r3, #1
2400a53c:	e01a      	b.n	2400a574 <HAL_I2C_Mem_Read+0x224>
    }

    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
2400a53e:	68fb      	ldr	r3, [r7, #12]
2400a540:	681b      	ldr	r3, [r3, #0]
2400a542:	2220      	movs	r2, #32
2400a544:	61da      	str	r2, [r3, #28]

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
2400a546:	68fb      	ldr	r3, [r7, #12]
2400a548:	681b      	ldr	r3, [r3, #0]
2400a54a:	6859      	ldr	r1, [r3, #4]
2400a54c:	68fb      	ldr	r3, [r7, #12]
2400a54e:	681a      	ldr	r2, [r3, #0]
2400a550:	4b0b      	ldr	r3, [pc, #44]	; (2400a580 <HAL_I2C_Mem_Read+0x230>)
2400a552:	400b      	ands	r3, r1
2400a554:	6053      	str	r3, [r2, #4]

    hi2c->State = HAL_I2C_STATE_READY;
2400a556:	68fb      	ldr	r3, [r7, #12]
2400a558:	2220      	movs	r2, #32
2400a55a:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode  = HAL_I2C_MODE_NONE;
2400a55e:	68fb      	ldr	r3, [r7, #12]
2400a560:	2200      	movs	r2, #0
2400a562:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2400a566:	68fb      	ldr	r3, [r7, #12]
2400a568:	2200      	movs	r2, #0
2400a56a:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    return HAL_OK;
2400a56e:	2300      	movs	r3, #0
2400a570:	e000      	b.n	2400a574 <HAL_I2C_Mem_Read+0x224>
  }
  else
  {
    return HAL_BUSY;
2400a572:	2302      	movs	r3, #2
  }
}
2400a574:	4618      	mov	r0, r3
2400a576:	3718      	adds	r7, #24
2400a578:	46bd      	mov	sp, r7
2400a57a:	bd80      	pop	{r7, pc}
2400a57c:	80002400 	.word	0x80002400
2400a580:	fe00e800 	.word	0xfe00e800

2400a584 <HAL_I2C_Mem_Write_IT>:
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Mem_Write_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size)
{
2400a584:	b580      	push	{r7, lr}
2400a586:	b088      	sub	sp, #32
2400a588:	af02      	add	r7, sp, #8
2400a58a:	60f8      	str	r0, [r7, #12]
2400a58c:	4608      	mov	r0, r1
2400a58e:	4611      	mov	r1, r2
2400a590:	461a      	mov	r2, r3
2400a592:	4603      	mov	r3, r0
2400a594:	817b      	strh	r3, [r7, #10]
2400a596:	460b      	mov	r3, r1
2400a598:	813b      	strh	r3, [r7, #8]
2400a59a:	4613      	mov	r3, r2
2400a59c:	80fb      	strh	r3, [r7, #6]
  uint32_t xfermode;

  /* Check the parameters */
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));

  if (hi2c->State == HAL_I2C_STATE_READY)
2400a59e:	68fb      	ldr	r3, [r7, #12]
2400a5a0:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400a5a4:	b2db      	uxtb	r3, r3
2400a5a6:	2b20      	cmp	r3, #32
2400a5a8:	d176      	bne.n	2400a698 <HAL_I2C_Mem_Write_IT+0x114>
  {
    if ((pData == NULL) || (Size == 0U))
2400a5aa:	6a3b      	ldr	r3, [r7, #32]
2400a5ac:	2b00      	cmp	r3, #0
2400a5ae:	d002      	beq.n	2400a5b6 <HAL_I2C_Mem_Write_IT+0x32>
2400a5b0:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
2400a5b2:	2b00      	cmp	r3, #0
2400a5b4:	d105      	bne.n	2400a5c2 <HAL_I2C_Mem_Write_IT+0x3e>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
2400a5b6:	68fb      	ldr	r3, [r7, #12]
2400a5b8:	f44f 7200 	mov.w	r2, #512	; 0x200
2400a5bc:	645a      	str	r2, [r3, #68]	; 0x44
      return  HAL_ERROR;
2400a5be:	2301      	movs	r3, #1
2400a5c0:	e06b      	b.n	2400a69a <HAL_I2C_Mem_Write_IT+0x116>
    }

    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
2400a5c2:	68fb      	ldr	r3, [r7, #12]
2400a5c4:	681b      	ldr	r3, [r3, #0]
2400a5c6:	699b      	ldr	r3, [r3, #24]
2400a5c8:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
2400a5cc:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
2400a5d0:	d101      	bne.n	2400a5d6 <HAL_I2C_Mem_Write_IT+0x52>
    {
      return HAL_BUSY;
2400a5d2:	2302      	movs	r3, #2
2400a5d4:	e061      	b.n	2400a69a <HAL_I2C_Mem_Write_IT+0x116>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
2400a5d6:	68fb      	ldr	r3, [r7, #12]
2400a5d8:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400a5dc:	2b01      	cmp	r3, #1
2400a5de:	d101      	bne.n	2400a5e4 <HAL_I2C_Mem_Write_IT+0x60>
2400a5e0:	2302      	movs	r3, #2
2400a5e2:	e05a      	b.n	2400a69a <HAL_I2C_Mem_Write_IT+0x116>
2400a5e4:	68fb      	ldr	r3, [r7, #12]
2400a5e6:	2201      	movs	r2, #1
2400a5e8:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Init tickstart for timeout management*/
    tickstart = HAL_GetTick();
2400a5ec:	f7f6 f930 	bl	24000850 <HAL_GetTick>
2400a5f0:	6138      	str	r0, [r7, #16]

    hi2c->State       = HAL_I2C_STATE_BUSY_TX;
2400a5f2:	68fb      	ldr	r3, [r7, #12]
2400a5f4:	2221      	movs	r2, #33	; 0x21
2400a5f6:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode        = HAL_I2C_MODE_MEM;
2400a5fa:	68fb      	ldr	r3, [r7, #12]
2400a5fc:	2240      	movs	r2, #64	; 0x40
2400a5fe:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
2400a602:	68fb      	ldr	r3, [r7, #12]
2400a604:	2200      	movs	r2, #0
2400a606:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
2400a608:	68fb      	ldr	r3, [r7, #12]
2400a60a:	6a3a      	ldr	r2, [r7, #32]
2400a60c:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
2400a60e:	68fb      	ldr	r3, [r7, #12]
2400a610:	8cba      	ldrh	r2, [r7, #36]	; 0x24
2400a612:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
2400a614:	68fb      	ldr	r3, [r7, #12]
2400a616:	4a23      	ldr	r2, [pc, #140]	; (2400a6a4 <HAL_I2C_Mem_Write_IT+0x120>)
2400a618:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Master_ISR_IT;
2400a61a:	68fb      	ldr	r3, [r7, #12]
2400a61c:	4a22      	ldr	r2, [pc, #136]	; (2400a6a8 <HAL_I2C_Mem_Write_IT+0x124>)
2400a61e:	635a      	str	r2, [r3, #52]	; 0x34

    if (hi2c->XferCount > MAX_NBYTE_SIZE)
2400a620:	68fb      	ldr	r3, [r7, #12]
2400a622:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400a624:	b29b      	uxth	r3, r3
2400a626:	2bff      	cmp	r3, #255	; 0xff
2400a628:	d906      	bls.n	2400a638 <HAL_I2C_Mem_Write_IT+0xb4>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
2400a62a:	68fb      	ldr	r3, [r7, #12]
2400a62c:	22ff      	movs	r2, #255	; 0xff
2400a62e:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_RELOAD_MODE;
2400a630:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2400a634:	617b      	str	r3, [r7, #20]
2400a636:	e007      	b.n	2400a648 <HAL_I2C_Mem_Write_IT+0xc4>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
2400a638:	68fb      	ldr	r3, [r7, #12]
2400a63a:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400a63c:	b29a      	uxth	r2, r3
2400a63e:	68fb      	ldr	r3, [r7, #12]
2400a640:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_AUTOEND_MODE;
2400a642:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
2400a646:	617b      	str	r3, [r7, #20]
    }

    /* Send Slave Address and Memory Address */
    if (I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, I2C_TIMEOUT_FLAG, tickstart) != HAL_OK)
2400a648:	88f8      	ldrh	r0, [r7, #6]
2400a64a:	893a      	ldrh	r2, [r7, #8]
2400a64c:	8979      	ldrh	r1, [r7, #10]
2400a64e:	693b      	ldr	r3, [r7, #16]
2400a650:	9301      	str	r3, [sp, #4]
2400a652:	2319      	movs	r3, #25
2400a654:	9300      	str	r3, [sp, #0]
2400a656:	4603      	mov	r3, r0
2400a658:	68f8      	ldr	r0, [r7, #12]
2400a65a:	f002 f927 	bl	2400c8ac <I2C_RequestMemoryWrite>
2400a65e:	4603      	mov	r3, r0
2400a660:	2b00      	cmp	r3, #0
2400a662:	d005      	beq.n	2400a670 <HAL_I2C_Mem_Write_IT+0xec>
    {
      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
2400a664:	68fb      	ldr	r3, [r7, #12]
2400a666:	2200      	movs	r2, #0
2400a668:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
2400a66c:	2301      	movs	r3, #1
2400a66e:	e014      	b.n	2400a69a <HAL_I2C_Mem_Write_IT+0x116>
    }

    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
    I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, I2C_NO_STARTSTOP);
2400a670:	68fb      	ldr	r3, [r7, #12]
2400a672:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400a674:	b2da      	uxtb	r2, r3
2400a676:	8979      	ldrh	r1, [r7, #10]
2400a678:	2300      	movs	r3, #0
2400a67a:	9300      	str	r3, [sp, #0]
2400a67c:	697b      	ldr	r3, [r7, #20]
2400a67e:	68f8      	ldr	r0, [r7, #12]
2400a680:	f003 fb5a 	bl	2400dd38 <I2C_TransferConfig>

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2400a684:	68fb      	ldr	r3, [r7, #12]
2400a686:	2200      	movs	r2, #0
2400a688:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
              process unlock */

    /* Enable ERR, TC, STOP, NACK, TXI interrupt */
    /* possible to enable all of these */
    /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
    I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT);
2400a68c:	2101      	movs	r1, #1
2400a68e:	68f8      	ldr	r0, [r7, #12]
2400a690:	f003 fb80 	bl	2400dd94 <I2C_Enable_IRQ>

    return HAL_OK;
2400a694:	2300      	movs	r3, #0
2400a696:	e000      	b.n	2400a69a <HAL_I2C_Mem_Write_IT+0x116>
  }
  else
  {
    return HAL_BUSY;
2400a698:	2302      	movs	r3, #2
  }
}
2400a69a:	4618      	mov	r0, r3
2400a69c:	3718      	adds	r7, #24
2400a69e:	46bd      	mov	sp, r7
2400a6a0:	bd80      	pop	{r7, pc}
2400a6a2:	bf00      	nop
2400a6a4:	ffff0000 	.word	0xffff0000
2400a6a8:	2400beaf 	.word	0x2400beaf

2400a6ac <HAL_I2C_Mem_Read_IT>:
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Mem_Read_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size)
{
2400a6ac:	b580      	push	{r7, lr}
2400a6ae:	b088      	sub	sp, #32
2400a6b0:	af02      	add	r7, sp, #8
2400a6b2:	60f8      	str	r0, [r7, #12]
2400a6b4:	4608      	mov	r0, r1
2400a6b6:	4611      	mov	r1, r2
2400a6b8:	461a      	mov	r2, r3
2400a6ba:	4603      	mov	r3, r0
2400a6bc:	817b      	strh	r3, [r7, #10]
2400a6be:	460b      	mov	r3, r1
2400a6c0:	813b      	strh	r3, [r7, #8]
2400a6c2:	4613      	mov	r3, r2
2400a6c4:	80fb      	strh	r3, [r7, #6]
  uint32_t xfermode;

  /* Check the parameters */
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));

  if (hi2c->State == HAL_I2C_STATE_READY)
2400a6c6:	68fb      	ldr	r3, [r7, #12]
2400a6c8:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400a6cc:	b2db      	uxtb	r3, r3
2400a6ce:	2b20      	cmp	r3, #32
2400a6d0:	d176      	bne.n	2400a7c0 <HAL_I2C_Mem_Read_IT+0x114>
  {
    if ((pData == NULL) || (Size == 0U))
2400a6d2:	6a3b      	ldr	r3, [r7, #32]
2400a6d4:	2b00      	cmp	r3, #0
2400a6d6:	d002      	beq.n	2400a6de <HAL_I2C_Mem_Read_IT+0x32>
2400a6d8:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
2400a6da:	2b00      	cmp	r3, #0
2400a6dc:	d105      	bne.n	2400a6ea <HAL_I2C_Mem_Read_IT+0x3e>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
2400a6de:	68fb      	ldr	r3, [r7, #12]
2400a6e0:	f44f 7200 	mov.w	r2, #512	; 0x200
2400a6e4:	645a      	str	r2, [r3, #68]	; 0x44
      return  HAL_ERROR;
2400a6e6:	2301      	movs	r3, #1
2400a6e8:	e06b      	b.n	2400a7c2 <HAL_I2C_Mem_Read_IT+0x116>
    }

    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
2400a6ea:	68fb      	ldr	r3, [r7, #12]
2400a6ec:	681b      	ldr	r3, [r3, #0]
2400a6ee:	699b      	ldr	r3, [r3, #24]
2400a6f0:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
2400a6f4:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
2400a6f8:	d101      	bne.n	2400a6fe <HAL_I2C_Mem_Read_IT+0x52>
    {
      return HAL_BUSY;
2400a6fa:	2302      	movs	r3, #2
2400a6fc:	e061      	b.n	2400a7c2 <HAL_I2C_Mem_Read_IT+0x116>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
2400a6fe:	68fb      	ldr	r3, [r7, #12]
2400a700:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400a704:	2b01      	cmp	r3, #1
2400a706:	d101      	bne.n	2400a70c <HAL_I2C_Mem_Read_IT+0x60>
2400a708:	2302      	movs	r3, #2
2400a70a:	e05a      	b.n	2400a7c2 <HAL_I2C_Mem_Read_IT+0x116>
2400a70c:	68fb      	ldr	r3, [r7, #12]
2400a70e:	2201      	movs	r2, #1
2400a710:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Init tickstart for timeout management*/
    tickstart = HAL_GetTick();
2400a714:	f7f6 f89c 	bl	24000850 <HAL_GetTick>
2400a718:	6138      	str	r0, [r7, #16]

    hi2c->State       = HAL_I2C_STATE_BUSY_RX;
2400a71a:	68fb      	ldr	r3, [r7, #12]
2400a71c:	2222      	movs	r2, #34	; 0x22
2400a71e:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode        = HAL_I2C_MODE_MEM;
2400a722:	68fb      	ldr	r3, [r7, #12]
2400a724:	2240      	movs	r2, #64	; 0x40
2400a726:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
2400a72a:	68fb      	ldr	r3, [r7, #12]
2400a72c:	2200      	movs	r2, #0
2400a72e:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
2400a730:	68fb      	ldr	r3, [r7, #12]
2400a732:	6a3a      	ldr	r2, [r7, #32]
2400a734:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
2400a736:	68fb      	ldr	r3, [r7, #12]
2400a738:	8cba      	ldrh	r2, [r7, #36]	; 0x24
2400a73a:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
2400a73c:	68fb      	ldr	r3, [r7, #12]
2400a73e:	4a23      	ldr	r2, [pc, #140]	; (2400a7cc <HAL_I2C_Mem_Read_IT+0x120>)
2400a740:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Master_ISR_IT;
2400a742:	68fb      	ldr	r3, [r7, #12]
2400a744:	4a22      	ldr	r2, [pc, #136]	; (2400a7d0 <HAL_I2C_Mem_Read_IT+0x124>)
2400a746:	635a      	str	r2, [r3, #52]	; 0x34

    if (hi2c->XferCount > MAX_NBYTE_SIZE)
2400a748:	68fb      	ldr	r3, [r7, #12]
2400a74a:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400a74c:	b29b      	uxth	r3, r3
2400a74e:	2bff      	cmp	r3, #255	; 0xff
2400a750:	d906      	bls.n	2400a760 <HAL_I2C_Mem_Read_IT+0xb4>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
2400a752:	68fb      	ldr	r3, [r7, #12]
2400a754:	22ff      	movs	r2, #255	; 0xff
2400a756:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_RELOAD_MODE;
2400a758:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2400a75c:	617b      	str	r3, [r7, #20]
2400a75e:	e007      	b.n	2400a770 <HAL_I2C_Mem_Read_IT+0xc4>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
2400a760:	68fb      	ldr	r3, [r7, #12]
2400a762:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400a764:	b29a      	uxth	r2, r3
2400a766:	68fb      	ldr	r3, [r7, #12]
2400a768:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_AUTOEND_MODE;
2400a76a:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
2400a76e:	617b      	str	r3, [r7, #20]
    }

    /* Send Slave Address and Memory Address */
    if (I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, I2C_TIMEOUT_FLAG, tickstart) != HAL_OK)
2400a770:	88f8      	ldrh	r0, [r7, #6]
2400a772:	893a      	ldrh	r2, [r7, #8]
2400a774:	8979      	ldrh	r1, [r7, #10]
2400a776:	693b      	ldr	r3, [r7, #16]
2400a778:	9301      	str	r3, [sp, #4]
2400a77a:	2319      	movs	r3, #25
2400a77c:	9300      	str	r3, [sp, #0]
2400a77e:	4603      	mov	r3, r0
2400a780:	68f8      	ldr	r0, [r7, #12]
2400a782:	f002 f8e7 	bl	2400c954 <I2C_RequestMemoryRead>
2400a786:	4603      	mov	r3, r0
2400a788:	2b00      	cmp	r3, #0
2400a78a:	d005      	beq.n	2400a798 <HAL_I2C_Mem_Read_IT+0xec>
    {
      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
2400a78c:	68fb      	ldr	r3, [r7, #12]
2400a78e:	2200      	movs	r2, #0
2400a790:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
2400a794:	2301      	movs	r3, #1
2400a796:	e014      	b.n	2400a7c2 <HAL_I2C_Mem_Read_IT+0x116>
    }

    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
    I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, I2C_GENERATE_START_READ);
2400a798:	68fb      	ldr	r3, [r7, #12]
2400a79a:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400a79c:	b2da      	uxtb	r2, r3
2400a79e:	8979      	ldrh	r1, [r7, #10]
2400a7a0:	4b0c      	ldr	r3, [pc, #48]	; (2400a7d4 <HAL_I2C_Mem_Read_IT+0x128>)
2400a7a2:	9300      	str	r3, [sp, #0]
2400a7a4:	697b      	ldr	r3, [r7, #20]
2400a7a6:	68f8      	ldr	r0, [r7, #12]
2400a7a8:	f003 fac6 	bl	2400dd38 <I2C_TransferConfig>

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2400a7ac:	68fb      	ldr	r3, [r7, #12]
2400a7ae:	2200      	movs	r2, #0
2400a7b0:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
              process unlock */

    /* Enable ERR, TC, STOP, NACK, RXI interrupt */
    /* possible to enable all of these */
    /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
    I2C_Enable_IRQ(hi2c, I2C_XFER_RX_IT);
2400a7b4:	2102      	movs	r1, #2
2400a7b6:	68f8      	ldr	r0, [r7, #12]
2400a7b8:	f003 faec 	bl	2400dd94 <I2C_Enable_IRQ>

    return HAL_OK;
2400a7bc:	2300      	movs	r3, #0
2400a7be:	e000      	b.n	2400a7c2 <HAL_I2C_Mem_Read_IT+0x116>
  }
  else
  {
    return HAL_BUSY;
2400a7c0:	2302      	movs	r3, #2
  }
}
2400a7c2:	4618      	mov	r0, r3
2400a7c4:	3718      	adds	r7, #24
2400a7c6:	46bd      	mov	sp, r7
2400a7c8:	bd80      	pop	{r7, pc}
2400a7ca:	bf00      	nop
2400a7cc:	ffff0000 	.word	0xffff0000
2400a7d0:	2400beaf 	.word	0x2400beaf
2400a7d4:	80002400 	.word	0x80002400

2400a7d8 <HAL_I2C_Mem_Write_DMA>:
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Mem_Write_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size)
{
2400a7d8:	b580      	push	{r7, lr}
2400a7da:	b08a      	sub	sp, #40	; 0x28
2400a7dc:	af02      	add	r7, sp, #8
2400a7de:	60f8      	str	r0, [r7, #12]
2400a7e0:	4608      	mov	r0, r1
2400a7e2:	4611      	mov	r1, r2
2400a7e4:	461a      	mov	r2, r3
2400a7e6:	4603      	mov	r3, r0
2400a7e8:	817b      	strh	r3, [r7, #10]
2400a7ea:	460b      	mov	r3, r1
2400a7ec:	813b      	strh	r3, [r7, #8]
2400a7ee:	4613      	mov	r3, r2
2400a7f0:	80fb      	strh	r3, [r7, #6]
  HAL_StatusTypeDef dmaxferstatus;

  /* Check the parameters */
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));

  if (hi2c->State == HAL_I2C_STATE_READY)
2400a7f2:	68fb      	ldr	r3, [r7, #12]
2400a7f4:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400a7f8:	b2db      	uxtb	r3, r3
2400a7fa:	2b20      	cmp	r3, #32
2400a7fc:	f040 80d5 	bne.w	2400a9aa <HAL_I2C_Mem_Write_DMA+0x1d2>
  {
    if ((pData == NULL) || (Size == 0U))
2400a800:	6abb      	ldr	r3, [r7, #40]	; 0x28
2400a802:	2b00      	cmp	r3, #0
2400a804:	d002      	beq.n	2400a80c <HAL_I2C_Mem_Write_DMA+0x34>
2400a806:	8dbb      	ldrh	r3, [r7, #44]	; 0x2c
2400a808:	2b00      	cmp	r3, #0
2400a80a:	d105      	bne.n	2400a818 <HAL_I2C_Mem_Write_DMA+0x40>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
2400a80c:	68fb      	ldr	r3, [r7, #12]
2400a80e:	f44f 7200 	mov.w	r2, #512	; 0x200
2400a812:	645a      	str	r2, [r3, #68]	; 0x44
      return  HAL_ERROR;
2400a814:	2301      	movs	r3, #1
2400a816:	e0c9      	b.n	2400a9ac <HAL_I2C_Mem_Write_DMA+0x1d4>
    }

    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
2400a818:	68fb      	ldr	r3, [r7, #12]
2400a81a:	681b      	ldr	r3, [r3, #0]
2400a81c:	699b      	ldr	r3, [r3, #24]
2400a81e:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
2400a822:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
2400a826:	d101      	bne.n	2400a82c <HAL_I2C_Mem_Write_DMA+0x54>
    {
      return HAL_BUSY;
2400a828:	2302      	movs	r3, #2
2400a82a:	e0bf      	b.n	2400a9ac <HAL_I2C_Mem_Write_DMA+0x1d4>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
2400a82c:	68fb      	ldr	r3, [r7, #12]
2400a82e:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400a832:	2b01      	cmp	r3, #1
2400a834:	d101      	bne.n	2400a83a <HAL_I2C_Mem_Write_DMA+0x62>
2400a836:	2302      	movs	r3, #2
2400a838:	e0b8      	b.n	2400a9ac <HAL_I2C_Mem_Write_DMA+0x1d4>
2400a83a:	68fb      	ldr	r3, [r7, #12]
2400a83c:	2201      	movs	r2, #1
2400a83e:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Init tickstart for timeout management*/
    tickstart = HAL_GetTick();
2400a842:	f7f6 f805 	bl	24000850 <HAL_GetTick>
2400a846:	61b8      	str	r0, [r7, #24]

    hi2c->State       = HAL_I2C_STATE_BUSY_TX;
2400a848:	68fb      	ldr	r3, [r7, #12]
2400a84a:	2221      	movs	r2, #33	; 0x21
2400a84c:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode        = HAL_I2C_MODE_MEM;
2400a850:	68fb      	ldr	r3, [r7, #12]
2400a852:	2240      	movs	r2, #64	; 0x40
2400a854:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
2400a858:	68fb      	ldr	r3, [r7, #12]
2400a85a:	2200      	movs	r2, #0
2400a85c:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
2400a85e:	68fb      	ldr	r3, [r7, #12]
2400a860:	6aba      	ldr	r2, [r7, #40]	; 0x28
2400a862:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
2400a864:	68fb      	ldr	r3, [r7, #12]
2400a866:	8dba      	ldrh	r2, [r7, #44]	; 0x2c
2400a868:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
2400a86a:	68fb      	ldr	r3, [r7, #12]
2400a86c:	4a51      	ldr	r2, [pc, #324]	; (2400a9b4 <HAL_I2C_Mem_Write_DMA+0x1dc>)
2400a86e:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Master_ISR_DMA;
2400a870:	68fb      	ldr	r3, [r7, #12]
2400a872:	4a51      	ldr	r2, [pc, #324]	; (2400a9b8 <HAL_I2C_Mem_Write_DMA+0x1e0>)
2400a874:	635a      	str	r2, [r3, #52]	; 0x34

    if (hi2c->XferCount > MAX_NBYTE_SIZE)
2400a876:	68fb      	ldr	r3, [r7, #12]
2400a878:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400a87a:	b29b      	uxth	r3, r3
2400a87c:	2bff      	cmp	r3, #255	; 0xff
2400a87e:	d906      	bls.n	2400a88e <HAL_I2C_Mem_Write_DMA+0xb6>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
2400a880:	68fb      	ldr	r3, [r7, #12]
2400a882:	22ff      	movs	r2, #255	; 0xff
2400a884:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_RELOAD_MODE;
2400a886:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2400a88a:	61fb      	str	r3, [r7, #28]
2400a88c:	e007      	b.n	2400a89e <HAL_I2C_Mem_Write_DMA+0xc6>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
2400a88e:	68fb      	ldr	r3, [r7, #12]
2400a890:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400a892:	b29a      	uxth	r2, r3
2400a894:	68fb      	ldr	r3, [r7, #12]
2400a896:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_AUTOEND_MODE;
2400a898:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
2400a89c:	61fb      	str	r3, [r7, #28]
    }

    /* Send Slave Address and Memory Address */
    if (I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, I2C_TIMEOUT_FLAG, tickstart) != HAL_OK)
2400a89e:	88f8      	ldrh	r0, [r7, #6]
2400a8a0:	893a      	ldrh	r2, [r7, #8]
2400a8a2:	8979      	ldrh	r1, [r7, #10]
2400a8a4:	69bb      	ldr	r3, [r7, #24]
2400a8a6:	9301      	str	r3, [sp, #4]
2400a8a8:	2319      	movs	r3, #25
2400a8aa:	9300      	str	r3, [sp, #0]
2400a8ac:	4603      	mov	r3, r0
2400a8ae:	68f8      	ldr	r0, [r7, #12]
2400a8b0:	f001 fffc 	bl	2400c8ac <I2C_RequestMemoryWrite>
2400a8b4:	4603      	mov	r3, r0
2400a8b6:	2b00      	cmp	r3, #0
2400a8b8:	d005      	beq.n	2400a8c6 <HAL_I2C_Mem_Write_DMA+0xee>
    {
      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
2400a8ba:	68fb      	ldr	r3, [r7, #12]
2400a8bc:	2200      	movs	r2, #0
2400a8be:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
2400a8c2:	2301      	movs	r3, #1
2400a8c4:	e072      	b.n	2400a9ac <HAL_I2C_Mem_Write_DMA+0x1d4>
    }


    if (hi2c->hdmatx != NULL)
2400a8c6:	68fb      	ldr	r3, [r7, #12]
2400a8c8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400a8ca:	2b00      	cmp	r3, #0
2400a8cc:	d020      	beq.n	2400a910 <HAL_I2C_Mem_Write_DMA+0x138>
    {
      /* Set the I2C DMA transfer complete callback */
      hi2c->hdmatx->XferCpltCallback = I2C_DMAMasterTransmitCplt;
2400a8ce:	68fb      	ldr	r3, [r7, #12]
2400a8d0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400a8d2:	4a3a      	ldr	r2, [pc, #232]	; (2400a9bc <HAL_I2C_Mem_Write_DMA+0x1e4>)
2400a8d4:	63da      	str	r2, [r3, #60]	; 0x3c

      /* Set the DMA error callback */
      hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
2400a8d6:	68fb      	ldr	r3, [r7, #12]
2400a8d8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400a8da:	4a39      	ldr	r2, [pc, #228]	; (2400a9c0 <HAL_I2C_Mem_Write_DMA+0x1e8>)
2400a8dc:	64da      	str	r2, [r3, #76]	; 0x4c

      /* Set the unused DMA callbacks to NULL */
      hi2c->hdmatx->XferHalfCpltCallback = NULL;
2400a8de:	68fb      	ldr	r3, [r7, #12]
2400a8e0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400a8e2:	2200      	movs	r2, #0
2400a8e4:	641a      	str	r2, [r3, #64]	; 0x40
      hi2c->hdmatx->XferAbortCallback = NULL;
2400a8e6:	68fb      	ldr	r3, [r7, #12]
2400a8e8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400a8ea:	2200      	movs	r2, #0
2400a8ec:	651a      	str	r2, [r3, #80]	; 0x50

      /* Enable the DMA stream or channel depends on Instance */
      dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->TXDR, hi2c->XferSize);
2400a8ee:	68fb      	ldr	r3, [r7, #12]
2400a8f0:	6b98      	ldr	r0, [r3, #56]	; 0x38
2400a8f2:	6ab9      	ldr	r1, [r7, #40]	; 0x28
2400a8f4:	68fb      	ldr	r3, [r7, #12]
2400a8f6:	681b      	ldr	r3, [r3, #0]
2400a8f8:	3328      	adds	r3, #40	; 0x28
2400a8fa:	461a      	mov	r2, r3
2400a8fc:	68fb      	ldr	r3, [r7, #12]
2400a8fe:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400a900:	f7f7 fe24 	bl	2400254c <HAL_DMA_Start_IT>
2400a904:	4603      	mov	r3, r0
2400a906:	75fb      	strb	r3, [r7, #23]
      __HAL_UNLOCK(hi2c);

      return HAL_ERROR;
    }

    if (dmaxferstatus == HAL_OK)
2400a908:	7dfb      	ldrb	r3, [r7, #23]
2400a90a:	2b00      	cmp	r3, #0
2400a90c:	d139      	bne.n	2400a982 <HAL_I2C_Mem_Write_DMA+0x1aa>
2400a90e:	e013      	b.n	2400a938 <HAL_I2C_Mem_Write_DMA+0x160>
      hi2c->State     = HAL_I2C_STATE_READY;
2400a910:	68fb      	ldr	r3, [r7, #12]
2400a912:	2220      	movs	r2, #32
2400a914:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
      hi2c->Mode      = HAL_I2C_MODE_NONE;
2400a918:	68fb      	ldr	r3, [r7, #12]
2400a91a:	2200      	movs	r2, #0
2400a91c:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
      hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
2400a920:	68fb      	ldr	r3, [r7, #12]
2400a922:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400a924:	f043 0280 	orr.w	r2, r3, #128	; 0x80
2400a928:	68fb      	ldr	r3, [r7, #12]
2400a92a:	645a      	str	r2, [r3, #68]	; 0x44
      __HAL_UNLOCK(hi2c);
2400a92c:	68fb      	ldr	r3, [r7, #12]
2400a92e:	2200      	movs	r2, #0
2400a930:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
2400a934:	2301      	movs	r3, #1
2400a936:	e039      	b.n	2400a9ac <HAL_I2C_Mem_Write_DMA+0x1d4>
    {
      /* Send Slave Address */
      /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, I2C_NO_STARTSTOP);
2400a938:	68fb      	ldr	r3, [r7, #12]
2400a93a:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400a93c:	b2da      	uxtb	r2, r3
2400a93e:	8979      	ldrh	r1, [r7, #10]
2400a940:	2300      	movs	r3, #0
2400a942:	9300      	str	r3, [sp, #0]
2400a944:	69fb      	ldr	r3, [r7, #28]
2400a946:	68f8      	ldr	r0, [r7, #12]
2400a948:	f003 f9f6 	bl	2400dd38 <I2C_TransferConfig>

      /* Update XferCount value */
      hi2c->XferCount -= hi2c->XferSize;
2400a94c:	68fb      	ldr	r3, [r7, #12]
2400a94e:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400a950:	b29a      	uxth	r2, r3
2400a952:	68fb      	ldr	r3, [r7, #12]
2400a954:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400a956:	1ad3      	subs	r3, r2, r3
2400a958:	b29a      	uxth	r2, r3
2400a95a:	68fb      	ldr	r3, [r7, #12]
2400a95c:	855a      	strh	r2, [r3, #42]	; 0x2a

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
2400a95e:	68fb      	ldr	r3, [r7, #12]
2400a960:	2200      	movs	r2, #0
2400a962:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

      /* Note : The I2C interrupts must be enabled after unlocking current process
                to avoid the risk of I2C interrupt handle execution before current
                process unlock */
      /* Enable ERR and NACK interrupts */
      I2C_Enable_IRQ(hi2c, I2C_XFER_ERROR_IT);
2400a966:	2110      	movs	r1, #16
2400a968:	68f8      	ldr	r0, [r7, #12]
2400a96a:	f003 fa13 	bl	2400dd94 <I2C_Enable_IRQ>

      /* Enable DMA Request */
      hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN;
2400a96e:	68fb      	ldr	r3, [r7, #12]
2400a970:	681b      	ldr	r3, [r3, #0]
2400a972:	681a      	ldr	r2, [r3, #0]
2400a974:	68fb      	ldr	r3, [r7, #12]
2400a976:	681b      	ldr	r3, [r3, #0]
2400a978:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
2400a97c:	601a      	str	r2, [r3, #0]
      __HAL_UNLOCK(hi2c);

      return HAL_ERROR;
    }

    return HAL_OK;
2400a97e:	2300      	movs	r3, #0
2400a980:	e014      	b.n	2400a9ac <HAL_I2C_Mem_Write_DMA+0x1d4>
      hi2c->State     = HAL_I2C_STATE_READY;
2400a982:	68fb      	ldr	r3, [r7, #12]
2400a984:	2220      	movs	r2, #32
2400a986:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
      hi2c->Mode      = HAL_I2C_MODE_NONE;
2400a98a:	68fb      	ldr	r3, [r7, #12]
2400a98c:	2200      	movs	r2, #0
2400a98e:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
      hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
2400a992:	68fb      	ldr	r3, [r7, #12]
2400a994:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400a996:	f043 0210 	orr.w	r2, r3, #16
2400a99a:	68fb      	ldr	r3, [r7, #12]
2400a99c:	645a      	str	r2, [r3, #68]	; 0x44
      __HAL_UNLOCK(hi2c);
2400a99e:	68fb      	ldr	r3, [r7, #12]
2400a9a0:	2200      	movs	r2, #0
2400a9a2:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
2400a9a6:	2301      	movs	r3, #1
2400a9a8:	e000      	b.n	2400a9ac <HAL_I2C_Mem_Write_DMA+0x1d4>
  }
  else
  {
    return HAL_BUSY;
2400a9aa:	2302      	movs	r3, #2
  }
}
2400a9ac:	4618      	mov	r0, r3
2400a9ae:	3720      	adds	r7, #32
2400a9b0:	46bd      	mov	sp, r7
2400a9b2:	bd80      	pop	{r7, pc}
2400a9b4:	ffff0000 	.word	0xffff0000
2400a9b8:	2400c307 	.word	0x2400c307
2400a9bc:	2400d49f 	.word	0x2400d49f
2400a9c0:	2400d771 	.word	0x2400d771

2400a9c4 <HAL_I2C_Mem_Read_DMA>:
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be read
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Mem_Read_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size)
{
2400a9c4:	b580      	push	{r7, lr}
2400a9c6:	b08a      	sub	sp, #40	; 0x28
2400a9c8:	af02      	add	r7, sp, #8
2400a9ca:	60f8      	str	r0, [r7, #12]
2400a9cc:	4608      	mov	r0, r1
2400a9ce:	4611      	mov	r1, r2
2400a9d0:	461a      	mov	r2, r3
2400a9d2:	4603      	mov	r3, r0
2400a9d4:	817b      	strh	r3, [r7, #10]
2400a9d6:	460b      	mov	r3, r1
2400a9d8:	813b      	strh	r3, [r7, #8]
2400a9da:	4613      	mov	r3, r2
2400a9dc:	80fb      	strh	r3, [r7, #6]
  HAL_StatusTypeDef dmaxferstatus;

  /* Check the parameters */
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));

  if (hi2c->State == HAL_I2C_STATE_READY)
2400a9de:	68fb      	ldr	r3, [r7, #12]
2400a9e0:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400a9e4:	b2db      	uxtb	r3, r3
2400a9e6:	2b20      	cmp	r3, #32
2400a9e8:	f040 80d5 	bne.w	2400ab96 <HAL_I2C_Mem_Read_DMA+0x1d2>
  {
    if ((pData == NULL) || (Size == 0U))
2400a9ec:	6abb      	ldr	r3, [r7, #40]	; 0x28
2400a9ee:	2b00      	cmp	r3, #0
2400a9f0:	d002      	beq.n	2400a9f8 <HAL_I2C_Mem_Read_DMA+0x34>
2400a9f2:	8dbb      	ldrh	r3, [r7, #44]	; 0x2c
2400a9f4:	2b00      	cmp	r3, #0
2400a9f6:	d105      	bne.n	2400aa04 <HAL_I2C_Mem_Read_DMA+0x40>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
2400a9f8:	68fb      	ldr	r3, [r7, #12]
2400a9fa:	f44f 7200 	mov.w	r2, #512	; 0x200
2400a9fe:	645a      	str	r2, [r3, #68]	; 0x44
      return  HAL_ERROR;
2400aa00:	2301      	movs	r3, #1
2400aa02:	e0c9      	b.n	2400ab98 <HAL_I2C_Mem_Read_DMA+0x1d4>
    }

    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
2400aa04:	68fb      	ldr	r3, [r7, #12]
2400aa06:	681b      	ldr	r3, [r3, #0]
2400aa08:	699b      	ldr	r3, [r3, #24]
2400aa0a:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
2400aa0e:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
2400aa12:	d101      	bne.n	2400aa18 <HAL_I2C_Mem_Read_DMA+0x54>
    {
      return HAL_BUSY;
2400aa14:	2302      	movs	r3, #2
2400aa16:	e0bf      	b.n	2400ab98 <HAL_I2C_Mem_Read_DMA+0x1d4>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
2400aa18:	68fb      	ldr	r3, [r7, #12]
2400aa1a:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400aa1e:	2b01      	cmp	r3, #1
2400aa20:	d101      	bne.n	2400aa26 <HAL_I2C_Mem_Read_DMA+0x62>
2400aa22:	2302      	movs	r3, #2
2400aa24:	e0b8      	b.n	2400ab98 <HAL_I2C_Mem_Read_DMA+0x1d4>
2400aa26:	68fb      	ldr	r3, [r7, #12]
2400aa28:	2201      	movs	r2, #1
2400aa2a:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Init tickstart for timeout management*/
    tickstart = HAL_GetTick();
2400aa2e:	f7f5 ff0f 	bl	24000850 <HAL_GetTick>
2400aa32:	61b8      	str	r0, [r7, #24]

    hi2c->State       = HAL_I2C_STATE_BUSY_RX;
2400aa34:	68fb      	ldr	r3, [r7, #12]
2400aa36:	2222      	movs	r2, #34	; 0x22
2400aa38:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode        = HAL_I2C_MODE_MEM;
2400aa3c:	68fb      	ldr	r3, [r7, #12]
2400aa3e:	2240      	movs	r2, #64	; 0x40
2400aa40:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
2400aa44:	68fb      	ldr	r3, [r7, #12]
2400aa46:	2200      	movs	r2, #0
2400aa48:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
2400aa4a:	68fb      	ldr	r3, [r7, #12]
2400aa4c:	6aba      	ldr	r2, [r7, #40]	; 0x28
2400aa4e:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
2400aa50:	68fb      	ldr	r3, [r7, #12]
2400aa52:	8dba      	ldrh	r2, [r7, #44]	; 0x2c
2400aa54:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
2400aa56:	68fb      	ldr	r3, [r7, #12]
2400aa58:	4a51      	ldr	r2, [pc, #324]	; (2400aba0 <HAL_I2C_Mem_Read_DMA+0x1dc>)
2400aa5a:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Master_ISR_DMA;
2400aa5c:	68fb      	ldr	r3, [r7, #12]
2400aa5e:	4a51      	ldr	r2, [pc, #324]	; (2400aba4 <HAL_I2C_Mem_Read_DMA+0x1e0>)
2400aa60:	635a      	str	r2, [r3, #52]	; 0x34

    if (hi2c->XferCount > MAX_NBYTE_SIZE)
2400aa62:	68fb      	ldr	r3, [r7, #12]
2400aa64:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400aa66:	b29b      	uxth	r3, r3
2400aa68:	2bff      	cmp	r3, #255	; 0xff
2400aa6a:	d906      	bls.n	2400aa7a <HAL_I2C_Mem_Read_DMA+0xb6>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
2400aa6c:	68fb      	ldr	r3, [r7, #12]
2400aa6e:	22ff      	movs	r2, #255	; 0xff
2400aa70:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_RELOAD_MODE;
2400aa72:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2400aa76:	61fb      	str	r3, [r7, #28]
2400aa78:	e007      	b.n	2400aa8a <HAL_I2C_Mem_Read_DMA+0xc6>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
2400aa7a:	68fb      	ldr	r3, [r7, #12]
2400aa7c:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400aa7e:	b29a      	uxth	r2, r3
2400aa80:	68fb      	ldr	r3, [r7, #12]
2400aa82:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_AUTOEND_MODE;
2400aa84:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
2400aa88:	61fb      	str	r3, [r7, #28]
    }

    /* Send Slave Address and Memory Address */
    if (I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, I2C_TIMEOUT_FLAG, tickstart) != HAL_OK)
2400aa8a:	88f8      	ldrh	r0, [r7, #6]
2400aa8c:	893a      	ldrh	r2, [r7, #8]
2400aa8e:	8979      	ldrh	r1, [r7, #10]
2400aa90:	69bb      	ldr	r3, [r7, #24]
2400aa92:	9301      	str	r3, [sp, #4]
2400aa94:	2319      	movs	r3, #25
2400aa96:	9300      	str	r3, [sp, #0]
2400aa98:	4603      	mov	r3, r0
2400aa9a:	68f8      	ldr	r0, [r7, #12]
2400aa9c:	f001 ff5a 	bl	2400c954 <I2C_RequestMemoryRead>
2400aaa0:	4603      	mov	r3, r0
2400aaa2:	2b00      	cmp	r3, #0
2400aaa4:	d005      	beq.n	2400aab2 <HAL_I2C_Mem_Read_DMA+0xee>
    {
      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
2400aaa6:	68fb      	ldr	r3, [r7, #12]
2400aaa8:	2200      	movs	r2, #0
2400aaaa:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
2400aaae:	2301      	movs	r3, #1
2400aab0:	e072      	b.n	2400ab98 <HAL_I2C_Mem_Read_DMA+0x1d4>
    }

    if (hi2c->hdmarx != NULL)
2400aab2:	68fb      	ldr	r3, [r7, #12]
2400aab4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400aab6:	2b00      	cmp	r3, #0
2400aab8:	d020      	beq.n	2400aafc <HAL_I2C_Mem_Read_DMA+0x138>
    {
      /* Set the I2C DMA transfer complete callback */
      hi2c->hdmarx->XferCpltCallback = I2C_DMAMasterReceiveCplt;
2400aaba:	68fb      	ldr	r3, [r7, #12]
2400aabc:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400aabe:	4a3a      	ldr	r2, [pc, #232]	; (2400aba8 <HAL_I2C_Mem_Read_DMA+0x1e4>)
2400aac0:	63da      	str	r2, [r3, #60]	; 0x3c

      /* Set the DMA error callback */
      hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
2400aac2:	68fb      	ldr	r3, [r7, #12]
2400aac4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400aac6:	4a39      	ldr	r2, [pc, #228]	; (2400abac <HAL_I2C_Mem_Read_DMA+0x1e8>)
2400aac8:	64da      	str	r2, [r3, #76]	; 0x4c

      /* Set the unused DMA callbacks to NULL */
      hi2c->hdmarx->XferHalfCpltCallback = NULL;
2400aaca:	68fb      	ldr	r3, [r7, #12]
2400aacc:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400aace:	2200      	movs	r2, #0
2400aad0:	641a      	str	r2, [r3, #64]	; 0x40
      hi2c->hdmarx->XferAbortCallback = NULL;
2400aad2:	68fb      	ldr	r3, [r7, #12]
2400aad4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400aad6:	2200      	movs	r2, #0
2400aad8:	651a      	str	r2, [r3, #80]	; 0x50

      /* Enable the DMA stream or channel depends on Instance */
      dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)pData, hi2c->XferSize);
2400aada:	68fb      	ldr	r3, [r7, #12]
2400aadc:	6bd8      	ldr	r0, [r3, #60]	; 0x3c
2400aade:	68fb      	ldr	r3, [r7, #12]
2400aae0:	681b      	ldr	r3, [r3, #0]
2400aae2:	3324      	adds	r3, #36	; 0x24
2400aae4:	4619      	mov	r1, r3
2400aae6:	6aba      	ldr	r2, [r7, #40]	; 0x28
2400aae8:	68fb      	ldr	r3, [r7, #12]
2400aaea:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400aaec:	f7f7 fd2e 	bl	2400254c <HAL_DMA_Start_IT>
2400aaf0:	4603      	mov	r3, r0
2400aaf2:	75fb      	strb	r3, [r7, #23]
      __HAL_UNLOCK(hi2c);

      return HAL_ERROR;
    }

    if (dmaxferstatus == HAL_OK)
2400aaf4:	7dfb      	ldrb	r3, [r7, #23]
2400aaf6:	2b00      	cmp	r3, #0
2400aaf8:	d139      	bne.n	2400ab6e <HAL_I2C_Mem_Read_DMA+0x1aa>
2400aafa:	e013      	b.n	2400ab24 <HAL_I2C_Mem_Read_DMA+0x160>
      hi2c->State     = HAL_I2C_STATE_READY;
2400aafc:	68fb      	ldr	r3, [r7, #12]
2400aafe:	2220      	movs	r2, #32
2400ab00:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
      hi2c->Mode      = HAL_I2C_MODE_NONE;
2400ab04:	68fb      	ldr	r3, [r7, #12]
2400ab06:	2200      	movs	r2, #0
2400ab08:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
      hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
2400ab0c:	68fb      	ldr	r3, [r7, #12]
2400ab0e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400ab10:	f043 0280 	orr.w	r2, r3, #128	; 0x80
2400ab14:	68fb      	ldr	r3, [r7, #12]
2400ab16:	645a      	str	r2, [r3, #68]	; 0x44
      __HAL_UNLOCK(hi2c);
2400ab18:	68fb      	ldr	r3, [r7, #12]
2400ab1a:	2200      	movs	r2, #0
2400ab1c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
2400ab20:	2301      	movs	r3, #1
2400ab22:	e039      	b.n	2400ab98 <HAL_I2C_Mem_Read_DMA+0x1d4>
    {
      /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, I2C_GENERATE_START_READ);
2400ab24:	68fb      	ldr	r3, [r7, #12]
2400ab26:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400ab28:	b2da      	uxtb	r2, r3
2400ab2a:	8979      	ldrh	r1, [r7, #10]
2400ab2c:	4b20      	ldr	r3, [pc, #128]	; (2400abb0 <HAL_I2C_Mem_Read_DMA+0x1ec>)
2400ab2e:	9300      	str	r3, [sp, #0]
2400ab30:	69fb      	ldr	r3, [r7, #28]
2400ab32:	68f8      	ldr	r0, [r7, #12]
2400ab34:	f003 f900 	bl	2400dd38 <I2C_TransferConfig>

      /* Update XferCount value */
      hi2c->XferCount -= hi2c->XferSize;
2400ab38:	68fb      	ldr	r3, [r7, #12]
2400ab3a:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400ab3c:	b29a      	uxth	r2, r3
2400ab3e:	68fb      	ldr	r3, [r7, #12]
2400ab40:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400ab42:	1ad3      	subs	r3, r2, r3
2400ab44:	b29a      	uxth	r2, r3
2400ab46:	68fb      	ldr	r3, [r7, #12]
2400ab48:	855a      	strh	r2, [r3, #42]	; 0x2a

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
2400ab4a:	68fb      	ldr	r3, [r7, #12]
2400ab4c:	2200      	movs	r2, #0
2400ab4e:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

      /* Note : The I2C interrupts must be enabled after unlocking current process
                to avoid the risk of I2C interrupt handle execution before current
                process unlock */
      /* Enable ERR and NACK interrupts */
      I2C_Enable_IRQ(hi2c, I2C_XFER_ERROR_IT);
2400ab52:	2110      	movs	r1, #16
2400ab54:	68f8      	ldr	r0, [r7, #12]
2400ab56:	f003 f91d 	bl	2400dd94 <I2C_Enable_IRQ>

      /* Enable DMA Request */
      hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;
2400ab5a:	68fb      	ldr	r3, [r7, #12]
2400ab5c:	681b      	ldr	r3, [r3, #0]
2400ab5e:	681a      	ldr	r2, [r3, #0]
2400ab60:	68fb      	ldr	r3, [r7, #12]
2400ab62:	681b      	ldr	r3, [r3, #0]
2400ab64:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
2400ab68:	601a      	str	r2, [r3, #0]
      __HAL_UNLOCK(hi2c);

      return HAL_ERROR;
    }

    return HAL_OK;
2400ab6a:	2300      	movs	r3, #0
2400ab6c:	e014      	b.n	2400ab98 <HAL_I2C_Mem_Read_DMA+0x1d4>
      hi2c->State     = HAL_I2C_STATE_READY;
2400ab6e:	68fb      	ldr	r3, [r7, #12]
2400ab70:	2220      	movs	r2, #32
2400ab72:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
      hi2c->Mode      = HAL_I2C_MODE_NONE;
2400ab76:	68fb      	ldr	r3, [r7, #12]
2400ab78:	2200      	movs	r2, #0
2400ab7a:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
      hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
2400ab7e:	68fb      	ldr	r3, [r7, #12]
2400ab80:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400ab82:	f043 0210 	orr.w	r2, r3, #16
2400ab86:	68fb      	ldr	r3, [r7, #12]
2400ab88:	645a      	str	r2, [r3, #68]	; 0x44
      __HAL_UNLOCK(hi2c);
2400ab8a:	68fb      	ldr	r3, [r7, #12]
2400ab8c:	2200      	movs	r2, #0
2400ab8e:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
2400ab92:	2301      	movs	r3, #1
2400ab94:	e000      	b.n	2400ab98 <HAL_I2C_Mem_Read_DMA+0x1d4>
  }
  else
  {
    return HAL_BUSY;
2400ab96:	2302      	movs	r3, #2
  }
}
2400ab98:	4618      	mov	r0, r3
2400ab9a:	3720      	adds	r7, #32
2400ab9c:	46bd      	mov	sp, r7
2400ab9e:	bd80      	pop	{r7, pc}
2400aba0:	ffff0000 	.word	0xffff0000
2400aba4:	2400c307 	.word	0x2400c307
2400aba8:	2400d575 	.word	0x2400d575
2400abac:	2400d771 	.word	0x2400d771
2400abb0:	80002400 	.word	0x80002400

2400abb4 <HAL_I2C_IsDeviceReady>:
  * @param  Trials Number of trials
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_IsDeviceReady(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint32_t Trials, uint32_t Timeout)
{
2400abb4:	b580      	push	{r7, lr}
2400abb6:	b08a      	sub	sp, #40	; 0x28
2400abb8:	af02      	add	r7, sp, #8
2400abba:	60f8      	str	r0, [r7, #12]
2400abbc:	607a      	str	r2, [r7, #4]
2400abbe:	603b      	str	r3, [r7, #0]
2400abc0:	460b      	mov	r3, r1
2400abc2:	817b      	strh	r3, [r7, #10]
  uint32_t tickstart;

  __IO uint32_t I2C_Trials = 0UL;
2400abc4:	2300      	movs	r3, #0
2400abc6:	617b      	str	r3, [r7, #20]

  FlagStatus tmp1;
  FlagStatus tmp2;

  if (hi2c->State == HAL_I2C_STATE_READY)
2400abc8:	68fb      	ldr	r3, [r7, #12]
2400abca:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400abce:	b2db      	uxtb	r3, r3
2400abd0:	2b20      	cmp	r3, #32
2400abd2:	f040 80ef 	bne.w	2400adb4 <HAL_I2C_IsDeviceReady+0x200>
  {
    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
2400abd6:	68fb      	ldr	r3, [r7, #12]
2400abd8:	681b      	ldr	r3, [r3, #0]
2400abda:	699b      	ldr	r3, [r3, #24]
2400abdc:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
2400abe0:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
2400abe4:	d101      	bne.n	2400abea <HAL_I2C_IsDeviceReady+0x36>
    {
      return HAL_BUSY;
2400abe6:	2302      	movs	r3, #2
2400abe8:	e0e5      	b.n	2400adb6 <HAL_I2C_IsDeviceReady+0x202>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
2400abea:	68fb      	ldr	r3, [r7, #12]
2400abec:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400abf0:	2b01      	cmp	r3, #1
2400abf2:	d101      	bne.n	2400abf8 <HAL_I2C_IsDeviceReady+0x44>
2400abf4:	2302      	movs	r3, #2
2400abf6:	e0de      	b.n	2400adb6 <HAL_I2C_IsDeviceReady+0x202>
2400abf8:	68fb      	ldr	r3, [r7, #12]
2400abfa:	2201      	movs	r2, #1
2400abfc:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State = HAL_I2C_STATE_BUSY;
2400ac00:	68fb      	ldr	r3, [r7, #12]
2400ac02:	2224      	movs	r2, #36	; 0x24
2400ac04:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
2400ac08:	68fb      	ldr	r3, [r7, #12]
2400ac0a:	2200      	movs	r2, #0
2400ac0c:	645a      	str	r2, [r3, #68]	; 0x44

    do
    {
      /* Generate Start */
      hi2c->Instance->CR2 = I2C_GENERATE_START(hi2c->Init.AddressingMode, DevAddress);
2400ac0e:	68fb      	ldr	r3, [r7, #12]
2400ac10:	68db      	ldr	r3, [r3, #12]
2400ac12:	2b01      	cmp	r3, #1
2400ac14:	d105      	bne.n	2400ac22 <HAL_I2C_IsDeviceReady+0x6e>
2400ac16:	897b      	ldrh	r3, [r7, #10]
2400ac18:	f3c3 0209 	ubfx	r2, r3, #0, #10
2400ac1c:	4b68      	ldr	r3, [pc, #416]	; (2400adc0 <HAL_I2C_IsDeviceReady+0x20c>)
2400ac1e:	4313      	orrs	r3, r2
2400ac20:	e004      	b.n	2400ac2c <HAL_I2C_IsDeviceReady+0x78>
2400ac22:	897b      	ldrh	r3, [r7, #10]
2400ac24:	f3c3 0309 	ubfx	r3, r3, #0, #10
2400ac28:	f443 5320 	orr.w	r3, r3, #10240	; 0x2800
2400ac2c:	68fa      	ldr	r2, [r7, #12]
2400ac2e:	6812      	ldr	r2, [r2, #0]
2400ac30:	6053      	str	r3, [r2, #4]

      /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
      /* Wait until STOPF flag is set or a NACK flag is set*/
      tickstart = HAL_GetTick();
2400ac32:	f7f5 fe0d 	bl	24000850 <HAL_GetTick>
2400ac36:	61b8      	str	r0, [r7, #24]

      tmp1 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF);
2400ac38:	68fb      	ldr	r3, [r7, #12]
2400ac3a:	681b      	ldr	r3, [r3, #0]
2400ac3c:	699b      	ldr	r3, [r3, #24]
2400ac3e:	f003 0320 	and.w	r3, r3, #32
2400ac42:	2b20      	cmp	r3, #32
2400ac44:	bf0c      	ite	eq
2400ac46:	2301      	moveq	r3, #1
2400ac48:	2300      	movne	r3, #0
2400ac4a:	b2db      	uxtb	r3, r3
2400ac4c:	77fb      	strb	r3, [r7, #31]
      tmp2 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF);
2400ac4e:	68fb      	ldr	r3, [r7, #12]
2400ac50:	681b      	ldr	r3, [r3, #0]
2400ac52:	699b      	ldr	r3, [r3, #24]
2400ac54:	f003 0310 	and.w	r3, r3, #16
2400ac58:	2b10      	cmp	r3, #16
2400ac5a:	bf0c      	ite	eq
2400ac5c:	2301      	moveq	r3, #1
2400ac5e:	2300      	movne	r3, #0
2400ac60:	b2db      	uxtb	r3, r3
2400ac62:	77bb      	strb	r3, [r7, #30]

      while ((tmp1 == RESET) && (tmp2 == RESET))
2400ac64:	e034      	b.n	2400acd0 <HAL_I2C_IsDeviceReady+0x11c>
      {
        if (Timeout != HAL_MAX_DELAY)
2400ac66:	683b      	ldr	r3, [r7, #0]
2400ac68:	f1b3 3fff 	cmp.w	r3, #4294967295
2400ac6c:	d01a      	beq.n	2400aca4 <HAL_I2C_IsDeviceReady+0xf0>
        {
          if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
2400ac6e:	f7f5 fdef 	bl	24000850 <HAL_GetTick>
2400ac72:	4602      	mov	r2, r0
2400ac74:	69bb      	ldr	r3, [r7, #24]
2400ac76:	1ad3      	subs	r3, r2, r3
2400ac78:	683a      	ldr	r2, [r7, #0]
2400ac7a:	429a      	cmp	r2, r3
2400ac7c:	d302      	bcc.n	2400ac84 <HAL_I2C_IsDeviceReady+0xd0>
2400ac7e:	683b      	ldr	r3, [r7, #0]
2400ac80:	2b00      	cmp	r3, #0
2400ac82:	d10f      	bne.n	2400aca4 <HAL_I2C_IsDeviceReady+0xf0>
          {
            /* Update I2C state */
            hi2c->State = HAL_I2C_STATE_READY;
2400ac84:	68fb      	ldr	r3, [r7, #12]
2400ac86:	2220      	movs	r2, #32
2400ac88:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

            /* Update I2C error code */
            hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
2400ac8c:	68fb      	ldr	r3, [r7, #12]
2400ac8e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400ac90:	f043 0220 	orr.w	r2, r3, #32
2400ac94:	68fb      	ldr	r3, [r7, #12]
2400ac96:	645a      	str	r2, [r3, #68]	; 0x44

            /* Process Unlocked */
            __HAL_UNLOCK(hi2c);
2400ac98:	68fb      	ldr	r3, [r7, #12]
2400ac9a:	2200      	movs	r2, #0
2400ac9c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

            return HAL_ERROR;
2400aca0:	2301      	movs	r3, #1
2400aca2:	e088      	b.n	2400adb6 <HAL_I2C_IsDeviceReady+0x202>
          }
        }

        tmp1 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF);
2400aca4:	68fb      	ldr	r3, [r7, #12]
2400aca6:	681b      	ldr	r3, [r3, #0]
2400aca8:	699b      	ldr	r3, [r3, #24]
2400acaa:	f003 0320 	and.w	r3, r3, #32
2400acae:	2b20      	cmp	r3, #32
2400acb0:	bf0c      	ite	eq
2400acb2:	2301      	moveq	r3, #1
2400acb4:	2300      	movne	r3, #0
2400acb6:	b2db      	uxtb	r3, r3
2400acb8:	77fb      	strb	r3, [r7, #31]
        tmp2 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF);
2400acba:	68fb      	ldr	r3, [r7, #12]
2400acbc:	681b      	ldr	r3, [r3, #0]
2400acbe:	699b      	ldr	r3, [r3, #24]
2400acc0:	f003 0310 	and.w	r3, r3, #16
2400acc4:	2b10      	cmp	r3, #16
2400acc6:	bf0c      	ite	eq
2400acc8:	2301      	moveq	r3, #1
2400acca:	2300      	movne	r3, #0
2400accc:	b2db      	uxtb	r3, r3
2400acce:	77bb      	strb	r3, [r7, #30]
      while ((tmp1 == RESET) && (tmp2 == RESET))
2400acd0:	7ffb      	ldrb	r3, [r7, #31]
2400acd2:	2b00      	cmp	r3, #0
2400acd4:	d102      	bne.n	2400acdc <HAL_I2C_IsDeviceReady+0x128>
2400acd6:	7fbb      	ldrb	r3, [r7, #30]
2400acd8:	2b00      	cmp	r3, #0
2400acda:	d0c4      	beq.n	2400ac66 <HAL_I2C_IsDeviceReady+0xb2>
      }

      /* Check if the NACKF flag has not been set */
      if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == RESET)
2400acdc:	68fb      	ldr	r3, [r7, #12]
2400acde:	681b      	ldr	r3, [r3, #0]
2400ace0:	699b      	ldr	r3, [r3, #24]
2400ace2:	f003 0310 	and.w	r3, r3, #16
2400ace6:	2b10      	cmp	r3, #16
2400ace8:	d01a      	beq.n	2400ad20 <HAL_I2C_IsDeviceReady+0x16c>
      {
        /* Wait until STOPF flag is reset */
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_STOPF, RESET, Timeout, tickstart) != HAL_OK)
2400acea:	69bb      	ldr	r3, [r7, #24]
2400acec:	9300      	str	r3, [sp, #0]
2400acee:	683b      	ldr	r3, [r7, #0]
2400acf0:	2200      	movs	r2, #0
2400acf2:	2120      	movs	r1, #32
2400acf4:	68f8      	ldr	r0, [r7, #12]
2400acf6:	f002 fe91 	bl	2400da1c <I2C_WaitOnFlagUntilTimeout>
2400acfa:	4603      	mov	r3, r0
2400acfc:	2b00      	cmp	r3, #0
2400acfe:	d001      	beq.n	2400ad04 <HAL_I2C_IsDeviceReady+0x150>
        {
          return HAL_ERROR;
2400ad00:	2301      	movs	r3, #1
2400ad02:	e058      	b.n	2400adb6 <HAL_I2C_IsDeviceReady+0x202>
        }

        /* Clear STOP Flag */
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
2400ad04:	68fb      	ldr	r3, [r7, #12]
2400ad06:	681b      	ldr	r3, [r3, #0]
2400ad08:	2220      	movs	r2, #32
2400ad0a:	61da      	str	r2, [r3, #28]

        /* Device is ready */
        hi2c->State = HAL_I2C_STATE_READY;
2400ad0c:	68fb      	ldr	r3, [r7, #12]
2400ad0e:	2220      	movs	r2, #32
2400ad10:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
2400ad14:	68fb      	ldr	r3, [r7, #12]
2400ad16:	2200      	movs	r2, #0
2400ad18:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

        return HAL_OK;
2400ad1c:	2300      	movs	r3, #0
2400ad1e:	e04a      	b.n	2400adb6 <HAL_I2C_IsDeviceReady+0x202>
      }
      else
      {
        /* Wait until STOPF flag is reset */
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_STOPF, RESET, Timeout, tickstart) != HAL_OK)
2400ad20:	69bb      	ldr	r3, [r7, #24]
2400ad22:	9300      	str	r3, [sp, #0]
2400ad24:	683b      	ldr	r3, [r7, #0]
2400ad26:	2200      	movs	r2, #0
2400ad28:	2120      	movs	r1, #32
2400ad2a:	68f8      	ldr	r0, [r7, #12]
2400ad2c:	f002 fe76 	bl	2400da1c <I2C_WaitOnFlagUntilTimeout>
2400ad30:	4603      	mov	r3, r0
2400ad32:	2b00      	cmp	r3, #0
2400ad34:	d001      	beq.n	2400ad3a <HAL_I2C_IsDeviceReady+0x186>
        {
          return HAL_ERROR;
2400ad36:	2301      	movs	r3, #1
2400ad38:	e03d      	b.n	2400adb6 <HAL_I2C_IsDeviceReady+0x202>
        }

        /* Clear NACK Flag */
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
2400ad3a:	68fb      	ldr	r3, [r7, #12]
2400ad3c:	681b      	ldr	r3, [r3, #0]
2400ad3e:	2210      	movs	r2, #16
2400ad40:	61da      	str	r2, [r3, #28]

        /* Clear STOP Flag, auto generated with autoend*/
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
2400ad42:	68fb      	ldr	r3, [r7, #12]
2400ad44:	681b      	ldr	r3, [r3, #0]
2400ad46:	2220      	movs	r2, #32
2400ad48:	61da      	str	r2, [r3, #28]
      }

      /* Check if the maximum allowed number of trials has been reached */
      if (I2C_Trials == Trials)
2400ad4a:	697b      	ldr	r3, [r7, #20]
2400ad4c:	687a      	ldr	r2, [r7, #4]
2400ad4e:	429a      	cmp	r2, r3
2400ad50:	d118      	bne.n	2400ad84 <HAL_I2C_IsDeviceReady+0x1d0>
      {
        /* Generate Stop */
        hi2c->Instance->CR2 |= I2C_CR2_STOP;
2400ad52:	68fb      	ldr	r3, [r7, #12]
2400ad54:	681b      	ldr	r3, [r3, #0]
2400ad56:	685a      	ldr	r2, [r3, #4]
2400ad58:	68fb      	ldr	r3, [r7, #12]
2400ad5a:	681b      	ldr	r3, [r3, #0]
2400ad5c:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
2400ad60:	605a      	str	r2, [r3, #4]

        /* Wait until STOPF flag is reset */
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_STOPF, RESET, Timeout, tickstart) != HAL_OK)
2400ad62:	69bb      	ldr	r3, [r7, #24]
2400ad64:	9300      	str	r3, [sp, #0]
2400ad66:	683b      	ldr	r3, [r7, #0]
2400ad68:	2200      	movs	r2, #0
2400ad6a:	2120      	movs	r1, #32
2400ad6c:	68f8      	ldr	r0, [r7, #12]
2400ad6e:	f002 fe55 	bl	2400da1c <I2C_WaitOnFlagUntilTimeout>
2400ad72:	4603      	mov	r3, r0
2400ad74:	2b00      	cmp	r3, #0
2400ad76:	d001      	beq.n	2400ad7c <HAL_I2C_IsDeviceReady+0x1c8>
        {
          return HAL_ERROR;
2400ad78:	2301      	movs	r3, #1
2400ad7a:	e01c      	b.n	2400adb6 <HAL_I2C_IsDeviceReady+0x202>
        }

        /* Clear STOP Flag */
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
2400ad7c:	68fb      	ldr	r3, [r7, #12]
2400ad7e:	681b      	ldr	r3, [r3, #0]
2400ad80:	2220      	movs	r2, #32
2400ad82:	61da      	str	r2, [r3, #28]
      }

      /* Increment Trials */
      I2C_Trials++;
2400ad84:	697b      	ldr	r3, [r7, #20]
2400ad86:	3301      	adds	r3, #1
2400ad88:	617b      	str	r3, [r7, #20]
    }
    while (I2C_Trials < Trials);
2400ad8a:	697b      	ldr	r3, [r7, #20]
2400ad8c:	687a      	ldr	r2, [r7, #4]
2400ad8e:	429a      	cmp	r2, r3
2400ad90:	f63f af3d 	bhi.w	2400ac0e <HAL_I2C_IsDeviceReady+0x5a>

    /* Update I2C state */
    hi2c->State = HAL_I2C_STATE_READY;
2400ad94:	68fb      	ldr	r3, [r7, #12]
2400ad96:	2220      	movs	r2, #32
2400ad98:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Update I2C error code */
    hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
2400ad9c:	68fb      	ldr	r3, [r7, #12]
2400ad9e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400ada0:	f043 0220 	orr.w	r2, r3, #32
2400ada4:	68fb      	ldr	r3, [r7, #12]
2400ada6:	645a      	str	r2, [r3, #68]	; 0x44

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2400ada8:	68fb      	ldr	r3, [r7, #12]
2400adaa:	2200      	movs	r2, #0
2400adac:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    return HAL_ERROR;
2400adb0:	2301      	movs	r3, #1
2400adb2:	e000      	b.n	2400adb6 <HAL_I2C_IsDeviceReady+0x202>
  }
  else
  {
    return HAL_BUSY;
2400adb4:	2302      	movs	r3, #2
  }
}
2400adb6:	4618      	mov	r0, r3
2400adb8:	3720      	adds	r7, #32
2400adba:	46bd      	mov	sp, r7
2400adbc:	bd80      	pop	{r7, pc}
2400adbe:	bf00      	nop
2400adc0:	02002000 	.word	0x02002000

2400adc4 <HAL_I2C_Master_Seq_Transmit_IT>:
  * @param  Size Amount of data to be sent
  * @param  XferOptions Options of Transfer, value of @ref I2C_XFEROPTIONS
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Master_Seq_Transmit_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t XferOptions)
{
2400adc4:	b580      	push	{r7, lr}
2400adc6:	b088      	sub	sp, #32
2400adc8:	af02      	add	r7, sp, #8
2400adca:	60f8      	str	r0, [r7, #12]
2400adcc:	607a      	str	r2, [r7, #4]
2400adce:	461a      	mov	r2, r3
2400add0:	460b      	mov	r3, r1
2400add2:	817b      	strh	r3, [r7, #10]
2400add4:	4613      	mov	r3, r2
2400add6:	813b      	strh	r3, [r7, #8]
  uint32_t xfermode;
  uint32_t xferrequest = I2C_GENERATE_START_WRITE;
2400add8:	4b3a      	ldr	r3, [pc, #232]	; (2400aec4 <HAL_I2C_Master_Seq_Transmit_IT+0x100>)
2400adda:	613b      	str	r3, [r7, #16]

  /* Check the parameters */
  assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));

  if (hi2c->State == HAL_I2C_STATE_READY)
2400addc:	68fb      	ldr	r3, [r7, #12]
2400adde:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400ade2:	b2db      	uxtb	r3, r3
2400ade4:	2b20      	cmp	r3, #32
2400ade6:	d167      	bne.n	2400aeb8 <HAL_I2C_Master_Seq_Transmit_IT+0xf4>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
2400ade8:	68fb      	ldr	r3, [r7, #12]
2400adea:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400adee:	2b01      	cmp	r3, #1
2400adf0:	d101      	bne.n	2400adf6 <HAL_I2C_Master_Seq_Transmit_IT+0x32>
2400adf2:	2302      	movs	r3, #2
2400adf4:	e061      	b.n	2400aeba <HAL_I2C_Master_Seq_Transmit_IT+0xf6>
2400adf6:	68fb      	ldr	r3, [r7, #12]
2400adf8:	2201      	movs	r2, #1
2400adfa:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State     = HAL_I2C_STATE_BUSY_TX;
2400adfe:	68fb      	ldr	r3, [r7, #12]
2400ae00:	2221      	movs	r2, #33	; 0x21
2400ae02:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_MASTER;
2400ae06:	68fb      	ldr	r3, [r7, #12]
2400ae08:	2210      	movs	r2, #16
2400ae0a:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
2400ae0e:	68fb      	ldr	r3, [r7, #12]
2400ae10:	2200      	movs	r2, #0
2400ae12:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
2400ae14:	68fb      	ldr	r3, [r7, #12]
2400ae16:	687a      	ldr	r2, [r7, #4]
2400ae18:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
2400ae1a:	68fb      	ldr	r3, [r7, #12]
2400ae1c:	893a      	ldrh	r2, [r7, #8]
2400ae1e:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferOptions = XferOptions;
2400ae20:	68fb      	ldr	r3, [r7, #12]
2400ae22:	6a3a      	ldr	r2, [r7, #32]
2400ae24:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Master_ISR_IT;
2400ae26:	68fb      	ldr	r3, [r7, #12]
2400ae28:	4a27      	ldr	r2, [pc, #156]	; (2400aec8 <HAL_I2C_Master_Seq_Transmit_IT+0x104>)
2400ae2a:	635a      	str	r2, [r3, #52]	; 0x34

    /* If hi2c->XferCount > MAX_NBYTE_SIZE, use reload mode */
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
2400ae2c:	68fb      	ldr	r3, [r7, #12]
2400ae2e:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400ae30:	b29b      	uxth	r3, r3
2400ae32:	2bff      	cmp	r3, #255	; 0xff
2400ae34:	d906      	bls.n	2400ae44 <HAL_I2C_Master_Seq_Transmit_IT+0x80>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
2400ae36:	68fb      	ldr	r3, [r7, #12]
2400ae38:	22ff      	movs	r2, #255	; 0xff
2400ae3a:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_RELOAD_MODE;
2400ae3c:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2400ae40:	617b      	str	r3, [r7, #20]
2400ae42:	e007      	b.n	2400ae54 <HAL_I2C_Master_Seq_Transmit_IT+0x90>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
2400ae44:	68fb      	ldr	r3, [r7, #12]
2400ae46:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400ae48:	b29a      	uxth	r2, r3
2400ae4a:	68fb      	ldr	r3, [r7, #12]
2400ae4c:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = hi2c->XferOptions;
2400ae4e:	68fb      	ldr	r3, [r7, #12]
2400ae50:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2400ae52:	617b      	str	r3, [r7, #20]
    }

    /* If transfer direction not change and there is no request to start another frame, do not generate Restart Condition */
    /* Mean Previous state is same as current state */
    if ((hi2c->PreviousState == I2C_STATE_MASTER_BUSY_TX) && (IS_I2C_TRANSFER_OTHER_OPTIONS_REQUEST(XferOptions) == 0))
2400ae54:	68fb      	ldr	r3, [r7, #12]
2400ae56:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2400ae58:	2b11      	cmp	r3, #17
2400ae5a:	d10e      	bne.n	2400ae7a <HAL_I2C_Master_Seq_Transmit_IT+0xb6>
2400ae5c:	6a3b      	ldr	r3, [r7, #32]
2400ae5e:	2baa      	cmp	r3, #170	; 0xaa
2400ae60:	d003      	beq.n	2400ae6a <HAL_I2C_Master_Seq_Transmit_IT+0xa6>
2400ae62:	6a3b      	ldr	r3, [r7, #32]
2400ae64:	f5b3 4f2a 	cmp.w	r3, #43520	; 0xaa00
2400ae68:	d101      	bne.n	2400ae6e <HAL_I2C_Master_Seq_Transmit_IT+0xaa>
2400ae6a:	2301      	movs	r3, #1
2400ae6c:	e000      	b.n	2400ae70 <HAL_I2C_Master_Seq_Transmit_IT+0xac>
2400ae6e:	2300      	movs	r3, #0
2400ae70:	2b00      	cmp	r3, #0
2400ae72:	d102      	bne.n	2400ae7a <HAL_I2C_Master_Seq_Transmit_IT+0xb6>
    {
      xferrequest = I2C_NO_STARTSTOP;
2400ae74:	2300      	movs	r3, #0
2400ae76:	613b      	str	r3, [r7, #16]
2400ae78:	e00a      	b.n	2400ae90 <HAL_I2C_Master_Seq_Transmit_IT+0xcc>
    }
    else
    {
      /* Convert OTHER_xxx XferOptions if any */
      I2C_ConvertOtherXferOptions(hi2c);
2400ae7a:	68f8      	ldr	r0, [r7, #12]
2400ae7c:	f003 f84c 	bl	2400df18 <I2C_ConvertOtherXferOptions>

      /* Update xfermode accordingly if no reload is necessary */
      if (hi2c->XferCount < MAX_NBYTE_SIZE)
2400ae80:	68fb      	ldr	r3, [r7, #12]
2400ae82:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400ae84:	b29b      	uxth	r3, r3
2400ae86:	2bfe      	cmp	r3, #254	; 0xfe
2400ae88:	d802      	bhi.n	2400ae90 <HAL_I2C_Master_Seq_Transmit_IT+0xcc>
      {
        xfermode = hi2c->XferOptions;
2400ae8a:	68fb      	ldr	r3, [r7, #12]
2400ae8c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2400ae8e:	617b      	str	r3, [r7, #20]
      }
    }

    /* Send Slave Address and set NBYTES to write */
    I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, xferrequest);
2400ae90:	68fb      	ldr	r3, [r7, #12]
2400ae92:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400ae94:	b2da      	uxtb	r2, r3
2400ae96:	8979      	ldrh	r1, [r7, #10]
2400ae98:	693b      	ldr	r3, [r7, #16]
2400ae9a:	9300      	str	r3, [sp, #0]
2400ae9c:	697b      	ldr	r3, [r7, #20]
2400ae9e:	68f8      	ldr	r0, [r7, #12]
2400aea0:	f002 ff4a 	bl	2400dd38 <I2C_TransferConfig>

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2400aea4:	68fb      	ldr	r3, [r7, #12]
2400aea6:	2200      	movs	r2, #0
2400aea8:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Note : The I2C interrupts must be enabled after unlocking current process
              to avoid the risk of I2C interrupt handle execution before current
              process unlock */
    I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT);
2400aeac:	2101      	movs	r1, #1
2400aeae:	68f8      	ldr	r0, [r7, #12]
2400aeb0:	f002 ff70 	bl	2400dd94 <I2C_Enable_IRQ>

    return HAL_OK;
2400aeb4:	2300      	movs	r3, #0
2400aeb6:	e000      	b.n	2400aeba <HAL_I2C_Master_Seq_Transmit_IT+0xf6>
  }
  else
  {
    return HAL_BUSY;
2400aeb8:	2302      	movs	r3, #2
  }
}
2400aeba:	4618      	mov	r0, r3
2400aebc:	3718      	adds	r7, #24
2400aebe:	46bd      	mov	sp, r7
2400aec0:	bd80      	pop	{r7, pc}
2400aec2:	bf00      	nop
2400aec4:	80002000 	.word	0x80002000
2400aec8:	2400beaf 	.word	0x2400beaf

2400aecc <HAL_I2C_Master_Seq_Transmit_DMA>:
  * @param  Size Amount of data to be sent
  * @param  XferOptions Options of Transfer, value of @ref I2C_XFEROPTIONS
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Master_Seq_Transmit_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t XferOptions)
{
2400aecc:	b580      	push	{r7, lr}
2400aece:	b08a      	sub	sp, #40	; 0x28
2400aed0:	af02      	add	r7, sp, #8
2400aed2:	60f8      	str	r0, [r7, #12]
2400aed4:	607a      	str	r2, [r7, #4]
2400aed6:	461a      	mov	r2, r3
2400aed8:	460b      	mov	r3, r1
2400aeda:	817b      	strh	r3, [r7, #10]
2400aedc:	4613      	mov	r3, r2
2400aede:	813b      	strh	r3, [r7, #8]
  uint32_t xfermode;
  uint32_t xferrequest = I2C_GENERATE_START_WRITE;
2400aee0:	4b77      	ldr	r3, [pc, #476]	; (2400b0c0 <HAL_I2C_Master_Seq_Transmit_DMA+0x1f4>)
2400aee2:	61bb      	str	r3, [r7, #24]
  HAL_StatusTypeDef dmaxferstatus;

  /* Check the parameters */
  assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));

  if (hi2c->State == HAL_I2C_STATE_READY)
2400aee4:	68fb      	ldr	r3, [r7, #12]
2400aee6:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400aeea:	b2db      	uxtb	r3, r3
2400aeec:	2b20      	cmp	r3, #32
2400aeee:	f040 80e1 	bne.w	2400b0b4 <HAL_I2C_Master_Seq_Transmit_DMA+0x1e8>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
2400aef2:	68fb      	ldr	r3, [r7, #12]
2400aef4:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400aef8:	2b01      	cmp	r3, #1
2400aefa:	d101      	bne.n	2400af00 <HAL_I2C_Master_Seq_Transmit_DMA+0x34>
2400aefc:	2302      	movs	r3, #2
2400aefe:	e0da      	b.n	2400b0b6 <HAL_I2C_Master_Seq_Transmit_DMA+0x1ea>
2400af00:	68fb      	ldr	r3, [r7, #12]
2400af02:	2201      	movs	r2, #1
2400af04:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State     = HAL_I2C_STATE_BUSY_TX;
2400af08:	68fb      	ldr	r3, [r7, #12]
2400af0a:	2221      	movs	r2, #33	; 0x21
2400af0c:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_MASTER;
2400af10:	68fb      	ldr	r3, [r7, #12]
2400af12:	2210      	movs	r2, #16
2400af14:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
2400af18:	68fb      	ldr	r3, [r7, #12]
2400af1a:	2200      	movs	r2, #0
2400af1c:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
2400af1e:	68fb      	ldr	r3, [r7, #12]
2400af20:	687a      	ldr	r2, [r7, #4]
2400af22:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
2400af24:	68fb      	ldr	r3, [r7, #12]
2400af26:	893a      	ldrh	r2, [r7, #8]
2400af28:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferOptions = XferOptions;
2400af2a:	68fb      	ldr	r3, [r7, #12]
2400af2c:	6aba      	ldr	r2, [r7, #40]	; 0x28
2400af2e:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Master_ISR_DMA;
2400af30:	68fb      	ldr	r3, [r7, #12]
2400af32:	4a64      	ldr	r2, [pc, #400]	; (2400b0c4 <HAL_I2C_Master_Seq_Transmit_DMA+0x1f8>)
2400af34:	635a      	str	r2, [r3, #52]	; 0x34

    /* If hi2c->XferCount > MAX_NBYTE_SIZE, use reload mode */
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
2400af36:	68fb      	ldr	r3, [r7, #12]
2400af38:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400af3a:	b29b      	uxth	r3, r3
2400af3c:	2bff      	cmp	r3, #255	; 0xff
2400af3e:	d906      	bls.n	2400af4e <HAL_I2C_Master_Seq_Transmit_DMA+0x82>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
2400af40:	68fb      	ldr	r3, [r7, #12]
2400af42:	22ff      	movs	r2, #255	; 0xff
2400af44:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_RELOAD_MODE;
2400af46:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2400af4a:	61fb      	str	r3, [r7, #28]
2400af4c:	e007      	b.n	2400af5e <HAL_I2C_Master_Seq_Transmit_DMA+0x92>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
2400af4e:	68fb      	ldr	r3, [r7, #12]
2400af50:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400af52:	b29a      	uxth	r2, r3
2400af54:	68fb      	ldr	r3, [r7, #12]
2400af56:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = hi2c->XferOptions;
2400af58:	68fb      	ldr	r3, [r7, #12]
2400af5a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2400af5c:	61fb      	str	r3, [r7, #28]
    }

    /* If transfer direction not change and there is no request to start another frame, do not generate Restart Condition */
    /* Mean Previous state is same as current state */
    if ((hi2c->PreviousState == I2C_STATE_MASTER_BUSY_TX) && (IS_I2C_TRANSFER_OTHER_OPTIONS_REQUEST(XferOptions) == 0))
2400af5e:	68fb      	ldr	r3, [r7, #12]
2400af60:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2400af62:	2b11      	cmp	r3, #17
2400af64:	d10e      	bne.n	2400af84 <HAL_I2C_Master_Seq_Transmit_DMA+0xb8>
2400af66:	6abb      	ldr	r3, [r7, #40]	; 0x28
2400af68:	2baa      	cmp	r3, #170	; 0xaa
2400af6a:	d003      	beq.n	2400af74 <HAL_I2C_Master_Seq_Transmit_DMA+0xa8>
2400af6c:	6abb      	ldr	r3, [r7, #40]	; 0x28
2400af6e:	f5b3 4f2a 	cmp.w	r3, #43520	; 0xaa00
2400af72:	d101      	bne.n	2400af78 <HAL_I2C_Master_Seq_Transmit_DMA+0xac>
2400af74:	2301      	movs	r3, #1
2400af76:	e000      	b.n	2400af7a <HAL_I2C_Master_Seq_Transmit_DMA+0xae>
2400af78:	2300      	movs	r3, #0
2400af7a:	2b00      	cmp	r3, #0
2400af7c:	d102      	bne.n	2400af84 <HAL_I2C_Master_Seq_Transmit_DMA+0xb8>
    {
      xferrequest = I2C_NO_STARTSTOP;
2400af7e:	2300      	movs	r3, #0
2400af80:	61bb      	str	r3, [r7, #24]
2400af82:	e00a      	b.n	2400af9a <HAL_I2C_Master_Seq_Transmit_DMA+0xce>
    }
    else
    {
      /* Convert OTHER_xxx XferOptions if any */
      I2C_ConvertOtherXferOptions(hi2c);
2400af84:	68f8      	ldr	r0, [r7, #12]
2400af86:	f002 ffc7 	bl	2400df18 <I2C_ConvertOtherXferOptions>

      /* Update xfermode accordingly if no reload is necessary */
      if (hi2c->XferCount < MAX_NBYTE_SIZE)
2400af8a:	68fb      	ldr	r3, [r7, #12]
2400af8c:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400af8e:	b29b      	uxth	r3, r3
2400af90:	2bfe      	cmp	r3, #254	; 0xfe
2400af92:	d802      	bhi.n	2400af9a <HAL_I2C_Master_Seq_Transmit_DMA+0xce>
      {
        xfermode = hi2c->XferOptions;
2400af94:	68fb      	ldr	r3, [r7, #12]
2400af96:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2400af98:	61fb      	str	r3, [r7, #28]
      }
    }

    if (hi2c->XferSize > 0U)
2400af9a:	68fb      	ldr	r3, [r7, #12]
2400af9c:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400af9e:	2b00      	cmp	r3, #0
2400afa0:	d070      	beq.n	2400b084 <HAL_I2C_Master_Seq_Transmit_DMA+0x1b8>
    {
      if (hi2c->hdmatx != NULL)
2400afa2:	68fb      	ldr	r3, [r7, #12]
2400afa4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400afa6:	2b00      	cmp	r3, #0
2400afa8:	d020      	beq.n	2400afec <HAL_I2C_Master_Seq_Transmit_DMA+0x120>
      {
        /* Set the I2C DMA transfer complete callback */
        hi2c->hdmatx->XferCpltCallback = I2C_DMAMasterTransmitCplt;
2400afaa:	68fb      	ldr	r3, [r7, #12]
2400afac:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400afae:	4a46      	ldr	r2, [pc, #280]	; (2400b0c8 <HAL_I2C_Master_Seq_Transmit_DMA+0x1fc>)
2400afb0:	63da      	str	r2, [r3, #60]	; 0x3c

        /* Set the DMA error callback */
        hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
2400afb2:	68fb      	ldr	r3, [r7, #12]
2400afb4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400afb6:	4a45      	ldr	r2, [pc, #276]	; (2400b0cc <HAL_I2C_Master_Seq_Transmit_DMA+0x200>)
2400afb8:	64da      	str	r2, [r3, #76]	; 0x4c

        /* Set the unused DMA callbacks to NULL */
        hi2c->hdmatx->XferHalfCpltCallback = NULL;
2400afba:	68fb      	ldr	r3, [r7, #12]
2400afbc:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400afbe:	2200      	movs	r2, #0
2400afc0:	641a      	str	r2, [r3, #64]	; 0x40
        hi2c->hdmatx->XferAbortCallback = NULL;
2400afc2:	68fb      	ldr	r3, [r7, #12]
2400afc4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400afc6:	2200      	movs	r2, #0
2400afc8:	651a      	str	r2, [r3, #80]	; 0x50

        /* Enable the DMA stream or channel depends on Instance */
        dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->TXDR, hi2c->XferSize);
2400afca:	68fb      	ldr	r3, [r7, #12]
2400afcc:	6b98      	ldr	r0, [r3, #56]	; 0x38
2400afce:	6879      	ldr	r1, [r7, #4]
2400afd0:	68fb      	ldr	r3, [r7, #12]
2400afd2:	681b      	ldr	r3, [r3, #0]
2400afd4:	3328      	adds	r3, #40	; 0x28
2400afd6:	461a      	mov	r2, r3
2400afd8:	68fb      	ldr	r3, [r7, #12]
2400afda:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400afdc:	f7f7 fab6 	bl	2400254c <HAL_DMA_Start_IT>
2400afe0:	4603      	mov	r3, r0
2400afe2:	75fb      	strb	r3, [r7, #23]
        __HAL_UNLOCK(hi2c);

        return HAL_ERROR;
      }

      if (dmaxferstatus == HAL_OK)
2400afe4:	7dfb      	ldrb	r3, [r7, #23]
2400afe6:	2b00      	cmp	r3, #0
2400afe8:	d138      	bne.n	2400b05c <HAL_I2C_Master_Seq_Transmit_DMA+0x190>
2400afea:	e013      	b.n	2400b014 <HAL_I2C_Master_Seq_Transmit_DMA+0x148>
        hi2c->State     = HAL_I2C_STATE_READY;
2400afec:	68fb      	ldr	r3, [r7, #12]
2400afee:	2220      	movs	r2, #32
2400aff0:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
        hi2c->Mode      = HAL_I2C_MODE_NONE;
2400aff4:	68fb      	ldr	r3, [r7, #12]
2400aff6:	2200      	movs	r2, #0
2400aff8:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
        hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
2400affc:	68fb      	ldr	r3, [r7, #12]
2400affe:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400b000:	f043 0280 	orr.w	r2, r3, #128	; 0x80
2400b004:	68fb      	ldr	r3, [r7, #12]
2400b006:	645a      	str	r2, [r3, #68]	; 0x44
        __HAL_UNLOCK(hi2c);
2400b008:	68fb      	ldr	r3, [r7, #12]
2400b00a:	2200      	movs	r2, #0
2400b00c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
        return HAL_ERROR;
2400b010:	2301      	movs	r3, #1
2400b012:	e050      	b.n	2400b0b6 <HAL_I2C_Master_Seq_Transmit_DMA+0x1ea>
      {
        /* Send Slave Address and set NBYTES to write */
        I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, xferrequest);
2400b014:	68fb      	ldr	r3, [r7, #12]
2400b016:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400b018:	b2da      	uxtb	r2, r3
2400b01a:	8979      	ldrh	r1, [r7, #10]
2400b01c:	69bb      	ldr	r3, [r7, #24]
2400b01e:	9300      	str	r3, [sp, #0]
2400b020:	69fb      	ldr	r3, [r7, #28]
2400b022:	68f8      	ldr	r0, [r7, #12]
2400b024:	f002 fe88 	bl	2400dd38 <I2C_TransferConfig>

        /* Update XferCount value */
        hi2c->XferCount -= hi2c->XferSize;
2400b028:	68fb      	ldr	r3, [r7, #12]
2400b02a:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400b02c:	b29a      	uxth	r2, r3
2400b02e:	68fb      	ldr	r3, [r7, #12]
2400b030:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400b032:	1ad3      	subs	r3, r2, r3
2400b034:	b29a      	uxth	r2, r3
2400b036:	68fb      	ldr	r3, [r7, #12]
2400b038:	855a      	strh	r2, [r3, #42]	; 0x2a

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
2400b03a:	68fb      	ldr	r3, [r7, #12]
2400b03c:	2200      	movs	r2, #0
2400b03e:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

        /* Note : The I2C interrupts must be enabled after unlocking current process
                  to avoid the risk of I2C interrupt handle execution before current
                  process unlock */
        /* Enable ERR and NACK interrupts */
        I2C_Enable_IRQ(hi2c, I2C_XFER_ERROR_IT);
2400b042:	2110      	movs	r1, #16
2400b044:	68f8      	ldr	r0, [r7, #12]
2400b046:	f002 fea5 	bl	2400dd94 <I2C_Enable_IRQ>

        /* Enable DMA Request */
        hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN;
2400b04a:	68fb      	ldr	r3, [r7, #12]
2400b04c:	681b      	ldr	r3, [r3, #0]
2400b04e:	681a      	ldr	r2, [r3, #0]
2400b050:	68fb      	ldr	r3, [r7, #12]
2400b052:	681b      	ldr	r3, [r3, #0]
2400b054:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
2400b058:	601a      	str	r2, [r3, #0]
2400b05a:	e029      	b.n	2400b0b0 <HAL_I2C_Master_Seq_Transmit_DMA+0x1e4>
      }
      else
      {
        /* Update I2C state */
        hi2c->State     = HAL_I2C_STATE_READY;
2400b05c:	68fb      	ldr	r3, [r7, #12]
2400b05e:	2220      	movs	r2, #32
2400b060:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
        hi2c->Mode      = HAL_I2C_MODE_NONE;
2400b064:	68fb      	ldr	r3, [r7, #12]
2400b066:	2200      	movs	r2, #0
2400b068:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

        /* Update I2C error code */
        hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
2400b06c:	68fb      	ldr	r3, [r7, #12]
2400b06e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400b070:	f043 0210 	orr.w	r2, r3, #16
2400b074:	68fb      	ldr	r3, [r7, #12]
2400b076:	645a      	str	r2, [r3, #68]	; 0x44

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
2400b078:	68fb      	ldr	r3, [r7, #12]
2400b07a:	2200      	movs	r2, #0
2400b07c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

        return HAL_ERROR;
2400b080:	2301      	movs	r3, #1
2400b082:	e018      	b.n	2400b0b6 <HAL_I2C_Master_Seq_Transmit_DMA+0x1ea>
      }
    }
    else
    {
      /* Update Transfer ISR function pointer */
      hi2c->XferISR = I2C_Master_ISR_IT;
2400b084:	68fb      	ldr	r3, [r7, #12]
2400b086:	4a12      	ldr	r2, [pc, #72]	; (2400b0d0 <HAL_I2C_Master_Seq_Transmit_DMA+0x204>)
2400b088:	635a      	str	r2, [r3, #52]	; 0x34

      /* Send Slave Address */
      /* Set NBYTES to write and generate START condition */
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_WRITE);
2400b08a:	68fb      	ldr	r3, [r7, #12]
2400b08c:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400b08e:	b2da      	uxtb	r2, r3
2400b090:	8979      	ldrh	r1, [r7, #10]
2400b092:	4b0b      	ldr	r3, [pc, #44]	; (2400b0c0 <HAL_I2C_Master_Seq_Transmit_DMA+0x1f4>)
2400b094:	9300      	str	r3, [sp, #0]
2400b096:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
2400b09a:	68f8      	ldr	r0, [r7, #12]
2400b09c:	f002 fe4c 	bl	2400dd38 <I2C_TransferConfig>

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
2400b0a0:	68fb      	ldr	r3, [r7, #12]
2400b0a2:	2200      	movs	r2, #0
2400b0a4:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
                to avoid the risk of I2C interrupt handle execution before current
                process unlock */
      /* Enable ERR, TC, STOP, NACK, TXI interrupt */
      /* possible to enable all of these */
      /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
      I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT);
2400b0a8:	2101      	movs	r1, #1
2400b0aa:	68f8      	ldr	r0, [r7, #12]
2400b0ac:	f002 fe72 	bl	2400dd94 <I2C_Enable_IRQ>
    }

    return HAL_OK;
2400b0b0:	2300      	movs	r3, #0
2400b0b2:	e000      	b.n	2400b0b6 <HAL_I2C_Master_Seq_Transmit_DMA+0x1ea>
  }
  else
  {
    return HAL_BUSY;
2400b0b4:	2302      	movs	r3, #2
  }
}
2400b0b6:	4618      	mov	r0, r3
2400b0b8:	3720      	adds	r7, #32
2400b0ba:	46bd      	mov	sp, r7
2400b0bc:	bd80      	pop	{r7, pc}
2400b0be:	bf00      	nop
2400b0c0:	80002000 	.word	0x80002000
2400b0c4:	2400c307 	.word	0x2400c307
2400b0c8:	2400d49f 	.word	0x2400d49f
2400b0cc:	2400d771 	.word	0x2400d771
2400b0d0:	2400beaf 	.word	0x2400beaf

2400b0d4 <HAL_I2C_Master_Seq_Receive_IT>:
  * @param  Size Amount of data to be sent
  * @param  XferOptions Options of Transfer, value of @ref I2C_XFEROPTIONS
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Master_Seq_Receive_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t XferOptions)
{
2400b0d4:	b580      	push	{r7, lr}
2400b0d6:	b088      	sub	sp, #32
2400b0d8:	af02      	add	r7, sp, #8
2400b0da:	60f8      	str	r0, [r7, #12]
2400b0dc:	607a      	str	r2, [r7, #4]
2400b0de:	461a      	mov	r2, r3
2400b0e0:	460b      	mov	r3, r1
2400b0e2:	817b      	strh	r3, [r7, #10]
2400b0e4:	4613      	mov	r3, r2
2400b0e6:	813b      	strh	r3, [r7, #8]
  uint32_t xfermode;
  uint32_t xferrequest = I2C_GENERATE_START_READ;
2400b0e8:	4b3a      	ldr	r3, [pc, #232]	; (2400b1d4 <HAL_I2C_Master_Seq_Receive_IT+0x100>)
2400b0ea:	613b      	str	r3, [r7, #16]

  /* Check the parameters */
  assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));

  if (hi2c->State == HAL_I2C_STATE_READY)
2400b0ec:	68fb      	ldr	r3, [r7, #12]
2400b0ee:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400b0f2:	b2db      	uxtb	r3, r3
2400b0f4:	2b20      	cmp	r3, #32
2400b0f6:	d167      	bne.n	2400b1c8 <HAL_I2C_Master_Seq_Receive_IT+0xf4>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
2400b0f8:	68fb      	ldr	r3, [r7, #12]
2400b0fa:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400b0fe:	2b01      	cmp	r3, #1
2400b100:	d101      	bne.n	2400b106 <HAL_I2C_Master_Seq_Receive_IT+0x32>
2400b102:	2302      	movs	r3, #2
2400b104:	e061      	b.n	2400b1ca <HAL_I2C_Master_Seq_Receive_IT+0xf6>
2400b106:	68fb      	ldr	r3, [r7, #12]
2400b108:	2201      	movs	r2, #1
2400b10a:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State     = HAL_I2C_STATE_BUSY_RX;
2400b10e:	68fb      	ldr	r3, [r7, #12]
2400b110:	2222      	movs	r2, #34	; 0x22
2400b112:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_MASTER;
2400b116:	68fb      	ldr	r3, [r7, #12]
2400b118:	2210      	movs	r2, #16
2400b11a:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
2400b11e:	68fb      	ldr	r3, [r7, #12]
2400b120:	2200      	movs	r2, #0
2400b122:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
2400b124:	68fb      	ldr	r3, [r7, #12]
2400b126:	687a      	ldr	r2, [r7, #4]
2400b128:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
2400b12a:	68fb      	ldr	r3, [r7, #12]
2400b12c:	893a      	ldrh	r2, [r7, #8]
2400b12e:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferOptions = XferOptions;
2400b130:	68fb      	ldr	r3, [r7, #12]
2400b132:	6a3a      	ldr	r2, [r7, #32]
2400b134:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Master_ISR_IT;
2400b136:	68fb      	ldr	r3, [r7, #12]
2400b138:	4a27      	ldr	r2, [pc, #156]	; (2400b1d8 <HAL_I2C_Master_Seq_Receive_IT+0x104>)
2400b13a:	635a      	str	r2, [r3, #52]	; 0x34

    /* If hi2c->XferCount > MAX_NBYTE_SIZE, use reload mode */
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
2400b13c:	68fb      	ldr	r3, [r7, #12]
2400b13e:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400b140:	b29b      	uxth	r3, r3
2400b142:	2bff      	cmp	r3, #255	; 0xff
2400b144:	d906      	bls.n	2400b154 <HAL_I2C_Master_Seq_Receive_IT+0x80>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
2400b146:	68fb      	ldr	r3, [r7, #12]
2400b148:	22ff      	movs	r2, #255	; 0xff
2400b14a:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_RELOAD_MODE;
2400b14c:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2400b150:	617b      	str	r3, [r7, #20]
2400b152:	e007      	b.n	2400b164 <HAL_I2C_Master_Seq_Receive_IT+0x90>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
2400b154:	68fb      	ldr	r3, [r7, #12]
2400b156:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400b158:	b29a      	uxth	r2, r3
2400b15a:	68fb      	ldr	r3, [r7, #12]
2400b15c:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = hi2c->XferOptions;
2400b15e:	68fb      	ldr	r3, [r7, #12]
2400b160:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2400b162:	617b      	str	r3, [r7, #20]
    }

    /* If transfer direction not change and there is no request to start another frame, do not generate Restart Condition */
    /* Mean Previous state is same as current state */
    if ((hi2c->PreviousState == I2C_STATE_MASTER_BUSY_RX) && (IS_I2C_TRANSFER_OTHER_OPTIONS_REQUEST(XferOptions) == 0))
2400b164:	68fb      	ldr	r3, [r7, #12]
2400b166:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2400b168:	2b12      	cmp	r3, #18
2400b16a:	d10e      	bne.n	2400b18a <HAL_I2C_Master_Seq_Receive_IT+0xb6>
2400b16c:	6a3b      	ldr	r3, [r7, #32]
2400b16e:	2baa      	cmp	r3, #170	; 0xaa
2400b170:	d003      	beq.n	2400b17a <HAL_I2C_Master_Seq_Receive_IT+0xa6>
2400b172:	6a3b      	ldr	r3, [r7, #32]
2400b174:	f5b3 4f2a 	cmp.w	r3, #43520	; 0xaa00
2400b178:	d101      	bne.n	2400b17e <HAL_I2C_Master_Seq_Receive_IT+0xaa>
2400b17a:	2301      	movs	r3, #1
2400b17c:	e000      	b.n	2400b180 <HAL_I2C_Master_Seq_Receive_IT+0xac>
2400b17e:	2300      	movs	r3, #0
2400b180:	2b00      	cmp	r3, #0
2400b182:	d102      	bne.n	2400b18a <HAL_I2C_Master_Seq_Receive_IT+0xb6>
    {
      xferrequest = I2C_NO_STARTSTOP;
2400b184:	2300      	movs	r3, #0
2400b186:	613b      	str	r3, [r7, #16]
2400b188:	e00a      	b.n	2400b1a0 <HAL_I2C_Master_Seq_Receive_IT+0xcc>
    }
    else
    {
      /* Convert OTHER_xxx XferOptions if any */
      I2C_ConvertOtherXferOptions(hi2c);
2400b18a:	68f8      	ldr	r0, [r7, #12]
2400b18c:	f002 fec4 	bl	2400df18 <I2C_ConvertOtherXferOptions>

      /* Update xfermode accordingly if no reload is necessary */
      if (hi2c->XferCount < MAX_NBYTE_SIZE)
2400b190:	68fb      	ldr	r3, [r7, #12]
2400b192:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400b194:	b29b      	uxth	r3, r3
2400b196:	2bfe      	cmp	r3, #254	; 0xfe
2400b198:	d802      	bhi.n	2400b1a0 <HAL_I2C_Master_Seq_Receive_IT+0xcc>
      {
        xfermode = hi2c->XferOptions;
2400b19a:	68fb      	ldr	r3, [r7, #12]
2400b19c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2400b19e:	617b      	str	r3, [r7, #20]
      }
    }

    /* Send Slave Address and set NBYTES to read */
    I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, xferrequest);
2400b1a0:	68fb      	ldr	r3, [r7, #12]
2400b1a2:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400b1a4:	b2da      	uxtb	r2, r3
2400b1a6:	8979      	ldrh	r1, [r7, #10]
2400b1a8:	693b      	ldr	r3, [r7, #16]
2400b1aa:	9300      	str	r3, [sp, #0]
2400b1ac:	697b      	ldr	r3, [r7, #20]
2400b1ae:	68f8      	ldr	r0, [r7, #12]
2400b1b0:	f002 fdc2 	bl	2400dd38 <I2C_TransferConfig>

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2400b1b4:	68fb      	ldr	r3, [r7, #12]
2400b1b6:	2200      	movs	r2, #0
2400b1b8:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Note : The I2C interrupts must be enabled after unlocking current process
              to avoid the risk of I2C interrupt handle execution before current
              process unlock */
    I2C_Enable_IRQ(hi2c, I2C_XFER_RX_IT);
2400b1bc:	2102      	movs	r1, #2
2400b1be:	68f8      	ldr	r0, [r7, #12]
2400b1c0:	f002 fde8 	bl	2400dd94 <I2C_Enable_IRQ>

    return HAL_OK;
2400b1c4:	2300      	movs	r3, #0
2400b1c6:	e000      	b.n	2400b1ca <HAL_I2C_Master_Seq_Receive_IT+0xf6>
  }
  else
  {
    return HAL_BUSY;
2400b1c8:	2302      	movs	r3, #2
  }
}
2400b1ca:	4618      	mov	r0, r3
2400b1cc:	3718      	adds	r7, #24
2400b1ce:	46bd      	mov	sp, r7
2400b1d0:	bd80      	pop	{r7, pc}
2400b1d2:	bf00      	nop
2400b1d4:	80002400 	.word	0x80002400
2400b1d8:	2400beaf 	.word	0x2400beaf

2400b1dc <HAL_I2C_Master_Seq_Receive_DMA>:
  * @param  Size Amount of data to be sent
  * @param  XferOptions Options of Transfer, value of @ref I2C_XFEROPTIONS
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Master_Seq_Receive_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t XferOptions)
{
2400b1dc:	b580      	push	{r7, lr}
2400b1de:	b08a      	sub	sp, #40	; 0x28
2400b1e0:	af02      	add	r7, sp, #8
2400b1e2:	60f8      	str	r0, [r7, #12]
2400b1e4:	607a      	str	r2, [r7, #4]
2400b1e6:	461a      	mov	r2, r3
2400b1e8:	460b      	mov	r3, r1
2400b1ea:	817b      	strh	r3, [r7, #10]
2400b1ec:	4613      	mov	r3, r2
2400b1ee:	813b      	strh	r3, [r7, #8]
  uint32_t xfermode;
  uint32_t xferrequest = I2C_GENERATE_START_READ;
2400b1f0:	4b77      	ldr	r3, [pc, #476]	; (2400b3d0 <HAL_I2C_Master_Seq_Receive_DMA+0x1f4>)
2400b1f2:	61bb      	str	r3, [r7, #24]
  HAL_StatusTypeDef dmaxferstatus;

  /* Check the parameters */
  assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));

  if (hi2c->State == HAL_I2C_STATE_READY)
2400b1f4:	68fb      	ldr	r3, [r7, #12]
2400b1f6:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400b1fa:	b2db      	uxtb	r3, r3
2400b1fc:	2b20      	cmp	r3, #32
2400b1fe:	f040 80e1 	bne.w	2400b3c4 <HAL_I2C_Master_Seq_Receive_DMA+0x1e8>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
2400b202:	68fb      	ldr	r3, [r7, #12]
2400b204:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400b208:	2b01      	cmp	r3, #1
2400b20a:	d101      	bne.n	2400b210 <HAL_I2C_Master_Seq_Receive_DMA+0x34>
2400b20c:	2302      	movs	r3, #2
2400b20e:	e0da      	b.n	2400b3c6 <HAL_I2C_Master_Seq_Receive_DMA+0x1ea>
2400b210:	68fb      	ldr	r3, [r7, #12]
2400b212:	2201      	movs	r2, #1
2400b214:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State     = HAL_I2C_STATE_BUSY_RX;
2400b218:	68fb      	ldr	r3, [r7, #12]
2400b21a:	2222      	movs	r2, #34	; 0x22
2400b21c:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_MASTER;
2400b220:	68fb      	ldr	r3, [r7, #12]
2400b222:	2210      	movs	r2, #16
2400b224:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
2400b228:	68fb      	ldr	r3, [r7, #12]
2400b22a:	2200      	movs	r2, #0
2400b22c:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
2400b22e:	68fb      	ldr	r3, [r7, #12]
2400b230:	687a      	ldr	r2, [r7, #4]
2400b232:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
2400b234:	68fb      	ldr	r3, [r7, #12]
2400b236:	893a      	ldrh	r2, [r7, #8]
2400b238:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferOptions = XferOptions;
2400b23a:	68fb      	ldr	r3, [r7, #12]
2400b23c:	6aba      	ldr	r2, [r7, #40]	; 0x28
2400b23e:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Master_ISR_DMA;
2400b240:	68fb      	ldr	r3, [r7, #12]
2400b242:	4a64      	ldr	r2, [pc, #400]	; (2400b3d4 <HAL_I2C_Master_Seq_Receive_DMA+0x1f8>)
2400b244:	635a      	str	r2, [r3, #52]	; 0x34

    /* If hi2c->XferCount > MAX_NBYTE_SIZE, use reload mode */
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
2400b246:	68fb      	ldr	r3, [r7, #12]
2400b248:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400b24a:	b29b      	uxth	r3, r3
2400b24c:	2bff      	cmp	r3, #255	; 0xff
2400b24e:	d906      	bls.n	2400b25e <HAL_I2C_Master_Seq_Receive_DMA+0x82>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
2400b250:	68fb      	ldr	r3, [r7, #12]
2400b252:	22ff      	movs	r2, #255	; 0xff
2400b254:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_RELOAD_MODE;
2400b256:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2400b25a:	61fb      	str	r3, [r7, #28]
2400b25c:	e007      	b.n	2400b26e <HAL_I2C_Master_Seq_Receive_DMA+0x92>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
2400b25e:	68fb      	ldr	r3, [r7, #12]
2400b260:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400b262:	b29a      	uxth	r2, r3
2400b264:	68fb      	ldr	r3, [r7, #12]
2400b266:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = hi2c->XferOptions;
2400b268:	68fb      	ldr	r3, [r7, #12]
2400b26a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2400b26c:	61fb      	str	r3, [r7, #28]
    }

    /* If transfer direction not change and there is no request to start another frame, do not generate Restart Condition */
    /* Mean Previous state is same as current state */
    if ((hi2c->PreviousState == I2C_STATE_MASTER_BUSY_RX) && (IS_I2C_TRANSFER_OTHER_OPTIONS_REQUEST(XferOptions) == 0))
2400b26e:	68fb      	ldr	r3, [r7, #12]
2400b270:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2400b272:	2b12      	cmp	r3, #18
2400b274:	d10e      	bne.n	2400b294 <HAL_I2C_Master_Seq_Receive_DMA+0xb8>
2400b276:	6abb      	ldr	r3, [r7, #40]	; 0x28
2400b278:	2baa      	cmp	r3, #170	; 0xaa
2400b27a:	d003      	beq.n	2400b284 <HAL_I2C_Master_Seq_Receive_DMA+0xa8>
2400b27c:	6abb      	ldr	r3, [r7, #40]	; 0x28
2400b27e:	f5b3 4f2a 	cmp.w	r3, #43520	; 0xaa00
2400b282:	d101      	bne.n	2400b288 <HAL_I2C_Master_Seq_Receive_DMA+0xac>
2400b284:	2301      	movs	r3, #1
2400b286:	e000      	b.n	2400b28a <HAL_I2C_Master_Seq_Receive_DMA+0xae>
2400b288:	2300      	movs	r3, #0
2400b28a:	2b00      	cmp	r3, #0
2400b28c:	d102      	bne.n	2400b294 <HAL_I2C_Master_Seq_Receive_DMA+0xb8>
    {
      xferrequest = I2C_NO_STARTSTOP;
2400b28e:	2300      	movs	r3, #0
2400b290:	61bb      	str	r3, [r7, #24]
2400b292:	e00a      	b.n	2400b2aa <HAL_I2C_Master_Seq_Receive_DMA+0xce>
    }
    else
    {
      /* Convert OTHER_xxx XferOptions if any */
      I2C_ConvertOtherXferOptions(hi2c);
2400b294:	68f8      	ldr	r0, [r7, #12]
2400b296:	f002 fe3f 	bl	2400df18 <I2C_ConvertOtherXferOptions>

      /* Update xfermode accordingly if no reload is necessary */
      if (hi2c->XferCount < MAX_NBYTE_SIZE)
2400b29a:	68fb      	ldr	r3, [r7, #12]
2400b29c:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400b29e:	b29b      	uxth	r3, r3
2400b2a0:	2bfe      	cmp	r3, #254	; 0xfe
2400b2a2:	d802      	bhi.n	2400b2aa <HAL_I2C_Master_Seq_Receive_DMA+0xce>
      {
        xfermode = hi2c->XferOptions;
2400b2a4:	68fb      	ldr	r3, [r7, #12]
2400b2a6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2400b2a8:	61fb      	str	r3, [r7, #28]
      }
    }

    if (hi2c->XferSize > 0U)
2400b2aa:	68fb      	ldr	r3, [r7, #12]
2400b2ac:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400b2ae:	2b00      	cmp	r3, #0
2400b2b0:	d070      	beq.n	2400b394 <HAL_I2C_Master_Seq_Receive_DMA+0x1b8>
    {
      if (hi2c->hdmarx != NULL)
2400b2b2:	68fb      	ldr	r3, [r7, #12]
2400b2b4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400b2b6:	2b00      	cmp	r3, #0
2400b2b8:	d020      	beq.n	2400b2fc <HAL_I2C_Master_Seq_Receive_DMA+0x120>
      {
        /* Set the I2C DMA transfer complete callback */
        hi2c->hdmarx->XferCpltCallback = I2C_DMAMasterReceiveCplt;
2400b2ba:	68fb      	ldr	r3, [r7, #12]
2400b2bc:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400b2be:	4a46      	ldr	r2, [pc, #280]	; (2400b3d8 <HAL_I2C_Master_Seq_Receive_DMA+0x1fc>)
2400b2c0:	63da      	str	r2, [r3, #60]	; 0x3c

        /* Set the DMA error callback */
        hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
2400b2c2:	68fb      	ldr	r3, [r7, #12]
2400b2c4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400b2c6:	4a45      	ldr	r2, [pc, #276]	; (2400b3dc <HAL_I2C_Master_Seq_Receive_DMA+0x200>)
2400b2c8:	64da      	str	r2, [r3, #76]	; 0x4c

        /* Set the unused DMA callbacks to NULL */
        hi2c->hdmarx->XferHalfCpltCallback = NULL;
2400b2ca:	68fb      	ldr	r3, [r7, #12]
2400b2cc:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400b2ce:	2200      	movs	r2, #0
2400b2d0:	641a      	str	r2, [r3, #64]	; 0x40
        hi2c->hdmarx->XferAbortCallback = NULL;
2400b2d2:	68fb      	ldr	r3, [r7, #12]
2400b2d4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400b2d6:	2200      	movs	r2, #0
2400b2d8:	651a      	str	r2, [r3, #80]	; 0x50

        /* Enable the DMA stream or channel depends on Instance */
        dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)pData, hi2c->XferSize);
2400b2da:	68fb      	ldr	r3, [r7, #12]
2400b2dc:	6bd8      	ldr	r0, [r3, #60]	; 0x3c
2400b2de:	68fb      	ldr	r3, [r7, #12]
2400b2e0:	681b      	ldr	r3, [r3, #0]
2400b2e2:	3324      	adds	r3, #36	; 0x24
2400b2e4:	4619      	mov	r1, r3
2400b2e6:	687a      	ldr	r2, [r7, #4]
2400b2e8:	68fb      	ldr	r3, [r7, #12]
2400b2ea:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400b2ec:	f7f7 f92e 	bl	2400254c <HAL_DMA_Start_IT>
2400b2f0:	4603      	mov	r3, r0
2400b2f2:	75fb      	strb	r3, [r7, #23]
        __HAL_UNLOCK(hi2c);

        return HAL_ERROR;
      }

      if (dmaxferstatus == HAL_OK)
2400b2f4:	7dfb      	ldrb	r3, [r7, #23]
2400b2f6:	2b00      	cmp	r3, #0
2400b2f8:	d138      	bne.n	2400b36c <HAL_I2C_Master_Seq_Receive_DMA+0x190>
2400b2fa:	e013      	b.n	2400b324 <HAL_I2C_Master_Seq_Receive_DMA+0x148>
        hi2c->State     = HAL_I2C_STATE_READY;
2400b2fc:	68fb      	ldr	r3, [r7, #12]
2400b2fe:	2220      	movs	r2, #32
2400b300:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
        hi2c->Mode      = HAL_I2C_MODE_NONE;
2400b304:	68fb      	ldr	r3, [r7, #12]
2400b306:	2200      	movs	r2, #0
2400b308:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
        hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
2400b30c:	68fb      	ldr	r3, [r7, #12]
2400b30e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400b310:	f043 0280 	orr.w	r2, r3, #128	; 0x80
2400b314:	68fb      	ldr	r3, [r7, #12]
2400b316:	645a      	str	r2, [r3, #68]	; 0x44
        __HAL_UNLOCK(hi2c);
2400b318:	68fb      	ldr	r3, [r7, #12]
2400b31a:	2200      	movs	r2, #0
2400b31c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
        return HAL_ERROR;
2400b320:	2301      	movs	r3, #1
2400b322:	e050      	b.n	2400b3c6 <HAL_I2C_Master_Seq_Receive_DMA+0x1ea>
      {
        /* Send Slave Address and set NBYTES to read */
        I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, xferrequest);
2400b324:	68fb      	ldr	r3, [r7, #12]
2400b326:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400b328:	b2da      	uxtb	r2, r3
2400b32a:	8979      	ldrh	r1, [r7, #10]
2400b32c:	69bb      	ldr	r3, [r7, #24]
2400b32e:	9300      	str	r3, [sp, #0]
2400b330:	69fb      	ldr	r3, [r7, #28]
2400b332:	68f8      	ldr	r0, [r7, #12]
2400b334:	f002 fd00 	bl	2400dd38 <I2C_TransferConfig>

        /* Update XferCount value */
        hi2c->XferCount -= hi2c->XferSize;
2400b338:	68fb      	ldr	r3, [r7, #12]
2400b33a:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400b33c:	b29a      	uxth	r2, r3
2400b33e:	68fb      	ldr	r3, [r7, #12]
2400b340:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400b342:	1ad3      	subs	r3, r2, r3
2400b344:	b29a      	uxth	r2, r3
2400b346:	68fb      	ldr	r3, [r7, #12]
2400b348:	855a      	strh	r2, [r3, #42]	; 0x2a

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
2400b34a:	68fb      	ldr	r3, [r7, #12]
2400b34c:	2200      	movs	r2, #0
2400b34e:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

        /* Note : The I2C interrupts must be enabled after unlocking current process
                  to avoid the risk of I2C interrupt handle execution before current
                  process unlock */
        /* Enable ERR and NACK interrupts */
        I2C_Enable_IRQ(hi2c, I2C_XFER_ERROR_IT);
2400b352:	2110      	movs	r1, #16
2400b354:	68f8      	ldr	r0, [r7, #12]
2400b356:	f002 fd1d 	bl	2400dd94 <I2C_Enable_IRQ>

        /* Enable DMA Request */
        hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;
2400b35a:	68fb      	ldr	r3, [r7, #12]
2400b35c:	681b      	ldr	r3, [r3, #0]
2400b35e:	681a      	ldr	r2, [r3, #0]
2400b360:	68fb      	ldr	r3, [r7, #12]
2400b362:	681b      	ldr	r3, [r3, #0]
2400b364:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
2400b368:	601a      	str	r2, [r3, #0]
2400b36a:	e029      	b.n	2400b3c0 <HAL_I2C_Master_Seq_Receive_DMA+0x1e4>
      }
      else
      {
        /* Update I2C state */
        hi2c->State     = HAL_I2C_STATE_READY;
2400b36c:	68fb      	ldr	r3, [r7, #12]
2400b36e:	2220      	movs	r2, #32
2400b370:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
        hi2c->Mode      = HAL_I2C_MODE_NONE;
2400b374:	68fb      	ldr	r3, [r7, #12]
2400b376:	2200      	movs	r2, #0
2400b378:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

        /* Update I2C error code */
        hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
2400b37c:	68fb      	ldr	r3, [r7, #12]
2400b37e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400b380:	f043 0210 	orr.w	r2, r3, #16
2400b384:	68fb      	ldr	r3, [r7, #12]
2400b386:	645a      	str	r2, [r3, #68]	; 0x44

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
2400b388:	68fb      	ldr	r3, [r7, #12]
2400b38a:	2200      	movs	r2, #0
2400b38c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

        return HAL_ERROR;
2400b390:	2301      	movs	r3, #1
2400b392:	e018      	b.n	2400b3c6 <HAL_I2C_Master_Seq_Receive_DMA+0x1ea>
      }
    }
    else
    {
      /* Update Transfer ISR function pointer */
      hi2c->XferISR = I2C_Master_ISR_IT;
2400b394:	68fb      	ldr	r3, [r7, #12]
2400b396:	4a12      	ldr	r2, [pc, #72]	; (2400b3e0 <HAL_I2C_Master_Seq_Receive_DMA+0x204>)
2400b398:	635a      	str	r2, [r3, #52]	; 0x34

      /* Send Slave Address */
      /* Set NBYTES to read and generate START condition */
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_READ);
2400b39a:	68fb      	ldr	r3, [r7, #12]
2400b39c:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400b39e:	b2da      	uxtb	r2, r3
2400b3a0:	8979      	ldrh	r1, [r7, #10]
2400b3a2:	4b0b      	ldr	r3, [pc, #44]	; (2400b3d0 <HAL_I2C_Master_Seq_Receive_DMA+0x1f4>)
2400b3a4:	9300      	str	r3, [sp, #0]
2400b3a6:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
2400b3aa:	68f8      	ldr	r0, [r7, #12]
2400b3ac:	f002 fcc4 	bl	2400dd38 <I2C_TransferConfig>

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
2400b3b0:	68fb      	ldr	r3, [r7, #12]
2400b3b2:	2200      	movs	r2, #0
2400b3b4:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
                to avoid the risk of I2C interrupt handle execution before current
                process unlock */
      /* Enable ERR, TC, STOP, NACK, TXI interrupt */
      /* possible to enable all of these */
      /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
      I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT);
2400b3b8:	2101      	movs	r1, #1
2400b3ba:	68f8      	ldr	r0, [r7, #12]
2400b3bc:	f002 fcea 	bl	2400dd94 <I2C_Enable_IRQ>
    }

    return HAL_OK;
2400b3c0:	2300      	movs	r3, #0
2400b3c2:	e000      	b.n	2400b3c6 <HAL_I2C_Master_Seq_Receive_DMA+0x1ea>
  }
  else
  {
    return HAL_BUSY;
2400b3c4:	2302      	movs	r3, #2
  }
}
2400b3c6:	4618      	mov	r0, r3
2400b3c8:	3720      	adds	r7, #32
2400b3ca:	46bd      	mov	sp, r7
2400b3cc:	bd80      	pop	{r7, pc}
2400b3ce:	bf00      	nop
2400b3d0:	80002400 	.word	0x80002400
2400b3d4:	2400c307 	.word	0x2400c307
2400b3d8:	2400d575 	.word	0x2400d575
2400b3dc:	2400d771 	.word	0x2400d771
2400b3e0:	2400beaf 	.word	0x2400beaf

2400b3e4 <HAL_I2C_Slave_Seq_Transmit_IT>:
  * @param  Size Amount of data to be sent
  * @param  XferOptions Options of Transfer, value of @ref I2C_XFEROPTIONS
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Slave_Seq_Transmit_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t XferOptions)
{
2400b3e4:	b580      	push	{r7, lr}
2400b3e6:	b084      	sub	sp, #16
2400b3e8:	af00      	add	r7, sp, #0
2400b3ea:	60f8      	str	r0, [r7, #12]
2400b3ec:	60b9      	str	r1, [r7, #8]
2400b3ee:	603b      	str	r3, [r7, #0]
2400b3f0:	4613      	mov	r3, r2
2400b3f2:	80fb      	strh	r3, [r7, #6]
  /* Check the parameters */
  assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));

  if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
2400b3f4:	68fb      	ldr	r3, [r7, #12]
2400b3f6:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400b3fa:	b2db      	uxtb	r3, r3
2400b3fc:	f003 0328 	and.w	r3, r3, #40	; 0x28
2400b400:	2b28      	cmp	r3, #40	; 0x28
2400b402:	f040 808a 	bne.w	2400b51a <HAL_I2C_Slave_Seq_Transmit_IT+0x136>
  {
    if ((pData == NULL) || (Size == 0U))
2400b406:	68bb      	ldr	r3, [r7, #8]
2400b408:	2b00      	cmp	r3, #0
2400b40a:	d002      	beq.n	2400b412 <HAL_I2C_Slave_Seq_Transmit_IT+0x2e>
2400b40c:	88fb      	ldrh	r3, [r7, #6]
2400b40e:	2b00      	cmp	r3, #0
2400b410:	d105      	bne.n	2400b41e <HAL_I2C_Slave_Seq_Transmit_IT+0x3a>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
2400b412:	68fb      	ldr	r3, [r7, #12]
2400b414:	f44f 7200 	mov.w	r2, #512	; 0x200
2400b418:	645a      	str	r2, [r3, #68]	; 0x44
      return  HAL_ERROR;
2400b41a:	2301      	movs	r3, #1
2400b41c:	e07e      	b.n	2400b51c <HAL_I2C_Slave_Seq_Transmit_IT+0x138>
    }

    /* Disable Interrupts, to prevent preemption during treatment in case of multicall */
    I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_TX_IT);
2400b41e:	f248 0101 	movw	r1, #32769	; 0x8001
2400b422:	68f8      	ldr	r0, [r7, #12]
2400b424:	f002 fd1a 	bl	2400de5c <I2C_Disable_IRQ>

    /* Process Locked */
    __HAL_LOCK(hi2c);
2400b428:	68fb      	ldr	r3, [r7, #12]
2400b42a:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400b42e:	2b01      	cmp	r3, #1
2400b430:	d101      	bne.n	2400b436 <HAL_I2C_Slave_Seq_Transmit_IT+0x52>
2400b432:	2302      	movs	r3, #2
2400b434:	e072      	b.n	2400b51c <HAL_I2C_Slave_Seq_Transmit_IT+0x138>
2400b436:	68fb      	ldr	r3, [r7, #12]
2400b438:	2201      	movs	r2, #1
2400b43a:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* I2C cannot manage full duplex exchange so disable previous IT enabled if any */
    /* and then toggle the HAL slave RX state to TX state */
    if (hi2c->State == HAL_I2C_STATE_BUSY_RX_LISTEN)
2400b43e:	68fb      	ldr	r3, [r7, #12]
2400b440:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400b444:	b2db      	uxtb	r3, r3
2400b446:	2b2a      	cmp	r3, #42	; 0x2a
2400b448:	d12a      	bne.n	2400b4a0 <HAL_I2C_Slave_Seq_Transmit_IT+0xbc>
    {
      /* Disable associated Interrupts */
      I2C_Disable_IRQ(hi2c, I2C_XFER_RX_IT);
2400b44a:	2102      	movs	r1, #2
2400b44c:	68f8      	ldr	r0, [r7, #12]
2400b44e:	f002 fd05 	bl	2400de5c <I2C_Disable_IRQ>

      /* Abort DMA Xfer if any */
      if ((hi2c->Instance->CR1 & I2C_CR1_RXDMAEN) == I2C_CR1_RXDMAEN)
2400b452:	68fb      	ldr	r3, [r7, #12]
2400b454:	681b      	ldr	r3, [r3, #0]
2400b456:	681b      	ldr	r3, [r3, #0]
2400b458:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
2400b45c:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
2400b460:	d11e      	bne.n	2400b4a0 <HAL_I2C_Slave_Seq_Transmit_IT+0xbc>
      {
        hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
2400b462:	68fb      	ldr	r3, [r7, #12]
2400b464:	681b      	ldr	r3, [r3, #0]
2400b466:	681a      	ldr	r2, [r3, #0]
2400b468:	68fb      	ldr	r3, [r7, #12]
2400b46a:	681b      	ldr	r3, [r3, #0]
2400b46c:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
2400b470:	601a      	str	r2, [r3, #0]

        if (hi2c->hdmarx != NULL)
2400b472:	68fb      	ldr	r3, [r7, #12]
2400b474:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400b476:	2b00      	cmp	r3, #0
2400b478:	d012      	beq.n	2400b4a0 <HAL_I2C_Slave_Seq_Transmit_IT+0xbc>
        {
          /* Set the I2C DMA Abort callback :
           will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
          hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
2400b47a:	68fb      	ldr	r3, [r7, #12]
2400b47c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400b47e:	4a29      	ldr	r2, [pc, #164]	; (2400b524 <HAL_I2C_Slave_Seq_Transmit_IT+0x140>)
2400b480:	651a      	str	r2, [r3, #80]	; 0x50

          /* Abort DMA RX */
          if (HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)
2400b482:	68fb      	ldr	r3, [r7, #12]
2400b484:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400b486:	4618      	mov	r0, r3
2400b488:	f7f7 fde8 	bl	2400305c <HAL_DMA_Abort_IT>
2400b48c:	4603      	mov	r3, r0
2400b48e:	2b00      	cmp	r3, #0
2400b490:	d006      	beq.n	2400b4a0 <HAL_I2C_Slave_Seq_Transmit_IT+0xbc>
          {
            /* Call Directly XferAbortCallback function in case of error */
            hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
2400b492:	68fb      	ldr	r3, [r7, #12]
2400b494:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400b496:	6d1b      	ldr	r3, [r3, #80]	; 0x50
2400b498:	68fa      	ldr	r2, [r7, #12]
2400b49a:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
2400b49c:	4610      	mov	r0, r2
2400b49e:	4798      	blx	r3
          }
        }
      }
    }

    hi2c->State     = HAL_I2C_STATE_BUSY_TX_LISTEN;
2400b4a0:	68fb      	ldr	r3, [r7, #12]
2400b4a2:	2229      	movs	r2, #41	; 0x29
2400b4a4:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_SLAVE;
2400b4a8:	68fb      	ldr	r3, [r7, #12]
2400b4aa:	2220      	movs	r2, #32
2400b4ac:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
2400b4b0:	68fb      	ldr	r3, [r7, #12]
2400b4b2:	2200      	movs	r2, #0
2400b4b4:	645a      	str	r2, [r3, #68]	; 0x44

    /* Enable Address Acknowledge */
    hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
2400b4b6:	68fb      	ldr	r3, [r7, #12]
2400b4b8:	681b      	ldr	r3, [r3, #0]
2400b4ba:	685a      	ldr	r2, [r3, #4]
2400b4bc:	68fb      	ldr	r3, [r7, #12]
2400b4be:	681b      	ldr	r3, [r3, #0]
2400b4c0:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
2400b4c4:	605a      	str	r2, [r3, #4]

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
2400b4c6:	68fb      	ldr	r3, [r7, #12]
2400b4c8:	68ba      	ldr	r2, [r7, #8]
2400b4ca:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
2400b4cc:	68fb      	ldr	r3, [r7, #12]
2400b4ce:	88fa      	ldrh	r2, [r7, #6]
2400b4d0:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferSize    = hi2c->XferCount;
2400b4d2:	68fb      	ldr	r3, [r7, #12]
2400b4d4:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400b4d6:	b29a      	uxth	r2, r3
2400b4d8:	68fb      	ldr	r3, [r7, #12]
2400b4da:	851a      	strh	r2, [r3, #40]	; 0x28
    hi2c->XferOptions = XferOptions;
2400b4dc:	68fb      	ldr	r3, [r7, #12]
2400b4de:	683a      	ldr	r2, [r7, #0]
2400b4e0:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Slave_ISR_IT;
2400b4e2:	68fb      	ldr	r3, [r7, #12]
2400b4e4:	4a10      	ldr	r2, [pc, #64]	; (2400b528 <HAL_I2C_Slave_Seq_Transmit_IT+0x144>)
2400b4e6:	635a      	str	r2, [r3, #52]	; 0x34

    if (I2C_GET_DIR(hi2c) == I2C_DIRECTION_RECEIVE)
2400b4e8:	68fb      	ldr	r3, [r7, #12]
2400b4ea:	681b      	ldr	r3, [r3, #0]
2400b4ec:	699b      	ldr	r3, [r3, #24]
2400b4ee:	0c1b      	lsrs	r3, r3, #16
2400b4f0:	b2db      	uxtb	r3, r3
2400b4f2:	f003 0301 	and.w	r3, r3, #1
2400b4f6:	b2db      	uxtb	r3, r3
2400b4f8:	2b01      	cmp	r3, #1
2400b4fa:	d103      	bne.n	2400b504 <HAL_I2C_Slave_Seq_Transmit_IT+0x120>
    {
      /* Clear ADDR flag after prepare the transfer parameters */
      /* This action will generate an acknowledge to the Master */
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
2400b4fc:	68fb      	ldr	r3, [r7, #12]
2400b4fe:	681b      	ldr	r3, [r3, #0]
2400b500:	2208      	movs	r2, #8
2400b502:	61da      	str	r2, [r3, #28]
    }

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2400b504:	68fb      	ldr	r3, [r7, #12]
2400b506:	2200      	movs	r2, #0
2400b508:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Note : The I2C interrupts must be enabled after unlocking current process
    to avoid the risk of I2C interrupt handle execution before current
    process unlock */
    /* REnable ADDR interrupt */
    I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT | I2C_XFER_LISTEN_IT);
2400b50c:	f248 0101 	movw	r1, #32769	; 0x8001
2400b510:	68f8      	ldr	r0, [r7, #12]
2400b512:	f002 fc3f 	bl	2400dd94 <I2C_Enable_IRQ>

    return HAL_OK;
2400b516:	2300      	movs	r3, #0
2400b518:	e000      	b.n	2400b51c <HAL_I2C_Slave_Seq_Transmit_IT+0x138>
  }
  else
  {
    return HAL_ERROR;
2400b51a:	2301      	movs	r3, #1
  }
}
2400b51c:	4618      	mov	r0, r3
2400b51e:	3710      	adds	r7, #16
2400b520:	46bd      	mov	sp, r7
2400b522:	bd80      	pop	{r7, pc}
2400b524:	2400d9e1 	.word	0x2400d9e1
2400b528:	2400c101 	.word	0x2400c101

2400b52c <HAL_I2C_Slave_Seq_Transmit_DMA>:
  * @param  Size Amount of data to be sent
  * @param  XferOptions Options of Transfer, value of @ref I2C_XFEROPTIONS
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Slave_Seq_Transmit_DMA(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t XferOptions)
{
2400b52c:	b580      	push	{r7, lr}
2400b52e:	b086      	sub	sp, #24
2400b530:	af00      	add	r7, sp, #0
2400b532:	60f8      	str	r0, [r7, #12]
2400b534:	60b9      	str	r1, [r7, #8]
2400b536:	603b      	str	r3, [r7, #0]
2400b538:	4613      	mov	r3, r2
2400b53a:	80fb      	strh	r3, [r7, #6]
  HAL_StatusTypeDef dmaxferstatus;

  /* Check the parameters */
  assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));

  if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
2400b53c:	68fb      	ldr	r3, [r7, #12]
2400b53e:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400b542:	b2db      	uxtb	r3, r3
2400b544:	f003 0328 	and.w	r3, r3, #40	; 0x28
2400b548:	2b28      	cmp	r3, #40	; 0x28
2400b54a:	f040 811a 	bne.w	2400b782 <HAL_I2C_Slave_Seq_Transmit_DMA+0x256>
  {
    if ((pData == NULL) || (Size == 0U))
2400b54e:	68bb      	ldr	r3, [r7, #8]
2400b550:	2b00      	cmp	r3, #0
2400b552:	d002      	beq.n	2400b55a <HAL_I2C_Slave_Seq_Transmit_DMA+0x2e>
2400b554:	88fb      	ldrh	r3, [r7, #6]
2400b556:	2b00      	cmp	r3, #0
2400b558:	d105      	bne.n	2400b566 <HAL_I2C_Slave_Seq_Transmit_DMA+0x3a>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
2400b55a:	68fb      	ldr	r3, [r7, #12]
2400b55c:	f44f 7200 	mov.w	r2, #512	; 0x200
2400b560:	645a      	str	r2, [r3, #68]	; 0x44
      return  HAL_ERROR;
2400b562:	2301      	movs	r3, #1
2400b564:	e10e      	b.n	2400b784 <HAL_I2C_Slave_Seq_Transmit_DMA+0x258>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
2400b566:	68fb      	ldr	r3, [r7, #12]
2400b568:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400b56c:	2b01      	cmp	r3, #1
2400b56e:	d101      	bne.n	2400b574 <HAL_I2C_Slave_Seq_Transmit_DMA+0x48>
2400b570:	2302      	movs	r3, #2
2400b572:	e107      	b.n	2400b784 <HAL_I2C_Slave_Seq_Transmit_DMA+0x258>
2400b574:	68fb      	ldr	r3, [r7, #12]
2400b576:	2201      	movs	r2, #1
2400b578:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Disable Interrupts, to prevent preemption during treatment in case of multicall */
    I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_TX_IT);
2400b57c:	f248 0101 	movw	r1, #32769	; 0x8001
2400b580:	68f8      	ldr	r0, [r7, #12]
2400b582:	f002 fc6b 	bl	2400de5c <I2C_Disable_IRQ>

    /* I2C cannot manage full duplex exchange so disable previous IT enabled if any */
    /* and then toggle the HAL slave RX state to TX state */
    if (hi2c->State == HAL_I2C_STATE_BUSY_RX_LISTEN)
2400b586:	68fb      	ldr	r3, [r7, #12]
2400b588:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400b58c:	b2db      	uxtb	r3, r3
2400b58e:	2b2a      	cmp	r3, #42	; 0x2a
2400b590:	d12b      	bne.n	2400b5ea <HAL_I2C_Slave_Seq_Transmit_DMA+0xbe>
    {
      /* Disable associated Interrupts */
      I2C_Disable_IRQ(hi2c, I2C_XFER_RX_IT);
2400b592:	2102      	movs	r1, #2
2400b594:	68f8      	ldr	r0, [r7, #12]
2400b596:	f002 fc61 	bl	2400de5c <I2C_Disable_IRQ>

      if ((hi2c->Instance->CR1 & I2C_CR1_RXDMAEN) == I2C_CR1_RXDMAEN)
2400b59a:	68fb      	ldr	r3, [r7, #12]
2400b59c:	681b      	ldr	r3, [r3, #0]
2400b59e:	681b      	ldr	r3, [r3, #0]
2400b5a0:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
2400b5a4:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
2400b5a8:	d14c      	bne.n	2400b644 <HAL_I2C_Slave_Seq_Transmit_DMA+0x118>
      {
        /* Abort DMA Xfer if any */
        if (hi2c->hdmarx != NULL)
2400b5aa:	68fb      	ldr	r3, [r7, #12]
2400b5ac:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400b5ae:	2b00      	cmp	r3, #0
2400b5b0:	d048      	beq.n	2400b644 <HAL_I2C_Slave_Seq_Transmit_DMA+0x118>
        {
          hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
2400b5b2:	68fb      	ldr	r3, [r7, #12]
2400b5b4:	681b      	ldr	r3, [r3, #0]
2400b5b6:	681a      	ldr	r2, [r3, #0]
2400b5b8:	68fb      	ldr	r3, [r7, #12]
2400b5ba:	681b      	ldr	r3, [r3, #0]
2400b5bc:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
2400b5c0:	601a      	str	r2, [r3, #0]

          /* Set the I2C DMA Abort callback :
           will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
          hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
2400b5c2:	68fb      	ldr	r3, [r7, #12]
2400b5c4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400b5c6:	4a71      	ldr	r2, [pc, #452]	; (2400b78c <HAL_I2C_Slave_Seq_Transmit_DMA+0x260>)
2400b5c8:	651a      	str	r2, [r3, #80]	; 0x50

          /* Abort DMA RX */
          if (HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)
2400b5ca:	68fb      	ldr	r3, [r7, #12]
2400b5cc:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400b5ce:	4618      	mov	r0, r3
2400b5d0:	f7f7 fd44 	bl	2400305c <HAL_DMA_Abort_IT>
2400b5d4:	4603      	mov	r3, r0
2400b5d6:	2b00      	cmp	r3, #0
2400b5d8:	d034      	beq.n	2400b644 <HAL_I2C_Slave_Seq_Transmit_DMA+0x118>
          {
            /* Call Directly XferAbortCallback function in case of error */
            hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
2400b5da:	68fb      	ldr	r3, [r7, #12]
2400b5dc:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400b5de:	6d1b      	ldr	r3, [r3, #80]	; 0x50
2400b5e0:	68fa      	ldr	r2, [r7, #12]
2400b5e2:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
2400b5e4:	4610      	mov	r0, r2
2400b5e6:	4798      	blx	r3
2400b5e8:	e02c      	b.n	2400b644 <HAL_I2C_Slave_Seq_Transmit_DMA+0x118>
          }
        }
      }
    }
    else if (hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN)
2400b5ea:	68fb      	ldr	r3, [r7, #12]
2400b5ec:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400b5f0:	b2db      	uxtb	r3, r3
2400b5f2:	2b29      	cmp	r3, #41	; 0x29
2400b5f4:	d126      	bne.n	2400b644 <HAL_I2C_Slave_Seq_Transmit_DMA+0x118>
    {
      if ((hi2c->Instance->CR1 & I2C_CR1_TXDMAEN) == I2C_CR1_TXDMAEN)
2400b5f6:	68fb      	ldr	r3, [r7, #12]
2400b5f8:	681b      	ldr	r3, [r3, #0]
2400b5fa:	681b      	ldr	r3, [r3, #0]
2400b5fc:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
2400b600:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
2400b604:	d11e      	bne.n	2400b644 <HAL_I2C_Slave_Seq_Transmit_DMA+0x118>
      {
        hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
2400b606:	68fb      	ldr	r3, [r7, #12]
2400b608:	681b      	ldr	r3, [r3, #0]
2400b60a:	681a      	ldr	r2, [r3, #0]
2400b60c:	68fb      	ldr	r3, [r7, #12]
2400b60e:	681b      	ldr	r3, [r3, #0]
2400b610:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
2400b614:	601a      	str	r2, [r3, #0]

        /* Abort DMA Xfer if any */
        if (hi2c->hdmatx != NULL)
2400b616:	68fb      	ldr	r3, [r7, #12]
2400b618:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400b61a:	2b00      	cmp	r3, #0
2400b61c:	d012      	beq.n	2400b644 <HAL_I2C_Slave_Seq_Transmit_DMA+0x118>
        {
          /* Set the I2C DMA Abort callback :
           will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
          hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
2400b61e:	68fb      	ldr	r3, [r7, #12]
2400b620:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400b622:	4a5a      	ldr	r2, [pc, #360]	; (2400b78c <HAL_I2C_Slave_Seq_Transmit_DMA+0x260>)
2400b624:	651a      	str	r2, [r3, #80]	; 0x50

          /* Abort DMA TX */
          if (HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)
2400b626:	68fb      	ldr	r3, [r7, #12]
2400b628:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400b62a:	4618      	mov	r0, r3
2400b62c:	f7f7 fd16 	bl	2400305c <HAL_DMA_Abort_IT>
2400b630:	4603      	mov	r3, r0
2400b632:	2b00      	cmp	r3, #0
2400b634:	d006      	beq.n	2400b644 <HAL_I2C_Slave_Seq_Transmit_DMA+0x118>
          {
            /* Call Directly XferAbortCallback function in case of error */
            hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
2400b636:	68fb      	ldr	r3, [r7, #12]
2400b638:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400b63a:	6d1b      	ldr	r3, [r3, #80]	; 0x50
2400b63c:	68fa      	ldr	r2, [r7, #12]
2400b63e:	6b92      	ldr	r2, [r2, #56]	; 0x38
2400b640:	4610      	mov	r0, r2
2400b642:	4798      	blx	r3
    else
    {
      /* Nothing to do */
    }

    hi2c->State     = HAL_I2C_STATE_BUSY_TX_LISTEN;
2400b644:	68fb      	ldr	r3, [r7, #12]
2400b646:	2229      	movs	r2, #41	; 0x29
2400b648:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_SLAVE;
2400b64c:	68fb      	ldr	r3, [r7, #12]
2400b64e:	2220      	movs	r2, #32
2400b650:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
2400b654:	68fb      	ldr	r3, [r7, #12]
2400b656:	2200      	movs	r2, #0
2400b658:	645a      	str	r2, [r3, #68]	; 0x44

    /* Enable Address Acknowledge */
    hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
2400b65a:	68fb      	ldr	r3, [r7, #12]
2400b65c:	681b      	ldr	r3, [r3, #0]
2400b65e:	685a      	ldr	r2, [r3, #4]
2400b660:	68fb      	ldr	r3, [r7, #12]
2400b662:	681b      	ldr	r3, [r3, #0]
2400b664:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
2400b668:	605a      	str	r2, [r3, #4]

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
2400b66a:	68fb      	ldr	r3, [r7, #12]
2400b66c:	68ba      	ldr	r2, [r7, #8]
2400b66e:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
2400b670:	68fb      	ldr	r3, [r7, #12]
2400b672:	88fa      	ldrh	r2, [r7, #6]
2400b674:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferSize    = hi2c->XferCount;
2400b676:	68fb      	ldr	r3, [r7, #12]
2400b678:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400b67a:	b29a      	uxth	r2, r3
2400b67c:	68fb      	ldr	r3, [r7, #12]
2400b67e:	851a      	strh	r2, [r3, #40]	; 0x28
    hi2c->XferOptions = XferOptions;
2400b680:	68fb      	ldr	r3, [r7, #12]
2400b682:	683a      	ldr	r2, [r7, #0]
2400b684:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Slave_ISR_DMA;
2400b686:	68fb      	ldr	r3, [r7, #12]
2400b688:	4a41      	ldr	r2, [pc, #260]	; (2400b790 <HAL_I2C_Slave_Seq_Transmit_DMA+0x264>)
2400b68a:	635a      	str	r2, [r3, #52]	; 0x34

    if (hi2c->hdmatx != NULL)
2400b68c:	68fb      	ldr	r3, [r7, #12]
2400b68e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400b690:	2b00      	cmp	r3, #0
2400b692:	d020      	beq.n	2400b6d6 <HAL_I2C_Slave_Seq_Transmit_DMA+0x1aa>
    {
      /* Set the I2C DMA transfer complete callback */
      hi2c->hdmatx->XferCpltCallback = I2C_DMASlaveTransmitCplt;
2400b694:	68fb      	ldr	r3, [r7, #12]
2400b696:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400b698:	4a3e      	ldr	r2, [pc, #248]	; (2400b794 <HAL_I2C_Slave_Seq_Transmit_DMA+0x268>)
2400b69a:	63da      	str	r2, [r3, #60]	; 0x3c

      /* Set the DMA error callback */
      hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
2400b69c:	68fb      	ldr	r3, [r7, #12]
2400b69e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400b6a0:	4a3d      	ldr	r2, [pc, #244]	; (2400b798 <HAL_I2C_Slave_Seq_Transmit_DMA+0x26c>)
2400b6a2:	64da      	str	r2, [r3, #76]	; 0x4c

      /* Set the unused DMA callbacks to NULL */
      hi2c->hdmatx->XferHalfCpltCallback = NULL;
2400b6a4:	68fb      	ldr	r3, [r7, #12]
2400b6a6:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400b6a8:	2200      	movs	r2, #0
2400b6aa:	641a      	str	r2, [r3, #64]	; 0x40
      hi2c->hdmatx->XferAbortCallback = NULL;
2400b6ac:	68fb      	ldr	r3, [r7, #12]
2400b6ae:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400b6b0:	2200      	movs	r2, #0
2400b6b2:	651a      	str	r2, [r3, #80]	; 0x50

      /* Enable the DMA stream or channel depends on Instance */
      dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->TXDR, hi2c->XferSize);
2400b6b4:	68fb      	ldr	r3, [r7, #12]
2400b6b6:	6b98      	ldr	r0, [r3, #56]	; 0x38
2400b6b8:	68b9      	ldr	r1, [r7, #8]
2400b6ba:	68fb      	ldr	r3, [r7, #12]
2400b6bc:	681b      	ldr	r3, [r3, #0]
2400b6be:	3328      	adds	r3, #40	; 0x28
2400b6c0:	461a      	mov	r2, r3
2400b6c2:	68fb      	ldr	r3, [r7, #12]
2400b6c4:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400b6c6:	f7f6 ff41 	bl	2400254c <HAL_DMA_Start_IT>
2400b6ca:	4603      	mov	r3, r0
2400b6cc:	75fb      	strb	r3, [r7, #23]
      __HAL_UNLOCK(hi2c);

      return HAL_ERROR;
    }

    if (dmaxferstatus == HAL_OK)
2400b6ce:	7dfb      	ldrb	r3, [r7, #23]
2400b6d0:	2b00      	cmp	r3, #0
2400b6d2:	d12b      	bne.n	2400b72c <HAL_I2C_Slave_Seq_Transmit_DMA+0x200>
2400b6d4:	e013      	b.n	2400b6fe <HAL_I2C_Slave_Seq_Transmit_DMA+0x1d2>
      hi2c->State     = HAL_I2C_STATE_LISTEN;
2400b6d6:	68fb      	ldr	r3, [r7, #12]
2400b6d8:	2228      	movs	r2, #40	; 0x28
2400b6da:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
      hi2c->Mode      = HAL_I2C_MODE_NONE;
2400b6de:	68fb      	ldr	r3, [r7, #12]
2400b6e0:	2200      	movs	r2, #0
2400b6e2:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
      hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
2400b6e6:	68fb      	ldr	r3, [r7, #12]
2400b6e8:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400b6ea:	f043 0280 	orr.w	r2, r3, #128	; 0x80
2400b6ee:	68fb      	ldr	r3, [r7, #12]
2400b6f0:	645a      	str	r2, [r3, #68]	; 0x44
      __HAL_UNLOCK(hi2c);
2400b6f2:	68fb      	ldr	r3, [r7, #12]
2400b6f4:	2200      	movs	r2, #0
2400b6f6:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
2400b6fa:	2301      	movs	r3, #1
2400b6fc:	e042      	b.n	2400b784 <HAL_I2C_Slave_Seq_Transmit_DMA+0x258>
    {
      /* Update XferCount value */
      hi2c->XferCount -= hi2c->XferSize;
2400b6fe:	68fb      	ldr	r3, [r7, #12]
2400b700:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400b702:	b29a      	uxth	r2, r3
2400b704:	68fb      	ldr	r3, [r7, #12]
2400b706:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400b708:	1ad3      	subs	r3, r2, r3
2400b70a:	b29a      	uxth	r2, r3
2400b70c:	68fb      	ldr	r3, [r7, #12]
2400b70e:	855a      	strh	r2, [r3, #42]	; 0x2a

      /* Reset XferSize */
      hi2c->XferSize = 0;
2400b710:	68fb      	ldr	r3, [r7, #12]
2400b712:	2200      	movs	r2, #0
2400b714:	851a      	strh	r2, [r3, #40]	; 0x28
      __HAL_UNLOCK(hi2c);

      return HAL_ERROR;
    }

    if (I2C_GET_DIR(hi2c) == I2C_DIRECTION_RECEIVE)
2400b716:	68fb      	ldr	r3, [r7, #12]
2400b718:	681b      	ldr	r3, [r3, #0]
2400b71a:	699b      	ldr	r3, [r3, #24]
2400b71c:	0c1b      	lsrs	r3, r3, #16
2400b71e:	b2db      	uxtb	r3, r3
2400b720:	f003 0301 	and.w	r3, r3, #1
2400b724:	b2db      	uxtb	r3, r3
2400b726:	2b01      	cmp	r3, #1
2400b728:	d118      	bne.n	2400b75c <HAL_I2C_Slave_Seq_Transmit_DMA+0x230>
2400b72a:	e013      	b.n	2400b754 <HAL_I2C_Slave_Seq_Transmit_DMA+0x228>
      hi2c->State     = HAL_I2C_STATE_LISTEN;
2400b72c:	68fb      	ldr	r3, [r7, #12]
2400b72e:	2228      	movs	r2, #40	; 0x28
2400b730:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
      hi2c->Mode      = HAL_I2C_MODE_NONE;
2400b734:	68fb      	ldr	r3, [r7, #12]
2400b736:	2200      	movs	r2, #0
2400b738:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
      hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
2400b73c:	68fb      	ldr	r3, [r7, #12]
2400b73e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400b740:	f043 0210 	orr.w	r2, r3, #16
2400b744:	68fb      	ldr	r3, [r7, #12]
2400b746:	645a      	str	r2, [r3, #68]	; 0x44
      __HAL_UNLOCK(hi2c);
2400b748:	68fb      	ldr	r3, [r7, #12]
2400b74a:	2200      	movs	r2, #0
2400b74c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
2400b750:	2301      	movs	r3, #1
2400b752:	e017      	b.n	2400b784 <HAL_I2C_Slave_Seq_Transmit_DMA+0x258>
    {
      /* Clear ADDR flag after prepare the transfer parameters */
      /* This action will generate an acknowledge to the Master */
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
2400b754:	68fb      	ldr	r3, [r7, #12]
2400b756:	681b      	ldr	r3, [r3, #0]
2400b758:	2208      	movs	r2, #8
2400b75a:	61da      	str	r2, [r3, #28]
    }

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2400b75c:	68fb      	ldr	r3, [r7, #12]
2400b75e:	2200      	movs	r2, #0
2400b760:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Note : The I2C interrupts must be enabled after unlocking current process
    to avoid the risk of I2C interrupt handle execution before current
    process unlock */
    /* Enable ERR, STOP, NACK, ADDR interrupts */
    I2C_Enable_IRQ(hi2c, I2C_XFER_LISTEN_IT);
2400b764:	f44f 4100 	mov.w	r1, #32768	; 0x8000
2400b768:	68f8      	ldr	r0, [r7, #12]
2400b76a:	f002 fb13 	bl	2400dd94 <I2C_Enable_IRQ>

    /* Enable DMA Request */
    hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN;
2400b76e:	68fb      	ldr	r3, [r7, #12]
2400b770:	681b      	ldr	r3, [r3, #0]
2400b772:	681a      	ldr	r2, [r3, #0]
2400b774:	68fb      	ldr	r3, [r7, #12]
2400b776:	681b      	ldr	r3, [r3, #0]
2400b778:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
2400b77c:	601a      	str	r2, [r3, #0]

    return HAL_OK;
2400b77e:	2300      	movs	r3, #0
2400b780:	e000      	b.n	2400b784 <HAL_I2C_Slave_Seq_Transmit_DMA+0x258>
  }
  else
  {
    return HAL_ERROR;
2400b782:	2301      	movs	r3, #1
  }
}
2400b784:	4618      	mov	r0, r3
2400b786:	3718      	adds	r7, #24
2400b788:	46bd      	mov	sp, r7
2400b78a:	bd80      	pop	{r7, pc}
2400b78c:	2400d9e1 	.word	0x2400d9e1
2400b790:	2400c4ed 	.word	0x2400c4ed
2400b794:	2400d535 	.word	0x2400d535
2400b798:	2400d771 	.word	0x2400d771

2400b79c <HAL_I2C_Slave_Seq_Receive_IT>:
  * @param  Size Amount of data to be sent
  * @param  XferOptions Options of Transfer, value of @ref I2C_XFEROPTIONS
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Slave_Seq_Receive_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t XferOptions)
{
2400b79c:	b580      	push	{r7, lr}
2400b79e:	b084      	sub	sp, #16
2400b7a0:	af00      	add	r7, sp, #0
2400b7a2:	60f8      	str	r0, [r7, #12]
2400b7a4:	60b9      	str	r1, [r7, #8]
2400b7a6:	603b      	str	r3, [r7, #0]
2400b7a8:	4613      	mov	r3, r2
2400b7aa:	80fb      	strh	r3, [r7, #6]
  /* Check the parameters */
  assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));

  if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
2400b7ac:	68fb      	ldr	r3, [r7, #12]
2400b7ae:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400b7b2:	b2db      	uxtb	r3, r3
2400b7b4:	f003 0328 	and.w	r3, r3, #40	; 0x28
2400b7b8:	2b28      	cmp	r3, #40	; 0x28
2400b7ba:	f040 808a 	bne.w	2400b8d2 <HAL_I2C_Slave_Seq_Receive_IT+0x136>
  {
    if ((pData == NULL) || (Size == 0U))
2400b7be:	68bb      	ldr	r3, [r7, #8]
2400b7c0:	2b00      	cmp	r3, #0
2400b7c2:	d002      	beq.n	2400b7ca <HAL_I2C_Slave_Seq_Receive_IT+0x2e>
2400b7c4:	88fb      	ldrh	r3, [r7, #6]
2400b7c6:	2b00      	cmp	r3, #0
2400b7c8:	d105      	bne.n	2400b7d6 <HAL_I2C_Slave_Seq_Receive_IT+0x3a>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
2400b7ca:	68fb      	ldr	r3, [r7, #12]
2400b7cc:	f44f 7200 	mov.w	r2, #512	; 0x200
2400b7d0:	645a      	str	r2, [r3, #68]	; 0x44
      return  HAL_ERROR;
2400b7d2:	2301      	movs	r3, #1
2400b7d4:	e07e      	b.n	2400b8d4 <HAL_I2C_Slave_Seq_Receive_IT+0x138>
    }

    /* Disable Interrupts, to prevent preemption during treatment in case of multicall */
    I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_RX_IT);
2400b7d6:	f248 0102 	movw	r1, #32770	; 0x8002
2400b7da:	68f8      	ldr	r0, [r7, #12]
2400b7dc:	f002 fb3e 	bl	2400de5c <I2C_Disable_IRQ>

    /* Process Locked */
    __HAL_LOCK(hi2c);
2400b7e0:	68fb      	ldr	r3, [r7, #12]
2400b7e2:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400b7e6:	2b01      	cmp	r3, #1
2400b7e8:	d101      	bne.n	2400b7ee <HAL_I2C_Slave_Seq_Receive_IT+0x52>
2400b7ea:	2302      	movs	r3, #2
2400b7ec:	e072      	b.n	2400b8d4 <HAL_I2C_Slave_Seq_Receive_IT+0x138>
2400b7ee:	68fb      	ldr	r3, [r7, #12]
2400b7f0:	2201      	movs	r2, #1
2400b7f2:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* I2C cannot manage full duplex exchange so disable previous IT enabled if any */
    /* and then toggle the HAL slave TX state to RX state */
    if (hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN)
2400b7f6:	68fb      	ldr	r3, [r7, #12]
2400b7f8:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400b7fc:	b2db      	uxtb	r3, r3
2400b7fe:	2b29      	cmp	r3, #41	; 0x29
2400b800:	d12a      	bne.n	2400b858 <HAL_I2C_Slave_Seq_Receive_IT+0xbc>
    {
      /* Disable associated Interrupts */
      I2C_Disable_IRQ(hi2c, I2C_XFER_TX_IT);
2400b802:	2101      	movs	r1, #1
2400b804:	68f8      	ldr	r0, [r7, #12]
2400b806:	f002 fb29 	bl	2400de5c <I2C_Disable_IRQ>

      if ((hi2c->Instance->CR1 & I2C_CR1_TXDMAEN) == I2C_CR1_TXDMAEN)
2400b80a:	68fb      	ldr	r3, [r7, #12]
2400b80c:	681b      	ldr	r3, [r3, #0]
2400b80e:	681b      	ldr	r3, [r3, #0]
2400b810:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
2400b814:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
2400b818:	d11e      	bne.n	2400b858 <HAL_I2C_Slave_Seq_Receive_IT+0xbc>
      {
        hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
2400b81a:	68fb      	ldr	r3, [r7, #12]
2400b81c:	681b      	ldr	r3, [r3, #0]
2400b81e:	681a      	ldr	r2, [r3, #0]
2400b820:	68fb      	ldr	r3, [r7, #12]
2400b822:	681b      	ldr	r3, [r3, #0]
2400b824:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
2400b828:	601a      	str	r2, [r3, #0]

        /* Abort DMA Xfer if any */
        if (hi2c->hdmatx != NULL)
2400b82a:	68fb      	ldr	r3, [r7, #12]
2400b82c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400b82e:	2b00      	cmp	r3, #0
2400b830:	d012      	beq.n	2400b858 <HAL_I2C_Slave_Seq_Receive_IT+0xbc>
        {
          /* Set the I2C DMA Abort callback :
           will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
          hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
2400b832:	68fb      	ldr	r3, [r7, #12]
2400b834:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400b836:	4a29      	ldr	r2, [pc, #164]	; (2400b8dc <HAL_I2C_Slave_Seq_Receive_IT+0x140>)
2400b838:	651a      	str	r2, [r3, #80]	; 0x50

          /* Abort DMA TX */
          if (HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)
2400b83a:	68fb      	ldr	r3, [r7, #12]
2400b83c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400b83e:	4618      	mov	r0, r3
2400b840:	f7f7 fc0c 	bl	2400305c <HAL_DMA_Abort_IT>
2400b844:	4603      	mov	r3, r0
2400b846:	2b00      	cmp	r3, #0
2400b848:	d006      	beq.n	2400b858 <HAL_I2C_Slave_Seq_Receive_IT+0xbc>
          {
            /* Call Directly XferAbortCallback function in case of error */
            hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
2400b84a:	68fb      	ldr	r3, [r7, #12]
2400b84c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400b84e:	6d1b      	ldr	r3, [r3, #80]	; 0x50
2400b850:	68fa      	ldr	r2, [r7, #12]
2400b852:	6b92      	ldr	r2, [r2, #56]	; 0x38
2400b854:	4610      	mov	r0, r2
2400b856:	4798      	blx	r3
          }
        }
      }
    }

    hi2c->State     = HAL_I2C_STATE_BUSY_RX_LISTEN;
2400b858:	68fb      	ldr	r3, [r7, #12]
2400b85a:	222a      	movs	r2, #42	; 0x2a
2400b85c:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_SLAVE;
2400b860:	68fb      	ldr	r3, [r7, #12]
2400b862:	2220      	movs	r2, #32
2400b864:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
2400b868:	68fb      	ldr	r3, [r7, #12]
2400b86a:	2200      	movs	r2, #0
2400b86c:	645a      	str	r2, [r3, #68]	; 0x44

    /* Enable Address Acknowledge */
    hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
2400b86e:	68fb      	ldr	r3, [r7, #12]
2400b870:	681b      	ldr	r3, [r3, #0]
2400b872:	685a      	ldr	r2, [r3, #4]
2400b874:	68fb      	ldr	r3, [r7, #12]
2400b876:	681b      	ldr	r3, [r3, #0]
2400b878:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
2400b87c:	605a      	str	r2, [r3, #4]

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
2400b87e:	68fb      	ldr	r3, [r7, #12]
2400b880:	68ba      	ldr	r2, [r7, #8]
2400b882:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
2400b884:	68fb      	ldr	r3, [r7, #12]
2400b886:	88fa      	ldrh	r2, [r7, #6]
2400b888:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferSize    = hi2c->XferCount;
2400b88a:	68fb      	ldr	r3, [r7, #12]
2400b88c:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400b88e:	b29a      	uxth	r2, r3
2400b890:	68fb      	ldr	r3, [r7, #12]
2400b892:	851a      	strh	r2, [r3, #40]	; 0x28
    hi2c->XferOptions = XferOptions;
2400b894:	68fb      	ldr	r3, [r7, #12]
2400b896:	683a      	ldr	r2, [r7, #0]
2400b898:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Slave_ISR_IT;
2400b89a:	68fb      	ldr	r3, [r7, #12]
2400b89c:	4a10      	ldr	r2, [pc, #64]	; (2400b8e0 <HAL_I2C_Slave_Seq_Receive_IT+0x144>)
2400b89e:	635a      	str	r2, [r3, #52]	; 0x34

    if (I2C_GET_DIR(hi2c) == I2C_DIRECTION_TRANSMIT)
2400b8a0:	68fb      	ldr	r3, [r7, #12]
2400b8a2:	681b      	ldr	r3, [r3, #0]
2400b8a4:	699b      	ldr	r3, [r3, #24]
2400b8a6:	0c1b      	lsrs	r3, r3, #16
2400b8a8:	b2db      	uxtb	r3, r3
2400b8aa:	f003 0301 	and.w	r3, r3, #1
2400b8ae:	b2db      	uxtb	r3, r3
2400b8b0:	2b00      	cmp	r3, #0
2400b8b2:	d103      	bne.n	2400b8bc <HAL_I2C_Slave_Seq_Receive_IT+0x120>
    {
      /* Clear ADDR flag after prepare the transfer parameters */
      /* This action will generate an acknowledge to the Master */
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
2400b8b4:	68fb      	ldr	r3, [r7, #12]
2400b8b6:	681b      	ldr	r3, [r3, #0]
2400b8b8:	2208      	movs	r2, #8
2400b8ba:	61da      	str	r2, [r3, #28]
    }

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2400b8bc:	68fb      	ldr	r3, [r7, #12]
2400b8be:	2200      	movs	r2, #0
2400b8c0:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Note : The I2C interrupts must be enabled after unlocking current process
    to avoid the risk of I2C interrupt handle execution before current
    process unlock */
    /* REnable ADDR interrupt */
    I2C_Enable_IRQ(hi2c, I2C_XFER_RX_IT | I2C_XFER_LISTEN_IT);
2400b8c4:	f248 0102 	movw	r1, #32770	; 0x8002
2400b8c8:	68f8      	ldr	r0, [r7, #12]
2400b8ca:	f002 fa63 	bl	2400dd94 <I2C_Enable_IRQ>

    return HAL_OK;
2400b8ce:	2300      	movs	r3, #0
2400b8d0:	e000      	b.n	2400b8d4 <HAL_I2C_Slave_Seq_Receive_IT+0x138>
  }
  else
  {
    return HAL_ERROR;
2400b8d2:	2301      	movs	r3, #1
  }
}
2400b8d4:	4618      	mov	r0, r3
2400b8d6:	3710      	adds	r7, #16
2400b8d8:	46bd      	mov	sp, r7
2400b8da:	bd80      	pop	{r7, pc}
2400b8dc:	2400d9e1 	.word	0x2400d9e1
2400b8e0:	2400c101 	.word	0x2400c101

2400b8e4 <HAL_I2C_Slave_Seq_Receive_DMA>:
  * @param  Size Amount of data to be sent
  * @param  XferOptions Options of Transfer, value of @ref I2C_XFEROPTIONS
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Slave_Seq_Receive_DMA(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t XferOptions)
{
2400b8e4:	b580      	push	{r7, lr}
2400b8e6:	b086      	sub	sp, #24
2400b8e8:	af00      	add	r7, sp, #0
2400b8ea:	60f8      	str	r0, [r7, #12]
2400b8ec:	60b9      	str	r1, [r7, #8]
2400b8ee:	603b      	str	r3, [r7, #0]
2400b8f0:	4613      	mov	r3, r2
2400b8f2:	80fb      	strh	r3, [r7, #6]
  HAL_StatusTypeDef dmaxferstatus;

  /* Check the parameters */
  assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));

  if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
2400b8f4:	68fb      	ldr	r3, [r7, #12]
2400b8f6:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400b8fa:	b2db      	uxtb	r3, r3
2400b8fc:	f003 0328 	and.w	r3, r3, #40	; 0x28
2400b900:	2b28      	cmp	r3, #40	; 0x28
2400b902:	f040 811a 	bne.w	2400bb3a <HAL_I2C_Slave_Seq_Receive_DMA+0x256>
  {
    if ((pData == NULL) || (Size == 0U))
2400b906:	68bb      	ldr	r3, [r7, #8]
2400b908:	2b00      	cmp	r3, #0
2400b90a:	d002      	beq.n	2400b912 <HAL_I2C_Slave_Seq_Receive_DMA+0x2e>
2400b90c:	88fb      	ldrh	r3, [r7, #6]
2400b90e:	2b00      	cmp	r3, #0
2400b910:	d105      	bne.n	2400b91e <HAL_I2C_Slave_Seq_Receive_DMA+0x3a>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
2400b912:	68fb      	ldr	r3, [r7, #12]
2400b914:	f44f 7200 	mov.w	r2, #512	; 0x200
2400b918:	645a      	str	r2, [r3, #68]	; 0x44
      return  HAL_ERROR;
2400b91a:	2301      	movs	r3, #1
2400b91c:	e10e      	b.n	2400bb3c <HAL_I2C_Slave_Seq_Receive_DMA+0x258>
    }

    /* Disable Interrupts, to prevent preemption during treatment in case of multicall */
    I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_RX_IT);
2400b91e:	f248 0102 	movw	r1, #32770	; 0x8002
2400b922:	68f8      	ldr	r0, [r7, #12]
2400b924:	f002 fa9a 	bl	2400de5c <I2C_Disable_IRQ>

    /* Process Locked */
    __HAL_LOCK(hi2c);
2400b928:	68fb      	ldr	r3, [r7, #12]
2400b92a:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400b92e:	2b01      	cmp	r3, #1
2400b930:	d101      	bne.n	2400b936 <HAL_I2C_Slave_Seq_Receive_DMA+0x52>
2400b932:	2302      	movs	r3, #2
2400b934:	e102      	b.n	2400bb3c <HAL_I2C_Slave_Seq_Receive_DMA+0x258>
2400b936:	68fb      	ldr	r3, [r7, #12]
2400b938:	2201      	movs	r2, #1
2400b93a:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* I2C cannot manage full duplex exchange so disable previous IT enabled if any */
    /* and then toggle the HAL slave TX state to RX state */
    if (hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN)
2400b93e:	68fb      	ldr	r3, [r7, #12]
2400b940:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400b944:	b2db      	uxtb	r3, r3
2400b946:	2b29      	cmp	r3, #41	; 0x29
2400b948:	d12b      	bne.n	2400b9a2 <HAL_I2C_Slave_Seq_Receive_DMA+0xbe>
    {
      /* Disable associated Interrupts */
      I2C_Disable_IRQ(hi2c, I2C_XFER_TX_IT);
2400b94a:	2101      	movs	r1, #1
2400b94c:	68f8      	ldr	r0, [r7, #12]
2400b94e:	f002 fa85 	bl	2400de5c <I2C_Disable_IRQ>

      if ((hi2c->Instance->CR1 & I2C_CR1_TXDMAEN) == I2C_CR1_TXDMAEN)
2400b952:	68fb      	ldr	r3, [r7, #12]
2400b954:	681b      	ldr	r3, [r3, #0]
2400b956:	681b      	ldr	r3, [r3, #0]
2400b958:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
2400b95c:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
2400b960:	d14c      	bne.n	2400b9fc <HAL_I2C_Slave_Seq_Receive_DMA+0x118>
      {
        /* Abort DMA Xfer if any */
        if (hi2c->hdmatx != NULL)
2400b962:	68fb      	ldr	r3, [r7, #12]
2400b964:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400b966:	2b00      	cmp	r3, #0
2400b968:	d048      	beq.n	2400b9fc <HAL_I2C_Slave_Seq_Receive_DMA+0x118>
        {
          hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
2400b96a:	68fb      	ldr	r3, [r7, #12]
2400b96c:	681b      	ldr	r3, [r3, #0]
2400b96e:	681a      	ldr	r2, [r3, #0]
2400b970:	68fb      	ldr	r3, [r7, #12]
2400b972:	681b      	ldr	r3, [r3, #0]
2400b974:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
2400b978:	601a      	str	r2, [r3, #0]

          /* Set the I2C DMA Abort callback :
           will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
          hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
2400b97a:	68fb      	ldr	r3, [r7, #12]
2400b97c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400b97e:	4a71      	ldr	r2, [pc, #452]	; (2400bb44 <HAL_I2C_Slave_Seq_Receive_DMA+0x260>)
2400b980:	651a      	str	r2, [r3, #80]	; 0x50

          /* Abort DMA TX */
          if (HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)
2400b982:	68fb      	ldr	r3, [r7, #12]
2400b984:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400b986:	4618      	mov	r0, r3
2400b988:	f7f7 fb68 	bl	2400305c <HAL_DMA_Abort_IT>
2400b98c:	4603      	mov	r3, r0
2400b98e:	2b00      	cmp	r3, #0
2400b990:	d034      	beq.n	2400b9fc <HAL_I2C_Slave_Seq_Receive_DMA+0x118>
          {
            /* Call Directly XferAbortCallback function in case of error */
            hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
2400b992:	68fb      	ldr	r3, [r7, #12]
2400b994:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400b996:	6d1b      	ldr	r3, [r3, #80]	; 0x50
2400b998:	68fa      	ldr	r2, [r7, #12]
2400b99a:	6b92      	ldr	r2, [r2, #56]	; 0x38
2400b99c:	4610      	mov	r0, r2
2400b99e:	4798      	blx	r3
2400b9a0:	e02c      	b.n	2400b9fc <HAL_I2C_Slave_Seq_Receive_DMA+0x118>
          }
        }
      }
    }
    else if (hi2c->State == HAL_I2C_STATE_BUSY_RX_LISTEN)
2400b9a2:	68fb      	ldr	r3, [r7, #12]
2400b9a4:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400b9a8:	b2db      	uxtb	r3, r3
2400b9aa:	2b2a      	cmp	r3, #42	; 0x2a
2400b9ac:	d126      	bne.n	2400b9fc <HAL_I2C_Slave_Seq_Receive_DMA+0x118>
    {
      if ((hi2c->Instance->CR1 & I2C_CR1_RXDMAEN) == I2C_CR1_RXDMAEN)
2400b9ae:	68fb      	ldr	r3, [r7, #12]
2400b9b0:	681b      	ldr	r3, [r3, #0]
2400b9b2:	681b      	ldr	r3, [r3, #0]
2400b9b4:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
2400b9b8:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
2400b9bc:	d11e      	bne.n	2400b9fc <HAL_I2C_Slave_Seq_Receive_DMA+0x118>
      {
        hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
2400b9be:	68fb      	ldr	r3, [r7, #12]
2400b9c0:	681b      	ldr	r3, [r3, #0]
2400b9c2:	681a      	ldr	r2, [r3, #0]
2400b9c4:	68fb      	ldr	r3, [r7, #12]
2400b9c6:	681b      	ldr	r3, [r3, #0]
2400b9c8:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
2400b9cc:	601a      	str	r2, [r3, #0]

        /* Abort DMA Xfer if any */
        if (hi2c->hdmarx != NULL)
2400b9ce:	68fb      	ldr	r3, [r7, #12]
2400b9d0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400b9d2:	2b00      	cmp	r3, #0
2400b9d4:	d012      	beq.n	2400b9fc <HAL_I2C_Slave_Seq_Receive_DMA+0x118>
        {
          /* Set the I2C DMA Abort callback :
           will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
          hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
2400b9d6:	68fb      	ldr	r3, [r7, #12]
2400b9d8:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400b9da:	4a5a      	ldr	r2, [pc, #360]	; (2400bb44 <HAL_I2C_Slave_Seq_Receive_DMA+0x260>)
2400b9dc:	651a      	str	r2, [r3, #80]	; 0x50

          /* Abort DMA RX */
          if (HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)
2400b9de:	68fb      	ldr	r3, [r7, #12]
2400b9e0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400b9e2:	4618      	mov	r0, r3
2400b9e4:	f7f7 fb3a 	bl	2400305c <HAL_DMA_Abort_IT>
2400b9e8:	4603      	mov	r3, r0
2400b9ea:	2b00      	cmp	r3, #0
2400b9ec:	d006      	beq.n	2400b9fc <HAL_I2C_Slave_Seq_Receive_DMA+0x118>
          {
            /* Call Directly XferAbortCallback function in case of error */
            hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
2400b9ee:	68fb      	ldr	r3, [r7, #12]
2400b9f0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400b9f2:	6d1b      	ldr	r3, [r3, #80]	; 0x50
2400b9f4:	68fa      	ldr	r2, [r7, #12]
2400b9f6:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
2400b9f8:	4610      	mov	r0, r2
2400b9fa:	4798      	blx	r3
    else
    {
      /* Nothing to do */
    }

    hi2c->State     = HAL_I2C_STATE_BUSY_RX_LISTEN;
2400b9fc:	68fb      	ldr	r3, [r7, #12]
2400b9fe:	222a      	movs	r2, #42	; 0x2a
2400ba00:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_SLAVE;
2400ba04:	68fb      	ldr	r3, [r7, #12]
2400ba06:	2220      	movs	r2, #32
2400ba08:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
2400ba0c:	68fb      	ldr	r3, [r7, #12]
2400ba0e:	2200      	movs	r2, #0
2400ba10:	645a      	str	r2, [r3, #68]	; 0x44

    /* Enable Address Acknowledge */
    hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
2400ba12:	68fb      	ldr	r3, [r7, #12]
2400ba14:	681b      	ldr	r3, [r3, #0]
2400ba16:	685a      	ldr	r2, [r3, #4]
2400ba18:	68fb      	ldr	r3, [r7, #12]
2400ba1a:	681b      	ldr	r3, [r3, #0]
2400ba1c:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
2400ba20:	605a      	str	r2, [r3, #4]

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
2400ba22:	68fb      	ldr	r3, [r7, #12]
2400ba24:	68ba      	ldr	r2, [r7, #8]
2400ba26:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
2400ba28:	68fb      	ldr	r3, [r7, #12]
2400ba2a:	88fa      	ldrh	r2, [r7, #6]
2400ba2c:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferSize    = hi2c->XferCount;
2400ba2e:	68fb      	ldr	r3, [r7, #12]
2400ba30:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400ba32:	b29a      	uxth	r2, r3
2400ba34:	68fb      	ldr	r3, [r7, #12]
2400ba36:	851a      	strh	r2, [r3, #40]	; 0x28
    hi2c->XferOptions = XferOptions;
2400ba38:	68fb      	ldr	r3, [r7, #12]
2400ba3a:	683a      	ldr	r2, [r7, #0]
2400ba3c:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Slave_ISR_DMA;
2400ba3e:	68fb      	ldr	r3, [r7, #12]
2400ba40:	4a41      	ldr	r2, [pc, #260]	; (2400bb48 <HAL_I2C_Slave_Seq_Receive_DMA+0x264>)
2400ba42:	635a      	str	r2, [r3, #52]	; 0x34

    if (hi2c->hdmarx != NULL)
2400ba44:	68fb      	ldr	r3, [r7, #12]
2400ba46:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400ba48:	2b00      	cmp	r3, #0
2400ba4a:	d020      	beq.n	2400ba8e <HAL_I2C_Slave_Seq_Receive_DMA+0x1aa>
    {
      /* Set the I2C DMA transfer complete callback */
      hi2c->hdmarx->XferCpltCallback = I2C_DMASlaveReceiveCplt;
2400ba4c:	68fb      	ldr	r3, [r7, #12]
2400ba4e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400ba50:	4a3e      	ldr	r2, [pc, #248]	; (2400bb4c <HAL_I2C_Slave_Seq_Receive_DMA+0x268>)
2400ba52:	63da      	str	r2, [r3, #60]	; 0x3c

      /* Set the DMA error callback */
      hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
2400ba54:	68fb      	ldr	r3, [r7, #12]
2400ba56:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400ba58:	4a3d      	ldr	r2, [pc, #244]	; (2400bb50 <HAL_I2C_Slave_Seq_Receive_DMA+0x26c>)
2400ba5a:	64da      	str	r2, [r3, #76]	; 0x4c

      /* Set the unused DMA callbacks to NULL */
      hi2c->hdmarx->XferHalfCpltCallback = NULL;
2400ba5c:	68fb      	ldr	r3, [r7, #12]
2400ba5e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400ba60:	2200      	movs	r2, #0
2400ba62:	641a      	str	r2, [r3, #64]	; 0x40
      hi2c->hdmarx->XferAbortCallback = NULL;
2400ba64:	68fb      	ldr	r3, [r7, #12]
2400ba66:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400ba68:	2200      	movs	r2, #0
2400ba6a:	651a      	str	r2, [r3, #80]	; 0x50

      /* Enable the DMA stream or channel depends on Instance */
      dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)pData, hi2c->XferSize);
2400ba6c:	68fb      	ldr	r3, [r7, #12]
2400ba6e:	6bd8      	ldr	r0, [r3, #60]	; 0x3c
2400ba70:	68fb      	ldr	r3, [r7, #12]
2400ba72:	681b      	ldr	r3, [r3, #0]
2400ba74:	3324      	adds	r3, #36	; 0x24
2400ba76:	4619      	mov	r1, r3
2400ba78:	68ba      	ldr	r2, [r7, #8]
2400ba7a:	68fb      	ldr	r3, [r7, #12]
2400ba7c:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400ba7e:	f7f6 fd65 	bl	2400254c <HAL_DMA_Start_IT>
2400ba82:	4603      	mov	r3, r0
2400ba84:	75fb      	strb	r3, [r7, #23]
      __HAL_UNLOCK(hi2c);

      return HAL_ERROR;
    }

    if (dmaxferstatus == HAL_OK)
2400ba86:	7dfb      	ldrb	r3, [r7, #23]
2400ba88:	2b00      	cmp	r3, #0
2400ba8a:	d12b      	bne.n	2400bae4 <HAL_I2C_Slave_Seq_Receive_DMA+0x200>
2400ba8c:	e013      	b.n	2400bab6 <HAL_I2C_Slave_Seq_Receive_DMA+0x1d2>
      hi2c->State     = HAL_I2C_STATE_LISTEN;
2400ba8e:	68fb      	ldr	r3, [r7, #12]
2400ba90:	2228      	movs	r2, #40	; 0x28
2400ba92:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
      hi2c->Mode      = HAL_I2C_MODE_NONE;
2400ba96:	68fb      	ldr	r3, [r7, #12]
2400ba98:	2200      	movs	r2, #0
2400ba9a:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
      hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
2400ba9e:	68fb      	ldr	r3, [r7, #12]
2400baa0:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400baa2:	f043 0280 	orr.w	r2, r3, #128	; 0x80
2400baa6:	68fb      	ldr	r3, [r7, #12]
2400baa8:	645a      	str	r2, [r3, #68]	; 0x44
      __HAL_UNLOCK(hi2c);
2400baaa:	68fb      	ldr	r3, [r7, #12]
2400baac:	2200      	movs	r2, #0
2400baae:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
2400bab2:	2301      	movs	r3, #1
2400bab4:	e042      	b.n	2400bb3c <HAL_I2C_Slave_Seq_Receive_DMA+0x258>
    {
      /* Update XferCount value */
      hi2c->XferCount -= hi2c->XferSize;
2400bab6:	68fb      	ldr	r3, [r7, #12]
2400bab8:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400baba:	b29a      	uxth	r2, r3
2400babc:	68fb      	ldr	r3, [r7, #12]
2400babe:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400bac0:	1ad3      	subs	r3, r2, r3
2400bac2:	b29a      	uxth	r2, r3
2400bac4:	68fb      	ldr	r3, [r7, #12]
2400bac6:	855a      	strh	r2, [r3, #42]	; 0x2a

      /* Reset XferSize */
      hi2c->XferSize = 0;
2400bac8:	68fb      	ldr	r3, [r7, #12]
2400baca:	2200      	movs	r2, #0
2400bacc:	851a      	strh	r2, [r3, #40]	; 0x28
      __HAL_UNLOCK(hi2c);

      return HAL_ERROR;
    }

    if (I2C_GET_DIR(hi2c) == I2C_DIRECTION_TRANSMIT)
2400bace:	68fb      	ldr	r3, [r7, #12]
2400bad0:	681b      	ldr	r3, [r3, #0]
2400bad2:	699b      	ldr	r3, [r3, #24]
2400bad4:	0c1b      	lsrs	r3, r3, #16
2400bad6:	b2db      	uxtb	r3, r3
2400bad8:	f003 0301 	and.w	r3, r3, #1
2400badc:	b2db      	uxtb	r3, r3
2400bade:	2b00      	cmp	r3, #0
2400bae0:	d118      	bne.n	2400bb14 <HAL_I2C_Slave_Seq_Receive_DMA+0x230>
2400bae2:	e013      	b.n	2400bb0c <HAL_I2C_Slave_Seq_Receive_DMA+0x228>
      hi2c->State     = HAL_I2C_STATE_LISTEN;
2400bae4:	68fb      	ldr	r3, [r7, #12]
2400bae6:	2228      	movs	r2, #40	; 0x28
2400bae8:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
      hi2c->Mode      = HAL_I2C_MODE_NONE;
2400baec:	68fb      	ldr	r3, [r7, #12]
2400baee:	2200      	movs	r2, #0
2400baf0:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
      hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
2400baf4:	68fb      	ldr	r3, [r7, #12]
2400baf6:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400baf8:	f043 0210 	orr.w	r2, r3, #16
2400bafc:	68fb      	ldr	r3, [r7, #12]
2400bafe:	645a      	str	r2, [r3, #68]	; 0x44
      __HAL_UNLOCK(hi2c);
2400bb00:	68fb      	ldr	r3, [r7, #12]
2400bb02:	2200      	movs	r2, #0
2400bb04:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
2400bb08:	2301      	movs	r3, #1
2400bb0a:	e017      	b.n	2400bb3c <HAL_I2C_Slave_Seq_Receive_DMA+0x258>
    {
      /* Clear ADDR flag after prepare the transfer parameters */
      /* This action will generate an acknowledge to the Master */
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
2400bb0c:	68fb      	ldr	r3, [r7, #12]
2400bb0e:	681b      	ldr	r3, [r3, #0]
2400bb10:	2208      	movs	r2, #8
2400bb12:	61da      	str	r2, [r3, #28]
    }

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2400bb14:	68fb      	ldr	r3, [r7, #12]
2400bb16:	2200      	movs	r2, #0
2400bb18:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Note : The I2C interrupts must be enabled after unlocking current process
    to avoid the risk of I2C interrupt handle execution before current
    process unlock */
    /* REnable ADDR interrupt */
    I2C_Enable_IRQ(hi2c, I2C_XFER_RX_IT | I2C_XFER_LISTEN_IT);
2400bb1c:	f248 0102 	movw	r1, #32770	; 0x8002
2400bb20:	68f8      	ldr	r0, [r7, #12]
2400bb22:	f002 f937 	bl	2400dd94 <I2C_Enable_IRQ>

    /* Enable DMA Request */
    hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;
2400bb26:	68fb      	ldr	r3, [r7, #12]
2400bb28:	681b      	ldr	r3, [r3, #0]
2400bb2a:	681a      	ldr	r2, [r3, #0]
2400bb2c:	68fb      	ldr	r3, [r7, #12]
2400bb2e:	681b      	ldr	r3, [r3, #0]
2400bb30:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
2400bb34:	601a      	str	r2, [r3, #0]

    return HAL_OK;
2400bb36:	2300      	movs	r3, #0
2400bb38:	e000      	b.n	2400bb3c <HAL_I2C_Slave_Seq_Receive_DMA+0x258>
  }
  else
  {
    return HAL_ERROR;
2400bb3a:	2301      	movs	r3, #1
  }
}
2400bb3c:	4618      	mov	r0, r3
2400bb3e:	3718      	adds	r7, #24
2400bb40:	46bd      	mov	sp, r7
2400bb42:	bd80      	pop	{r7, pc}
2400bb44:	2400d9e1 	.word	0x2400d9e1
2400bb48:	2400c4ed 	.word	0x2400c4ed
2400bb4c:	2400d60d 	.word	0x2400d60d
2400bb50:	2400d771 	.word	0x2400d771

2400bb54 <HAL_I2C_EnableListen_IT>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_EnableListen_IT(I2C_HandleTypeDef *hi2c)
{
2400bb54:	b580      	push	{r7, lr}
2400bb56:	b082      	sub	sp, #8
2400bb58:	af00      	add	r7, sp, #0
2400bb5a:	6078      	str	r0, [r7, #4]
  if (hi2c->State == HAL_I2C_STATE_READY)
2400bb5c:	687b      	ldr	r3, [r7, #4]
2400bb5e:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400bb62:	b2db      	uxtb	r3, r3
2400bb64:	2b20      	cmp	r3, #32
2400bb66:	d10d      	bne.n	2400bb84 <HAL_I2C_EnableListen_IT+0x30>
  {
    hi2c->State = HAL_I2C_STATE_LISTEN;
2400bb68:	687b      	ldr	r3, [r7, #4]
2400bb6a:	2228      	movs	r2, #40	; 0x28
2400bb6c:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->XferISR = I2C_Slave_ISR_IT;
2400bb70:	687b      	ldr	r3, [r7, #4]
2400bb72:	4a07      	ldr	r2, [pc, #28]	; (2400bb90 <HAL_I2C_EnableListen_IT+0x3c>)
2400bb74:	635a      	str	r2, [r3, #52]	; 0x34

    /* Enable the Address Match interrupt */
    I2C_Enable_IRQ(hi2c, I2C_XFER_LISTEN_IT);
2400bb76:	f44f 4100 	mov.w	r1, #32768	; 0x8000
2400bb7a:	6878      	ldr	r0, [r7, #4]
2400bb7c:	f002 f90a 	bl	2400dd94 <I2C_Enable_IRQ>

    return HAL_OK;
2400bb80:	2300      	movs	r3, #0
2400bb82:	e000      	b.n	2400bb86 <HAL_I2C_EnableListen_IT+0x32>
  }
  else
  {
    return HAL_BUSY;
2400bb84:	2302      	movs	r3, #2
  }
}
2400bb86:	4618      	mov	r0, r3
2400bb88:	3708      	adds	r7, #8
2400bb8a:	46bd      	mov	sp, r7
2400bb8c:	bd80      	pop	{r7, pc}
2400bb8e:	bf00      	nop
2400bb90:	2400c101 	.word	0x2400c101

2400bb94 <HAL_I2C_DisableListen_IT>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_DisableListen_IT(I2C_HandleTypeDef *hi2c)
{
2400bb94:	b580      	push	{r7, lr}
2400bb96:	b084      	sub	sp, #16
2400bb98:	af00      	add	r7, sp, #0
2400bb9a:	6078      	str	r0, [r7, #4]
  /* Declaration of tmp to prevent undefined behavior of volatile usage */
  uint32_t tmp;

  /* Disable Address listen mode only if a transfer is not ongoing */
  if (hi2c->State == HAL_I2C_STATE_LISTEN)
2400bb9c:	687b      	ldr	r3, [r7, #4]
2400bb9e:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400bba2:	b2db      	uxtb	r3, r3
2400bba4:	2b28      	cmp	r3, #40	; 0x28
2400bba6:	d121      	bne.n	2400bbec <HAL_I2C_DisableListen_IT+0x58>
  {
    tmp = (uint32_t)(hi2c->State) & I2C_STATE_MSK;
2400bba8:	687b      	ldr	r3, [r7, #4]
2400bbaa:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400bbae:	b2db      	uxtb	r3, r3
2400bbb0:	f003 0303 	and.w	r3, r3, #3
2400bbb4:	60fb      	str	r3, [r7, #12]
    hi2c->PreviousState = tmp | (uint32_t)(hi2c->Mode);
2400bbb6:	687b      	ldr	r3, [r7, #4]
2400bbb8:	f893 3042 	ldrb.w	r3, [r3, #66]	; 0x42
2400bbbc:	b2db      	uxtb	r3, r3
2400bbbe:	461a      	mov	r2, r3
2400bbc0:	68fb      	ldr	r3, [r7, #12]
2400bbc2:	431a      	orrs	r2, r3
2400bbc4:	687b      	ldr	r3, [r7, #4]
2400bbc6:	631a      	str	r2, [r3, #48]	; 0x30
    hi2c->State = HAL_I2C_STATE_READY;
2400bbc8:	687b      	ldr	r3, [r7, #4]
2400bbca:	2220      	movs	r2, #32
2400bbcc:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode = HAL_I2C_MODE_NONE;
2400bbd0:	687b      	ldr	r3, [r7, #4]
2400bbd2:	2200      	movs	r2, #0
2400bbd4:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->XferISR = NULL;
2400bbd8:	687b      	ldr	r3, [r7, #4]
2400bbda:	2200      	movs	r2, #0
2400bbdc:	635a      	str	r2, [r3, #52]	; 0x34

    /* Disable the Address Match interrupt */
    I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT);
2400bbde:	f44f 4100 	mov.w	r1, #32768	; 0x8000
2400bbe2:	6878      	ldr	r0, [r7, #4]
2400bbe4:	f002 f93a 	bl	2400de5c <I2C_Disable_IRQ>

    return HAL_OK;
2400bbe8:	2300      	movs	r3, #0
2400bbea:	e000      	b.n	2400bbee <HAL_I2C_DisableListen_IT+0x5a>
  }
  else
  {
    return HAL_BUSY;
2400bbec:	2302      	movs	r3, #2
  }
}
2400bbee:	4618      	mov	r0, r3
2400bbf0:	3710      	adds	r7, #16
2400bbf2:	46bd      	mov	sp, r7
2400bbf4:	bd80      	pop	{r7, pc}
	...

2400bbf8 <HAL_I2C_Master_Abort_IT>:
  * @param  DevAddress Target device address: The device 7 bits address value
  *         in datasheet must be shifted to the left before calling the interface
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Master_Abort_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress)
{
2400bbf8:	b580      	push	{r7, lr}
2400bbfa:	b084      	sub	sp, #16
2400bbfc:	af02      	add	r7, sp, #8
2400bbfe:	6078      	str	r0, [r7, #4]
2400bc00:	460b      	mov	r3, r1
2400bc02:	807b      	strh	r3, [r7, #2]
  if (hi2c->Mode == HAL_I2C_MODE_MASTER)
2400bc04:	687b      	ldr	r3, [r7, #4]
2400bc06:	f893 3042 	ldrb.w	r3, [r3, #66]	; 0x42
2400bc0a:	b2db      	uxtb	r3, r3
2400bc0c:	2b10      	cmp	r3, #16
2400bc0e:	d13c      	bne.n	2400bc8a <HAL_I2C_Master_Abort_IT+0x92>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
2400bc10:	687b      	ldr	r3, [r7, #4]
2400bc12:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400bc16:	2b01      	cmp	r3, #1
2400bc18:	d101      	bne.n	2400bc1e <HAL_I2C_Master_Abort_IT+0x26>
2400bc1a:	2302      	movs	r3, #2
2400bc1c:	e036      	b.n	2400bc8c <HAL_I2C_Master_Abort_IT+0x94>
2400bc1e:	687b      	ldr	r3, [r7, #4]
2400bc20:	2201      	movs	r2, #1
2400bc22:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Disable Interrupts and Store Previous state */
    if (hi2c->State == HAL_I2C_STATE_BUSY_TX)
2400bc26:	687b      	ldr	r3, [r7, #4]
2400bc28:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400bc2c:	b2db      	uxtb	r3, r3
2400bc2e:	2b21      	cmp	r3, #33	; 0x21
2400bc30:	d107      	bne.n	2400bc42 <HAL_I2C_Master_Abort_IT+0x4a>
    {
      I2C_Disable_IRQ(hi2c, I2C_XFER_TX_IT);
2400bc32:	2101      	movs	r1, #1
2400bc34:	6878      	ldr	r0, [r7, #4]
2400bc36:	f002 f911 	bl	2400de5c <I2C_Disable_IRQ>
      hi2c->PreviousState = I2C_STATE_MASTER_BUSY_TX;
2400bc3a:	687b      	ldr	r3, [r7, #4]
2400bc3c:	2211      	movs	r2, #17
2400bc3e:	631a      	str	r2, [r3, #48]	; 0x30
2400bc40:	e00c      	b.n	2400bc5c <HAL_I2C_Master_Abort_IT+0x64>
    }
    else if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
2400bc42:	687b      	ldr	r3, [r7, #4]
2400bc44:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400bc48:	b2db      	uxtb	r3, r3
2400bc4a:	2b22      	cmp	r3, #34	; 0x22
2400bc4c:	d106      	bne.n	2400bc5c <HAL_I2C_Master_Abort_IT+0x64>
    {
      I2C_Disable_IRQ(hi2c, I2C_XFER_RX_IT);
2400bc4e:	2102      	movs	r1, #2
2400bc50:	6878      	ldr	r0, [r7, #4]
2400bc52:	f002 f903 	bl	2400de5c <I2C_Disable_IRQ>
      hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
2400bc56:	687b      	ldr	r3, [r7, #4]
2400bc58:	2212      	movs	r2, #18
2400bc5a:	631a      	str	r2, [r3, #48]	; 0x30
    {
      /* Do nothing */
    }

    /* Set State at HAL_I2C_STATE_ABORT */
    hi2c->State = HAL_I2C_STATE_ABORT;
2400bc5c:	687b      	ldr	r3, [r7, #4]
2400bc5e:	2260      	movs	r2, #96	; 0x60
2400bc60:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Set NBYTES to 1 to generate a dummy read on I2C peripheral */
    /* Set AUTOEND mode, this will generate a NACK then STOP condition to abort the current transfer */
    I2C_TransferConfig(hi2c, DevAddress, 1, I2C_AUTOEND_MODE, I2C_GENERATE_STOP);
2400bc64:	8879      	ldrh	r1, [r7, #2]
2400bc66:	4b0b      	ldr	r3, [pc, #44]	; (2400bc94 <HAL_I2C_Master_Abort_IT+0x9c>)
2400bc68:	9300      	str	r3, [sp, #0]
2400bc6a:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
2400bc6e:	2201      	movs	r2, #1
2400bc70:	6878      	ldr	r0, [r7, #4]
2400bc72:	f002 f861 	bl	2400dd38 <I2C_TransferConfig>

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2400bc76:	687b      	ldr	r3, [r7, #4]
2400bc78:	2200      	movs	r2, #0
2400bc7a:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Note : The I2C interrupts must be enabled after unlocking current process
              to avoid the risk of I2C interrupt handle execution before current
              process unlock */
    I2C_Enable_IRQ(hi2c, I2C_XFER_CPLT_IT);
2400bc7e:	2120      	movs	r1, #32
2400bc80:	6878      	ldr	r0, [r7, #4]
2400bc82:	f002 f887 	bl	2400dd94 <I2C_Enable_IRQ>

    return HAL_OK;
2400bc86:	2300      	movs	r3, #0
2400bc88:	e000      	b.n	2400bc8c <HAL_I2C_Master_Abort_IT+0x94>
  }
  else
  {
    /* Wrong usage of abort function */
    /* This function should be used only in case of abort monitored by master device */
    return HAL_ERROR;
2400bc8a:	2301      	movs	r3, #1
  }
}
2400bc8c:	4618      	mov	r0, r3
2400bc8e:	3708      	adds	r7, #8
2400bc90:	46bd      	mov	sp, r7
2400bc92:	bd80      	pop	{r7, pc}
2400bc94:	80004000 	.word	0x80004000

2400bc98 <HAL_I2C_EV_IRQHandler>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
void HAL_I2C_EV_IRQHandler(I2C_HandleTypeDef *hi2c)
{
2400bc98:	b580      	push	{r7, lr}
2400bc9a:	b084      	sub	sp, #16
2400bc9c:	af00      	add	r7, sp, #0
2400bc9e:	6078      	str	r0, [r7, #4]
  /* Get current IT Flags and IT sources value */
  uint32_t itflags   = READ_REG(hi2c->Instance->ISR);
2400bca0:	687b      	ldr	r3, [r7, #4]
2400bca2:	681b      	ldr	r3, [r3, #0]
2400bca4:	699b      	ldr	r3, [r3, #24]
2400bca6:	60fb      	str	r3, [r7, #12]
  uint32_t itsources = READ_REG(hi2c->Instance->CR1);
2400bca8:	687b      	ldr	r3, [r7, #4]
2400bcaa:	681b      	ldr	r3, [r3, #0]
2400bcac:	681b      	ldr	r3, [r3, #0]
2400bcae:	60bb      	str	r3, [r7, #8]

  /* I2C events treatment -------------------------------------*/
  if (hi2c->XferISR != NULL)
2400bcb0:	687b      	ldr	r3, [r7, #4]
2400bcb2:	6b5b      	ldr	r3, [r3, #52]	; 0x34
2400bcb4:	2b00      	cmp	r3, #0
2400bcb6:	d005      	beq.n	2400bcc4 <HAL_I2C_EV_IRQHandler+0x2c>
  {
    hi2c->XferISR(hi2c, itflags, itsources);
2400bcb8:	687b      	ldr	r3, [r7, #4]
2400bcba:	6b5b      	ldr	r3, [r3, #52]	; 0x34
2400bcbc:	68ba      	ldr	r2, [r7, #8]
2400bcbe:	68f9      	ldr	r1, [r7, #12]
2400bcc0:	6878      	ldr	r0, [r7, #4]
2400bcc2:	4798      	blx	r3
  }
}
2400bcc4:	bf00      	nop
2400bcc6:	3710      	adds	r7, #16
2400bcc8:	46bd      	mov	sp, r7
2400bcca:	bd80      	pop	{r7, pc}

2400bccc <HAL_I2C_ER_IRQHandler>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
void HAL_I2C_ER_IRQHandler(I2C_HandleTypeDef *hi2c)
{
2400bccc:	b580      	push	{r7, lr}
2400bcce:	b086      	sub	sp, #24
2400bcd0:	af00      	add	r7, sp, #0
2400bcd2:	6078      	str	r0, [r7, #4]
  uint32_t itflags   = READ_REG(hi2c->Instance->ISR);
2400bcd4:	687b      	ldr	r3, [r7, #4]
2400bcd6:	681b      	ldr	r3, [r3, #0]
2400bcd8:	699b      	ldr	r3, [r3, #24]
2400bcda:	617b      	str	r3, [r7, #20]
  uint32_t itsources = READ_REG(hi2c->Instance->CR1);
2400bcdc:	687b      	ldr	r3, [r7, #4]
2400bcde:	681b      	ldr	r3, [r3, #0]
2400bce0:	681b      	ldr	r3, [r3, #0]
2400bce2:	613b      	str	r3, [r7, #16]
  uint32_t tmperror;

  /* I2C Bus error interrupt occurred ------------------------------------*/
  if ((I2C_CHECK_FLAG(itflags, I2C_FLAG_BERR) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERRI) != RESET))
2400bce4:	697b      	ldr	r3, [r7, #20]
2400bce6:	0a1b      	lsrs	r3, r3, #8
2400bce8:	f003 0301 	and.w	r3, r3, #1
2400bcec:	2b00      	cmp	r3, #0
2400bcee:	d010      	beq.n	2400bd12 <HAL_I2C_ER_IRQHandler+0x46>
2400bcf0:	693b      	ldr	r3, [r7, #16]
2400bcf2:	09db      	lsrs	r3, r3, #7
2400bcf4:	f003 0301 	and.w	r3, r3, #1
2400bcf8:	2b00      	cmp	r3, #0
2400bcfa:	d00a      	beq.n	2400bd12 <HAL_I2C_ER_IRQHandler+0x46>
  {
    hi2c->ErrorCode |= HAL_I2C_ERROR_BERR;
2400bcfc:	687b      	ldr	r3, [r7, #4]
2400bcfe:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400bd00:	f043 0201 	orr.w	r2, r3, #1
2400bd04:	687b      	ldr	r3, [r7, #4]
2400bd06:	645a      	str	r2, [r3, #68]	; 0x44

    /* Clear BERR flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_BERR);
2400bd08:	687b      	ldr	r3, [r7, #4]
2400bd0a:	681b      	ldr	r3, [r3, #0]
2400bd0c:	f44f 7280 	mov.w	r2, #256	; 0x100
2400bd10:	61da      	str	r2, [r3, #28]
  }

  /* I2C Over-Run/Under-Run interrupt occurred ----------------------------------------*/
  if ((I2C_CHECK_FLAG(itflags, I2C_FLAG_OVR) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERRI) != RESET))
2400bd12:	697b      	ldr	r3, [r7, #20]
2400bd14:	0a9b      	lsrs	r3, r3, #10
2400bd16:	f003 0301 	and.w	r3, r3, #1
2400bd1a:	2b00      	cmp	r3, #0
2400bd1c:	d010      	beq.n	2400bd40 <HAL_I2C_ER_IRQHandler+0x74>
2400bd1e:	693b      	ldr	r3, [r7, #16]
2400bd20:	09db      	lsrs	r3, r3, #7
2400bd22:	f003 0301 	and.w	r3, r3, #1
2400bd26:	2b00      	cmp	r3, #0
2400bd28:	d00a      	beq.n	2400bd40 <HAL_I2C_ER_IRQHandler+0x74>
  {
    hi2c->ErrorCode |= HAL_I2C_ERROR_OVR;
2400bd2a:	687b      	ldr	r3, [r7, #4]
2400bd2c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400bd2e:	f043 0208 	orr.w	r2, r3, #8
2400bd32:	687b      	ldr	r3, [r7, #4]
2400bd34:	645a      	str	r2, [r3, #68]	; 0x44

    /* Clear OVR flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_OVR);
2400bd36:	687b      	ldr	r3, [r7, #4]
2400bd38:	681b      	ldr	r3, [r3, #0]
2400bd3a:	f44f 6280 	mov.w	r2, #1024	; 0x400
2400bd3e:	61da      	str	r2, [r3, #28]
  }

  /* I2C Arbitration Loss error interrupt occurred -------------------------------------*/
  if ((I2C_CHECK_FLAG(itflags, I2C_FLAG_ARLO) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERRI) != RESET))
2400bd40:	697b      	ldr	r3, [r7, #20]
2400bd42:	0a5b      	lsrs	r3, r3, #9
2400bd44:	f003 0301 	and.w	r3, r3, #1
2400bd48:	2b00      	cmp	r3, #0
2400bd4a:	d010      	beq.n	2400bd6e <HAL_I2C_ER_IRQHandler+0xa2>
2400bd4c:	693b      	ldr	r3, [r7, #16]
2400bd4e:	09db      	lsrs	r3, r3, #7
2400bd50:	f003 0301 	and.w	r3, r3, #1
2400bd54:	2b00      	cmp	r3, #0
2400bd56:	d00a      	beq.n	2400bd6e <HAL_I2C_ER_IRQHandler+0xa2>
  {
    hi2c->ErrorCode |= HAL_I2C_ERROR_ARLO;
2400bd58:	687b      	ldr	r3, [r7, #4]
2400bd5a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400bd5c:	f043 0202 	orr.w	r2, r3, #2
2400bd60:	687b      	ldr	r3, [r7, #4]
2400bd62:	645a      	str	r2, [r3, #68]	; 0x44

    /* Clear ARLO flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ARLO);
2400bd64:	687b      	ldr	r3, [r7, #4]
2400bd66:	681b      	ldr	r3, [r3, #0]
2400bd68:	f44f 7200 	mov.w	r2, #512	; 0x200
2400bd6c:	61da      	str	r2, [r3, #28]
  }

  /* Store current volatile hi2c->ErrorCode, misra rule */
  tmperror = hi2c->ErrorCode;
2400bd6e:	687b      	ldr	r3, [r7, #4]
2400bd70:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400bd72:	60fb      	str	r3, [r7, #12]

  /* Call the Error Callback in case of Error detected */
  if ((tmperror & (HAL_I2C_ERROR_BERR | HAL_I2C_ERROR_OVR | HAL_I2C_ERROR_ARLO)) !=  HAL_I2C_ERROR_NONE)
2400bd74:	68fb      	ldr	r3, [r7, #12]
2400bd76:	f003 030b 	and.w	r3, r3, #11
2400bd7a:	2b00      	cmp	r3, #0
2400bd7c:	d003      	beq.n	2400bd86 <HAL_I2C_ER_IRQHandler+0xba>
  {
    I2C_ITError(hi2c, tmperror);
2400bd7e:	68f9      	ldr	r1, [r7, #12]
2400bd80:	6878      	ldr	r0, [r7, #4]
2400bd82:	f001 fa71 	bl	2400d268 <I2C_ITError>
  }
}
2400bd86:	bf00      	nop
2400bd88:	3718      	adds	r7, #24
2400bd8a:	46bd      	mov	sp, r7
2400bd8c:	bd80      	pop	{r7, pc}

2400bd8e <HAL_I2C_MasterTxCpltCallback>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_MasterTxCpltCallback(I2C_HandleTypeDef *hi2c)
{
2400bd8e:	b480      	push	{r7}
2400bd90:	b083      	sub	sp, #12
2400bd92:	af00      	add	r7, sp, #0
2400bd94:	6078      	str	r0, [r7, #4]
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_MasterTxCpltCallback could be implemented in the user file
   */
}
2400bd96:	bf00      	nop
2400bd98:	370c      	adds	r7, #12
2400bd9a:	46bd      	mov	sp, r7
2400bd9c:	f85d 7b04 	ldr.w	r7, [sp], #4
2400bda0:	4770      	bx	lr

2400bda2 <HAL_I2C_MasterRxCpltCallback>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_MasterRxCpltCallback(I2C_HandleTypeDef *hi2c)
{
2400bda2:	b480      	push	{r7}
2400bda4:	b083      	sub	sp, #12
2400bda6:	af00      	add	r7, sp, #0
2400bda8:	6078      	str	r0, [r7, #4]
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_MasterRxCpltCallback could be implemented in the user file
   */
}
2400bdaa:	bf00      	nop
2400bdac:	370c      	adds	r7, #12
2400bdae:	46bd      	mov	sp, r7
2400bdb0:	f85d 7b04 	ldr.w	r7, [sp], #4
2400bdb4:	4770      	bx	lr

2400bdb6 <HAL_I2C_SlaveTxCpltCallback>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_SlaveTxCpltCallback(I2C_HandleTypeDef *hi2c)
{
2400bdb6:	b480      	push	{r7}
2400bdb8:	b083      	sub	sp, #12
2400bdba:	af00      	add	r7, sp, #0
2400bdbc:	6078      	str	r0, [r7, #4]
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_SlaveTxCpltCallback could be implemented in the user file
   */
}
2400bdbe:	bf00      	nop
2400bdc0:	370c      	adds	r7, #12
2400bdc2:	46bd      	mov	sp, r7
2400bdc4:	f85d 7b04 	ldr.w	r7, [sp], #4
2400bdc8:	4770      	bx	lr

2400bdca <HAL_I2C_SlaveRxCpltCallback>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_SlaveRxCpltCallback(I2C_HandleTypeDef *hi2c)
{
2400bdca:	b480      	push	{r7}
2400bdcc:	b083      	sub	sp, #12
2400bdce:	af00      	add	r7, sp, #0
2400bdd0:	6078      	str	r0, [r7, #4]
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_SlaveRxCpltCallback could be implemented in the user file
   */
}
2400bdd2:	bf00      	nop
2400bdd4:	370c      	adds	r7, #12
2400bdd6:	46bd      	mov	sp, r7
2400bdd8:	f85d 7b04 	ldr.w	r7, [sp], #4
2400bddc:	4770      	bx	lr

2400bdde <HAL_I2C_AddrCallback>:
  * @param  TransferDirection Master request Transfer Direction (Write/Read), value of @ref I2C_XFERDIRECTION
  * @param  AddrMatchCode Address Match Code
  * @retval None
  */
__weak void HAL_I2C_AddrCallback(I2C_HandleTypeDef *hi2c, uint8_t TransferDirection, uint16_t AddrMatchCode)
{
2400bdde:	b480      	push	{r7}
2400bde0:	b083      	sub	sp, #12
2400bde2:	af00      	add	r7, sp, #0
2400bde4:	6078      	str	r0, [r7, #4]
2400bde6:	460b      	mov	r3, r1
2400bde8:	70fb      	strb	r3, [r7, #3]
2400bdea:	4613      	mov	r3, r2
2400bdec:	803b      	strh	r3, [r7, #0]
  UNUSED(AddrMatchCode);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_AddrCallback() could be implemented in the user file
   */
}
2400bdee:	bf00      	nop
2400bdf0:	370c      	adds	r7, #12
2400bdf2:	46bd      	mov	sp, r7
2400bdf4:	f85d 7b04 	ldr.w	r7, [sp], #4
2400bdf8:	4770      	bx	lr

2400bdfa <HAL_I2C_ListenCpltCallback>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_ListenCpltCallback(I2C_HandleTypeDef *hi2c)
{
2400bdfa:	b480      	push	{r7}
2400bdfc:	b083      	sub	sp, #12
2400bdfe:	af00      	add	r7, sp, #0
2400be00:	6078      	str	r0, [r7, #4]
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_ListenCpltCallback() could be implemented in the user file
   */
}
2400be02:	bf00      	nop
2400be04:	370c      	adds	r7, #12
2400be06:	46bd      	mov	sp, r7
2400be08:	f85d 7b04 	ldr.w	r7, [sp], #4
2400be0c:	4770      	bx	lr

2400be0e <HAL_I2C_MemTxCpltCallback>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_MemTxCpltCallback(I2C_HandleTypeDef *hi2c)
{
2400be0e:	b480      	push	{r7}
2400be10:	b083      	sub	sp, #12
2400be12:	af00      	add	r7, sp, #0
2400be14:	6078      	str	r0, [r7, #4]
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_MemTxCpltCallback could be implemented in the user file
   */
}
2400be16:	bf00      	nop
2400be18:	370c      	adds	r7, #12
2400be1a:	46bd      	mov	sp, r7
2400be1c:	f85d 7b04 	ldr.w	r7, [sp], #4
2400be20:	4770      	bx	lr

2400be22 <HAL_I2C_MemRxCpltCallback>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_MemRxCpltCallback(I2C_HandleTypeDef *hi2c)
{
2400be22:	b480      	push	{r7}
2400be24:	b083      	sub	sp, #12
2400be26:	af00      	add	r7, sp, #0
2400be28:	6078      	str	r0, [r7, #4]
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_MemRxCpltCallback could be implemented in the user file
   */
}
2400be2a:	bf00      	nop
2400be2c:	370c      	adds	r7, #12
2400be2e:	46bd      	mov	sp, r7
2400be30:	f85d 7b04 	ldr.w	r7, [sp], #4
2400be34:	4770      	bx	lr

2400be36 <HAL_I2C_ErrorCallback>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_ErrorCallback(I2C_HandleTypeDef *hi2c)
{
2400be36:	b480      	push	{r7}
2400be38:	b083      	sub	sp, #12
2400be3a:	af00      	add	r7, sp, #0
2400be3c:	6078      	str	r0, [r7, #4]
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_ErrorCallback could be implemented in the user file
   */
}
2400be3e:	bf00      	nop
2400be40:	370c      	adds	r7, #12
2400be42:	46bd      	mov	sp, r7
2400be44:	f85d 7b04 	ldr.w	r7, [sp], #4
2400be48:	4770      	bx	lr

2400be4a <HAL_I2C_AbortCpltCallback>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_AbortCpltCallback(I2C_HandleTypeDef *hi2c)
{
2400be4a:	b480      	push	{r7}
2400be4c:	b083      	sub	sp, #12
2400be4e:	af00      	add	r7, sp, #0
2400be50:	6078      	str	r0, [r7, #4]
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_AbortCpltCallback could be implemented in the user file
   */
}
2400be52:	bf00      	nop
2400be54:	370c      	adds	r7, #12
2400be56:	46bd      	mov	sp, r7
2400be58:	f85d 7b04 	ldr.w	r7, [sp], #4
2400be5c:	4770      	bx	lr

2400be5e <HAL_I2C_GetState>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval HAL state
  */
HAL_I2C_StateTypeDef HAL_I2C_GetState(I2C_HandleTypeDef *hi2c)
{
2400be5e:	b480      	push	{r7}
2400be60:	b083      	sub	sp, #12
2400be62:	af00      	add	r7, sp, #0
2400be64:	6078      	str	r0, [r7, #4]
  /* Return I2C handle state */
  return hi2c->State;
2400be66:	687b      	ldr	r3, [r7, #4]
2400be68:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400be6c:	b2db      	uxtb	r3, r3
}
2400be6e:	4618      	mov	r0, r3
2400be70:	370c      	adds	r7, #12
2400be72:	46bd      	mov	sp, r7
2400be74:	f85d 7b04 	ldr.w	r7, [sp], #4
2400be78:	4770      	bx	lr

2400be7a <HAL_I2C_GetMode>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *         the configuration information for I2C module
  * @retval HAL mode
  */
HAL_I2C_ModeTypeDef HAL_I2C_GetMode(I2C_HandleTypeDef *hi2c)
{
2400be7a:	b480      	push	{r7}
2400be7c:	b083      	sub	sp, #12
2400be7e:	af00      	add	r7, sp, #0
2400be80:	6078      	str	r0, [r7, #4]
  return hi2c->Mode;
2400be82:	687b      	ldr	r3, [r7, #4]
2400be84:	f893 3042 	ldrb.w	r3, [r3, #66]	; 0x42
2400be88:	b2db      	uxtb	r3, r3
}
2400be8a:	4618      	mov	r0, r3
2400be8c:	370c      	adds	r7, #12
2400be8e:	46bd      	mov	sp, r7
2400be90:	f85d 7b04 	ldr.w	r7, [sp], #4
2400be94:	4770      	bx	lr

2400be96 <HAL_I2C_GetError>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *              the configuration information for the specified I2C.
* @retval I2C Error Code
*/
uint32_t HAL_I2C_GetError(I2C_HandleTypeDef *hi2c)
{
2400be96:	b480      	push	{r7}
2400be98:	b083      	sub	sp, #12
2400be9a:	af00      	add	r7, sp, #0
2400be9c:	6078      	str	r0, [r7, #4]
  return hi2c->ErrorCode;
2400be9e:	687b      	ldr	r3, [r7, #4]
2400bea0:	6c5b      	ldr	r3, [r3, #68]	; 0x44
}
2400bea2:	4618      	mov	r0, r3
2400bea4:	370c      	adds	r7, #12
2400bea6:	46bd      	mov	sp, r7
2400bea8:	f85d 7b04 	ldr.w	r7, [sp], #4
2400beac:	4770      	bx	lr

2400beae <I2C_Master_ISR_IT>:
  * @param  ITFlags Interrupt flags to handle.
  * @param  ITSources Interrupt sources enabled.
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_Master_ISR_IT(struct __I2C_HandleTypeDef *hi2c, uint32_t ITFlags, uint32_t ITSources)
{
2400beae:	b580      	push	{r7, lr}
2400beb0:	b088      	sub	sp, #32
2400beb2:	af02      	add	r7, sp, #8
2400beb4:	60f8      	str	r0, [r7, #12]
2400beb6:	60b9      	str	r1, [r7, #8]
2400beb8:	607a      	str	r2, [r7, #4]
  uint16_t devaddress;
  uint32_t tmpITFlags = ITFlags;
2400beba:	68bb      	ldr	r3, [r7, #8]
2400bebc:	617b      	str	r3, [r7, #20]

  /* Process Locked */
  __HAL_LOCK(hi2c);
2400bebe:	68fb      	ldr	r3, [r7, #12]
2400bec0:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400bec4:	2b01      	cmp	r3, #1
2400bec6:	d101      	bne.n	2400becc <I2C_Master_ISR_IT+0x1e>
2400bec8:	2302      	movs	r3, #2
2400beca:	e115      	b.n	2400c0f8 <I2C_Master_ISR_IT+0x24a>
2400becc:	68fb      	ldr	r3, [r7, #12]
2400bece:	2201      	movs	r2, #1
2400bed0:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_AF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))
2400bed4:	697b      	ldr	r3, [r7, #20]
2400bed6:	091b      	lsrs	r3, r3, #4
2400bed8:	f003 0301 	and.w	r3, r3, #1
2400bedc:	2b00      	cmp	r3, #0
2400bede:	d013      	beq.n	2400bf08 <I2C_Master_ISR_IT+0x5a>
2400bee0:	687b      	ldr	r3, [r7, #4]
2400bee2:	091b      	lsrs	r3, r3, #4
2400bee4:	f003 0301 	and.w	r3, r3, #1
2400bee8:	2b00      	cmp	r3, #0
2400beea:	d00d      	beq.n	2400bf08 <I2C_Master_ISR_IT+0x5a>
  {
    /* Clear NACK Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
2400beec:	68fb      	ldr	r3, [r7, #12]
2400beee:	681b      	ldr	r3, [r3, #0]
2400bef0:	2210      	movs	r2, #16
2400bef2:	61da      	str	r2, [r3, #28]

    /* Set corresponding Error Code */
    /* No need to generate STOP, it is automatically done */
    /* Error callback will be send during stop flag treatment */
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
2400bef4:	68fb      	ldr	r3, [r7, #12]
2400bef6:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400bef8:	f043 0204 	orr.w	r2, r3, #4
2400befc:	68fb      	ldr	r3, [r7, #12]
2400befe:	645a      	str	r2, [r3, #68]	; 0x44

    /* Flush TX register */
    I2C_Flush_TXDR(hi2c);
2400bf00:	68f8      	ldr	r0, [r7, #12]
2400bf02:	f001 faa8 	bl	2400d456 <I2C_Flush_TXDR>
2400bf06:	e0e2      	b.n	2400c0ce <I2C_Master_ISR_IT+0x220>
  }
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_RXI) != RESET))
2400bf08:	697b      	ldr	r3, [r7, #20]
2400bf0a:	089b      	lsrs	r3, r3, #2
2400bf0c:	f003 0301 	and.w	r3, r3, #1
2400bf10:	2b00      	cmp	r3, #0
2400bf12:	d023      	beq.n	2400bf5c <I2C_Master_ISR_IT+0xae>
2400bf14:	687b      	ldr	r3, [r7, #4]
2400bf16:	089b      	lsrs	r3, r3, #2
2400bf18:	f003 0301 	and.w	r3, r3, #1
2400bf1c:	2b00      	cmp	r3, #0
2400bf1e:	d01d      	beq.n	2400bf5c <I2C_Master_ISR_IT+0xae>
  {
    /* Remove RXNE flag on temporary variable as read done */
    tmpITFlags &= ~I2C_FLAG_RXNE;
2400bf20:	697b      	ldr	r3, [r7, #20]
2400bf22:	f023 0304 	bic.w	r3, r3, #4
2400bf26:	617b      	str	r3, [r7, #20]

    /* Read data from RXDR */
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
2400bf28:	68fb      	ldr	r3, [r7, #12]
2400bf2a:	681b      	ldr	r3, [r3, #0]
2400bf2c:	6a5a      	ldr	r2, [r3, #36]	; 0x24
2400bf2e:	68fb      	ldr	r3, [r7, #12]
2400bf30:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400bf32:	b2d2      	uxtb	r2, r2
2400bf34:	701a      	strb	r2, [r3, #0]

    /* Increment Buffer pointer */
    hi2c->pBuffPtr++;
2400bf36:	68fb      	ldr	r3, [r7, #12]
2400bf38:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400bf3a:	1c5a      	adds	r2, r3, #1
2400bf3c:	68fb      	ldr	r3, [r7, #12]
2400bf3e:	625a      	str	r2, [r3, #36]	; 0x24

    hi2c->XferSize--;
2400bf40:	68fb      	ldr	r3, [r7, #12]
2400bf42:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400bf44:	3b01      	subs	r3, #1
2400bf46:	b29a      	uxth	r2, r3
2400bf48:	68fb      	ldr	r3, [r7, #12]
2400bf4a:	851a      	strh	r2, [r3, #40]	; 0x28
    hi2c->XferCount--;
2400bf4c:	68fb      	ldr	r3, [r7, #12]
2400bf4e:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400bf50:	b29b      	uxth	r3, r3
2400bf52:	3b01      	subs	r3, #1
2400bf54:	b29a      	uxth	r2, r3
2400bf56:	68fb      	ldr	r3, [r7, #12]
2400bf58:	855a      	strh	r2, [r3, #42]	; 0x2a
2400bf5a:	e0b8      	b.n	2400c0ce <I2C_Master_ISR_IT+0x220>
  }
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TXIS) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TXI) != RESET))
2400bf5c:	697b      	ldr	r3, [r7, #20]
2400bf5e:	085b      	lsrs	r3, r3, #1
2400bf60:	f003 0301 	and.w	r3, r3, #1
2400bf64:	2b00      	cmp	r3, #0
2400bf66:	d01e      	beq.n	2400bfa6 <I2C_Master_ISR_IT+0xf8>
2400bf68:	687b      	ldr	r3, [r7, #4]
2400bf6a:	085b      	lsrs	r3, r3, #1
2400bf6c:	f003 0301 	and.w	r3, r3, #1
2400bf70:	2b00      	cmp	r3, #0
2400bf72:	d018      	beq.n	2400bfa6 <I2C_Master_ISR_IT+0xf8>
  {
    /* Write data to TXDR */
    hi2c->Instance->TXDR = *hi2c->pBuffPtr;
2400bf74:	68fb      	ldr	r3, [r7, #12]
2400bf76:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400bf78:	781a      	ldrb	r2, [r3, #0]
2400bf7a:	68fb      	ldr	r3, [r7, #12]
2400bf7c:	681b      	ldr	r3, [r3, #0]
2400bf7e:	629a      	str	r2, [r3, #40]	; 0x28

    /* Increment Buffer pointer */
    hi2c->pBuffPtr++;
2400bf80:	68fb      	ldr	r3, [r7, #12]
2400bf82:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400bf84:	1c5a      	adds	r2, r3, #1
2400bf86:	68fb      	ldr	r3, [r7, #12]
2400bf88:	625a      	str	r2, [r3, #36]	; 0x24

    hi2c->XferSize--;
2400bf8a:	68fb      	ldr	r3, [r7, #12]
2400bf8c:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400bf8e:	3b01      	subs	r3, #1
2400bf90:	b29a      	uxth	r2, r3
2400bf92:	68fb      	ldr	r3, [r7, #12]
2400bf94:	851a      	strh	r2, [r3, #40]	; 0x28
    hi2c->XferCount--;
2400bf96:	68fb      	ldr	r3, [r7, #12]
2400bf98:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400bf9a:	b29b      	uxth	r3, r3
2400bf9c:	3b01      	subs	r3, #1
2400bf9e:	b29a      	uxth	r2, r3
2400bfa0:	68fb      	ldr	r3, [r7, #12]
2400bfa2:	855a      	strh	r2, [r3, #42]	; 0x2a
2400bfa4:	e093      	b.n	2400c0ce <I2C_Master_ISR_IT+0x220>
  }
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TCR) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TCI) != RESET))
2400bfa6:	697b      	ldr	r3, [r7, #20]
2400bfa8:	09db      	lsrs	r3, r3, #7
2400bfaa:	f003 0301 	and.w	r3, r3, #1
2400bfae:	2b00      	cmp	r3, #0
2400bfb0:	d05e      	beq.n	2400c070 <I2C_Master_ISR_IT+0x1c2>
2400bfb2:	687b      	ldr	r3, [r7, #4]
2400bfb4:	099b      	lsrs	r3, r3, #6
2400bfb6:	f003 0301 	and.w	r3, r3, #1
2400bfba:	2b00      	cmp	r3, #0
2400bfbc:	d058      	beq.n	2400c070 <I2C_Master_ISR_IT+0x1c2>
  {
    if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
2400bfbe:	68fb      	ldr	r3, [r7, #12]
2400bfc0:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400bfc2:	b29b      	uxth	r3, r3
2400bfc4:	2b00      	cmp	r3, #0
2400bfc6:	d041      	beq.n	2400c04c <I2C_Master_ISR_IT+0x19e>
2400bfc8:	68fb      	ldr	r3, [r7, #12]
2400bfca:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400bfcc:	2b00      	cmp	r3, #0
2400bfce:	d13d      	bne.n	2400c04c <I2C_Master_ISR_IT+0x19e>
    {
      devaddress = (uint16_t)(hi2c->Instance->CR2 & I2C_CR2_SADD);
2400bfd0:	68fb      	ldr	r3, [r7, #12]
2400bfd2:	681b      	ldr	r3, [r3, #0]
2400bfd4:	685b      	ldr	r3, [r3, #4]
2400bfd6:	b29b      	uxth	r3, r3
2400bfd8:	f3c3 0309 	ubfx	r3, r3, #0, #10
2400bfdc:	827b      	strh	r3, [r7, #18]

      if (hi2c->XferCount > MAX_NBYTE_SIZE)
2400bfde:	68fb      	ldr	r3, [r7, #12]
2400bfe0:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400bfe2:	b29b      	uxth	r3, r3
2400bfe4:	2bff      	cmp	r3, #255	; 0xff
2400bfe6:	d90e      	bls.n	2400c006 <I2C_Master_ISR_IT+0x158>
      {
        hi2c->XferSize = MAX_NBYTE_SIZE;
2400bfe8:	68fb      	ldr	r3, [r7, #12]
2400bfea:	22ff      	movs	r2, #255	; 0xff
2400bfec:	851a      	strh	r2, [r3, #40]	; 0x28
        I2C_TransferConfig(hi2c, devaddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
2400bfee:	68fb      	ldr	r3, [r7, #12]
2400bff0:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400bff2:	b2da      	uxtb	r2, r3
2400bff4:	8a79      	ldrh	r1, [r7, #18]
2400bff6:	2300      	movs	r3, #0
2400bff8:	9300      	str	r3, [sp, #0]
2400bffa:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2400bffe:	68f8      	ldr	r0, [r7, #12]
2400c000:	f001 fe9a 	bl	2400dd38 <I2C_TransferConfig>
      if (hi2c->XferCount > MAX_NBYTE_SIZE)
2400c004:	e033      	b.n	2400c06e <I2C_Master_ISR_IT+0x1c0>
      }
      else
      {
        hi2c->XferSize = hi2c->XferCount;
2400c006:	68fb      	ldr	r3, [r7, #12]
2400c008:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400c00a:	b29a      	uxth	r2, r3
2400c00c:	68fb      	ldr	r3, [r7, #12]
2400c00e:	851a      	strh	r2, [r3, #40]	; 0x28
        if (hi2c->XferOptions != I2C_NO_OPTION_FRAME)
2400c010:	68fb      	ldr	r3, [r7, #12]
2400c012:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2400c014:	f513 3f80 	cmn.w	r3, #65536	; 0x10000
2400c018:	d00c      	beq.n	2400c034 <I2C_Master_ISR_IT+0x186>
        {
          I2C_TransferConfig(hi2c, devaddress, (uint8_t)hi2c->XferSize, hi2c->XferOptions, I2C_NO_STARTSTOP);
2400c01a:	68fb      	ldr	r3, [r7, #12]
2400c01c:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400c01e:	b2da      	uxtb	r2, r3
2400c020:	68fb      	ldr	r3, [r7, #12]
2400c022:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
2400c024:	8a79      	ldrh	r1, [r7, #18]
2400c026:	2300      	movs	r3, #0
2400c028:	9300      	str	r3, [sp, #0]
2400c02a:	4603      	mov	r3, r0
2400c02c:	68f8      	ldr	r0, [r7, #12]
2400c02e:	f001 fe83 	bl	2400dd38 <I2C_TransferConfig>
      if (hi2c->XferCount > MAX_NBYTE_SIZE)
2400c032:	e01c      	b.n	2400c06e <I2C_Master_ISR_IT+0x1c0>
        }
        else
        {
          I2C_TransferConfig(hi2c, devaddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
2400c034:	68fb      	ldr	r3, [r7, #12]
2400c036:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400c038:	b2da      	uxtb	r2, r3
2400c03a:	8a79      	ldrh	r1, [r7, #18]
2400c03c:	2300      	movs	r3, #0
2400c03e:	9300      	str	r3, [sp, #0]
2400c040:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
2400c044:	68f8      	ldr	r0, [r7, #12]
2400c046:	f001 fe77 	bl	2400dd38 <I2C_TransferConfig>
      if (hi2c->XferCount > MAX_NBYTE_SIZE)
2400c04a:	e010      	b.n	2400c06e <I2C_Master_ISR_IT+0x1c0>
      }
    }
    else
    {
      /* Call TxCpltCallback() if no stop mode is set */
      if (I2C_GET_STOP_MODE(hi2c) != I2C_AUTOEND_MODE)
2400c04c:	68fb      	ldr	r3, [r7, #12]
2400c04e:	681b      	ldr	r3, [r3, #0]
2400c050:	685b      	ldr	r3, [r3, #4]
2400c052:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
2400c056:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
2400c05a:	d003      	beq.n	2400c064 <I2C_Master_ISR_IT+0x1b6>
      {
        /* Call I2C Master Sequential complete process */
        I2C_ITMasterSeqCplt(hi2c);
2400c05c:	68f8      	ldr	r0, [r7, #12]
2400c05e:	f000 fd51 	bl	2400cb04 <I2C_ITMasterSeqCplt>
    if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
2400c062:	e034      	b.n	2400c0ce <I2C_Master_ISR_IT+0x220>
      }
      else
      {
        /* Wrong size Status regarding TCR flag event */
        /* Call the corresponding callback to inform upper layer of End of Transfer */
        I2C_ITError(hi2c, HAL_I2C_ERROR_SIZE);
2400c064:	2140      	movs	r1, #64	; 0x40
2400c066:	68f8      	ldr	r0, [r7, #12]
2400c068:	f001 f8fe 	bl	2400d268 <I2C_ITError>
    if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
2400c06c:	e02f      	b.n	2400c0ce <I2C_Master_ISR_IT+0x220>
2400c06e:	e02e      	b.n	2400c0ce <I2C_Master_ISR_IT+0x220>
      }
    }
  }
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TC) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TCI) != RESET))
2400c070:	697b      	ldr	r3, [r7, #20]
2400c072:	099b      	lsrs	r3, r3, #6
2400c074:	f003 0301 	and.w	r3, r3, #1
2400c078:	2b00      	cmp	r3, #0
2400c07a:	d028      	beq.n	2400c0ce <I2C_Master_ISR_IT+0x220>
2400c07c:	687b      	ldr	r3, [r7, #4]
2400c07e:	099b      	lsrs	r3, r3, #6
2400c080:	f003 0301 	and.w	r3, r3, #1
2400c084:	2b00      	cmp	r3, #0
2400c086:	d022      	beq.n	2400c0ce <I2C_Master_ISR_IT+0x220>
  {
    if (hi2c->XferCount == 0U)
2400c088:	68fb      	ldr	r3, [r7, #12]
2400c08a:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400c08c:	b29b      	uxth	r3, r3
2400c08e:	2b00      	cmp	r3, #0
2400c090:	d119      	bne.n	2400c0c6 <I2C_Master_ISR_IT+0x218>
    {
      if (I2C_GET_STOP_MODE(hi2c) != I2C_AUTOEND_MODE)
2400c092:	68fb      	ldr	r3, [r7, #12]
2400c094:	681b      	ldr	r3, [r3, #0]
2400c096:	685b      	ldr	r3, [r3, #4]
2400c098:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
2400c09c:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
2400c0a0:	d015      	beq.n	2400c0ce <I2C_Master_ISR_IT+0x220>
      {
        /* Generate a stop condition in case of no transfer option */
        if (hi2c->XferOptions == I2C_NO_OPTION_FRAME)
2400c0a2:	68fb      	ldr	r3, [r7, #12]
2400c0a4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2400c0a6:	f513 3f80 	cmn.w	r3, #65536	; 0x10000
2400c0aa:	d108      	bne.n	2400c0be <I2C_Master_ISR_IT+0x210>
        {
          /* Generate Stop */
          hi2c->Instance->CR2 |= I2C_CR2_STOP;
2400c0ac:	68fb      	ldr	r3, [r7, #12]
2400c0ae:	681b      	ldr	r3, [r3, #0]
2400c0b0:	685a      	ldr	r2, [r3, #4]
2400c0b2:	68fb      	ldr	r3, [r7, #12]
2400c0b4:	681b      	ldr	r3, [r3, #0]
2400c0b6:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
2400c0ba:	605a      	str	r2, [r3, #4]
2400c0bc:	e007      	b.n	2400c0ce <I2C_Master_ISR_IT+0x220>
        }
        else
        {
          /* Call I2C Master Sequential complete process */
          I2C_ITMasterSeqCplt(hi2c);
2400c0be:	68f8      	ldr	r0, [r7, #12]
2400c0c0:	f000 fd20 	bl	2400cb04 <I2C_ITMasterSeqCplt>
2400c0c4:	e003      	b.n	2400c0ce <I2C_Master_ISR_IT+0x220>
    }
    else
    {
      /* Wrong size Status regarding TC flag event */
      /* Call the corresponding callback to inform upper layer of End of Transfer */
      I2C_ITError(hi2c, HAL_I2C_ERROR_SIZE);
2400c0c6:	2140      	movs	r1, #64	; 0x40
2400c0c8:	68f8      	ldr	r0, [r7, #12]
2400c0ca:	f001 f8cd 	bl	2400d268 <I2C_ITError>
  else
  {
    /* Nothing to do */
  }

  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_STOPF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_STOPI) != RESET))
2400c0ce:	697b      	ldr	r3, [r7, #20]
2400c0d0:	095b      	lsrs	r3, r3, #5
2400c0d2:	f003 0301 	and.w	r3, r3, #1
2400c0d6:	2b00      	cmp	r3, #0
2400c0d8:	d009      	beq.n	2400c0ee <I2C_Master_ISR_IT+0x240>
2400c0da:	687b      	ldr	r3, [r7, #4]
2400c0dc:	095b      	lsrs	r3, r3, #5
2400c0de:	f003 0301 	and.w	r3, r3, #1
2400c0e2:	2b00      	cmp	r3, #0
2400c0e4:	d003      	beq.n	2400c0ee <I2C_Master_ISR_IT+0x240>
  {
    /* Call I2C Master complete process */
    I2C_ITMasterCplt(hi2c, tmpITFlags);
2400c0e6:	6979      	ldr	r1, [r7, #20]
2400c0e8:	68f8      	ldr	r0, [r7, #12]
2400c0ea:	f000 fda7 	bl	2400cc3c <I2C_ITMasterCplt>
  }

  /* Process Unlocked */
  __HAL_UNLOCK(hi2c);
2400c0ee:	68fb      	ldr	r3, [r7, #12]
2400c0f0:	2200      	movs	r2, #0
2400c0f2:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  return HAL_OK;
2400c0f6:	2300      	movs	r3, #0
}
2400c0f8:	4618      	mov	r0, r3
2400c0fa:	3718      	adds	r7, #24
2400c0fc:	46bd      	mov	sp, r7
2400c0fe:	bd80      	pop	{r7, pc}

2400c100 <I2C_Slave_ISR_IT>:
  * @param  ITFlags Interrupt flags to handle.
  * @param  ITSources Interrupt sources enabled.
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_Slave_ISR_IT(struct __I2C_HandleTypeDef *hi2c, uint32_t ITFlags, uint32_t ITSources)
{
2400c100:	b580      	push	{r7, lr}
2400c102:	b086      	sub	sp, #24
2400c104:	af00      	add	r7, sp, #0
2400c106:	60f8      	str	r0, [r7, #12]
2400c108:	60b9      	str	r1, [r7, #8]
2400c10a:	607a      	str	r2, [r7, #4]
  uint32_t tmpoptions = hi2c->XferOptions;
2400c10c:	68fb      	ldr	r3, [r7, #12]
2400c10e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2400c110:	617b      	str	r3, [r7, #20]
  uint32_t tmpITFlags = ITFlags;
2400c112:	68bb      	ldr	r3, [r7, #8]
2400c114:	613b      	str	r3, [r7, #16]

  /* Process locked */
  __HAL_LOCK(hi2c);
2400c116:	68fb      	ldr	r3, [r7, #12]
2400c118:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400c11c:	2b01      	cmp	r3, #1
2400c11e:	d101      	bne.n	2400c124 <I2C_Slave_ISR_IT+0x24>
2400c120:	2302      	movs	r3, #2
2400c122:	e0ec      	b.n	2400c2fe <I2C_Slave_ISR_IT+0x1fe>
2400c124:	68fb      	ldr	r3, [r7, #12]
2400c126:	2201      	movs	r2, #1
2400c128:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  /* Check if STOPF is set */
  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_STOPF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_STOPI) != RESET))
2400c12c:	693b      	ldr	r3, [r7, #16]
2400c12e:	095b      	lsrs	r3, r3, #5
2400c130:	f003 0301 	and.w	r3, r3, #1
2400c134:	2b00      	cmp	r3, #0
2400c136:	d009      	beq.n	2400c14c <I2C_Slave_ISR_IT+0x4c>
2400c138:	687b      	ldr	r3, [r7, #4]
2400c13a:	095b      	lsrs	r3, r3, #5
2400c13c:	f003 0301 	and.w	r3, r3, #1
2400c140:	2b00      	cmp	r3, #0
2400c142:	d003      	beq.n	2400c14c <I2C_Slave_ISR_IT+0x4c>
  {
    /* Call I2C Slave complete process */
    I2C_ITSlaveCplt(hi2c, tmpITFlags);
2400c144:	6939      	ldr	r1, [r7, #16]
2400c146:	68f8      	ldr	r0, [r7, #12]
2400c148:	f000 fe40 	bl	2400cdcc <I2C_ITSlaveCplt>
  }

  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_AF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))
2400c14c:	693b      	ldr	r3, [r7, #16]
2400c14e:	091b      	lsrs	r3, r3, #4
2400c150:	f003 0301 	and.w	r3, r3, #1
2400c154:	2b00      	cmp	r3, #0
2400c156:	d04d      	beq.n	2400c1f4 <I2C_Slave_ISR_IT+0xf4>
2400c158:	687b      	ldr	r3, [r7, #4]
2400c15a:	091b      	lsrs	r3, r3, #4
2400c15c:	f003 0301 	and.w	r3, r3, #1
2400c160:	2b00      	cmp	r3, #0
2400c162:	d047      	beq.n	2400c1f4 <I2C_Slave_ISR_IT+0xf4>
  {
    /* Check that I2C transfer finished */
    /* if yes, normal use case, a NACK is sent by the MASTER when Transfer is finished */
    /* Mean XferCount == 0*/
    /* So clear Flag NACKF only */
    if (hi2c->XferCount == 0U)
2400c164:	68fb      	ldr	r3, [r7, #12]
2400c166:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400c168:	b29b      	uxth	r3, r3
2400c16a:	2b00      	cmp	r3, #0
2400c16c:	d128      	bne.n	2400c1c0 <I2C_Slave_ISR_IT+0xc0>
    {
      if ((hi2c->State == HAL_I2C_STATE_LISTEN) && (tmpoptions == I2C_FIRST_AND_LAST_FRAME)) /* Same action must be done for (tmpoptions == I2C_LAST_FRAME) which removed for Warning[Pa134]: left and right operands are identical */
2400c16e:	68fb      	ldr	r3, [r7, #12]
2400c170:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400c174:	b2db      	uxtb	r3, r3
2400c176:	2b28      	cmp	r3, #40	; 0x28
2400c178:	d108      	bne.n	2400c18c <I2C_Slave_ISR_IT+0x8c>
2400c17a:	697b      	ldr	r3, [r7, #20]
2400c17c:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
2400c180:	d104      	bne.n	2400c18c <I2C_Slave_ISR_IT+0x8c>
      {
        /* Call I2C Listen complete process */
        I2C_ITListenCplt(hi2c, tmpITFlags);
2400c182:	6939      	ldr	r1, [r7, #16]
2400c184:	68f8      	ldr	r0, [r7, #12]
2400c186:	f001 f819 	bl	2400d1bc <I2C_ITListenCplt>
2400c18a:	e032      	b.n	2400c1f2 <I2C_Slave_ISR_IT+0xf2>
      }
      else if ((hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN) && (tmpoptions != I2C_NO_OPTION_FRAME))
2400c18c:	68fb      	ldr	r3, [r7, #12]
2400c18e:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400c192:	b2db      	uxtb	r3, r3
2400c194:	2b29      	cmp	r3, #41	; 0x29
2400c196:	d10e      	bne.n	2400c1b6 <I2C_Slave_ISR_IT+0xb6>
2400c198:	697b      	ldr	r3, [r7, #20]
2400c19a:	f513 3f80 	cmn.w	r3, #65536	; 0x10000
2400c19e:	d00a      	beq.n	2400c1b6 <I2C_Slave_ISR_IT+0xb6>
      {
        /* Clear NACK Flag */
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
2400c1a0:	68fb      	ldr	r3, [r7, #12]
2400c1a2:	681b      	ldr	r3, [r3, #0]
2400c1a4:	2210      	movs	r2, #16
2400c1a6:	61da      	str	r2, [r3, #28]

        /* Flush TX register */
        I2C_Flush_TXDR(hi2c);
2400c1a8:	68f8      	ldr	r0, [r7, #12]
2400c1aa:	f001 f954 	bl	2400d456 <I2C_Flush_TXDR>

        /* Last Byte is Transmitted */
        /* Call I2C Slave Sequential complete process */
        I2C_ITSlaveSeqCplt(hi2c);
2400c1ae:	68f8      	ldr	r0, [r7, #12]
2400c1b0:	f000 fce5 	bl	2400cb7e <I2C_ITSlaveSeqCplt>
2400c1b4:	e01d      	b.n	2400c1f2 <I2C_Slave_ISR_IT+0xf2>
      }
      else
      {
        /* Clear NACK Flag */
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
2400c1b6:	68fb      	ldr	r3, [r7, #12]
2400c1b8:	681b      	ldr	r3, [r3, #0]
2400c1ba:	2210      	movs	r2, #16
2400c1bc:	61da      	str	r2, [r3, #28]
    if (hi2c->XferCount == 0U)
2400c1be:	e096      	b.n	2400c2ee <I2C_Slave_ISR_IT+0x1ee>
    }
    else
    {
      /* if no, error use case, a Non-Acknowledge of last Data is generated by the MASTER*/
      /* Clear NACK Flag */
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
2400c1c0:	68fb      	ldr	r3, [r7, #12]
2400c1c2:	681b      	ldr	r3, [r3, #0]
2400c1c4:	2210      	movs	r2, #16
2400c1c6:	61da      	str	r2, [r3, #28]

      /* Set ErrorCode corresponding to a Non-Acknowledge */
      hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
2400c1c8:	68fb      	ldr	r3, [r7, #12]
2400c1ca:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400c1cc:	f043 0204 	orr.w	r2, r3, #4
2400c1d0:	68fb      	ldr	r3, [r7, #12]
2400c1d2:	645a      	str	r2, [r3, #68]	; 0x44

      if ((tmpoptions == I2C_FIRST_FRAME) || (tmpoptions == I2C_NEXT_FRAME))
2400c1d4:	697b      	ldr	r3, [r7, #20]
2400c1d6:	2b00      	cmp	r3, #0
2400c1d8:	d004      	beq.n	2400c1e4 <I2C_Slave_ISR_IT+0xe4>
2400c1da:	697b      	ldr	r3, [r7, #20]
2400c1dc:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
2400c1e0:	f040 8085 	bne.w	2400c2ee <I2C_Slave_ISR_IT+0x1ee>
      {
        /* Call the corresponding callback to inform upper layer of End of Transfer */
        I2C_ITError(hi2c, hi2c->ErrorCode);
2400c1e4:	68fb      	ldr	r3, [r7, #12]
2400c1e6:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400c1e8:	4619      	mov	r1, r3
2400c1ea:	68f8      	ldr	r0, [r7, #12]
2400c1ec:	f001 f83c 	bl	2400d268 <I2C_ITError>
    if (hi2c->XferCount == 0U)
2400c1f0:	e07d      	b.n	2400c2ee <I2C_Slave_ISR_IT+0x1ee>
2400c1f2:	e07c      	b.n	2400c2ee <I2C_Slave_ISR_IT+0x1ee>
      }
    }
  }
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_RXI) != RESET))
2400c1f4:	693b      	ldr	r3, [r7, #16]
2400c1f6:	089b      	lsrs	r3, r3, #2
2400c1f8:	f003 0301 	and.w	r3, r3, #1
2400c1fc:	2b00      	cmp	r3, #0
2400c1fe:	d030      	beq.n	2400c262 <I2C_Slave_ISR_IT+0x162>
2400c200:	687b      	ldr	r3, [r7, #4]
2400c202:	089b      	lsrs	r3, r3, #2
2400c204:	f003 0301 	and.w	r3, r3, #1
2400c208:	2b00      	cmp	r3, #0
2400c20a:	d02a      	beq.n	2400c262 <I2C_Slave_ISR_IT+0x162>
  {
    if (hi2c->XferCount > 0U)
2400c20c:	68fb      	ldr	r3, [r7, #12]
2400c20e:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400c210:	b29b      	uxth	r3, r3
2400c212:	2b00      	cmp	r3, #0
2400c214:	d018      	beq.n	2400c248 <I2C_Slave_ISR_IT+0x148>
    {
      /* Read data from RXDR */
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
2400c216:	68fb      	ldr	r3, [r7, #12]
2400c218:	681b      	ldr	r3, [r3, #0]
2400c21a:	6a5a      	ldr	r2, [r3, #36]	; 0x24
2400c21c:	68fb      	ldr	r3, [r7, #12]
2400c21e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400c220:	b2d2      	uxtb	r2, r2
2400c222:	701a      	strb	r2, [r3, #0]

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
2400c224:	68fb      	ldr	r3, [r7, #12]
2400c226:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400c228:	1c5a      	adds	r2, r3, #1
2400c22a:	68fb      	ldr	r3, [r7, #12]
2400c22c:	625a      	str	r2, [r3, #36]	; 0x24

      hi2c->XferSize--;
2400c22e:	68fb      	ldr	r3, [r7, #12]
2400c230:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400c232:	3b01      	subs	r3, #1
2400c234:	b29a      	uxth	r2, r3
2400c236:	68fb      	ldr	r3, [r7, #12]
2400c238:	851a      	strh	r2, [r3, #40]	; 0x28
      hi2c->XferCount--;
2400c23a:	68fb      	ldr	r3, [r7, #12]
2400c23c:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400c23e:	b29b      	uxth	r3, r3
2400c240:	3b01      	subs	r3, #1
2400c242:	b29a      	uxth	r2, r3
2400c244:	68fb      	ldr	r3, [r7, #12]
2400c246:	855a      	strh	r2, [r3, #42]	; 0x2a
    }

    if ((hi2c->XferCount == 0U) && \
2400c248:	68fb      	ldr	r3, [r7, #12]
2400c24a:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400c24c:	b29b      	uxth	r3, r3
2400c24e:	2b00      	cmp	r3, #0
2400c250:	d14f      	bne.n	2400c2f2 <I2C_Slave_ISR_IT+0x1f2>
2400c252:	697b      	ldr	r3, [r7, #20]
2400c254:	f513 3f80 	cmn.w	r3, #65536	; 0x10000
2400c258:	d04b      	beq.n	2400c2f2 <I2C_Slave_ISR_IT+0x1f2>
        (tmpoptions != I2C_NO_OPTION_FRAME))
    {
      /* Call I2C Slave Sequential complete process */
      I2C_ITSlaveSeqCplt(hi2c);
2400c25a:	68f8      	ldr	r0, [r7, #12]
2400c25c:	f000 fc8f 	bl	2400cb7e <I2C_ITSlaveSeqCplt>
    if ((hi2c->XferCount == 0U) && \
2400c260:	e047      	b.n	2400c2f2 <I2C_Slave_ISR_IT+0x1f2>
    }
  }
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_ADDR) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_ADDRI) != RESET))
2400c262:	693b      	ldr	r3, [r7, #16]
2400c264:	08db      	lsrs	r3, r3, #3
2400c266:	f003 0301 	and.w	r3, r3, #1
2400c26a:	2b00      	cmp	r3, #0
2400c26c:	d00a      	beq.n	2400c284 <I2C_Slave_ISR_IT+0x184>
2400c26e:	687b      	ldr	r3, [r7, #4]
2400c270:	08db      	lsrs	r3, r3, #3
2400c272:	f003 0301 	and.w	r3, r3, #1
2400c276:	2b00      	cmp	r3, #0
2400c278:	d004      	beq.n	2400c284 <I2C_Slave_ISR_IT+0x184>
  {
    I2C_ITAddrCplt(hi2c, tmpITFlags);
2400c27a:	6939      	ldr	r1, [r7, #16]
2400c27c:	68f8      	ldr	r0, [r7, #12]
2400c27e:	f000 fbbd 	bl	2400c9fc <I2C_ITAddrCplt>
2400c282:	e037      	b.n	2400c2f4 <I2C_Slave_ISR_IT+0x1f4>
  }
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TXIS) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TXI) != RESET))
2400c284:	693b      	ldr	r3, [r7, #16]
2400c286:	085b      	lsrs	r3, r3, #1
2400c288:	f003 0301 	and.w	r3, r3, #1
2400c28c:	2b00      	cmp	r3, #0
2400c28e:	d031      	beq.n	2400c2f4 <I2C_Slave_ISR_IT+0x1f4>
2400c290:	687b      	ldr	r3, [r7, #4]
2400c292:	085b      	lsrs	r3, r3, #1
2400c294:	f003 0301 	and.w	r3, r3, #1
2400c298:	2b00      	cmp	r3, #0
2400c29a:	d02b      	beq.n	2400c2f4 <I2C_Slave_ISR_IT+0x1f4>
  {
    /* Write data to TXDR only if XferCount not reach "0" */
    /* A TXIS flag can be set, during STOP treatment      */
    /* Check if all Datas have already been sent */
    /* If it is the case, this last write in TXDR is not sent, correspond to a dummy TXIS event */
    if (hi2c->XferCount > 0U)
2400c29c:	68fb      	ldr	r3, [r7, #12]
2400c29e:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400c2a0:	b29b      	uxth	r3, r3
2400c2a2:	2b00      	cmp	r3, #0
2400c2a4:	d018      	beq.n	2400c2d8 <I2C_Slave_ISR_IT+0x1d8>
    {
      /* Write data to TXDR */
      hi2c->Instance->TXDR = *hi2c->pBuffPtr;
2400c2a6:	68fb      	ldr	r3, [r7, #12]
2400c2a8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400c2aa:	781a      	ldrb	r2, [r3, #0]
2400c2ac:	68fb      	ldr	r3, [r7, #12]
2400c2ae:	681b      	ldr	r3, [r3, #0]
2400c2b0:	629a      	str	r2, [r3, #40]	; 0x28

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
2400c2b2:	68fb      	ldr	r3, [r7, #12]
2400c2b4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400c2b6:	1c5a      	adds	r2, r3, #1
2400c2b8:	68fb      	ldr	r3, [r7, #12]
2400c2ba:	625a      	str	r2, [r3, #36]	; 0x24

      hi2c->XferCount--;
2400c2bc:	68fb      	ldr	r3, [r7, #12]
2400c2be:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400c2c0:	b29b      	uxth	r3, r3
2400c2c2:	3b01      	subs	r3, #1
2400c2c4:	b29a      	uxth	r2, r3
2400c2c6:	68fb      	ldr	r3, [r7, #12]
2400c2c8:	855a      	strh	r2, [r3, #42]	; 0x2a
      hi2c->XferSize--;
2400c2ca:	68fb      	ldr	r3, [r7, #12]
2400c2cc:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400c2ce:	3b01      	subs	r3, #1
2400c2d0:	b29a      	uxth	r2, r3
2400c2d2:	68fb      	ldr	r3, [r7, #12]
2400c2d4:	851a      	strh	r2, [r3, #40]	; 0x28
2400c2d6:	e00d      	b.n	2400c2f4 <I2C_Slave_ISR_IT+0x1f4>
    }
    else
    {
      if ((tmpoptions == I2C_NEXT_FRAME) || (tmpoptions == I2C_FIRST_FRAME))
2400c2d8:	697b      	ldr	r3, [r7, #20]
2400c2da:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
2400c2de:	d002      	beq.n	2400c2e6 <I2C_Slave_ISR_IT+0x1e6>
2400c2e0:	697b      	ldr	r3, [r7, #20]
2400c2e2:	2b00      	cmp	r3, #0
2400c2e4:	d106      	bne.n	2400c2f4 <I2C_Slave_ISR_IT+0x1f4>
      {
        /* Last Byte is Transmitted */
        /* Call I2C Slave Sequential complete process */
        I2C_ITSlaveSeqCplt(hi2c);
2400c2e6:	68f8      	ldr	r0, [r7, #12]
2400c2e8:	f000 fc49 	bl	2400cb7e <I2C_ITSlaveSeqCplt>
2400c2ec:	e002      	b.n	2400c2f4 <I2C_Slave_ISR_IT+0x1f4>
    if (hi2c->XferCount == 0U)
2400c2ee:	bf00      	nop
2400c2f0:	e000      	b.n	2400c2f4 <I2C_Slave_ISR_IT+0x1f4>
    if ((hi2c->XferCount == 0U) && \
2400c2f2:	bf00      	nop
  {
    /* Nothing to do */
  }

  /* Process Unlocked */
  __HAL_UNLOCK(hi2c);
2400c2f4:	68fb      	ldr	r3, [r7, #12]
2400c2f6:	2200      	movs	r2, #0
2400c2f8:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  return HAL_OK;
2400c2fc:	2300      	movs	r3, #0
}
2400c2fe:	4618      	mov	r0, r3
2400c300:	3718      	adds	r7, #24
2400c302:	46bd      	mov	sp, r7
2400c304:	bd80      	pop	{r7, pc}

2400c306 <I2C_Master_ISR_DMA>:
  * @param  ITFlags Interrupt flags to handle.
  * @param  ITSources Interrupt sources enabled.
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_Master_ISR_DMA(struct __I2C_HandleTypeDef *hi2c, uint32_t ITFlags, uint32_t ITSources)
{
2400c306:	b580      	push	{r7, lr}
2400c308:	b088      	sub	sp, #32
2400c30a:	af02      	add	r7, sp, #8
2400c30c:	60f8      	str	r0, [r7, #12]
2400c30e:	60b9      	str	r1, [r7, #8]
2400c310:	607a      	str	r2, [r7, #4]
  uint16_t devaddress;
  uint32_t xfermode;

  /* Process Locked */
  __HAL_LOCK(hi2c);
2400c312:	68fb      	ldr	r3, [r7, #12]
2400c314:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400c318:	2b01      	cmp	r3, #1
2400c31a:	d101      	bne.n	2400c320 <I2C_Master_ISR_DMA+0x1a>
2400c31c:	2302      	movs	r3, #2
2400c31e:	e0e1      	b.n	2400c4e4 <I2C_Master_ISR_DMA+0x1de>
2400c320:	68fb      	ldr	r3, [r7, #12]
2400c322:	2201      	movs	r2, #1
2400c324:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_AF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))
2400c328:	68bb      	ldr	r3, [r7, #8]
2400c32a:	091b      	lsrs	r3, r3, #4
2400c32c:	f003 0301 	and.w	r3, r3, #1
2400c330:	2b00      	cmp	r3, #0
2400c332:	d017      	beq.n	2400c364 <I2C_Master_ISR_DMA+0x5e>
2400c334:	687b      	ldr	r3, [r7, #4]
2400c336:	091b      	lsrs	r3, r3, #4
2400c338:	f003 0301 	and.w	r3, r3, #1
2400c33c:	2b00      	cmp	r3, #0
2400c33e:	d011      	beq.n	2400c364 <I2C_Master_ISR_DMA+0x5e>
  {
    /* Clear NACK Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
2400c340:	68fb      	ldr	r3, [r7, #12]
2400c342:	681b      	ldr	r3, [r3, #0]
2400c344:	2210      	movs	r2, #16
2400c346:	61da      	str	r2, [r3, #28]

    /* Set corresponding Error Code */
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
2400c348:	68fb      	ldr	r3, [r7, #12]
2400c34a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400c34c:	f043 0204 	orr.w	r2, r3, #4
2400c350:	68fb      	ldr	r3, [r7, #12]
2400c352:	645a      	str	r2, [r3, #68]	; 0x44

    /* No need to generate STOP, it is automatically done */
    /* But enable STOP interrupt, to treat it */
    /* Error callback will be send during stop flag treatment */
    I2C_Enable_IRQ(hi2c, I2C_XFER_CPLT_IT);
2400c354:	2120      	movs	r1, #32
2400c356:	68f8      	ldr	r0, [r7, #12]
2400c358:	f001 fd1c 	bl	2400dd94 <I2C_Enable_IRQ>

    /* Flush TX register */
    I2C_Flush_TXDR(hi2c);
2400c35c:	68f8      	ldr	r0, [r7, #12]
2400c35e:	f001 f87a 	bl	2400d456 <I2C_Flush_TXDR>
2400c362:	e0ba      	b.n	2400c4da <I2C_Master_ISR_DMA+0x1d4>
  }
  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_TCR) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TCI) != RESET))
2400c364:	68bb      	ldr	r3, [r7, #8]
2400c366:	09db      	lsrs	r3, r3, #7
2400c368:	f003 0301 	and.w	r3, r3, #1
2400c36c:	2b00      	cmp	r3, #0
2400c36e:	d072      	beq.n	2400c456 <I2C_Master_ISR_DMA+0x150>
2400c370:	687b      	ldr	r3, [r7, #4]
2400c372:	099b      	lsrs	r3, r3, #6
2400c374:	f003 0301 	and.w	r3, r3, #1
2400c378:	2b00      	cmp	r3, #0
2400c37a:	d06c      	beq.n	2400c456 <I2C_Master_ISR_DMA+0x150>
  {
    /* Disable TC interrupt */
    __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_TCI);
2400c37c:	68fb      	ldr	r3, [r7, #12]
2400c37e:	681b      	ldr	r3, [r3, #0]
2400c380:	681a      	ldr	r2, [r3, #0]
2400c382:	68fb      	ldr	r3, [r7, #12]
2400c384:	681b      	ldr	r3, [r3, #0]
2400c386:	f022 0240 	bic.w	r2, r2, #64	; 0x40
2400c38a:	601a      	str	r2, [r3, #0]

    if (hi2c->XferCount != 0U)
2400c38c:	68fb      	ldr	r3, [r7, #12]
2400c38e:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400c390:	b29b      	uxth	r3, r3
2400c392:	2b00      	cmp	r3, #0
2400c394:	d04e      	beq.n	2400c434 <I2C_Master_ISR_DMA+0x12e>
    {
      /* Recover Slave address */
      devaddress = (uint16_t)(hi2c->Instance->CR2 & I2C_CR2_SADD);
2400c396:	68fb      	ldr	r3, [r7, #12]
2400c398:	681b      	ldr	r3, [r3, #0]
2400c39a:	685b      	ldr	r3, [r3, #4]
2400c39c:	b29b      	uxth	r3, r3
2400c39e:	f3c3 0309 	ubfx	r3, r3, #0, #10
2400c3a2:	827b      	strh	r3, [r7, #18]

      /* Prepare the new XferSize to transfer */
      if (hi2c->XferCount > MAX_NBYTE_SIZE)
2400c3a4:	68fb      	ldr	r3, [r7, #12]
2400c3a6:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400c3a8:	b29b      	uxth	r3, r3
2400c3aa:	2bff      	cmp	r3, #255	; 0xff
2400c3ac:	d906      	bls.n	2400c3bc <I2C_Master_ISR_DMA+0xb6>
      {
        hi2c->XferSize = MAX_NBYTE_SIZE;
2400c3ae:	68fb      	ldr	r3, [r7, #12]
2400c3b0:	22ff      	movs	r2, #255	; 0xff
2400c3b2:	851a      	strh	r2, [r3, #40]	; 0x28
        xfermode = I2C_RELOAD_MODE;
2400c3b4:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2400c3b8:	617b      	str	r3, [r7, #20]
2400c3ba:	e010      	b.n	2400c3de <I2C_Master_ISR_DMA+0xd8>
      }
      else
      {
        hi2c->XferSize = hi2c->XferCount;
2400c3bc:	68fb      	ldr	r3, [r7, #12]
2400c3be:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400c3c0:	b29a      	uxth	r2, r3
2400c3c2:	68fb      	ldr	r3, [r7, #12]
2400c3c4:	851a      	strh	r2, [r3, #40]	; 0x28
        if (hi2c->XferOptions != I2C_NO_OPTION_FRAME)
2400c3c6:	68fb      	ldr	r3, [r7, #12]
2400c3c8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2400c3ca:	f513 3f80 	cmn.w	r3, #65536	; 0x10000
2400c3ce:	d003      	beq.n	2400c3d8 <I2C_Master_ISR_DMA+0xd2>
        {
          xfermode = hi2c->XferOptions;
2400c3d0:	68fb      	ldr	r3, [r7, #12]
2400c3d2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2400c3d4:	617b      	str	r3, [r7, #20]
2400c3d6:	e002      	b.n	2400c3de <I2C_Master_ISR_DMA+0xd8>
        }
        else
        {
          xfermode = I2C_AUTOEND_MODE;
2400c3d8:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
2400c3dc:	617b      	str	r3, [r7, #20]
        }
      }

      /* Set the new XferSize in Nbytes register */
      I2C_TransferConfig(hi2c, devaddress, (uint8_t)hi2c->XferSize, xfermode, I2C_NO_STARTSTOP);
2400c3de:	68fb      	ldr	r3, [r7, #12]
2400c3e0:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400c3e2:	b2da      	uxtb	r2, r3
2400c3e4:	8a79      	ldrh	r1, [r7, #18]
2400c3e6:	2300      	movs	r3, #0
2400c3e8:	9300      	str	r3, [sp, #0]
2400c3ea:	697b      	ldr	r3, [r7, #20]
2400c3ec:	68f8      	ldr	r0, [r7, #12]
2400c3ee:	f001 fca3 	bl	2400dd38 <I2C_TransferConfig>

      /* Update XferCount value */
      hi2c->XferCount -= hi2c->XferSize;
2400c3f2:	68fb      	ldr	r3, [r7, #12]
2400c3f4:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400c3f6:	b29a      	uxth	r2, r3
2400c3f8:	68fb      	ldr	r3, [r7, #12]
2400c3fa:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400c3fc:	1ad3      	subs	r3, r2, r3
2400c3fe:	b29a      	uxth	r2, r3
2400c400:	68fb      	ldr	r3, [r7, #12]
2400c402:	855a      	strh	r2, [r3, #42]	; 0x2a

      /* Enable DMA Request */
      if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
2400c404:	68fb      	ldr	r3, [r7, #12]
2400c406:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400c40a:	b2db      	uxtb	r3, r3
2400c40c:	2b22      	cmp	r3, #34	; 0x22
2400c40e:	d108      	bne.n	2400c422 <I2C_Master_ISR_DMA+0x11c>
      {
        hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;
2400c410:	68fb      	ldr	r3, [r7, #12]
2400c412:	681b      	ldr	r3, [r3, #0]
2400c414:	681a      	ldr	r2, [r3, #0]
2400c416:	68fb      	ldr	r3, [r7, #12]
2400c418:	681b      	ldr	r3, [r3, #0]
2400c41a:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
2400c41e:	601a      	str	r2, [r3, #0]
    if (hi2c->XferCount != 0U)
2400c420:	e05b      	b.n	2400c4da <I2C_Master_ISR_DMA+0x1d4>
      }
      else
      {
        hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN;
2400c422:	68fb      	ldr	r3, [r7, #12]
2400c424:	681b      	ldr	r3, [r3, #0]
2400c426:	681a      	ldr	r2, [r3, #0]
2400c428:	68fb      	ldr	r3, [r7, #12]
2400c42a:	681b      	ldr	r3, [r3, #0]
2400c42c:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
2400c430:	601a      	str	r2, [r3, #0]
    if (hi2c->XferCount != 0U)
2400c432:	e052      	b.n	2400c4da <I2C_Master_ISR_DMA+0x1d4>
      }
    }
    else
    {
      /* Call TxCpltCallback() if no stop mode is set */
      if (I2C_GET_STOP_MODE(hi2c) != I2C_AUTOEND_MODE)
2400c434:	68fb      	ldr	r3, [r7, #12]
2400c436:	681b      	ldr	r3, [r3, #0]
2400c438:	685b      	ldr	r3, [r3, #4]
2400c43a:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
2400c43e:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
2400c442:	d003      	beq.n	2400c44c <I2C_Master_ISR_DMA+0x146>
      {
        /* Call I2C Master Sequential complete process */
        I2C_ITMasterSeqCplt(hi2c);
2400c444:	68f8      	ldr	r0, [r7, #12]
2400c446:	f000 fb5d 	bl	2400cb04 <I2C_ITMasterSeqCplt>
    if (hi2c->XferCount != 0U)
2400c44a:	e046      	b.n	2400c4da <I2C_Master_ISR_DMA+0x1d4>
      }
      else
      {
        /* Wrong size Status regarding TCR flag event */
        /* Call the corresponding callback to inform upper layer of End of Transfer */
        I2C_ITError(hi2c, HAL_I2C_ERROR_SIZE);
2400c44c:	2140      	movs	r1, #64	; 0x40
2400c44e:	68f8      	ldr	r0, [r7, #12]
2400c450:	f000 ff0a 	bl	2400d268 <I2C_ITError>
    if (hi2c->XferCount != 0U)
2400c454:	e041      	b.n	2400c4da <I2C_Master_ISR_DMA+0x1d4>
      }
    }
  }
  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_TC) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TCI) != RESET))
2400c456:	68bb      	ldr	r3, [r7, #8]
2400c458:	099b      	lsrs	r3, r3, #6
2400c45a:	f003 0301 	and.w	r3, r3, #1
2400c45e:	2b00      	cmp	r3, #0
2400c460:	d029      	beq.n	2400c4b6 <I2C_Master_ISR_DMA+0x1b0>
2400c462:	687b      	ldr	r3, [r7, #4]
2400c464:	099b      	lsrs	r3, r3, #6
2400c466:	f003 0301 	and.w	r3, r3, #1
2400c46a:	2b00      	cmp	r3, #0
2400c46c:	d023      	beq.n	2400c4b6 <I2C_Master_ISR_DMA+0x1b0>
  {
    if (hi2c->XferCount == 0U)
2400c46e:	68fb      	ldr	r3, [r7, #12]
2400c470:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400c472:	b29b      	uxth	r3, r3
2400c474:	2b00      	cmp	r3, #0
2400c476:	d119      	bne.n	2400c4ac <I2C_Master_ISR_DMA+0x1a6>
    {
      if (I2C_GET_STOP_MODE(hi2c) != I2C_AUTOEND_MODE)
2400c478:	68fb      	ldr	r3, [r7, #12]
2400c47a:	681b      	ldr	r3, [r3, #0]
2400c47c:	685b      	ldr	r3, [r3, #4]
2400c47e:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
2400c482:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
2400c486:	d027      	beq.n	2400c4d8 <I2C_Master_ISR_DMA+0x1d2>
      {
        /* Generate a stop condition in case of no transfer option */
        if (hi2c->XferOptions == I2C_NO_OPTION_FRAME)
2400c488:	68fb      	ldr	r3, [r7, #12]
2400c48a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2400c48c:	f513 3f80 	cmn.w	r3, #65536	; 0x10000
2400c490:	d108      	bne.n	2400c4a4 <I2C_Master_ISR_DMA+0x19e>
        {
          /* Generate Stop */
          hi2c->Instance->CR2 |= I2C_CR2_STOP;
2400c492:	68fb      	ldr	r3, [r7, #12]
2400c494:	681b      	ldr	r3, [r3, #0]
2400c496:	685a      	ldr	r2, [r3, #4]
2400c498:	68fb      	ldr	r3, [r7, #12]
2400c49a:	681b      	ldr	r3, [r3, #0]
2400c49c:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
2400c4a0:	605a      	str	r2, [r3, #4]
    if (hi2c->XferCount == 0U)
2400c4a2:	e019      	b.n	2400c4d8 <I2C_Master_ISR_DMA+0x1d2>
        }
        else
        {
          /* Call I2C Master Sequential complete process */
          I2C_ITMasterSeqCplt(hi2c);
2400c4a4:	68f8      	ldr	r0, [r7, #12]
2400c4a6:	f000 fb2d 	bl	2400cb04 <I2C_ITMasterSeqCplt>
    if (hi2c->XferCount == 0U)
2400c4aa:	e015      	b.n	2400c4d8 <I2C_Master_ISR_DMA+0x1d2>
    }
    else
    {
      /* Wrong size Status regarding TC flag event */
      /* Call the corresponding callback to inform upper layer of End of Transfer */
      I2C_ITError(hi2c, HAL_I2C_ERROR_SIZE);
2400c4ac:	2140      	movs	r1, #64	; 0x40
2400c4ae:	68f8      	ldr	r0, [r7, #12]
2400c4b0:	f000 feda 	bl	2400d268 <I2C_ITError>
    if (hi2c->XferCount == 0U)
2400c4b4:	e010      	b.n	2400c4d8 <I2C_Master_ISR_DMA+0x1d2>
    }
  }
  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_STOPF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_STOPI) != RESET))
2400c4b6:	68bb      	ldr	r3, [r7, #8]
2400c4b8:	095b      	lsrs	r3, r3, #5
2400c4ba:	f003 0301 	and.w	r3, r3, #1
2400c4be:	2b00      	cmp	r3, #0
2400c4c0:	d00b      	beq.n	2400c4da <I2C_Master_ISR_DMA+0x1d4>
2400c4c2:	687b      	ldr	r3, [r7, #4]
2400c4c4:	095b      	lsrs	r3, r3, #5
2400c4c6:	f003 0301 	and.w	r3, r3, #1
2400c4ca:	2b00      	cmp	r3, #0
2400c4cc:	d005      	beq.n	2400c4da <I2C_Master_ISR_DMA+0x1d4>
  {
    /* Call I2C Master complete process */
    I2C_ITMasterCplt(hi2c, ITFlags);
2400c4ce:	68b9      	ldr	r1, [r7, #8]
2400c4d0:	68f8      	ldr	r0, [r7, #12]
2400c4d2:	f000 fbb3 	bl	2400cc3c <I2C_ITMasterCplt>
2400c4d6:	e000      	b.n	2400c4da <I2C_Master_ISR_DMA+0x1d4>
    if (hi2c->XferCount == 0U)
2400c4d8:	bf00      	nop
  {
    /* Nothing to do */
  }

  /* Process Unlocked */
  __HAL_UNLOCK(hi2c);
2400c4da:	68fb      	ldr	r3, [r7, #12]
2400c4dc:	2200      	movs	r2, #0
2400c4de:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  return HAL_OK;
2400c4e2:	2300      	movs	r3, #0
}
2400c4e4:	4618      	mov	r0, r3
2400c4e6:	3718      	adds	r7, #24
2400c4e8:	46bd      	mov	sp, r7
2400c4ea:	bd80      	pop	{r7, pc}

2400c4ec <I2C_Slave_ISR_DMA>:
  * @param  ITFlags Interrupt flags to handle.
  * @param  ITSources Interrupt sources enabled.
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_Slave_ISR_DMA(struct __I2C_HandleTypeDef *hi2c, uint32_t ITFlags, uint32_t ITSources)
{
2400c4ec:	b580      	push	{r7, lr}
2400c4ee:	b088      	sub	sp, #32
2400c4f0:	af00      	add	r7, sp, #0
2400c4f2:	60f8      	str	r0, [r7, #12]
2400c4f4:	60b9      	str	r1, [r7, #8]
2400c4f6:	607a      	str	r2, [r7, #4]
  uint32_t tmpoptions = hi2c->XferOptions;
2400c4f8:	68fb      	ldr	r3, [r7, #12]
2400c4fa:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2400c4fc:	61bb      	str	r3, [r7, #24]
  uint32_t treatdmanack = 0U;
2400c4fe:	2300      	movs	r3, #0
2400c500:	61fb      	str	r3, [r7, #28]
  HAL_I2C_StateTypeDef tmpstate;

  /* Process locked */
  __HAL_LOCK(hi2c);
2400c502:	68fb      	ldr	r3, [r7, #12]
2400c504:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400c508:	2b01      	cmp	r3, #1
2400c50a:	d101      	bne.n	2400c510 <I2C_Slave_ISR_DMA+0x24>
2400c50c:	2302      	movs	r3, #2
2400c50e:	e1c8      	b.n	2400c8a2 <I2C_Slave_ISR_DMA+0x3b6>
2400c510:	68fb      	ldr	r3, [r7, #12]
2400c512:	2201      	movs	r2, #1
2400c514:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  /* Check if STOPF is set */
  if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_STOPF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_STOPI) != RESET))
2400c518:	68bb      	ldr	r3, [r7, #8]
2400c51a:	095b      	lsrs	r3, r3, #5
2400c51c:	f003 0301 	and.w	r3, r3, #1
2400c520:	2b00      	cmp	r3, #0
2400c522:	d009      	beq.n	2400c538 <I2C_Slave_ISR_DMA+0x4c>
2400c524:	687b      	ldr	r3, [r7, #4]
2400c526:	095b      	lsrs	r3, r3, #5
2400c528:	f003 0301 	and.w	r3, r3, #1
2400c52c:	2b00      	cmp	r3, #0
2400c52e:	d003      	beq.n	2400c538 <I2C_Slave_ISR_DMA+0x4c>
  {
    /* Call I2C Slave complete process */
    I2C_ITSlaveCplt(hi2c, ITFlags);
2400c530:	68b9      	ldr	r1, [r7, #8]
2400c532:	68f8      	ldr	r0, [r7, #12]
2400c534:	f000 fc4a 	bl	2400cdcc <I2C_ITSlaveCplt>
  }

  if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_AF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))
2400c538:	68bb      	ldr	r3, [r7, #8]
2400c53a:	091b      	lsrs	r3, r3, #4
2400c53c:	f003 0301 	and.w	r3, r3, #1
2400c540:	2b00      	cmp	r3, #0
2400c542:	f000 8199 	beq.w	2400c878 <I2C_Slave_ISR_DMA+0x38c>
2400c546:	687b      	ldr	r3, [r7, #4]
2400c548:	091b      	lsrs	r3, r3, #4
2400c54a:	f003 0301 	and.w	r3, r3, #1
2400c54e:	2b00      	cmp	r3, #0
2400c550:	f000 8192 	beq.w	2400c878 <I2C_Slave_ISR_DMA+0x38c>
  {
    /* Check that I2C transfer finished */
    /* if yes, normal use case, a NACK is sent by the MASTER when Transfer is finished */
    /* Mean XferCount == 0 */
    /* So clear Flag NACKF only */
    if ((I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_TXDMAEN) != RESET) ||
2400c554:	687b      	ldr	r3, [r7, #4]
2400c556:	0b9b      	lsrs	r3, r3, #14
2400c558:	f003 0301 	and.w	r3, r3, #1
2400c55c:	2b00      	cmp	r3, #0
2400c55e:	d106      	bne.n	2400c56e <I2C_Slave_ISR_DMA+0x82>
        (I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_RXDMAEN) != RESET))
2400c560:	687b      	ldr	r3, [r7, #4]
2400c562:	0bdb      	lsrs	r3, r3, #15
2400c564:	f003 0301 	and.w	r3, r3, #1
    if ((I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_TXDMAEN) != RESET) ||
2400c568:	2b00      	cmp	r3, #0
2400c56a:	f000 817e 	beq.w	2400c86a <I2C_Slave_ISR_DMA+0x37e>
    {
      /* Split check of hdmarx, for MISRA compliance */
      if (hi2c->hdmarx != NULL)
2400c56e:	68fb      	ldr	r3, [r7, #12]
2400c570:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400c572:	2b00      	cmp	r3, #0
2400c574:	d07c      	beq.n	2400c670 <I2C_Slave_ISR_DMA+0x184>
      {
        if (I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_RXDMAEN) != RESET)
2400c576:	687b      	ldr	r3, [r7, #4]
2400c578:	0bdb      	lsrs	r3, r3, #15
2400c57a:	f003 0301 	and.w	r3, r3, #1
2400c57e:	2b00      	cmp	r3, #0
2400c580:	d076      	beq.n	2400c670 <I2C_Slave_ISR_DMA+0x184>
        {
          if (__HAL_DMA_GET_COUNTER(hi2c->hdmarx) == 0U)
2400c582:	68fb      	ldr	r3, [r7, #12]
2400c584:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400c586:	681b      	ldr	r3, [r3, #0]
2400c588:	4a8d      	ldr	r2, [pc, #564]	; (2400c7c0 <I2C_Slave_ISR_DMA+0x2d4>)
2400c58a:	4293      	cmp	r3, r2
2400c58c:	d059      	beq.n	2400c642 <I2C_Slave_ISR_DMA+0x156>
2400c58e:	68fb      	ldr	r3, [r7, #12]
2400c590:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400c592:	681b      	ldr	r3, [r3, #0]
2400c594:	4a8b      	ldr	r2, [pc, #556]	; (2400c7c4 <I2C_Slave_ISR_DMA+0x2d8>)
2400c596:	4293      	cmp	r3, r2
2400c598:	d053      	beq.n	2400c642 <I2C_Slave_ISR_DMA+0x156>
2400c59a:	68fb      	ldr	r3, [r7, #12]
2400c59c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400c59e:	681b      	ldr	r3, [r3, #0]
2400c5a0:	4a89      	ldr	r2, [pc, #548]	; (2400c7c8 <I2C_Slave_ISR_DMA+0x2dc>)
2400c5a2:	4293      	cmp	r3, r2
2400c5a4:	d04d      	beq.n	2400c642 <I2C_Slave_ISR_DMA+0x156>
2400c5a6:	68fb      	ldr	r3, [r7, #12]
2400c5a8:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400c5aa:	681b      	ldr	r3, [r3, #0]
2400c5ac:	4a87      	ldr	r2, [pc, #540]	; (2400c7cc <I2C_Slave_ISR_DMA+0x2e0>)
2400c5ae:	4293      	cmp	r3, r2
2400c5b0:	d047      	beq.n	2400c642 <I2C_Slave_ISR_DMA+0x156>
2400c5b2:	68fb      	ldr	r3, [r7, #12]
2400c5b4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400c5b6:	681b      	ldr	r3, [r3, #0]
2400c5b8:	4a85      	ldr	r2, [pc, #532]	; (2400c7d0 <I2C_Slave_ISR_DMA+0x2e4>)
2400c5ba:	4293      	cmp	r3, r2
2400c5bc:	d041      	beq.n	2400c642 <I2C_Slave_ISR_DMA+0x156>
2400c5be:	68fb      	ldr	r3, [r7, #12]
2400c5c0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400c5c2:	681b      	ldr	r3, [r3, #0]
2400c5c4:	4a83      	ldr	r2, [pc, #524]	; (2400c7d4 <I2C_Slave_ISR_DMA+0x2e8>)
2400c5c6:	4293      	cmp	r3, r2
2400c5c8:	d03b      	beq.n	2400c642 <I2C_Slave_ISR_DMA+0x156>
2400c5ca:	68fb      	ldr	r3, [r7, #12]
2400c5cc:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400c5ce:	681b      	ldr	r3, [r3, #0]
2400c5d0:	4a81      	ldr	r2, [pc, #516]	; (2400c7d8 <I2C_Slave_ISR_DMA+0x2ec>)
2400c5d2:	4293      	cmp	r3, r2
2400c5d4:	d035      	beq.n	2400c642 <I2C_Slave_ISR_DMA+0x156>
2400c5d6:	68fb      	ldr	r3, [r7, #12]
2400c5d8:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400c5da:	681b      	ldr	r3, [r3, #0]
2400c5dc:	4a7f      	ldr	r2, [pc, #508]	; (2400c7dc <I2C_Slave_ISR_DMA+0x2f0>)
2400c5de:	4293      	cmp	r3, r2
2400c5e0:	d02f      	beq.n	2400c642 <I2C_Slave_ISR_DMA+0x156>
2400c5e2:	68fb      	ldr	r3, [r7, #12]
2400c5e4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400c5e6:	681b      	ldr	r3, [r3, #0]
2400c5e8:	4a7d      	ldr	r2, [pc, #500]	; (2400c7e0 <I2C_Slave_ISR_DMA+0x2f4>)
2400c5ea:	4293      	cmp	r3, r2
2400c5ec:	d029      	beq.n	2400c642 <I2C_Slave_ISR_DMA+0x156>
2400c5ee:	68fb      	ldr	r3, [r7, #12]
2400c5f0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400c5f2:	681b      	ldr	r3, [r3, #0]
2400c5f4:	4a7b      	ldr	r2, [pc, #492]	; (2400c7e4 <I2C_Slave_ISR_DMA+0x2f8>)
2400c5f6:	4293      	cmp	r3, r2
2400c5f8:	d023      	beq.n	2400c642 <I2C_Slave_ISR_DMA+0x156>
2400c5fa:	68fb      	ldr	r3, [r7, #12]
2400c5fc:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400c5fe:	681b      	ldr	r3, [r3, #0]
2400c600:	4a79      	ldr	r2, [pc, #484]	; (2400c7e8 <I2C_Slave_ISR_DMA+0x2fc>)
2400c602:	4293      	cmp	r3, r2
2400c604:	d01d      	beq.n	2400c642 <I2C_Slave_ISR_DMA+0x156>
2400c606:	68fb      	ldr	r3, [r7, #12]
2400c608:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400c60a:	681b      	ldr	r3, [r3, #0]
2400c60c:	4a77      	ldr	r2, [pc, #476]	; (2400c7ec <I2C_Slave_ISR_DMA+0x300>)
2400c60e:	4293      	cmp	r3, r2
2400c610:	d017      	beq.n	2400c642 <I2C_Slave_ISR_DMA+0x156>
2400c612:	68fb      	ldr	r3, [r7, #12]
2400c614:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400c616:	681b      	ldr	r3, [r3, #0]
2400c618:	4a75      	ldr	r2, [pc, #468]	; (2400c7f0 <I2C_Slave_ISR_DMA+0x304>)
2400c61a:	4293      	cmp	r3, r2
2400c61c:	d011      	beq.n	2400c642 <I2C_Slave_ISR_DMA+0x156>
2400c61e:	68fb      	ldr	r3, [r7, #12]
2400c620:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400c622:	681b      	ldr	r3, [r3, #0]
2400c624:	4a73      	ldr	r2, [pc, #460]	; (2400c7f4 <I2C_Slave_ISR_DMA+0x308>)
2400c626:	4293      	cmp	r3, r2
2400c628:	d00b      	beq.n	2400c642 <I2C_Slave_ISR_DMA+0x156>
2400c62a:	68fb      	ldr	r3, [r7, #12]
2400c62c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400c62e:	681b      	ldr	r3, [r3, #0]
2400c630:	4a71      	ldr	r2, [pc, #452]	; (2400c7f8 <I2C_Slave_ISR_DMA+0x30c>)
2400c632:	4293      	cmp	r3, r2
2400c634:	d005      	beq.n	2400c642 <I2C_Slave_ISR_DMA+0x156>
2400c636:	68fb      	ldr	r3, [r7, #12]
2400c638:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400c63a:	681b      	ldr	r3, [r3, #0]
2400c63c:	4a6f      	ldr	r2, [pc, #444]	; (2400c7fc <I2C_Slave_ISR_DMA+0x310>)
2400c63e:	4293      	cmp	r3, r2
2400c640:	d109      	bne.n	2400c656 <I2C_Slave_ISR_DMA+0x16a>
2400c642:	68fb      	ldr	r3, [r7, #12]
2400c644:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400c646:	681b      	ldr	r3, [r3, #0]
2400c648:	685b      	ldr	r3, [r3, #4]
2400c64a:	2b00      	cmp	r3, #0
2400c64c:	bf0c      	ite	eq
2400c64e:	2301      	moveq	r3, #1
2400c650:	2300      	movne	r3, #0
2400c652:	b2db      	uxtb	r3, r3
2400c654:	e008      	b.n	2400c668 <I2C_Slave_ISR_DMA+0x17c>
2400c656:	68fb      	ldr	r3, [r7, #12]
2400c658:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400c65a:	681b      	ldr	r3, [r3, #0]
2400c65c:	685b      	ldr	r3, [r3, #4]
2400c65e:	2b00      	cmp	r3, #0
2400c660:	bf0c      	ite	eq
2400c662:	2301      	moveq	r3, #1
2400c664:	2300      	movne	r3, #0
2400c666:	b2db      	uxtb	r3, r3
2400c668:	2b00      	cmp	r3, #0
2400c66a:	d001      	beq.n	2400c670 <I2C_Slave_ISR_DMA+0x184>
          {
            treatdmanack = 1U;
2400c66c:	2301      	movs	r3, #1
2400c66e:	61fb      	str	r3, [r7, #28]
          }
        }
      }

      /* Split check of hdmatx, for MISRA compliance  */
      if (hi2c->hdmatx != NULL)
2400c670:	68fb      	ldr	r3, [r7, #12]
2400c672:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400c674:	2b00      	cmp	r3, #0
2400c676:	d07c      	beq.n	2400c772 <I2C_Slave_ISR_DMA+0x286>
      {
        if (I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_TXDMAEN) != RESET)
2400c678:	687b      	ldr	r3, [r7, #4]
2400c67a:	0b9b      	lsrs	r3, r3, #14
2400c67c:	f003 0301 	and.w	r3, r3, #1
2400c680:	2b00      	cmp	r3, #0
2400c682:	d076      	beq.n	2400c772 <I2C_Slave_ISR_DMA+0x286>
        {
          if (__HAL_DMA_GET_COUNTER(hi2c->hdmatx) == 0U)
2400c684:	68fb      	ldr	r3, [r7, #12]
2400c686:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400c688:	681b      	ldr	r3, [r3, #0]
2400c68a:	4a4d      	ldr	r2, [pc, #308]	; (2400c7c0 <I2C_Slave_ISR_DMA+0x2d4>)
2400c68c:	4293      	cmp	r3, r2
2400c68e:	d059      	beq.n	2400c744 <I2C_Slave_ISR_DMA+0x258>
2400c690:	68fb      	ldr	r3, [r7, #12]
2400c692:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400c694:	681b      	ldr	r3, [r3, #0]
2400c696:	4a4b      	ldr	r2, [pc, #300]	; (2400c7c4 <I2C_Slave_ISR_DMA+0x2d8>)
2400c698:	4293      	cmp	r3, r2
2400c69a:	d053      	beq.n	2400c744 <I2C_Slave_ISR_DMA+0x258>
2400c69c:	68fb      	ldr	r3, [r7, #12]
2400c69e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400c6a0:	681b      	ldr	r3, [r3, #0]
2400c6a2:	4a49      	ldr	r2, [pc, #292]	; (2400c7c8 <I2C_Slave_ISR_DMA+0x2dc>)
2400c6a4:	4293      	cmp	r3, r2
2400c6a6:	d04d      	beq.n	2400c744 <I2C_Slave_ISR_DMA+0x258>
2400c6a8:	68fb      	ldr	r3, [r7, #12]
2400c6aa:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400c6ac:	681b      	ldr	r3, [r3, #0]
2400c6ae:	4a47      	ldr	r2, [pc, #284]	; (2400c7cc <I2C_Slave_ISR_DMA+0x2e0>)
2400c6b0:	4293      	cmp	r3, r2
2400c6b2:	d047      	beq.n	2400c744 <I2C_Slave_ISR_DMA+0x258>
2400c6b4:	68fb      	ldr	r3, [r7, #12]
2400c6b6:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400c6b8:	681b      	ldr	r3, [r3, #0]
2400c6ba:	4a45      	ldr	r2, [pc, #276]	; (2400c7d0 <I2C_Slave_ISR_DMA+0x2e4>)
2400c6bc:	4293      	cmp	r3, r2
2400c6be:	d041      	beq.n	2400c744 <I2C_Slave_ISR_DMA+0x258>
2400c6c0:	68fb      	ldr	r3, [r7, #12]
2400c6c2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400c6c4:	681b      	ldr	r3, [r3, #0]
2400c6c6:	4a43      	ldr	r2, [pc, #268]	; (2400c7d4 <I2C_Slave_ISR_DMA+0x2e8>)
2400c6c8:	4293      	cmp	r3, r2
2400c6ca:	d03b      	beq.n	2400c744 <I2C_Slave_ISR_DMA+0x258>
2400c6cc:	68fb      	ldr	r3, [r7, #12]
2400c6ce:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400c6d0:	681b      	ldr	r3, [r3, #0]
2400c6d2:	4a41      	ldr	r2, [pc, #260]	; (2400c7d8 <I2C_Slave_ISR_DMA+0x2ec>)
2400c6d4:	4293      	cmp	r3, r2
2400c6d6:	d035      	beq.n	2400c744 <I2C_Slave_ISR_DMA+0x258>
2400c6d8:	68fb      	ldr	r3, [r7, #12]
2400c6da:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400c6dc:	681b      	ldr	r3, [r3, #0]
2400c6de:	4a3f      	ldr	r2, [pc, #252]	; (2400c7dc <I2C_Slave_ISR_DMA+0x2f0>)
2400c6e0:	4293      	cmp	r3, r2
2400c6e2:	d02f      	beq.n	2400c744 <I2C_Slave_ISR_DMA+0x258>
2400c6e4:	68fb      	ldr	r3, [r7, #12]
2400c6e6:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400c6e8:	681b      	ldr	r3, [r3, #0]
2400c6ea:	4a3d      	ldr	r2, [pc, #244]	; (2400c7e0 <I2C_Slave_ISR_DMA+0x2f4>)
2400c6ec:	4293      	cmp	r3, r2
2400c6ee:	d029      	beq.n	2400c744 <I2C_Slave_ISR_DMA+0x258>
2400c6f0:	68fb      	ldr	r3, [r7, #12]
2400c6f2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400c6f4:	681b      	ldr	r3, [r3, #0]
2400c6f6:	4a3b      	ldr	r2, [pc, #236]	; (2400c7e4 <I2C_Slave_ISR_DMA+0x2f8>)
2400c6f8:	4293      	cmp	r3, r2
2400c6fa:	d023      	beq.n	2400c744 <I2C_Slave_ISR_DMA+0x258>
2400c6fc:	68fb      	ldr	r3, [r7, #12]
2400c6fe:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400c700:	681b      	ldr	r3, [r3, #0]
2400c702:	4a39      	ldr	r2, [pc, #228]	; (2400c7e8 <I2C_Slave_ISR_DMA+0x2fc>)
2400c704:	4293      	cmp	r3, r2
2400c706:	d01d      	beq.n	2400c744 <I2C_Slave_ISR_DMA+0x258>
2400c708:	68fb      	ldr	r3, [r7, #12]
2400c70a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400c70c:	681b      	ldr	r3, [r3, #0]
2400c70e:	4a37      	ldr	r2, [pc, #220]	; (2400c7ec <I2C_Slave_ISR_DMA+0x300>)
2400c710:	4293      	cmp	r3, r2
2400c712:	d017      	beq.n	2400c744 <I2C_Slave_ISR_DMA+0x258>
2400c714:	68fb      	ldr	r3, [r7, #12]
2400c716:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400c718:	681b      	ldr	r3, [r3, #0]
2400c71a:	4a35      	ldr	r2, [pc, #212]	; (2400c7f0 <I2C_Slave_ISR_DMA+0x304>)
2400c71c:	4293      	cmp	r3, r2
2400c71e:	d011      	beq.n	2400c744 <I2C_Slave_ISR_DMA+0x258>
2400c720:	68fb      	ldr	r3, [r7, #12]
2400c722:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400c724:	681b      	ldr	r3, [r3, #0]
2400c726:	4a33      	ldr	r2, [pc, #204]	; (2400c7f4 <I2C_Slave_ISR_DMA+0x308>)
2400c728:	4293      	cmp	r3, r2
2400c72a:	d00b      	beq.n	2400c744 <I2C_Slave_ISR_DMA+0x258>
2400c72c:	68fb      	ldr	r3, [r7, #12]
2400c72e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400c730:	681b      	ldr	r3, [r3, #0]
2400c732:	4a31      	ldr	r2, [pc, #196]	; (2400c7f8 <I2C_Slave_ISR_DMA+0x30c>)
2400c734:	4293      	cmp	r3, r2
2400c736:	d005      	beq.n	2400c744 <I2C_Slave_ISR_DMA+0x258>
2400c738:	68fb      	ldr	r3, [r7, #12]
2400c73a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400c73c:	681b      	ldr	r3, [r3, #0]
2400c73e:	4a2f      	ldr	r2, [pc, #188]	; (2400c7fc <I2C_Slave_ISR_DMA+0x310>)
2400c740:	4293      	cmp	r3, r2
2400c742:	d109      	bne.n	2400c758 <I2C_Slave_ISR_DMA+0x26c>
2400c744:	68fb      	ldr	r3, [r7, #12]
2400c746:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400c748:	681b      	ldr	r3, [r3, #0]
2400c74a:	685b      	ldr	r3, [r3, #4]
2400c74c:	2b00      	cmp	r3, #0
2400c74e:	bf0c      	ite	eq
2400c750:	2301      	moveq	r3, #1
2400c752:	2300      	movne	r3, #0
2400c754:	b2db      	uxtb	r3, r3
2400c756:	e008      	b.n	2400c76a <I2C_Slave_ISR_DMA+0x27e>
2400c758:	68fb      	ldr	r3, [r7, #12]
2400c75a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400c75c:	681b      	ldr	r3, [r3, #0]
2400c75e:	685b      	ldr	r3, [r3, #4]
2400c760:	2b00      	cmp	r3, #0
2400c762:	bf0c      	ite	eq
2400c764:	2301      	moveq	r3, #1
2400c766:	2300      	movne	r3, #0
2400c768:	b2db      	uxtb	r3, r3
2400c76a:	2b00      	cmp	r3, #0
2400c76c:	d001      	beq.n	2400c772 <I2C_Slave_ISR_DMA+0x286>
          {
            treatdmanack = 1U;
2400c76e:	2301      	movs	r3, #1
2400c770:	61fb      	str	r3, [r7, #28]
          }
        }
      }

      if (treatdmanack == 1U)
2400c772:	69fb      	ldr	r3, [r7, #28]
2400c774:	2b01      	cmp	r3, #1
2400c776:	d148      	bne.n	2400c80a <I2C_Slave_ISR_DMA+0x31e>
      {
        if ((hi2c->State == HAL_I2C_STATE_LISTEN) && (tmpoptions == I2C_FIRST_AND_LAST_FRAME)) /* Same action must be done for (tmpoptions == I2C_LAST_FRAME) which removed for Warning[Pa134]: left and right operands are identical */
2400c778:	68fb      	ldr	r3, [r7, #12]
2400c77a:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400c77e:	b2db      	uxtb	r3, r3
2400c780:	2b28      	cmp	r3, #40	; 0x28
2400c782:	d108      	bne.n	2400c796 <I2C_Slave_ISR_DMA+0x2aa>
2400c784:	69bb      	ldr	r3, [r7, #24]
2400c786:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
2400c78a:	d104      	bne.n	2400c796 <I2C_Slave_ISR_DMA+0x2aa>
        {
          /* Call I2C Listen complete process */
          I2C_ITListenCplt(hi2c, ITFlags);
2400c78c:	68b9      	ldr	r1, [r7, #8]
2400c78e:	68f8      	ldr	r0, [r7, #12]
2400c790:	f000 fd14 	bl	2400d1bc <I2C_ITListenCplt>
2400c794:	e068      	b.n	2400c868 <I2C_Slave_ISR_DMA+0x37c>
        }
        else if ((hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN) && (tmpoptions != I2C_NO_OPTION_FRAME))
2400c796:	68fb      	ldr	r3, [r7, #12]
2400c798:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400c79c:	b2db      	uxtb	r3, r3
2400c79e:	2b29      	cmp	r3, #41	; 0x29
2400c7a0:	d12e      	bne.n	2400c800 <I2C_Slave_ISR_DMA+0x314>
2400c7a2:	69bb      	ldr	r3, [r7, #24]
2400c7a4:	f513 3f80 	cmn.w	r3, #65536	; 0x10000
2400c7a8:	d02a      	beq.n	2400c800 <I2C_Slave_ISR_DMA+0x314>
        {
          /* Clear NACK Flag */
          __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
2400c7aa:	68fb      	ldr	r3, [r7, #12]
2400c7ac:	681b      	ldr	r3, [r3, #0]
2400c7ae:	2210      	movs	r2, #16
2400c7b0:	61da      	str	r2, [r3, #28]

          /* Flush TX register */
          I2C_Flush_TXDR(hi2c);
2400c7b2:	68f8      	ldr	r0, [r7, #12]
2400c7b4:	f000 fe4f 	bl	2400d456 <I2C_Flush_TXDR>

          /* Last Byte is Transmitted */
          /* Call I2C Slave Sequential complete process */
          I2C_ITSlaveSeqCplt(hi2c);
2400c7b8:	68f8      	ldr	r0, [r7, #12]
2400c7ba:	f000 f9e0 	bl	2400cb7e <I2C_ITSlaveSeqCplt>
2400c7be:	e053      	b.n	2400c868 <I2C_Slave_ISR_DMA+0x37c>
2400c7c0:	40020010 	.word	0x40020010
2400c7c4:	40020028 	.word	0x40020028
2400c7c8:	40020040 	.word	0x40020040
2400c7cc:	40020058 	.word	0x40020058
2400c7d0:	40020070 	.word	0x40020070
2400c7d4:	40020088 	.word	0x40020088
2400c7d8:	400200a0 	.word	0x400200a0
2400c7dc:	400200b8 	.word	0x400200b8
2400c7e0:	40020410 	.word	0x40020410
2400c7e4:	40020428 	.word	0x40020428
2400c7e8:	40020440 	.word	0x40020440
2400c7ec:	40020458 	.word	0x40020458
2400c7f0:	40020470 	.word	0x40020470
2400c7f4:	40020488 	.word	0x40020488
2400c7f8:	400204a0 	.word	0x400204a0
2400c7fc:	400204b8 	.word	0x400204b8
        }
        else
        {
          /* Clear NACK Flag */
          __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
2400c800:	68fb      	ldr	r3, [r7, #12]
2400c802:	681b      	ldr	r3, [r3, #0]
2400c804:	2210      	movs	r2, #16
2400c806:	61da      	str	r2, [r3, #28]
      if (treatdmanack == 1U)
2400c808:	e034      	b.n	2400c874 <I2C_Slave_ISR_DMA+0x388>
      }
      else
      {
        /* if no, error use case, a Non-Acknowledge of last Data is generated by the MASTER*/
        /* Clear NACK Flag */
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
2400c80a:	68fb      	ldr	r3, [r7, #12]
2400c80c:	681b      	ldr	r3, [r3, #0]
2400c80e:	2210      	movs	r2, #16
2400c810:	61da      	str	r2, [r3, #28]

        /* Set ErrorCode corresponding to a Non-Acknowledge */
        hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
2400c812:	68fb      	ldr	r3, [r7, #12]
2400c814:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400c816:	f043 0204 	orr.w	r2, r3, #4
2400c81a:	68fb      	ldr	r3, [r7, #12]
2400c81c:	645a      	str	r2, [r3, #68]	; 0x44

        /* Store current hi2c->State, solve MISRA2012-Rule-13.5 */
        tmpstate = hi2c->State;
2400c81e:	68fb      	ldr	r3, [r7, #12]
2400c820:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400c824:	75fb      	strb	r3, [r7, #23]

        if ((tmpoptions == I2C_FIRST_FRAME) || (tmpoptions == I2C_NEXT_FRAME))
2400c826:	69bb      	ldr	r3, [r7, #24]
2400c828:	2b00      	cmp	r3, #0
2400c82a:	d003      	beq.n	2400c834 <I2C_Slave_ISR_DMA+0x348>
2400c82c:	69bb      	ldr	r3, [r7, #24]
2400c82e:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
2400c832:	d11f      	bne.n	2400c874 <I2C_Slave_ISR_DMA+0x388>
        {
          if ((tmpstate == HAL_I2C_STATE_BUSY_TX) || (tmpstate == HAL_I2C_STATE_BUSY_TX_LISTEN))
2400c834:	7dfb      	ldrb	r3, [r7, #23]
2400c836:	2b21      	cmp	r3, #33	; 0x21
2400c838:	d002      	beq.n	2400c840 <I2C_Slave_ISR_DMA+0x354>
2400c83a:	7dfb      	ldrb	r3, [r7, #23]
2400c83c:	2b29      	cmp	r3, #41	; 0x29
2400c83e:	d103      	bne.n	2400c848 <I2C_Slave_ISR_DMA+0x35c>
          {
            hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_TX;
2400c840:	68fb      	ldr	r3, [r7, #12]
2400c842:	2221      	movs	r2, #33	; 0x21
2400c844:	631a      	str	r2, [r3, #48]	; 0x30
2400c846:	e008      	b.n	2400c85a <I2C_Slave_ISR_DMA+0x36e>
          }
          else if ((tmpstate == HAL_I2C_STATE_BUSY_RX) || (tmpstate == HAL_I2C_STATE_BUSY_RX_LISTEN))
2400c848:	7dfb      	ldrb	r3, [r7, #23]
2400c84a:	2b22      	cmp	r3, #34	; 0x22
2400c84c:	d002      	beq.n	2400c854 <I2C_Slave_ISR_DMA+0x368>
2400c84e:	7dfb      	ldrb	r3, [r7, #23]
2400c850:	2b2a      	cmp	r3, #42	; 0x2a
2400c852:	d102      	bne.n	2400c85a <I2C_Slave_ISR_DMA+0x36e>
          {
            hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_RX;
2400c854:	68fb      	ldr	r3, [r7, #12]
2400c856:	2222      	movs	r2, #34	; 0x22
2400c858:	631a      	str	r2, [r3, #48]	; 0x30
          {
            /* Do nothing */
          }

          /* Call the corresponding callback to inform upper layer of End of Transfer */
          I2C_ITError(hi2c, hi2c->ErrorCode);
2400c85a:	68fb      	ldr	r3, [r7, #12]
2400c85c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400c85e:	4619      	mov	r1, r3
2400c860:	68f8      	ldr	r0, [r7, #12]
2400c862:	f000 fd01 	bl	2400d268 <I2C_ITError>
      if (treatdmanack == 1U)
2400c866:	e005      	b.n	2400c874 <I2C_Slave_ISR_DMA+0x388>
2400c868:	e004      	b.n	2400c874 <I2C_Slave_ISR_DMA+0x388>
      }
    }
    else
    {
      /* Only Clear NACK Flag, no DMA treatment is pending */
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
2400c86a:	68fb      	ldr	r3, [r7, #12]
2400c86c:	681b      	ldr	r3, [r3, #0]
2400c86e:	2210      	movs	r2, #16
2400c870:	61da      	str	r2, [r3, #28]
    if ((I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_TXDMAEN) != RESET) ||
2400c872:	e011      	b.n	2400c898 <I2C_Slave_ISR_DMA+0x3ac>
      if (treatdmanack == 1U)
2400c874:	bf00      	nop
    if ((I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_TXDMAEN) != RESET) ||
2400c876:	e00f      	b.n	2400c898 <I2C_Slave_ISR_DMA+0x3ac>
    }
  }
  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_ADDR) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_ADDRI) != RESET))
2400c878:	68bb      	ldr	r3, [r7, #8]
2400c87a:	08db      	lsrs	r3, r3, #3
2400c87c:	f003 0301 	and.w	r3, r3, #1
2400c880:	2b00      	cmp	r3, #0
2400c882:	d009      	beq.n	2400c898 <I2C_Slave_ISR_DMA+0x3ac>
2400c884:	687b      	ldr	r3, [r7, #4]
2400c886:	08db      	lsrs	r3, r3, #3
2400c888:	f003 0301 	and.w	r3, r3, #1
2400c88c:	2b00      	cmp	r3, #0
2400c88e:	d003      	beq.n	2400c898 <I2C_Slave_ISR_DMA+0x3ac>
  {
    I2C_ITAddrCplt(hi2c, ITFlags);
2400c890:	68b9      	ldr	r1, [r7, #8]
2400c892:	68f8      	ldr	r0, [r7, #12]
2400c894:	f000 f8b2 	bl	2400c9fc <I2C_ITAddrCplt>
  {
    /* Nothing to do */
  }

  /* Process Unlocked */
  __HAL_UNLOCK(hi2c);
2400c898:	68fb      	ldr	r3, [r7, #12]
2400c89a:	2200      	movs	r2, #0
2400c89c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  return HAL_OK;
2400c8a0:	2300      	movs	r3, #0
}
2400c8a2:	4618      	mov	r0, r3
2400c8a4:	3720      	adds	r7, #32
2400c8a6:	46bd      	mov	sp, r7
2400c8a8:	bd80      	pop	{r7, pc}
2400c8aa:	bf00      	nop

2400c8ac <I2C_RequestMemoryWrite>:
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_RequestMemoryWrite(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout, uint32_t Tickstart)
{
2400c8ac:	b580      	push	{r7, lr}
2400c8ae:	b086      	sub	sp, #24
2400c8b0:	af02      	add	r7, sp, #8
2400c8b2:	60f8      	str	r0, [r7, #12]
2400c8b4:	4608      	mov	r0, r1
2400c8b6:	4611      	mov	r1, r2
2400c8b8:	461a      	mov	r2, r3
2400c8ba:	4603      	mov	r3, r0
2400c8bc:	817b      	strh	r3, [r7, #10]
2400c8be:	460b      	mov	r3, r1
2400c8c0:	813b      	strh	r3, [r7, #8]
2400c8c2:	4613      	mov	r3, r2
2400c8c4:	80fb      	strh	r3, [r7, #6]
  I2C_TransferConfig(hi2c, DevAddress, (uint8_t)MemAddSize, I2C_RELOAD_MODE, I2C_GENERATE_START_WRITE);
2400c8c6:	88fb      	ldrh	r3, [r7, #6]
2400c8c8:	b2da      	uxtb	r2, r3
2400c8ca:	8979      	ldrh	r1, [r7, #10]
2400c8cc:	4b20      	ldr	r3, [pc, #128]	; (2400c950 <I2C_RequestMemoryWrite+0xa4>)
2400c8ce:	9300      	str	r3, [sp, #0]
2400c8d0:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2400c8d4:	68f8      	ldr	r0, [r7, #12]
2400c8d6:	f001 fa2f 	bl	2400dd38 <I2C_TransferConfig>

  /* Wait until TXIS flag is set */
  if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
2400c8da:	69fa      	ldr	r2, [r7, #28]
2400c8dc:	69b9      	ldr	r1, [r7, #24]
2400c8de:	68f8      	ldr	r0, [r7, #12]
2400c8e0:	f001 f8dc 	bl	2400da9c <I2C_WaitOnTXISFlagUntilTimeout>
2400c8e4:	4603      	mov	r3, r0
2400c8e6:	2b00      	cmp	r3, #0
2400c8e8:	d001      	beq.n	2400c8ee <I2C_RequestMemoryWrite+0x42>
  {
    return HAL_ERROR;
2400c8ea:	2301      	movs	r3, #1
2400c8ec:	e02c      	b.n	2400c948 <I2C_RequestMemoryWrite+0x9c>
  }

  /* If Memory address size is 8Bit */
  if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
2400c8ee:	88fb      	ldrh	r3, [r7, #6]
2400c8f0:	2b01      	cmp	r3, #1
2400c8f2:	d105      	bne.n	2400c900 <I2C_RequestMemoryWrite+0x54>
  {
    /* Send Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
2400c8f4:	893b      	ldrh	r3, [r7, #8]
2400c8f6:	b2da      	uxtb	r2, r3
2400c8f8:	68fb      	ldr	r3, [r7, #12]
2400c8fa:	681b      	ldr	r3, [r3, #0]
2400c8fc:	629a      	str	r2, [r3, #40]	; 0x28
2400c8fe:	e015      	b.n	2400c92c <I2C_RequestMemoryWrite+0x80>
  }
  /* If Memory address size is 16Bit */
  else
  {
    /* Send MSB of Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);
2400c900:	893b      	ldrh	r3, [r7, #8]
2400c902:	0a1b      	lsrs	r3, r3, #8
2400c904:	b29b      	uxth	r3, r3
2400c906:	b2da      	uxtb	r2, r3
2400c908:	68fb      	ldr	r3, [r7, #12]
2400c90a:	681b      	ldr	r3, [r3, #0]
2400c90c:	629a      	str	r2, [r3, #40]	; 0x28

    /* Wait until TXIS flag is set */
    if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
2400c90e:	69fa      	ldr	r2, [r7, #28]
2400c910:	69b9      	ldr	r1, [r7, #24]
2400c912:	68f8      	ldr	r0, [r7, #12]
2400c914:	f001 f8c2 	bl	2400da9c <I2C_WaitOnTXISFlagUntilTimeout>
2400c918:	4603      	mov	r3, r0
2400c91a:	2b00      	cmp	r3, #0
2400c91c:	d001      	beq.n	2400c922 <I2C_RequestMemoryWrite+0x76>
    {
      return HAL_ERROR;
2400c91e:	2301      	movs	r3, #1
2400c920:	e012      	b.n	2400c948 <I2C_RequestMemoryWrite+0x9c>
    }

    /* Send LSB of Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
2400c922:	893b      	ldrh	r3, [r7, #8]
2400c924:	b2da      	uxtb	r2, r3
2400c926:	68fb      	ldr	r3, [r7, #12]
2400c928:	681b      	ldr	r3, [r3, #0]
2400c92a:	629a      	str	r2, [r3, #40]	; 0x28
  }

  /* Wait until TCR flag is set */
  if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, Tickstart) != HAL_OK)
2400c92c:	69fb      	ldr	r3, [r7, #28]
2400c92e:	9300      	str	r3, [sp, #0]
2400c930:	69bb      	ldr	r3, [r7, #24]
2400c932:	2200      	movs	r2, #0
2400c934:	2180      	movs	r1, #128	; 0x80
2400c936:	68f8      	ldr	r0, [r7, #12]
2400c938:	f001 f870 	bl	2400da1c <I2C_WaitOnFlagUntilTimeout>
2400c93c:	4603      	mov	r3, r0
2400c93e:	2b00      	cmp	r3, #0
2400c940:	d001      	beq.n	2400c946 <I2C_RequestMemoryWrite+0x9a>
  {
    return HAL_ERROR;
2400c942:	2301      	movs	r3, #1
2400c944:	e000      	b.n	2400c948 <I2C_RequestMemoryWrite+0x9c>
  }

  return HAL_OK;
2400c946:	2300      	movs	r3, #0
}
2400c948:	4618      	mov	r0, r3
2400c94a:	3710      	adds	r7, #16
2400c94c:	46bd      	mov	sp, r7
2400c94e:	bd80      	pop	{r7, pc}
2400c950:	80002000 	.word	0x80002000

2400c954 <I2C_RequestMemoryRead>:
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_RequestMemoryRead(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout, uint32_t Tickstart)
{
2400c954:	b580      	push	{r7, lr}
2400c956:	b086      	sub	sp, #24
2400c958:	af02      	add	r7, sp, #8
2400c95a:	60f8      	str	r0, [r7, #12]
2400c95c:	4608      	mov	r0, r1
2400c95e:	4611      	mov	r1, r2
2400c960:	461a      	mov	r2, r3
2400c962:	4603      	mov	r3, r0
2400c964:	817b      	strh	r3, [r7, #10]
2400c966:	460b      	mov	r3, r1
2400c968:	813b      	strh	r3, [r7, #8]
2400c96a:	4613      	mov	r3, r2
2400c96c:	80fb      	strh	r3, [r7, #6]
  I2C_TransferConfig(hi2c, DevAddress, (uint8_t)MemAddSize, I2C_SOFTEND_MODE, I2C_GENERATE_START_WRITE);
2400c96e:	88fb      	ldrh	r3, [r7, #6]
2400c970:	b2da      	uxtb	r2, r3
2400c972:	8979      	ldrh	r1, [r7, #10]
2400c974:	4b20      	ldr	r3, [pc, #128]	; (2400c9f8 <I2C_RequestMemoryRead+0xa4>)
2400c976:	9300      	str	r3, [sp, #0]
2400c978:	2300      	movs	r3, #0
2400c97a:	68f8      	ldr	r0, [r7, #12]
2400c97c:	f001 f9dc 	bl	2400dd38 <I2C_TransferConfig>

  /* Wait until TXIS flag is set */
  if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
2400c980:	69fa      	ldr	r2, [r7, #28]
2400c982:	69b9      	ldr	r1, [r7, #24]
2400c984:	68f8      	ldr	r0, [r7, #12]
2400c986:	f001 f889 	bl	2400da9c <I2C_WaitOnTXISFlagUntilTimeout>
2400c98a:	4603      	mov	r3, r0
2400c98c:	2b00      	cmp	r3, #0
2400c98e:	d001      	beq.n	2400c994 <I2C_RequestMemoryRead+0x40>
  {
    return HAL_ERROR;
2400c990:	2301      	movs	r3, #1
2400c992:	e02c      	b.n	2400c9ee <I2C_RequestMemoryRead+0x9a>
  }

  /* If Memory address size is 8Bit */
  if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
2400c994:	88fb      	ldrh	r3, [r7, #6]
2400c996:	2b01      	cmp	r3, #1
2400c998:	d105      	bne.n	2400c9a6 <I2C_RequestMemoryRead+0x52>
  {
    /* Send Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
2400c99a:	893b      	ldrh	r3, [r7, #8]
2400c99c:	b2da      	uxtb	r2, r3
2400c99e:	68fb      	ldr	r3, [r7, #12]
2400c9a0:	681b      	ldr	r3, [r3, #0]
2400c9a2:	629a      	str	r2, [r3, #40]	; 0x28
2400c9a4:	e015      	b.n	2400c9d2 <I2C_RequestMemoryRead+0x7e>
  }
  /* If Memory address size is 16Bit */
  else
  {
    /* Send MSB of Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);
2400c9a6:	893b      	ldrh	r3, [r7, #8]
2400c9a8:	0a1b      	lsrs	r3, r3, #8
2400c9aa:	b29b      	uxth	r3, r3
2400c9ac:	b2da      	uxtb	r2, r3
2400c9ae:	68fb      	ldr	r3, [r7, #12]
2400c9b0:	681b      	ldr	r3, [r3, #0]
2400c9b2:	629a      	str	r2, [r3, #40]	; 0x28

    /* Wait until TXIS flag is set */
    if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
2400c9b4:	69fa      	ldr	r2, [r7, #28]
2400c9b6:	69b9      	ldr	r1, [r7, #24]
2400c9b8:	68f8      	ldr	r0, [r7, #12]
2400c9ba:	f001 f86f 	bl	2400da9c <I2C_WaitOnTXISFlagUntilTimeout>
2400c9be:	4603      	mov	r3, r0
2400c9c0:	2b00      	cmp	r3, #0
2400c9c2:	d001      	beq.n	2400c9c8 <I2C_RequestMemoryRead+0x74>
    {
      return HAL_ERROR;
2400c9c4:	2301      	movs	r3, #1
2400c9c6:	e012      	b.n	2400c9ee <I2C_RequestMemoryRead+0x9a>
    }

    /* Send LSB of Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
2400c9c8:	893b      	ldrh	r3, [r7, #8]
2400c9ca:	b2da      	uxtb	r2, r3
2400c9cc:	68fb      	ldr	r3, [r7, #12]
2400c9ce:	681b      	ldr	r3, [r3, #0]
2400c9d0:	629a      	str	r2, [r3, #40]	; 0x28
  }

  /* Wait until TC flag is set */
  if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TC, RESET, Timeout, Tickstart) != HAL_OK)
2400c9d2:	69fb      	ldr	r3, [r7, #28]
2400c9d4:	9300      	str	r3, [sp, #0]
2400c9d6:	69bb      	ldr	r3, [r7, #24]
2400c9d8:	2200      	movs	r2, #0
2400c9da:	2140      	movs	r1, #64	; 0x40
2400c9dc:	68f8      	ldr	r0, [r7, #12]
2400c9de:	f001 f81d 	bl	2400da1c <I2C_WaitOnFlagUntilTimeout>
2400c9e2:	4603      	mov	r3, r0
2400c9e4:	2b00      	cmp	r3, #0
2400c9e6:	d001      	beq.n	2400c9ec <I2C_RequestMemoryRead+0x98>
  {
    return HAL_ERROR;
2400c9e8:	2301      	movs	r3, #1
2400c9ea:	e000      	b.n	2400c9ee <I2C_RequestMemoryRead+0x9a>
  }

  return HAL_OK;
2400c9ec:	2300      	movs	r3, #0
}
2400c9ee:	4618      	mov	r0, r3
2400c9f0:	3710      	adds	r7, #16
2400c9f2:	46bd      	mov	sp, r7
2400c9f4:	bd80      	pop	{r7, pc}
2400c9f6:	bf00      	nop
2400c9f8:	80002000 	.word	0x80002000

2400c9fc <I2C_ITAddrCplt>:
  * @param  hi2c I2C handle.
  * @param  ITFlags Interrupt flags to handle.
  * @retval None
  */
static void I2C_ITAddrCplt(I2C_HandleTypeDef *hi2c, uint32_t ITFlags)
{
2400c9fc:	b580      	push	{r7, lr}
2400c9fe:	b084      	sub	sp, #16
2400ca00:	af00      	add	r7, sp, #0
2400ca02:	6078      	str	r0, [r7, #4]
2400ca04:	6039      	str	r1, [r7, #0]

  /* Prevent unused argument(s) compilation warning */
  UNUSED(ITFlags);

  /* In case of Listen state, need to inform upper layer of address match code event */
  if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
2400ca06:	687b      	ldr	r3, [r7, #4]
2400ca08:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400ca0c:	b2db      	uxtb	r3, r3
2400ca0e:	f003 0328 	and.w	r3, r3, #40	; 0x28
2400ca12:	2b28      	cmp	r3, #40	; 0x28
2400ca14:	d16a      	bne.n	2400caec <I2C_ITAddrCplt+0xf0>
  {
    transferdirection = I2C_GET_DIR(hi2c);
2400ca16:	687b      	ldr	r3, [r7, #4]
2400ca18:	681b      	ldr	r3, [r3, #0]
2400ca1a:	699b      	ldr	r3, [r3, #24]
2400ca1c:	0c1b      	lsrs	r3, r3, #16
2400ca1e:	b2db      	uxtb	r3, r3
2400ca20:	f003 0301 	and.w	r3, r3, #1
2400ca24:	73fb      	strb	r3, [r7, #15]
    slaveaddrcode     = I2C_GET_ADDR_MATCH(hi2c);
2400ca26:	687b      	ldr	r3, [r7, #4]
2400ca28:	681b      	ldr	r3, [r3, #0]
2400ca2a:	699b      	ldr	r3, [r3, #24]
2400ca2c:	0c1b      	lsrs	r3, r3, #16
2400ca2e:	b29b      	uxth	r3, r3
2400ca30:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
2400ca34:	81bb      	strh	r3, [r7, #12]
    ownadd1code       = I2C_GET_OWN_ADDRESS1(hi2c);
2400ca36:	687b      	ldr	r3, [r7, #4]
2400ca38:	681b      	ldr	r3, [r3, #0]
2400ca3a:	689b      	ldr	r3, [r3, #8]
2400ca3c:	b29b      	uxth	r3, r3
2400ca3e:	f3c3 0309 	ubfx	r3, r3, #0, #10
2400ca42:	817b      	strh	r3, [r7, #10]
    ownadd2code       = I2C_GET_OWN_ADDRESS2(hi2c);
2400ca44:	687b      	ldr	r3, [r7, #4]
2400ca46:	681b      	ldr	r3, [r3, #0]
2400ca48:	68db      	ldr	r3, [r3, #12]
2400ca4a:	b29b      	uxth	r3, r3
2400ca4c:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
2400ca50:	813b      	strh	r3, [r7, #8]

    /* If 10bits addressing mode is selected */
    if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
2400ca52:	687b      	ldr	r3, [r7, #4]
2400ca54:	68db      	ldr	r3, [r3, #12]
2400ca56:	2b02      	cmp	r3, #2
2400ca58:	d138      	bne.n	2400cacc <I2C_ITAddrCplt+0xd0>
    {
      if ((slaveaddrcode & SlaveAddr_MSK) == ((ownadd1code >> SlaveAddr_SHIFT) & SlaveAddr_MSK))
2400ca5a:	897b      	ldrh	r3, [r7, #10]
2400ca5c:	09db      	lsrs	r3, r3, #7
2400ca5e:	b29a      	uxth	r2, r3
2400ca60:	89bb      	ldrh	r3, [r7, #12]
2400ca62:	4053      	eors	r3, r2
2400ca64:	b29b      	uxth	r3, r3
2400ca66:	f003 0306 	and.w	r3, r3, #6
2400ca6a:	2b00      	cmp	r3, #0
2400ca6c:	d11c      	bne.n	2400caa8 <I2C_ITAddrCplt+0xac>
      {
        slaveaddrcode = ownadd1code;
2400ca6e:	897b      	ldrh	r3, [r7, #10]
2400ca70:	81bb      	strh	r3, [r7, #12]
        hi2c->AddrEventCount++;
2400ca72:	687b      	ldr	r3, [r7, #4]
2400ca74:	6c9b      	ldr	r3, [r3, #72]	; 0x48
2400ca76:	1c5a      	adds	r2, r3, #1
2400ca78:	687b      	ldr	r3, [r7, #4]
2400ca7a:	649a      	str	r2, [r3, #72]	; 0x48
        if (hi2c->AddrEventCount == 2U)
2400ca7c:	687b      	ldr	r3, [r7, #4]
2400ca7e:	6c9b      	ldr	r3, [r3, #72]	; 0x48
2400ca80:	2b02      	cmp	r3, #2
2400ca82:	d13b      	bne.n	2400cafc <I2C_ITAddrCplt+0x100>
        {
          /* Reset Address Event counter */
          hi2c->AddrEventCount = 0U;
2400ca84:	687b      	ldr	r3, [r7, #4]
2400ca86:	2200      	movs	r2, #0
2400ca88:	649a      	str	r2, [r3, #72]	; 0x48

          /* Clear ADDR flag */
          __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
2400ca8a:	687b      	ldr	r3, [r7, #4]
2400ca8c:	681b      	ldr	r3, [r3, #0]
2400ca8e:	2208      	movs	r2, #8
2400ca90:	61da      	str	r2, [r3, #28]

          /* Process Unlocked */
          __HAL_UNLOCK(hi2c);
2400ca92:	687b      	ldr	r3, [r7, #4]
2400ca94:	2200      	movs	r2, #0
2400ca96:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

          /* Call Slave Addr callback */
#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
          hi2c->AddrCallback(hi2c, transferdirection, slaveaddrcode);
#else
          HAL_I2C_AddrCallback(hi2c, transferdirection, slaveaddrcode);
2400ca9a:	89ba      	ldrh	r2, [r7, #12]
2400ca9c:	7bfb      	ldrb	r3, [r7, #15]
2400ca9e:	4619      	mov	r1, r3
2400caa0:	6878      	ldr	r0, [r7, #4]
2400caa2:	f7ff f99c 	bl	2400bdde <HAL_I2C_AddrCallback>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
  }
}
2400caa6:	e029      	b.n	2400cafc <I2C_ITAddrCplt+0x100>
        slaveaddrcode = ownadd2code;
2400caa8:	893b      	ldrh	r3, [r7, #8]
2400caaa:	81bb      	strh	r3, [r7, #12]
        I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT);
2400caac:	f44f 4100 	mov.w	r1, #32768	; 0x8000
2400cab0:	6878      	ldr	r0, [r7, #4]
2400cab2:	f001 f9d3 	bl	2400de5c <I2C_Disable_IRQ>
        __HAL_UNLOCK(hi2c);
2400cab6:	687b      	ldr	r3, [r7, #4]
2400cab8:	2200      	movs	r2, #0
2400caba:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
        HAL_I2C_AddrCallback(hi2c, transferdirection, slaveaddrcode);
2400cabe:	89ba      	ldrh	r2, [r7, #12]
2400cac0:	7bfb      	ldrb	r3, [r7, #15]
2400cac2:	4619      	mov	r1, r3
2400cac4:	6878      	ldr	r0, [r7, #4]
2400cac6:	f7ff f98a 	bl	2400bdde <HAL_I2C_AddrCallback>
}
2400caca:	e017      	b.n	2400cafc <I2C_ITAddrCplt+0x100>
      I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT);
2400cacc:	f44f 4100 	mov.w	r1, #32768	; 0x8000
2400cad0:	6878      	ldr	r0, [r7, #4]
2400cad2:	f001 f9c3 	bl	2400de5c <I2C_Disable_IRQ>
      __HAL_UNLOCK(hi2c);
2400cad6:	687b      	ldr	r3, [r7, #4]
2400cad8:	2200      	movs	r2, #0
2400cada:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      HAL_I2C_AddrCallback(hi2c, transferdirection, slaveaddrcode);
2400cade:	89ba      	ldrh	r2, [r7, #12]
2400cae0:	7bfb      	ldrb	r3, [r7, #15]
2400cae2:	4619      	mov	r1, r3
2400cae4:	6878      	ldr	r0, [r7, #4]
2400cae6:	f7ff f97a 	bl	2400bdde <HAL_I2C_AddrCallback>
}
2400caea:	e007      	b.n	2400cafc <I2C_ITAddrCplt+0x100>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
2400caec:	687b      	ldr	r3, [r7, #4]
2400caee:	681b      	ldr	r3, [r3, #0]
2400caf0:	2208      	movs	r2, #8
2400caf2:	61da      	str	r2, [r3, #28]
    __HAL_UNLOCK(hi2c);
2400caf4:	687b      	ldr	r3, [r7, #4]
2400caf6:	2200      	movs	r2, #0
2400caf8:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
}
2400cafc:	bf00      	nop
2400cafe:	3710      	adds	r7, #16
2400cb00:	46bd      	mov	sp, r7
2400cb02:	bd80      	pop	{r7, pc}

2400cb04 <I2C_ITMasterSeqCplt>:
  * @brief  I2C Master sequential complete process.
  * @param  hi2c I2C handle.
  * @retval None
  */
static void I2C_ITMasterSeqCplt(I2C_HandleTypeDef *hi2c)
{
2400cb04:	b580      	push	{r7, lr}
2400cb06:	b082      	sub	sp, #8
2400cb08:	af00      	add	r7, sp, #0
2400cb0a:	6078      	str	r0, [r7, #4]
  /* Reset I2C handle mode */
  hi2c->Mode = HAL_I2C_MODE_NONE;
2400cb0c:	687b      	ldr	r3, [r7, #4]
2400cb0e:	2200      	movs	r2, #0
2400cb10:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

  /* No Generate Stop, to permit restart mode */
  /* The stop will be done at the end of transfer, when I2C_AUTOEND_MODE enable */
  if (hi2c->State == HAL_I2C_STATE_BUSY_TX)
2400cb14:	687b      	ldr	r3, [r7, #4]
2400cb16:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400cb1a:	b2db      	uxtb	r3, r3
2400cb1c:	2b21      	cmp	r3, #33	; 0x21
2400cb1e:	d115      	bne.n	2400cb4c <I2C_ITMasterSeqCplt+0x48>
  {
    hi2c->State         = HAL_I2C_STATE_READY;
2400cb20:	687b      	ldr	r3, [r7, #4]
2400cb22:	2220      	movs	r2, #32
2400cb24:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_TX;
2400cb28:	687b      	ldr	r3, [r7, #4]
2400cb2a:	2211      	movs	r2, #17
2400cb2c:	631a      	str	r2, [r3, #48]	; 0x30
    hi2c->XferISR       = NULL;
2400cb2e:	687b      	ldr	r3, [r7, #4]
2400cb30:	2200      	movs	r2, #0
2400cb32:	635a      	str	r2, [r3, #52]	; 0x34

    /* Disable Interrupts */
    I2C_Disable_IRQ(hi2c, I2C_XFER_TX_IT);
2400cb34:	2101      	movs	r1, #1
2400cb36:	6878      	ldr	r0, [r7, #4]
2400cb38:	f001 f990 	bl	2400de5c <I2C_Disable_IRQ>

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2400cb3c:	687b      	ldr	r3, [r7, #4]
2400cb3e:	2200      	movs	r2, #0
2400cb40:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Call the corresponding callback to inform upper layer of End of Transfer */
#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
    hi2c->MasterTxCpltCallback(hi2c);
#else
    HAL_I2C_MasterTxCpltCallback(hi2c);
2400cb44:	6878      	ldr	r0, [r7, #4]
2400cb46:	f7ff f922 	bl	2400bd8e <HAL_I2C_MasterTxCpltCallback>
    hi2c->MasterRxCpltCallback(hi2c);
#else
    HAL_I2C_MasterRxCpltCallback(hi2c);
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
  }
}
2400cb4a:	e014      	b.n	2400cb76 <I2C_ITMasterSeqCplt+0x72>
    hi2c->State         = HAL_I2C_STATE_READY;
2400cb4c:	687b      	ldr	r3, [r7, #4]
2400cb4e:	2220      	movs	r2, #32
2400cb50:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
2400cb54:	687b      	ldr	r3, [r7, #4]
2400cb56:	2212      	movs	r2, #18
2400cb58:	631a      	str	r2, [r3, #48]	; 0x30
    hi2c->XferISR       = NULL;
2400cb5a:	687b      	ldr	r3, [r7, #4]
2400cb5c:	2200      	movs	r2, #0
2400cb5e:	635a      	str	r2, [r3, #52]	; 0x34
    I2C_Disable_IRQ(hi2c, I2C_XFER_RX_IT);
2400cb60:	2102      	movs	r1, #2
2400cb62:	6878      	ldr	r0, [r7, #4]
2400cb64:	f001 f97a 	bl	2400de5c <I2C_Disable_IRQ>
    __HAL_UNLOCK(hi2c);
2400cb68:	687b      	ldr	r3, [r7, #4]
2400cb6a:	2200      	movs	r2, #0
2400cb6c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
    HAL_I2C_MasterRxCpltCallback(hi2c);
2400cb70:	6878      	ldr	r0, [r7, #4]
2400cb72:	f7ff f916 	bl	2400bda2 <HAL_I2C_MasterRxCpltCallback>
}
2400cb76:	bf00      	nop
2400cb78:	3708      	adds	r7, #8
2400cb7a:	46bd      	mov	sp, r7
2400cb7c:	bd80      	pop	{r7, pc}

2400cb7e <I2C_ITSlaveSeqCplt>:
  * @brief  I2C Slave sequential complete process.
  * @param  hi2c I2C handle.
  * @retval None
  */
static void I2C_ITSlaveSeqCplt(I2C_HandleTypeDef *hi2c)
{
2400cb7e:	b580      	push	{r7, lr}
2400cb80:	b084      	sub	sp, #16
2400cb82:	af00      	add	r7, sp, #0
2400cb84:	6078      	str	r0, [r7, #4]
  uint32_t tmpcr1value = READ_REG(hi2c->Instance->CR1);
2400cb86:	687b      	ldr	r3, [r7, #4]
2400cb88:	681b      	ldr	r3, [r3, #0]
2400cb8a:	681b      	ldr	r3, [r3, #0]
2400cb8c:	60fb      	str	r3, [r7, #12]

  /* Reset I2C handle mode */
  hi2c->Mode = HAL_I2C_MODE_NONE;
2400cb8e:	687b      	ldr	r3, [r7, #4]
2400cb90:	2200      	movs	r2, #0
2400cb92:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

  /* If a DMA is ongoing, Update handle size context */
  if (I2C_CHECK_IT_SOURCE(tmpcr1value, I2C_CR1_TXDMAEN) != RESET)
2400cb96:	68fb      	ldr	r3, [r7, #12]
2400cb98:	0b9b      	lsrs	r3, r3, #14
2400cb9a:	f003 0301 	and.w	r3, r3, #1
2400cb9e:	2b00      	cmp	r3, #0
2400cba0:	d008      	beq.n	2400cbb4 <I2C_ITSlaveSeqCplt+0x36>
  {
    /* Disable DMA Request */
    hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
2400cba2:	687b      	ldr	r3, [r7, #4]
2400cba4:	681b      	ldr	r3, [r3, #0]
2400cba6:	681a      	ldr	r2, [r3, #0]
2400cba8:	687b      	ldr	r3, [r7, #4]
2400cbaa:	681b      	ldr	r3, [r3, #0]
2400cbac:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
2400cbb0:	601a      	str	r2, [r3, #0]
2400cbb2:	e00d      	b.n	2400cbd0 <I2C_ITSlaveSeqCplt+0x52>
  }
  else if (I2C_CHECK_IT_SOURCE(tmpcr1value, I2C_CR1_RXDMAEN) != RESET)
2400cbb4:	68fb      	ldr	r3, [r7, #12]
2400cbb6:	0bdb      	lsrs	r3, r3, #15
2400cbb8:	f003 0301 	and.w	r3, r3, #1
2400cbbc:	2b00      	cmp	r3, #0
2400cbbe:	d007      	beq.n	2400cbd0 <I2C_ITSlaveSeqCplt+0x52>
  {
    /* Disable DMA Request */
    hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
2400cbc0:	687b      	ldr	r3, [r7, #4]
2400cbc2:	681b      	ldr	r3, [r3, #0]
2400cbc4:	681a      	ldr	r2, [r3, #0]
2400cbc6:	687b      	ldr	r3, [r7, #4]
2400cbc8:	681b      	ldr	r3, [r3, #0]
2400cbca:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
2400cbce:	601a      	str	r2, [r3, #0]
  else
  {
    /* Do nothing */
  }

  if (hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN)
2400cbd0:	687b      	ldr	r3, [r7, #4]
2400cbd2:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400cbd6:	b2db      	uxtb	r3, r3
2400cbd8:	2b29      	cmp	r3, #41	; 0x29
2400cbda:	d112      	bne.n	2400cc02 <I2C_ITSlaveSeqCplt+0x84>
  {
    /* Remove HAL_I2C_STATE_SLAVE_BUSY_TX, keep only HAL_I2C_STATE_LISTEN */
    hi2c->State         = HAL_I2C_STATE_LISTEN;
2400cbdc:	687b      	ldr	r3, [r7, #4]
2400cbde:	2228      	movs	r2, #40	; 0x28
2400cbe0:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_TX;
2400cbe4:	687b      	ldr	r3, [r7, #4]
2400cbe6:	2221      	movs	r2, #33	; 0x21
2400cbe8:	631a      	str	r2, [r3, #48]	; 0x30

    /* Disable Interrupts */
    I2C_Disable_IRQ(hi2c, I2C_XFER_TX_IT);
2400cbea:	2101      	movs	r1, #1
2400cbec:	6878      	ldr	r0, [r7, #4]
2400cbee:	f001 f935 	bl	2400de5c <I2C_Disable_IRQ>

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2400cbf2:	687b      	ldr	r3, [r7, #4]
2400cbf4:	2200      	movs	r2, #0
2400cbf6:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Call the corresponding callback to inform upper layer of End of Transfer */
#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
    hi2c->SlaveTxCpltCallback(hi2c);
#else
    HAL_I2C_SlaveTxCpltCallback(hi2c);
2400cbfa:	6878      	ldr	r0, [r7, #4]
2400cbfc:	f7ff f8db 	bl	2400bdb6 <HAL_I2C_SlaveTxCpltCallback>
  }
  else
  {
    /* Nothing to do */
  }
}
2400cc00:	e017      	b.n	2400cc32 <I2C_ITSlaveSeqCplt+0xb4>
  else if (hi2c->State == HAL_I2C_STATE_BUSY_RX_LISTEN)
2400cc02:	687b      	ldr	r3, [r7, #4]
2400cc04:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400cc08:	b2db      	uxtb	r3, r3
2400cc0a:	2b2a      	cmp	r3, #42	; 0x2a
2400cc0c:	d111      	bne.n	2400cc32 <I2C_ITSlaveSeqCplt+0xb4>
    hi2c->State         = HAL_I2C_STATE_LISTEN;
2400cc0e:	687b      	ldr	r3, [r7, #4]
2400cc10:	2228      	movs	r2, #40	; 0x28
2400cc12:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_RX;
2400cc16:	687b      	ldr	r3, [r7, #4]
2400cc18:	2222      	movs	r2, #34	; 0x22
2400cc1a:	631a      	str	r2, [r3, #48]	; 0x30
    I2C_Disable_IRQ(hi2c, I2C_XFER_RX_IT);
2400cc1c:	2102      	movs	r1, #2
2400cc1e:	6878      	ldr	r0, [r7, #4]
2400cc20:	f001 f91c 	bl	2400de5c <I2C_Disable_IRQ>
    __HAL_UNLOCK(hi2c);
2400cc24:	687b      	ldr	r3, [r7, #4]
2400cc26:	2200      	movs	r2, #0
2400cc28:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
    HAL_I2C_SlaveRxCpltCallback(hi2c);
2400cc2c:	6878      	ldr	r0, [r7, #4]
2400cc2e:	f7ff f8cc 	bl	2400bdca <HAL_I2C_SlaveRxCpltCallback>
}
2400cc32:	bf00      	nop
2400cc34:	3710      	adds	r7, #16
2400cc36:	46bd      	mov	sp, r7
2400cc38:	bd80      	pop	{r7, pc}
	...

2400cc3c <I2C_ITMasterCplt>:
  * @param  hi2c I2C handle.
  * @param  ITFlags Interrupt flags to handle.
  * @retval None
  */
static void I2C_ITMasterCplt(I2C_HandleTypeDef *hi2c, uint32_t ITFlags)
{
2400cc3c:	b580      	push	{r7, lr}
2400cc3e:	b086      	sub	sp, #24
2400cc40:	af00      	add	r7, sp, #0
2400cc42:	6078      	str	r0, [r7, #4]
2400cc44:	6039      	str	r1, [r7, #0]
  uint32_t tmperror;
  uint32_t tmpITFlags = ITFlags;
2400cc46:	683b      	ldr	r3, [r7, #0]
2400cc48:	617b      	str	r3, [r7, #20]
  uint32_t tmp;

  /* Clear STOP Flag */
  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
2400cc4a:	687b      	ldr	r3, [r7, #4]
2400cc4c:	681b      	ldr	r3, [r3, #0]
2400cc4e:	2220      	movs	r2, #32
2400cc50:	61da      	str	r2, [r3, #28]

  /* Disable Interrupts and Store Previous state */
  if (hi2c->State == HAL_I2C_STATE_BUSY_TX)
2400cc52:	687b      	ldr	r3, [r7, #4]
2400cc54:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400cc58:	b2db      	uxtb	r3, r3
2400cc5a:	2b21      	cmp	r3, #33	; 0x21
2400cc5c:	d107      	bne.n	2400cc6e <I2C_ITMasterCplt+0x32>
  {
    I2C_Disable_IRQ(hi2c, I2C_XFER_TX_IT);
2400cc5e:	2101      	movs	r1, #1
2400cc60:	6878      	ldr	r0, [r7, #4]
2400cc62:	f001 f8fb 	bl	2400de5c <I2C_Disable_IRQ>
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_TX;
2400cc66:	687b      	ldr	r3, [r7, #4]
2400cc68:	2211      	movs	r2, #17
2400cc6a:	631a      	str	r2, [r3, #48]	; 0x30
2400cc6c:	e00c      	b.n	2400cc88 <I2C_ITMasterCplt+0x4c>
  }
  else if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
2400cc6e:	687b      	ldr	r3, [r7, #4]
2400cc70:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400cc74:	b2db      	uxtb	r3, r3
2400cc76:	2b22      	cmp	r3, #34	; 0x22
2400cc78:	d106      	bne.n	2400cc88 <I2C_ITMasterCplt+0x4c>
  {
    I2C_Disable_IRQ(hi2c, I2C_XFER_RX_IT);
2400cc7a:	2102      	movs	r1, #2
2400cc7c:	6878      	ldr	r0, [r7, #4]
2400cc7e:	f001 f8ed 	bl	2400de5c <I2C_Disable_IRQ>
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
2400cc82:	687b      	ldr	r3, [r7, #4]
2400cc84:	2212      	movs	r2, #18
2400cc86:	631a      	str	r2, [r3, #48]	; 0x30
  {
    /* Do nothing */
  }

  /* Clear Configuration Register 2 */
  I2C_RESET_CR2(hi2c);
2400cc88:	687b      	ldr	r3, [r7, #4]
2400cc8a:	681b      	ldr	r3, [r3, #0]
2400cc8c:	6859      	ldr	r1, [r3, #4]
2400cc8e:	687b      	ldr	r3, [r7, #4]
2400cc90:	681a      	ldr	r2, [r3, #0]
2400cc92:	4b4c      	ldr	r3, [pc, #304]	; (2400cdc4 <I2C_ITMasterCplt+0x188>)
2400cc94:	400b      	ands	r3, r1
2400cc96:	6053      	str	r3, [r2, #4]

  /* Reset handle parameters */
  hi2c->XferISR       = NULL;
2400cc98:	687b      	ldr	r3, [r7, #4]
2400cc9a:	2200      	movs	r2, #0
2400cc9c:	635a      	str	r2, [r3, #52]	; 0x34
  hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
2400cc9e:	687b      	ldr	r3, [r7, #4]
2400cca0:	4a49      	ldr	r2, [pc, #292]	; (2400cdc8 <I2C_ITMasterCplt+0x18c>)
2400cca2:	62da      	str	r2, [r3, #44]	; 0x2c

  if (I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_AF) != RESET)
2400cca4:	697b      	ldr	r3, [r7, #20]
2400cca6:	091b      	lsrs	r3, r3, #4
2400cca8:	f003 0301 	and.w	r3, r3, #1
2400ccac:	2b00      	cmp	r3, #0
2400ccae:	d009      	beq.n	2400ccc4 <I2C_ITMasterCplt+0x88>
  {
    /* Clear NACK Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
2400ccb0:	687b      	ldr	r3, [r7, #4]
2400ccb2:	681b      	ldr	r3, [r3, #0]
2400ccb4:	2210      	movs	r2, #16
2400ccb6:	61da      	str	r2, [r3, #28]

    /* Set acknowledge error code */
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
2400ccb8:	687b      	ldr	r3, [r7, #4]
2400ccba:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400ccbc:	f043 0204 	orr.w	r2, r3, #4
2400ccc0:	687b      	ldr	r3, [r7, #4]
2400ccc2:	645a      	str	r2, [r3, #68]	; 0x44
  }

  /* Fetch Last receive data if any */
  if ((hi2c->State == HAL_I2C_STATE_ABORT) && (I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET))
2400ccc4:	687b      	ldr	r3, [r7, #4]
2400ccc6:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400ccca:	b2db      	uxtb	r3, r3
2400cccc:	2b60      	cmp	r3, #96	; 0x60
2400ccce:	d10a      	bne.n	2400cce6 <I2C_ITMasterCplt+0xaa>
2400ccd0:	697b      	ldr	r3, [r7, #20]
2400ccd2:	089b      	lsrs	r3, r3, #2
2400ccd4:	f003 0301 	and.w	r3, r3, #1
2400ccd8:	2b00      	cmp	r3, #0
2400ccda:	d004      	beq.n	2400cce6 <I2C_ITMasterCplt+0xaa>
  {
    /* Read data from RXDR */
    tmp = (uint8_t)hi2c->Instance->RXDR;
2400ccdc:	687b      	ldr	r3, [r7, #4]
2400ccde:	681b      	ldr	r3, [r3, #0]
2400cce0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400cce2:	b2db      	uxtb	r3, r3
2400cce4:	613b      	str	r3, [r7, #16]

    UNUSED(tmp);
  }

  /* Flush TX register */
  I2C_Flush_TXDR(hi2c);
2400cce6:	6878      	ldr	r0, [r7, #4]
2400cce8:	f000 fbb5 	bl	2400d456 <I2C_Flush_TXDR>

  /* Store current volatile hi2c->ErrorCode, misra rule */
  tmperror = hi2c->ErrorCode;
2400ccec:	687b      	ldr	r3, [r7, #4]
2400ccee:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400ccf0:	60fb      	str	r3, [r7, #12]

  /* Call the corresponding callback to inform upper layer of End of Transfer */
  if ((hi2c->State == HAL_I2C_STATE_ABORT) || (tmperror != HAL_I2C_ERROR_NONE))
2400ccf2:	687b      	ldr	r3, [r7, #4]
2400ccf4:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400ccf8:	b2db      	uxtb	r3, r3
2400ccfa:	2b60      	cmp	r3, #96	; 0x60
2400ccfc:	d002      	beq.n	2400cd04 <I2C_ITMasterCplt+0xc8>
2400ccfe:	68fb      	ldr	r3, [r7, #12]
2400cd00:	2b00      	cmp	r3, #0
2400cd02:	d006      	beq.n	2400cd12 <I2C_ITMasterCplt+0xd6>
  {
    /* Call the corresponding callback to inform upper layer of End of Transfer */
    I2C_ITError(hi2c, hi2c->ErrorCode);
2400cd04:	687b      	ldr	r3, [r7, #4]
2400cd06:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400cd08:	4619      	mov	r1, r3
2400cd0a:	6878      	ldr	r0, [r7, #4]
2400cd0c:	f000 faac 	bl	2400d268 <I2C_ITError>
  }
  else
  {
    /* Nothing to do */
  }
}
2400cd10:	e054      	b.n	2400cdbc <I2C_ITMasterCplt+0x180>
  else if (hi2c->State == HAL_I2C_STATE_BUSY_TX)
2400cd12:	687b      	ldr	r3, [r7, #4]
2400cd14:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400cd18:	b2db      	uxtb	r3, r3
2400cd1a:	2b21      	cmp	r3, #33	; 0x21
2400cd1c:	d124      	bne.n	2400cd68 <I2C_ITMasterCplt+0x12c>
    hi2c->State = HAL_I2C_STATE_READY;
2400cd1e:	687b      	ldr	r3, [r7, #4]
2400cd20:	2220      	movs	r2, #32
2400cd22:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->PreviousState = I2C_STATE_NONE;
2400cd26:	687b      	ldr	r3, [r7, #4]
2400cd28:	2200      	movs	r2, #0
2400cd2a:	631a      	str	r2, [r3, #48]	; 0x30
    if (hi2c->Mode == HAL_I2C_MODE_MEM)
2400cd2c:	687b      	ldr	r3, [r7, #4]
2400cd2e:	f893 3042 	ldrb.w	r3, [r3, #66]	; 0x42
2400cd32:	b2db      	uxtb	r3, r3
2400cd34:	2b40      	cmp	r3, #64	; 0x40
2400cd36:	d10b      	bne.n	2400cd50 <I2C_ITMasterCplt+0x114>
      hi2c->Mode = HAL_I2C_MODE_NONE;
2400cd38:	687b      	ldr	r3, [r7, #4]
2400cd3a:	2200      	movs	r2, #0
2400cd3c:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
      __HAL_UNLOCK(hi2c);
2400cd40:	687b      	ldr	r3, [r7, #4]
2400cd42:	2200      	movs	r2, #0
2400cd44:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      HAL_I2C_MemTxCpltCallback(hi2c);
2400cd48:	6878      	ldr	r0, [r7, #4]
2400cd4a:	f7ff f860 	bl	2400be0e <HAL_I2C_MemTxCpltCallback>
}
2400cd4e:	e035      	b.n	2400cdbc <I2C_ITMasterCplt+0x180>
      hi2c->Mode = HAL_I2C_MODE_NONE;
2400cd50:	687b      	ldr	r3, [r7, #4]
2400cd52:	2200      	movs	r2, #0
2400cd54:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
      __HAL_UNLOCK(hi2c);
2400cd58:	687b      	ldr	r3, [r7, #4]
2400cd5a:	2200      	movs	r2, #0
2400cd5c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      HAL_I2C_MasterTxCpltCallback(hi2c);
2400cd60:	6878      	ldr	r0, [r7, #4]
2400cd62:	f7ff f814 	bl	2400bd8e <HAL_I2C_MasterTxCpltCallback>
}
2400cd66:	e029      	b.n	2400cdbc <I2C_ITMasterCplt+0x180>
  else if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
2400cd68:	687b      	ldr	r3, [r7, #4]
2400cd6a:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400cd6e:	b2db      	uxtb	r3, r3
2400cd70:	2b22      	cmp	r3, #34	; 0x22
2400cd72:	d123      	bne.n	2400cdbc <I2C_ITMasterCplt+0x180>
    hi2c->State = HAL_I2C_STATE_READY;
2400cd74:	687b      	ldr	r3, [r7, #4]
2400cd76:	2220      	movs	r2, #32
2400cd78:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->PreviousState = I2C_STATE_NONE;
2400cd7c:	687b      	ldr	r3, [r7, #4]
2400cd7e:	2200      	movs	r2, #0
2400cd80:	631a      	str	r2, [r3, #48]	; 0x30
    if (hi2c->Mode == HAL_I2C_MODE_MEM)
2400cd82:	687b      	ldr	r3, [r7, #4]
2400cd84:	f893 3042 	ldrb.w	r3, [r3, #66]	; 0x42
2400cd88:	b2db      	uxtb	r3, r3
2400cd8a:	2b40      	cmp	r3, #64	; 0x40
2400cd8c:	d10b      	bne.n	2400cda6 <I2C_ITMasterCplt+0x16a>
      hi2c->Mode = HAL_I2C_MODE_NONE;
2400cd8e:	687b      	ldr	r3, [r7, #4]
2400cd90:	2200      	movs	r2, #0
2400cd92:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
      __HAL_UNLOCK(hi2c);
2400cd96:	687b      	ldr	r3, [r7, #4]
2400cd98:	2200      	movs	r2, #0
2400cd9a:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      HAL_I2C_MemRxCpltCallback(hi2c);
2400cd9e:	6878      	ldr	r0, [r7, #4]
2400cda0:	f7ff f83f 	bl	2400be22 <HAL_I2C_MemRxCpltCallback>
}
2400cda4:	e00a      	b.n	2400cdbc <I2C_ITMasterCplt+0x180>
      hi2c->Mode = HAL_I2C_MODE_NONE;
2400cda6:	687b      	ldr	r3, [r7, #4]
2400cda8:	2200      	movs	r2, #0
2400cdaa:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
      __HAL_UNLOCK(hi2c);
2400cdae:	687b      	ldr	r3, [r7, #4]
2400cdb0:	2200      	movs	r2, #0
2400cdb2:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      HAL_I2C_MasterRxCpltCallback(hi2c);
2400cdb6:	6878      	ldr	r0, [r7, #4]
2400cdb8:	f7fe fff3 	bl	2400bda2 <HAL_I2C_MasterRxCpltCallback>
}
2400cdbc:	bf00      	nop
2400cdbe:	3718      	adds	r7, #24
2400cdc0:	46bd      	mov	sp, r7
2400cdc2:	bd80      	pop	{r7, pc}
2400cdc4:	fe00e800 	.word	0xfe00e800
2400cdc8:	ffff0000 	.word	0xffff0000

2400cdcc <I2C_ITSlaveCplt>:
  * @param  hi2c I2C handle.
  * @param  ITFlags Interrupt flags to handle.
  * @retval None
  */
static void I2C_ITSlaveCplt(I2C_HandleTypeDef *hi2c, uint32_t ITFlags)
{
2400cdcc:	b580      	push	{r7, lr}
2400cdce:	b086      	sub	sp, #24
2400cdd0:	af00      	add	r7, sp, #0
2400cdd2:	6078      	str	r0, [r7, #4]
2400cdd4:	6039      	str	r1, [r7, #0]
  uint32_t tmpcr1value = READ_REG(hi2c->Instance->CR1);
2400cdd6:	687b      	ldr	r3, [r7, #4]
2400cdd8:	681b      	ldr	r3, [r3, #0]
2400cdda:	681b      	ldr	r3, [r3, #0]
2400cddc:	613b      	str	r3, [r7, #16]
  uint32_t tmpITFlags = ITFlags;
2400cdde:	683b      	ldr	r3, [r7, #0]
2400cde0:	617b      	str	r3, [r7, #20]
  HAL_I2C_StateTypeDef tmpstate = hi2c->State;
2400cde2:	687b      	ldr	r3, [r7, #4]
2400cde4:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400cde8:	73fb      	strb	r3, [r7, #15]

  /* Clear STOP Flag */
  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
2400cdea:	687b      	ldr	r3, [r7, #4]
2400cdec:	681b      	ldr	r3, [r3, #0]
2400cdee:	2220      	movs	r2, #32
2400cdf0:	61da      	str	r2, [r3, #28]

  /* Disable Interrupts and Store Previous state */
  if ((tmpstate == HAL_I2C_STATE_BUSY_TX) || (tmpstate == HAL_I2C_STATE_BUSY_TX_LISTEN))
2400cdf2:	7bfb      	ldrb	r3, [r7, #15]
2400cdf4:	2b21      	cmp	r3, #33	; 0x21
2400cdf6:	d002      	beq.n	2400cdfe <I2C_ITSlaveCplt+0x32>
2400cdf8:	7bfb      	ldrb	r3, [r7, #15]
2400cdfa:	2b29      	cmp	r3, #41	; 0x29
2400cdfc:	d108      	bne.n	2400ce10 <I2C_ITSlaveCplt+0x44>
  {
    I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_TX_IT);
2400cdfe:	f248 0101 	movw	r1, #32769	; 0x8001
2400ce02:	6878      	ldr	r0, [r7, #4]
2400ce04:	f001 f82a 	bl	2400de5c <I2C_Disable_IRQ>
    hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_TX;
2400ce08:	687b      	ldr	r3, [r7, #4]
2400ce0a:	2221      	movs	r2, #33	; 0x21
2400ce0c:	631a      	str	r2, [r3, #48]	; 0x30
2400ce0e:	e00d      	b.n	2400ce2c <I2C_ITSlaveCplt+0x60>
  }
  else if ((tmpstate == HAL_I2C_STATE_BUSY_RX) || (tmpstate == HAL_I2C_STATE_BUSY_RX_LISTEN))
2400ce10:	7bfb      	ldrb	r3, [r7, #15]
2400ce12:	2b22      	cmp	r3, #34	; 0x22
2400ce14:	d002      	beq.n	2400ce1c <I2C_ITSlaveCplt+0x50>
2400ce16:	7bfb      	ldrb	r3, [r7, #15]
2400ce18:	2b2a      	cmp	r3, #42	; 0x2a
2400ce1a:	d107      	bne.n	2400ce2c <I2C_ITSlaveCplt+0x60>
  {
    I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_RX_IT);
2400ce1c:	f248 0102 	movw	r1, #32770	; 0x8002
2400ce20:	6878      	ldr	r0, [r7, #4]
2400ce22:	f001 f81b 	bl	2400de5c <I2C_Disable_IRQ>
    hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_RX;
2400ce26:	687b      	ldr	r3, [r7, #4]
2400ce28:	2222      	movs	r2, #34	; 0x22
2400ce2a:	631a      	str	r2, [r3, #48]	; 0x30
  {
    /* Do nothing */
  }

  /* Disable Address Acknowledge */
  hi2c->Instance->CR2 |= I2C_CR2_NACK;
2400ce2c:	687b      	ldr	r3, [r7, #4]
2400ce2e:	681b      	ldr	r3, [r3, #0]
2400ce30:	685a      	ldr	r2, [r3, #4]
2400ce32:	687b      	ldr	r3, [r7, #4]
2400ce34:	681b      	ldr	r3, [r3, #0]
2400ce36:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
2400ce3a:	605a      	str	r2, [r3, #4]

  /* Clear Configuration Register 2 */
  I2C_RESET_CR2(hi2c);
2400ce3c:	687b      	ldr	r3, [r7, #4]
2400ce3e:	681b      	ldr	r3, [r3, #0]
2400ce40:	6859      	ldr	r1, [r3, #4]
2400ce42:	687b      	ldr	r3, [r7, #4]
2400ce44:	681a      	ldr	r2, [r3, #0]
2400ce46:	4b80      	ldr	r3, [pc, #512]	; (2400d048 <I2C_ITSlaveCplt+0x27c>)
2400ce48:	400b      	ands	r3, r1
2400ce4a:	6053      	str	r3, [r2, #4]

  /* Flush TX register */
  I2C_Flush_TXDR(hi2c);
2400ce4c:	6878      	ldr	r0, [r7, #4]
2400ce4e:	f000 fb02 	bl	2400d456 <I2C_Flush_TXDR>

  /* If a DMA is ongoing, Update handle size context */
  if (I2C_CHECK_IT_SOURCE(tmpcr1value, I2C_CR1_TXDMAEN) != RESET)
2400ce52:	693b      	ldr	r3, [r7, #16]
2400ce54:	0b9b      	lsrs	r3, r3, #14
2400ce56:	f003 0301 	and.w	r3, r3, #1
2400ce5a:	2b00      	cmp	r3, #0
2400ce5c:	d07a      	beq.n	2400cf54 <I2C_ITSlaveCplt+0x188>
  {
    /* Disable DMA Request */
    hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
2400ce5e:	687b      	ldr	r3, [r7, #4]
2400ce60:	681b      	ldr	r3, [r3, #0]
2400ce62:	681a      	ldr	r2, [r3, #0]
2400ce64:	687b      	ldr	r3, [r7, #4]
2400ce66:	681b      	ldr	r3, [r3, #0]
2400ce68:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
2400ce6c:	601a      	str	r2, [r3, #0]

    if (hi2c->hdmatx != NULL)
2400ce6e:	687b      	ldr	r3, [r7, #4]
2400ce70:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400ce72:	2b00      	cmp	r3, #0
2400ce74:	f000 8111 	beq.w	2400d09a <I2C_ITSlaveCplt+0x2ce>
    {
      hi2c->XferCount = (uint16_t)__HAL_DMA_GET_COUNTER(hi2c->hdmatx);
2400ce78:	687b      	ldr	r3, [r7, #4]
2400ce7a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400ce7c:	681b      	ldr	r3, [r3, #0]
2400ce7e:	4a73      	ldr	r2, [pc, #460]	; (2400d04c <I2C_ITSlaveCplt+0x280>)
2400ce80:	4293      	cmp	r3, r2
2400ce82:	d059      	beq.n	2400cf38 <I2C_ITSlaveCplt+0x16c>
2400ce84:	687b      	ldr	r3, [r7, #4]
2400ce86:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400ce88:	681b      	ldr	r3, [r3, #0]
2400ce8a:	4a71      	ldr	r2, [pc, #452]	; (2400d050 <I2C_ITSlaveCplt+0x284>)
2400ce8c:	4293      	cmp	r3, r2
2400ce8e:	d053      	beq.n	2400cf38 <I2C_ITSlaveCplt+0x16c>
2400ce90:	687b      	ldr	r3, [r7, #4]
2400ce92:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400ce94:	681b      	ldr	r3, [r3, #0]
2400ce96:	4a6f      	ldr	r2, [pc, #444]	; (2400d054 <I2C_ITSlaveCplt+0x288>)
2400ce98:	4293      	cmp	r3, r2
2400ce9a:	d04d      	beq.n	2400cf38 <I2C_ITSlaveCplt+0x16c>
2400ce9c:	687b      	ldr	r3, [r7, #4]
2400ce9e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400cea0:	681b      	ldr	r3, [r3, #0]
2400cea2:	4a6d      	ldr	r2, [pc, #436]	; (2400d058 <I2C_ITSlaveCplt+0x28c>)
2400cea4:	4293      	cmp	r3, r2
2400cea6:	d047      	beq.n	2400cf38 <I2C_ITSlaveCplt+0x16c>
2400cea8:	687b      	ldr	r3, [r7, #4]
2400ceaa:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400ceac:	681b      	ldr	r3, [r3, #0]
2400ceae:	4a6b      	ldr	r2, [pc, #428]	; (2400d05c <I2C_ITSlaveCplt+0x290>)
2400ceb0:	4293      	cmp	r3, r2
2400ceb2:	d041      	beq.n	2400cf38 <I2C_ITSlaveCplt+0x16c>
2400ceb4:	687b      	ldr	r3, [r7, #4]
2400ceb6:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400ceb8:	681b      	ldr	r3, [r3, #0]
2400ceba:	4a69      	ldr	r2, [pc, #420]	; (2400d060 <I2C_ITSlaveCplt+0x294>)
2400cebc:	4293      	cmp	r3, r2
2400cebe:	d03b      	beq.n	2400cf38 <I2C_ITSlaveCplt+0x16c>
2400cec0:	687b      	ldr	r3, [r7, #4]
2400cec2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400cec4:	681b      	ldr	r3, [r3, #0]
2400cec6:	4a67      	ldr	r2, [pc, #412]	; (2400d064 <I2C_ITSlaveCplt+0x298>)
2400cec8:	4293      	cmp	r3, r2
2400ceca:	d035      	beq.n	2400cf38 <I2C_ITSlaveCplt+0x16c>
2400cecc:	687b      	ldr	r3, [r7, #4]
2400cece:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400ced0:	681b      	ldr	r3, [r3, #0]
2400ced2:	4a65      	ldr	r2, [pc, #404]	; (2400d068 <I2C_ITSlaveCplt+0x29c>)
2400ced4:	4293      	cmp	r3, r2
2400ced6:	d02f      	beq.n	2400cf38 <I2C_ITSlaveCplt+0x16c>
2400ced8:	687b      	ldr	r3, [r7, #4]
2400ceda:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400cedc:	681b      	ldr	r3, [r3, #0]
2400cede:	4a63      	ldr	r2, [pc, #396]	; (2400d06c <I2C_ITSlaveCplt+0x2a0>)
2400cee0:	4293      	cmp	r3, r2
2400cee2:	d029      	beq.n	2400cf38 <I2C_ITSlaveCplt+0x16c>
2400cee4:	687b      	ldr	r3, [r7, #4]
2400cee6:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400cee8:	681b      	ldr	r3, [r3, #0]
2400ceea:	4a61      	ldr	r2, [pc, #388]	; (2400d070 <I2C_ITSlaveCplt+0x2a4>)
2400ceec:	4293      	cmp	r3, r2
2400ceee:	d023      	beq.n	2400cf38 <I2C_ITSlaveCplt+0x16c>
2400cef0:	687b      	ldr	r3, [r7, #4]
2400cef2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400cef4:	681b      	ldr	r3, [r3, #0]
2400cef6:	4a5f      	ldr	r2, [pc, #380]	; (2400d074 <I2C_ITSlaveCplt+0x2a8>)
2400cef8:	4293      	cmp	r3, r2
2400cefa:	d01d      	beq.n	2400cf38 <I2C_ITSlaveCplt+0x16c>
2400cefc:	687b      	ldr	r3, [r7, #4]
2400cefe:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400cf00:	681b      	ldr	r3, [r3, #0]
2400cf02:	4a5d      	ldr	r2, [pc, #372]	; (2400d078 <I2C_ITSlaveCplt+0x2ac>)
2400cf04:	4293      	cmp	r3, r2
2400cf06:	d017      	beq.n	2400cf38 <I2C_ITSlaveCplt+0x16c>
2400cf08:	687b      	ldr	r3, [r7, #4]
2400cf0a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400cf0c:	681b      	ldr	r3, [r3, #0]
2400cf0e:	4a5b      	ldr	r2, [pc, #364]	; (2400d07c <I2C_ITSlaveCplt+0x2b0>)
2400cf10:	4293      	cmp	r3, r2
2400cf12:	d011      	beq.n	2400cf38 <I2C_ITSlaveCplt+0x16c>
2400cf14:	687b      	ldr	r3, [r7, #4]
2400cf16:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400cf18:	681b      	ldr	r3, [r3, #0]
2400cf1a:	4a59      	ldr	r2, [pc, #356]	; (2400d080 <I2C_ITSlaveCplt+0x2b4>)
2400cf1c:	4293      	cmp	r3, r2
2400cf1e:	d00b      	beq.n	2400cf38 <I2C_ITSlaveCplt+0x16c>
2400cf20:	687b      	ldr	r3, [r7, #4]
2400cf22:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400cf24:	681b      	ldr	r3, [r3, #0]
2400cf26:	4a57      	ldr	r2, [pc, #348]	; (2400d084 <I2C_ITSlaveCplt+0x2b8>)
2400cf28:	4293      	cmp	r3, r2
2400cf2a:	d005      	beq.n	2400cf38 <I2C_ITSlaveCplt+0x16c>
2400cf2c:	687b      	ldr	r3, [r7, #4]
2400cf2e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400cf30:	681b      	ldr	r3, [r3, #0]
2400cf32:	4a55      	ldr	r2, [pc, #340]	; (2400d088 <I2C_ITSlaveCplt+0x2bc>)
2400cf34:	4293      	cmp	r3, r2
2400cf36:	d105      	bne.n	2400cf44 <I2C_ITSlaveCplt+0x178>
2400cf38:	687b      	ldr	r3, [r7, #4]
2400cf3a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400cf3c:	681b      	ldr	r3, [r3, #0]
2400cf3e:	685b      	ldr	r3, [r3, #4]
2400cf40:	b29b      	uxth	r3, r3
2400cf42:	e004      	b.n	2400cf4e <I2C_ITSlaveCplt+0x182>
2400cf44:	687b      	ldr	r3, [r7, #4]
2400cf46:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400cf48:	681b      	ldr	r3, [r3, #0]
2400cf4a:	685b      	ldr	r3, [r3, #4]
2400cf4c:	b29b      	uxth	r3, r3
2400cf4e:	687a      	ldr	r2, [r7, #4]
2400cf50:	8553      	strh	r3, [r2, #42]	; 0x2a
2400cf52:	e0a2      	b.n	2400d09a <I2C_ITSlaveCplt+0x2ce>
    }
  }
  else if (I2C_CHECK_IT_SOURCE(tmpcr1value, I2C_CR1_RXDMAEN) != RESET)
2400cf54:	693b      	ldr	r3, [r7, #16]
2400cf56:	0bdb      	lsrs	r3, r3, #15
2400cf58:	f003 0301 	and.w	r3, r3, #1
2400cf5c:	2b00      	cmp	r3, #0
2400cf5e:	f000 809c 	beq.w	2400d09a <I2C_ITSlaveCplt+0x2ce>
  {
    /* Disable DMA Request */
    hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
2400cf62:	687b      	ldr	r3, [r7, #4]
2400cf64:	681b      	ldr	r3, [r3, #0]
2400cf66:	681a      	ldr	r2, [r3, #0]
2400cf68:	687b      	ldr	r3, [r7, #4]
2400cf6a:	681b      	ldr	r3, [r3, #0]
2400cf6c:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
2400cf70:	601a      	str	r2, [r3, #0]

    if (hi2c->hdmarx != NULL)
2400cf72:	687b      	ldr	r3, [r7, #4]
2400cf74:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400cf76:	2b00      	cmp	r3, #0
2400cf78:	f000 808f 	beq.w	2400d09a <I2C_ITSlaveCplt+0x2ce>
    {
      hi2c->XferCount = (uint16_t)__HAL_DMA_GET_COUNTER(hi2c->hdmarx);
2400cf7c:	687b      	ldr	r3, [r7, #4]
2400cf7e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400cf80:	681b      	ldr	r3, [r3, #0]
2400cf82:	4a32      	ldr	r2, [pc, #200]	; (2400d04c <I2C_ITSlaveCplt+0x280>)
2400cf84:	4293      	cmp	r3, r2
2400cf86:	d059      	beq.n	2400d03c <I2C_ITSlaveCplt+0x270>
2400cf88:	687b      	ldr	r3, [r7, #4]
2400cf8a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400cf8c:	681b      	ldr	r3, [r3, #0]
2400cf8e:	4a30      	ldr	r2, [pc, #192]	; (2400d050 <I2C_ITSlaveCplt+0x284>)
2400cf90:	4293      	cmp	r3, r2
2400cf92:	d053      	beq.n	2400d03c <I2C_ITSlaveCplt+0x270>
2400cf94:	687b      	ldr	r3, [r7, #4]
2400cf96:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400cf98:	681b      	ldr	r3, [r3, #0]
2400cf9a:	4a2e      	ldr	r2, [pc, #184]	; (2400d054 <I2C_ITSlaveCplt+0x288>)
2400cf9c:	4293      	cmp	r3, r2
2400cf9e:	d04d      	beq.n	2400d03c <I2C_ITSlaveCplt+0x270>
2400cfa0:	687b      	ldr	r3, [r7, #4]
2400cfa2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400cfa4:	681b      	ldr	r3, [r3, #0]
2400cfa6:	4a2c      	ldr	r2, [pc, #176]	; (2400d058 <I2C_ITSlaveCplt+0x28c>)
2400cfa8:	4293      	cmp	r3, r2
2400cfaa:	d047      	beq.n	2400d03c <I2C_ITSlaveCplt+0x270>
2400cfac:	687b      	ldr	r3, [r7, #4]
2400cfae:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400cfb0:	681b      	ldr	r3, [r3, #0]
2400cfb2:	4a2a      	ldr	r2, [pc, #168]	; (2400d05c <I2C_ITSlaveCplt+0x290>)
2400cfb4:	4293      	cmp	r3, r2
2400cfb6:	d041      	beq.n	2400d03c <I2C_ITSlaveCplt+0x270>
2400cfb8:	687b      	ldr	r3, [r7, #4]
2400cfba:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400cfbc:	681b      	ldr	r3, [r3, #0]
2400cfbe:	4a28      	ldr	r2, [pc, #160]	; (2400d060 <I2C_ITSlaveCplt+0x294>)
2400cfc0:	4293      	cmp	r3, r2
2400cfc2:	d03b      	beq.n	2400d03c <I2C_ITSlaveCplt+0x270>
2400cfc4:	687b      	ldr	r3, [r7, #4]
2400cfc6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400cfc8:	681b      	ldr	r3, [r3, #0]
2400cfca:	4a26      	ldr	r2, [pc, #152]	; (2400d064 <I2C_ITSlaveCplt+0x298>)
2400cfcc:	4293      	cmp	r3, r2
2400cfce:	d035      	beq.n	2400d03c <I2C_ITSlaveCplt+0x270>
2400cfd0:	687b      	ldr	r3, [r7, #4]
2400cfd2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400cfd4:	681b      	ldr	r3, [r3, #0]
2400cfd6:	4a24      	ldr	r2, [pc, #144]	; (2400d068 <I2C_ITSlaveCplt+0x29c>)
2400cfd8:	4293      	cmp	r3, r2
2400cfda:	d02f      	beq.n	2400d03c <I2C_ITSlaveCplt+0x270>
2400cfdc:	687b      	ldr	r3, [r7, #4]
2400cfde:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400cfe0:	681b      	ldr	r3, [r3, #0]
2400cfe2:	4a22      	ldr	r2, [pc, #136]	; (2400d06c <I2C_ITSlaveCplt+0x2a0>)
2400cfe4:	4293      	cmp	r3, r2
2400cfe6:	d029      	beq.n	2400d03c <I2C_ITSlaveCplt+0x270>
2400cfe8:	687b      	ldr	r3, [r7, #4]
2400cfea:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400cfec:	681b      	ldr	r3, [r3, #0]
2400cfee:	4a20      	ldr	r2, [pc, #128]	; (2400d070 <I2C_ITSlaveCplt+0x2a4>)
2400cff0:	4293      	cmp	r3, r2
2400cff2:	d023      	beq.n	2400d03c <I2C_ITSlaveCplt+0x270>
2400cff4:	687b      	ldr	r3, [r7, #4]
2400cff6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400cff8:	681b      	ldr	r3, [r3, #0]
2400cffa:	4a1e      	ldr	r2, [pc, #120]	; (2400d074 <I2C_ITSlaveCplt+0x2a8>)
2400cffc:	4293      	cmp	r3, r2
2400cffe:	d01d      	beq.n	2400d03c <I2C_ITSlaveCplt+0x270>
2400d000:	687b      	ldr	r3, [r7, #4]
2400d002:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d004:	681b      	ldr	r3, [r3, #0]
2400d006:	4a1c      	ldr	r2, [pc, #112]	; (2400d078 <I2C_ITSlaveCplt+0x2ac>)
2400d008:	4293      	cmp	r3, r2
2400d00a:	d017      	beq.n	2400d03c <I2C_ITSlaveCplt+0x270>
2400d00c:	687b      	ldr	r3, [r7, #4]
2400d00e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d010:	681b      	ldr	r3, [r3, #0]
2400d012:	4a1a      	ldr	r2, [pc, #104]	; (2400d07c <I2C_ITSlaveCplt+0x2b0>)
2400d014:	4293      	cmp	r3, r2
2400d016:	d011      	beq.n	2400d03c <I2C_ITSlaveCplt+0x270>
2400d018:	687b      	ldr	r3, [r7, #4]
2400d01a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d01c:	681b      	ldr	r3, [r3, #0]
2400d01e:	4a18      	ldr	r2, [pc, #96]	; (2400d080 <I2C_ITSlaveCplt+0x2b4>)
2400d020:	4293      	cmp	r3, r2
2400d022:	d00b      	beq.n	2400d03c <I2C_ITSlaveCplt+0x270>
2400d024:	687b      	ldr	r3, [r7, #4]
2400d026:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d028:	681b      	ldr	r3, [r3, #0]
2400d02a:	4a16      	ldr	r2, [pc, #88]	; (2400d084 <I2C_ITSlaveCplt+0x2b8>)
2400d02c:	4293      	cmp	r3, r2
2400d02e:	d005      	beq.n	2400d03c <I2C_ITSlaveCplt+0x270>
2400d030:	687b      	ldr	r3, [r7, #4]
2400d032:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d034:	681b      	ldr	r3, [r3, #0]
2400d036:	4a14      	ldr	r2, [pc, #80]	; (2400d088 <I2C_ITSlaveCplt+0x2bc>)
2400d038:	4293      	cmp	r3, r2
2400d03a:	d127      	bne.n	2400d08c <I2C_ITSlaveCplt+0x2c0>
2400d03c:	687b      	ldr	r3, [r7, #4]
2400d03e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d040:	681b      	ldr	r3, [r3, #0]
2400d042:	685b      	ldr	r3, [r3, #4]
2400d044:	b29b      	uxth	r3, r3
2400d046:	e026      	b.n	2400d096 <I2C_ITSlaveCplt+0x2ca>
2400d048:	fe00e800 	.word	0xfe00e800
2400d04c:	40020010 	.word	0x40020010
2400d050:	40020028 	.word	0x40020028
2400d054:	40020040 	.word	0x40020040
2400d058:	40020058 	.word	0x40020058
2400d05c:	40020070 	.word	0x40020070
2400d060:	40020088 	.word	0x40020088
2400d064:	400200a0 	.word	0x400200a0
2400d068:	400200b8 	.word	0x400200b8
2400d06c:	40020410 	.word	0x40020410
2400d070:	40020428 	.word	0x40020428
2400d074:	40020440 	.word	0x40020440
2400d078:	40020458 	.word	0x40020458
2400d07c:	40020470 	.word	0x40020470
2400d080:	40020488 	.word	0x40020488
2400d084:	400204a0 	.word	0x400204a0
2400d088:	400204b8 	.word	0x400204b8
2400d08c:	687b      	ldr	r3, [r7, #4]
2400d08e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d090:	681b      	ldr	r3, [r3, #0]
2400d092:	685b      	ldr	r3, [r3, #4]
2400d094:	b29b      	uxth	r3, r3
2400d096:	687a      	ldr	r2, [r7, #4]
2400d098:	8553      	strh	r3, [r2, #42]	; 0x2a
  {
    /* Do nothing */
  }

  /* Store Last receive data if any */
  if (I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET)
2400d09a:	697b      	ldr	r3, [r7, #20]
2400d09c:	089b      	lsrs	r3, r3, #2
2400d09e:	f003 0301 	and.w	r3, r3, #1
2400d0a2:	2b00      	cmp	r3, #0
2400d0a4:	d020      	beq.n	2400d0e8 <I2C_ITSlaveCplt+0x31c>
  {
    /* Remove RXNE flag on temporary variable as read done */
    tmpITFlags &= ~I2C_FLAG_RXNE;
2400d0a6:	697b      	ldr	r3, [r7, #20]
2400d0a8:	f023 0304 	bic.w	r3, r3, #4
2400d0ac:	617b      	str	r3, [r7, #20]

    /* Read data from RXDR */
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
2400d0ae:	687b      	ldr	r3, [r7, #4]
2400d0b0:	681b      	ldr	r3, [r3, #0]
2400d0b2:	6a5a      	ldr	r2, [r3, #36]	; 0x24
2400d0b4:	687b      	ldr	r3, [r7, #4]
2400d0b6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400d0b8:	b2d2      	uxtb	r2, r2
2400d0ba:	701a      	strb	r2, [r3, #0]

    /* Increment Buffer pointer */
    hi2c->pBuffPtr++;
2400d0bc:	687b      	ldr	r3, [r7, #4]
2400d0be:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400d0c0:	1c5a      	adds	r2, r3, #1
2400d0c2:	687b      	ldr	r3, [r7, #4]
2400d0c4:	625a      	str	r2, [r3, #36]	; 0x24

    if ((hi2c->XferSize > 0U))
2400d0c6:	687b      	ldr	r3, [r7, #4]
2400d0c8:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400d0ca:	2b00      	cmp	r3, #0
2400d0cc:	d00c      	beq.n	2400d0e8 <I2C_ITSlaveCplt+0x31c>
    {
      hi2c->XferSize--;
2400d0ce:	687b      	ldr	r3, [r7, #4]
2400d0d0:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400d0d2:	3b01      	subs	r3, #1
2400d0d4:	b29a      	uxth	r2, r3
2400d0d6:	687b      	ldr	r3, [r7, #4]
2400d0d8:	851a      	strh	r2, [r3, #40]	; 0x28
      hi2c->XferCount--;
2400d0da:	687b      	ldr	r3, [r7, #4]
2400d0dc:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400d0de:	b29b      	uxth	r3, r3
2400d0e0:	3b01      	subs	r3, #1
2400d0e2:	b29a      	uxth	r2, r3
2400d0e4:	687b      	ldr	r3, [r7, #4]
2400d0e6:	855a      	strh	r2, [r3, #42]	; 0x2a
    }
  }

  /* All data are not transferred, so set error code accordingly */
  if (hi2c->XferCount != 0U)
2400d0e8:	687b      	ldr	r3, [r7, #4]
2400d0ea:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400d0ec:	b29b      	uxth	r3, r3
2400d0ee:	2b00      	cmp	r3, #0
2400d0f0:	d005      	beq.n	2400d0fe <I2C_ITSlaveCplt+0x332>
  {
    /* Set ErrorCode corresponding to a Non-Acknowledge */
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
2400d0f2:	687b      	ldr	r3, [r7, #4]
2400d0f4:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400d0f6:	f043 0204 	orr.w	r2, r3, #4
2400d0fa:	687b      	ldr	r3, [r7, #4]
2400d0fc:	645a      	str	r2, [r3, #68]	; 0x44
  }

  hi2c->Mode = HAL_I2C_MODE_NONE;
2400d0fe:	687b      	ldr	r3, [r7, #4]
2400d100:	2200      	movs	r2, #0
2400d102:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
  hi2c->XferISR = NULL;
2400d106:	687b      	ldr	r3, [r7, #4]
2400d108:	2200      	movs	r2, #0
2400d10a:	635a      	str	r2, [r3, #52]	; 0x34

  if (hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
2400d10c:	687b      	ldr	r3, [r7, #4]
2400d10e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400d110:	2b00      	cmp	r3, #0
2400d112:	d010      	beq.n	2400d136 <I2C_ITSlaveCplt+0x36a>
  {
    /* Call the corresponding callback to inform upper layer of End of Transfer */
    I2C_ITError(hi2c, hi2c->ErrorCode);
2400d114:	687b      	ldr	r3, [r7, #4]
2400d116:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400d118:	4619      	mov	r1, r3
2400d11a:	6878      	ldr	r0, [r7, #4]
2400d11c:	f000 f8a4 	bl	2400d268 <I2C_ITError>

    /* Call the Listen Complete callback, to inform upper layer of the end of Listen usecase */
    if (hi2c->State == HAL_I2C_STATE_LISTEN)
2400d120:	687b      	ldr	r3, [r7, #4]
2400d122:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400d126:	b2db      	uxtb	r3, r3
2400d128:	2b28      	cmp	r3, #40	; 0x28
2400d12a:	d141      	bne.n	2400d1b0 <I2C_ITSlaveCplt+0x3e4>
    {
      /* Call I2C Listen complete process */
      I2C_ITListenCplt(hi2c, tmpITFlags);
2400d12c:	6979      	ldr	r1, [r7, #20]
2400d12e:	6878      	ldr	r0, [r7, #4]
2400d130:	f000 f844 	bl	2400d1bc <I2C_ITListenCplt>
    hi2c->SlaveTxCpltCallback(hi2c);
#else
    HAL_I2C_SlaveTxCpltCallback(hi2c);
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
  }
}
2400d134:	e03c      	b.n	2400d1b0 <I2C_ITSlaveCplt+0x3e4>
  else if (hi2c->XferOptions != I2C_NO_OPTION_FRAME)
2400d136:	687b      	ldr	r3, [r7, #4]
2400d138:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2400d13a:	f513 3f80 	cmn.w	r3, #65536	; 0x10000
2400d13e:	d014      	beq.n	2400d16a <I2C_ITSlaveCplt+0x39e>
    I2C_ITSlaveSeqCplt(hi2c);
2400d140:	6878      	ldr	r0, [r7, #4]
2400d142:	f7ff fd1c 	bl	2400cb7e <I2C_ITSlaveSeqCplt>
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
2400d146:	687b      	ldr	r3, [r7, #4]
2400d148:	4a1b      	ldr	r2, [pc, #108]	; (2400d1b8 <I2C_ITSlaveCplt+0x3ec>)
2400d14a:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->State = HAL_I2C_STATE_READY;
2400d14c:	687b      	ldr	r3, [r7, #4]
2400d14e:	2220      	movs	r2, #32
2400d150:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->PreviousState = I2C_STATE_NONE;
2400d154:	687b      	ldr	r3, [r7, #4]
2400d156:	2200      	movs	r2, #0
2400d158:	631a      	str	r2, [r3, #48]	; 0x30
    __HAL_UNLOCK(hi2c);
2400d15a:	687b      	ldr	r3, [r7, #4]
2400d15c:	2200      	movs	r2, #0
2400d15e:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
    HAL_I2C_ListenCpltCallback(hi2c);
2400d162:	6878      	ldr	r0, [r7, #4]
2400d164:	f7fe fe49 	bl	2400bdfa <HAL_I2C_ListenCpltCallback>
}
2400d168:	e022      	b.n	2400d1b0 <I2C_ITSlaveCplt+0x3e4>
  else if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
2400d16a:	687b      	ldr	r3, [r7, #4]
2400d16c:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400d170:	b2db      	uxtb	r3, r3
2400d172:	2b22      	cmp	r3, #34	; 0x22
2400d174:	d10e      	bne.n	2400d194 <I2C_ITSlaveCplt+0x3c8>
    hi2c->State = HAL_I2C_STATE_READY;
2400d176:	687b      	ldr	r3, [r7, #4]
2400d178:	2220      	movs	r2, #32
2400d17a:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->PreviousState = I2C_STATE_NONE;
2400d17e:	687b      	ldr	r3, [r7, #4]
2400d180:	2200      	movs	r2, #0
2400d182:	631a      	str	r2, [r3, #48]	; 0x30
    __HAL_UNLOCK(hi2c);
2400d184:	687b      	ldr	r3, [r7, #4]
2400d186:	2200      	movs	r2, #0
2400d188:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
    HAL_I2C_SlaveRxCpltCallback(hi2c);
2400d18c:	6878      	ldr	r0, [r7, #4]
2400d18e:	f7fe fe1c 	bl	2400bdca <HAL_I2C_SlaveRxCpltCallback>
}
2400d192:	e00d      	b.n	2400d1b0 <I2C_ITSlaveCplt+0x3e4>
    hi2c->State = HAL_I2C_STATE_READY;
2400d194:	687b      	ldr	r3, [r7, #4]
2400d196:	2220      	movs	r2, #32
2400d198:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->PreviousState = I2C_STATE_NONE;
2400d19c:	687b      	ldr	r3, [r7, #4]
2400d19e:	2200      	movs	r2, #0
2400d1a0:	631a      	str	r2, [r3, #48]	; 0x30
    __HAL_UNLOCK(hi2c);
2400d1a2:	687b      	ldr	r3, [r7, #4]
2400d1a4:	2200      	movs	r2, #0
2400d1a6:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
    HAL_I2C_SlaveTxCpltCallback(hi2c);
2400d1aa:	6878      	ldr	r0, [r7, #4]
2400d1ac:	f7fe fe03 	bl	2400bdb6 <HAL_I2C_SlaveTxCpltCallback>
}
2400d1b0:	bf00      	nop
2400d1b2:	3718      	adds	r7, #24
2400d1b4:	46bd      	mov	sp, r7
2400d1b6:	bd80      	pop	{r7, pc}
2400d1b8:	ffff0000 	.word	0xffff0000

2400d1bc <I2C_ITListenCplt>:
  * @param  hi2c I2C handle.
  * @param  ITFlags Interrupt flags to handle.
  * @retval None
  */
static void I2C_ITListenCplt(I2C_HandleTypeDef *hi2c, uint32_t ITFlags)
{
2400d1bc:	b580      	push	{r7, lr}
2400d1be:	b082      	sub	sp, #8
2400d1c0:	af00      	add	r7, sp, #0
2400d1c2:	6078      	str	r0, [r7, #4]
2400d1c4:	6039      	str	r1, [r7, #0]
  /* Reset handle parameters */
  hi2c->XferOptions = I2C_NO_OPTION_FRAME;
2400d1c6:	687b      	ldr	r3, [r7, #4]
2400d1c8:	4a26      	ldr	r2, [pc, #152]	; (2400d264 <I2C_ITListenCplt+0xa8>)
2400d1ca:	62da      	str	r2, [r3, #44]	; 0x2c
  hi2c->PreviousState = I2C_STATE_NONE;
2400d1cc:	687b      	ldr	r3, [r7, #4]
2400d1ce:	2200      	movs	r2, #0
2400d1d0:	631a      	str	r2, [r3, #48]	; 0x30
  hi2c->State = HAL_I2C_STATE_READY;
2400d1d2:	687b      	ldr	r3, [r7, #4]
2400d1d4:	2220      	movs	r2, #32
2400d1d6:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
  hi2c->Mode = HAL_I2C_MODE_NONE;
2400d1da:	687b      	ldr	r3, [r7, #4]
2400d1dc:	2200      	movs	r2, #0
2400d1de:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
  hi2c->XferISR = NULL;
2400d1e2:	687b      	ldr	r3, [r7, #4]
2400d1e4:	2200      	movs	r2, #0
2400d1e6:	635a      	str	r2, [r3, #52]	; 0x34

  /* Store Last receive data if any */
  if (I2C_CHECK_FLAG(ITFlags, I2C_FLAG_RXNE) != RESET)
2400d1e8:	683b      	ldr	r3, [r7, #0]
2400d1ea:	089b      	lsrs	r3, r3, #2
2400d1ec:	f003 0301 	and.w	r3, r3, #1
2400d1f0:	2b00      	cmp	r3, #0
2400d1f2:	d022      	beq.n	2400d23a <I2C_ITListenCplt+0x7e>
  {
    /* Read data from RXDR */
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
2400d1f4:	687b      	ldr	r3, [r7, #4]
2400d1f6:	681b      	ldr	r3, [r3, #0]
2400d1f8:	6a5a      	ldr	r2, [r3, #36]	; 0x24
2400d1fa:	687b      	ldr	r3, [r7, #4]
2400d1fc:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400d1fe:	b2d2      	uxtb	r2, r2
2400d200:	701a      	strb	r2, [r3, #0]

    /* Increment Buffer pointer */
    hi2c->pBuffPtr++;
2400d202:	687b      	ldr	r3, [r7, #4]
2400d204:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400d206:	1c5a      	adds	r2, r3, #1
2400d208:	687b      	ldr	r3, [r7, #4]
2400d20a:	625a      	str	r2, [r3, #36]	; 0x24

    if ((hi2c->XferSize > 0U))
2400d20c:	687b      	ldr	r3, [r7, #4]
2400d20e:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400d210:	2b00      	cmp	r3, #0
2400d212:	d012      	beq.n	2400d23a <I2C_ITListenCplt+0x7e>
    {
      hi2c->XferSize--;
2400d214:	687b      	ldr	r3, [r7, #4]
2400d216:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400d218:	3b01      	subs	r3, #1
2400d21a:	b29a      	uxth	r2, r3
2400d21c:	687b      	ldr	r3, [r7, #4]
2400d21e:	851a      	strh	r2, [r3, #40]	; 0x28
      hi2c->XferCount--;
2400d220:	687b      	ldr	r3, [r7, #4]
2400d222:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400d224:	b29b      	uxth	r3, r3
2400d226:	3b01      	subs	r3, #1
2400d228:	b29a      	uxth	r2, r3
2400d22a:	687b      	ldr	r3, [r7, #4]
2400d22c:	855a      	strh	r2, [r3, #42]	; 0x2a

      /* Set ErrorCode corresponding to a Non-Acknowledge */
      hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
2400d22e:	687b      	ldr	r3, [r7, #4]
2400d230:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400d232:	f043 0204 	orr.w	r2, r3, #4
2400d236:	687b      	ldr	r3, [r7, #4]
2400d238:	645a      	str	r2, [r3, #68]	; 0x44
    }
  }

  /* Disable all Interrupts*/
  I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_RX_IT | I2C_XFER_TX_IT);
2400d23a:	f248 0103 	movw	r1, #32771	; 0x8003
2400d23e:	6878      	ldr	r0, [r7, #4]
2400d240:	f000 fe0c 	bl	2400de5c <I2C_Disable_IRQ>

  /* Clear NACK Flag */
  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
2400d244:	687b      	ldr	r3, [r7, #4]
2400d246:	681b      	ldr	r3, [r3, #0]
2400d248:	2210      	movs	r2, #16
2400d24a:	61da      	str	r2, [r3, #28]

  /* Process Unlocked */
  __HAL_UNLOCK(hi2c);
2400d24c:	687b      	ldr	r3, [r7, #4]
2400d24e:	2200      	movs	r2, #0
2400d250:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  /* Call the Listen Complete callback, to inform upper layer of the end of Listen usecase */
#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
  hi2c->ListenCpltCallback(hi2c);
#else
  HAL_I2C_ListenCpltCallback(hi2c);
2400d254:	6878      	ldr	r0, [r7, #4]
2400d256:	f7fe fdd0 	bl	2400bdfa <HAL_I2C_ListenCpltCallback>
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
}
2400d25a:	bf00      	nop
2400d25c:	3708      	adds	r7, #8
2400d25e:	46bd      	mov	sp, r7
2400d260:	bd80      	pop	{r7, pc}
2400d262:	bf00      	nop
2400d264:	ffff0000 	.word	0xffff0000

2400d268 <I2C_ITError>:
  * @param  hi2c I2C handle.
  * @param  ErrorCode Error code to handle.
  * @retval None
  */
static void I2C_ITError(I2C_HandleTypeDef *hi2c, uint32_t ErrorCode)
{
2400d268:	b580      	push	{r7, lr}
2400d26a:	b084      	sub	sp, #16
2400d26c:	af00      	add	r7, sp, #0
2400d26e:	6078      	str	r0, [r7, #4]
2400d270:	6039      	str	r1, [r7, #0]
  HAL_I2C_StateTypeDef tmpstate = hi2c->State;
2400d272:	687b      	ldr	r3, [r7, #4]
2400d274:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400d278:	73fb      	strb	r3, [r7, #15]
  uint32_t tmppreviousstate;

  /* Reset handle parameters */
  hi2c->Mode          = HAL_I2C_MODE_NONE;
2400d27a:	687b      	ldr	r3, [r7, #4]
2400d27c:	2200      	movs	r2, #0
2400d27e:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
  hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
2400d282:	687b      	ldr	r3, [r7, #4]
2400d284:	4a5d      	ldr	r2, [pc, #372]	; (2400d3fc <I2C_ITError+0x194>)
2400d286:	62da      	str	r2, [r3, #44]	; 0x2c
  hi2c->XferCount     = 0U;
2400d288:	687b      	ldr	r3, [r7, #4]
2400d28a:	2200      	movs	r2, #0
2400d28c:	855a      	strh	r2, [r3, #42]	; 0x2a

  /* Set new error code */
  hi2c->ErrorCode |= ErrorCode;
2400d28e:	687b      	ldr	r3, [r7, #4]
2400d290:	6c5a      	ldr	r2, [r3, #68]	; 0x44
2400d292:	683b      	ldr	r3, [r7, #0]
2400d294:	431a      	orrs	r2, r3
2400d296:	687b      	ldr	r3, [r7, #4]
2400d298:	645a      	str	r2, [r3, #68]	; 0x44

  /* Disable Interrupts */
  if ((tmpstate == HAL_I2C_STATE_LISTEN)         ||
2400d29a:	7bfb      	ldrb	r3, [r7, #15]
2400d29c:	2b28      	cmp	r3, #40	; 0x28
2400d29e:	d005      	beq.n	2400d2ac <I2C_ITError+0x44>
2400d2a0:	7bfb      	ldrb	r3, [r7, #15]
2400d2a2:	2b29      	cmp	r3, #41	; 0x29
2400d2a4:	d002      	beq.n	2400d2ac <I2C_ITError+0x44>
      (tmpstate == HAL_I2C_STATE_BUSY_TX_LISTEN) ||
2400d2a6:	7bfb      	ldrb	r3, [r7, #15]
2400d2a8:	2b2a      	cmp	r3, #42	; 0x2a
2400d2aa:	d10b      	bne.n	2400d2c4 <I2C_ITError+0x5c>
      (tmpstate == HAL_I2C_STATE_BUSY_RX_LISTEN))
  {
    /* Disable all interrupts, except interrupts related to LISTEN state */
    I2C_Disable_IRQ(hi2c, I2C_XFER_RX_IT | I2C_XFER_TX_IT);
2400d2ac:	2103      	movs	r1, #3
2400d2ae:	6878      	ldr	r0, [r7, #4]
2400d2b0:	f000 fdd4 	bl	2400de5c <I2C_Disable_IRQ>

    /* keep HAL_I2C_STATE_LISTEN if set */
    hi2c->State         = HAL_I2C_STATE_LISTEN;
2400d2b4:	687b      	ldr	r3, [r7, #4]
2400d2b6:	2228      	movs	r2, #40	; 0x28
2400d2b8:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->XferISR       = I2C_Slave_ISR_IT;
2400d2bc:	687b      	ldr	r3, [r7, #4]
2400d2be:	4a50      	ldr	r2, [pc, #320]	; (2400d400 <I2C_ITError+0x198>)
2400d2c0:	635a      	str	r2, [r3, #52]	; 0x34
2400d2c2:	e011      	b.n	2400d2e8 <I2C_ITError+0x80>
  }
  else
  {
    /* Disable all interrupts */
    I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_RX_IT | I2C_XFER_TX_IT);
2400d2c4:	f248 0103 	movw	r1, #32771	; 0x8003
2400d2c8:	6878      	ldr	r0, [r7, #4]
2400d2ca:	f000 fdc7 	bl	2400de5c <I2C_Disable_IRQ>

    /* If state is an abort treatment on goind, don't change state */
    /* This change will be do later */
    if (hi2c->State != HAL_I2C_STATE_ABORT)
2400d2ce:	687b      	ldr	r3, [r7, #4]
2400d2d0:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400d2d4:	b2db      	uxtb	r3, r3
2400d2d6:	2b60      	cmp	r3, #96	; 0x60
2400d2d8:	d003      	beq.n	2400d2e2 <I2C_ITError+0x7a>
    {
      /* Set HAL_I2C_STATE_READY */
      hi2c->State         = HAL_I2C_STATE_READY;
2400d2da:	687b      	ldr	r3, [r7, #4]
2400d2dc:	2220      	movs	r2, #32
2400d2de:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    }
    hi2c->XferISR       = NULL;
2400d2e2:	687b      	ldr	r3, [r7, #4]
2400d2e4:	2200      	movs	r2, #0
2400d2e6:	635a      	str	r2, [r3, #52]	; 0x34
  }

  /* Abort DMA TX transfer if any */
  tmppreviousstate = hi2c->PreviousState;
2400d2e8:	687b      	ldr	r3, [r7, #4]
2400d2ea:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2400d2ec:	60bb      	str	r3, [r7, #8]
  if ((hi2c->hdmatx != NULL) && ((tmppreviousstate == I2C_STATE_MASTER_BUSY_TX) || (tmppreviousstate == I2C_STATE_SLAVE_BUSY_TX)))
2400d2ee:	687b      	ldr	r3, [r7, #4]
2400d2f0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400d2f2:	2b00      	cmp	r3, #0
2400d2f4:	d039      	beq.n	2400d36a <I2C_ITError+0x102>
2400d2f6:	68bb      	ldr	r3, [r7, #8]
2400d2f8:	2b11      	cmp	r3, #17
2400d2fa:	d002      	beq.n	2400d302 <I2C_ITError+0x9a>
2400d2fc:	68bb      	ldr	r3, [r7, #8]
2400d2fe:	2b21      	cmp	r3, #33	; 0x21
2400d300:	d133      	bne.n	2400d36a <I2C_ITError+0x102>
  {
    if ((hi2c->Instance->CR1 & I2C_CR1_TXDMAEN) == I2C_CR1_TXDMAEN)
2400d302:	687b      	ldr	r3, [r7, #4]
2400d304:	681b      	ldr	r3, [r3, #0]
2400d306:	681b      	ldr	r3, [r3, #0]
2400d308:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
2400d30c:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
2400d310:	d107      	bne.n	2400d322 <I2C_ITError+0xba>
    {
      hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
2400d312:	687b      	ldr	r3, [r7, #4]
2400d314:	681b      	ldr	r3, [r3, #0]
2400d316:	681a      	ldr	r2, [r3, #0]
2400d318:	687b      	ldr	r3, [r7, #4]
2400d31a:	681b      	ldr	r3, [r3, #0]
2400d31c:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
2400d320:	601a      	str	r2, [r3, #0]
    }

    if (HAL_DMA_GetState(hi2c->hdmatx) != HAL_DMA_STATE_READY)
2400d322:	687b      	ldr	r3, [r7, #4]
2400d324:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400d326:	4618      	mov	r0, r3
2400d328:	f7f7 fc78 	bl	24004c1c <HAL_DMA_GetState>
2400d32c:	4603      	mov	r3, r0
2400d32e:	2b01      	cmp	r3, #1
2400d330:	d017      	beq.n	2400d362 <I2C_ITError+0xfa>
    {
      /* Set the I2C DMA Abort callback :
       will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
      hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
2400d332:	687b      	ldr	r3, [r7, #4]
2400d334:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400d336:	4a33      	ldr	r2, [pc, #204]	; (2400d404 <I2C_ITError+0x19c>)
2400d338:	651a      	str	r2, [r3, #80]	; 0x50

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
2400d33a:	687b      	ldr	r3, [r7, #4]
2400d33c:	2200      	movs	r2, #0
2400d33e:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

      /* Abort DMA TX */
      if (HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)
2400d342:	687b      	ldr	r3, [r7, #4]
2400d344:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400d346:	4618      	mov	r0, r3
2400d348:	f7f5 fe88 	bl	2400305c <HAL_DMA_Abort_IT>
2400d34c:	4603      	mov	r3, r0
2400d34e:	2b00      	cmp	r3, #0
2400d350:	d04d      	beq.n	2400d3ee <I2C_ITError+0x186>
      {
        /* Call Directly XferAbortCallback function in case of error */
        hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
2400d352:	687b      	ldr	r3, [r7, #4]
2400d354:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400d356:	6d1b      	ldr	r3, [r3, #80]	; 0x50
2400d358:	687a      	ldr	r2, [r7, #4]
2400d35a:	6b92      	ldr	r2, [r2, #56]	; 0x38
2400d35c:	4610      	mov	r0, r2
2400d35e:	4798      	blx	r3
    if (HAL_DMA_GetState(hi2c->hdmatx) != HAL_DMA_STATE_READY)
2400d360:	e045      	b.n	2400d3ee <I2C_ITError+0x186>
      }
    }
    else
    {
      I2C_TreatErrorCallback(hi2c);
2400d362:	6878      	ldr	r0, [r7, #4]
2400d364:	f000 f850 	bl	2400d408 <I2C_TreatErrorCallback>
    if (HAL_DMA_GetState(hi2c->hdmatx) != HAL_DMA_STATE_READY)
2400d368:	e041      	b.n	2400d3ee <I2C_ITError+0x186>
    }
  }
  /* Abort DMA RX transfer if any */
  else if ((hi2c->hdmarx != NULL) && ((tmppreviousstate == I2C_STATE_MASTER_BUSY_RX) || (tmppreviousstate == I2C_STATE_SLAVE_BUSY_RX)))
2400d36a:	687b      	ldr	r3, [r7, #4]
2400d36c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d36e:	2b00      	cmp	r3, #0
2400d370:	d039      	beq.n	2400d3e6 <I2C_ITError+0x17e>
2400d372:	68bb      	ldr	r3, [r7, #8]
2400d374:	2b12      	cmp	r3, #18
2400d376:	d002      	beq.n	2400d37e <I2C_ITError+0x116>
2400d378:	68bb      	ldr	r3, [r7, #8]
2400d37a:	2b22      	cmp	r3, #34	; 0x22
2400d37c:	d133      	bne.n	2400d3e6 <I2C_ITError+0x17e>
  {
    if ((hi2c->Instance->CR1 & I2C_CR1_RXDMAEN) == I2C_CR1_RXDMAEN)
2400d37e:	687b      	ldr	r3, [r7, #4]
2400d380:	681b      	ldr	r3, [r3, #0]
2400d382:	681b      	ldr	r3, [r3, #0]
2400d384:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
2400d388:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
2400d38c:	d107      	bne.n	2400d39e <I2C_ITError+0x136>
    {
      hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
2400d38e:	687b      	ldr	r3, [r7, #4]
2400d390:	681b      	ldr	r3, [r3, #0]
2400d392:	681a      	ldr	r2, [r3, #0]
2400d394:	687b      	ldr	r3, [r7, #4]
2400d396:	681b      	ldr	r3, [r3, #0]
2400d398:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
2400d39c:	601a      	str	r2, [r3, #0]
    }

    if (HAL_DMA_GetState(hi2c->hdmarx) != HAL_DMA_STATE_READY)
2400d39e:	687b      	ldr	r3, [r7, #4]
2400d3a0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d3a2:	4618      	mov	r0, r3
2400d3a4:	f7f7 fc3a 	bl	24004c1c <HAL_DMA_GetState>
2400d3a8:	4603      	mov	r3, r0
2400d3aa:	2b01      	cmp	r3, #1
2400d3ac:	d017      	beq.n	2400d3de <I2C_ITError+0x176>
    {
      /* Set the I2C DMA Abort callback :
        will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
      hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
2400d3ae:	687b      	ldr	r3, [r7, #4]
2400d3b0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d3b2:	4a14      	ldr	r2, [pc, #80]	; (2400d404 <I2C_ITError+0x19c>)
2400d3b4:	651a      	str	r2, [r3, #80]	; 0x50

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
2400d3b6:	687b      	ldr	r3, [r7, #4]
2400d3b8:	2200      	movs	r2, #0
2400d3ba:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

      /* Abort DMA RX */
      if (HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)
2400d3be:	687b      	ldr	r3, [r7, #4]
2400d3c0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d3c2:	4618      	mov	r0, r3
2400d3c4:	f7f5 fe4a 	bl	2400305c <HAL_DMA_Abort_IT>
2400d3c8:	4603      	mov	r3, r0
2400d3ca:	2b00      	cmp	r3, #0
2400d3cc:	d011      	beq.n	2400d3f2 <I2C_ITError+0x18a>
      {
        /* Call Directly hi2c->hdmarx->XferAbortCallback function in case of error */
        hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
2400d3ce:	687b      	ldr	r3, [r7, #4]
2400d3d0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d3d2:	6d1b      	ldr	r3, [r3, #80]	; 0x50
2400d3d4:	687a      	ldr	r2, [r7, #4]
2400d3d6:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
2400d3d8:	4610      	mov	r0, r2
2400d3da:	4798      	blx	r3
    if (HAL_DMA_GetState(hi2c->hdmarx) != HAL_DMA_STATE_READY)
2400d3dc:	e009      	b.n	2400d3f2 <I2C_ITError+0x18a>
      }
    }
    else
    {
      I2C_TreatErrorCallback(hi2c);
2400d3de:	6878      	ldr	r0, [r7, #4]
2400d3e0:	f000 f812 	bl	2400d408 <I2C_TreatErrorCallback>
    if (HAL_DMA_GetState(hi2c->hdmarx) != HAL_DMA_STATE_READY)
2400d3e4:	e005      	b.n	2400d3f2 <I2C_ITError+0x18a>
    }
  }
  else
  {
    I2C_TreatErrorCallback(hi2c);
2400d3e6:	6878      	ldr	r0, [r7, #4]
2400d3e8:	f000 f80e 	bl	2400d408 <I2C_TreatErrorCallback>
  }
}
2400d3ec:	e002      	b.n	2400d3f4 <I2C_ITError+0x18c>
    if (HAL_DMA_GetState(hi2c->hdmatx) != HAL_DMA_STATE_READY)
2400d3ee:	bf00      	nop
2400d3f0:	e000      	b.n	2400d3f4 <I2C_ITError+0x18c>
    if (HAL_DMA_GetState(hi2c->hdmarx) != HAL_DMA_STATE_READY)
2400d3f2:	bf00      	nop
}
2400d3f4:	bf00      	nop
2400d3f6:	3710      	adds	r7, #16
2400d3f8:	46bd      	mov	sp, r7
2400d3fa:	bd80      	pop	{r7, pc}
2400d3fc:	ffff0000 	.word	0xffff0000
2400d400:	2400c101 	.word	0x2400c101
2400d404:	2400d9e1 	.word	0x2400d9e1

2400d408 <I2C_TreatErrorCallback>:
  * @brief  I2C Error callback treatment.
  * @param  hi2c I2C handle.
  * @retval None
  */
static void I2C_TreatErrorCallback(I2C_HandleTypeDef *hi2c)
{
2400d408:	b580      	push	{r7, lr}
2400d40a:	b082      	sub	sp, #8
2400d40c:	af00      	add	r7, sp, #0
2400d40e:	6078      	str	r0, [r7, #4]
  if (hi2c->State == HAL_I2C_STATE_ABORT)
2400d410:	687b      	ldr	r3, [r7, #4]
2400d412:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400d416:	b2db      	uxtb	r3, r3
2400d418:	2b60      	cmp	r3, #96	; 0x60
2400d41a:	d10e      	bne.n	2400d43a <I2C_TreatErrorCallback+0x32>
  {
    hi2c->State = HAL_I2C_STATE_READY;
2400d41c:	687b      	ldr	r3, [r7, #4]
2400d41e:	2220      	movs	r2, #32
2400d420:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->PreviousState = I2C_STATE_NONE;
2400d424:	687b      	ldr	r3, [r7, #4]
2400d426:	2200      	movs	r2, #0
2400d428:	631a      	str	r2, [r3, #48]	; 0x30

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2400d42a:	687b      	ldr	r3, [r7, #4]
2400d42c:	2200      	movs	r2, #0
2400d42e:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Call the corresponding callback to inform upper layer of End of Transfer */
#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
    hi2c->AbortCpltCallback(hi2c);
#else
    HAL_I2C_AbortCpltCallback(hi2c);
2400d432:	6878      	ldr	r0, [r7, #4]
2400d434:	f7fe fd09 	bl	2400be4a <HAL_I2C_AbortCpltCallback>
    hi2c->ErrorCallback(hi2c);
#else
    HAL_I2C_ErrorCallback(hi2c);
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
  }
}
2400d438:	e009      	b.n	2400d44e <I2C_TreatErrorCallback+0x46>
    hi2c->PreviousState = I2C_STATE_NONE;
2400d43a:	687b      	ldr	r3, [r7, #4]
2400d43c:	2200      	movs	r2, #0
2400d43e:	631a      	str	r2, [r3, #48]	; 0x30
    __HAL_UNLOCK(hi2c);
2400d440:	687b      	ldr	r3, [r7, #4]
2400d442:	2200      	movs	r2, #0
2400d444:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
    HAL_I2C_ErrorCallback(hi2c);
2400d448:	6878      	ldr	r0, [r7, #4]
2400d44a:	f7fe fcf4 	bl	2400be36 <HAL_I2C_ErrorCallback>
}
2400d44e:	bf00      	nop
2400d450:	3708      	adds	r7, #8
2400d452:	46bd      	mov	sp, r7
2400d454:	bd80      	pop	{r7, pc}

2400d456 <I2C_Flush_TXDR>:
  * @brief  I2C Tx data register flush process.
  * @param  hi2c I2C handle.
  * @retval None
  */
static void I2C_Flush_TXDR(I2C_HandleTypeDef *hi2c)
{
2400d456:	b480      	push	{r7}
2400d458:	b083      	sub	sp, #12
2400d45a:	af00      	add	r7, sp, #0
2400d45c:	6078      	str	r0, [r7, #4]
  /* If a pending TXIS flag is set */
  /* Write a dummy data in TXDR to clear it */
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
2400d45e:	687b      	ldr	r3, [r7, #4]
2400d460:	681b      	ldr	r3, [r3, #0]
2400d462:	699b      	ldr	r3, [r3, #24]
2400d464:	f003 0302 	and.w	r3, r3, #2
2400d468:	2b02      	cmp	r3, #2
2400d46a:	d103      	bne.n	2400d474 <I2C_Flush_TXDR+0x1e>
  {
    hi2c->Instance->TXDR = 0x00U;
2400d46c:	687b      	ldr	r3, [r7, #4]
2400d46e:	681b      	ldr	r3, [r3, #0]
2400d470:	2200      	movs	r2, #0
2400d472:	629a      	str	r2, [r3, #40]	; 0x28
  }

  /* Flush TX register if not empty */
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
2400d474:	687b      	ldr	r3, [r7, #4]
2400d476:	681b      	ldr	r3, [r3, #0]
2400d478:	699b      	ldr	r3, [r3, #24]
2400d47a:	f003 0301 	and.w	r3, r3, #1
2400d47e:	2b01      	cmp	r3, #1
2400d480:	d007      	beq.n	2400d492 <I2C_Flush_TXDR+0x3c>
  {
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
2400d482:	687b      	ldr	r3, [r7, #4]
2400d484:	681b      	ldr	r3, [r3, #0]
2400d486:	699a      	ldr	r2, [r3, #24]
2400d488:	687b      	ldr	r3, [r7, #4]
2400d48a:	681b      	ldr	r3, [r3, #0]
2400d48c:	f042 0201 	orr.w	r2, r2, #1
2400d490:	619a      	str	r2, [r3, #24]
  }
}
2400d492:	bf00      	nop
2400d494:	370c      	adds	r7, #12
2400d496:	46bd      	mov	sp, r7
2400d498:	f85d 7b04 	ldr.w	r7, [sp], #4
2400d49c:	4770      	bx	lr

2400d49e <I2C_DMAMasterTransmitCplt>:
  * @brief  DMA I2C master transmit process complete callback.
  * @param  hdma DMA handle
  * @retval None
  */
static void I2C_DMAMasterTransmitCplt(DMA_HandleTypeDef *hdma)
{
2400d49e:	b580      	push	{r7, lr}
2400d4a0:	b084      	sub	sp, #16
2400d4a2:	af00      	add	r7, sp, #0
2400d4a4:	6078      	str	r0, [r7, #4]
  I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
2400d4a6:	687b      	ldr	r3, [r7, #4]
2400d4a8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400d4aa:	60fb      	str	r3, [r7, #12]

  /* Disable DMA Request */
  hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
2400d4ac:	68fb      	ldr	r3, [r7, #12]
2400d4ae:	681b      	ldr	r3, [r3, #0]
2400d4b0:	681a      	ldr	r2, [r3, #0]
2400d4b2:	68fb      	ldr	r3, [r7, #12]
2400d4b4:	681b      	ldr	r3, [r3, #0]
2400d4b6:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
2400d4ba:	601a      	str	r2, [r3, #0]

  /* If last transfer, enable STOP interrupt */
  if (hi2c->XferCount == 0U)
2400d4bc:	68fb      	ldr	r3, [r7, #12]
2400d4be:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400d4c0:	b29b      	uxth	r3, r3
2400d4c2:	2b00      	cmp	r3, #0
2400d4c4:	d104      	bne.n	2400d4d0 <I2C_DMAMasterTransmitCplt+0x32>
  {
    /* Enable STOP interrupt */
    I2C_Enable_IRQ(hi2c, I2C_XFER_CPLT_IT);
2400d4c6:	2120      	movs	r1, #32
2400d4c8:	68f8      	ldr	r0, [r7, #12]
2400d4ca:	f000 fc63 	bl	2400dd94 <I2C_Enable_IRQ>
    {
      /* Enable TC interrupts */
      I2C_Enable_IRQ(hi2c, I2C_XFER_RELOAD_IT);
    }
  }
}
2400d4ce:	e02d      	b.n	2400d52c <I2C_DMAMasterTransmitCplt+0x8e>
    hi2c->pBuffPtr += hi2c->XferSize;
2400d4d0:	68fb      	ldr	r3, [r7, #12]
2400d4d2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400d4d4:	68fa      	ldr	r2, [r7, #12]
2400d4d6:	8d12      	ldrh	r2, [r2, #40]	; 0x28
2400d4d8:	441a      	add	r2, r3
2400d4da:	68fb      	ldr	r3, [r7, #12]
2400d4dc:	625a      	str	r2, [r3, #36]	; 0x24
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
2400d4de:	68fb      	ldr	r3, [r7, #12]
2400d4e0:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400d4e2:	b29b      	uxth	r3, r3
2400d4e4:	2bff      	cmp	r3, #255	; 0xff
2400d4e6:	d903      	bls.n	2400d4f0 <I2C_DMAMasterTransmitCplt+0x52>
      hi2c->XferSize = MAX_NBYTE_SIZE;
2400d4e8:	68fb      	ldr	r3, [r7, #12]
2400d4ea:	22ff      	movs	r2, #255	; 0xff
2400d4ec:	851a      	strh	r2, [r3, #40]	; 0x28
2400d4ee:	e004      	b.n	2400d4fa <I2C_DMAMasterTransmitCplt+0x5c>
      hi2c->XferSize = hi2c->XferCount;
2400d4f0:	68fb      	ldr	r3, [r7, #12]
2400d4f2:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400d4f4:	b29a      	uxth	r2, r3
2400d4f6:	68fb      	ldr	r3, [r7, #12]
2400d4f8:	851a      	strh	r2, [r3, #40]	; 0x28
    if (HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)hi2c->pBuffPtr, (uint32_t)&hi2c->Instance->TXDR, hi2c->XferSize) != HAL_OK)
2400d4fa:	68fb      	ldr	r3, [r7, #12]
2400d4fc:	6b98      	ldr	r0, [r3, #56]	; 0x38
2400d4fe:	68fb      	ldr	r3, [r7, #12]
2400d500:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400d502:	4619      	mov	r1, r3
2400d504:	68fb      	ldr	r3, [r7, #12]
2400d506:	681b      	ldr	r3, [r3, #0]
2400d508:	3328      	adds	r3, #40	; 0x28
2400d50a:	461a      	mov	r2, r3
2400d50c:	68fb      	ldr	r3, [r7, #12]
2400d50e:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400d510:	f7f5 f81c 	bl	2400254c <HAL_DMA_Start_IT>
2400d514:	4603      	mov	r3, r0
2400d516:	2b00      	cmp	r3, #0
2400d518:	d004      	beq.n	2400d524 <I2C_DMAMasterTransmitCplt+0x86>
      I2C_ITError(hi2c, HAL_I2C_ERROR_DMA);
2400d51a:	2110      	movs	r1, #16
2400d51c:	68f8      	ldr	r0, [r7, #12]
2400d51e:	f7ff fea3 	bl	2400d268 <I2C_ITError>
}
2400d522:	e003      	b.n	2400d52c <I2C_DMAMasterTransmitCplt+0x8e>
      I2C_Enable_IRQ(hi2c, I2C_XFER_RELOAD_IT);
2400d524:	2140      	movs	r1, #64	; 0x40
2400d526:	68f8      	ldr	r0, [r7, #12]
2400d528:	f000 fc34 	bl	2400dd94 <I2C_Enable_IRQ>
}
2400d52c:	bf00      	nop
2400d52e:	3710      	adds	r7, #16
2400d530:	46bd      	mov	sp, r7
2400d532:	bd80      	pop	{r7, pc}

2400d534 <I2C_DMASlaveTransmitCplt>:
  * @brief  DMA I2C slave transmit process complete callback.
  * @param  hdma DMA handle
  * @retval None
  */
static void I2C_DMASlaveTransmitCplt(DMA_HandleTypeDef *hdma)
{
2400d534:	b580      	push	{r7, lr}
2400d536:	b084      	sub	sp, #16
2400d538:	af00      	add	r7, sp, #0
2400d53a:	6078      	str	r0, [r7, #4]
  I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
2400d53c:	687b      	ldr	r3, [r7, #4]
2400d53e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400d540:	60fb      	str	r3, [r7, #12]
  uint32_t tmpoptions = hi2c->XferOptions;
2400d542:	68fb      	ldr	r3, [r7, #12]
2400d544:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2400d546:	60bb      	str	r3, [r7, #8]

  if ((tmpoptions == I2C_NEXT_FRAME) || (tmpoptions == I2C_FIRST_FRAME))
2400d548:	68bb      	ldr	r3, [r7, #8]
2400d54a:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
2400d54e:	d002      	beq.n	2400d556 <I2C_DMASlaveTransmitCplt+0x22>
2400d550:	68bb      	ldr	r3, [r7, #8]
2400d552:	2b00      	cmp	r3, #0
2400d554:	d10a      	bne.n	2400d56c <I2C_DMASlaveTransmitCplt+0x38>
  {
    /* Disable DMA Request */
    hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
2400d556:	68fb      	ldr	r3, [r7, #12]
2400d558:	681b      	ldr	r3, [r3, #0]
2400d55a:	681a      	ldr	r2, [r3, #0]
2400d55c:	68fb      	ldr	r3, [r7, #12]
2400d55e:	681b      	ldr	r3, [r3, #0]
2400d560:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
2400d564:	601a      	str	r2, [r3, #0]

    /* Last Byte is Transmitted */
    /* Call I2C Slave Sequential complete process */
    I2C_ITSlaveSeqCplt(hi2c);
2400d566:	68f8      	ldr	r0, [r7, #12]
2400d568:	f7ff fb09 	bl	2400cb7e <I2C_ITSlaveSeqCplt>
  {
    /* No specific action, Master fully manage the generation of STOP condition */
    /* Mean that this generation can arrive at any time, at the end or during DMA process */
    /* So STOP condition should be manage through Interrupt treatment */
  }
}
2400d56c:	bf00      	nop
2400d56e:	3710      	adds	r7, #16
2400d570:	46bd      	mov	sp, r7
2400d572:	bd80      	pop	{r7, pc}

2400d574 <I2C_DMAMasterReceiveCplt>:
  * @brief DMA I2C master receive process complete callback.
  * @param  hdma DMA handle
  * @retval None
  */
static void I2C_DMAMasterReceiveCplt(DMA_HandleTypeDef *hdma)
{
2400d574:	b580      	push	{r7, lr}
2400d576:	b084      	sub	sp, #16
2400d578:	af00      	add	r7, sp, #0
2400d57a:	6078      	str	r0, [r7, #4]
  I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
2400d57c:	687b      	ldr	r3, [r7, #4]
2400d57e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400d580:	60fb      	str	r3, [r7, #12]

  /* Disable DMA Request */
  hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
2400d582:	68fb      	ldr	r3, [r7, #12]
2400d584:	681b      	ldr	r3, [r3, #0]
2400d586:	681a      	ldr	r2, [r3, #0]
2400d588:	68fb      	ldr	r3, [r7, #12]
2400d58a:	681b      	ldr	r3, [r3, #0]
2400d58c:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
2400d590:	601a      	str	r2, [r3, #0]

  /* If last transfer, enable STOP interrupt */
  if (hi2c->XferCount == 0U)
2400d592:	68fb      	ldr	r3, [r7, #12]
2400d594:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400d596:	b29b      	uxth	r3, r3
2400d598:	2b00      	cmp	r3, #0
2400d59a:	d104      	bne.n	2400d5a6 <I2C_DMAMasterReceiveCplt+0x32>
  {
    /* Enable STOP interrupt */
    I2C_Enable_IRQ(hi2c, I2C_XFER_CPLT_IT);
2400d59c:	2120      	movs	r1, #32
2400d59e:	68f8      	ldr	r0, [r7, #12]
2400d5a0:	f000 fbf8 	bl	2400dd94 <I2C_Enable_IRQ>
    {
      /* Enable TC interrupts */
      I2C_Enable_IRQ(hi2c, I2C_XFER_RELOAD_IT);
    }
  }
}
2400d5a4:	e02d      	b.n	2400d602 <I2C_DMAMasterReceiveCplt+0x8e>
    hi2c->pBuffPtr += hi2c->XferSize;
2400d5a6:	68fb      	ldr	r3, [r7, #12]
2400d5a8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400d5aa:	68fa      	ldr	r2, [r7, #12]
2400d5ac:	8d12      	ldrh	r2, [r2, #40]	; 0x28
2400d5ae:	441a      	add	r2, r3
2400d5b0:	68fb      	ldr	r3, [r7, #12]
2400d5b2:	625a      	str	r2, [r3, #36]	; 0x24
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
2400d5b4:	68fb      	ldr	r3, [r7, #12]
2400d5b6:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400d5b8:	b29b      	uxth	r3, r3
2400d5ba:	2bff      	cmp	r3, #255	; 0xff
2400d5bc:	d903      	bls.n	2400d5c6 <I2C_DMAMasterReceiveCplt+0x52>
      hi2c->XferSize = MAX_NBYTE_SIZE;
2400d5be:	68fb      	ldr	r3, [r7, #12]
2400d5c0:	22ff      	movs	r2, #255	; 0xff
2400d5c2:	851a      	strh	r2, [r3, #40]	; 0x28
2400d5c4:	e004      	b.n	2400d5d0 <I2C_DMAMasterReceiveCplt+0x5c>
      hi2c->XferSize = hi2c->XferCount;
2400d5c6:	68fb      	ldr	r3, [r7, #12]
2400d5c8:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400d5ca:	b29a      	uxth	r2, r3
2400d5cc:	68fb      	ldr	r3, [r7, #12]
2400d5ce:	851a      	strh	r2, [r3, #40]	; 0x28
    if (HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)hi2c->pBuffPtr, hi2c->XferSize) != HAL_OK)
2400d5d0:	68fb      	ldr	r3, [r7, #12]
2400d5d2:	6bd8      	ldr	r0, [r3, #60]	; 0x3c
2400d5d4:	68fb      	ldr	r3, [r7, #12]
2400d5d6:	681b      	ldr	r3, [r3, #0]
2400d5d8:	3324      	adds	r3, #36	; 0x24
2400d5da:	4619      	mov	r1, r3
2400d5dc:	68fb      	ldr	r3, [r7, #12]
2400d5de:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400d5e0:	461a      	mov	r2, r3
2400d5e2:	68fb      	ldr	r3, [r7, #12]
2400d5e4:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400d5e6:	f7f4 ffb1 	bl	2400254c <HAL_DMA_Start_IT>
2400d5ea:	4603      	mov	r3, r0
2400d5ec:	2b00      	cmp	r3, #0
2400d5ee:	d004      	beq.n	2400d5fa <I2C_DMAMasterReceiveCplt+0x86>
      I2C_ITError(hi2c, HAL_I2C_ERROR_DMA);
2400d5f0:	2110      	movs	r1, #16
2400d5f2:	68f8      	ldr	r0, [r7, #12]
2400d5f4:	f7ff fe38 	bl	2400d268 <I2C_ITError>
}
2400d5f8:	e003      	b.n	2400d602 <I2C_DMAMasterReceiveCplt+0x8e>
      I2C_Enable_IRQ(hi2c, I2C_XFER_RELOAD_IT);
2400d5fa:	2140      	movs	r1, #64	; 0x40
2400d5fc:	68f8      	ldr	r0, [r7, #12]
2400d5fe:	f000 fbc9 	bl	2400dd94 <I2C_Enable_IRQ>
}
2400d602:	bf00      	nop
2400d604:	3710      	adds	r7, #16
2400d606:	46bd      	mov	sp, r7
2400d608:	bd80      	pop	{r7, pc}
	...

2400d60c <I2C_DMASlaveReceiveCplt>:
  * @brief  DMA I2C slave receive process complete callback.
  * @param  hdma DMA handle
  * @retval None
  */
static void I2C_DMASlaveReceiveCplt(DMA_HandleTypeDef *hdma)
{
2400d60c:	b580      	push	{r7, lr}
2400d60e:	b084      	sub	sp, #16
2400d610:	af00      	add	r7, sp, #0
2400d612:	6078      	str	r0, [r7, #4]
  I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
2400d614:	687b      	ldr	r3, [r7, #4]
2400d616:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400d618:	60fb      	str	r3, [r7, #12]
  uint32_t tmpoptions = hi2c->XferOptions;
2400d61a:	68fb      	ldr	r3, [r7, #12]
2400d61c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2400d61e:	60bb      	str	r3, [r7, #8]

  if ((__HAL_DMA_GET_COUNTER(hi2c->hdmarx) == 0U) && \
2400d620:	68fb      	ldr	r3, [r7, #12]
2400d622:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d624:	681b      	ldr	r3, [r3, #0]
2400d626:	4a42      	ldr	r2, [pc, #264]	; (2400d730 <I2C_DMASlaveReceiveCplt+0x124>)
2400d628:	4293      	cmp	r3, r2
2400d62a:	d059      	beq.n	2400d6e0 <I2C_DMASlaveReceiveCplt+0xd4>
2400d62c:	68fb      	ldr	r3, [r7, #12]
2400d62e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d630:	681b      	ldr	r3, [r3, #0]
2400d632:	4a40      	ldr	r2, [pc, #256]	; (2400d734 <I2C_DMASlaveReceiveCplt+0x128>)
2400d634:	4293      	cmp	r3, r2
2400d636:	d053      	beq.n	2400d6e0 <I2C_DMASlaveReceiveCplt+0xd4>
2400d638:	68fb      	ldr	r3, [r7, #12]
2400d63a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d63c:	681b      	ldr	r3, [r3, #0]
2400d63e:	4a3e      	ldr	r2, [pc, #248]	; (2400d738 <I2C_DMASlaveReceiveCplt+0x12c>)
2400d640:	4293      	cmp	r3, r2
2400d642:	d04d      	beq.n	2400d6e0 <I2C_DMASlaveReceiveCplt+0xd4>
2400d644:	68fb      	ldr	r3, [r7, #12]
2400d646:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d648:	681b      	ldr	r3, [r3, #0]
2400d64a:	4a3c      	ldr	r2, [pc, #240]	; (2400d73c <I2C_DMASlaveReceiveCplt+0x130>)
2400d64c:	4293      	cmp	r3, r2
2400d64e:	d047      	beq.n	2400d6e0 <I2C_DMASlaveReceiveCplt+0xd4>
2400d650:	68fb      	ldr	r3, [r7, #12]
2400d652:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d654:	681b      	ldr	r3, [r3, #0]
2400d656:	4a3a      	ldr	r2, [pc, #232]	; (2400d740 <I2C_DMASlaveReceiveCplt+0x134>)
2400d658:	4293      	cmp	r3, r2
2400d65a:	d041      	beq.n	2400d6e0 <I2C_DMASlaveReceiveCplt+0xd4>
2400d65c:	68fb      	ldr	r3, [r7, #12]
2400d65e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d660:	681b      	ldr	r3, [r3, #0]
2400d662:	4a38      	ldr	r2, [pc, #224]	; (2400d744 <I2C_DMASlaveReceiveCplt+0x138>)
2400d664:	4293      	cmp	r3, r2
2400d666:	d03b      	beq.n	2400d6e0 <I2C_DMASlaveReceiveCplt+0xd4>
2400d668:	68fb      	ldr	r3, [r7, #12]
2400d66a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d66c:	681b      	ldr	r3, [r3, #0]
2400d66e:	4a36      	ldr	r2, [pc, #216]	; (2400d748 <I2C_DMASlaveReceiveCplt+0x13c>)
2400d670:	4293      	cmp	r3, r2
2400d672:	d035      	beq.n	2400d6e0 <I2C_DMASlaveReceiveCplt+0xd4>
2400d674:	68fb      	ldr	r3, [r7, #12]
2400d676:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d678:	681b      	ldr	r3, [r3, #0]
2400d67a:	4a34      	ldr	r2, [pc, #208]	; (2400d74c <I2C_DMASlaveReceiveCplt+0x140>)
2400d67c:	4293      	cmp	r3, r2
2400d67e:	d02f      	beq.n	2400d6e0 <I2C_DMASlaveReceiveCplt+0xd4>
2400d680:	68fb      	ldr	r3, [r7, #12]
2400d682:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d684:	681b      	ldr	r3, [r3, #0]
2400d686:	4a32      	ldr	r2, [pc, #200]	; (2400d750 <I2C_DMASlaveReceiveCplt+0x144>)
2400d688:	4293      	cmp	r3, r2
2400d68a:	d029      	beq.n	2400d6e0 <I2C_DMASlaveReceiveCplt+0xd4>
2400d68c:	68fb      	ldr	r3, [r7, #12]
2400d68e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d690:	681b      	ldr	r3, [r3, #0]
2400d692:	4a30      	ldr	r2, [pc, #192]	; (2400d754 <I2C_DMASlaveReceiveCplt+0x148>)
2400d694:	4293      	cmp	r3, r2
2400d696:	d023      	beq.n	2400d6e0 <I2C_DMASlaveReceiveCplt+0xd4>
2400d698:	68fb      	ldr	r3, [r7, #12]
2400d69a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d69c:	681b      	ldr	r3, [r3, #0]
2400d69e:	4a2e      	ldr	r2, [pc, #184]	; (2400d758 <I2C_DMASlaveReceiveCplt+0x14c>)
2400d6a0:	4293      	cmp	r3, r2
2400d6a2:	d01d      	beq.n	2400d6e0 <I2C_DMASlaveReceiveCplt+0xd4>
2400d6a4:	68fb      	ldr	r3, [r7, #12]
2400d6a6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d6a8:	681b      	ldr	r3, [r3, #0]
2400d6aa:	4a2c      	ldr	r2, [pc, #176]	; (2400d75c <I2C_DMASlaveReceiveCplt+0x150>)
2400d6ac:	4293      	cmp	r3, r2
2400d6ae:	d017      	beq.n	2400d6e0 <I2C_DMASlaveReceiveCplt+0xd4>
2400d6b0:	68fb      	ldr	r3, [r7, #12]
2400d6b2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d6b4:	681b      	ldr	r3, [r3, #0]
2400d6b6:	4a2a      	ldr	r2, [pc, #168]	; (2400d760 <I2C_DMASlaveReceiveCplt+0x154>)
2400d6b8:	4293      	cmp	r3, r2
2400d6ba:	d011      	beq.n	2400d6e0 <I2C_DMASlaveReceiveCplt+0xd4>
2400d6bc:	68fb      	ldr	r3, [r7, #12]
2400d6be:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d6c0:	681b      	ldr	r3, [r3, #0]
2400d6c2:	4a28      	ldr	r2, [pc, #160]	; (2400d764 <I2C_DMASlaveReceiveCplt+0x158>)
2400d6c4:	4293      	cmp	r3, r2
2400d6c6:	d00b      	beq.n	2400d6e0 <I2C_DMASlaveReceiveCplt+0xd4>
2400d6c8:	68fb      	ldr	r3, [r7, #12]
2400d6ca:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d6cc:	681b      	ldr	r3, [r3, #0]
2400d6ce:	4a26      	ldr	r2, [pc, #152]	; (2400d768 <I2C_DMASlaveReceiveCplt+0x15c>)
2400d6d0:	4293      	cmp	r3, r2
2400d6d2:	d005      	beq.n	2400d6e0 <I2C_DMASlaveReceiveCplt+0xd4>
2400d6d4:	68fb      	ldr	r3, [r7, #12]
2400d6d6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d6d8:	681b      	ldr	r3, [r3, #0]
2400d6da:	4a24      	ldr	r2, [pc, #144]	; (2400d76c <I2C_DMASlaveReceiveCplt+0x160>)
2400d6dc:	4293      	cmp	r3, r2
2400d6de:	d109      	bne.n	2400d6f4 <I2C_DMASlaveReceiveCplt+0xe8>
2400d6e0:	68fb      	ldr	r3, [r7, #12]
2400d6e2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d6e4:	681b      	ldr	r3, [r3, #0]
2400d6e6:	685b      	ldr	r3, [r3, #4]
2400d6e8:	2b00      	cmp	r3, #0
2400d6ea:	bf0c      	ite	eq
2400d6ec:	2301      	moveq	r3, #1
2400d6ee:	2300      	movne	r3, #0
2400d6f0:	b2db      	uxtb	r3, r3
2400d6f2:	e008      	b.n	2400d706 <I2C_DMASlaveReceiveCplt+0xfa>
2400d6f4:	68fb      	ldr	r3, [r7, #12]
2400d6f6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d6f8:	681b      	ldr	r3, [r3, #0]
2400d6fa:	685b      	ldr	r3, [r3, #4]
2400d6fc:	2b00      	cmp	r3, #0
2400d6fe:	bf0c      	ite	eq
2400d700:	2301      	moveq	r3, #1
2400d702:	2300      	movne	r3, #0
2400d704:	b2db      	uxtb	r3, r3
2400d706:	2b00      	cmp	r3, #0
2400d708:	d00e      	beq.n	2400d728 <I2C_DMASlaveReceiveCplt+0x11c>
2400d70a:	68bb      	ldr	r3, [r7, #8]
2400d70c:	f513 3f80 	cmn.w	r3, #65536	; 0x10000
2400d710:	d00a      	beq.n	2400d728 <I2C_DMASlaveReceiveCplt+0x11c>
      (tmpoptions != I2C_NO_OPTION_FRAME))
  {
    /* Disable DMA Request */
    hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
2400d712:	68fb      	ldr	r3, [r7, #12]
2400d714:	681b      	ldr	r3, [r3, #0]
2400d716:	681a      	ldr	r2, [r3, #0]
2400d718:	68fb      	ldr	r3, [r7, #12]
2400d71a:	681b      	ldr	r3, [r3, #0]
2400d71c:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
2400d720:	601a      	str	r2, [r3, #0]

    /* Call I2C Slave Sequential complete process */
    I2C_ITSlaveSeqCplt(hi2c);
2400d722:	68f8      	ldr	r0, [r7, #12]
2400d724:	f7ff fa2b 	bl	2400cb7e <I2C_ITSlaveSeqCplt>
  {
    /* No specific action, Master fully manage the generation of STOP condition */
    /* Mean that this generation can arrive at any time, at the end or during DMA process */
    /* So STOP condition should be manage through Interrupt treatment */
  }
}
2400d728:	bf00      	nop
2400d72a:	3710      	adds	r7, #16
2400d72c:	46bd      	mov	sp, r7
2400d72e:	bd80      	pop	{r7, pc}
2400d730:	40020010 	.word	0x40020010
2400d734:	40020028 	.word	0x40020028
2400d738:	40020040 	.word	0x40020040
2400d73c:	40020058 	.word	0x40020058
2400d740:	40020070 	.word	0x40020070
2400d744:	40020088 	.word	0x40020088
2400d748:	400200a0 	.word	0x400200a0
2400d74c:	400200b8 	.word	0x400200b8
2400d750:	40020410 	.word	0x40020410
2400d754:	40020428 	.word	0x40020428
2400d758:	40020440 	.word	0x40020440
2400d75c:	40020458 	.word	0x40020458
2400d760:	40020470 	.word	0x40020470
2400d764:	40020488 	.word	0x40020488
2400d768:	400204a0 	.word	0x400204a0
2400d76c:	400204b8 	.word	0x400204b8

2400d770 <I2C_DMAError>:
  * @brief  DMA I2C communication error callback.
  * @param hdma DMA handle
  * @retval None
  */
static void I2C_DMAError(DMA_HandleTypeDef *hdma)
{
2400d770:	b580      	push	{r7, lr}
2400d772:	b084      	sub	sp, #16
2400d774:	af00      	add	r7, sp, #0
2400d776:	6078      	str	r0, [r7, #4]
  uint32_t treatdmaerror = 0U;
2400d778:	2300      	movs	r3, #0
2400d77a:	60fb      	str	r3, [r7, #12]
  I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
2400d77c:	687b      	ldr	r3, [r7, #4]
2400d77e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400d780:	60bb      	str	r3, [r7, #8]

  if (hi2c->hdmatx != NULL)
2400d782:	68bb      	ldr	r3, [r7, #8]
2400d784:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400d786:	2b00      	cmp	r3, #0
2400d788:	d076      	beq.n	2400d878 <I2C_DMAError+0x108>
  {
    if (__HAL_DMA_GET_COUNTER(hi2c->hdmatx) == 0U)
2400d78a:	68bb      	ldr	r3, [r7, #8]
2400d78c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400d78e:	681b      	ldr	r3, [r3, #0]
2400d790:	4a83      	ldr	r2, [pc, #524]	; (2400d9a0 <I2C_DMAError+0x230>)
2400d792:	4293      	cmp	r3, r2
2400d794:	d059      	beq.n	2400d84a <I2C_DMAError+0xda>
2400d796:	68bb      	ldr	r3, [r7, #8]
2400d798:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400d79a:	681b      	ldr	r3, [r3, #0]
2400d79c:	4a81      	ldr	r2, [pc, #516]	; (2400d9a4 <I2C_DMAError+0x234>)
2400d79e:	4293      	cmp	r3, r2
2400d7a0:	d053      	beq.n	2400d84a <I2C_DMAError+0xda>
2400d7a2:	68bb      	ldr	r3, [r7, #8]
2400d7a4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400d7a6:	681b      	ldr	r3, [r3, #0]
2400d7a8:	4a7f      	ldr	r2, [pc, #508]	; (2400d9a8 <I2C_DMAError+0x238>)
2400d7aa:	4293      	cmp	r3, r2
2400d7ac:	d04d      	beq.n	2400d84a <I2C_DMAError+0xda>
2400d7ae:	68bb      	ldr	r3, [r7, #8]
2400d7b0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400d7b2:	681b      	ldr	r3, [r3, #0]
2400d7b4:	4a7d      	ldr	r2, [pc, #500]	; (2400d9ac <I2C_DMAError+0x23c>)
2400d7b6:	4293      	cmp	r3, r2
2400d7b8:	d047      	beq.n	2400d84a <I2C_DMAError+0xda>
2400d7ba:	68bb      	ldr	r3, [r7, #8]
2400d7bc:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400d7be:	681b      	ldr	r3, [r3, #0]
2400d7c0:	4a7b      	ldr	r2, [pc, #492]	; (2400d9b0 <I2C_DMAError+0x240>)
2400d7c2:	4293      	cmp	r3, r2
2400d7c4:	d041      	beq.n	2400d84a <I2C_DMAError+0xda>
2400d7c6:	68bb      	ldr	r3, [r7, #8]
2400d7c8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400d7ca:	681b      	ldr	r3, [r3, #0]
2400d7cc:	4a79      	ldr	r2, [pc, #484]	; (2400d9b4 <I2C_DMAError+0x244>)
2400d7ce:	4293      	cmp	r3, r2
2400d7d0:	d03b      	beq.n	2400d84a <I2C_DMAError+0xda>
2400d7d2:	68bb      	ldr	r3, [r7, #8]
2400d7d4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400d7d6:	681b      	ldr	r3, [r3, #0]
2400d7d8:	4a77      	ldr	r2, [pc, #476]	; (2400d9b8 <I2C_DMAError+0x248>)
2400d7da:	4293      	cmp	r3, r2
2400d7dc:	d035      	beq.n	2400d84a <I2C_DMAError+0xda>
2400d7de:	68bb      	ldr	r3, [r7, #8]
2400d7e0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400d7e2:	681b      	ldr	r3, [r3, #0]
2400d7e4:	4a75      	ldr	r2, [pc, #468]	; (2400d9bc <I2C_DMAError+0x24c>)
2400d7e6:	4293      	cmp	r3, r2
2400d7e8:	d02f      	beq.n	2400d84a <I2C_DMAError+0xda>
2400d7ea:	68bb      	ldr	r3, [r7, #8]
2400d7ec:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400d7ee:	681b      	ldr	r3, [r3, #0]
2400d7f0:	4a73      	ldr	r2, [pc, #460]	; (2400d9c0 <I2C_DMAError+0x250>)
2400d7f2:	4293      	cmp	r3, r2
2400d7f4:	d029      	beq.n	2400d84a <I2C_DMAError+0xda>
2400d7f6:	68bb      	ldr	r3, [r7, #8]
2400d7f8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400d7fa:	681b      	ldr	r3, [r3, #0]
2400d7fc:	4a71      	ldr	r2, [pc, #452]	; (2400d9c4 <I2C_DMAError+0x254>)
2400d7fe:	4293      	cmp	r3, r2
2400d800:	d023      	beq.n	2400d84a <I2C_DMAError+0xda>
2400d802:	68bb      	ldr	r3, [r7, #8]
2400d804:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400d806:	681b      	ldr	r3, [r3, #0]
2400d808:	4a6f      	ldr	r2, [pc, #444]	; (2400d9c8 <I2C_DMAError+0x258>)
2400d80a:	4293      	cmp	r3, r2
2400d80c:	d01d      	beq.n	2400d84a <I2C_DMAError+0xda>
2400d80e:	68bb      	ldr	r3, [r7, #8]
2400d810:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400d812:	681b      	ldr	r3, [r3, #0]
2400d814:	4a6d      	ldr	r2, [pc, #436]	; (2400d9cc <I2C_DMAError+0x25c>)
2400d816:	4293      	cmp	r3, r2
2400d818:	d017      	beq.n	2400d84a <I2C_DMAError+0xda>
2400d81a:	68bb      	ldr	r3, [r7, #8]
2400d81c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400d81e:	681b      	ldr	r3, [r3, #0]
2400d820:	4a6b      	ldr	r2, [pc, #428]	; (2400d9d0 <I2C_DMAError+0x260>)
2400d822:	4293      	cmp	r3, r2
2400d824:	d011      	beq.n	2400d84a <I2C_DMAError+0xda>
2400d826:	68bb      	ldr	r3, [r7, #8]
2400d828:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400d82a:	681b      	ldr	r3, [r3, #0]
2400d82c:	4a69      	ldr	r2, [pc, #420]	; (2400d9d4 <I2C_DMAError+0x264>)
2400d82e:	4293      	cmp	r3, r2
2400d830:	d00b      	beq.n	2400d84a <I2C_DMAError+0xda>
2400d832:	68bb      	ldr	r3, [r7, #8]
2400d834:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400d836:	681b      	ldr	r3, [r3, #0]
2400d838:	4a67      	ldr	r2, [pc, #412]	; (2400d9d8 <I2C_DMAError+0x268>)
2400d83a:	4293      	cmp	r3, r2
2400d83c:	d005      	beq.n	2400d84a <I2C_DMAError+0xda>
2400d83e:	68bb      	ldr	r3, [r7, #8]
2400d840:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400d842:	681b      	ldr	r3, [r3, #0]
2400d844:	4a65      	ldr	r2, [pc, #404]	; (2400d9dc <I2C_DMAError+0x26c>)
2400d846:	4293      	cmp	r3, r2
2400d848:	d109      	bne.n	2400d85e <I2C_DMAError+0xee>
2400d84a:	68bb      	ldr	r3, [r7, #8]
2400d84c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400d84e:	681b      	ldr	r3, [r3, #0]
2400d850:	685b      	ldr	r3, [r3, #4]
2400d852:	2b00      	cmp	r3, #0
2400d854:	bf0c      	ite	eq
2400d856:	2301      	moveq	r3, #1
2400d858:	2300      	movne	r3, #0
2400d85a:	b2db      	uxtb	r3, r3
2400d85c:	e008      	b.n	2400d870 <I2C_DMAError+0x100>
2400d85e:	68bb      	ldr	r3, [r7, #8]
2400d860:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400d862:	681b      	ldr	r3, [r3, #0]
2400d864:	685b      	ldr	r3, [r3, #4]
2400d866:	2b00      	cmp	r3, #0
2400d868:	bf0c      	ite	eq
2400d86a:	2301      	moveq	r3, #1
2400d86c:	2300      	movne	r3, #0
2400d86e:	b2db      	uxtb	r3, r3
2400d870:	2b00      	cmp	r3, #0
2400d872:	d001      	beq.n	2400d878 <I2C_DMAError+0x108>
    {
      treatdmaerror = 1U;
2400d874:	2301      	movs	r3, #1
2400d876:	60fb      	str	r3, [r7, #12]
    }
  }

  if (hi2c->hdmarx != NULL)
2400d878:	68bb      	ldr	r3, [r7, #8]
2400d87a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d87c:	2b00      	cmp	r3, #0
2400d87e:	d076      	beq.n	2400d96e <I2C_DMAError+0x1fe>
  {
    if (__HAL_DMA_GET_COUNTER(hi2c->hdmarx) == 0U)
2400d880:	68bb      	ldr	r3, [r7, #8]
2400d882:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d884:	681b      	ldr	r3, [r3, #0]
2400d886:	4a46      	ldr	r2, [pc, #280]	; (2400d9a0 <I2C_DMAError+0x230>)
2400d888:	4293      	cmp	r3, r2
2400d88a:	d059      	beq.n	2400d940 <I2C_DMAError+0x1d0>
2400d88c:	68bb      	ldr	r3, [r7, #8]
2400d88e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d890:	681b      	ldr	r3, [r3, #0]
2400d892:	4a44      	ldr	r2, [pc, #272]	; (2400d9a4 <I2C_DMAError+0x234>)
2400d894:	4293      	cmp	r3, r2
2400d896:	d053      	beq.n	2400d940 <I2C_DMAError+0x1d0>
2400d898:	68bb      	ldr	r3, [r7, #8]
2400d89a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d89c:	681b      	ldr	r3, [r3, #0]
2400d89e:	4a42      	ldr	r2, [pc, #264]	; (2400d9a8 <I2C_DMAError+0x238>)
2400d8a0:	4293      	cmp	r3, r2
2400d8a2:	d04d      	beq.n	2400d940 <I2C_DMAError+0x1d0>
2400d8a4:	68bb      	ldr	r3, [r7, #8]
2400d8a6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d8a8:	681b      	ldr	r3, [r3, #0]
2400d8aa:	4a40      	ldr	r2, [pc, #256]	; (2400d9ac <I2C_DMAError+0x23c>)
2400d8ac:	4293      	cmp	r3, r2
2400d8ae:	d047      	beq.n	2400d940 <I2C_DMAError+0x1d0>
2400d8b0:	68bb      	ldr	r3, [r7, #8]
2400d8b2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d8b4:	681b      	ldr	r3, [r3, #0]
2400d8b6:	4a3e      	ldr	r2, [pc, #248]	; (2400d9b0 <I2C_DMAError+0x240>)
2400d8b8:	4293      	cmp	r3, r2
2400d8ba:	d041      	beq.n	2400d940 <I2C_DMAError+0x1d0>
2400d8bc:	68bb      	ldr	r3, [r7, #8]
2400d8be:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d8c0:	681b      	ldr	r3, [r3, #0]
2400d8c2:	4a3c      	ldr	r2, [pc, #240]	; (2400d9b4 <I2C_DMAError+0x244>)
2400d8c4:	4293      	cmp	r3, r2
2400d8c6:	d03b      	beq.n	2400d940 <I2C_DMAError+0x1d0>
2400d8c8:	68bb      	ldr	r3, [r7, #8]
2400d8ca:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d8cc:	681b      	ldr	r3, [r3, #0]
2400d8ce:	4a3a      	ldr	r2, [pc, #232]	; (2400d9b8 <I2C_DMAError+0x248>)
2400d8d0:	4293      	cmp	r3, r2
2400d8d2:	d035      	beq.n	2400d940 <I2C_DMAError+0x1d0>
2400d8d4:	68bb      	ldr	r3, [r7, #8]
2400d8d6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d8d8:	681b      	ldr	r3, [r3, #0]
2400d8da:	4a38      	ldr	r2, [pc, #224]	; (2400d9bc <I2C_DMAError+0x24c>)
2400d8dc:	4293      	cmp	r3, r2
2400d8de:	d02f      	beq.n	2400d940 <I2C_DMAError+0x1d0>
2400d8e0:	68bb      	ldr	r3, [r7, #8]
2400d8e2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d8e4:	681b      	ldr	r3, [r3, #0]
2400d8e6:	4a36      	ldr	r2, [pc, #216]	; (2400d9c0 <I2C_DMAError+0x250>)
2400d8e8:	4293      	cmp	r3, r2
2400d8ea:	d029      	beq.n	2400d940 <I2C_DMAError+0x1d0>
2400d8ec:	68bb      	ldr	r3, [r7, #8]
2400d8ee:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d8f0:	681b      	ldr	r3, [r3, #0]
2400d8f2:	4a34      	ldr	r2, [pc, #208]	; (2400d9c4 <I2C_DMAError+0x254>)
2400d8f4:	4293      	cmp	r3, r2
2400d8f6:	d023      	beq.n	2400d940 <I2C_DMAError+0x1d0>
2400d8f8:	68bb      	ldr	r3, [r7, #8]
2400d8fa:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d8fc:	681b      	ldr	r3, [r3, #0]
2400d8fe:	4a32      	ldr	r2, [pc, #200]	; (2400d9c8 <I2C_DMAError+0x258>)
2400d900:	4293      	cmp	r3, r2
2400d902:	d01d      	beq.n	2400d940 <I2C_DMAError+0x1d0>
2400d904:	68bb      	ldr	r3, [r7, #8]
2400d906:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d908:	681b      	ldr	r3, [r3, #0]
2400d90a:	4a30      	ldr	r2, [pc, #192]	; (2400d9cc <I2C_DMAError+0x25c>)
2400d90c:	4293      	cmp	r3, r2
2400d90e:	d017      	beq.n	2400d940 <I2C_DMAError+0x1d0>
2400d910:	68bb      	ldr	r3, [r7, #8]
2400d912:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d914:	681b      	ldr	r3, [r3, #0]
2400d916:	4a2e      	ldr	r2, [pc, #184]	; (2400d9d0 <I2C_DMAError+0x260>)
2400d918:	4293      	cmp	r3, r2
2400d91a:	d011      	beq.n	2400d940 <I2C_DMAError+0x1d0>
2400d91c:	68bb      	ldr	r3, [r7, #8]
2400d91e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d920:	681b      	ldr	r3, [r3, #0]
2400d922:	4a2c      	ldr	r2, [pc, #176]	; (2400d9d4 <I2C_DMAError+0x264>)
2400d924:	4293      	cmp	r3, r2
2400d926:	d00b      	beq.n	2400d940 <I2C_DMAError+0x1d0>
2400d928:	68bb      	ldr	r3, [r7, #8]
2400d92a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d92c:	681b      	ldr	r3, [r3, #0]
2400d92e:	4a2a      	ldr	r2, [pc, #168]	; (2400d9d8 <I2C_DMAError+0x268>)
2400d930:	4293      	cmp	r3, r2
2400d932:	d005      	beq.n	2400d940 <I2C_DMAError+0x1d0>
2400d934:	68bb      	ldr	r3, [r7, #8]
2400d936:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d938:	681b      	ldr	r3, [r3, #0]
2400d93a:	4a28      	ldr	r2, [pc, #160]	; (2400d9dc <I2C_DMAError+0x26c>)
2400d93c:	4293      	cmp	r3, r2
2400d93e:	d109      	bne.n	2400d954 <I2C_DMAError+0x1e4>
2400d940:	68bb      	ldr	r3, [r7, #8]
2400d942:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d944:	681b      	ldr	r3, [r3, #0]
2400d946:	685b      	ldr	r3, [r3, #4]
2400d948:	2b00      	cmp	r3, #0
2400d94a:	bf0c      	ite	eq
2400d94c:	2301      	moveq	r3, #1
2400d94e:	2300      	movne	r3, #0
2400d950:	b2db      	uxtb	r3, r3
2400d952:	e008      	b.n	2400d966 <I2C_DMAError+0x1f6>
2400d954:	68bb      	ldr	r3, [r7, #8]
2400d956:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d958:	681b      	ldr	r3, [r3, #0]
2400d95a:	685b      	ldr	r3, [r3, #4]
2400d95c:	2b00      	cmp	r3, #0
2400d95e:	bf0c      	ite	eq
2400d960:	2301      	moveq	r3, #1
2400d962:	2300      	movne	r3, #0
2400d964:	b2db      	uxtb	r3, r3
2400d966:	2b00      	cmp	r3, #0
2400d968:	d001      	beq.n	2400d96e <I2C_DMAError+0x1fe>
    {
      treatdmaerror = 1U;
2400d96a:	2301      	movs	r3, #1
2400d96c:	60fb      	str	r3, [r7, #12]
    }
  }

  /* Check if a FIFO error is detected, if true normal use case, so no specific action to perform */
  if (!((HAL_DMA_GetError(hdma) == HAL_DMA_ERROR_FE)) && (treatdmaerror != 0U))
2400d96e:	6878      	ldr	r0, [r7, #4]
2400d970:	f7f7 f962 	bl	24004c38 <HAL_DMA_GetError>
2400d974:	4603      	mov	r3, r0
2400d976:	2b02      	cmp	r3, #2
2400d978:	d00e      	beq.n	2400d998 <I2C_DMAError+0x228>
2400d97a:	68fb      	ldr	r3, [r7, #12]
2400d97c:	2b00      	cmp	r3, #0
2400d97e:	d00b      	beq.n	2400d998 <I2C_DMAError+0x228>
  {
    /* Disable Acknowledge */
    hi2c->Instance->CR2 |= I2C_CR2_NACK;
2400d980:	68bb      	ldr	r3, [r7, #8]
2400d982:	681b      	ldr	r3, [r3, #0]
2400d984:	685a      	ldr	r2, [r3, #4]
2400d986:	68bb      	ldr	r3, [r7, #8]
2400d988:	681b      	ldr	r3, [r3, #0]
2400d98a:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
2400d98e:	605a      	str	r2, [r3, #4]

    /* Call the corresponding callback to inform upper layer of End of Transfer */
    I2C_ITError(hi2c, HAL_I2C_ERROR_DMA);
2400d990:	2110      	movs	r1, #16
2400d992:	68b8      	ldr	r0, [r7, #8]
2400d994:	f7ff fc68 	bl	2400d268 <I2C_ITError>
  }
}
2400d998:	bf00      	nop
2400d99a:	3710      	adds	r7, #16
2400d99c:	46bd      	mov	sp, r7
2400d99e:	bd80      	pop	{r7, pc}
2400d9a0:	40020010 	.word	0x40020010
2400d9a4:	40020028 	.word	0x40020028
2400d9a8:	40020040 	.word	0x40020040
2400d9ac:	40020058 	.word	0x40020058
2400d9b0:	40020070 	.word	0x40020070
2400d9b4:	40020088 	.word	0x40020088
2400d9b8:	400200a0 	.word	0x400200a0
2400d9bc:	400200b8 	.word	0x400200b8
2400d9c0:	40020410 	.word	0x40020410
2400d9c4:	40020428 	.word	0x40020428
2400d9c8:	40020440 	.word	0x40020440
2400d9cc:	40020458 	.word	0x40020458
2400d9d0:	40020470 	.word	0x40020470
2400d9d4:	40020488 	.word	0x40020488
2400d9d8:	400204a0 	.word	0x400204a0
2400d9dc:	400204b8 	.word	0x400204b8

2400d9e0 <I2C_DMAAbort>:
  *        (To be called at end of DMA Abort procedure).
  * @param hdma DMA handle.
  * @retval None
  */
static void I2C_DMAAbort(DMA_HandleTypeDef *hdma)
{
2400d9e0:	b580      	push	{r7, lr}
2400d9e2:	b084      	sub	sp, #16
2400d9e4:	af00      	add	r7, sp, #0
2400d9e6:	6078      	str	r0, [r7, #4]
  I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
2400d9e8:	687b      	ldr	r3, [r7, #4]
2400d9ea:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400d9ec:	60fb      	str	r3, [r7, #12]

  /* Reset AbortCpltCallback */
  if (hi2c->hdmatx != NULL)
2400d9ee:	68fb      	ldr	r3, [r7, #12]
2400d9f0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400d9f2:	2b00      	cmp	r3, #0
2400d9f4:	d003      	beq.n	2400d9fe <I2C_DMAAbort+0x1e>
  {
    hi2c->hdmatx->XferAbortCallback = NULL;
2400d9f6:	68fb      	ldr	r3, [r7, #12]
2400d9f8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400d9fa:	2200      	movs	r2, #0
2400d9fc:	651a      	str	r2, [r3, #80]	; 0x50
  }
  if (hi2c->hdmarx != NULL)
2400d9fe:	68fb      	ldr	r3, [r7, #12]
2400da00:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400da02:	2b00      	cmp	r3, #0
2400da04:	d003      	beq.n	2400da0e <I2C_DMAAbort+0x2e>
  {
    hi2c->hdmarx->XferAbortCallback = NULL;
2400da06:	68fb      	ldr	r3, [r7, #12]
2400da08:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400da0a:	2200      	movs	r2, #0
2400da0c:	651a      	str	r2, [r3, #80]	; 0x50
  }

  I2C_TreatErrorCallback(hi2c);
2400da0e:	68f8      	ldr	r0, [r7, #12]
2400da10:	f7ff fcfa 	bl	2400d408 <I2C_TreatErrorCallback>
}
2400da14:	bf00      	nop
2400da16:	3710      	adds	r7, #16
2400da18:	46bd      	mov	sp, r7
2400da1a:	bd80      	pop	{r7, pc}

2400da1c <I2C_WaitOnFlagUntilTimeout>:
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Flag, FlagStatus Status, uint32_t Timeout, uint32_t Tickstart)
{
2400da1c:	b580      	push	{r7, lr}
2400da1e:	b084      	sub	sp, #16
2400da20:	af00      	add	r7, sp, #0
2400da22:	60f8      	str	r0, [r7, #12]
2400da24:	60b9      	str	r1, [r7, #8]
2400da26:	603b      	str	r3, [r7, #0]
2400da28:	4613      	mov	r3, r2
2400da2a:	71fb      	strb	r3, [r7, #7]
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
2400da2c:	e022      	b.n	2400da74 <I2C_WaitOnFlagUntilTimeout+0x58>
  {
    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
2400da2e:	683b      	ldr	r3, [r7, #0]
2400da30:	f1b3 3fff 	cmp.w	r3, #4294967295
2400da34:	d01e      	beq.n	2400da74 <I2C_WaitOnFlagUntilTimeout+0x58>
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
2400da36:	f7f2 ff0b 	bl	24000850 <HAL_GetTick>
2400da3a:	4602      	mov	r2, r0
2400da3c:	69bb      	ldr	r3, [r7, #24]
2400da3e:	1ad3      	subs	r3, r2, r3
2400da40:	683a      	ldr	r2, [r7, #0]
2400da42:	429a      	cmp	r2, r3
2400da44:	d302      	bcc.n	2400da4c <I2C_WaitOnFlagUntilTimeout+0x30>
2400da46:	683b      	ldr	r3, [r7, #0]
2400da48:	2b00      	cmp	r3, #0
2400da4a:	d113      	bne.n	2400da74 <I2C_WaitOnFlagUntilTimeout+0x58>
      {
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
2400da4c:	68fb      	ldr	r3, [r7, #12]
2400da4e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400da50:	f043 0220 	orr.w	r2, r3, #32
2400da54:	68fb      	ldr	r3, [r7, #12]
2400da56:	645a      	str	r2, [r3, #68]	; 0x44
        hi2c->State = HAL_I2C_STATE_READY;
2400da58:	68fb      	ldr	r3, [r7, #12]
2400da5a:	2220      	movs	r2, #32
2400da5c:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
        hi2c->Mode = HAL_I2C_MODE_NONE;
2400da60:	68fb      	ldr	r3, [r7, #12]
2400da62:	2200      	movs	r2, #0
2400da64:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
2400da68:	68fb      	ldr	r3, [r7, #12]
2400da6a:	2200      	movs	r2, #0
2400da6c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
        return HAL_ERROR;
2400da70:	2301      	movs	r3, #1
2400da72:	e00f      	b.n	2400da94 <I2C_WaitOnFlagUntilTimeout+0x78>
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
2400da74:	68fb      	ldr	r3, [r7, #12]
2400da76:	681b      	ldr	r3, [r3, #0]
2400da78:	699a      	ldr	r2, [r3, #24]
2400da7a:	68bb      	ldr	r3, [r7, #8]
2400da7c:	4013      	ands	r3, r2
2400da7e:	68ba      	ldr	r2, [r7, #8]
2400da80:	429a      	cmp	r2, r3
2400da82:	bf0c      	ite	eq
2400da84:	2301      	moveq	r3, #1
2400da86:	2300      	movne	r3, #0
2400da88:	b2db      	uxtb	r3, r3
2400da8a:	461a      	mov	r2, r3
2400da8c:	79fb      	ldrb	r3, [r7, #7]
2400da8e:	429a      	cmp	r2, r3
2400da90:	d0cd      	beq.n	2400da2e <I2C_WaitOnFlagUntilTimeout+0x12>
      }
    }
  }
  return HAL_OK;
2400da92:	2300      	movs	r3, #0
}
2400da94:	4618      	mov	r0, r3
2400da96:	3710      	adds	r7, #16
2400da98:	46bd      	mov	sp, r7
2400da9a:	bd80      	pop	{r7, pc}

2400da9c <I2C_WaitOnTXISFlagUntilTimeout>:
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnTXISFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
{
2400da9c:	b580      	push	{r7, lr}
2400da9e:	b084      	sub	sp, #16
2400daa0:	af00      	add	r7, sp, #0
2400daa2:	60f8      	str	r0, [r7, #12]
2400daa4:	60b9      	str	r1, [r7, #8]
2400daa6:	607a      	str	r2, [r7, #4]
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
2400daa8:	e02c      	b.n	2400db04 <I2C_WaitOnTXISFlagUntilTimeout+0x68>
  {
    /* Check if a NACK is detected */
    if (I2C_IsAcknowledgeFailed(hi2c, Timeout, Tickstart) != HAL_OK)
2400daaa:	687a      	ldr	r2, [r7, #4]
2400daac:	68b9      	ldr	r1, [r7, #8]
2400daae:	68f8      	ldr	r0, [r7, #12]
2400dab0:	f000 f8dc 	bl	2400dc6c <I2C_IsAcknowledgeFailed>
2400dab4:	4603      	mov	r3, r0
2400dab6:	2b00      	cmp	r3, #0
2400dab8:	d001      	beq.n	2400dabe <I2C_WaitOnTXISFlagUntilTimeout+0x22>
    {
      return HAL_ERROR;
2400daba:	2301      	movs	r3, #1
2400dabc:	e02a      	b.n	2400db14 <I2C_WaitOnTXISFlagUntilTimeout+0x78>
    }

    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
2400dabe:	68bb      	ldr	r3, [r7, #8]
2400dac0:	f1b3 3fff 	cmp.w	r3, #4294967295
2400dac4:	d01e      	beq.n	2400db04 <I2C_WaitOnTXISFlagUntilTimeout+0x68>
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
2400dac6:	f7f2 fec3 	bl	24000850 <HAL_GetTick>
2400daca:	4602      	mov	r2, r0
2400dacc:	687b      	ldr	r3, [r7, #4]
2400dace:	1ad3      	subs	r3, r2, r3
2400dad0:	68ba      	ldr	r2, [r7, #8]
2400dad2:	429a      	cmp	r2, r3
2400dad4:	d302      	bcc.n	2400dadc <I2C_WaitOnTXISFlagUntilTimeout+0x40>
2400dad6:	68bb      	ldr	r3, [r7, #8]
2400dad8:	2b00      	cmp	r3, #0
2400dada:	d113      	bne.n	2400db04 <I2C_WaitOnTXISFlagUntilTimeout+0x68>
      {
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
2400dadc:	68fb      	ldr	r3, [r7, #12]
2400dade:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400dae0:	f043 0220 	orr.w	r2, r3, #32
2400dae4:	68fb      	ldr	r3, [r7, #12]
2400dae6:	645a      	str	r2, [r3, #68]	; 0x44
        hi2c->State = HAL_I2C_STATE_READY;
2400dae8:	68fb      	ldr	r3, [r7, #12]
2400daea:	2220      	movs	r2, #32
2400daec:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
        hi2c->Mode = HAL_I2C_MODE_NONE;
2400daf0:	68fb      	ldr	r3, [r7, #12]
2400daf2:	2200      	movs	r2, #0
2400daf4:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
2400daf8:	68fb      	ldr	r3, [r7, #12]
2400dafa:	2200      	movs	r2, #0
2400dafc:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

        return HAL_ERROR;
2400db00:	2301      	movs	r3, #1
2400db02:	e007      	b.n	2400db14 <I2C_WaitOnTXISFlagUntilTimeout+0x78>
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
2400db04:	68fb      	ldr	r3, [r7, #12]
2400db06:	681b      	ldr	r3, [r3, #0]
2400db08:	699b      	ldr	r3, [r3, #24]
2400db0a:	f003 0302 	and.w	r3, r3, #2
2400db0e:	2b02      	cmp	r3, #2
2400db10:	d1cb      	bne.n	2400daaa <I2C_WaitOnTXISFlagUntilTimeout+0xe>
      }
    }
  }
  return HAL_OK;
2400db12:	2300      	movs	r3, #0
}
2400db14:	4618      	mov	r0, r3
2400db16:	3710      	adds	r7, #16
2400db18:	46bd      	mov	sp, r7
2400db1a:	bd80      	pop	{r7, pc}

2400db1c <I2C_WaitOnSTOPFlagUntilTimeout>:
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnSTOPFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
{
2400db1c:	b580      	push	{r7, lr}
2400db1e:	b084      	sub	sp, #16
2400db20:	af00      	add	r7, sp, #0
2400db22:	60f8      	str	r0, [r7, #12]
2400db24:	60b9      	str	r1, [r7, #8]
2400db26:	607a      	str	r2, [r7, #4]
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
2400db28:	e028      	b.n	2400db7c <I2C_WaitOnSTOPFlagUntilTimeout+0x60>
  {
    /* Check if a NACK is detected */
    if (I2C_IsAcknowledgeFailed(hi2c, Timeout, Tickstart) != HAL_OK)
2400db2a:	687a      	ldr	r2, [r7, #4]
2400db2c:	68b9      	ldr	r1, [r7, #8]
2400db2e:	68f8      	ldr	r0, [r7, #12]
2400db30:	f000 f89c 	bl	2400dc6c <I2C_IsAcknowledgeFailed>
2400db34:	4603      	mov	r3, r0
2400db36:	2b00      	cmp	r3, #0
2400db38:	d001      	beq.n	2400db3e <I2C_WaitOnSTOPFlagUntilTimeout+0x22>
    {
      return HAL_ERROR;
2400db3a:	2301      	movs	r3, #1
2400db3c:	e026      	b.n	2400db8c <I2C_WaitOnSTOPFlagUntilTimeout+0x70>
    }

    /* Check for the Timeout */
    if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
2400db3e:	f7f2 fe87 	bl	24000850 <HAL_GetTick>
2400db42:	4602      	mov	r2, r0
2400db44:	687b      	ldr	r3, [r7, #4]
2400db46:	1ad3      	subs	r3, r2, r3
2400db48:	68ba      	ldr	r2, [r7, #8]
2400db4a:	429a      	cmp	r2, r3
2400db4c:	d302      	bcc.n	2400db54 <I2C_WaitOnSTOPFlagUntilTimeout+0x38>
2400db4e:	68bb      	ldr	r3, [r7, #8]
2400db50:	2b00      	cmp	r3, #0
2400db52:	d113      	bne.n	2400db7c <I2C_WaitOnSTOPFlagUntilTimeout+0x60>
    {
      hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
2400db54:	68fb      	ldr	r3, [r7, #12]
2400db56:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400db58:	f043 0220 	orr.w	r2, r3, #32
2400db5c:	68fb      	ldr	r3, [r7, #12]
2400db5e:	645a      	str	r2, [r3, #68]	; 0x44
      hi2c->State = HAL_I2C_STATE_READY;
2400db60:	68fb      	ldr	r3, [r7, #12]
2400db62:	2220      	movs	r2, #32
2400db64:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
      hi2c->Mode = HAL_I2C_MODE_NONE;
2400db68:	68fb      	ldr	r3, [r7, #12]
2400db6a:	2200      	movs	r2, #0
2400db6c:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
2400db70:	68fb      	ldr	r3, [r7, #12]
2400db72:	2200      	movs	r2, #0
2400db74:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

      return HAL_ERROR;
2400db78:	2301      	movs	r3, #1
2400db7a:	e007      	b.n	2400db8c <I2C_WaitOnSTOPFlagUntilTimeout+0x70>
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
2400db7c:	68fb      	ldr	r3, [r7, #12]
2400db7e:	681b      	ldr	r3, [r3, #0]
2400db80:	699b      	ldr	r3, [r3, #24]
2400db82:	f003 0320 	and.w	r3, r3, #32
2400db86:	2b20      	cmp	r3, #32
2400db88:	d1cf      	bne.n	2400db2a <I2C_WaitOnSTOPFlagUntilTimeout+0xe>
    }
  }
  return HAL_OK;
2400db8a:	2300      	movs	r3, #0
}
2400db8c:	4618      	mov	r0, r3
2400db8e:	3710      	adds	r7, #16
2400db90:	46bd      	mov	sp, r7
2400db92:	bd80      	pop	{r7, pc}

2400db94 <I2C_WaitOnRXNEFlagUntilTimeout>:
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnRXNEFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
{
2400db94:	b580      	push	{r7, lr}
2400db96:	b084      	sub	sp, #16
2400db98:	af00      	add	r7, sp, #0
2400db9a:	60f8      	str	r0, [r7, #12]
2400db9c:	60b9      	str	r1, [r7, #8]
2400db9e:	607a      	str	r2, [r7, #4]
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == RESET)
2400dba0:	e055      	b.n	2400dc4e <I2C_WaitOnRXNEFlagUntilTimeout+0xba>
  {
    /* Check if a NACK is detected */
    if (I2C_IsAcknowledgeFailed(hi2c, Timeout, Tickstart) != HAL_OK)
2400dba2:	687a      	ldr	r2, [r7, #4]
2400dba4:	68b9      	ldr	r1, [r7, #8]
2400dba6:	68f8      	ldr	r0, [r7, #12]
2400dba8:	f000 f860 	bl	2400dc6c <I2C_IsAcknowledgeFailed>
2400dbac:	4603      	mov	r3, r0
2400dbae:	2b00      	cmp	r3, #0
2400dbb0:	d001      	beq.n	2400dbb6 <I2C_WaitOnRXNEFlagUntilTimeout+0x22>
    {
      return HAL_ERROR;
2400dbb2:	2301      	movs	r3, #1
2400dbb4:	e053      	b.n	2400dc5e <I2C_WaitOnRXNEFlagUntilTimeout+0xca>
    }

    /* Check if a STOPF is detected */
    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == SET)
2400dbb6:	68fb      	ldr	r3, [r7, #12]
2400dbb8:	681b      	ldr	r3, [r3, #0]
2400dbba:	699b      	ldr	r3, [r3, #24]
2400dbbc:	f003 0320 	and.w	r3, r3, #32
2400dbc0:	2b20      	cmp	r3, #32
2400dbc2:	d129      	bne.n	2400dc18 <I2C_WaitOnRXNEFlagUntilTimeout+0x84>
    {
      /* Check if an RXNE is pending */
      /* Store Last receive data if any */
      if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET) && (hi2c->XferSize > 0U))
2400dbc4:	68fb      	ldr	r3, [r7, #12]
2400dbc6:	681b      	ldr	r3, [r3, #0]
2400dbc8:	699b      	ldr	r3, [r3, #24]
2400dbca:	f003 0304 	and.w	r3, r3, #4
2400dbce:	2b04      	cmp	r3, #4
2400dbd0:	d105      	bne.n	2400dbde <I2C_WaitOnRXNEFlagUntilTimeout+0x4a>
2400dbd2:	68fb      	ldr	r3, [r7, #12]
2400dbd4:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400dbd6:	2b00      	cmp	r3, #0
2400dbd8:	d001      	beq.n	2400dbde <I2C_WaitOnRXNEFlagUntilTimeout+0x4a>
      {
        /* Return HAL_OK */
        /* The Reading of data from RXDR will be done in caller function */
        return HAL_OK;
2400dbda:	2300      	movs	r3, #0
2400dbdc:	e03f      	b.n	2400dc5e <I2C_WaitOnRXNEFlagUntilTimeout+0xca>
      }
      else
      {
        /* Clear STOP Flag */
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
2400dbde:	68fb      	ldr	r3, [r7, #12]
2400dbe0:	681b      	ldr	r3, [r3, #0]
2400dbe2:	2220      	movs	r2, #32
2400dbe4:	61da      	str	r2, [r3, #28]

        /* Clear Configuration Register 2 */
        I2C_RESET_CR2(hi2c);
2400dbe6:	68fb      	ldr	r3, [r7, #12]
2400dbe8:	681b      	ldr	r3, [r3, #0]
2400dbea:	6859      	ldr	r1, [r3, #4]
2400dbec:	68fb      	ldr	r3, [r7, #12]
2400dbee:	681a      	ldr	r2, [r3, #0]
2400dbf0:	4b1d      	ldr	r3, [pc, #116]	; (2400dc68 <I2C_WaitOnRXNEFlagUntilTimeout+0xd4>)
2400dbf2:	400b      	ands	r3, r1
2400dbf4:	6053      	str	r3, [r2, #4]

        hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
2400dbf6:	68fb      	ldr	r3, [r7, #12]
2400dbf8:	2200      	movs	r2, #0
2400dbfa:	645a      	str	r2, [r3, #68]	; 0x44
        hi2c->State = HAL_I2C_STATE_READY;
2400dbfc:	68fb      	ldr	r3, [r7, #12]
2400dbfe:	2220      	movs	r2, #32
2400dc00:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
        hi2c->Mode = HAL_I2C_MODE_NONE;
2400dc04:	68fb      	ldr	r3, [r7, #12]
2400dc06:	2200      	movs	r2, #0
2400dc08:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
2400dc0c:	68fb      	ldr	r3, [r7, #12]
2400dc0e:	2200      	movs	r2, #0
2400dc10:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

        return HAL_ERROR;
2400dc14:	2301      	movs	r3, #1
2400dc16:	e022      	b.n	2400dc5e <I2C_WaitOnRXNEFlagUntilTimeout+0xca>
      }
    }

    /* Check for the Timeout */
    if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
2400dc18:	f7f2 fe1a 	bl	24000850 <HAL_GetTick>
2400dc1c:	4602      	mov	r2, r0
2400dc1e:	687b      	ldr	r3, [r7, #4]
2400dc20:	1ad3      	subs	r3, r2, r3
2400dc22:	68ba      	ldr	r2, [r7, #8]
2400dc24:	429a      	cmp	r2, r3
2400dc26:	d302      	bcc.n	2400dc2e <I2C_WaitOnRXNEFlagUntilTimeout+0x9a>
2400dc28:	68bb      	ldr	r3, [r7, #8]
2400dc2a:	2b00      	cmp	r3, #0
2400dc2c:	d10f      	bne.n	2400dc4e <I2C_WaitOnRXNEFlagUntilTimeout+0xba>
    {
      hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
2400dc2e:	68fb      	ldr	r3, [r7, #12]
2400dc30:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400dc32:	f043 0220 	orr.w	r2, r3, #32
2400dc36:	68fb      	ldr	r3, [r7, #12]
2400dc38:	645a      	str	r2, [r3, #68]	; 0x44
      hi2c->State = HAL_I2C_STATE_READY;
2400dc3a:	68fb      	ldr	r3, [r7, #12]
2400dc3c:	2220      	movs	r2, #32
2400dc3e:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
2400dc42:	68fb      	ldr	r3, [r7, #12]
2400dc44:	2200      	movs	r2, #0
2400dc46:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

      return HAL_ERROR;
2400dc4a:	2301      	movs	r3, #1
2400dc4c:	e007      	b.n	2400dc5e <I2C_WaitOnRXNEFlagUntilTimeout+0xca>
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == RESET)
2400dc4e:	68fb      	ldr	r3, [r7, #12]
2400dc50:	681b      	ldr	r3, [r3, #0]
2400dc52:	699b      	ldr	r3, [r3, #24]
2400dc54:	f003 0304 	and.w	r3, r3, #4
2400dc58:	2b04      	cmp	r3, #4
2400dc5a:	d1a2      	bne.n	2400dba2 <I2C_WaitOnRXNEFlagUntilTimeout+0xe>
    }
  }
  return HAL_OK;
2400dc5c:	2300      	movs	r3, #0
}
2400dc5e:	4618      	mov	r0, r3
2400dc60:	3710      	adds	r7, #16
2400dc62:	46bd      	mov	sp, r7
2400dc64:	bd80      	pop	{r7, pc}
2400dc66:	bf00      	nop
2400dc68:	fe00e800 	.word	0xfe00e800

2400dc6c <I2C_IsAcknowledgeFailed>:
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_IsAcknowledgeFailed(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
{
2400dc6c:	b580      	push	{r7, lr}
2400dc6e:	b084      	sub	sp, #16
2400dc70:	af00      	add	r7, sp, #0
2400dc72:	60f8      	str	r0, [r7, #12]
2400dc74:	60b9      	str	r1, [r7, #8]
2400dc76:	607a      	str	r2, [r7, #4]
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
2400dc78:	68fb      	ldr	r3, [r7, #12]
2400dc7a:	681b      	ldr	r3, [r3, #0]
2400dc7c:	699b      	ldr	r3, [r3, #24]
2400dc7e:	f003 0310 	and.w	r3, r3, #16
2400dc82:	2b10      	cmp	r3, #16
2400dc84:	d151      	bne.n	2400dd2a <I2C_IsAcknowledgeFailed+0xbe>
  {
    /* Wait until STOP Flag is reset */
    /* AutoEnd should be initiate after AF */
    while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
2400dc86:	e022      	b.n	2400dcce <I2C_IsAcknowledgeFailed+0x62>
    {
      /* Check for the Timeout */
      if (Timeout != HAL_MAX_DELAY)
2400dc88:	68bb      	ldr	r3, [r7, #8]
2400dc8a:	f1b3 3fff 	cmp.w	r3, #4294967295
2400dc8e:	d01e      	beq.n	2400dcce <I2C_IsAcknowledgeFailed+0x62>
      {
        if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
2400dc90:	f7f2 fdde 	bl	24000850 <HAL_GetTick>
2400dc94:	4602      	mov	r2, r0
2400dc96:	687b      	ldr	r3, [r7, #4]
2400dc98:	1ad3      	subs	r3, r2, r3
2400dc9a:	68ba      	ldr	r2, [r7, #8]
2400dc9c:	429a      	cmp	r2, r3
2400dc9e:	d302      	bcc.n	2400dca6 <I2C_IsAcknowledgeFailed+0x3a>
2400dca0:	68bb      	ldr	r3, [r7, #8]
2400dca2:	2b00      	cmp	r3, #0
2400dca4:	d113      	bne.n	2400dcce <I2C_IsAcknowledgeFailed+0x62>
        {
          hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
2400dca6:	68fb      	ldr	r3, [r7, #12]
2400dca8:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400dcaa:	f043 0220 	orr.w	r2, r3, #32
2400dcae:	68fb      	ldr	r3, [r7, #12]
2400dcb0:	645a      	str	r2, [r3, #68]	; 0x44
          hi2c->State = HAL_I2C_STATE_READY;
2400dcb2:	68fb      	ldr	r3, [r7, #12]
2400dcb4:	2220      	movs	r2, #32
2400dcb6:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
          hi2c->Mode = HAL_I2C_MODE_NONE;
2400dcba:	68fb      	ldr	r3, [r7, #12]
2400dcbc:	2200      	movs	r2, #0
2400dcbe:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

          /* Process Unlocked */
          __HAL_UNLOCK(hi2c);
2400dcc2:	68fb      	ldr	r3, [r7, #12]
2400dcc4:	2200      	movs	r2, #0
2400dcc6:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

          return HAL_ERROR;
2400dcca:	2301      	movs	r3, #1
2400dccc:	e02e      	b.n	2400dd2c <I2C_IsAcknowledgeFailed+0xc0>
    while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
2400dcce:	68fb      	ldr	r3, [r7, #12]
2400dcd0:	681b      	ldr	r3, [r3, #0]
2400dcd2:	699b      	ldr	r3, [r3, #24]
2400dcd4:	f003 0320 	and.w	r3, r3, #32
2400dcd8:	2b20      	cmp	r3, #32
2400dcda:	d1d5      	bne.n	2400dc88 <I2C_IsAcknowledgeFailed+0x1c>
        }
      }
    }

    /* Clear NACKF Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
2400dcdc:	68fb      	ldr	r3, [r7, #12]
2400dcde:	681b      	ldr	r3, [r3, #0]
2400dce0:	2210      	movs	r2, #16
2400dce2:	61da      	str	r2, [r3, #28]

    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
2400dce4:	68fb      	ldr	r3, [r7, #12]
2400dce6:	681b      	ldr	r3, [r3, #0]
2400dce8:	2220      	movs	r2, #32
2400dcea:	61da      	str	r2, [r3, #28]

    /* Flush TX register */
    I2C_Flush_TXDR(hi2c);
2400dcec:	68f8      	ldr	r0, [r7, #12]
2400dcee:	f7ff fbb2 	bl	2400d456 <I2C_Flush_TXDR>

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
2400dcf2:	68fb      	ldr	r3, [r7, #12]
2400dcf4:	681b      	ldr	r3, [r3, #0]
2400dcf6:	6859      	ldr	r1, [r3, #4]
2400dcf8:	68fb      	ldr	r3, [r7, #12]
2400dcfa:	681a      	ldr	r2, [r3, #0]
2400dcfc:	4b0d      	ldr	r3, [pc, #52]	; (2400dd34 <I2C_IsAcknowledgeFailed+0xc8>)
2400dcfe:	400b      	ands	r3, r1
2400dd00:	6053      	str	r3, [r2, #4]

    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
2400dd02:	68fb      	ldr	r3, [r7, #12]
2400dd04:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400dd06:	f043 0204 	orr.w	r2, r3, #4
2400dd0a:	68fb      	ldr	r3, [r7, #12]
2400dd0c:	645a      	str	r2, [r3, #68]	; 0x44
    hi2c->State = HAL_I2C_STATE_READY;
2400dd0e:	68fb      	ldr	r3, [r7, #12]
2400dd10:	2220      	movs	r2, #32
2400dd12:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode = HAL_I2C_MODE_NONE;
2400dd16:	68fb      	ldr	r3, [r7, #12]
2400dd18:	2200      	movs	r2, #0
2400dd1a:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2400dd1e:	68fb      	ldr	r3, [r7, #12]
2400dd20:	2200      	movs	r2, #0
2400dd22:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    return HAL_ERROR;
2400dd26:	2301      	movs	r3, #1
2400dd28:	e000      	b.n	2400dd2c <I2C_IsAcknowledgeFailed+0xc0>
  }
  return HAL_OK;
2400dd2a:	2300      	movs	r3, #0
}
2400dd2c:	4618      	mov	r0, r3
2400dd2e:	3710      	adds	r7, #16
2400dd30:	46bd      	mov	sp, r7
2400dd32:	bd80      	pop	{r7, pc}
2400dd34:	fe00e800 	.word	0xfe00e800

2400dd38 <I2C_TransferConfig>:
  *     @arg @ref I2C_GENERATE_START_READ Generate Restart for read request.
  *     @arg @ref I2C_GENERATE_START_WRITE Generate Restart for write request.
  * @retval None
  */
static void I2C_TransferConfig(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t Size, uint32_t Mode, uint32_t Request)
{
2400dd38:	b480      	push	{r7}
2400dd3a:	b085      	sub	sp, #20
2400dd3c:	af00      	add	r7, sp, #0
2400dd3e:	60f8      	str	r0, [r7, #12]
2400dd40:	607b      	str	r3, [r7, #4]
2400dd42:	460b      	mov	r3, r1
2400dd44:	817b      	strh	r3, [r7, #10]
2400dd46:	4613      	mov	r3, r2
2400dd48:	727b      	strb	r3, [r7, #9]
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));

  /* update CR2 register */
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
2400dd4a:	68fb      	ldr	r3, [r7, #12]
2400dd4c:	681b      	ldr	r3, [r3, #0]
2400dd4e:	685a      	ldr	r2, [r3, #4]
2400dd50:	69bb      	ldr	r3, [r7, #24]
2400dd52:	0d5b      	lsrs	r3, r3, #21
2400dd54:	f403 6180 	and.w	r1, r3, #1024	; 0x400
2400dd58:	4b0d      	ldr	r3, [pc, #52]	; (2400dd90 <I2C_TransferConfig+0x58>)
2400dd5a:	430b      	orrs	r3, r1
2400dd5c:	43db      	mvns	r3, r3
2400dd5e:	ea02 0103 	and.w	r1, r2, r3
2400dd62:	897b      	ldrh	r3, [r7, #10]
2400dd64:	f3c3 0209 	ubfx	r2, r3, #0, #10
2400dd68:	7a7b      	ldrb	r3, [r7, #9]
2400dd6a:	041b      	lsls	r3, r3, #16
2400dd6c:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
2400dd70:	431a      	orrs	r2, r3
2400dd72:	687b      	ldr	r3, [r7, #4]
2400dd74:	431a      	orrs	r2, r3
2400dd76:	69bb      	ldr	r3, [r7, #24]
2400dd78:	431a      	orrs	r2, r3
2400dd7a:	68fb      	ldr	r3, [r7, #12]
2400dd7c:	681b      	ldr	r3, [r3, #0]
2400dd7e:	430a      	orrs	r2, r1
2400dd80:	605a      	str	r2, [r3, #4]
             (uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | (((uint32_t)Size << I2C_CR2_NBYTES_Pos) & I2C_CR2_NBYTES) | (uint32_t)Mode | (uint32_t)Request));
}
2400dd82:	bf00      	nop
2400dd84:	3714      	adds	r7, #20
2400dd86:	46bd      	mov	sp, r7
2400dd88:	f85d 7b04 	ldr.w	r7, [sp], #4
2400dd8c:	4770      	bx	lr
2400dd8e:	bf00      	nop
2400dd90:	03ff63ff 	.word	0x03ff63ff

2400dd94 <I2C_Enable_IRQ>:
  *                the configuration information for the specified I2C.
  * @param  InterruptRequest Value of @ref I2C_Interrupt_configuration_definition.
  * @retval None
  */
static void I2C_Enable_IRQ(I2C_HandleTypeDef *hi2c, uint16_t InterruptRequest)
{
2400dd94:	b480      	push	{r7}
2400dd96:	b085      	sub	sp, #20
2400dd98:	af00      	add	r7, sp, #0
2400dd9a:	6078      	str	r0, [r7, #4]
2400dd9c:	460b      	mov	r3, r1
2400dd9e:	807b      	strh	r3, [r7, #2]
  uint32_t tmpisr = 0U;
2400dda0:	2300      	movs	r3, #0
2400dda2:	60fb      	str	r3, [r7, #12]

  if ((hi2c->XferISR == I2C_Master_ISR_DMA) || \
2400dda4:	687b      	ldr	r3, [r7, #4]
2400dda6:	6b5b      	ldr	r3, [r3, #52]	; 0x34
2400dda8:	4a2a      	ldr	r2, [pc, #168]	; (2400de54 <I2C_Enable_IRQ+0xc0>)
2400ddaa:	4293      	cmp	r3, r2
2400ddac:	d004      	beq.n	2400ddb8 <I2C_Enable_IRQ+0x24>
      (hi2c->XferISR == I2C_Slave_ISR_DMA))
2400ddae:	687b      	ldr	r3, [r7, #4]
2400ddb0:	6b5b      	ldr	r3, [r3, #52]	; 0x34
  if ((hi2c->XferISR == I2C_Master_ISR_DMA) || \
2400ddb2:	4a29      	ldr	r2, [pc, #164]	; (2400de58 <I2C_Enable_IRQ+0xc4>)
2400ddb4:	4293      	cmp	r3, r2
2400ddb6:	d11d      	bne.n	2400ddf4 <I2C_Enable_IRQ+0x60>
  {
    if ((InterruptRequest & I2C_XFER_LISTEN_IT) == I2C_XFER_LISTEN_IT)
2400ddb8:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
2400ddbc:	2b00      	cmp	r3, #0
2400ddbe:	da03      	bge.n	2400ddc8 <I2C_Enable_IRQ+0x34>
    {
      /* Enable ERR, STOP, NACK and ADDR interrupts */
      tmpisr |= I2C_IT_ADDRI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_ERRI;
2400ddc0:	68fb      	ldr	r3, [r7, #12]
2400ddc2:	f043 03b8 	orr.w	r3, r3, #184	; 0xb8
2400ddc6:	60fb      	str	r3, [r7, #12]
    }

    if (InterruptRequest == I2C_XFER_ERROR_IT)
2400ddc8:	887b      	ldrh	r3, [r7, #2]
2400ddca:	2b10      	cmp	r3, #16
2400ddcc:	d103      	bne.n	2400ddd6 <I2C_Enable_IRQ+0x42>
    {
      /* Enable ERR and NACK interrupts */
      tmpisr |= I2C_IT_ERRI | I2C_IT_NACKI;
2400ddce:	68fb      	ldr	r3, [r7, #12]
2400ddd0:	f043 0390 	orr.w	r3, r3, #144	; 0x90
2400ddd4:	60fb      	str	r3, [r7, #12]
    }

    if (InterruptRequest == I2C_XFER_CPLT_IT)
2400ddd6:	887b      	ldrh	r3, [r7, #2]
2400ddd8:	2b20      	cmp	r3, #32
2400ddda:	d103      	bne.n	2400dde4 <I2C_Enable_IRQ+0x50>
    {
      /* Enable STOP interrupts */
      tmpisr |= (I2C_IT_STOPI | I2C_IT_TCI);
2400dddc:	68fb      	ldr	r3, [r7, #12]
2400ddde:	f043 0360 	orr.w	r3, r3, #96	; 0x60
2400dde2:	60fb      	str	r3, [r7, #12]
    }

    if (InterruptRequest == I2C_XFER_RELOAD_IT)
2400dde4:	887b      	ldrh	r3, [r7, #2]
2400dde6:	2b40      	cmp	r3, #64	; 0x40
2400dde8:	d125      	bne.n	2400de36 <I2C_Enable_IRQ+0xa2>
    {
      /* Enable TC interrupts */
      tmpisr |= I2C_IT_TCI;
2400ddea:	68fb      	ldr	r3, [r7, #12]
2400ddec:	f043 0340 	orr.w	r3, r3, #64	; 0x40
2400ddf0:	60fb      	str	r3, [r7, #12]
    if (InterruptRequest == I2C_XFER_RELOAD_IT)
2400ddf2:	e020      	b.n	2400de36 <I2C_Enable_IRQ+0xa2>
    }
  }
  else
  {
    if ((InterruptRequest & I2C_XFER_LISTEN_IT) == I2C_XFER_LISTEN_IT)
2400ddf4:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
2400ddf8:	2b00      	cmp	r3, #0
2400ddfa:	da03      	bge.n	2400de04 <I2C_Enable_IRQ+0x70>
    {
      /* Enable ERR, STOP, NACK, and ADDR interrupts */
      tmpisr |= I2C_IT_ADDRI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_ERRI;
2400ddfc:	68fb      	ldr	r3, [r7, #12]
2400ddfe:	f043 03b8 	orr.w	r3, r3, #184	; 0xb8
2400de02:	60fb      	str	r3, [r7, #12]
    }

    if ((InterruptRequest & I2C_XFER_TX_IT) == I2C_XFER_TX_IT)
2400de04:	887b      	ldrh	r3, [r7, #2]
2400de06:	f003 0301 	and.w	r3, r3, #1
2400de0a:	2b00      	cmp	r3, #0
2400de0c:	d003      	beq.n	2400de16 <I2C_Enable_IRQ+0x82>
    {
      /* Enable ERR, TC, STOP, NACK and RXI interrupts */
      tmpisr |= I2C_IT_ERRI | I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_TXI;
2400de0e:	68fb      	ldr	r3, [r7, #12]
2400de10:	f043 03f2 	orr.w	r3, r3, #242	; 0xf2
2400de14:	60fb      	str	r3, [r7, #12]
    }

    if ((InterruptRequest & I2C_XFER_RX_IT) == I2C_XFER_RX_IT)
2400de16:	887b      	ldrh	r3, [r7, #2]
2400de18:	f003 0302 	and.w	r3, r3, #2
2400de1c:	2b00      	cmp	r3, #0
2400de1e:	d003      	beq.n	2400de28 <I2C_Enable_IRQ+0x94>
    {
      /* Enable ERR, TC, STOP, NACK and TXI interrupts */
      tmpisr |= I2C_IT_ERRI | I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_RXI;
2400de20:	68fb      	ldr	r3, [r7, #12]
2400de22:	f043 03f4 	orr.w	r3, r3, #244	; 0xf4
2400de26:	60fb      	str	r3, [r7, #12]
    }

    if (InterruptRequest == I2C_XFER_CPLT_IT)
2400de28:	887b      	ldrh	r3, [r7, #2]
2400de2a:	2b20      	cmp	r3, #32
2400de2c:	d103      	bne.n	2400de36 <I2C_Enable_IRQ+0xa2>
    {
      /* Enable STOP interrupts */
      tmpisr |= I2C_IT_STOPI;
2400de2e:	68fb      	ldr	r3, [r7, #12]
2400de30:	f043 0320 	orr.w	r3, r3, #32
2400de34:	60fb      	str	r3, [r7, #12]
  }

  /* Enable interrupts only at the end */
  /* to avoid the risk of I2C interrupt handle execution before */
  /* all interrupts requested done */
  __HAL_I2C_ENABLE_IT(hi2c, tmpisr);
2400de36:	687b      	ldr	r3, [r7, #4]
2400de38:	681b      	ldr	r3, [r3, #0]
2400de3a:	6819      	ldr	r1, [r3, #0]
2400de3c:	687b      	ldr	r3, [r7, #4]
2400de3e:	681b      	ldr	r3, [r3, #0]
2400de40:	68fa      	ldr	r2, [r7, #12]
2400de42:	430a      	orrs	r2, r1
2400de44:	601a      	str	r2, [r3, #0]
}
2400de46:	bf00      	nop
2400de48:	3714      	adds	r7, #20
2400de4a:	46bd      	mov	sp, r7
2400de4c:	f85d 7b04 	ldr.w	r7, [sp], #4
2400de50:	4770      	bx	lr
2400de52:	bf00      	nop
2400de54:	2400c307 	.word	0x2400c307
2400de58:	2400c4ed 	.word	0x2400c4ed

2400de5c <I2C_Disable_IRQ>:
  *                the configuration information for the specified I2C.
  * @param  InterruptRequest Value of @ref I2C_Interrupt_configuration_definition.
  * @retval None
  */
static void I2C_Disable_IRQ(I2C_HandleTypeDef *hi2c, uint16_t InterruptRequest)
{
2400de5c:	b480      	push	{r7}
2400de5e:	b085      	sub	sp, #20
2400de60:	af00      	add	r7, sp, #0
2400de62:	6078      	str	r0, [r7, #4]
2400de64:	460b      	mov	r3, r1
2400de66:	807b      	strh	r3, [r7, #2]
  uint32_t tmpisr = 0U;
2400de68:	2300      	movs	r3, #0
2400de6a:	60fb      	str	r3, [r7, #12]

  if ((InterruptRequest & I2C_XFER_TX_IT) == I2C_XFER_TX_IT)
2400de6c:	887b      	ldrh	r3, [r7, #2]
2400de6e:	f003 0301 	and.w	r3, r3, #1
2400de72:	2b00      	cmp	r3, #0
2400de74:	d00f      	beq.n	2400de96 <I2C_Disable_IRQ+0x3a>
  {
    /* Disable TC and TXI interrupts */
    tmpisr |= I2C_IT_TCI | I2C_IT_TXI;
2400de76:	68fb      	ldr	r3, [r7, #12]
2400de78:	f043 0342 	orr.w	r3, r3, #66	; 0x42
2400de7c:	60fb      	str	r3, [r7, #12]

    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
2400de7e:	687b      	ldr	r3, [r7, #4]
2400de80:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400de84:	b2db      	uxtb	r3, r3
2400de86:	f003 0328 	and.w	r3, r3, #40	; 0x28
2400de8a:	2b28      	cmp	r3, #40	; 0x28
2400de8c:	d003      	beq.n	2400de96 <I2C_Disable_IRQ+0x3a>
    {
      /* Disable NACK and STOP interrupts */
      tmpisr |= I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_ERRI;
2400de8e:	68fb      	ldr	r3, [r7, #12]
2400de90:	f043 03b0 	orr.w	r3, r3, #176	; 0xb0
2400de94:	60fb      	str	r3, [r7, #12]
    }
  }

  if ((InterruptRequest & I2C_XFER_RX_IT) == I2C_XFER_RX_IT)
2400de96:	887b      	ldrh	r3, [r7, #2]
2400de98:	f003 0302 	and.w	r3, r3, #2
2400de9c:	2b00      	cmp	r3, #0
2400de9e:	d00f      	beq.n	2400dec0 <I2C_Disable_IRQ+0x64>
  {
    /* Disable TC and RXI interrupts */
    tmpisr |= I2C_IT_TCI | I2C_IT_RXI;
2400dea0:	68fb      	ldr	r3, [r7, #12]
2400dea2:	f043 0344 	orr.w	r3, r3, #68	; 0x44
2400dea6:	60fb      	str	r3, [r7, #12]

    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
2400dea8:	687b      	ldr	r3, [r7, #4]
2400deaa:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400deae:	b2db      	uxtb	r3, r3
2400deb0:	f003 0328 	and.w	r3, r3, #40	; 0x28
2400deb4:	2b28      	cmp	r3, #40	; 0x28
2400deb6:	d003      	beq.n	2400dec0 <I2C_Disable_IRQ+0x64>
    {
      /* Disable NACK and STOP interrupts */
      tmpisr |= I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_ERRI;
2400deb8:	68fb      	ldr	r3, [r7, #12]
2400deba:	f043 03b0 	orr.w	r3, r3, #176	; 0xb0
2400debe:	60fb      	str	r3, [r7, #12]
    }
  }

  if ((InterruptRequest & I2C_XFER_LISTEN_IT) == I2C_XFER_LISTEN_IT)
2400dec0:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
2400dec4:	2b00      	cmp	r3, #0
2400dec6:	da03      	bge.n	2400ded0 <I2C_Disable_IRQ+0x74>
  {
    /* Disable ADDR, NACK and STOP interrupts */
    tmpisr |= I2C_IT_ADDRI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_ERRI;
2400dec8:	68fb      	ldr	r3, [r7, #12]
2400deca:	f043 03b8 	orr.w	r3, r3, #184	; 0xb8
2400dece:	60fb      	str	r3, [r7, #12]
  }

  if (InterruptRequest == I2C_XFER_ERROR_IT)
2400ded0:	887b      	ldrh	r3, [r7, #2]
2400ded2:	2b10      	cmp	r3, #16
2400ded4:	d103      	bne.n	2400dede <I2C_Disable_IRQ+0x82>
  {
    /* Enable ERR and NACK interrupts */
    tmpisr |= I2C_IT_ERRI | I2C_IT_NACKI;
2400ded6:	68fb      	ldr	r3, [r7, #12]
2400ded8:	f043 0390 	orr.w	r3, r3, #144	; 0x90
2400dedc:	60fb      	str	r3, [r7, #12]
  }

  if (InterruptRequest == I2C_XFER_CPLT_IT)
2400dede:	887b      	ldrh	r3, [r7, #2]
2400dee0:	2b20      	cmp	r3, #32
2400dee2:	d103      	bne.n	2400deec <I2C_Disable_IRQ+0x90>
  {
    /* Enable STOP interrupts */
    tmpisr |= I2C_IT_STOPI;
2400dee4:	68fb      	ldr	r3, [r7, #12]
2400dee6:	f043 0320 	orr.w	r3, r3, #32
2400deea:	60fb      	str	r3, [r7, #12]
  }

  if (InterruptRequest == I2C_XFER_RELOAD_IT)
2400deec:	887b      	ldrh	r3, [r7, #2]
2400deee:	2b40      	cmp	r3, #64	; 0x40
2400def0:	d103      	bne.n	2400defa <I2C_Disable_IRQ+0x9e>
  {
    /* Enable TC interrupts */
    tmpisr |= I2C_IT_TCI;
2400def2:	68fb      	ldr	r3, [r7, #12]
2400def4:	f043 0340 	orr.w	r3, r3, #64	; 0x40
2400def8:	60fb      	str	r3, [r7, #12]
  }

  /* Disable interrupts only at the end */
  /* to avoid a breaking situation like at "t" time */
  /* all disable interrupts request are not done */
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
2400defa:	687b      	ldr	r3, [r7, #4]
2400defc:	681b      	ldr	r3, [r3, #0]
2400defe:	6819      	ldr	r1, [r3, #0]
2400df00:	68fb      	ldr	r3, [r7, #12]
2400df02:	43da      	mvns	r2, r3
2400df04:	687b      	ldr	r3, [r7, #4]
2400df06:	681b      	ldr	r3, [r3, #0]
2400df08:	400a      	ands	r2, r1
2400df0a:	601a      	str	r2, [r3, #0]
}
2400df0c:	bf00      	nop
2400df0e:	3714      	adds	r7, #20
2400df10:	46bd      	mov	sp, r7
2400df12:	f85d 7b04 	ldr.w	r7, [sp], #4
2400df16:	4770      	bx	lr

2400df18 <I2C_ConvertOtherXferOptions>:
  * @brief  Convert I2Cx OTHER_xxx XferOptions to functionnal XferOptions.
  * @param  hi2c I2C handle.
  * @retval None
  */
static void I2C_ConvertOtherXferOptions(I2C_HandleTypeDef *hi2c)
{
2400df18:	b480      	push	{r7}
2400df1a:	b083      	sub	sp, #12
2400df1c:	af00      	add	r7, sp, #0
2400df1e:	6078      	str	r0, [r7, #4]
  /* if user set XferOptions to I2C_OTHER_FRAME            */
  /* it request implicitly to generate a restart condition */
  /* set XferOptions to I2C_FIRST_FRAME                    */
  if (hi2c->XferOptions == I2C_OTHER_FRAME)
2400df20:	687b      	ldr	r3, [r7, #4]
2400df22:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2400df24:	2baa      	cmp	r3, #170	; 0xaa
2400df26:	d103      	bne.n	2400df30 <I2C_ConvertOtherXferOptions+0x18>
  {
    hi2c->XferOptions = I2C_FIRST_FRAME;
2400df28:	687b      	ldr	r3, [r7, #4]
2400df2a:	2200      	movs	r2, #0
2400df2c:	62da      	str	r2, [r3, #44]	; 0x2c
  }
  else
  {
    /* Nothing to do */
  }
}
2400df2e:	e008      	b.n	2400df42 <I2C_ConvertOtherXferOptions+0x2a>
  else if (hi2c->XferOptions == I2C_OTHER_AND_LAST_FRAME)
2400df30:	687b      	ldr	r3, [r7, #4]
2400df32:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2400df34:	f5b3 4f2a 	cmp.w	r3, #43520	; 0xaa00
2400df38:	d103      	bne.n	2400df42 <I2C_ConvertOtherXferOptions+0x2a>
    hi2c->XferOptions = I2C_FIRST_AND_LAST_FRAME;
2400df3a:	687b      	ldr	r3, [r7, #4]
2400df3c:	f04f 7200 	mov.w	r2, #33554432	; 0x2000000
2400df40:	62da      	str	r2, [r3, #44]	; 0x2c
}
2400df42:	bf00      	nop
2400df44:	370c      	adds	r7, #12
2400df46:	46bd      	mov	sp, r7
2400df48:	f85d 7b04 	ldr.w	r7, [sp], #4
2400df4c:	4770      	bx	lr

2400df4e <HAL_I2CEx_ConfigAnalogFilter>:
  *                the configuration information for the specified I2Cx peripheral.
  * @param  AnalogFilter New state of the Analog filter.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2CEx_ConfigAnalogFilter(I2C_HandleTypeDef *hi2c, uint32_t AnalogFilter)
{
2400df4e:	b480      	push	{r7}
2400df50:	b083      	sub	sp, #12
2400df52:	af00      	add	r7, sp, #0
2400df54:	6078      	str	r0, [r7, #4]
2400df56:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_I2C_ANALOG_FILTER(AnalogFilter));

  if (hi2c->State == HAL_I2C_STATE_READY)
2400df58:	687b      	ldr	r3, [r7, #4]
2400df5a:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400df5e:	b2db      	uxtb	r3, r3
2400df60:	2b20      	cmp	r3, #32
2400df62:	d138      	bne.n	2400dfd6 <HAL_I2CEx_ConfigAnalogFilter+0x88>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
2400df64:	687b      	ldr	r3, [r7, #4]
2400df66:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400df6a:	2b01      	cmp	r3, #1
2400df6c:	d101      	bne.n	2400df72 <HAL_I2CEx_ConfigAnalogFilter+0x24>
2400df6e:	2302      	movs	r3, #2
2400df70:	e032      	b.n	2400dfd8 <HAL_I2CEx_ConfigAnalogFilter+0x8a>
2400df72:	687b      	ldr	r3, [r7, #4]
2400df74:	2201      	movs	r2, #1
2400df76:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State = HAL_I2C_STATE_BUSY;
2400df7a:	687b      	ldr	r3, [r7, #4]
2400df7c:	2224      	movs	r2, #36	; 0x24
2400df7e:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
2400df82:	687b      	ldr	r3, [r7, #4]
2400df84:	681b      	ldr	r3, [r3, #0]
2400df86:	681a      	ldr	r2, [r3, #0]
2400df88:	687b      	ldr	r3, [r7, #4]
2400df8a:	681b      	ldr	r3, [r3, #0]
2400df8c:	f022 0201 	bic.w	r2, r2, #1
2400df90:	601a      	str	r2, [r3, #0]

    /* Reset I2Cx ANOFF bit */
    hi2c->Instance->CR1 &= ~(I2C_CR1_ANFOFF);
2400df92:	687b      	ldr	r3, [r7, #4]
2400df94:	681b      	ldr	r3, [r3, #0]
2400df96:	681a      	ldr	r2, [r3, #0]
2400df98:	687b      	ldr	r3, [r7, #4]
2400df9a:	681b      	ldr	r3, [r3, #0]
2400df9c:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
2400dfa0:	601a      	str	r2, [r3, #0]

    /* Set analog filter bit*/
    hi2c->Instance->CR1 |= AnalogFilter;
2400dfa2:	687b      	ldr	r3, [r7, #4]
2400dfa4:	681b      	ldr	r3, [r3, #0]
2400dfa6:	6819      	ldr	r1, [r3, #0]
2400dfa8:	687b      	ldr	r3, [r7, #4]
2400dfaa:	681b      	ldr	r3, [r3, #0]
2400dfac:	683a      	ldr	r2, [r7, #0]
2400dfae:	430a      	orrs	r2, r1
2400dfb0:	601a      	str	r2, [r3, #0]

    __HAL_I2C_ENABLE(hi2c);
2400dfb2:	687b      	ldr	r3, [r7, #4]
2400dfb4:	681b      	ldr	r3, [r3, #0]
2400dfb6:	681a      	ldr	r2, [r3, #0]
2400dfb8:	687b      	ldr	r3, [r7, #4]
2400dfba:	681b      	ldr	r3, [r3, #0]
2400dfbc:	f042 0201 	orr.w	r2, r2, #1
2400dfc0:	601a      	str	r2, [r3, #0]

    hi2c->State = HAL_I2C_STATE_READY;
2400dfc2:	687b      	ldr	r3, [r7, #4]
2400dfc4:	2220      	movs	r2, #32
2400dfc6:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2400dfca:	687b      	ldr	r3, [r7, #4]
2400dfcc:	2200      	movs	r2, #0
2400dfce:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    return HAL_OK;
2400dfd2:	2300      	movs	r3, #0
2400dfd4:	e000      	b.n	2400dfd8 <HAL_I2CEx_ConfigAnalogFilter+0x8a>
  }
  else
  {
    return HAL_BUSY;
2400dfd6:	2302      	movs	r3, #2
  }
}
2400dfd8:	4618      	mov	r0, r3
2400dfda:	370c      	adds	r7, #12
2400dfdc:	46bd      	mov	sp, r7
2400dfde:	f85d 7b04 	ldr.w	r7, [sp], #4
2400dfe2:	4770      	bx	lr

2400dfe4 <HAL_I2CEx_ConfigDigitalFilter>:
  *                the configuration information for the specified I2Cx peripheral.
  * @param  DigitalFilter Coefficient of digital noise filter between Min_Data=0x00 and Max_Data=0x0F.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2CEx_ConfigDigitalFilter(I2C_HandleTypeDef *hi2c, uint32_t DigitalFilter)
{
2400dfe4:	b480      	push	{r7}
2400dfe6:	b085      	sub	sp, #20
2400dfe8:	af00      	add	r7, sp, #0
2400dfea:	6078      	str	r0, [r7, #4]
2400dfec:	6039      	str	r1, [r7, #0]

  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_I2C_DIGITAL_FILTER(DigitalFilter));

  if (hi2c->State == HAL_I2C_STATE_READY)
2400dfee:	687b      	ldr	r3, [r7, #4]
2400dff0:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400dff4:	b2db      	uxtb	r3, r3
2400dff6:	2b20      	cmp	r3, #32
2400dff8:	d139      	bne.n	2400e06e <HAL_I2CEx_ConfigDigitalFilter+0x8a>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
2400dffa:	687b      	ldr	r3, [r7, #4]
2400dffc:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400e000:	2b01      	cmp	r3, #1
2400e002:	d101      	bne.n	2400e008 <HAL_I2CEx_ConfigDigitalFilter+0x24>
2400e004:	2302      	movs	r3, #2
2400e006:	e033      	b.n	2400e070 <HAL_I2CEx_ConfigDigitalFilter+0x8c>
2400e008:	687b      	ldr	r3, [r7, #4]
2400e00a:	2201      	movs	r2, #1
2400e00c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State = HAL_I2C_STATE_BUSY;
2400e010:	687b      	ldr	r3, [r7, #4]
2400e012:	2224      	movs	r2, #36	; 0x24
2400e014:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
2400e018:	687b      	ldr	r3, [r7, #4]
2400e01a:	681b      	ldr	r3, [r3, #0]
2400e01c:	681a      	ldr	r2, [r3, #0]
2400e01e:	687b      	ldr	r3, [r7, #4]
2400e020:	681b      	ldr	r3, [r3, #0]
2400e022:	f022 0201 	bic.w	r2, r2, #1
2400e026:	601a      	str	r2, [r3, #0]

    /* Get the old register value */
    tmpreg = hi2c->Instance->CR1;
2400e028:	687b      	ldr	r3, [r7, #4]
2400e02a:	681b      	ldr	r3, [r3, #0]
2400e02c:	681b      	ldr	r3, [r3, #0]
2400e02e:	60fb      	str	r3, [r7, #12]

    /* Reset I2Cx DNF bits [11:8] */
    tmpreg &= ~(I2C_CR1_DNF);
2400e030:	68fb      	ldr	r3, [r7, #12]
2400e032:	f423 6370 	bic.w	r3, r3, #3840	; 0xf00
2400e036:	60fb      	str	r3, [r7, #12]

    /* Set I2Cx DNF coefficient */
    tmpreg |= DigitalFilter << 8U;
2400e038:	683b      	ldr	r3, [r7, #0]
2400e03a:	021b      	lsls	r3, r3, #8
2400e03c:	68fa      	ldr	r2, [r7, #12]
2400e03e:	4313      	orrs	r3, r2
2400e040:	60fb      	str	r3, [r7, #12]

    /* Store the new register value */
    hi2c->Instance->CR1 = tmpreg;
2400e042:	687b      	ldr	r3, [r7, #4]
2400e044:	681b      	ldr	r3, [r3, #0]
2400e046:	68fa      	ldr	r2, [r7, #12]
2400e048:	601a      	str	r2, [r3, #0]

    __HAL_I2C_ENABLE(hi2c);
2400e04a:	687b      	ldr	r3, [r7, #4]
2400e04c:	681b      	ldr	r3, [r3, #0]
2400e04e:	681a      	ldr	r2, [r3, #0]
2400e050:	687b      	ldr	r3, [r7, #4]
2400e052:	681b      	ldr	r3, [r3, #0]
2400e054:	f042 0201 	orr.w	r2, r2, #1
2400e058:	601a      	str	r2, [r3, #0]

    hi2c->State = HAL_I2C_STATE_READY;
2400e05a:	687b      	ldr	r3, [r7, #4]
2400e05c:	2220      	movs	r2, #32
2400e05e:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2400e062:	687b      	ldr	r3, [r7, #4]
2400e064:	2200      	movs	r2, #0
2400e066:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    return HAL_OK;
2400e06a:	2300      	movs	r3, #0
2400e06c:	e000      	b.n	2400e070 <HAL_I2CEx_ConfigDigitalFilter+0x8c>
  }
  else
  {
    return HAL_BUSY;
2400e06e:	2302      	movs	r3, #2
  }
}
2400e070:	4618      	mov	r0, r3
2400e072:	3714      	adds	r7, #20
2400e074:	46bd      	mov	sp, r7
2400e076:	f85d 7b04 	ldr.w	r7, [sp], #4
2400e07a:	4770      	bx	lr

2400e07c <HAL_I2CEx_EnableWakeUp>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2Cx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2CEx_EnableWakeUp(I2C_HandleTypeDef *hi2c)
{
2400e07c:	b480      	push	{r7}
2400e07e:	b083      	sub	sp, #12
2400e080:	af00      	add	r7, sp, #0
2400e082:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_I2C_WAKEUP_FROMSTOP_INSTANCE(hi2c->Instance));

  if (hi2c->State == HAL_I2C_STATE_READY)
2400e084:	687b      	ldr	r3, [r7, #4]
2400e086:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400e08a:	b2db      	uxtb	r3, r3
2400e08c:	2b20      	cmp	r3, #32
2400e08e:	d130      	bne.n	2400e0f2 <HAL_I2CEx_EnableWakeUp+0x76>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
2400e090:	687b      	ldr	r3, [r7, #4]
2400e092:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400e096:	2b01      	cmp	r3, #1
2400e098:	d101      	bne.n	2400e09e <HAL_I2CEx_EnableWakeUp+0x22>
2400e09a:	2302      	movs	r3, #2
2400e09c:	e02a      	b.n	2400e0f4 <HAL_I2CEx_EnableWakeUp+0x78>
2400e09e:	687b      	ldr	r3, [r7, #4]
2400e0a0:	2201      	movs	r2, #1
2400e0a2:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State = HAL_I2C_STATE_BUSY;
2400e0a6:	687b      	ldr	r3, [r7, #4]
2400e0a8:	2224      	movs	r2, #36	; 0x24
2400e0aa:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
2400e0ae:	687b      	ldr	r3, [r7, #4]
2400e0b0:	681b      	ldr	r3, [r3, #0]
2400e0b2:	681a      	ldr	r2, [r3, #0]
2400e0b4:	687b      	ldr	r3, [r7, #4]
2400e0b6:	681b      	ldr	r3, [r3, #0]
2400e0b8:	f022 0201 	bic.w	r2, r2, #1
2400e0bc:	601a      	str	r2, [r3, #0]

    /* Enable wakeup from stop mode */
    hi2c->Instance->CR1 |= I2C_CR1_WUPEN;
2400e0be:	687b      	ldr	r3, [r7, #4]
2400e0c0:	681b      	ldr	r3, [r3, #0]
2400e0c2:	681a      	ldr	r2, [r3, #0]
2400e0c4:	687b      	ldr	r3, [r7, #4]
2400e0c6:	681b      	ldr	r3, [r3, #0]
2400e0c8:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
2400e0cc:	601a      	str	r2, [r3, #0]

    __HAL_I2C_ENABLE(hi2c);
2400e0ce:	687b      	ldr	r3, [r7, #4]
2400e0d0:	681b      	ldr	r3, [r3, #0]
2400e0d2:	681a      	ldr	r2, [r3, #0]
2400e0d4:	687b      	ldr	r3, [r7, #4]
2400e0d6:	681b      	ldr	r3, [r3, #0]
2400e0d8:	f042 0201 	orr.w	r2, r2, #1
2400e0dc:	601a      	str	r2, [r3, #0]

    hi2c->State = HAL_I2C_STATE_READY;
2400e0de:	687b      	ldr	r3, [r7, #4]
2400e0e0:	2220      	movs	r2, #32
2400e0e2:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2400e0e6:	687b      	ldr	r3, [r7, #4]
2400e0e8:	2200      	movs	r2, #0
2400e0ea:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    return HAL_OK;
2400e0ee:	2300      	movs	r3, #0
2400e0f0:	e000      	b.n	2400e0f4 <HAL_I2CEx_EnableWakeUp+0x78>
  }
  else
  {
    return HAL_BUSY;
2400e0f2:	2302      	movs	r3, #2
  }
}
2400e0f4:	4618      	mov	r0, r3
2400e0f6:	370c      	adds	r7, #12
2400e0f8:	46bd      	mov	sp, r7
2400e0fa:	f85d 7b04 	ldr.w	r7, [sp], #4
2400e0fe:	4770      	bx	lr

2400e100 <HAL_I2CEx_DisableWakeUp>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2Cx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2CEx_DisableWakeUp(I2C_HandleTypeDef *hi2c)
{
2400e100:	b480      	push	{r7}
2400e102:	b083      	sub	sp, #12
2400e104:	af00      	add	r7, sp, #0
2400e106:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_I2C_WAKEUP_FROMSTOP_INSTANCE(hi2c->Instance));

  if (hi2c->State == HAL_I2C_STATE_READY)
2400e108:	687b      	ldr	r3, [r7, #4]
2400e10a:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400e10e:	b2db      	uxtb	r3, r3
2400e110:	2b20      	cmp	r3, #32
2400e112:	d130      	bne.n	2400e176 <HAL_I2CEx_DisableWakeUp+0x76>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
2400e114:	687b      	ldr	r3, [r7, #4]
2400e116:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400e11a:	2b01      	cmp	r3, #1
2400e11c:	d101      	bne.n	2400e122 <HAL_I2CEx_DisableWakeUp+0x22>
2400e11e:	2302      	movs	r3, #2
2400e120:	e02a      	b.n	2400e178 <HAL_I2CEx_DisableWakeUp+0x78>
2400e122:	687b      	ldr	r3, [r7, #4]
2400e124:	2201      	movs	r2, #1
2400e126:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State = HAL_I2C_STATE_BUSY;
2400e12a:	687b      	ldr	r3, [r7, #4]
2400e12c:	2224      	movs	r2, #36	; 0x24
2400e12e:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
2400e132:	687b      	ldr	r3, [r7, #4]
2400e134:	681b      	ldr	r3, [r3, #0]
2400e136:	681a      	ldr	r2, [r3, #0]
2400e138:	687b      	ldr	r3, [r7, #4]
2400e13a:	681b      	ldr	r3, [r3, #0]
2400e13c:	f022 0201 	bic.w	r2, r2, #1
2400e140:	601a      	str	r2, [r3, #0]

    /* Enable wakeup from stop mode */
    hi2c->Instance->CR1 &= ~(I2C_CR1_WUPEN);
2400e142:	687b      	ldr	r3, [r7, #4]
2400e144:	681b      	ldr	r3, [r3, #0]
2400e146:	681a      	ldr	r2, [r3, #0]
2400e148:	687b      	ldr	r3, [r7, #4]
2400e14a:	681b      	ldr	r3, [r3, #0]
2400e14c:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
2400e150:	601a      	str	r2, [r3, #0]

    __HAL_I2C_ENABLE(hi2c);
2400e152:	687b      	ldr	r3, [r7, #4]
2400e154:	681b      	ldr	r3, [r3, #0]
2400e156:	681a      	ldr	r2, [r3, #0]
2400e158:	687b      	ldr	r3, [r7, #4]
2400e15a:	681b      	ldr	r3, [r3, #0]
2400e15c:	f042 0201 	orr.w	r2, r2, #1
2400e160:	601a      	str	r2, [r3, #0]

    hi2c->State = HAL_I2C_STATE_READY;
2400e162:	687b      	ldr	r3, [r7, #4]
2400e164:	2220      	movs	r2, #32
2400e166:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2400e16a:	687b      	ldr	r3, [r7, #4]
2400e16c:	2200      	movs	r2, #0
2400e16e:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    return HAL_OK;
2400e172:	2300      	movs	r3, #0
2400e174:	e000      	b.n	2400e178 <HAL_I2CEx_DisableWakeUp+0x78>
  }
  else
  {
    return HAL_BUSY;
2400e176:	2302      	movs	r3, #2
  }
}
2400e178:	4618      	mov	r0, r3
2400e17a:	370c      	adds	r7, #12
2400e17c:	46bd      	mov	sp, r7
2400e17e:	f85d 7b04 	ldr.w	r7, [sp], #4
2400e182:	4770      	bx	lr

2400e184 <HAL_I2CEx_EnableFastModePlus>:
  * @note  For all I2C4 pins fast mode plus driving capability can be enabled
  *        only by using I2C_FASTMODEPLUS_I2C4 parameter.
  * @retval None
  */
void HAL_I2CEx_EnableFastModePlus(uint32_t ConfigFastModePlus)
{
2400e184:	b480      	push	{r7}
2400e186:	b085      	sub	sp, #20
2400e188:	af00      	add	r7, sp, #0
2400e18a:	6078      	str	r0, [r7, #4]
  /* Check the parameter */
  assert_param(IS_I2C_FASTMODEPLUS(ConfigFastModePlus));

  /* Enable SYSCFG clock */
  __HAL_RCC_SYSCFG_CLK_ENABLE();
2400e18c:	4b0d      	ldr	r3, [pc, #52]	; (2400e1c4 <HAL_I2CEx_EnableFastModePlus+0x40>)
2400e18e:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
2400e192:	4a0c      	ldr	r2, [pc, #48]	; (2400e1c4 <HAL_I2CEx_EnableFastModePlus+0x40>)
2400e194:	f043 0302 	orr.w	r3, r3, #2
2400e198:	f8c2 30f4 	str.w	r3, [r2, #244]	; 0xf4
2400e19c:	4b09      	ldr	r3, [pc, #36]	; (2400e1c4 <HAL_I2CEx_EnableFastModePlus+0x40>)
2400e19e:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
2400e1a2:	f003 0302 	and.w	r3, r3, #2
2400e1a6:	60fb      	str	r3, [r7, #12]
2400e1a8:	68fb      	ldr	r3, [r7, #12]

  /* Enable fast mode plus driving capability for selected pin */
  SET_BIT(SYSCFG->PMCR, (uint32_t)ConfigFastModePlus);
2400e1aa:	4b07      	ldr	r3, [pc, #28]	; (2400e1c8 <HAL_I2CEx_EnableFastModePlus+0x44>)
2400e1ac:	685a      	ldr	r2, [r3, #4]
2400e1ae:	4906      	ldr	r1, [pc, #24]	; (2400e1c8 <HAL_I2CEx_EnableFastModePlus+0x44>)
2400e1b0:	687b      	ldr	r3, [r7, #4]
2400e1b2:	4313      	orrs	r3, r2
2400e1b4:	604b      	str	r3, [r1, #4]
}
2400e1b6:	bf00      	nop
2400e1b8:	3714      	adds	r7, #20
2400e1ba:	46bd      	mov	sp, r7
2400e1bc:	f85d 7b04 	ldr.w	r7, [sp], #4
2400e1c0:	4770      	bx	lr
2400e1c2:	bf00      	nop
2400e1c4:	58024400 	.word	0x58024400
2400e1c8:	58000400 	.word	0x58000400

2400e1cc <HAL_I2CEx_DisableFastModePlus>:
  * @note  For all I2C4 pins fast mode plus driving capability can be disabled
  *        only by using I2C_FASTMODEPLUS_I2C4 parameter.
  * @retval None
  */
void HAL_I2CEx_DisableFastModePlus(uint32_t ConfigFastModePlus)
{
2400e1cc:	b480      	push	{r7}
2400e1ce:	b085      	sub	sp, #20
2400e1d0:	af00      	add	r7, sp, #0
2400e1d2:	6078      	str	r0, [r7, #4]
  /* Check the parameter */
  assert_param(IS_I2C_FASTMODEPLUS(ConfigFastModePlus));

  /* Enable SYSCFG clock */
  __HAL_RCC_SYSCFG_CLK_ENABLE();
2400e1d4:	4b0d      	ldr	r3, [pc, #52]	; (2400e20c <HAL_I2CEx_DisableFastModePlus+0x40>)
2400e1d6:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
2400e1da:	4a0c      	ldr	r2, [pc, #48]	; (2400e20c <HAL_I2CEx_DisableFastModePlus+0x40>)
2400e1dc:	f043 0302 	orr.w	r3, r3, #2
2400e1e0:	f8c2 30f4 	str.w	r3, [r2, #244]	; 0xf4
2400e1e4:	4b09      	ldr	r3, [pc, #36]	; (2400e20c <HAL_I2CEx_DisableFastModePlus+0x40>)
2400e1e6:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
2400e1ea:	f003 0302 	and.w	r3, r3, #2
2400e1ee:	60fb      	str	r3, [r7, #12]
2400e1f0:	68fb      	ldr	r3, [r7, #12]

  /* Disable fast mode plus driving capability for selected pin */
  CLEAR_BIT(SYSCFG->PMCR, (uint32_t)ConfigFastModePlus);
2400e1f2:	4b07      	ldr	r3, [pc, #28]	; (2400e210 <HAL_I2CEx_DisableFastModePlus+0x44>)
2400e1f4:	685a      	ldr	r2, [r3, #4]
2400e1f6:	687b      	ldr	r3, [r7, #4]
2400e1f8:	43db      	mvns	r3, r3
2400e1fa:	4905      	ldr	r1, [pc, #20]	; (2400e210 <HAL_I2CEx_DisableFastModePlus+0x44>)
2400e1fc:	4013      	ands	r3, r2
2400e1fe:	604b      	str	r3, [r1, #4]
}
2400e200:	bf00      	nop
2400e202:	3714      	adds	r7, #20
2400e204:	46bd      	mov	sp, r7
2400e206:	f85d 7b04 	ldr.w	r7, [sp], #4
2400e20a:	4770      	bx	lr
2400e20c:	58024400 	.word	0x58024400
2400e210:	58000400 	.word	0x58000400

2400e214 <HAL_MDMA_Init>:
  * @param  hmdma: Pointer to a MDMA_HandleTypeDef structure that contains
  *               the configuration information for the specified MDMA Channel.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_MDMA_Init(MDMA_HandleTypeDef *hmdma)
{
2400e214:	b580      	push	{r7, lr}
2400e216:	b084      	sub	sp, #16
2400e218:	af00      	add	r7, sp, #0
2400e21a:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = HAL_GetTick();
2400e21c:	f7f2 fb18 	bl	24000850 <HAL_GetTick>
2400e220:	60f8      	str	r0, [r7, #12]

  /* Check the MDMA peripheral handle */
  if(hmdma == NULL)
2400e222:	687b      	ldr	r3, [r7, #4]
2400e224:	2b00      	cmp	r3, #0
2400e226:	d101      	bne.n	2400e22c <HAL_MDMA_Init+0x18>
  {
    return HAL_ERROR;
2400e228:	2301      	movs	r3, #1
2400e22a:	e03b      	b.n	2400e2a4 <HAL_MDMA_Init+0x90>
  assert_param(IS_MDMA_BLOCK_ADDR_OFFSET(hmdma->Init.SourceBlockAddressOffset));
  assert_param(IS_MDMA_BLOCK_ADDR_OFFSET(hmdma->Init.DestBlockAddressOffset));


  /* Allocate lock resource */
  __HAL_UNLOCK(hmdma);
2400e22c:	687b      	ldr	r3, [r7, #4]
2400e22e:	2200      	movs	r2, #0
2400e230:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  /* Change MDMA peripheral state */
  hmdma->State = HAL_MDMA_STATE_BUSY;
2400e234:	687b      	ldr	r3, [r7, #4]
2400e236:	2202      	movs	r2, #2
2400e238:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Disable the MDMA channel */
  __HAL_MDMA_DISABLE(hmdma);
2400e23c:	687b      	ldr	r3, [r7, #4]
2400e23e:	681b      	ldr	r3, [r3, #0]
2400e240:	68da      	ldr	r2, [r3, #12]
2400e242:	687b      	ldr	r3, [r7, #4]
2400e244:	681b      	ldr	r3, [r3, #0]
2400e246:	f022 0201 	bic.w	r2, r2, #1
2400e24a:	60da      	str	r2, [r3, #12]

  /* Check if the MDMA channel is effectively disabled */
  while((hmdma->Instance->CCR & MDMA_CCR_EN) != 0U)
2400e24c:	e00f      	b.n	2400e26e <HAL_MDMA_Init+0x5a>
  {
    /* Check for the Timeout */
    if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_MDMA_ABORT)
2400e24e:	f7f2 faff 	bl	24000850 <HAL_GetTick>
2400e252:	4602      	mov	r2, r0
2400e254:	68fb      	ldr	r3, [r7, #12]
2400e256:	1ad3      	subs	r3, r2, r3
2400e258:	2b05      	cmp	r3, #5
2400e25a:	d908      	bls.n	2400e26e <HAL_MDMA_Init+0x5a>
    {
      /* Update error code */
      hmdma->ErrorCode = HAL_MDMA_ERROR_TIMEOUT;
2400e25c:	687b      	ldr	r3, [r7, #4]
2400e25e:	2240      	movs	r2, #64	; 0x40
2400e260:	669a      	str	r2, [r3, #104]	; 0x68

      /* Change the MDMA state */
      hmdma->State = HAL_MDMA_STATE_ERROR;
2400e262:	687b      	ldr	r3, [r7, #4]
2400e264:	2203      	movs	r2, #3
2400e266:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

      return HAL_ERROR;
2400e26a:	2301      	movs	r3, #1
2400e26c:	e01a      	b.n	2400e2a4 <HAL_MDMA_Init+0x90>
  while((hmdma->Instance->CCR & MDMA_CCR_EN) != 0U)
2400e26e:	687b      	ldr	r3, [r7, #4]
2400e270:	681b      	ldr	r3, [r3, #0]
2400e272:	68db      	ldr	r3, [r3, #12]
2400e274:	f003 0301 	and.w	r3, r3, #1
2400e278:	2b00      	cmp	r3, #0
2400e27a:	d1e8      	bne.n	2400e24e <HAL_MDMA_Init+0x3a>
    }
  }

  /* Initialize the MDMA channel registers */
  MDMA_Init(hmdma);
2400e27c:	6878      	ldr	r0, [r7, #4]
2400e27e:	f001 f89b 	bl	2400f3b8 <MDMA_Init>

  /* Reset the MDMA first/last linkedlist node addresses and node counter */
  hmdma->FirstLinkedListNodeAddress  = 0;
2400e282:	687b      	ldr	r3, [r7, #4]
2400e284:	2200      	movs	r2, #0
2400e286:	65da      	str	r2, [r3, #92]	; 0x5c
  hmdma->LastLinkedListNodeAddress   = 0;
2400e288:	687b      	ldr	r3, [r7, #4]
2400e28a:	2200      	movs	r2, #0
2400e28c:	661a      	str	r2, [r3, #96]	; 0x60
  hmdma->LinkedListNodeCounter  = 0;
2400e28e:	687b      	ldr	r3, [r7, #4]
2400e290:	2200      	movs	r2, #0
2400e292:	665a      	str	r2, [r3, #100]	; 0x64

  /* Initialize the error code */
  hmdma->ErrorCode = HAL_MDMA_ERROR_NONE;
2400e294:	687b      	ldr	r3, [r7, #4]
2400e296:	2200      	movs	r2, #0
2400e298:	669a      	str	r2, [r3, #104]	; 0x68

  /* Initialize the MDMA state */
  hmdma->State = HAL_MDMA_STATE_READY;
2400e29a:	687b      	ldr	r3, [r7, #4]
2400e29c:	2201      	movs	r2, #1
2400e29e:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  return HAL_OK;
2400e2a2:	2300      	movs	r3, #0
}
2400e2a4:	4618      	mov	r0, r3
2400e2a6:	3710      	adds	r7, #16
2400e2a8:	46bd      	mov	sp, r7
2400e2aa:	bd80      	pop	{r7, pc}

2400e2ac <HAL_MDMA_DeInit>:
  * @param  hmdma: pointer to a MDMA_HandleTypeDef structure that contains
  *               the configuration information for the specified MDMA Channel.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_MDMA_DeInit(MDMA_HandleTypeDef *hmdma)
{
2400e2ac:	b480      	push	{r7}
2400e2ae:	b083      	sub	sp, #12
2400e2b0:	af00      	add	r7, sp, #0
2400e2b2:	6078      	str	r0, [r7, #4]

  /* Check the MDMA peripheral handle */
  if(hmdma == NULL)
2400e2b4:	687b      	ldr	r3, [r7, #4]
2400e2b6:	2b00      	cmp	r3, #0
2400e2b8:	d101      	bne.n	2400e2be <HAL_MDMA_DeInit+0x12>
  {
    return HAL_ERROR;
2400e2ba:	2301      	movs	r3, #1
2400e2bc:	e048      	b.n	2400e350 <HAL_MDMA_DeInit+0xa4>
  }

  /* Disable the selected MDMA Channelx */
  __HAL_MDMA_DISABLE(hmdma);
2400e2be:	687b      	ldr	r3, [r7, #4]
2400e2c0:	681b      	ldr	r3, [r3, #0]
2400e2c2:	68da      	ldr	r2, [r3, #12]
2400e2c4:	687b      	ldr	r3, [r7, #4]
2400e2c6:	681b      	ldr	r3, [r3, #0]
2400e2c8:	f022 0201 	bic.w	r2, r2, #1
2400e2cc:	60da      	str	r2, [r3, #12]

  /* Reset MDMA Channel control register */
  hmdma->Instance->CCR  = 0;
2400e2ce:	687b      	ldr	r3, [r7, #4]
2400e2d0:	681b      	ldr	r3, [r3, #0]
2400e2d2:	2200      	movs	r2, #0
2400e2d4:	60da      	str	r2, [r3, #12]
  hmdma->Instance->CTCR = 0;
2400e2d6:	687b      	ldr	r3, [r7, #4]
2400e2d8:	681b      	ldr	r3, [r3, #0]
2400e2da:	2200      	movs	r2, #0
2400e2dc:	611a      	str	r2, [r3, #16]
  hmdma->Instance->CBNDTR = 0;
2400e2de:	687b      	ldr	r3, [r7, #4]
2400e2e0:	681b      	ldr	r3, [r3, #0]
2400e2e2:	2200      	movs	r2, #0
2400e2e4:	615a      	str	r2, [r3, #20]
  hmdma->Instance->CSAR = 0;
2400e2e6:	687b      	ldr	r3, [r7, #4]
2400e2e8:	681b      	ldr	r3, [r3, #0]
2400e2ea:	2200      	movs	r2, #0
2400e2ec:	619a      	str	r2, [r3, #24]
  hmdma->Instance->CDAR = 0;
2400e2ee:	687b      	ldr	r3, [r7, #4]
2400e2f0:	681b      	ldr	r3, [r3, #0]
2400e2f2:	2200      	movs	r2, #0
2400e2f4:	61da      	str	r2, [r3, #28]
  hmdma->Instance->CBRUR = 0;
2400e2f6:	687b      	ldr	r3, [r7, #4]
2400e2f8:	681b      	ldr	r3, [r3, #0]
2400e2fa:	2200      	movs	r2, #0
2400e2fc:	621a      	str	r2, [r3, #32]
  hmdma->Instance->CLAR = 0;
2400e2fe:	687b      	ldr	r3, [r7, #4]
2400e300:	681b      	ldr	r3, [r3, #0]
2400e302:	2200      	movs	r2, #0
2400e304:	625a      	str	r2, [r3, #36]	; 0x24
  hmdma->Instance->CTBR = 0;
2400e306:	687b      	ldr	r3, [r7, #4]
2400e308:	681b      	ldr	r3, [r3, #0]
2400e30a:	2200      	movs	r2, #0
2400e30c:	629a      	str	r2, [r3, #40]	; 0x28
  hmdma->Instance->CMAR = 0;
2400e30e:	687b      	ldr	r3, [r7, #4]
2400e310:	681b      	ldr	r3, [r3, #0]
2400e312:	2200      	movs	r2, #0
2400e314:	631a      	str	r2, [r3, #48]	; 0x30
  hmdma->Instance->CMDR = 0;
2400e316:	687b      	ldr	r3, [r7, #4]
2400e318:	681b      	ldr	r3, [r3, #0]
2400e31a:	2200      	movs	r2, #0
2400e31c:	635a      	str	r2, [r3, #52]	; 0x34

  /* Clear all flags */
  __HAL_MDMA_CLEAR_FLAG(hmdma,(MDMA_FLAG_TE | MDMA_FLAG_CTC | MDMA_FLAG_BRT | MDMA_FLAG_BT | MDMA_FLAG_BFTC));
2400e31e:	687b      	ldr	r3, [r7, #4]
2400e320:	681b      	ldr	r3, [r3, #0]
2400e322:	221f      	movs	r2, #31
2400e324:	605a      	str	r2, [r3, #4]

  /* Reset the  MDMA first/last linkedlist node addresses and node counter */
  hmdma->FirstLinkedListNodeAddress  = 0;
2400e326:	687b      	ldr	r3, [r7, #4]
2400e328:	2200      	movs	r2, #0
2400e32a:	65da      	str	r2, [r3, #92]	; 0x5c
  hmdma->LastLinkedListNodeAddress   = 0;
2400e32c:	687b      	ldr	r3, [r7, #4]
2400e32e:	2200      	movs	r2, #0
2400e330:	661a      	str	r2, [r3, #96]	; 0x60
  hmdma->LinkedListNodeCounter  = 0;
2400e332:	687b      	ldr	r3, [r7, #4]
2400e334:	2200      	movs	r2, #0
2400e336:	665a      	str	r2, [r3, #100]	; 0x64

  /* Initialize the error code */
  hmdma->ErrorCode = HAL_MDMA_ERROR_NONE;
2400e338:	687b      	ldr	r3, [r7, #4]
2400e33a:	2200      	movs	r2, #0
2400e33c:	669a      	str	r2, [r3, #104]	; 0x68

  /* Initialize the MDMA state */
  hmdma->State = HAL_MDMA_STATE_RESET;
2400e33e:	687b      	ldr	r3, [r7, #4]
2400e340:	2200      	movs	r2, #0
2400e342:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Release Lock */
  __HAL_UNLOCK(hmdma);
2400e346:	687b      	ldr	r3, [r7, #4]
2400e348:	2200      	movs	r2, #0
2400e34a:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  return HAL_OK;
2400e34e:	2300      	movs	r3, #0
}
2400e350:	4618      	mov	r0, r3
2400e352:	370c      	adds	r7, #12
2400e354:	46bd      	mov	sp, r7
2400e356:	f85d 7b04 	ldr.w	r7, [sp], #4
2400e35a:	4770      	bx	lr

2400e35c <HAL_MDMA_ConfigPostRequestMask>:
  * @param  MaskData:    specifies the value to be written to MaskAddress after a request is served.
  *                      MaskAddress and MaskData could be used to automatically clear a peripheral flag when the request is served.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_MDMA_ConfigPostRequestMask(MDMA_HandleTypeDef *hmdma, uint32_t MaskAddress, uint32_t MaskData)
{
2400e35c:	b480      	push	{r7}
2400e35e:	b087      	sub	sp, #28
2400e360:	af00      	add	r7, sp, #0
2400e362:	60f8      	str	r0, [r7, #12]
2400e364:	60b9      	str	r1, [r7, #8]
2400e366:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef  status = HAL_OK;
2400e368:	2300      	movs	r3, #0
2400e36a:	75fb      	strb	r3, [r7, #23]

  /* Check the MDMA peripheral handle */
  if(hmdma == NULL)
2400e36c:	68fb      	ldr	r3, [r7, #12]
2400e36e:	2b00      	cmp	r3, #0
2400e370:	d101      	bne.n	2400e376 <HAL_MDMA_ConfigPostRequestMask+0x1a>
  {
    return HAL_ERROR;
2400e372:	2301      	movs	r3, #1
2400e374:	e03e      	b.n	2400e3f4 <HAL_MDMA_ConfigPostRequestMask+0x98>
  }

  /* Process locked */
  __HAL_LOCK(hmdma);
2400e376:	68fb      	ldr	r3, [r7, #12]
2400e378:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
2400e37c:	2b01      	cmp	r3, #1
2400e37e:	d101      	bne.n	2400e384 <HAL_MDMA_ConfigPostRequestMask+0x28>
2400e380:	2302      	movs	r3, #2
2400e382:	e037      	b.n	2400e3f4 <HAL_MDMA_ConfigPostRequestMask+0x98>
2400e384:	68fb      	ldr	r3, [r7, #12]
2400e386:	2201      	movs	r2, #1
2400e388:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  if(HAL_MDMA_STATE_READY == hmdma->State)
2400e38c:	68fb      	ldr	r3, [r7, #12]
2400e38e:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
2400e392:	b2db      	uxtb	r3, r3
2400e394:	2b01      	cmp	r3, #1
2400e396:	d126      	bne.n	2400e3e6 <HAL_MDMA_ConfigPostRequestMask+0x8a>
  {
    /* if HW request set Post Request MaskAddress and MaskData,  */
    if((hmdma->Instance->CTCR & MDMA_CTCR_SWRM) == 0U)
2400e398:	68fb      	ldr	r3, [r7, #12]
2400e39a:	681b      	ldr	r3, [r3, #0]
2400e39c:	691b      	ldr	r3, [r3, #16]
2400e39e:	f003 4380 	and.w	r3, r3, #1073741824	; 0x40000000
2400e3a2:	2b00      	cmp	r3, #0
2400e3a4:	d11c      	bne.n	2400e3e0 <HAL_MDMA_ConfigPostRequestMask+0x84>
    {
      /* Set the HW request clear Mask and Data */
      hmdma->Instance->CMAR = MaskAddress;
2400e3a6:	68fb      	ldr	r3, [r7, #12]
2400e3a8:	681b      	ldr	r3, [r3, #0]
2400e3aa:	68ba      	ldr	r2, [r7, #8]
2400e3ac:	631a      	str	r2, [r3, #48]	; 0x30
      hmdma->Instance->CMDR = MaskData;
2400e3ae:	68fb      	ldr	r3, [r7, #12]
2400e3b0:	681b      	ldr	r3, [r3, #0]
2400e3b2:	687a      	ldr	r2, [r7, #4]
2400e3b4:	635a      	str	r2, [r3, #52]	; 0x34
      -If the request is done by SW : BWM could be set to 1 or 0.
      -If the request is done by a peripheral :
         If mask address not set (0) => BWM must be set to 0
         If mask address set (different than 0) => BWM could be set to 1 or 0
      */
      if(MaskAddress == 0U)
2400e3b6:	68bb      	ldr	r3, [r7, #8]
2400e3b8:	2b00      	cmp	r3, #0
2400e3ba:	d108      	bne.n	2400e3ce <HAL_MDMA_ConfigPostRequestMask+0x72>
      {
        hmdma->Instance->CTCR &=  ~MDMA_CTCR_BWM;
2400e3bc:	68fb      	ldr	r3, [r7, #12]
2400e3be:	681b      	ldr	r3, [r3, #0]
2400e3c0:	691a      	ldr	r2, [r3, #16]
2400e3c2:	68fb      	ldr	r3, [r7, #12]
2400e3c4:	681b      	ldr	r3, [r3, #0]
2400e3c6:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
2400e3ca:	611a      	str	r2, [r3, #16]
2400e3cc:	e00d      	b.n	2400e3ea <HAL_MDMA_ConfigPostRequestMask+0x8e>
      }
      else
      {
        hmdma->Instance->CTCR |=  MDMA_CTCR_BWM;
2400e3ce:	68fb      	ldr	r3, [r7, #12]
2400e3d0:	681b      	ldr	r3, [r3, #0]
2400e3d2:	691a      	ldr	r2, [r3, #16]
2400e3d4:	68fb      	ldr	r3, [r7, #12]
2400e3d6:	681b      	ldr	r3, [r3, #0]
2400e3d8:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
2400e3dc:	611a      	str	r2, [r3, #16]
2400e3de:	e004      	b.n	2400e3ea <HAL_MDMA_ConfigPostRequestMask+0x8e>
      }
    }
    else
    {
      /* Return error status */
      status =  HAL_ERROR;
2400e3e0:	2301      	movs	r3, #1
2400e3e2:	75fb      	strb	r3, [r7, #23]
2400e3e4:	e001      	b.n	2400e3ea <HAL_MDMA_ConfigPostRequestMask+0x8e>
    }
  }
  else
  {
    /* Return error status */
    status =  HAL_ERROR;
2400e3e6:	2301      	movs	r3, #1
2400e3e8:	75fb      	strb	r3, [r7, #23]
  }
  /* Release Lock */
  __HAL_UNLOCK(hmdma);
2400e3ea:	68fb      	ldr	r3, [r7, #12]
2400e3ec:	2200      	movs	r2, #0
2400e3ee:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  return status;
2400e3f2:	7dfb      	ldrb	r3, [r7, #23]
}
2400e3f4:	4618      	mov	r0, r3
2400e3f6:	371c      	adds	r7, #28
2400e3f8:	46bd      	mov	sp, r7
2400e3fa:	f85d 7b04 	ldr.w	r7, [sp], #4
2400e3fe:	4770      	bx	lr

2400e400 <HAL_MDMA_RegisterCallback>:
  * @param  CallbackID:           User Callback identifier
  * @param  pCallback:            pointer to callbacsk function.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_MDMA_RegisterCallback(MDMA_HandleTypeDef *hmdma, HAL_MDMA_CallbackIDTypeDef CallbackID, void (* pCallback)(MDMA_HandleTypeDef *_hmdma))
{
2400e400:	b480      	push	{r7}
2400e402:	b087      	sub	sp, #28
2400e404:	af00      	add	r7, sp, #0
2400e406:	60f8      	str	r0, [r7, #12]
2400e408:	460b      	mov	r3, r1
2400e40a:	607a      	str	r2, [r7, #4]
2400e40c:	72fb      	strb	r3, [r7, #11]
  HAL_StatusTypeDef status = HAL_OK;
2400e40e:	2300      	movs	r3, #0
2400e410:	75fb      	strb	r3, [r7, #23]

  /* Check the MDMA peripheral handle */
  if(hmdma == NULL)
2400e412:	68fb      	ldr	r3, [r7, #12]
2400e414:	2b00      	cmp	r3, #0
2400e416:	d101      	bne.n	2400e41c <HAL_MDMA_RegisterCallback+0x1c>
  {
    return HAL_ERROR;
2400e418:	2301      	movs	r3, #1
2400e41a:	e044      	b.n	2400e4a6 <HAL_MDMA_RegisterCallback+0xa6>
  }

  /* Process locked */
  __HAL_LOCK(hmdma);
2400e41c:	68fb      	ldr	r3, [r7, #12]
2400e41e:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
2400e422:	2b01      	cmp	r3, #1
2400e424:	d101      	bne.n	2400e42a <HAL_MDMA_RegisterCallback+0x2a>
2400e426:	2302      	movs	r3, #2
2400e428:	e03d      	b.n	2400e4a6 <HAL_MDMA_RegisterCallback+0xa6>
2400e42a:	68fb      	ldr	r3, [r7, #12]
2400e42c:	2201      	movs	r2, #1
2400e42e:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  if(HAL_MDMA_STATE_READY == hmdma->State)
2400e432:	68fb      	ldr	r3, [r7, #12]
2400e434:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
2400e438:	b2db      	uxtb	r3, r3
2400e43a:	2b01      	cmp	r3, #1
2400e43c:	d12a      	bne.n	2400e494 <HAL_MDMA_RegisterCallback+0x94>
  {
    switch (CallbackID)
2400e43e:	7afb      	ldrb	r3, [r7, #11]
2400e440:	2b05      	cmp	r3, #5
2400e442:	d82a      	bhi.n	2400e49a <HAL_MDMA_RegisterCallback+0x9a>
2400e444:	a201      	add	r2, pc, #4	; (adr r2, 2400e44c <HAL_MDMA_RegisterCallback+0x4c>)
2400e446:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
2400e44a:	bf00      	nop
2400e44c:	2400e465 	.word	0x2400e465
2400e450:	2400e46d 	.word	0x2400e46d
2400e454:	2400e475 	.word	0x2400e475
2400e458:	2400e47d 	.word	0x2400e47d
2400e45c:	2400e485 	.word	0x2400e485
2400e460:	2400e48d 	.word	0x2400e48d
    {
    case  HAL_MDMA_XFER_CPLT_CB_ID:
      hmdma->XferCpltCallback = pCallback;
2400e464:	68fb      	ldr	r3, [r7, #12]
2400e466:	687a      	ldr	r2, [r7, #4]
2400e468:	645a      	str	r2, [r3, #68]	; 0x44
      break;
2400e46a:	e017      	b.n	2400e49c <HAL_MDMA_RegisterCallback+0x9c>

    case  HAL_MDMA_XFER_BUFFERCPLT_CB_ID:
      hmdma->XferBufferCpltCallback = pCallback;
2400e46c:	68fb      	ldr	r3, [r7, #12]
2400e46e:	687a      	ldr	r2, [r7, #4]
2400e470:	649a      	str	r2, [r3, #72]	; 0x48
      break;
2400e472:	e013      	b.n	2400e49c <HAL_MDMA_RegisterCallback+0x9c>

    case  HAL_MDMA_XFER_BLOCKCPLT_CB_ID:
      hmdma->XferBlockCpltCallback = pCallback;
2400e474:	68fb      	ldr	r3, [r7, #12]
2400e476:	687a      	ldr	r2, [r7, #4]
2400e478:	64da      	str	r2, [r3, #76]	; 0x4c
      break;
2400e47a:	e00f      	b.n	2400e49c <HAL_MDMA_RegisterCallback+0x9c>

    case  HAL_MDMA_XFER_REPBLOCKCPLT_CB_ID:
      hmdma->XferRepeatBlockCpltCallback = pCallback;
2400e47c:	68fb      	ldr	r3, [r7, #12]
2400e47e:	687a      	ldr	r2, [r7, #4]
2400e480:	651a      	str	r2, [r3, #80]	; 0x50
      break;
2400e482:	e00b      	b.n	2400e49c <HAL_MDMA_RegisterCallback+0x9c>

    case  HAL_MDMA_XFER_ERROR_CB_ID:
      hmdma->XferErrorCallback = pCallback;
2400e484:	68fb      	ldr	r3, [r7, #12]
2400e486:	687a      	ldr	r2, [r7, #4]
2400e488:	655a      	str	r2, [r3, #84]	; 0x54
      break;
2400e48a:	e007      	b.n	2400e49c <HAL_MDMA_RegisterCallback+0x9c>

    case  HAL_MDMA_XFER_ABORT_CB_ID:
      hmdma->XferAbortCallback = pCallback;
2400e48c:	68fb      	ldr	r3, [r7, #12]
2400e48e:	687a      	ldr	r2, [r7, #4]
2400e490:	659a      	str	r2, [r3, #88]	; 0x58
      break;
2400e492:	e003      	b.n	2400e49c <HAL_MDMA_RegisterCallback+0x9c>
    }
  }
  else
  {
    /* Return error status */
    status =  HAL_ERROR;
2400e494:	2301      	movs	r3, #1
2400e496:	75fb      	strb	r3, [r7, #23]
2400e498:	e000      	b.n	2400e49c <HAL_MDMA_RegisterCallback+0x9c>
      break;
2400e49a:	bf00      	nop
  }

  /* Release Lock */
  __HAL_UNLOCK(hmdma);
2400e49c:	68fb      	ldr	r3, [r7, #12]
2400e49e:	2200      	movs	r2, #0
2400e4a0:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  return status;
2400e4a4:	7dfb      	ldrb	r3, [r7, #23]
}
2400e4a6:	4618      	mov	r0, r3
2400e4a8:	371c      	adds	r7, #28
2400e4aa:	46bd      	mov	sp, r7
2400e4ac:	f85d 7b04 	ldr.w	r7, [sp], #4
2400e4b0:	4770      	bx	lr
2400e4b2:	bf00      	nop

2400e4b4 <HAL_MDMA_UnRegisterCallback>:
  * @param  CallbackID:           User Callback identifier
  *                               a HAL_MDMA_CallbackIDTypeDef ENUM as parameter.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_MDMA_UnRegisterCallback(MDMA_HandleTypeDef *hmdma, HAL_MDMA_CallbackIDTypeDef CallbackID)
{
2400e4b4:	b480      	push	{r7}
2400e4b6:	b085      	sub	sp, #20
2400e4b8:	af00      	add	r7, sp, #0
2400e4ba:	6078      	str	r0, [r7, #4]
2400e4bc:	460b      	mov	r3, r1
2400e4be:	70fb      	strb	r3, [r7, #3]
  HAL_StatusTypeDef status = HAL_OK;
2400e4c0:	2300      	movs	r3, #0
2400e4c2:	73fb      	strb	r3, [r7, #15]

  /* Check the MDMA peripheral handle */
  if(hmdma == NULL)
2400e4c4:	687b      	ldr	r3, [r7, #4]
2400e4c6:	2b00      	cmp	r3, #0
2400e4c8:	d101      	bne.n	2400e4ce <HAL_MDMA_UnRegisterCallback+0x1a>
  {
    return HAL_ERROR;
2400e4ca:	2301      	movs	r3, #1
2400e4cc:	e05a      	b.n	2400e584 <HAL_MDMA_UnRegisterCallback+0xd0>
  }

  /* Process locked */
  __HAL_LOCK(hmdma);
2400e4ce:	687b      	ldr	r3, [r7, #4]
2400e4d0:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
2400e4d4:	2b01      	cmp	r3, #1
2400e4d6:	d101      	bne.n	2400e4dc <HAL_MDMA_UnRegisterCallback+0x28>
2400e4d8:	2302      	movs	r3, #2
2400e4da:	e053      	b.n	2400e584 <HAL_MDMA_UnRegisterCallback+0xd0>
2400e4dc:	687b      	ldr	r3, [r7, #4]
2400e4de:	2201      	movs	r2, #1
2400e4e0:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  if(HAL_MDMA_STATE_READY == hmdma->State)
2400e4e4:	687b      	ldr	r3, [r7, #4]
2400e4e6:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
2400e4ea:	b2db      	uxtb	r3, r3
2400e4ec:	2b01      	cmp	r3, #1
2400e4ee:	d142      	bne.n	2400e576 <HAL_MDMA_UnRegisterCallback+0xc2>
  {
    switch (CallbackID)
2400e4f0:	78fb      	ldrb	r3, [r7, #3]
2400e4f2:	2b06      	cmp	r3, #6
2400e4f4:	d83b      	bhi.n	2400e56e <HAL_MDMA_UnRegisterCallback+0xba>
2400e4f6:	a201      	add	r2, pc, #4	; (adr r2, 2400e4fc <HAL_MDMA_UnRegisterCallback+0x48>)
2400e4f8:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
2400e4fc:	2400e519 	.word	0x2400e519
2400e500:	2400e521 	.word	0x2400e521
2400e504:	2400e529 	.word	0x2400e529
2400e508:	2400e531 	.word	0x2400e531
2400e50c:	2400e539 	.word	0x2400e539
2400e510:	2400e541 	.word	0x2400e541
2400e514:	2400e549 	.word	0x2400e549
    {
    case  HAL_MDMA_XFER_CPLT_CB_ID:
      hmdma->XferCpltCallback = NULL;
2400e518:	687b      	ldr	r3, [r7, #4]
2400e51a:	2200      	movs	r2, #0
2400e51c:	645a      	str	r2, [r3, #68]	; 0x44
      break;
2400e51e:	e02c      	b.n	2400e57a <HAL_MDMA_UnRegisterCallback+0xc6>

    case  HAL_MDMA_XFER_BUFFERCPLT_CB_ID:
      hmdma->XferBufferCpltCallback = NULL;
2400e520:	687b      	ldr	r3, [r7, #4]
2400e522:	2200      	movs	r2, #0
2400e524:	649a      	str	r2, [r3, #72]	; 0x48
      break;
2400e526:	e028      	b.n	2400e57a <HAL_MDMA_UnRegisterCallback+0xc6>

    case  HAL_MDMA_XFER_BLOCKCPLT_CB_ID:
      hmdma->XferBlockCpltCallback = NULL;
2400e528:	687b      	ldr	r3, [r7, #4]
2400e52a:	2200      	movs	r2, #0
2400e52c:	64da      	str	r2, [r3, #76]	; 0x4c
      break;
2400e52e:	e024      	b.n	2400e57a <HAL_MDMA_UnRegisterCallback+0xc6>

    case  HAL_MDMA_XFER_REPBLOCKCPLT_CB_ID:
      hmdma->XferRepeatBlockCpltCallback = NULL;
2400e530:	687b      	ldr	r3, [r7, #4]
2400e532:	2200      	movs	r2, #0
2400e534:	651a      	str	r2, [r3, #80]	; 0x50
      break;
2400e536:	e020      	b.n	2400e57a <HAL_MDMA_UnRegisterCallback+0xc6>

    case  HAL_MDMA_XFER_ERROR_CB_ID:
      hmdma->XferErrorCallback = NULL;
2400e538:	687b      	ldr	r3, [r7, #4]
2400e53a:	2200      	movs	r2, #0
2400e53c:	655a      	str	r2, [r3, #84]	; 0x54
      break;
2400e53e:	e01c      	b.n	2400e57a <HAL_MDMA_UnRegisterCallback+0xc6>

    case  HAL_MDMA_XFER_ABORT_CB_ID:
      hmdma->XferAbortCallback = NULL;
2400e540:	687b      	ldr	r3, [r7, #4]
2400e542:	2200      	movs	r2, #0
2400e544:	659a      	str	r2, [r3, #88]	; 0x58
      break;
2400e546:	e018      	b.n	2400e57a <HAL_MDMA_UnRegisterCallback+0xc6>

    case   HAL_MDMA_XFER_ALL_CB_ID:
      hmdma->XferCpltCallback = NULL;
2400e548:	687b      	ldr	r3, [r7, #4]
2400e54a:	2200      	movs	r2, #0
2400e54c:	645a      	str	r2, [r3, #68]	; 0x44
      hmdma->XferBufferCpltCallback = NULL;
2400e54e:	687b      	ldr	r3, [r7, #4]
2400e550:	2200      	movs	r2, #0
2400e552:	649a      	str	r2, [r3, #72]	; 0x48
      hmdma->XferBlockCpltCallback = NULL;
2400e554:	687b      	ldr	r3, [r7, #4]
2400e556:	2200      	movs	r2, #0
2400e558:	64da      	str	r2, [r3, #76]	; 0x4c
      hmdma->XferRepeatBlockCpltCallback = NULL;
2400e55a:	687b      	ldr	r3, [r7, #4]
2400e55c:	2200      	movs	r2, #0
2400e55e:	651a      	str	r2, [r3, #80]	; 0x50
      hmdma->XferErrorCallback = NULL;
2400e560:	687b      	ldr	r3, [r7, #4]
2400e562:	2200      	movs	r2, #0
2400e564:	655a      	str	r2, [r3, #84]	; 0x54
      hmdma->XferAbortCallback = NULL;
2400e566:	687b      	ldr	r3, [r7, #4]
2400e568:	2200      	movs	r2, #0
2400e56a:	659a      	str	r2, [r3, #88]	; 0x58
      break;
2400e56c:	e005      	b.n	2400e57a <HAL_MDMA_UnRegisterCallback+0xc6>

    default:
      status = HAL_ERROR;
2400e56e:	2301      	movs	r3, #1
2400e570:	73fb      	strb	r3, [r7, #15]
      break;
2400e572:	bf00      	nop
2400e574:	e001      	b.n	2400e57a <HAL_MDMA_UnRegisterCallback+0xc6>
    }
  }
  else
  {
    status = HAL_ERROR;
2400e576:	2301      	movs	r3, #1
2400e578:	73fb      	strb	r3, [r7, #15]
  }

  /* Release Lock */
  __HAL_UNLOCK(hmdma);
2400e57a:	687b      	ldr	r3, [r7, #4]
2400e57c:	2200      	movs	r2, #0
2400e57e:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  return status;
2400e582:	7bfb      	ldrb	r3, [r7, #15]
}
2400e584:	4618      	mov	r0, r3
2400e586:	3714      	adds	r7, #20
2400e588:	46bd      	mov	sp, r7
2400e58a:	f85d 7b04 	ldr.w	r7, [sp], #4
2400e58e:	4770      	bx	lr

2400e590 <HAL_MDMA_LinkedList_CreateNode>:
  * @param  pNodeConfig: Pointer to a MDMA_LinkNodeConfTypeDef structure that contains
  *               the configuration information for the specified MDMA Linked List Node.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_MDMA_LinkedList_CreateNode(MDMA_LinkNodeTypeDef *pNode, MDMA_LinkNodeConfTypeDef *pNodeConfig)
{
2400e590:	b480      	push	{r7}
2400e592:	b085      	sub	sp, #20
2400e594:	af00      	add	r7, sp, #0
2400e596:	6078      	str	r0, [r7, #4]
2400e598:	6039      	str	r1, [r7, #0]
  uint32_t addressMask;
  uint32_t blockoffset;

  /* Check the MDMA peripheral state */
  if((pNode == NULL) || (pNodeConfig == NULL))
2400e59a:	687b      	ldr	r3, [r7, #4]
2400e59c:	2b00      	cmp	r3, #0
2400e59e:	d002      	beq.n	2400e5a6 <HAL_MDMA_LinkedList_CreateNode+0x16>
2400e5a0:	683b      	ldr	r3, [r7, #0]
2400e5a2:	2b00      	cmp	r3, #0
2400e5a4:	d101      	bne.n	2400e5aa <HAL_MDMA_LinkedList_CreateNode+0x1a>
  {
    return HAL_ERROR;
2400e5a6:	2301      	movs	r3, #1
2400e5a8:	e0c8      	b.n	2400e73c <HAL_MDMA_LinkedList_CreateNode+0x1ac>
  assert_param(IS_MDMA_TRANSFER_LENGTH(pNodeConfig->BlockDataLength));
  assert_param(IS_MDMA_BLOCK_COUNT(pNodeConfig->BlockCount));


  /* Configure next Link node Address Register to zero */
  pNode->CLAR =  0;
2400e5aa:	687b      	ldr	r3, [r7, #4]
2400e5ac:	2200      	movs	r2, #0
2400e5ae:	615a      	str	r2, [r3, #20]

  /* Configure the Link Node registers*/
  pNode->CTBR   = 0;
2400e5b0:	687b      	ldr	r3, [r7, #4]
2400e5b2:	2200      	movs	r2, #0
2400e5b4:	619a      	str	r2, [r3, #24]
  pNode->CMAR   = 0;
2400e5b6:	687b      	ldr	r3, [r7, #4]
2400e5b8:	2200      	movs	r2, #0
2400e5ba:	621a      	str	r2, [r3, #32]
  pNode->CMDR   = 0;
2400e5bc:	687b      	ldr	r3, [r7, #4]
2400e5be:	2200      	movs	r2, #0
2400e5c0:	625a      	str	r2, [r3, #36]	; 0x24
  pNode->Reserved = 0;
2400e5c2:	687b      	ldr	r3, [r7, #4]
2400e5c4:	2200      	movs	r2, #0
2400e5c6:	61da      	str	r2, [r3, #28]

  /* Write new CTCR Register value */
  pNode->CTCR =  pNodeConfig->Init.SourceInc | pNodeConfig->Init.DestinationInc | \
2400e5c8:	683b      	ldr	r3, [r7, #0]
2400e5ca:	691a      	ldr	r2, [r3, #16]
2400e5cc:	683b      	ldr	r3, [r7, #0]
2400e5ce:	695b      	ldr	r3, [r3, #20]
2400e5d0:	431a      	orrs	r2, r3
    pNodeConfig->Init.SourceDataSize | pNodeConfig->Init.DestDataSize           | \
2400e5d2:	683b      	ldr	r3, [r7, #0]
2400e5d4:	699b      	ldr	r3, [r3, #24]
  pNode->CTCR =  pNodeConfig->Init.SourceInc | pNodeConfig->Init.DestinationInc | \
2400e5d6:	431a      	orrs	r2, r3
    pNodeConfig->Init.SourceDataSize | pNodeConfig->Init.DestDataSize           | \
2400e5d8:	683b      	ldr	r3, [r7, #0]
2400e5da:	69db      	ldr	r3, [r3, #28]
2400e5dc:	431a      	orrs	r2, r3
      pNodeConfig->Init.DataAlignment| pNodeConfig->Init.SourceBurst            | \
2400e5de:	683b      	ldr	r3, [r7, #0]
2400e5e0:	6a1b      	ldr	r3, [r3, #32]
    pNodeConfig->Init.SourceDataSize | pNodeConfig->Init.DestDataSize           | \
2400e5e2:	431a      	orrs	r2, r3
      pNodeConfig->Init.DataAlignment| pNodeConfig->Init.SourceBurst            | \
2400e5e4:	683b      	ldr	r3, [r7, #0]
2400e5e6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
2400e5e8:	431a      	orrs	r2, r3
        pNodeConfig->Init.DestBurst                                             | \
2400e5ea:	683b      	ldr	r3, [r7, #0]
2400e5ec:	6adb      	ldr	r3, [r3, #44]	; 0x2c
      pNodeConfig->Init.DataAlignment| pNodeConfig->Init.SourceBurst            | \
2400e5ee:	431a      	orrs	r2, r3
          ((pNodeConfig->Init.BufferTransferLength - 1U) << MDMA_CTCR_TLEN_Pos) | \
2400e5f0:	683b      	ldr	r3, [r7, #0]
2400e5f2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400e5f4:	3b01      	subs	r3, #1
2400e5f6:	049b      	lsls	r3, r3, #18
        pNodeConfig->Init.DestBurst                                             | \
2400e5f8:	431a      	orrs	r2, r3
            pNodeConfig->Init.TransferTriggerMode;
2400e5fa:	683b      	ldr	r3, [r7, #0]
2400e5fc:	685b      	ldr	r3, [r3, #4]
          ((pNodeConfig->Init.BufferTransferLength - 1U) << MDMA_CTCR_TLEN_Pos) | \
2400e5fe:	431a      	orrs	r2, r3
  pNode->CTCR =  pNodeConfig->Init.SourceInc | pNodeConfig->Init.DestinationInc | \
2400e600:	687b      	ldr	r3, [r7, #4]
2400e602:	601a      	str	r2, [r3, #0]

  /* If SW request set the CTCR register to SW Request Mode*/
  if(pNodeConfig->Init.Request == MDMA_REQUEST_SW)
2400e604:	683b      	ldr	r3, [r7, #0]
2400e606:	681b      	ldr	r3, [r3, #0]
2400e608:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
2400e60c:	d105      	bne.n	2400e61a <HAL_MDMA_LinkedList_CreateNode+0x8a>
  {
    pNode->CTCR |= MDMA_CTCR_SWRM;
2400e60e:	687b      	ldr	r3, [r7, #4]
2400e610:	681b      	ldr	r3, [r3, #0]
2400e612:	f043 4280 	orr.w	r2, r3, #1073741824	; 0x40000000
2400e616:	687b      	ldr	r3, [r7, #4]
2400e618:	601a      	str	r2, [r3, #0]
  -If the request is done by SW : BWM could be set to 1 or 0.
  -If the request is done by a peripheral :
     If mask address not set (0) => BWM must be set to 0
     If mask address set (different than 0) => BWM could be set to 1 or 0
  */
  if((pNodeConfig->Init.Request == MDMA_REQUEST_SW) || (pNodeConfig->PostRequestMaskAddress != 0U))
2400e61a:	683b      	ldr	r3, [r7, #0]
2400e61c:	681b      	ldr	r3, [r3, #0]
2400e61e:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
2400e622:	d003      	beq.n	2400e62c <HAL_MDMA_LinkedList_CreateNode+0x9c>
2400e624:	683b      	ldr	r3, [r7, #0]
2400e626:	6c9b      	ldr	r3, [r3, #72]	; 0x48
2400e628:	2b00      	cmp	r3, #0
2400e62a:	d005      	beq.n	2400e638 <HAL_MDMA_LinkedList_CreateNode+0xa8>
  {
    pNode->CTCR |=  MDMA_CTCR_BWM;
2400e62c:	687b      	ldr	r3, [r7, #4]
2400e62e:	681b      	ldr	r3, [r3, #0]
2400e630:	f043 4200 	orr.w	r2, r3, #2147483648	; 0x80000000
2400e634:	687b      	ldr	r3, [r7, #4]
2400e636:	601a      	str	r2, [r3, #0]
  }

  /* Set the new CBNDTR Register value */
  pNode->CBNDTR = ((pNodeConfig->BlockCount - 1U) << MDMA_CBNDTR_BRC_Pos) & MDMA_CBNDTR_BRC;
2400e638:	683b      	ldr	r3, [r7, #0]
2400e63a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400e63c:	3b01      	subs	r3, #1
2400e63e:	051a      	lsls	r2, r3, #20
2400e640:	687b      	ldr	r3, [r7, #4]
2400e642:	605a      	str	r2, [r3, #4]

  /* if block source address offset is negative set the Block Repeat Source address Update Mode to decrement */
  if(pNodeConfig->Init.SourceBlockAddressOffset < 0)
2400e644:	683b      	ldr	r3, [r7, #0]
2400e646:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2400e648:	2b00      	cmp	r3, #0
2400e64a:	da0e      	bge.n	2400e66a <HAL_MDMA_LinkedList_CreateNode+0xda>
  {
    pNode->CBNDTR |= MDMA_CBNDTR_BRSUM;
2400e64c:	687b      	ldr	r3, [r7, #4]
2400e64e:	685b      	ldr	r3, [r3, #4]
2400e650:	f443 2280 	orr.w	r2, r3, #262144	; 0x40000
2400e654:	687b      	ldr	r3, [r7, #4]
2400e656:	605a      	str	r2, [r3, #4]
    /*write new CBRUR Register value : source repeat block offset */
    blockoffset = (uint32_t)(- pNodeConfig->Init.SourceBlockAddressOffset);
2400e658:	683b      	ldr	r3, [r7, #0]
2400e65a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2400e65c:	425b      	negs	r3, r3
2400e65e:	60fb      	str	r3, [r7, #12]
    pNode->CBRUR = blockoffset & 0x0000FFFFU;
2400e660:	68fb      	ldr	r3, [r7, #12]
2400e662:	b29a      	uxth	r2, r3
2400e664:	687b      	ldr	r3, [r7, #4]
2400e666:	611a      	str	r2, [r3, #16]
2400e668:	e004      	b.n	2400e674 <HAL_MDMA_LinkedList_CreateNode+0xe4>
  }
  else
  {
    /*write new CBRUR Register value : source repeat block offset */
    pNode->CBRUR = (((uint32_t) pNodeConfig->Init.SourceBlockAddressOffset) & 0x0000FFFFU);
2400e66a:	683b      	ldr	r3, [r7, #0]
2400e66c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2400e66e:	b29a      	uxth	r2, r3
2400e670:	687b      	ldr	r3, [r7, #4]
2400e672:	611a      	str	r2, [r3, #16]
  }

  /* if block destination address offset is negative set the Block Repeat destination address Update Mode to decrement */
  if(pNodeConfig->Init.DestBlockAddressOffset < 0)
2400e674:	683b      	ldr	r3, [r7, #0]
2400e676:	6b5b      	ldr	r3, [r3, #52]	; 0x34
2400e678:	2b00      	cmp	r3, #0
2400e67a:	da11      	bge.n	2400e6a0 <HAL_MDMA_LinkedList_CreateNode+0x110>
  {
    pNode->CBNDTR |= MDMA_CBNDTR_BRDUM;
2400e67c:	687b      	ldr	r3, [r7, #4]
2400e67e:	685b      	ldr	r3, [r3, #4]
2400e680:	f443 2200 	orr.w	r2, r3, #524288	; 0x80000
2400e684:	687b      	ldr	r3, [r7, #4]
2400e686:	605a      	str	r2, [r3, #4]
    /*write new CBRUR Register value : destination repeat block offset */
    blockoffset = (uint32_t)(- pNodeConfig->Init.DestBlockAddressOffset);
2400e688:	683b      	ldr	r3, [r7, #0]
2400e68a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
2400e68c:	425b      	negs	r3, r3
2400e68e:	60fb      	str	r3, [r7, #12]
    pNode->CBRUR |= ((blockoffset & 0x0000FFFFU) << MDMA_CBRUR_DUV_Pos);
2400e690:	687b      	ldr	r3, [r7, #4]
2400e692:	691a      	ldr	r2, [r3, #16]
2400e694:	68fb      	ldr	r3, [r7, #12]
2400e696:	041b      	lsls	r3, r3, #16
2400e698:	431a      	orrs	r2, r3
2400e69a:	687b      	ldr	r3, [r7, #4]
2400e69c:	611a      	str	r2, [r3, #16]
2400e69e:	e007      	b.n	2400e6b0 <HAL_MDMA_LinkedList_CreateNode+0x120>
  }
  else
  {
    /*write new CBRUR Register value : destination repeat block offset */
    pNode->CBRUR |= ((((uint32_t)pNodeConfig->Init.DestBlockAddressOffset) & 0x0000FFFFU) << MDMA_CBRUR_DUV_Pos);
2400e6a0:	687b      	ldr	r3, [r7, #4]
2400e6a2:	691a      	ldr	r2, [r3, #16]
2400e6a4:	683b      	ldr	r3, [r7, #0]
2400e6a6:	6b5b      	ldr	r3, [r3, #52]	; 0x34
2400e6a8:	041b      	lsls	r3, r3, #16
2400e6aa:	431a      	orrs	r2, r3
2400e6ac:	687b      	ldr	r3, [r7, #4]
2400e6ae:	611a      	str	r2, [r3, #16]
  }

  /* Configure MDMA Link Node data length */
  pNode->CBNDTR |=  pNodeConfig->BlockDataLength;
2400e6b0:	687b      	ldr	r3, [r7, #4]
2400e6b2:	685a      	ldr	r2, [r3, #4]
2400e6b4:	683b      	ldr	r3, [r7, #0]
2400e6b6:	6c1b      	ldr	r3, [r3, #64]	; 0x40
2400e6b8:	431a      	orrs	r2, r3
2400e6ba:	687b      	ldr	r3, [r7, #4]
2400e6bc:	605a      	str	r2, [r3, #4]

  /* Configure MDMA Link Node destination address */
  pNode->CDAR = pNodeConfig->DstAddress;
2400e6be:	683b      	ldr	r3, [r7, #0]
2400e6c0:	6bda      	ldr	r2, [r3, #60]	; 0x3c
2400e6c2:	687b      	ldr	r3, [r7, #4]
2400e6c4:	60da      	str	r2, [r3, #12]

  /* Configure MDMA Link Node Source address */
  pNode->CSAR = pNodeConfig->SrcAddress;
2400e6c6:	683b      	ldr	r3, [r7, #0]
2400e6c8:	6b9a      	ldr	r2, [r3, #56]	; 0x38
2400e6ca:	687b      	ldr	r3, [r7, #4]
2400e6cc:	609a      	str	r2, [r3, #8]

  /* if HW request set the HW request and the requet CleraMask and ClearData MaskData,  */
  if(pNodeConfig->Init.Request != MDMA_REQUEST_SW)
2400e6ce:	683b      	ldr	r3, [r7, #0]
2400e6d0:	681b      	ldr	r3, [r3, #0]
2400e6d2:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
2400e6d6:	d00c      	beq.n	2400e6f2 <HAL_MDMA_LinkedList_CreateNode+0x162>
  {
    /* Set the HW request in CTBR register  */
    pNode->CTBR = pNodeConfig->Init.Request & MDMA_CTBR_TSEL;
2400e6d8:	683b      	ldr	r3, [r7, #0]
2400e6da:	681b      	ldr	r3, [r3, #0]
2400e6dc:	b2da      	uxtb	r2, r3
2400e6de:	687b      	ldr	r3, [r7, #4]
2400e6e0:	619a      	str	r2, [r3, #24]
    /* Set the HW request clear Mask and Data */
    pNode->CMAR = pNodeConfig->PostRequestMaskAddress;
2400e6e2:	683b      	ldr	r3, [r7, #0]
2400e6e4:	6c9a      	ldr	r2, [r3, #72]	; 0x48
2400e6e6:	687b      	ldr	r3, [r7, #4]
2400e6e8:	621a      	str	r2, [r3, #32]
    pNode->CMDR = pNodeConfig->PostRequestMaskData;
2400e6ea:	683b      	ldr	r3, [r7, #0]
2400e6ec:	6cda      	ldr	r2, [r3, #76]	; 0x4c
2400e6ee:	687b      	ldr	r3, [r7, #4]
2400e6f0:	625a      	str	r2, [r3, #36]	; 0x24
  }

  addressMask = pNodeConfig->SrcAddress & 0xFF000000U;
2400e6f2:	683b      	ldr	r3, [r7, #0]
2400e6f4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400e6f6:	f003 437f 	and.w	r3, r3, #4278190080	; 0xff000000
2400e6fa:	60bb      	str	r3, [r7, #8]
  if((addressMask == 0x20000000U) || (addressMask == 0x00000000U))
2400e6fc:	68bb      	ldr	r3, [r7, #8]
2400e6fe:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
2400e702:	d002      	beq.n	2400e70a <HAL_MDMA_LinkedList_CreateNode+0x17a>
2400e704:	68bb      	ldr	r3, [r7, #8]
2400e706:	2b00      	cmp	r3, #0
2400e708:	d105      	bne.n	2400e716 <HAL_MDMA_LinkedList_CreateNode+0x186>
  {
    /*The AHBSbus is used as source (read operation) on channel x */
    pNode->CTBR |= MDMA_CTBR_SBUS;
2400e70a:	687b      	ldr	r3, [r7, #4]
2400e70c:	699b      	ldr	r3, [r3, #24]
2400e70e:	f443 3280 	orr.w	r2, r3, #65536	; 0x10000
2400e712:	687b      	ldr	r3, [r7, #4]
2400e714:	619a      	str	r2, [r3, #24]
  }

  addressMask = pNodeConfig->DstAddress & 0xFF000000U;
2400e716:	683b      	ldr	r3, [r7, #0]
2400e718:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400e71a:	f003 437f 	and.w	r3, r3, #4278190080	; 0xff000000
2400e71e:	60bb      	str	r3, [r7, #8]
  if((addressMask == 0x20000000U) || (addressMask == 0x00000000U))
2400e720:	68bb      	ldr	r3, [r7, #8]
2400e722:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
2400e726:	d002      	beq.n	2400e72e <HAL_MDMA_LinkedList_CreateNode+0x19e>
2400e728:	68bb      	ldr	r3, [r7, #8]
2400e72a:	2b00      	cmp	r3, #0
2400e72c:	d105      	bne.n	2400e73a <HAL_MDMA_LinkedList_CreateNode+0x1aa>
  {
    /*The AHB bus is used as destination (write operation) on channel x */
    pNode->CTBR |= MDMA_CTBR_DBUS;
2400e72e:	687b      	ldr	r3, [r7, #4]
2400e730:	699b      	ldr	r3, [r3, #24]
2400e732:	f443 3200 	orr.w	r2, r3, #131072	; 0x20000
2400e736:	687b      	ldr	r3, [r7, #4]
2400e738:	619a      	str	r2, [r3, #24]
  }

  return HAL_OK;
2400e73a:	2300      	movs	r3, #0
}
2400e73c:	4618      	mov	r0, r3
2400e73e:	3714      	adds	r7, #20
2400e740:	46bd      	mov	sp, r7
2400e742:	f85d 7b04 	ldr.w	r7, [sp], #4
2400e746:	4770      	bx	lr

2400e748 <HAL_MDMA_LinkedList_AddNode>:
  *                    at the end of the list
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_MDMA_LinkedList_AddNode(MDMA_HandleTypeDef *hmdma, MDMA_LinkNodeTypeDef *pNewNode, MDMA_LinkNodeTypeDef *pPrevNode)
{
2400e748:	b480      	push	{r7}
2400e74a:	b089      	sub	sp, #36	; 0x24
2400e74c:	af00      	add	r7, sp, #0
2400e74e:	60f8      	str	r0, [r7, #12]
2400e750:	60b9      	str	r1, [r7, #8]
2400e752:	607a      	str	r2, [r7, #4]
  MDMA_LinkNodeTypeDef *pNode;
  uint32_t counter = 0, nodeInserted = 0;
2400e754:	2300      	movs	r3, #0
2400e756:	61bb      	str	r3, [r7, #24]
2400e758:	2300      	movs	r3, #0
2400e75a:	617b      	str	r3, [r7, #20]
  HAL_StatusTypeDef hal_status = HAL_OK;
2400e75c:	2300      	movs	r3, #0
2400e75e:	74fb      	strb	r3, [r7, #19]

  /* Check the MDMA peripheral handle */
  if((hmdma == NULL) || (pNewNode == NULL))
2400e760:	68fb      	ldr	r3, [r7, #12]
2400e762:	2b00      	cmp	r3, #0
2400e764:	d002      	beq.n	2400e76c <HAL_MDMA_LinkedList_AddNode+0x24>
2400e766:	68bb      	ldr	r3, [r7, #8]
2400e768:	2b00      	cmp	r3, #0
2400e76a:	d101      	bne.n	2400e770 <HAL_MDMA_LinkedList_AddNode+0x28>
  {
    return HAL_ERROR;
2400e76c:	2301      	movs	r3, #1
2400e76e:	e0a9      	b.n	2400e8c4 <HAL_MDMA_LinkedList_AddNode+0x17c>
  }

  /* Process locked */
  __HAL_LOCK(hmdma);
2400e770:	68fb      	ldr	r3, [r7, #12]
2400e772:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
2400e776:	2b01      	cmp	r3, #1
2400e778:	d101      	bne.n	2400e77e <HAL_MDMA_LinkedList_AddNode+0x36>
2400e77a:	2302      	movs	r3, #2
2400e77c:	e0a2      	b.n	2400e8c4 <HAL_MDMA_LinkedList_AddNode+0x17c>
2400e77e:	68fb      	ldr	r3, [r7, #12]
2400e780:	2201      	movs	r2, #1
2400e782:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  if(HAL_MDMA_STATE_READY == hmdma->State)
2400e786:	68fb      	ldr	r3, [r7, #12]
2400e788:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
2400e78c:	b2db      	uxtb	r3, r3
2400e78e:	2b01      	cmp	r3, #1
2400e790:	f040 8093 	bne.w	2400e8ba <HAL_MDMA_LinkedList_AddNode+0x172>
  {
    /* Change MDMA peripheral state */
    hmdma->State = HAL_MDMA_STATE_BUSY;
2400e794:	68fb      	ldr	r3, [r7, #12]
2400e796:	2202      	movs	r2, #2
2400e798:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

    /* Check if this is the first node (after the Inititlization node) */
    if((uint32_t)hmdma->FirstLinkedListNodeAddress == 0U)
2400e79c:	68fb      	ldr	r3, [r7, #12]
2400e79e:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
2400e7a0:	2b00      	cmp	r3, #0
2400e7a2:	d116      	bne.n	2400e7d2 <HAL_MDMA_LinkedList_AddNode+0x8a>
    {
      if(pPrevNode == NULL)
2400e7a4:	687b      	ldr	r3, [r7, #4]
2400e7a6:	2b00      	cmp	r3, #0
2400e7a8:	d110      	bne.n	2400e7cc <HAL_MDMA_LinkedList_AddNode+0x84>
      {
        /* if this is the first node after the initialization
        connect this node to the node 0 by updating
        the MDMA channel CLAR register to this node address */
        hmdma->Instance->CLAR = (uint32_t)pNewNode;
2400e7aa:	68fb      	ldr	r3, [r7, #12]
2400e7ac:	681b      	ldr	r3, [r3, #0]
2400e7ae:	68ba      	ldr	r2, [r7, #8]
2400e7b0:	625a      	str	r2, [r3, #36]	; 0x24
        /* Set the MDMA handle First linked List node*/
        hmdma->FirstLinkedListNodeAddress = pNewNode;
2400e7b2:	68fb      	ldr	r3, [r7, #12]
2400e7b4:	68ba      	ldr	r2, [r7, #8]
2400e7b6:	65da      	str	r2, [r3, #92]	; 0x5c

        /*reset New node link */
        pNewNode->CLAR = 0;
2400e7b8:	68bb      	ldr	r3, [r7, #8]
2400e7ba:	2200      	movs	r2, #0
2400e7bc:	615a      	str	r2, [r3, #20]

        /* Update the Handle last node address */
        hmdma->LastLinkedListNodeAddress = pNewNode;
2400e7be:	68fb      	ldr	r3, [r7, #12]
2400e7c0:	68ba      	ldr	r2, [r7, #8]
2400e7c2:	661a      	str	r2, [r3, #96]	; 0x60

        hmdma->LinkedListNodeCounter = 1;
2400e7c4:	68fb      	ldr	r3, [r7, #12]
2400e7c6:	2201      	movs	r2, #1
2400e7c8:	665a      	str	r2, [r3, #100]	; 0x64
2400e7ca:	e06c      	b.n	2400e8a6 <HAL_MDMA_LinkedList_AddNode+0x15e>
      }
      else
      {
        hal_status = HAL_ERROR;
2400e7cc:	2301      	movs	r3, #1
2400e7ce:	74fb      	strb	r3, [r7, #19]
2400e7d0:	e069      	b.n	2400e8a6 <HAL_MDMA_LinkedList_AddNode+0x15e>
      }
    }
    else if(hmdma->FirstLinkedListNodeAddress != pNewNode)
2400e7d2:	68fb      	ldr	r3, [r7, #12]
2400e7d4:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
2400e7d6:	68ba      	ldr	r2, [r7, #8]
2400e7d8:	429a      	cmp	r2, r3
2400e7da:	d062      	beq.n	2400e8a2 <HAL_MDMA_LinkedList_AddNode+0x15a>
    {
      /* Check if the node to insert already exists*/
      pNode = hmdma->FirstLinkedListNodeAddress;
2400e7dc:	68fb      	ldr	r3, [r7, #12]
2400e7de:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
2400e7e0:	61fb      	str	r3, [r7, #28]
      while((counter < hmdma->LinkedListNodeCounter) && (hal_status == HAL_OK))
2400e7e2:	e00c      	b.n	2400e7fe <HAL_MDMA_LinkedList_AddNode+0xb6>
      {
        if(pNode->CLAR == (uint32_t)pNewNode)
2400e7e4:	69fb      	ldr	r3, [r7, #28]
2400e7e6:	695a      	ldr	r2, [r3, #20]
2400e7e8:	68bb      	ldr	r3, [r7, #8]
2400e7ea:	429a      	cmp	r2, r3
2400e7ec:	d101      	bne.n	2400e7f2 <HAL_MDMA_LinkedList_AddNode+0xaa>
        {
          hal_status = HAL_ERROR; /* error this node already exist in the linked list and it is not first node */
2400e7ee:	2301      	movs	r3, #1
2400e7f0:	74fb      	strb	r3, [r7, #19]
        }
        pNode = (MDMA_LinkNodeTypeDef *)pNode->CLAR;
2400e7f2:	69fb      	ldr	r3, [r7, #28]
2400e7f4:	695b      	ldr	r3, [r3, #20]
2400e7f6:	61fb      	str	r3, [r7, #28]
        counter++;
2400e7f8:	69bb      	ldr	r3, [r7, #24]
2400e7fa:	3301      	adds	r3, #1
2400e7fc:	61bb      	str	r3, [r7, #24]
      while((counter < hmdma->LinkedListNodeCounter) && (hal_status == HAL_OK))
2400e7fe:	68fb      	ldr	r3, [r7, #12]
2400e800:	6e5b      	ldr	r3, [r3, #100]	; 0x64
2400e802:	69ba      	ldr	r2, [r7, #24]
2400e804:	429a      	cmp	r2, r3
2400e806:	d202      	bcs.n	2400e80e <HAL_MDMA_LinkedList_AddNode+0xc6>
2400e808:	7cfb      	ldrb	r3, [r7, #19]
2400e80a:	2b00      	cmp	r3, #0
2400e80c:	d0ea      	beq.n	2400e7e4 <HAL_MDMA_LinkedList_AddNode+0x9c>
      }

      if(hal_status == HAL_OK)
2400e80e:	7cfb      	ldrb	r3, [r7, #19]
2400e810:	2b00      	cmp	r3, #0
2400e812:	d148      	bne.n	2400e8a6 <HAL_MDMA_LinkedList_AddNode+0x15e>
      {
        /* Check if the previous node is the last one in the current list or zero */
        if((pPrevNode == hmdma->LastLinkedListNodeAddress) || (pPrevNode == NULL))
2400e814:	68fb      	ldr	r3, [r7, #12]
2400e816:	6e1b      	ldr	r3, [r3, #96]	; 0x60
2400e818:	687a      	ldr	r2, [r7, #4]
2400e81a:	429a      	cmp	r2, r3
2400e81c:	d002      	beq.n	2400e824 <HAL_MDMA_LinkedList_AddNode+0xdc>
2400e81e:	687b      	ldr	r3, [r7, #4]
2400e820:	2b00      	cmp	r3, #0
2400e822:	d111      	bne.n	2400e848 <HAL_MDMA_LinkedList_AddNode+0x100>
        {
          /* insert the new node at the end of the list */
          pNewNode->CLAR = hmdma->LastLinkedListNodeAddress->CLAR;
2400e824:	68fb      	ldr	r3, [r7, #12]
2400e826:	6e1b      	ldr	r3, [r3, #96]	; 0x60
2400e828:	695a      	ldr	r2, [r3, #20]
2400e82a:	68bb      	ldr	r3, [r7, #8]
2400e82c:	615a      	str	r2, [r3, #20]
          hmdma->LastLinkedListNodeAddress->CLAR = (uint32_t)pNewNode;
2400e82e:	68fb      	ldr	r3, [r7, #12]
2400e830:	6e1b      	ldr	r3, [r3, #96]	; 0x60
2400e832:	68ba      	ldr	r2, [r7, #8]
2400e834:	615a      	str	r2, [r3, #20]
          /* Update the Handle last node address */
          hmdma->LastLinkedListNodeAddress = pNewNode;
2400e836:	68fb      	ldr	r3, [r7, #12]
2400e838:	68ba      	ldr	r2, [r7, #8]
2400e83a:	661a      	str	r2, [r3, #96]	; 0x60
          /* Increment the linked list node counter */
          hmdma->LinkedListNodeCounter++;
2400e83c:	68fb      	ldr	r3, [r7, #12]
2400e83e:	6e5b      	ldr	r3, [r3, #100]	; 0x64
2400e840:	1c5a      	adds	r2, r3, #1
2400e842:	68fb      	ldr	r3, [r7, #12]
2400e844:	665a      	str	r2, [r3, #100]	; 0x64
2400e846:	e02e      	b.n	2400e8a6 <HAL_MDMA_LinkedList_AddNode+0x15e>
        }
        else
        {
          /*insert the new node after the pPreviousNode node */
          pNode = hmdma->FirstLinkedListNodeAddress;
2400e848:	68fb      	ldr	r3, [r7, #12]
2400e84a:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
2400e84c:	61fb      	str	r3, [r7, #28]
          counter = 0;
2400e84e:	2300      	movs	r3, #0
2400e850:	61bb      	str	r3, [r7, #24]
          while((counter < hmdma->LinkedListNodeCounter) && (nodeInserted == 0U))
2400e852:	e018      	b.n	2400e886 <HAL_MDMA_LinkedList_AddNode+0x13e>
          {
            counter++;
2400e854:	69bb      	ldr	r3, [r7, #24]
2400e856:	3301      	adds	r3, #1
2400e858:	61bb      	str	r3, [r7, #24]
            if(pNode == pPrevNode)
2400e85a:	69fa      	ldr	r2, [r7, #28]
2400e85c:	687b      	ldr	r3, [r7, #4]
2400e85e:	429a      	cmp	r2, r3
2400e860:	d10e      	bne.n	2400e880 <HAL_MDMA_LinkedList_AddNode+0x138>
            {
              /*Insert the new node after the previous one */
              pNewNode->CLAR = pNode->CLAR;
2400e862:	69fb      	ldr	r3, [r7, #28]
2400e864:	695a      	ldr	r2, [r3, #20]
2400e866:	68bb      	ldr	r3, [r7, #8]
2400e868:	615a      	str	r2, [r3, #20]
              pNode->CLAR = (uint32_t)pNewNode;
2400e86a:	68ba      	ldr	r2, [r7, #8]
2400e86c:	69fb      	ldr	r3, [r7, #28]
2400e86e:	615a      	str	r2, [r3, #20]
              /* Increment the linked list node counter */
              hmdma->LinkedListNodeCounter++;
2400e870:	68fb      	ldr	r3, [r7, #12]
2400e872:	6e5b      	ldr	r3, [r3, #100]	; 0x64
2400e874:	1c5a      	adds	r2, r3, #1
2400e876:	68fb      	ldr	r3, [r7, #12]
2400e878:	665a      	str	r2, [r3, #100]	; 0x64
              nodeInserted = 1;
2400e87a:	2301      	movs	r3, #1
2400e87c:	617b      	str	r3, [r7, #20]
2400e87e:	e002      	b.n	2400e886 <HAL_MDMA_LinkedList_AddNode+0x13e>
            }
            else
            {
              pNode = (MDMA_LinkNodeTypeDef *)pNode->CLAR;
2400e880:	69fb      	ldr	r3, [r7, #28]
2400e882:	695b      	ldr	r3, [r3, #20]
2400e884:	61fb      	str	r3, [r7, #28]
          while((counter < hmdma->LinkedListNodeCounter) && (nodeInserted == 0U))
2400e886:	68fb      	ldr	r3, [r7, #12]
2400e888:	6e5b      	ldr	r3, [r3, #100]	; 0x64
2400e88a:	69ba      	ldr	r2, [r7, #24]
2400e88c:	429a      	cmp	r2, r3
2400e88e:	d202      	bcs.n	2400e896 <HAL_MDMA_LinkedList_AddNode+0x14e>
2400e890:	697b      	ldr	r3, [r7, #20]
2400e892:	2b00      	cmp	r3, #0
2400e894:	d0de      	beq.n	2400e854 <HAL_MDMA_LinkedList_AddNode+0x10c>
            }
          }

          if(nodeInserted == 0U)
2400e896:	697b      	ldr	r3, [r7, #20]
2400e898:	2b00      	cmp	r3, #0
2400e89a:	d104      	bne.n	2400e8a6 <HAL_MDMA_LinkedList_AddNode+0x15e>
          {
            hal_status = HAL_ERROR;
2400e89c:	2301      	movs	r3, #1
2400e89e:	74fb      	strb	r3, [r7, #19]
2400e8a0:	e001      	b.n	2400e8a6 <HAL_MDMA_LinkedList_AddNode+0x15e>
        }
      }
    }
    else
    {
      hal_status = HAL_ERROR;
2400e8a2:	2301      	movs	r3, #1
2400e8a4:	74fb      	strb	r3, [r7, #19]
    }

    /* Process unlocked */
    __HAL_UNLOCK(hmdma);
2400e8a6:	68fb      	ldr	r3, [r7, #12]
2400e8a8:	2200      	movs	r2, #0
2400e8aa:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

    hmdma->State = HAL_MDMA_STATE_READY;
2400e8ae:	68fb      	ldr	r3, [r7, #12]
2400e8b0:	2201      	movs	r2, #1
2400e8b2:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

    return hal_status;
2400e8b6:	7cfb      	ldrb	r3, [r7, #19]
2400e8b8:	e004      	b.n	2400e8c4 <HAL_MDMA_LinkedList_AddNode+0x17c>
  }
  else
  {
    /* Process unlocked */
    __HAL_UNLOCK(hmdma);
2400e8ba:	68fb      	ldr	r3, [r7, #12]
2400e8bc:	2200      	movs	r2, #0
2400e8be:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

    /* Return error status */
    return HAL_BUSY;
2400e8c2:	2302      	movs	r3, #2
  }
}
2400e8c4:	4618      	mov	r0, r3
2400e8c6:	3724      	adds	r7, #36	; 0x24
2400e8c8:	46bd      	mov	sp, r7
2400e8ca:	f85d 7b04 	ldr.w	r7, [sp], #4
2400e8ce:	4770      	bx	lr

2400e8d0 <HAL_MDMA_LinkedList_RemoveNode>:
  *                 to be removed from the list.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_MDMA_LinkedList_RemoveNode(MDMA_HandleTypeDef *hmdma, MDMA_LinkNodeTypeDef *pNode)
{
2400e8d0:	b480      	push	{r7}
2400e8d2:	b087      	sub	sp, #28
2400e8d4:	af00      	add	r7, sp, #0
2400e8d6:	6078      	str	r0, [r7, #4]
2400e8d8:	6039      	str	r1, [r7, #0]
  MDMA_LinkNodeTypeDef *ptmpNode;
  uint32_t counter = 0, nodeDeleted = 0;
2400e8da:	2300      	movs	r3, #0
2400e8dc:	613b      	str	r3, [r7, #16]
2400e8de:	2300      	movs	r3, #0
2400e8e0:	60fb      	str	r3, [r7, #12]
  HAL_StatusTypeDef hal_status = HAL_OK;
2400e8e2:	2300      	movs	r3, #0
2400e8e4:	72fb      	strb	r3, [r7, #11]

  /* Check the MDMA peripheral handle */
  if((hmdma == NULL) || (pNode == NULL))
2400e8e6:	687b      	ldr	r3, [r7, #4]
2400e8e8:	2b00      	cmp	r3, #0
2400e8ea:	d002      	beq.n	2400e8f2 <HAL_MDMA_LinkedList_RemoveNode+0x22>
2400e8ec:	683b      	ldr	r3, [r7, #0]
2400e8ee:	2b00      	cmp	r3, #0
2400e8f0:	d101      	bne.n	2400e8f6 <HAL_MDMA_LinkedList_RemoveNode+0x26>
  {
    return HAL_ERROR;
2400e8f2:	2301      	movs	r3, #1
2400e8f4:	e099      	b.n	2400ea2a <HAL_MDMA_LinkedList_RemoveNode+0x15a>
  }

  /* Process locked */
  __HAL_LOCK(hmdma);
2400e8f6:	687b      	ldr	r3, [r7, #4]
2400e8f8:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
2400e8fc:	2b01      	cmp	r3, #1
2400e8fe:	d101      	bne.n	2400e904 <HAL_MDMA_LinkedList_RemoveNode+0x34>
2400e900:	2302      	movs	r3, #2
2400e902:	e092      	b.n	2400ea2a <HAL_MDMA_LinkedList_RemoveNode+0x15a>
2400e904:	687b      	ldr	r3, [r7, #4]
2400e906:	2201      	movs	r2, #1
2400e908:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  if(HAL_MDMA_STATE_READY == hmdma->State)
2400e90c:	687b      	ldr	r3, [r7, #4]
2400e90e:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
2400e912:	b2db      	uxtb	r3, r3
2400e914:	2b01      	cmp	r3, #1
2400e916:	f040 8083 	bne.w	2400ea20 <HAL_MDMA_LinkedList_RemoveNode+0x150>
  {
    /* Change MDMA peripheral state */
    hmdma->State = HAL_MDMA_STATE_BUSY;
2400e91a:	687b      	ldr	r3, [r7, #4]
2400e91c:	2202      	movs	r2, #2
2400e91e:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

    /* If first and last node are null (no nodes in the list) : return error*/
    if(((uint32_t)hmdma->FirstLinkedListNodeAddress == 0U) || ((uint32_t)hmdma->LastLinkedListNodeAddress == 0U) || (hmdma->LinkedListNodeCounter == 0U))
2400e922:	687b      	ldr	r3, [r7, #4]
2400e924:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
2400e926:	2b00      	cmp	r3, #0
2400e928:	d007      	beq.n	2400e93a <HAL_MDMA_LinkedList_RemoveNode+0x6a>
2400e92a:	687b      	ldr	r3, [r7, #4]
2400e92c:	6e1b      	ldr	r3, [r3, #96]	; 0x60
2400e92e:	2b00      	cmp	r3, #0
2400e930:	d003      	beq.n	2400e93a <HAL_MDMA_LinkedList_RemoveNode+0x6a>
2400e932:	687b      	ldr	r3, [r7, #4]
2400e934:	6e5b      	ldr	r3, [r3, #100]	; 0x64
2400e936:	2b00      	cmp	r3, #0
2400e938:	d102      	bne.n	2400e940 <HAL_MDMA_LinkedList_RemoveNode+0x70>
    {
      hal_status = HAL_ERROR;
2400e93a:	2301      	movs	r3, #1
2400e93c:	72fb      	strb	r3, [r7, #11]
2400e93e:	e065      	b.n	2400ea0c <HAL_MDMA_LinkedList_RemoveNode+0x13c>
    }
    else if(hmdma->FirstLinkedListNodeAddress == pNode) /* Deleting first node */
2400e940:	687b      	ldr	r3, [r7, #4]
2400e942:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
2400e944:	683a      	ldr	r2, [r7, #0]
2400e946:	429a      	cmp	r2, r3
2400e948:	d130      	bne.n	2400e9ac <HAL_MDMA_LinkedList_RemoveNode+0xdc>
    {
      /* Delete 1st node */
      if(hmdma->LastLinkedListNodeAddress == pNode)
2400e94a:	687b      	ldr	r3, [r7, #4]
2400e94c:	6e1b      	ldr	r3, [r3, #96]	; 0x60
2400e94e:	683a      	ldr	r2, [r7, #0]
2400e950:	429a      	cmp	r2, r3
2400e952:	d10d      	bne.n	2400e970 <HAL_MDMA_LinkedList_RemoveNode+0xa0>
      {
        /*if the last node is at the same time the first one (1 single node after the init node 0)
        then update the last node too */

        hmdma->FirstLinkedListNodeAddress = 0;
2400e954:	687b      	ldr	r3, [r7, #4]
2400e956:	2200      	movs	r2, #0
2400e958:	65da      	str	r2, [r3, #92]	; 0x5c
        hmdma->LastLinkedListNodeAddress  = 0;
2400e95a:	687b      	ldr	r3, [r7, #4]
2400e95c:	2200      	movs	r2, #0
2400e95e:	661a      	str	r2, [r3, #96]	; 0x60
        hmdma->LinkedListNodeCounter = 0;
2400e960:	687b      	ldr	r3, [r7, #4]
2400e962:	2200      	movs	r2, #0
2400e964:	665a      	str	r2, [r3, #100]	; 0x64

        hmdma->Instance->CLAR = 0;
2400e966:	687b      	ldr	r3, [r7, #4]
2400e968:	681b      	ldr	r3, [r3, #0]
2400e96a:	2200      	movs	r2, #0
2400e96c:	625a      	str	r2, [r3, #36]	; 0x24
2400e96e:	e04d      	b.n	2400ea0c <HAL_MDMA_LinkedList_RemoveNode+0x13c>
      }
      else
      {
        if((uint32_t)hmdma->FirstLinkedListNodeAddress == hmdma->LastLinkedListNodeAddress->CLAR)
2400e970:	687b      	ldr	r3, [r7, #4]
2400e972:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
2400e974:	461a      	mov	r2, r3
2400e976:	687b      	ldr	r3, [r7, #4]
2400e978:	6e1b      	ldr	r3, [r3, #96]	; 0x60
2400e97a:	695b      	ldr	r3, [r3, #20]
2400e97c:	429a      	cmp	r2, r3
2400e97e:	d104      	bne.n	2400e98a <HAL_MDMA_LinkedList_RemoveNode+0xba>
        {
          /* if last node is looping to first (circular list) one update the last node connection */
          hmdma->LastLinkedListNodeAddress->CLAR = pNode->CLAR;
2400e980:	687b      	ldr	r3, [r7, #4]
2400e982:	6e1b      	ldr	r3, [r3, #96]	; 0x60
2400e984:	683a      	ldr	r2, [r7, #0]
2400e986:	6952      	ldr	r2, [r2, #20]
2400e988:	615a      	str	r2, [r3, #20]
        }

        /* if deleting the first node after the initialization
        connect the next node to the node 0 by updating
        the MDMA channel CLAR register to this node address */
        hmdma->Instance->CLAR = pNode->CLAR;
2400e98a:	687b      	ldr	r3, [r7, #4]
2400e98c:	681b      	ldr	r3, [r3, #0]
2400e98e:	683a      	ldr	r2, [r7, #0]
2400e990:	6952      	ldr	r2, [r2, #20]
2400e992:	625a      	str	r2, [r3, #36]	; 0x24
        hmdma->FirstLinkedListNodeAddress = (MDMA_LinkNodeTypeDef *)hmdma->Instance->CLAR;
2400e994:	687b      	ldr	r3, [r7, #4]
2400e996:	681b      	ldr	r3, [r3, #0]
2400e998:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400e99a:	461a      	mov	r2, r3
2400e99c:	687b      	ldr	r3, [r7, #4]
2400e99e:	65da      	str	r2, [r3, #92]	; 0x5c
        /* Update the Handle node counter */
        hmdma->LinkedListNodeCounter--;
2400e9a0:	687b      	ldr	r3, [r7, #4]
2400e9a2:	6e5b      	ldr	r3, [r3, #100]	; 0x64
2400e9a4:	1e5a      	subs	r2, r3, #1
2400e9a6:	687b      	ldr	r3, [r7, #4]
2400e9a8:	665a      	str	r2, [r3, #100]	; 0x64
2400e9aa:	e02f      	b.n	2400ea0c <HAL_MDMA_LinkedList_RemoveNode+0x13c>
      }
    }
    else /* Deleting any other node */
    {
      /*Deleted node is not the first one : find it  */
      ptmpNode = hmdma->FirstLinkedListNodeAddress;
2400e9ac:	687b      	ldr	r3, [r7, #4]
2400e9ae:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
2400e9b0:	617b      	str	r3, [r7, #20]
      while((counter < hmdma->LinkedListNodeCounter) && (nodeDeleted == 0U))
2400e9b2:	e01e      	b.n	2400e9f2 <HAL_MDMA_LinkedList_RemoveNode+0x122>
      {
        counter++;
2400e9b4:	693b      	ldr	r3, [r7, #16]
2400e9b6:	3301      	adds	r3, #1
2400e9b8:	613b      	str	r3, [r7, #16]
        if(ptmpNode->CLAR == ((uint32_t)pNode))
2400e9ba:	697b      	ldr	r3, [r7, #20]
2400e9bc:	695a      	ldr	r2, [r3, #20]
2400e9be:	683b      	ldr	r3, [r7, #0]
2400e9c0:	429a      	cmp	r2, r3
2400e9c2:	d113      	bne.n	2400e9ec <HAL_MDMA_LinkedList_RemoveNode+0x11c>
        {
          /* if deleting the last node */
          if(pNode == hmdma->LastLinkedListNodeAddress)
2400e9c4:	687b      	ldr	r3, [r7, #4]
2400e9c6:	6e1b      	ldr	r3, [r3, #96]	; 0x60
2400e9c8:	683a      	ldr	r2, [r7, #0]
2400e9ca:	429a      	cmp	r2, r3
2400e9cc:	d102      	bne.n	2400e9d4 <HAL_MDMA_LinkedList_RemoveNode+0x104>
          {
            /*Update the linked list last node address in the handle*/
            hmdma->LastLinkedListNodeAddress = ptmpNode;
2400e9ce:	687b      	ldr	r3, [r7, #4]
2400e9d0:	697a      	ldr	r2, [r7, #20]
2400e9d2:	661a      	str	r2, [r3, #96]	; 0x60
          }
          /* update the next node link after deleting pMDMA_LinkedListNode */
          ptmpNode->CLAR = pNode->CLAR;
2400e9d4:	683b      	ldr	r3, [r7, #0]
2400e9d6:	695a      	ldr	r2, [r3, #20]
2400e9d8:	697b      	ldr	r3, [r7, #20]
2400e9da:	615a      	str	r2, [r3, #20]
          nodeDeleted = 1;
2400e9dc:	2301      	movs	r3, #1
2400e9de:	60fb      	str	r3, [r7, #12]
          /* Update the Handle node counter */
          hmdma->LinkedListNodeCounter--;
2400e9e0:	687b      	ldr	r3, [r7, #4]
2400e9e2:	6e5b      	ldr	r3, [r3, #100]	; 0x64
2400e9e4:	1e5a      	subs	r2, r3, #1
2400e9e6:	687b      	ldr	r3, [r7, #4]
2400e9e8:	665a      	str	r2, [r3, #100]	; 0x64
2400e9ea:	e002      	b.n	2400e9f2 <HAL_MDMA_LinkedList_RemoveNode+0x122>
        }
        else
        {
          ptmpNode = (MDMA_LinkNodeTypeDef *)ptmpNode->CLAR;
2400e9ec:	697b      	ldr	r3, [r7, #20]
2400e9ee:	695b      	ldr	r3, [r3, #20]
2400e9f0:	617b      	str	r3, [r7, #20]
      while((counter < hmdma->LinkedListNodeCounter) && (nodeDeleted == 0U))
2400e9f2:	687b      	ldr	r3, [r7, #4]
2400e9f4:	6e5b      	ldr	r3, [r3, #100]	; 0x64
2400e9f6:	693a      	ldr	r2, [r7, #16]
2400e9f8:	429a      	cmp	r2, r3
2400e9fa:	d202      	bcs.n	2400ea02 <HAL_MDMA_LinkedList_RemoveNode+0x132>
2400e9fc:	68fb      	ldr	r3, [r7, #12]
2400e9fe:	2b00      	cmp	r3, #0
2400ea00:	d0d8      	beq.n	2400e9b4 <HAL_MDMA_LinkedList_RemoveNode+0xe4>
        }
      }

      if(nodeDeleted == 0U)
2400ea02:	68fb      	ldr	r3, [r7, #12]
2400ea04:	2b00      	cmp	r3, #0
2400ea06:	d101      	bne.n	2400ea0c <HAL_MDMA_LinkedList_RemoveNode+0x13c>
      {
        /* last node reashed without finding the node to delete : return error */
        hal_status = HAL_ERROR;
2400ea08:	2301      	movs	r3, #1
2400ea0a:	72fb      	strb	r3, [r7, #11]
      }
    }

    /* Process unlocked */
    __HAL_UNLOCK(hmdma);
2400ea0c:	687b      	ldr	r3, [r7, #4]
2400ea0e:	2200      	movs	r2, #0
2400ea10:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

    hmdma->State = HAL_MDMA_STATE_READY;
2400ea14:	687b      	ldr	r3, [r7, #4]
2400ea16:	2201      	movs	r2, #1
2400ea18:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

    return hal_status;
2400ea1c:	7afb      	ldrb	r3, [r7, #11]
2400ea1e:	e004      	b.n	2400ea2a <HAL_MDMA_LinkedList_RemoveNode+0x15a>
  }
  else
  {
    /* Process unlocked */
    __HAL_UNLOCK(hmdma);
2400ea20:	687b      	ldr	r3, [r7, #4]
2400ea22:	2200      	movs	r2, #0
2400ea24:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

    /* Return error status */
    return HAL_BUSY;
2400ea28:	2302      	movs	r3, #2
  }
}
2400ea2a:	4618      	mov	r0, r3
2400ea2c:	371c      	adds	r7, #28
2400ea2e:	46bd      	mov	sp, r7
2400ea30:	f85d 7b04 	ldr.w	r7, [sp], #4
2400ea34:	4770      	bx	lr

2400ea36 <HAL_MDMA_LinkedList_EnableCircularMode>:
  * @param  hmdma : Pointer to a MDMA_HandleTypeDef structure that contains
  *                 the configuration information for the specified MDMA Channel.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_MDMA_LinkedList_EnableCircularMode(MDMA_HandleTypeDef *hmdma)
{
2400ea36:	b480      	push	{r7}
2400ea38:	b085      	sub	sp, #20
2400ea3a:	af00      	add	r7, sp, #0
2400ea3c:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef hal_status = HAL_OK;
2400ea3e:	2300      	movs	r3, #0
2400ea40:	73fb      	strb	r3, [r7, #15]

  /* Check the MDMA peripheral handle */
  if(hmdma == NULL)
2400ea42:	687b      	ldr	r3, [r7, #4]
2400ea44:	2b00      	cmp	r3, #0
2400ea46:	d101      	bne.n	2400ea4c <HAL_MDMA_LinkedList_EnableCircularMode+0x16>
  {
    return HAL_ERROR;
2400ea48:	2301      	movs	r3, #1
2400ea4a:	e031      	b.n	2400eab0 <HAL_MDMA_LinkedList_EnableCircularMode+0x7a>
  }

  /* Process locked */
  __HAL_LOCK(hmdma);
2400ea4c:	687b      	ldr	r3, [r7, #4]
2400ea4e:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
2400ea52:	2b01      	cmp	r3, #1
2400ea54:	d101      	bne.n	2400ea5a <HAL_MDMA_LinkedList_EnableCircularMode+0x24>
2400ea56:	2302      	movs	r3, #2
2400ea58:	e02a      	b.n	2400eab0 <HAL_MDMA_LinkedList_EnableCircularMode+0x7a>
2400ea5a:	687b      	ldr	r3, [r7, #4]
2400ea5c:	2201      	movs	r2, #1
2400ea5e:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  if(HAL_MDMA_STATE_READY == hmdma->State)
2400ea62:	687b      	ldr	r3, [r7, #4]
2400ea64:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
2400ea68:	b2db      	uxtb	r3, r3
2400ea6a:	2b01      	cmp	r3, #1
2400ea6c:	d117      	bne.n	2400ea9e <HAL_MDMA_LinkedList_EnableCircularMode+0x68>
  {
    /* Change MDMA peripheral state */
    hmdma->State = HAL_MDMA_STATE_BUSY;
2400ea6e:	687b      	ldr	r3, [r7, #4]
2400ea70:	2202      	movs	r2, #2
2400ea72:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

    /* If first and last node are null (no nodes in the list) : return error*/
    if(((uint32_t)hmdma->FirstLinkedListNodeAddress == 0U) || ((uint32_t)hmdma->LastLinkedListNodeAddress == 0U) || (hmdma->LinkedListNodeCounter == 0U))
2400ea76:	687b      	ldr	r3, [r7, #4]
2400ea78:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
2400ea7a:	2b00      	cmp	r3, #0
2400ea7c:	d007      	beq.n	2400ea8e <HAL_MDMA_LinkedList_EnableCircularMode+0x58>
2400ea7e:	687b      	ldr	r3, [r7, #4]
2400ea80:	6e1b      	ldr	r3, [r3, #96]	; 0x60
2400ea82:	2b00      	cmp	r3, #0
2400ea84:	d003      	beq.n	2400ea8e <HAL_MDMA_LinkedList_EnableCircularMode+0x58>
2400ea86:	687b      	ldr	r3, [r7, #4]
2400ea88:	6e5b      	ldr	r3, [r3, #100]	; 0x64
2400ea8a:	2b00      	cmp	r3, #0
2400ea8c:	d102      	bne.n	2400ea94 <HAL_MDMA_LinkedList_EnableCircularMode+0x5e>
    {
      hal_status = HAL_ERROR;
2400ea8e:	2301      	movs	r3, #1
2400ea90:	73fb      	strb	r3, [r7, #15]
2400ea92:	e004      	b.n	2400ea9e <HAL_MDMA_LinkedList_EnableCircularMode+0x68>
    }
    else
    {
      /* to enable circular mode Last Node should be connected to first node */
      hmdma->LastLinkedListNodeAddress->CLAR = (uint32_t)hmdma->FirstLinkedListNodeAddress;
2400ea94:	687b      	ldr	r3, [r7, #4]
2400ea96:	6dda      	ldr	r2, [r3, #92]	; 0x5c
2400ea98:	687b      	ldr	r3, [r7, #4]
2400ea9a:	6e1b      	ldr	r3, [r3, #96]	; 0x60
2400ea9c:	615a      	str	r2, [r3, #20]
    }

  }
  /* Process unlocked */
  __HAL_UNLOCK(hmdma);
2400ea9e:	687b      	ldr	r3, [r7, #4]
2400eaa0:	2200      	movs	r2, #0
2400eaa2:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  hmdma->State = HAL_MDMA_STATE_READY;
2400eaa6:	687b      	ldr	r3, [r7, #4]
2400eaa8:	2201      	movs	r2, #1
2400eaaa:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  return hal_status;
2400eaae:	7bfb      	ldrb	r3, [r7, #15]
}
2400eab0:	4618      	mov	r0, r3
2400eab2:	3714      	adds	r7, #20
2400eab4:	46bd      	mov	sp, r7
2400eab6:	f85d 7b04 	ldr.w	r7, [sp], #4
2400eaba:	4770      	bx	lr

2400eabc <HAL_MDMA_LinkedList_DisableCircularMode>:
  * @param  hmdma : Pointer to a MDMA_HandleTypeDef structure that contains
  *                 the configuration information for the specified MDMA Channel.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_MDMA_LinkedList_DisableCircularMode(MDMA_HandleTypeDef *hmdma)
{
2400eabc:	b480      	push	{r7}
2400eabe:	b085      	sub	sp, #20
2400eac0:	af00      	add	r7, sp, #0
2400eac2:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef hal_status = HAL_OK;
2400eac4:	2300      	movs	r3, #0
2400eac6:	73fb      	strb	r3, [r7, #15]

  /* Check the MDMA peripheral handle */
  if(hmdma == NULL)
2400eac8:	687b      	ldr	r3, [r7, #4]
2400eaca:	2b00      	cmp	r3, #0
2400eacc:	d101      	bne.n	2400ead2 <HAL_MDMA_LinkedList_DisableCircularMode+0x16>
  {
    return HAL_ERROR;
2400eace:	2301      	movs	r3, #1
2400ead0:	e030      	b.n	2400eb34 <HAL_MDMA_LinkedList_DisableCircularMode+0x78>
  }

  /* Process locked */
  __HAL_LOCK(hmdma);
2400ead2:	687b      	ldr	r3, [r7, #4]
2400ead4:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
2400ead8:	2b01      	cmp	r3, #1
2400eada:	d101      	bne.n	2400eae0 <HAL_MDMA_LinkedList_DisableCircularMode+0x24>
2400eadc:	2302      	movs	r3, #2
2400eade:	e029      	b.n	2400eb34 <HAL_MDMA_LinkedList_DisableCircularMode+0x78>
2400eae0:	687b      	ldr	r3, [r7, #4]
2400eae2:	2201      	movs	r2, #1
2400eae4:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  if(HAL_MDMA_STATE_READY == hmdma->State)
2400eae8:	687b      	ldr	r3, [r7, #4]
2400eaea:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
2400eaee:	b2db      	uxtb	r3, r3
2400eaf0:	2b01      	cmp	r3, #1
2400eaf2:	d116      	bne.n	2400eb22 <HAL_MDMA_LinkedList_DisableCircularMode+0x66>
  {
    /* Change MDMA peripheral state */
    hmdma->State = HAL_MDMA_STATE_BUSY;
2400eaf4:	687b      	ldr	r3, [r7, #4]
2400eaf6:	2202      	movs	r2, #2
2400eaf8:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

    /* If first and last node are null (no nodes in the list) : return error*/
    if(((uint32_t)hmdma->FirstLinkedListNodeAddress == 0U) || ((uint32_t)hmdma->LastLinkedListNodeAddress == 0U) || (hmdma->LinkedListNodeCounter == 0U))
2400eafc:	687b      	ldr	r3, [r7, #4]
2400eafe:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
2400eb00:	2b00      	cmp	r3, #0
2400eb02:	d007      	beq.n	2400eb14 <HAL_MDMA_LinkedList_DisableCircularMode+0x58>
2400eb04:	687b      	ldr	r3, [r7, #4]
2400eb06:	6e1b      	ldr	r3, [r3, #96]	; 0x60
2400eb08:	2b00      	cmp	r3, #0
2400eb0a:	d003      	beq.n	2400eb14 <HAL_MDMA_LinkedList_DisableCircularMode+0x58>
2400eb0c:	687b      	ldr	r3, [r7, #4]
2400eb0e:	6e5b      	ldr	r3, [r3, #100]	; 0x64
2400eb10:	2b00      	cmp	r3, #0
2400eb12:	d102      	bne.n	2400eb1a <HAL_MDMA_LinkedList_DisableCircularMode+0x5e>
    {
      hal_status = HAL_ERROR;
2400eb14:	2301      	movs	r3, #1
2400eb16:	73fb      	strb	r3, [r7, #15]
2400eb18:	e003      	b.n	2400eb22 <HAL_MDMA_LinkedList_DisableCircularMode+0x66>
    }
    else
    {
      /* to disable circular mode Last Node should be connected to NULL */
      hmdma->LastLinkedListNodeAddress->CLAR = 0;
2400eb1a:	687b      	ldr	r3, [r7, #4]
2400eb1c:	6e1b      	ldr	r3, [r3, #96]	; 0x60
2400eb1e:	2200      	movs	r2, #0
2400eb20:	615a      	str	r2, [r3, #20]
    }

  }
  /* Process unlocked */
  __HAL_UNLOCK(hmdma);
2400eb22:	687b      	ldr	r3, [r7, #4]
2400eb24:	2200      	movs	r2, #0
2400eb26:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  hmdma->State = HAL_MDMA_STATE_READY;
2400eb2a:	687b      	ldr	r3, [r7, #4]
2400eb2c:	2201      	movs	r2, #1
2400eb2e:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  return hal_status;
2400eb32:	7bfb      	ldrb	r3, [r7, #15]
}
2400eb34:	4618      	mov	r0, r3
2400eb36:	3714      	adds	r7, #20
2400eb38:	46bd      	mov	sp, r7
2400eb3a:	f85d 7b04 	ldr.w	r7, [sp], #4
2400eb3e:	4770      	bx	lr

2400eb40 <HAL_MDMA_Start>:
  * @param  BlockDataLength : The length of a block transfer in bytes
  * @param  BlockCount      : The number of a blocks to be transfer
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_MDMA_Start(MDMA_HandleTypeDef *hmdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t BlockDataLength, uint32_t BlockCount)
{
2400eb40:	b580      	push	{r7, lr}
2400eb42:	b086      	sub	sp, #24
2400eb44:	af02      	add	r7, sp, #8
2400eb46:	60f8      	str	r0, [r7, #12]
2400eb48:	60b9      	str	r1, [r7, #8]
2400eb4a:	607a      	str	r2, [r7, #4]
2400eb4c:	603b      	str	r3, [r7, #0]
  /* Check the parameters */
  assert_param(IS_MDMA_TRANSFER_LENGTH(BlockDataLength));
  assert_param(IS_MDMA_BLOCK_COUNT(BlockCount));

  /* Check the MDMA peripheral handle */
  if(hmdma == NULL)
2400eb4e:	68fb      	ldr	r3, [r7, #12]
2400eb50:	2b00      	cmp	r3, #0
2400eb52:	d101      	bne.n	2400eb58 <HAL_MDMA_Start+0x18>
  {
    return HAL_ERROR;
2400eb54:	2301      	movs	r3, #1
2400eb56:	e044      	b.n	2400ebe2 <HAL_MDMA_Start+0xa2>
  }

  /* Process locked */
  __HAL_LOCK(hmdma);
2400eb58:	68fb      	ldr	r3, [r7, #12]
2400eb5a:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
2400eb5e:	2b01      	cmp	r3, #1
2400eb60:	d101      	bne.n	2400eb66 <HAL_MDMA_Start+0x26>
2400eb62:	2302      	movs	r3, #2
2400eb64:	e03d      	b.n	2400ebe2 <HAL_MDMA_Start+0xa2>
2400eb66:	68fb      	ldr	r3, [r7, #12]
2400eb68:	2201      	movs	r2, #1
2400eb6a:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  if(HAL_MDMA_STATE_READY == hmdma->State)
2400eb6e:	68fb      	ldr	r3, [r7, #12]
2400eb70:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
2400eb74:	b2db      	uxtb	r3, r3
2400eb76:	2b01      	cmp	r3, #1
2400eb78:	d12c      	bne.n	2400ebd4 <HAL_MDMA_Start+0x94>
  {
    /* Change MDMA peripheral state */
    hmdma->State = HAL_MDMA_STATE_BUSY;
2400eb7a:	68fb      	ldr	r3, [r7, #12]
2400eb7c:	2202      	movs	r2, #2
2400eb7e:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

    /* Initialize the error code */
    hmdma->ErrorCode = HAL_MDMA_ERROR_NONE;
2400eb82:	68fb      	ldr	r3, [r7, #12]
2400eb84:	2200      	movs	r2, #0
2400eb86:	669a      	str	r2, [r3, #104]	; 0x68

    /* Disable the peripheral */
    __HAL_MDMA_DISABLE(hmdma);
2400eb88:	68fb      	ldr	r3, [r7, #12]
2400eb8a:	681b      	ldr	r3, [r3, #0]
2400eb8c:	68da      	ldr	r2, [r3, #12]
2400eb8e:	68fb      	ldr	r3, [r7, #12]
2400eb90:	681b      	ldr	r3, [r3, #0]
2400eb92:	f022 0201 	bic.w	r2, r2, #1
2400eb96:	60da      	str	r2, [r3, #12]

    /* Configure the source, destination address and the data length */
    MDMA_SetConfig(hmdma, SrcAddress, DstAddress, BlockDataLength, BlockCount);
2400eb98:	69bb      	ldr	r3, [r7, #24]
2400eb9a:	9300      	str	r3, [sp, #0]
2400eb9c:	683b      	ldr	r3, [r7, #0]
2400eb9e:	687a      	ldr	r2, [r7, #4]
2400eba0:	68b9      	ldr	r1, [r7, #8]
2400eba2:	68f8      	ldr	r0, [r7, #12]
2400eba4:	f000 fb98 	bl	2400f2d8 <MDMA_SetConfig>

    /* Enable the Peripheral */
    __HAL_MDMA_ENABLE(hmdma);
2400eba8:	68fb      	ldr	r3, [r7, #12]
2400ebaa:	681b      	ldr	r3, [r3, #0]
2400ebac:	68da      	ldr	r2, [r3, #12]
2400ebae:	68fb      	ldr	r3, [r7, #12]
2400ebb0:	681b      	ldr	r3, [r3, #0]
2400ebb2:	f042 0201 	orr.w	r2, r2, #1
2400ebb6:	60da      	str	r2, [r3, #12]

    if(hmdma->Init.Request == MDMA_REQUEST_SW)
2400ebb8:	68fb      	ldr	r3, [r7, #12]
2400ebba:	685b      	ldr	r3, [r3, #4]
2400ebbc:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
2400ebc0:	d10e      	bne.n	2400ebe0 <HAL_MDMA_Start+0xa0>
    {
      /* activate If SW request mode*/
      hmdma->Instance->CCR |=  MDMA_CCR_SWRQ;
2400ebc2:	68fb      	ldr	r3, [r7, #12]
2400ebc4:	681b      	ldr	r3, [r3, #0]
2400ebc6:	68da      	ldr	r2, [r3, #12]
2400ebc8:	68fb      	ldr	r3, [r7, #12]
2400ebca:	681b      	ldr	r3, [r3, #0]
2400ebcc:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
2400ebd0:	60da      	str	r2, [r3, #12]
2400ebd2:	e005      	b.n	2400ebe0 <HAL_MDMA_Start+0xa0>
    }
  }
  else
  {
    /* Process unlocked */
    __HAL_UNLOCK(hmdma);
2400ebd4:	68fb      	ldr	r3, [r7, #12]
2400ebd6:	2200      	movs	r2, #0
2400ebd8:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

    /* Return error status */
    return HAL_BUSY;
2400ebdc:	2302      	movs	r3, #2
2400ebde:	e000      	b.n	2400ebe2 <HAL_MDMA_Start+0xa2>
  }

  return HAL_OK;
2400ebe0:	2300      	movs	r3, #0
}
2400ebe2:	4618      	mov	r0, r3
2400ebe4:	3710      	adds	r7, #16
2400ebe6:	46bd      	mov	sp, r7
2400ebe8:	bd80      	pop	{r7, pc}

2400ebea <HAL_MDMA_Start_IT>:
  * @param  BlockDataLength : The length of a block transfer in bytes
  * @param  BlockCount      : The number of a blocks to be transfer
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_MDMA_Start_IT(MDMA_HandleTypeDef *hmdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t BlockDataLength, uint32_t BlockCount)
{
2400ebea:	b580      	push	{r7, lr}
2400ebec:	b086      	sub	sp, #24
2400ebee:	af02      	add	r7, sp, #8
2400ebf0:	60f8      	str	r0, [r7, #12]
2400ebf2:	60b9      	str	r1, [r7, #8]
2400ebf4:	607a      	str	r2, [r7, #4]
2400ebf6:	603b      	str	r3, [r7, #0]
  /* Check the parameters */
  assert_param(IS_MDMA_TRANSFER_LENGTH(BlockDataLength));
  assert_param(IS_MDMA_BLOCK_COUNT(BlockCount));

  /* Check the MDMA peripheral handle */
  if(hmdma == NULL)
2400ebf8:	68fb      	ldr	r3, [r7, #12]
2400ebfa:	2b00      	cmp	r3, #0
2400ebfc:	d101      	bne.n	2400ec02 <HAL_MDMA_Start_IT+0x18>
  {
    return HAL_ERROR;
2400ebfe:	2301      	movs	r3, #1
2400ec00:	e070      	b.n	2400ece4 <HAL_MDMA_Start_IT+0xfa>
  }

  /* Process locked */
  __HAL_LOCK(hmdma);
2400ec02:	68fb      	ldr	r3, [r7, #12]
2400ec04:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
2400ec08:	2b01      	cmp	r3, #1
2400ec0a:	d101      	bne.n	2400ec10 <HAL_MDMA_Start_IT+0x26>
2400ec0c:	2302      	movs	r3, #2
2400ec0e:	e069      	b.n	2400ece4 <HAL_MDMA_Start_IT+0xfa>
2400ec10:	68fb      	ldr	r3, [r7, #12]
2400ec12:	2201      	movs	r2, #1
2400ec14:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  if(HAL_MDMA_STATE_READY == hmdma->State)
2400ec18:	68fb      	ldr	r3, [r7, #12]
2400ec1a:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
2400ec1e:	b2db      	uxtb	r3, r3
2400ec20:	2b01      	cmp	r3, #1
2400ec22:	d158      	bne.n	2400ecd6 <HAL_MDMA_Start_IT+0xec>
  {
    /* Change MDMA peripheral state */
    hmdma->State = HAL_MDMA_STATE_BUSY;
2400ec24:	68fb      	ldr	r3, [r7, #12]
2400ec26:	2202      	movs	r2, #2
2400ec28:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

    /* Initialize the error code */
    hmdma->ErrorCode = HAL_MDMA_ERROR_NONE;
2400ec2c:	68fb      	ldr	r3, [r7, #12]
2400ec2e:	2200      	movs	r2, #0
2400ec30:	669a      	str	r2, [r3, #104]	; 0x68

    /* Disable the peripheral */
    __HAL_MDMA_DISABLE(hmdma);
2400ec32:	68fb      	ldr	r3, [r7, #12]
2400ec34:	681b      	ldr	r3, [r3, #0]
2400ec36:	68da      	ldr	r2, [r3, #12]
2400ec38:	68fb      	ldr	r3, [r7, #12]
2400ec3a:	681b      	ldr	r3, [r3, #0]
2400ec3c:	f022 0201 	bic.w	r2, r2, #1
2400ec40:	60da      	str	r2, [r3, #12]

    /* Configure the source, destination address and the data length */
    MDMA_SetConfig(hmdma, SrcAddress, DstAddress, BlockDataLength, BlockCount);
2400ec42:	69bb      	ldr	r3, [r7, #24]
2400ec44:	9300      	str	r3, [sp, #0]
2400ec46:	683b      	ldr	r3, [r7, #0]
2400ec48:	687a      	ldr	r2, [r7, #4]
2400ec4a:	68b9      	ldr	r1, [r7, #8]
2400ec4c:	68f8      	ldr	r0, [r7, #12]
2400ec4e:	f000 fb43 	bl	2400f2d8 <MDMA_SetConfig>

    /* Enable Common interrupts i.e Transfer Error IT and Channel Transfer Complete IT*/
    __HAL_MDMA_ENABLE_IT(hmdma, (MDMA_IT_TE | MDMA_IT_CTC));
2400ec52:	68fb      	ldr	r3, [r7, #12]
2400ec54:	681b      	ldr	r3, [r3, #0]
2400ec56:	68da      	ldr	r2, [r3, #12]
2400ec58:	68fb      	ldr	r3, [r7, #12]
2400ec5a:	681b      	ldr	r3, [r3, #0]
2400ec5c:	f042 0206 	orr.w	r2, r2, #6
2400ec60:	60da      	str	r2, [r3, #12]

    if(hmdma->XferBlockCpltCallback != NULL)
2400ec62:	68fb      	ldr	r3, [r7, #12]
2400ec64:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
2400ec66:	2b00      	cmp	r3, #0
2400ec68:	d007      	beq.n	2400ec7a <HAL_MDMA_Start_IT+0x90>
    {
      /* if Block transfer complete Callback is set enable the corresponding IT*/
      __HAL_MDMA_ENABLE_IT(hmdma, MDMA_IT_BT);
2400ec6a:	68fb      	ldr	r3, [r7, #12]
2400ec6c:	681b      	ldr	r3, [r3, #0]
2400ec6e:	68da      	ldr	r2, [r3, #12]
2400ec70:	68fb      	ldr	r3, [r7, #12]
2400ec72:	681b      	ldr	r3, [r3, #0]
2400ec74:	f042 0210 	orr.w	r2, r2, #16
2400ec78:	60da      	str	r2, [r3, #12]
    }

    if(hmdma->XferRepeatBlockCpltCallback != NULL)
2400ec7a:	68fb      	ldr	r3, [r7, #12]
2400ec7c:	6d1b      	ldr	r3, [r3, #80]	; 0x50
2400ec7e:	2b00      	cmp	r3, #0
2400ec80:	d007      	beq.n	2400ec92 <HAL_MDMA_Start_IT+0xa8>
    {
      /* if Repeated Block transfer complete Callback is set enable the corresponding IT*/
      __HAL_MDMA_ENABLE_IT(hmdma, MDMA_IT_BRT);
2400ec82:	68fb      	ldr	r3, [r7, #12]
2400ec84:	681b      	ldr	r3, [r3, #0]
2400ec86:	68da      	ldr	r2, [r3, #12]
2400ec88:	68fb      	ldr	r3, [r7, #12]
2400ec8a:	681b      	ldr	r3, [r3, #0]
2400ec8c:	f042 0208 	orr.w	r2, r2, #8
2400ec90:	60da      	str	r2, [r3, #12]
    }

    if(hmdma->XferBufferCpltCallback != NULL)
2400ec92:	68fb      	ldr	r3, [r7, #12]
2400ec94:	6c9b      	ldr	r3, [r3, #72]	; 0x48
2400ec96:	2b00      	cmp	r3, #0
2400ec98:	d007      	beq.n	2400ecaa <HAL_MDMA_Start_IT+0xc0>
    {
      /* if buffer transfer complete Callback is set enable the corresponding IT*/
      __HAL_MDMA_ENABLE_IT(hmdma, MDMA_IT_BFTC);
2400ec9a:	68fb      	ldr	r3, [r7, #12]
2400ec9c:	681b      	ldr	r3, [r3, #0]
2400ec9e:	68da      	ldr	r2, [r3, #12]
2400eca0:	68fb      	ldr	r3, [r7, #12]
2400eca2:	681b      	ldr	r3, [r3, #0]
2400eca4:	f042 0220 	orr.w	r2, r2, #32
2400eca8:	60da      	str	r2, [r3, #12]
    }

    /* Enable the Peripheral */
    __HAL_MDMA_ENABLE(hmdma);
2400ecaa:	68fb      	ldr	r3, [r7, #12]
2400ecac:	681b      	ldr	r3, [r3, #0]
2400ecae:	68da      	ldr	r2, [r3, #12]
2400ecb0:	68fb      	ldr	r3, [r7, #12]
2400ecb2:	681b      	ldr	r3, [r3, #0]
2400ecb4:	f042 0201 	orr.w	r2, r2, #1
2400ecb8:	60da      	str	r2, [r3, #12]

    if(hmdma->Init.Request == MDMA_REQUEST_SW)
2400ecba:	68fb      	ldr	r3, [r7, #12]
2400ecbc:	685b      	ldr	r3, [r3, #4]
2400ecbe:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
2400ecc2:	d10e      	bne.n	2400ece2 <HAL_MDMA_Start_IT+0xf8>
    {
      /* activate If SW request mode*/
      hmdma->Instance->CCR |=  MDMA_CCR_SWRQ;
2400ecc4:	68fb      	ldr	r3, [r7, #12]
2400ecc6:	681b      	ldr	r3, [r3, #0]
2400ecc8:	68da      	ldr	r2, [r3, #12]
2400ecca:	68fb      	ldr	r3, [r7, #12]
2400eccc:	681b      	ldr	r3, [r3, #0]
2400ecce:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
2400ecd2:	60da      	str	r2, [r3, #12]
2400ecd4:	e005      	b.n	2400ece2 <HAL_MDMA_Start_IT+0xf8>
    }
  }
  else
  {
    /* Process unlocked */
    __HAL_UNLOCK(hmdma);
2400ecd6:	68fb      	ldr	r3, [r7, #12]
2400ecd8:	2200      	movs	r2, #0
2400ecda:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

    /* Return error status */
    return HAL_BUSY;
2400ecde:	2302      	movs	r3, #2
2400ece0:	e000      	b.n	2400ece4 <HAL_MDMA_Start_IT+0xfa>
  }

  return HAL_OK;
2400ece2:	2300      	movs	r3, #0
}
2400ece4:	4618      	mov	r0, r3
2400ece6:	3710      	adds	r7, #16
2400ece8:	46bd      	mov	sp, r7
2400ecea:	bd80      	pop	{r7, pc}

2400ecec <HAL_MDMA_Abort>:
  *        and the Channel will be effectively disabled only after the transfer of
  *        this single data is finished.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_MDMA_Abort(MDMA_HandleTypeDef *hmdma)
{
2400ecec:	b580      	push	{r7, lr}
2400ecee:	b084      	sub	sp, #16
2400ecf0:	af00      	add	r7, sp, #0
2400ecf2:	6078      	str	r0, [r7, #4]
  uint32_t tickstart =  HAL_GetTick();
2400ecf4:	f7f1 fdac 	bl	24000850 <HAL_GetTick>
2400ecf8:	60f8      	str	r0, [r7, #12]

  /* Check the MDMA peripheral handle */
  if(hmdma == NULL)
2400ecfa:	687b      	ldr	r3, [r7, #4]
2400ecfc:	2b00      	cmp	r3, #0
2400ecfe:	d101      	bne.n	2400ed04 <HAL_MDMA_Abort+0x18>
  {
    return HAL_ERROR;
2400ed00:	2301      	movs	r3, #1
2400ed02:	e04a      	b.n	2400ed9a <HAL_MDMA_Abort+0xae>
  }

  if(HAL_MDMA_STATE_BUSY != hmdma->State)
2400ed04:	687b      	ldr	r3, [r7, #4]
2400ed06:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
2400ed0a:	b2db      	uxtb	r3, r3
2400ed0c:	2b02      	cmp	r3, #2
2400ed0e:	d008      	beq.n	2400ed22 <HAL_MDMA_Abort+0x36>
  {
    hmdma->ErrorCode = HAL_MDMA_ERROR_NO_XFER;
2400ed10:	687b      	ldr	r3, [r7, #4]
2400ed12:	2280      	movs	r2, #128	; 0x80
2400ed14:	669a      	str	r2, [r3, #104]	; 0x68

    /* Process Unlocked */
    __HAL_UNLOCK(hmdma);
2400ed16:	687b      	ldr	r3, [r7, #4]
2400ed18:	2200      	movs	r2, #0
2400ed1a:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

    return HAL_ERROR;
2400ed1e:	2301      	movs	r3, #1
2400ed20:	e03b      	b.n	2400ed9a <HAL_MDMA_Abort+0xae>
  }
  else
  {
    /* Disable all the transfer interrupts */
    __HAL_MDMA_DISABLE_IT(hmdma, (MDMA_IT_TE | MDMA_IT_CTC | MDMA_IT_BT | MDMA_IT_BRT | MDMA_IT_BFTC));
2400ed22:	687b      	ldr	r3, [r7, #4]
2400ed24:	681b      	ldr	r3, [r3, #0]
2400ed26:	68da      	ldr	r2, [r3, #12]
2400ed28:	687b      	ldr	r3, [r7, #4]
2400ed2a:	681b      	ldr	r3, [r3, #0]
2400ed2c:	f022 023e 	bic.w	r2, r2, #62	; 0x3e
2400ed30:	60da      	str	r2, [r3, #12]

    /* Disable the channel */
    __HAL_MDMA_DISABLE(hmdma);
2400ed32:	687b      	ldr	r3, [r7, #4]
2400ed34:	681b      	ldr	r3, [r3, #0]
2400ed36:	68da      	ldr	r2, [r3, #12]
2400ed38:	687b      	ldr	r3, [r7, #4]
2400ed3a:	681b      	ldr	r3, [r3, #0]
2400ed3c:	f022 0201 	bic.w	r2, r2, #1
2400ed40:	60da      	str	r2, [r3, #12]

    /* Check if the MDMA Channel is effectively disabled */
    while((hmdma->Instance->CCR & MDMA_CCR_EN) != 0U)
2400ed42:	e016      	b.n	2400ed72 <HAL_MDMA_Abort+0x86>
    {
      /* Check for the Timeout */
      if( (HAL_GetTick()  - tickstart ) > HAL_TIMEOUT_MDMA_ABORT)
2400ed44:	f7f1 fd84 	bl	24000850 <HAL_GetTick>
2400ed48:	4602      	mov	r2, r0
2400ed4a:	68fb      	ldr	r3, [r7, #12]
2400ed4c:	1ad3      	subs	r3, r2, r3
2400ed4e:	2b05      	cmp	r3, #5
2400ed50:	d90f      	bls.n	2400ed72 <HAL_MDMA_Abort+0x86>
      {
        /* Update error code */
        hmdma->ErrorCode |= HAL_MDMA_ERROR_TIMEOUT;
2400ed52:	687b      	ldr	r3, [r7, #4]
2400ed54:	6e9b      	ldr	r3, [r3, #104]	; 0x68
2400ed56:	f043 0240 	orr.w	r2, r3, #64	; 0x40
2400ed5a:	687b      	ldr	r3, [r7, #4]
2400ed5c:	669a      	str	r2, [r3, #104]	; 0x68

        /* Process Unlocked */
        __HAL_UNLOCK(hmdma);
2400ed5e:	687b      	ldr	r3, [r7, #4]
2400ed60:	2200      	movs	r2, #0
2400ed62:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

        /* Change the MDMA state */
        hmdma->State = HAL_MDMA_STATE_ERROR;
2400ed66:	687b      	ldr	r3, [r7, #4]
2400ed68:	2203      	movs	r2, #3
2400ed6a:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

        return HAL_ERROR;
2400ed6e:	2301      	movs	r3, #1
2400ed70:	e013      	b.n	2400ed9a <HAL_MDMA_Abort+0xae>
    while((hmdma->Instance->CCR & MDMA_CCR_EN) != 0U)
2400ed72:	687b      	ldr	r3, [r7, #4]
2400ed74:	681b      	ldr	r3, [r3, #0]
2400ed76:	68db      	ldr	r3, [r3, #12]
2400ed78:	f003 0301 	and.w	r3, r3, #1
2400ed7c:	2b00      	cmp	r3, #0
2400ed7e:	d1e1      	bne.n	2400ed44 <HAL_MDMA_Abort+0x58>
      }
    }

    /* Clear all interrupt flags */
    __HAL_MDMA_CLEAR_FLAG(hmdma, (MDMA_FLAG_TE | MDMA_FLAG_CTC | MDMA_FLAG_BT | MDMA_FLAG_BRT | MDMA_FLAG_BFTC));
2400ed80:	687b      	ldr	r3, [r7, #4]
2400ed82:	681b      	ldr	r3, [r3, #0]
2400ed84:	221f      	movs	r2, #31
2400ed86:	605a      	str	r2, [r3, #4]

    /* Process Unlocked */
    __HAL_UNLOCK(hmdma);
2400ed88:	687b      	ldr	r3, [r7, #4]
2400ed8a:	2200      	movs	r2, #0
2400ed8c:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

    /* Change the MDMA state*/
    hmdma->State = HAL_MDMA_STATE_READY;
2400ed90:	687b      	ldr	r3, [r7, #4]
2400ed92:	2201      	movs	r2, #1
2400ed94:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
  }

  return HAL_OK;
2400ed98:	2300      	movs	r3, #0
}
2400ed9a:	4618      	mov	r0, r3
2400ed9c:	3710      	adds	r7, #16
2400ed9e:	46bd      	mov	sp, r7
2400eda0:	bd80      	pop	{r7, pc}

2400eda2 <HAL_MDMA_Abort_IT>:
  * @param  hmdma  : pointer to a MDMA_HandleTypeDef structure that contains
  *                 the configuration information for the specified MDMA Channel.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_MDMA_Abort_IT(MDMA_HandleTypeDef *hmdma)
{
2400eda2:	b480      	push	{r7}
2400eda4:	b083      	sub	sp, #12
2400eda6:	af00      	add	r7, sp, #0
2400eda8:	6078      	str	r0, [r7, #4]
  /* Check the MDMA peripheral handle */
  if(hmdma == NULL)
2400edaa:	687b      	ldr	r3, [r7, #4]
2400edac:	2b00      	cmp	r3, #0
2400edae:	d101      	bne.n	2400edb4 <HAL_MDMA_Abort_IT+0x12>
  {
    return HAL_ERROR;
2400edb0:	2301      	movs	r3, #1
2400edb2:	e017      	b.n	2400ede4 <HAL_MDMA_Abort_IT+0x42>
  }

  if(HAL_MDMA_STATE_BUSY != hmdma->State)
2400edb4:	687b      	ldr	r3, [r7, #4]
2400edb6:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
2400edba:	b2db      	uxtb	r3, r3
2400edbc:	2b02      	cmp	r3, #2
2400edbe:	d004      	beq.n	2400edca <HAL_MDMA_Abort_IT+0x28>
  {
    /* No transfer ongoing */
    hmdma->ErrorCode = HAL_MDMA_ERROR_NO_XFER;
2400edc0:	687b      	ldr	r3, [r7, #4]
2400edc2:	2280      	movs	r2, #128	; 0x80
2400edc4:	669a      	str	r2, [r3, #104]	; 0x68

    return HAL_ERROR;
2400edc6:	2301      	movs	r3, #1
2400edc8:	e00c      	b.n	2400ede4 <HAL_MDMA_Abort_IT+0x42>
  }
  else
  {
    /* Set Abort State  */
    hmdma->State = HAL_MDMA_STATE_ABORT;
2400edca:	687b      	ldr	r3, [r7, #4]
2400edcc:	2204      	movs	r2, #4
2400edce:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

    /* Disable the stream */
    __HAL_MDMA_DISABLE(hmdma);
2400edd2:	687b      	ldr	r3, [r7, #4]
2400edd4:	681b      	ldr	r3, [r3, #0]
2400edd6:	68da      	ldr	r2, [r3, #12]
2400edd8:	687b      	ldr	r3, [r7, #4]
2400edda:	681b      	ldr	r3, [r3, #0]
2400eddc:	f022 0201 	bic.w	r2, r2, #1
2400ede0:	60da      	str	r2, [r3, #12]
  }

  return HAL_OK;
2400ede2:	2300      	movs	r3, #0
}
2400ede4:	4618      	mov	r0, r3
2400ede6:	370c      	adds	r7, #12
2400ede8:	46bd      	mov	sp, r7
2400edea:	f85d 7b04 	ldr.w	r7, [sp], #4
2400edee:	4770      	bx	lr

2400edf0 <HAL_MDMA_PollForTransfer>:
  * @param  CompleteLevel: Specifies the MDMA level complete.
  * @param  Timeout:       Timeout duration.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_MDMA_PollForTransfer(MDMA_HandleTypeDef *hmdma, HAL_MDMA_LevelCompleteTypeDef CompleteLevel, uint32_t Timeout)
{
2400edf0:	b580      	push	{r7, lr}
2400edf2:	b088      	sub	sp, #32
2400edf4:	af00      	add	r7, sp, #0
2400edf6:	60f8      	str	r0, [r7, #12]
2400edf8:	460b      	mov	r3, r1
2400edfa:	607a      	str	r2, [r7, #4]
2400edfc:	72fb      	strb	r3, [r7, #11]

  /* Check the parameters */
  assert_param(IS_MDMA_LEVEL_COMPLETE(CompleteLevel));

  /* Check the MDMA peripheral handle */
  if(hmdma == NULL)
2400edfe:	68fb      	ldr	r3, [r7, #12]
2400ee00:	2b00      	cmp	r3, #0
2400ee02:	d101      	bne.n	2400ee08 <HAL_MDMA_PollForTransfer+0x18>
  {
    return HAL_ERROR;
2400ee04:	2301      	movs	r3, #1
2400ee06:	e0b9      	b.n	2400ef7c <HAL_MDMA_PollForTransfer+0x18c>
  }

  if(HAL_MDMA_STATE_BUSY != hmdma->State)
2400ee08:	68fb      	ldr	r3, [r7, #12]
2400ee0a:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
2400ee0e:	b2db      	uxtb	r3, r3
2400ee10:	2b02      	cmp	r3, #2
2400ee12:	d004      	beq.n	2400ee1e <HAL_MDMA_PollForTransfer+0x2e>
  {
    /* No transfer ongoing */
    hmdma->ErrorCode = HAL_MDMA_ERROR_NO_XFER;
2400ee14:	68fb      	ldr	r3, [r7, #12]
2400ee16:	2280      	movs	r2, #128	; 0x80
2400ee18:	669a      	str	r2, [r3, #104]	; 0x68

    return HAL_ERROR;
2400ee1a:	2301      	movs	r3, #1
2400ee1c:	e0ae      	b.n	2400ef7c <HAL_MDMA_PollForTransfer+0x18c>
  }

  /* Get the level transfer complete flag */
  levelFlag = ((CompleteLevel == HAL_MDMA_FULL_TRANSFER)  ? MDMA_FLAG_CTC  : \
2400ee1e:	7afb      	ldrb	r3, [r7, #11]
2400ee20:	2b00      	cmp	r3, #0
2400ee22:	d00b      	beq.n	2400ee3c <HAL_MDMA_PollForTransfer+0x4c>
               (CompleteLevel == HAL_MDMA_BUFFER_TRANSFER)? MDMA_FLAG_BFTC : \
2400ee24:	7afb      	ldrb	r3, [r7, #11]
2400ee26:	2b01      	cmp	r3, #1
2400ee28:	d006      	beq.n	2400ee38 <HAL_MDMA_PollForTransfer+0x48>
               (CompleteLevel == HAL_MDMA_BLOCK_TRANSFER) ? MDMA_FLAG_BT   : \
2400ee2a:	7afb      	ldrb	r3, [r7, #11]
2400ee2c:	2b02      	cmp	r3, #2
2400ee2e:	d101      	bne.n	2400ee34 <HAL_MDMA_PollForTransfer+0x44>
2400ee30:	2308      	movs	r3, #8
2400ee32:	e004      	b.n	2400ee3e <HAL_MDMA_PollForTransfer+0x4e>
2400ee34:	2304      	movs	r3, #4
2400ee36:	e002      	b.n	2400ee3e <HAL_MDMA_PollForTransfer+0x4e>
               (CompleteLevel == HAL_MDMA_BUFFER_TRANSFER)? MDMA_FLAG_BFTC : \
2400ee38:	2310      	movs	r3, #16
2400ee3a:	e000      	b.n	2400ee3e <HAL_MDMA_PollForTransfer+0x4e>
  levelFlag = ((CompleteLevel == HAL_MDMA_FULL_TRANSFER)  ? MDMA_FLAG_CTC  : \
2400ee3c:	2302      	movs	r3, #2
2400ee3e:	61fb      	str	r3, [r7, #28]
               MDMA_FLAG_BRT);


  /* Get timeout */
  tickstart = HAL_GetTick();
2400ee40:	f7f1 fd06 	bl	24000850 <HAL_GetTick>
2400ee44:	61b8      	str	r0, [r7, #24]

  while(__HAL_MDMA_GET_FLAG(hmdma, levelFlag) == 0U)
2400ee46:	e067      	b.n	2400ef18 <HAL_MDMA_PollForTransfer+0x128>
  {
    if((__HAL_MDMA_GET_FLAG(hmdma, MDMA_FLAG_TE) != 0U))
2400ee48:	68fb      	ldr	r3, [r7, #12]
2400ee4a:	681b      	ldr	r3, [r3, #0]
2400ee4c:	681b      	ldr	r3, [r3, #0]
2400ee4e:	f003 0301 	and.w	r3, r3, #1
2400ee52:	2b00      	cmp	r3, #0
2400ee54:	d046      	beq.n	2400eee4 <HAL_MDMA_PollForTransfer+0xf4>
    {
      /* Get the transfer error source flag */
      errorFlag = hmdma->Instance->CESR;
2400ee56:	68fb      	ldr	r3, [r7, #12]
2400ee58:	681b      	ldr	r3, [r3, #0]
2400ee5a:	689b      	ldr	r3, [r3, #8]
2400ee5c:	617b      	str	r3, [r7, #20]

      if((errorFlag & MDMA_CESR_TED) == 0U)
2400ee5e:	697b      	ldr	r3, [r7, #20]
2400ee60:	f003 0380 	and.w	r3, r3, #128	; 0x80
2400ee64:	2b00      	cmp	r3, #0
2400ee66:	d106      	bne.n	2400ee76 <HAL_MDMA_PollForTransfer+0x86>
      {
        /* Update error code : Read Transfer error  */
        hmdma->ErrorCode |= HAL_MDMA_ERROR_READ_XFER;
2400ee68:	68fb      	ldr	r3, [r7, #12]
2400ee6a:	6e9b      	ldr	r3, [r3, #104]	; 0x68
2400ee6c:	f043 0201 	orr.w	r2, r3, #1
2400ee70:	68fb      	ldr	r3, [r7, #12]
2400ee72:	669a      	str	r2, [r3, #104]	; 0x68
2400ee74:	e005      	b.n	2400ee82 <HAL_MDMA_PollForTransfer+0x92>
      }
      else
      {
        /* Update error code : Write Transfer error */
        hmdma->ErrorCode |= HAL_MDMA_ERROR_WRITE_XFER;
2400ee76:	68fb      	ldr	r3, [r7, #12]
2400ee78:	6e9b      	ldr	r3, [r3, #104]	; 0x68
2400ee7a:	f043 0202 	orr.w	r2, r3, #2
2400ee7e:	68fb      	ldr	r3, [r7, #12]
2400ee80:	669a      	str	r2, [r3, #104]	; 0x68
      }

      if((errorFlag & MDMA_CESR_TEMD) != 0U)
2400ee82:	697b      	ldr	r3, [r7, #20]
2400ee84:	f403 7300 	and.w	r3, r3, #512	; 0x200
2400ee88:	2b00      	cmp	r3, #0
2400ee8a:	d005      	beq.n	2400ee98 <HAL_MDMA_PollForTransfer+0xa8>
      {
        /* Update error code : Error Mask Data */
        hmdma->ErrorCode |= HAL_MDMA_ERROR_MASK_DATA;
2400ee8c:	68fb      	ldr	r3, [r7, #12]
2400ee8e:	6e9b      	ldr	r3, [r3, #104]	; 0x68
2400ee90:	f043 0204 	orr.w	r2, r3, #4
2400ee94:	68fb      	ldr	r3, [r7, #12]
2400ee96:	669a      	str	r2, [r3, #104]	; 0x68
      }

      if((errorFlag & MDMA_CESR_TELD) != 0U)
2400ee98:	697b      	ldr	r3, [r7, #20]
2400ee9a:	f403 7380 	and.w	r3, r3, #256	; 0x100
2400ee9e:	2b00      	cmp	r3, #0
2400eea0:	d005      	beq.n	2400eeae <HAL_MDMA_PollForTransfer+0xbe>
      {
        /* Update error code : Error Linked list */
        hmdma->ErrorCode |= HAL_MDMA_ERROR_LINKED_LIST;
2400eea2:	68fb      	ldr	r3, [r7, #12]
2400eea4:	6e9b      	ldr	r3, [r3, #104]	; 0x68
2400eea6:	f043 0208 	orr.w	r2, r3, #8
2400eeaa:	68fb      	ldr	r3, [r7, #12]
2400eeac:	669a      	str	r2, [r3, #104]	; 0x68
      }

      if((errorFlag & MDMA_CESR_ASE) != 0U)
2400eeae:	697b      	ldr	r3, [r7, #20]
2400eeb0:	f403 6380 	and.w	r3, r3, #1024	; 0x400
2400eeb4:	2b00      	cmp	r3, #0
2400eeb6:	d005      	beq.n	2400eec4 <HAL_MDMA_PollForTransfer+0xd4>
      {
        /* Update error code : Address/Size alignment error */
        hmdma->ErrorCode |= HAL_MDMA_ERROR_ALIGNMENT;
2400eeb8:	68fb      	ldr	r3, [r7, #12]
2400eeba:	6e9b      	ldr	r3, [r3, #104]	; 0x68
2400eebc:	f043 0210 	orr.w	r2, r3, #16
2400eec0:	68fb      	ldr	r3, [r7, #12]
2400eec2:	669a      	str	r2, [r3, #104]	; 0x68
      }

      if((errorFlag & MDMA_CESR_BSE) != 0U)
2400eec4:	697b      	ldr	r3, [r7, #20]
2400eec6:	f403 6300 	and.w	r3, r3, #2048	; 0x800
2400eeca:	2b00      	cmp	r3, #0
2400eecc:	d005      	beq.n	2400eeda <HAL_MDMA_PollForTransfer+0xea>
      {
        /* Update error code : Block Size error */
        hmdma->ErrorCode |= HAL_MDMA_ERROR_BLOCK_SIZE;
2400eece:	68fb      	ldr	r3, [r7, #12]
2400eed0:	6e9b      	ldr	r3, [r3, #104]	; 0x68
2400eed2:	f043 0220 	orr.w	r2, r3, #32
2400eed6:	68fb      	ldr	r3, [r7, #12]
2400eed8:	669a      	str	r2, [r3, #104]	; 0x68
      }

      (void) HAL_MDMA_Abort(hmdma); /* if error then abort the current transfer */
2400eeda:	68f8      	ldr	r0, [r7, #12]
2400eedc:	f7ff ff06 	bl	2400ecec <HAL_MDMA_Abort>
          - Clear all transfer flags
          - Unlock
          - Set the State
      */

      return HAL_ERROR;
2400eee0:	2301      	movs	r3, #1
2400eee2:	e04b      	b.n	2400ef7c <HAL_MDMA_PollForTransfer+0x18c>

    }

    /* Check for the Timeout */
    if(Timeout != HAL_MAX_DELAY)
2400eee4:	687b      	ldr	r3, [r7, #4]
2400eee6:	f1b3 3fff 	cmp.w	r3, #4294967295
2400eeea:	d015      	beq.n	2400ef18 <HAL_MDMA_PollForTransfer+0x128>
    {
      if(((HAL_GetTick() - tickstart ) > Timeout) || (Timeout == 0U))
2400eeec:	f7f1 fcb0 	bl	24000850 <HAL_GetTick>
2400eef0:	4602      	mov	r2, r0
2400eef2:	69bb      	ldr	r3, [r7, #24]
2400eef4:	1ad3      	subs	r3, r2, r3
2400eef6:	687a      	ldr	r2, [r7, #4]
2400eef8:	429a      	cmp	r2, r3
2400eefa:	d302      	bcc.n	2400ef02 <HAL_MDMA_PollForTransfer+0x112>
2400eefc:	687b      	ldr	r3, [r7, #4]
2400eefe:	2b00      	cmp	r3, #0
2400ef00:	d10a      	bne.n	2400ef18 <HAL_MDMA_PollForTransfer+0x128>
      {
        /* Update error code */
        hmdma->ErrorCode |= HAL_MDMA_ERROR_TIMEOUT;
2400ef02:	68fb      	ldr	r3, [r7, #12]
2400ef04:	6e9b      	ldr	r3, [r3, #104]	; 0x68
2400ef06:	f043 0240 	orr.w	r2, r3, #64	; 0x40
2400ef0a:	68fb      	ldr	r3, [r7, #12]
2400ef0c:	669a      	str	r2, [r3, #104]	; 0x68

        (void) HAL_MDMA_Abort(hmdma); /* if timeout then abort the current transfer */
2400ef0e:	68f8      	ldr	r0, [r7, #12]
2400ef10:	f7ff feec 	bl	2400ecec <HAL_MDMA_Abort>
            - Clear all transfer flags
            - Unlock
            - Set the State
        */

        return HAL_ERROR;
2400ef14:	2301      	movs	r3, #1
2400ef16:	e031      	b.n	2400ef7c <HAL_MDMA_PollForTransfer+0x18c>
  while(__HAL_MDMA_GET_FLAG(hmdma, levelFlag) == 0U)
2400ef18:	68fb      	ldr	r3, [r7, #12]
2400ef1a:	681b      	ldr	r3, [r3, #0]
2400ef1c:	681a      	ldr	r2, [r3, #0]
2400ef1e:	69fb      	ldr	r3, [r7, #28]
2400ef20:	4013      	ands	r3, r2
2400ef22:	2b00      	cmp	r3, #0
2400ef24:	d090      	beq.n	2400ee48 <HAL_MDMA_PollForTransfer+0x58>
      }
    }
  }

  /* Clear the transfer level flag */
  if(CompleteLevel == HAL_MDMA_BUFFER_TRANSFER)
2400ef26:	7afb      	ldrb	r3, [r7, #11]
2400ef28:	2b01      	cmp	r3, #1
2400ef2a:	d104      	bne.n	2400ef36 <HAL_MDMA_PollForTransfer+0x146>
  {
    __HAL_MDMA_CLEAR_FLAG(hmdma, MDMA_FLAG_BFTC);
2400ef2c:	68fb      	ldr	r3, [r7, #12]
2400ef2e:	681b      	ldr	r3, [r3, #0]
2400ef30:	2210      	movs	r2, #16
2400ef32:	605a      	str	r2, [r3, #4]
2400ef34:	e021      	b.n	2400ef7a <HAL_MDMA_PollForTransfer+0x18a>

  }
  else if(CompleteLevel == HAL_MDMA_BLOCK_TRANSFER)
2400ef36:	7afb      	ldrb	r3, [r7, #11]
2400ef38:	2b02      	cmp	r3, #2
2400ef3a:	d104      	bne.n	2400ef46 <HAL_MDMA_PollForTransfer+0x156>
  {
    __HAL_MDMA_CLEAR_FLAG(hmdma, (MDMA_FLAG_BFTC | MDMA_FLAG_BT));
2400ef3c:	68fb      	ldr	r3, [r7, #12]
2400ef3e:	681b      	ldr	r3, [r3, #0]
2400ef40:	2218      	movs	r2, #24
2400ef42:	605a      	str	r2, [r3, #4]
2400ef44:	e019      	b.n	2400ef7a <HAL_MDMA_PollForTransfer+0x18a>

  }
  else if(CompleteLevel == HAL_MDMA_REPEAT_BLOCK_TRANSFER)
2400ef46:	7afb      	ldrb	r3, [r7, #11]
2400ef48:	2b03      	cmp	r3, #3
2400ef4a:	d104      	bne.n	2400ef56 <HAL_MDMA_PollForTransfer+0x166>
  {
    __HAL_MDMA_CLEAR_FLAG(hmdma, (MDMA_FLAG_BFTC | MDMA_FLAG_BT | MDMA_FLAG_BRT));
2400ef4c:	68fb      	ldr	r3, [r7, #12]
2400ef4e:	681b      	ldr	r3, [r3, #0]
2400ef50:	221c      	movs	r2, #28
2400ef52:	605a      	str	r2, [r3, #4]
2400ef54:	e011      	b.n	2400ef7a <HAL_MDMA_PollForTransfer+0x18a>
  }
  else if(CompleteLevel == HAL_MDMA_FULL_TRANSFER)
2400ef56:	7afb      	ldrb	r3, [r7, #11]
2400ef58:	2b00      	cmp	r3, #0
2400ef5a:	d10c      	bne.n	2400ef76 <HAL_MDMA_PollForTransfer+0x186>
  {
    __HAL_MDMA_CLEAR_FLAG(hmdma, (MDMA_FLAG_BRT | MDMA_FLAG_BT | MDMA_FLAG_BFTC | MDMA_FLAG_CTC));
2400ef5c:	68fb      	ldr	r3, [r7, #12]
2400ef5e:	681b      	ldr	r3, [r3, #0]
2400ef60:	221e      	movs	r2, #30
2400ef62:	605a      	str	r2, [r3, #4]

    /* Process unlocked */
    __HAL_UNLOCK(hmdma);
2400ef64:	68fb      	ldr	r3, [r7, #12]
2400ef66:	2200      	movs	r2, #0
2400ef68:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

    hmdma->State = HAL_MDMA_STATE_READY;
2400ef6c:	68fb      	ldr	r3, [r7, #12]
2400ef6e:	2201      	movs	r2, #1
2400ef70:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
2400ef74:	e001      	b.n	2400ef7a <HAL_MDMA_PollForTransfer+0x18a>
  }
  else
  {
    return HAL_ERROR;
2400ef76:	2301      	movs	r3, #1
2400ef78:	e000      	b.n	2400ef7c <HAL_MDMA_PollForTransfer+0x18c>
  }

  return HAL_OK;
2400ef7a:	2300      	movs	r3, #0
}
2400ef7c:	4618      	mov	r0, r3
2400ef7e:	3720      	adds	r7, #32
2400ef80:	46bd      	mov	sp, r7
2400ef82:	bd80      	pop	{r7, pc}

2400ef84 <HAL_MDMA_GenerateSWRequest>:
  * @param  hmdma:       pointer to a MDMA_HandleTypeDef structure that contains
  *                     the configuration information for the specified MDMA Stream.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_MDMA_GenerateSWRequest(MDMA_HandleTypeDef *hmdma)
{
2400ef84:	b480      	push	{r7}
2400ef86:	b085      	sub	sp, #20
2400ef88:	af00      	add	r7, sp, #0
2400ef8a:	6078      	str	r0, [r7, #4]
  uint32_t request_mode;

  /* Check the MDMA peripheral handle */
  if(hmdma == NULL)
2400ef8c:	687b      	ldr	r3, [r7, #4]
2400ef8e:	2b00      	cmp	r3, #0
2400ef90:	d101      	bne.n	2400ef96 <HAL_MDMA_GenerateSWRequest+0x12>
  {
    return HAL_ERROR;
2400ef92:	2301      	movs	r3, #1
2400ef94:	e02a      	b.n	2400efec <HAL_MDMA_GenerateSWRequest+0x68>
  }

  /* Get the softawre request mode */
  request_mode = hmdma->Instance->CTCR & MDMA_CTCR_SWRM;
2400ef96:	687b      	ldr	r3, [r7, #4]
2400ef98:	681b      	ldr	r3, [r3, #0]
2400ef9a:	691b      	ldr	r3, [r3, #16]
2400ef9c:	f003 4380 	and.w	r3, r3, #1073741824	; 0x40000000
2400efa0:	60fb      	str	r3, [r7, #12]

  if((hmdma->Instance->CCR &  MDMA_CCR_EN) == 0U)
2400efa2:	687b      	ldr	r3, [r7, #4]
2400efa4:	681b      	ldr	r3, [r3, #0]
2400efa6:	68db      	ldr	r3, [r3, #12]
2400efa8:	f003 0301 	and.w	r3, r3, #1
2400efac:	2b00      	cmp	r3, #0
2400efae:	d104      	bne.n	2400efba <HAL_MDMA_GenerateSWRequest+0x36>
  {
    /* if no Transfer on going (MDMA enable bit not set) retrun error */
    hmdma->ErrorCode = HAL_MDMA_ERROR_NO_XFER;
2400efb0:	687b      	ldr	r3, [r7, #4]
2400efb2:	2280      	movs	r2, #128	; 0x80
2400efb4:	669a      	str	r2, [r3, #104]	; 0x68

    return HAL_ERROR;
2400efb6:	2301      	movs	r3, #1
2400efb8:	e018      	b.n	2400efec <HAL_MDMA_GenerateSWRequest+0x68>
  }
  else if(((hmdma->Instance->CISR &  MDMA_CISR_CRQA) != 0U) || (request_mode == 0U))
2400efba:	687b      	ldr	r3, [r7, #4]
2400efbc:	681b      	ldr	r3, [r3, #0]
2400efbe:	681b      	ldr	r3, [r3, #0]
2400efc0:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
2400efc4:	2b00      	cmp	r3, #0
2400efc6:	d102      	bne.n	2400efce <HAL_MDMA_GenerateSWRequest+0x4a>
2400efc8:	68fb      	ldr	r3, [r7, #12]
2400efca:	2b00      	cmp	r3, #0
2400efcc:	d105      	bne.n	2400efda <HAL_MDMA_GenerateSWRequest+0x56>
  {
    /* if an MDMA ongoing request has not yet end or if request mode is not SW request retrun error */
    hmdma->ErrorCode = HAL_MDMA_ERROR_BUSY;
2400efce:	687b      	ldr	r3, [r7, #4]
2400efd0:	f44f 7280 	mov.w	r2, #256	; 0x100
2400efd4:	669a      	str	r2, [r3, #104]	; 0x68

    return HAL_ERROR;
2400efd6:	2301      	movs	r3, #1
2400efd8:	e008      	b.n	2400efec <HAL_MDMA_GenerateSWRequest+0x68>
  }
  else
  {
    /* Set the SW request bit to activate the request on the Channel */
    hmdma->Instance->CCR |= MDMA_CCR_SWRQ;
2400efda:	687b      	ldr	r3, [r7, #4]
2400efdc:	681b      	ldr	r3, [r3, #0]
2400efde:	68da      	ldr	r2, [r3, #12]
2400efe0:	687b      	ldr	r3, [r7, #4]
2400efe2:	681b      	ldr	r3, [r3, #0]
2400efe4:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
2400efe8:	60da      	str	r2, [r3, #12]

    return HAL_OK;
2400efea:	2300      	movs	r3, #0
  }
}
2400efec:	4618      	mov	r0, r3
2400efee:	3714      	adds	r7, #20
2400eff0:	46bd      	mov	sp, r7
2400eff2:	f85d 7b04 	ldr.w	r7, [sp], #4
2400eff6:	4770      	bx	lr

2400eff8 <HAL_MDMA_IRQHandler>:
  * @param  hmdma: pointer to a MDMA_HandleTypeDef structure that contains
  *               the configuration information for the specified MDMA Channel.
  * @retval None
  */
void HAL_MDMA_IRQHandler(MDMA_HandleTypeDef *hmdma)
{
2400eff8:	b580      	push	{r7, lr}
2400effa:	b086      	sub	sp, #24
2400effc:	af00      	add	r7, sp, #0
2400effe:	6078      	str	r0, [r7, #4]
  __IO uint32_t count = 0;
2400f000:	2300      	movs	r3, #0
2400f002:	60bb      	str	r3, [r7, #8]
  uint32_t timeout = SystemCoreClock / 9600U;
2400f004:	4b9a      	ldr	r3, [pc, #616]	; (2400f270 <HAL_MDMA_IRQHandler+0x278>)
2400f006:	681b      	ldr	r3, [r3, #0]
2400f008:	4a9a      	ldr	r2, [pc, #616]	; (2400f274 <HAL_MDMA_IRQHandler+0x27c>)
2400f00a:	fba2 2303 	umull	r2, r3, r2, r3
2400f00e:	0a9b      	lsrs	r3, r3, #10
2400f010:	617b      	str	r3, [r7, #20]

  uint32_t generalIntFlag, errorFlag;

  /* General Interrupt Flag management ****************************************/
  generalIntFlag =  1UL << ((((uint32_t)hmdma->Instance - (uint32_t)(MDMA_Channel0))/HAL_MDMA_CHANNEL_SIZE) & 0x1FU);
2400f012:	687b      	ldr	r3, [r7, #4]
2400f014:	681b      	ldr	r3, [r3, #0]
2400f016:	461a      	mov	r2, r3
2400f018:	4b97      	ldr	r3, [pc, #604]	; (2400f278 <HAL_MDMA_IRQHandler+0x280>)
2400f01a:	4413      	add	r3, r2
2400f01c:	099b      	lsrs	r3, r3, #6
2400f01e:	f003 031f 	and.w	r3, r3, #31
2400f022:	2201      	movs	r2, #1
2400f024:	fa02 f303 	lsl.w	r3, r2, r3
2400f028:	613b      	str	r3, [r7, #16]
  if((MDMA->GISR0 & generalIntFlag) == 0U)
2400f02a:	f04f 43a4 	mov.w	r3, #1375731712	; 0x52000000
2400f02e:	681a      	ldr	r2, [r3, #0]
2400f030:	693b      	ldr	r3, [r7, #16]
2400f032:	4013      	ands	r3, r2
2400f034:	2b00      	cmp	r3, #0
2400f036:	f000 812e 	beq.w	2400f296 <HAL_MDMA_IRQHandler+0x29e>
  {
    return; /* the  General interrupt flag for the current channel is down , nothing to do */
  }

  /* Transfer Error Interrupt management ***************************************/
  if((__HAL_MDMA_GET_FLAG(hmdma, MDMA_FLAG_TE) != 0U))
2400f03a:	687b      	ldr	r3, [r7, #4]
2400f03c:	681b      	ldr	r3, [r3, #0]
2400f03e:	681b      	ldr	r3, [r3, #0]
2400f040:	f003 0301 	and.w	r3, r3, #1
2400f044:	2b00      	cmp	r3, #0
2400f046:	d054      	beq.n	2400f0f2 <HAL_MDMA_IRQHandler+0xfa>
  {
    if(__HAL_MDMA_GET_IT_SOURCE(hmdma, MDMA_IT_TE) != 0U)
2400f048:	687b      	ldr	r3, [r7, #4]
2400f04a:	681b      	ldr	r3, [r3, #0]
2400f04c:	68db      	ldr	r3, [r3, #12]
2400f04e:	f003 0302 	and.w	r3, r3, #2
2400f052:	2b00      	cmp	r3, #0
2400f054:	d04d      	beq.n	2400f0f2 <HAL_MDMA_IRQHandler+0xfa>
    {
      /* Disable the transfer error interrupt */
      __HAL_MDMA_DISABLE_IT(hmdma, MDMA_IT_TE);
2400f056:	687b      	ldr	r3, [r7, #4]
2400f058:	681b      	ldr	r3, [r3, #0]
2400f05a:	68da      	ldr	r2, [r3, #12]
2400f05c:	687b      	ldr	r3, [r7, #4]
2400f05e:	681b      	ldr	r3, [r3, #0]
2400f060:	f022 0202 	bic.w	r2, r2, #2
2400f064:	60da      	str	r2, [r3, #12]

      /* Get the transfer error source flag */
      errorFlag = hmdma->Instance->CESR;
2400f066:	687b      	ldr	r3, [r7, #4]
2400f068:	681b      	ldr	r3, [r3, #0]
2400f06a:	689b      	ldr	r3, [r3, #8]
2400f06c:	60fb      	str	r3, [r7, #12]

      if((errorFlag & MDMA_CESR_TED) == 0U)
2400f06e:	68fb      	ldr	r3, [r7, #12]
2400f070:	f003 0380 	and.w	r3, r3, #128	; 0x80
2400f074:	2b00      	cmp	r3, #0
2400f076:	d106      	bne.n	2400f086 <HAL_MDMA_IRQHandler+0x8e>
      {
        /* Update error code : Read Transfer error  */
        hmdma->ErrorCode |= HAL_MDMA_ERROR_READ_XFER;
2400f078:	687b      	ldr	r3, [r7, #4]
2400f07a:	6e9b      	ldr	r3, [r3, #104]	; 0x68
2400f07c:	f043 0201 	orr.w	r2, r3, #1
2400f080:	687b      	ldr	r3, [r7, #4]
2400f082:	669a      	str	r2, [r3, #104]	; 0x68
2400f084:	e005      	b.n	2400f092 <HAL_MDMA_IRQHandler+0x9a>
      }
      else
      {
        /* Update error code : Write Transfer error */
        hmdma->ErrorCode |= HAL_MDMA_ERROR_WRITE_XFER;
2400f086:	687b      	ldr	r3, [r7, #4]
2400f088:	6e9b      	ldr	r3, [r3, #104]	; 0x68
2400f08a:	f043 0202 	orr.w	r2, r3, #2
2400f08e:	687b      	ldr	r3, [r7, #4]
2400f090:	669a      	str	r2, [r3, #104]	; 0x68
      }

      if((errorFlag & MDMA_CESR_TEMD) != 0U)
2400f092:	68fb      	ldr	r3, [r7, #12]
2400f094:	f403 7300 	and.w	r3, r3, #512	; 0x200
2400f098:	2b00      	cmp	r3, #0
2400f09a:	d005      	beq.n	2400f0a8 <HAL_MDMA_IRQHandler+0xb0>
      {
        /* Update error code : Error Mask Data */
        hmdma->ErrorCode |= HAL_MDMA_ERROR_MASK_DATA;
2400f09c:	687b      	ldr	r3, [r7, #4]
2400f09e:	6e9b      	ldr	r3, [r3, #104]	; 0x68
2400f0a0:	f043 0204 	orr.w	r2, r3, #4
2400f0a4:	687b      	ldr	r3, [r7, #4]
2400f0a6:	669a      	str	r2, [r3, #104]	; 0x68
      }

      if((errorFlag & MDMA_CESR_TELD) != 0U)
2400f0a8:	68fb      	ldr	r3, [r7, #12]
2400f0aa:	f403 7380 	and.w	r3, r3, #256	; 0x100
2400f0ae:	2b00      	cmp	r3, #0
2400f0b0:	d005      	beq.n	2400f0be <HAL_MDMA_IRQHandler+0xc6>
      {
        /* Update error code : Error Linked list */
        hmdma->ErrorCode |= HAL_MDMA_ERROR_LINKED_LIST;
2400f0b2:	687b      	ldr	r3, [r7, #4]
2400f0b4:	6e9b      	ldr	r3, [r3, #104]	; 0x68
2400f0b6:	f043 0208 	orr.w	r2, r3, #8
2400f0ba:	687b      	ldr	r3, [r7, #4]
2400f0bc:	669a      	str	r2, [r3, #104]	; 0x68
      }

      if((errorFlag & MDMA_CESR_ASE) != 0U)
2400f0be:	68fb      	ldr	r3, [r7, #12]
2400f0c0:	f403 6380 	and.w	r3, r3, #1024	; 0x400
2400f0c4:	2b00      	cmp	r3, #0
2400f0c6:	d005      	beq.n	2400f0d4 <HAL_MDMA_IRQHandler+0xdc>
      {
        /* Update error code : Address/Size alignment error */
        hmdma->ErrorCode |= HAL_MDMA_ERROR_ALIGNMENT;
2400f0c8:	687b      	ldr	r3, [r7, #4]
2400f0ca:	6e9b      	ldr	r3, [r3, #104]	; 0x68
2400f0cc:	f043 0210 	orr.w	r2, r3, #16
2400f0d0:	687b      	ldr	r3, [r7, #4]
2400f0d2:	669a      	str	r2, [r3, #104]	; 0x68
      }

      if((errorFlag & MDMA_CESR_BSE) != 0U)
2400f0d4:	68fb      	ldr	r3, [r7, #12]
2400f0d6:	f403 6300 	and.w	r3, r3, #2048	; 0x800
2400f0da:	2b00      	cmp	r3, #0
2400f0dc:	d005      	beq.n	2400f0ea <HAL_MDMA_IRQHandler+0xf2>
      {
        /* Update error code : Block Size error error */
        hmdma->ErrorCode |= HAL_MDMA_ERROR_BLOCK_SIZE;
2400f0de:	687b      	ldr	r3, [r7, #4]
2400f0e0:	6e9b      	ldr	r3, [r3, #104]	; 0x68
2400f0e2:	f043 0220 	orr.w	r2, r3, #32
2400f0e6:	687b      	ldr	r3, [r7, #4]
2400f0e8:	669a      	str	r2, [r3, #104]	; 0x68
      }

      /* Clear the transfer error flags */
      __HAL_MDMA_CLEAR_FLAG(hmdma, MDMA_FLAG_TE);
2400f0ea:	687b      	ldr	r3, [r7, #4]
2400f0ec:	681b      	ldr	r3, [r3, #0]
2400f0ee:	2201      	movs	r2, #1
2400f0f0:	605a      	str	r2, [r3, #4]
    }
  }

  /* Buffer Transfer Complete Interrupt management ******************************/
  if((__HAL_MDMA_GET_FLAG(hmdma, MDMA_FLAG_BFTC) != 0U))
2400f0f2:	687b      	ldr	r3, [r7, #4]
2400f0f4:	681b      	ldr	r3, [r3, #0]
2400f0f6:	681b      	ldr	r3, [r3, #0]
2400f0f8:	f003 0310 	and.w	r3, r3, #16
2400f0fc:	2b00      	cmp	r3, #0
2400f0fe:	d012      	beq.n	2400f126 <HAL_MDMA_IRQHandler+0x12e>
  {
    if(__HAL_MDMA_GET_IT_SOURCE(hmdma, MDMA_IT_BFTC) != 0U)
2400f100:	687b      	ldr	r3, [r7, #4]
2400f102:	681b      	ldr	r3, [r3, #0]
2400f104:	68db      	ldr	r3, [r3, #12]
2400f106:	f003 0320 	and.w	r3, r3, #32
2400f10a:	2b00      	cmp	r3, #0
2400f10c:	d00b      	beq.n	2400f126 <HAL_MDMA_IRQHandler+0x12e>
    {
      /* Clear the buffer transfer complete flag */
      __HAL_MDMA_CLEAR_FLAG(hmdma, MDMA_FLAG_BFTC);
2400f10e:	687b      	ldr	r3, [r7, #4]
2400f110:	681b      	ldr	r3, [r3, #0]
2400f112:	2210      	movs	r2, #16
2400f114:	605a      	str	r2, [r3, #4]

      if(hmdma->XferBufferCpltCallback != NULL)
2400f116:	687b      	ldr	r3, [r7, #4]
2400f118:	6c9b      	ldr	r3, [r3, #72]	; 0x48
2400f11a:	2b00      	cmp	r3, #0
2400f11c:	d003      	beq.n	2400f126 <HAL_MDMA_IRQHandler+0x12e>
      {
        /* Buffer transfer callback */
        hmdma->XferBufferCpltCallback(hmdma);
2400f11e:	687b      	ldr	r3, [r7, #4]
2400f120:	6c9b      	ldr	r3, [r3, #72]	; 0x48
2400f122:	6878      	ldr	r0, [r7, #4]
2400f124:	4798      	blx	r3
      }
    }
  }

  /* Block Transfer Complete Interrupt management ******************************/
  if((__HAL_MDMA_GET_FLAG(hmdma, MDMA_FLAG_BT) != 0U))
2400f126:	687b      	ldr	r3, [r7, #4]
2400f128:	681b      	ldr	r3, [r3, #0]
2400f12a:	681b      	ldr	r3, [r3, #0]
2400f12c:	f003 0308 	and.w	r3, r3, #8
2400f130:	2b00      	cmp	r3, #0
2400f132:	d012      	beq.n	2400f15a <HAL_MDMA_IRQHandler+0x162>
  {
    if(__HAL_MDMA_GET_IT_SOURCE(hmdma, MDMA_IT_BT) != 0U)
2400f134:	687b      	ldr	r3, [r7, #4]
2400f136:	681b      	ldr	r3, [r3, #0]
2400f138:	68db      	ldr	r3, [r3, #12]
2400f13a:	f003 0310 	and.w	r3, r3, #16
2400f13e:	2b00      	cmp	r3, #0
2400f140:	d00b      	beq.n	2400f15a <HAL_MDMA_IRQHandler+0x162>
    {
      /* Clear the block transfer complete flag */
      __HAL_MDMA_CLEAR_FLAG(hmdma, MDMA_FLAG_BT);
2400f142:	687b      	ldr	r3, [r7, #4]
2400f144:	681b      	ldr	r3, [r3, #0]
2400f146:	2208      	movs	r2, #8
2400f148:	605a      	str	r2, [r3, #4]

      if(hmdma->XferBlockCpltCallback != NULL)
2400f14a:	687b      	ldr	r3, [r7, #4]
2400f14c:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
2400f14e:	2b00      	cmp	r3, #0
2400f150:	d003      	beq.n	2400f15a <HAL_MDMA_IRQHandler+0x162>
      {
        /* Block transfer callback */
        hmdma->XferBlockCpltCallback(hmdma);
2400f152:	687b      	ldr	r3, [r7, #4]
2400f154:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
2400f156:	6878      	ldr	r0, [r7, #4]
2400f158:	4798      	blx	r3
      }
    }
  }

  /* Repeated Block Transfer Complete Interrupt management ******************************/
  if((__HAL_MDMA_GET_FLAG(hmdma, MDMA_FLAG_BRT) != 0U))
2400f15a:	687b      	ldr	r3, [r7, #4]
2400f15c:	681b      	ldr	r3, [r3, #0]
2400f15e:	681b      	ldr	r3, [r3, #0]
2400f160:	f003 0304 	and.w	r3, r3, #4
2400f164:	2b00      	cmp	r3, #0
2400f166:	d012      	beq.n	2400f18e <HAL_MDMA_IRQHandler+0x196>
  {
    if(__HAL_MDMA_GET_IT_SOURCE(hmdma, MDMA_IT_BRT) != 0U)
2400f168:	687b      	ldr	r3, [r7, #4]
2400f16a:	681b      	ldr	r3, [r3, #0]
2400f16c:	68db      	ldr	r3, [r3, #12]
2400f16e:	f003 0308 	and.w	r3, r3, #8
2400f172:	2b00      	cmp	r3, #0
2400f174:	d00b      	beq.n	2400f18e <HAL_MDMA_IRQHandler+0x196>
    {
      /* Clear the repeat block transfer complete flag */
      __HAL_MDMA_CLEAR_FLAG(hmdma, MDMA_FLAG_BRT);
2400f176:	687b      	ldr	r3, [r7, #4]
2400f178:	681b      	ldr	r3, [r3, #0]
2400f17a:	2204      	movs	r2, #4
2400f17c:	605a      	str	r2, [r3, #4]

      if(hmdma->XferRepeatBlockCpltCallback != NULL)
2400f17e:	687b      	ldr	r3, [r7, #4]
2400f180:	6d1b      	ldr	r3, [r3, #80]	; 0x50
2400f182:	2b00      	cmp	r3, #0
2400f184:	d003      	beq.n	2400f18e <HAL_MDMA_IRQHandler+0x196>
      {
        /* Repeated Block transfer callback */
        hmdma->XferRepeatBlockCpltCallback(hmdma);
2400f186:	687b      	ldr	r3, [r7, #4]
2400f188:	6d1b      	ldr	r3, [r3, #80]	; 0x50
2400f18a:	6878      	ldr	r0, [r7, #4]
2400f18c:	4798      	blx	r3
      }
    }
  }

  /* Channel Transfer Complete Interrupt management ***********************************/
  if((__HAL_MDMA_GET_FLAG(hmdma, MDMA_FLAG_CTC) != 0U))
2400f18e:	687b      	ldr	r3, [r7, #4]
2400f190:	681b      	ldr	r3, [r3, #0]
2400f192:	681b      	ldr	r3, [r3, #0]
2400f194:	f003 0302 	and.w	r3, r3, #2
2400f198:	2b00      	cmp	r3, #0
2400f19a:	d039      	beq.n	2400f210 <HAL_MDMA_IRQHandler+0x218>
  {
    if(__HAL_MDMA_GET_IT_SOURCE(hmdma, MDMA_IT_CTC) != 0U)
2400f19c:	687b      	ldr	r3, [r7, #4]
2400f19e:	681b      	ldr	r3, [r3, #0]
2400f1a0:	68db      	ldr	r3, [r3, #12]
2400f1a2:	f003 0304 	and.w	r3, r3, #4
2400f1a6:	2b00      	cmp	r3, #0
2400f1a8:	d032      	beq.n	2400f210 <HAL_MDMA_IRQHandler+0x218>
    {
      /* Disable all the transfer interrupts */
      __HAL_MDMA_DISABLE_IT(hmdma, (MDMA_IT_TE | MDMA_IT_CTC | MDMA_IT_BT | MDMA_IT_BRT | MDMA_IT_BFTC));
2400f1aa:	687b      	ldr	r3, [r7, #4]
2400f1ac:	681b      	ldr	r3, [r3, #0]
2400f1ae:	68da      	ldr	r2, [r3, #12]
2400f1b0:	687b      	ldr	r3, [r7, #4]
2400f1b2:	681b      	ldr	r3, [r3, #0]
2400f1b4:	f022 023e 	bic.w	r2, r2, #62	; 0x3e
2400f1b8:	60da      	str	r2, [r3, #12]

      if(HAL_MDMA_STATE_ABORT == hmdma->State)
2400f1ba:	687b      	ldr	r3, [r7, #4]
2400f1bc:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
2400f1c0:	b2db      	uxtb	r3, r3
2400f1c2:	2b04      	cmp	r3, #4
2400f1c4:	d110      	bne.n	2400f1e8 <HAL_MDMA_IRQHandler+0x1f0>
      {
        /* Process Unlocked */
        __HAL_UNLOCK(hmdma);
2400f1c6:	687b      	ldr	r3, [r7, #4]
2400f1c8:	2200      	movs	r2, #0
2400f1ca:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

        /* Change the DMA state */
        hmdma->State = HAL_MDMA_STATE_READY;
2400f1ce:	687b      	ldr	r3, [r7, #4]
2400f1d0:	2201      	movs	r2, #1
2400f1d2:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

        if(hmdma->XferAbortCallback != NULL)
2400f1d6:	687b      	ldr	r3, [r7, #4]
2400f1d8:	6d9b      	ldr	r3, [r3, #88]	; 0x58
2400f1da:	2b00      	cmp	r3, #0
2400f1dc:	d05d      	beq.n	2400f29a <HAL_MDMA_IRQHandler+0x2a2>
        {
          hmdma->XferAbortCallback(hmdma);
2400f1de:	687b      	ldr	r3, [r7, #4]
2400f1e0:	6d9b      	ldr	r3, [r3, #88]	; 0x58
2400f1e2:	6878      	ldr	r0, [r7, #4]
2400f1e4:	4798      	blx	r3
        }
        return;
2400f1e6:	e058      	b.n	2400f29a <HAL_MDMA_IRQHandler+0x2a2>
      }

      /* Clear the Channel Transfer Complete flag */
      __HAL_MDMA_CLEAR_FLAG(hmdma, MDMA_FLAG_CTC);
2400f1e8:	687b      	ldr	r3, [r7, #4]
2400f1ea:	681b      	ldr	r3, [r3, #0]
2400f1ec:	2202      	movs	r2, #2
2400f1ee:	605a      	str	r2, [r3, #4]

      /* Process Unlocked */
      __HAL_UNLOCK(hmdma);
2400f1f0:	687b      	ldr	r3, [r7, #4]
2400f1f2:	2200      	movs	r2, #0
2400f1f4:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

      /* Change MDMA peripheral state */
      hmdma->State = HAL_MDMA_STATE_READY;
2400f1f8:	687b      	ldr	r3, [r7, #4]
2400f1fa:	2201      	movs	r2, #1
2400f1fc:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

      if(hmdma->XferCpltCallback != NULL)
2400f200:	687b      	ldr	r3, [r7, #4]
2400f202:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400f204:	2b00      	cmp	r3, #0
2400f206:	d003      	beq.n	2400f210 <HAL_MDMA_IRQHandler+0x218>
      {
        /* Channel Transfer Complete callback */
        hmdma->XferCpltCallback(hmdma);
2400f208:	687b      	ldr	r3, [r7, #4]
2400f20a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400f20c:	6878      	ldr	r0, [r7, #4]
2400f20e:	4798      	blx	r3
      }
    }
  }

  /* manage error case */
  if(hmdma->ErrorCode != HAL_MDMA_ERROR_NONE)
2400f210:	687b      	ldr	r3, [r7, #4]
2400f212:	6e9b      	ldr	r3, [r3, #104]	; 0x68
2400f214:	2b00      	cmp	r3, #0
2400f216:	d041      	beq.n	2400f29c <HAL_MDMA_IRQHandler+0x2a4>
  {
    hmdma->State = HAL_MDMA_STATE_ABORT;
2400f218:	687b      	ldr	r3, [r7, #4]
2400f21a:	2204      	movs	r2, #4
2400f21c:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

    /* Disable the channel */
    __HAL_MDMA_DISABLE(hmdma);
2400f220:	687b      	ldr	r3, [r7, #4]
2400f222:	681b      	ldr	r3, [r3, #0]
2400f224:	68da      	ldr	r2, [r3, #12]
2400f226:	687b      	ldr	r3, [r7, #4]
2400f228:	681b      	ldr	r3, [r3, #0]
2400f22a:	f022 0201 	bic.w	r2, r2, #1
2400f22e:	60da      	str	r2, [r3, #12]

    do
    {
      if (++count > timeout)
2400f230:	68bb      	ldr	r3, [r7, #8]
2400f232:	3301      	adds	r3, #1
2400f234:	60bb      	str	r3, [r7, #8]
2400f236:	697a      	ldr	r2, [r7, #20]
2400f238:	429a      	cmp	r2, r3
2400f23a:	d307      	bcc.n	2400f24c <HAL_MDMA_IRQHandler+0x254>
      {
        break;
      }
    }
    while((hmdma->Instance->CCR & MDMA_CCR_EN) != 0U);
2400f23c:	687b      	ldr	r3, [r7, #4]
2400f23e:	681b      	ldr	r3, [r3, #0]
2400f240:	68db      	ldr	r3, [r3, #12]
2400f242:	f003 0301 	and.w	r3, r3, #1
2400f246:	2b00      	cmp	r3, #0
2400f248:	d1f2      	bne.n	2400f230 <HAL_MDMA_IRQHandler+0x238>
2400f24a:	e000      	b.n	2400f24e <HAL_MDMA_IRQHandler+0x256>
        break;
2400f24c:	bf00      	nop

    /* Process Unlocked */
    __HAL_UNLOCK(hmdma);
2400f24e:	687b      	ldr	r3, [r7, #4]
2400f250:	2200      	movs	r2, #0
2400f252:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

    if((hmdma->Instance->CCR & MDMA_CCR_EN) != 0U)
2400f256:	687b      	ldr	r3, [r7, #4]
2400f258:	681b      	ldr	r3, [r3, #0]
2400f25a:	68db      	ldr	r3, [r3, #12]
2400f25c:	f003 0301 	and.w	r3, r3, #1
2400f260:	2b00      	cmp	r3, #0
2400f262:	d00b      	beq.n	2400f27c <HAL_MDMA_IRQHandler+0x284>
    {
      /* Change the MDMA state to error if MDMA disable fails */
      hmdma->State = HAL_MDMA_STATE_ERROR;
2400f264:	687b      	ldr	r3, [r7, #4]
2400f266:	2203      	movs	r2, #3
2400f268:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
2400f26c:	e00a      	b.n	2400f284 <HAL_MDMA_IRQHandler+0x28c>
2400f26e:	bf00      	nop
2400f270:	240004b8 	.word	0x240004b8
2400f274:	1b4e81b5 	.word	0x1b4e81b5
2400f278:	adffffc0 	.word	0xadffffc0
    }
    else
    {
      /* Change the MDMA state to Ready if MDMA disable success */
      hmdma->State = HAL_MDMA_STATE_READY;
2400f27c:	687b      	ldr	r3, [r7, #4]
2400f27e:	2201      	movs	r2, #1
2400f280:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
    }


    if (hmdma->XferErrorCallback != NULL)
2400f284:	687b      	ldr	r3, [r7, #4]
2400f286:	6d5b      	ldr	r3, [r3, #84]	; 0x54
2400f288:	2b00      	cmp	r3, #0
2400f28a:	d007      	beq.n	2400f29c <HAL_MDMA_IRQHandler+0x2a4>
    {
      /* Transfer error callback */
      hmdma->XferErrorCallback(hmdma);
2400f28c:	687b      	ldr	r3, [r7, #4]
2400f28e:	6d5b      	ldr	r3, [r3, #84]	; 0x54
2400f290:	6878      	ldr	r0, [r7, #4]
2400f292:	4798      	blx	r3
2400f294:	e002      	b.n	2400f29c <HAL_MDMA_IRQHandler+0x2a4>
    return; /* the  General interrupt flag for the current channel is down , nothing to do */
2400f296:	bf00      	nop
2400f298:	e000      	b.n	2400f29c <HAL_MDMA_IRQHandler+0x2a4>
        return;
2400f29a:	bf00      	nop
    }
  }
}
2400f29c:	3718      	adds	r7, #24
2400f29e:	46bd      	mov	sp, r7
2400f2a0:	bd80      	pop	{r7, pc}
2400f2a2:	bf00      	nop

2400f2a4 <HAL_MDMA_GetState>:
  * @param  hmdma: pointer to a MDMA_HandleTypeDef structure that contains
  *               the configuration information for the specified MDMA Channel.
  * @retval HAL state
  */
HAL_MDMA_StateTypeDef HAL_MDMA_GetState(MDMA_HandleTypeDef *hmdma)
{
2400f2a4:	b480      	push	{r7}
2400f2a6:	b083      	sub	sp, #12
2400f2a8:	af00      	add	r7, sp, #0
2400f2aa:	6078      	str	r0, [r7, #4]
  return hmdma->State;
2400f2ac:	687b      	ldr	r3, [r7, #4]
2400f2ae:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
2400f2b2:	b2db      	uxtb	r3, r3
}
2400f2b4:	4618      	mov	r0, r3
2400f2b6:	370c      	adds	r7, #12
2400f2b8:	46bd      	mov	sp, r7
2400f2ba:	f85d 7b04 	ldr.w	r7, [sp], #4
2400f2be:	4770      	bx	lr

2400f2c0 <HAL_MDMA_GetError>:
  * @param  hmdma : pointer to a MDMA_HandleTypeDef structure that contains
  *              the configuration information for the specified MDMA Channel.
  * @retval MDMA Error Code
  */
uint32_t HAL_MDMA_GetError(MDMA_HandleTypeDef *hmdma)
{
2400f2c0:	b480      	push	{r7}
2400f2c2:	b083      	sub	sp, #12
2400f2c4:	af00      	add	r7, sp, #0
2400f2c6:	6078      	str	r0, [r7, #4]
  return hmdma->ErrorCode;
2400f2c8:	687b      	ldr	r3, [r7, #4]
2400f2ca:	6e9b      	ldr	r3, [r3, #104]	; 0x68
}
2400f2cc:	4618      	mov	r0, r3
2400f2ce:	370c      	adds	r7, #12
2400f2d0:	46bd      	mov	sp, r7
2400f2d2:	f85d 7b04 	ldr.w	r7, [sp], #4
2400f2d6:	4770      	bx	lr

2400f2d8 <MDMA_SetConfig>:
  * @param  BlockDataLength : The length of a block transfer in bytes
  * @param  BlockCount: The number of blocks to be transfered
  * @retval HAL status
  */
static void MDMA_SetConfig(MDMA_HandleTypeDef *hmdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t BlockDataLength, uint32_t BlockCount)
{
2400f2d8:	b480      	push	{r7}
2400f2da:	b087      	sub	sp, #28
2400f2dc:	af00      	add	r7, sp, #0
2400f2de:	60f8      	str	r0, [r7, #12]
2400f2e0:	60b9      	str	r1, [r7, #8]
2400f2e2:	607a      	str	r2, [r7, #4]
2400f2e4:	603b      	str	r3, [r7, #0]
  uint32_t addressMask;

  /* Configure the MDMA Channel data length */
  MODIFY_REG(hmdma->Instance->CBNDTR ,MDMA_CBNDTR_BNDT, (BlockDataLength & MDMA_CBNDTR_BNDT));
2400f2e6:	68fb      	ldr	r3, [r7, #12]
2400f2e8:	681b      	ldr	r3, [r3, #0]
2400f2ea:	695a      	ldr	r2, [r3, #20]
2400f2ec:	4b31      	ldr	r3, [pc, #196]	; (2400f3b4 <MDMA_SetConfig+0xdc>)
2400f2ee:	4013      	ands	r3, r2
2400f2f0:	683a      	ldr	r2, [r7, #0]
2400f2f2:	f3c2 0110 	ubfx	r1, r2, #0, #17
2400f2f6:	68fa      	ldr	r2, [r7, #12]
2400f2f8:	6812      	ldr	r2, [r2, #0]
2400f2fa:	430b      	orrs	r3, r1
2400f2fc:	6153      	str	r3, [r2, #20]

  /* Configure the MDMA block repeat count */
  MODIFY_REG(hmdma->Instance->CBNDTR , MDMA_CBNDTR_BRC , ((BlockCount - 1U) << MDMA_CBNDTR_BRC_Pos) & MDMA_CBNDTR_BRC);
2400f2fe:	68fb      	ldr	r3, [r7, #12]
2400f300:	681b      	ldr	r3, [r3, #0]
2400f302:	695b      	ldr	r3, [r3, #20]
2400f304:	f3c3 0113 	ubfx	r1, r3, #0, #20
2400f308:	6a3b      	ldr	r3, [r7, #32]
2400f30a:	3b01      	subs	r3, #1
2400f30c:	051a      	lsls	r2, r3, #20
2400f30e:	68fb      	ldr	r3, [r7, #12]
2400f310:	681b      	ldr	r3, [r3, #0]
2400f312:	430a      	orrs	r2, r1
2400f314:	615a      	str	r2, [r3, #20]

  /* Clear all interrupt flags */
  __HAL_MDMA_CLEAR_FLAG(hmdma, MDMA_FLAG_TE | MDMA_FLAG_CTC | MDMA_CISR_BRTIF | MDMA_CISR_BTIF | MDMA_CISR_TCIF);
2400f316:	68fb      	ldr	r3, [r7, #12]
2400f318:	681b      	ldr	r3, [r3, #0]
2400f31a:	221f      	movs	r2, #31
2400f31c:	605a      	str	r2, [r3, #4]

  /* Configure MDMA Channel destination address */
  hmdma->Instance->CDAR = DstAddress;
2400f31e:	68fb      	ldr	r3, [r7, #12]
2400f320:	681b      	ldr	r3, [r3, #0]
2400f322:	687a      	ldr	r2, [r7, #4]
2400f324:	61da      	str	r2, [r3, #28]

  /* Configure MDMA Channel Source address */
  hmdma->Instance->CSAR = SrcAddress;
2400f326:	68fb      	ldr	r3, [r7, #12]
2400f328:	681b      	ldr	r3, [r3, #0]
2400f32a:	68ba      	ldr	r2, [r7, #8]
2400f32c:	619a      	str	r2, [r3, #24]

  addressMask = SrcAddress & 0xFF000000U;
2400f32e:	68bb      	ldr	r3, [r7, #8]
2400f330:	f003 437f 	and.w	r3, r3, #4278190080	; 0xff000000
2400f334:	617b      	str	r3, [r7, #20]
  if((addressMask == 0x20000000U) || (addressMask == 0x00000000U))
2400f336:	697b      	ldr	r3, [r7, #20]
2400f338:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
2400f33c:	d002      	beq.n	2400f344 <MDMA_SetConfig+0x6c>
2400f33e:	697b      	ldr	r3, [r7, #20]
2400f340:	2b00      	cmp	r3, #0
2400f342:	d108      	bne.n	2400f356 <MDMA_SetConfig+0x7e>
  {
    /*The AHBSbus is used as source (read operation) on channel x */
    hmdma->Instance->CTBR |= MDMA_CTBR_SBUS;
2400f344:	68fb      	ldr	r3, [r7, #12]
2400f346:	681b      	ldr	r3, [r3, #0]
2400f348:	6a9a      	ldr	r2, [r3, #40]	; 0x28
2400f34a:	68fb      	ldr	r3, [r7, #12]
2400f34c:	681b      	ldr	r3, [r3, #0]
2400f34e:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
2400f352:	629a      	str	r2, [r3, #40]	; 0x28
2400f354:	e007      	b.n	2400f366 <MDMA_SetConfig+0x8e>
  }
  else
  {
    /*The AXI bus is used as source (read operation) on channel x */
    hmdma->Instance->CTBR &= (~MDMA_CTBR_SBUS);
2400f356:	68fb      	ldr	r3, [r7, #12]
2400f358:	681b      	ldr	r3, [r3, #0]
2400f35a:	6a9a      	ldr	r2, [r3, #40]	; 0x28
2400f35c:	68fb      	ldr	r3, [r7, #12]
2400f35e:	681b      	ldr	r3, [r3, #0]
2400f360:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
2400f364:	629a      	str	r2, [r3, #40]	; 0x28
  }

  addressMask = DstAddress & 0xFF000000U;
2400f366:	687b      	ldr	r3, [r7, #4]
2400f368:	f003 437f 	and.w	r3, r3, #4278190080	; 0xff000000
2400f36c:	617b      	str	r3, [r7, #20]
  if((addressMask == 0x20000000U) || (addressMask == 0x00000000U))
2400f36e:	697b      	ldr	r3, [r7, #20]
2400f370:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
2400f374:	d002      	beq.n	2400f37c <MDMA_SetConfig+0xa4>
2400f376:	697b      	ldr	r3, [r7, #20]
2400f378:	2b00      	cmp	r3, #0
2400f37a:	d108      	bne.n	2400f38e <MDMA_SetConfig+0xb6>
  {
    /*The AHB bus is used as destination (write operation) on channel x */
    hmdma->Instance->CTBR |= MDMA_CTBR_DBUS;
2400f37c:	68fb      	ldr	r3, [r7, #12]
2400f37e:	681b      	ldr	r3, [r3, #0]
2400f380:	6a9a      	ldr	r2, [r3, #40]	; 0x28
2400f382:	68fb      	ldr	r3, [r7, #12]
2400f384:	681b      	ldr	r3, [r3, #0]
2400f386:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
2400f38a:	629a      	str	r2, [r3, #40]	; 0x28
2400f38c:	e007      	b.n	2400f39e <MDMA_SetConfig+0xc6>
  }
  else
  {
    /*The AXI bus is used as destination (write operation) on channel x */
    hmdma->Instance->CTBR &= (~MDMA_CTBR_DBUS);
2400f38e:	68fb      	ldr	r3, [r7, #12]
2400f390:	681b      	ldr	r3, [r3, #0]
2400f392:	6a9a      	ldr	r2, [r3, #40]	; 0x28
2400f394:	68fb      	ldr	r3, [r7, #12]
2400f396:	681b      	ldr	r3, [r3, #0]
2400f398:	f422 3200 	bic.w	r2, r2, #131072	; 0x20000
2400f39c:	629a      	str	r2, [r3, #40]	; 0x28
  }

  /* Set the linked list register to the first node of the list */
  hmdma->Instance->CLAR = (uint32_t)hmdma->FirstLinkedListNodeAddress;
2400f39e:	68fb      	ldr	r3, [r7, #12]
2400f3a0:	6dda      	ldr	r2, [r3, #92]	; 0x5c
2400f3a2:	68fb      	ldr	r3, [r7, #12]
2400f3a4:	681b      	ldr	r3, [r3, #0]
2400f3a6:	625a      	str	r2, [r3, #36]	; 0x24
}
2400f3a8:	bf00      	nop
2400f3aa:	371c      	adds	r7, #28
2400f3ac:	46bd      	mov	sp, r7
2400f3ae:	f85d 7b04 	ldr.w	r7, [sp], #4
2400f3b2:	4770      	bx	lr
2400f3b4:	fffe0000 	.word	0xfffe0000

2400f3b8 <MDMA_Init>:
  * @param  hmdma:       pointer to a MDMA_HandleTypeDef structure that contains
  *                     the configuration information for the specified MDMA Channel.
  * @retval None
  */
static void MDMA_Init(MDMA_HandleTypeDef *hmdma)
{
2400f3b8:	b480      	push	{r7}
2400f3ba:	b085      	sub	sp, #20
2400f3bc:	af00      	add	r7, sp, #0
2400f3be:	6078      	str	r0, [r7, #4]
  uint32_t blockoffset;

  /* Prepare the MDMA Channel configuration */
  hmdma->Instance->CCR = hmdma->Init.Priority  | hmdma->Init.Endianness;
2400f3c0:	687b      	ldr	r3, [r7, #4]
2400f3c2:	68d9      	ldr	r1, [r3, #12]
2400f3c4:	687b      	ldr	r3, [r7, #4]
2400f3c6:	691a      	ldr	r2, [r3, #16]
2400f3c8:	687b      	ldr	r3, [r7, #4]
2400f3ca:	681b      	ldr	r3, [r3, #0]
2400f3cc:	430a      	orrs	r2, r1
2400f3ce:	60da      	str	r2, [r3, #12]

  /* Write new CTCR Register value */
  hmdma->Instance->CTCR =  hmdma->Init.SourceInc      | hmdma->Init.DestinationInc | \
2400f3d0:	687b      	ldr	r3, [r7, #4]
2400f3d2:	695a      	ldr	r2, [r3, #20]
2400f3d4:	687b      	ldr	r3, [r7, #4]
2400f3d6:	699b      	ldr	r3, [r3, #24]
2400f3d8:	431a      	orrs	r2, r3
                           hmdma->Init.SourceDataSize | hmdma->Init.DestDataSize   | \
2400f3da:	687b      	ldr	r3, [r7, #4]
2400f3dc:	69db      	ldr	r3, [r3, #28]
  hmdma->Instance->CTCR =  hmdma->Init.SourceInc      | hmdma->Init.DestinationInc | \
2400f3de:	431a      	orrs	r2, r3
                           hmdma->Init.SourceDataSize | hmdma->Init.DestDataSize   | \
2400f3e0:	687b      	ldr	r3, [r7, #4]
2400f3e2:	6a1b      	ldr	r3, [r3, #32]
2400f3e4:	431a      	orrs	r2, r3
                           hmdma->Init.DataAlignment  | hmdma->Init.SourceBurst    | \
2400f3e6:	687b      	ldr	r3, [r7, #4]
2400f3e8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
                           hmdma->Init.SourceDataSize | hmdma->Init.DestDataSize   | \
2400f3ea:	431a      	orrs	r2, r3
                           hmdma->Init.DataAlignment  | hmdma->Init.SourceBurst    | \
2400f3ec:	687b      	ldr	r3, [r7, #4]
2400f3ee:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2400f3f0:	431a      	orrs	r2, r3
                           hmdma->Init.DestBurst                                   | \
2400f3f2:	687b      	ldr	r3, [r7, #4]
2400f3f4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
                           hmdma->Init.DataAlignment  | hmdma->Init.SourceBurst    | \
2400f3f6:	431a      	orrs	r2, r3
                           ((hmdma->Init.BufferTransferLength - 1U) << MDMA_CTCR_TLEN_Pos) | \
2400f3f8:	687b      	ldr	r3, [r7, #4]
2400f3fa:	6a9b      	ldr	r3, [r3, #40]	; 0x28
2400f3fc:	3b01      	subs	r3, #1
2400f3fe:	049b      	lsls	r3, r3, #18
                           hmdma->Init.DestBurst                                   | \
2400f400:	ea42 0103 	orr.w	r1, r2, r3
                           hmdma->Init.TransferTriggerMode;
2400f404:	687b      	ldr	r3, [r7, #4]
2400f406:	689a      	ldr	r2, [r3, #8]
  hmdma->Instance->CTCR =  hmdma->Init.SourceInc      | hmdma->Init.DestinationInc | \
2400f408:	687b      	ldr	r3, [r7, #4]
2400f40a:	681b      	ldr	r3, [r3, #0]
                           ((hmdma->Init.BufferTransferLength - 1U) << MDMA_CTCR_TLEN_Pos) | \
2400f40c:	430a      	orrs	r2, r1
  hmdma->Instance->CTCR =  hmdma->Init.SourceInc      | hmdma->Init.DestinationInc | \
2400f40e:	611a      	str	r2, [r3, #16]

  /* If SW request set the CTCR register to SW Request Mode */
  if(hmdma->Init.Request == MDMA_REQUEST_SW)
2400f410:	687b      	ldr	r3, [r7, #4]
2400f412:	685b      	ldr	r3, [r3, #4]
2400f414:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
2400f418:	d107      	bne.n	2400f42a <MDMA_Init+0x72>
    -If the request is done by SW : BWM could be set to 1 or 0.
    -If the request is done by a peripheral :
    If mask address not set (0) => BWM must be set to 0
    If mask address set (different than 0) => BWM could be set to 1 or 0
    */
    hmdma->Instance->CTCR |= (MDMA_CTCR_SWRM | MDMA_CTCR_BWM);
2400f41a:	687b      	ldr	r3, [r7, #4]
2400f41c:	681b      	ldr	r3, [r3, #0]
2400f41e:	691a      	ldr	r2, [r3, #16]
2400f420:	687b      	ldr	r3, [r7, #4]
2400f422:	681b      	ldr	r3, [r3, #0]
2400f424:	f042 4240 	orr.w	r2, r2, #3221225472	; 0xc0000000
2400f428:	611a      	str	r2, [r3, #16]
  }

  /* Reset CBNDTR Register */
  hmdma->Instance->CBNDTR = 0;
2400f42a:	687b      	ldr	r3, [r7, #4]
2400f42c:	681b      	ldr	r3, [r3, #0]
2400f42e:	2200      	movs	r2, #0
2400f430:	615a      	str	r2, [r3, #20]

  /* if block source address offset is negative set the Block Repeat Source address Update Mode to decrement */
  if(hmdma->Init.SourceBlockAddressOffset < 0)
2400f432:	687b      	ldr	r3, [r7, #4]
2400f434:	6b5b      	ldr	r3, [r3, #52]	; 0x34
2400f436:	2b00      	cmp	r3, #0
2400f438:	da11      	bge.n	2400f45e <MDMA_Init+0xa6>
  {
    hmdma->Instance->CBNDTR |= MDMA_CBNDTR_BRSUM;
2400f43a:	687b      	ldr	r3, [r7, #4]
2400f43c:	681b      	ldr	r3, [r3, #0]
2400f43e:	695a      	ldr	r2, [r3, #20]
2400f440:	687b      	ldr	r3, [r7, #4]
2400f442:	681b      	ldr	r3, [r3, #0]
2400f444:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
2400f448:	615a      	str	r2, [r3, #20]
    /* Write new CBRUR Register value : source repeat block offset */
    blockoffset = (uint32_t)(- hmdma->Init.SourceBlockAddressOffset);
2400f44a:	687b      	ldr	r3, [r7, #4]
2400f44c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
2400f44e:	425b      	negs	r3, r3
2400f450:	60fb      	str	r3, [r7, #12]
    hmdma->Instance->CBRUR = (blockoffset & 0x0000FFFFU);
2400f452:	687b      	ldr	r3, [r7, #4]
2400f454:	681b      	ldr	r3, [r3, #0]
2400f456:	68fa      	ldr	r2, [r7, #12]
2400f458:	b292      	uxth	r2, r2
2400f45a:	621a      	str	r2, [r3, #32]
2400f45c:	e006      	b.n	2400f46c <MDMA_Init+0xb4>
  }
  else
  {
    /* Write new CBRUR Register value : source repeat block offset */
    hmdma->Instance->CBRUR = (((uint32_t)hmdma->Init.SourceBlockAddressOffset) & 0x0000FFFFU);
2400f45e:	687b      	ldr	r3, [r7, #4]
2400f460:	6b5b      	ldr	r3, [r3, #52]	; 0x34
2400f462:	461a      	mov	r2, r3
2400f464:	687b      	ldr	r3, [r7, #4]
2400f466:	681b      	ldr	r3, [r3, #0]
2400f468:	b292      	uxth	r2, r2
2400f46a:	621a      	str	r2, [r3, #32]
  }

  /* If block destination address offset is negative set the Block Repeat destination address Update Mode to decrement */
  if(hmdma->Init.DestBlockAddressOffset < 0)
2400f46c:	687b      	ldr	r3, [r7, #4]
2400f46e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400f470:	2b00      	cmp	r3, #0
2400f472:	da15      	bge.n	2400f4a0 <MDMA_Init+0xe8>
  {
    hmdma->Instance->CBNDTR |= MDMA_CBNDTR_BRDUM;
2400f474:	687b      	ldr	r3, [r7, #4]
2400f476:	681b      	ldr	r3, [r3, #0]
2400f478:	695a      	ldr	r2, [r3, #20]
2400f47a:	687b      	ldr	r3, [r7, #4]
2400f47c:	681b      	ldr	r3, [r3, #0]
2400f47e:	f442 2200 	orr.w	r2, r2, #524288	; 0x80000
2400f482:	615a      	str	r2, [r3, #20]
    /* Write new CBRUR Register value : destination repeat block offset */
    blockoffset = (uint32_t)(- hmdma->Init.DestBlockAddressOffset);
2400f484:	687b      	ldr	r3, [r7, #4]
2400f486:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400f488:	425b      	negs	r3, r3
2400f48a:	60fb      	str	r3, [r7, #12]
    hmdma->Instance->CBRUR |= ((blockoffset & 0x0000FFFFU) << MDMA_CBRUR_DUV_Pos);
2400f48c:	687b      	ldr	r3, [r7, #4]
2400f48e:	681b      	ldr	r3, [r3, #0]
2400f490:	6a19      	ldr	r1, [r3, #32]
2400f492:	68fb      	ldr	r3, [r7, #12]
2400f494:	041a      	lsls	r2, r3, #16
2400f496:	687b      	ldr	r3, [r7, #4]
2400f498:	681b      	ldr	r3, [r3, #0]
2400f49a:	430a      	orrs	r2, r1
2400f49c:	621a      	str	r2, [r3, #32]
2400f49e:	e009      	b.n	2400f4b4 <MDMA_Init+0xfc>
  }
  else
  {
    /*write new CBRUR Register value : destination repeat block offset */
    hmdma->Instance->CBRUR |= ((((uint32_t)hmdma->Init.DestBlockAddressOffset) & 0x0000FFFFU) << MDMA_CBRUR_DUV_Pos);
2400f4a0:	687b      	ldr	r3, [r7, #4]
2400f4a2:	681b      	ldr	r3, [r3, #0]
2400f4a4:	6a19      	ldr	r1, [r3, #32]
2400f4a6:	687b      	ldr	r3, [r7, #4]
2400f4a8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400f4aa:	041a      	lsls	r2, r3, #16
2400f4ac:	687b      	ldr	r3, [r7, #4]
2400f4ae:	681b      	ldr	r3, [r3, #0]
2400f4b0:	430a      	orrs	r2, r1
2400f4b2:	621a      	str	r2, [r3, #32]
  }

  /* if HW request set the HW request and the requet CleraMask and ClearData MaskData, */
  if(hmdma->Init.Request != MDMA_REQUEST_SW)
2400f4b4:	687b      	ldr	r3, [r7, #4]
2400f4b6:	685b      	ldr	r3, [r3, #4]
2400f4b8:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
2400f4bc:	d006      	beq.n	2400f4cc <MDMA_Init+0x114>
  {
    /* Set the HW request in CTRB register  */
    hmdma->Instance->CTBR = hmdma->Init.Request & MDMA_CTBR_TSEL;
2400f4be:	687b      	ldr	r3, [r7, #4]
2400f4c0:	685a      	ldr	r2, [r3, #4]
2400f4c2:	687b      	ldr	r3, [r7, #4]
2400f4c4:	681b      	ldr	r3, [r3, #0]
2400f4c6:	b2d2      	uxtb	r2, r2
2400f4c8:	629a      	str	r2, [r3, #40]	; 0x28
2400f4ca:	e003      	b.n	2400f4d4 <MDMA_Init+0x11c>
  }
  else /* SW request : reset the CTBR register */
  {
    hmdma->Instance->CTBR = 0;
2400f4cc:	687b      	ldr	r3, [r7, #4]
2400f4ce:	681b      	ldr	r3, [r3, #0]
2400f4d0:	2200      	movs	r2, #0
2400f4d2:	629a      	str	r2, [r3, #40]	; 0x28
  }

  /* Write Link Address Register */
  hmdma->Instance->CLAR =  0;
2400f4d4:	687b      	ldr	r3, [r7, #4]
2400f4d6:	681b      	ldr	r3, [r3, #0]
2400f4d8:	2200      	movs	r2, #0
2400f4da:	625a      	str	r2, [r3, #36]	; 0x24
}
2400f4dc:	bf00      	nop
2400f4de:	3714      	adds	r7, #20
2400f4e0:	46bd      	mov	sp, r7
2400f4e2:	f85d 7b04 	ldr.w	r7, [sp], #4
2400f4e6:	4770      	bx	lr

2400f4e8 <HAL_PWR_DeInit>:
  *         The prototype is kept just to maintain compatibility with other
  *         products.
  * @retval None.
  */
void HAL_PWR_DeInit (void)
{
2400f4e8:	b480      	push	{r7}
2400f4ea:	af00      	add	r7, sp, #0
}
2400f4ec:	bf00      	nop
2400f4ee:	46bd      	mov	sp, r7
2400f4f0:	f85d 7b04 	ldr.w	r7, [sp], #4
2400f4f4:	4770      	bx	lr
	...

2400f4f8 <HAL_PWR_EnableBkUpAccess>:
  * @note   If the HSE divided by 2, 3, ..31 is used as the RTC clock, the
  *         Backup Domain Access should be kept enabled.
  * @retval None.
  */
void HAL_PWR_EnableBkUpAccess (void)
{
2400f4f8:	b480      	push	{r7}
2400f4fa:	af00      	add	r7, sp, #0
  /* Enable access to RTC and backup registers */
  SET_BIT (PWR->CR1, PWR_CR1_DBP);
2400f4fc:	4b05      	ldr	r3, [pc, #20]	; (2400f514 <HAL_PWR_EnableBkUpAccess+0x1c>)
2400f4fe:	681b      	ldr	r3, [r3, #0]
2400f500:	4a04      	ldr	r2, [pc, #16]	; (2400f514 <HAL_PWR_EnableBkUpAccess+0x1c>)
2400f502:	f443 7380 	orr.w	r3, r3, #256	; 0x100
2400f506:	6013      	str	r3, [r2, #0]
}
2400f508:	bf00      	nop
2400f50a:	46bd      	mov	sp, r7
2400f50c:	f85d 7b04 	ldr.w	r7, [sp], #4
2400f510:	4770      	bx	lr
2400f512:	bf00      	nop
2400f514:	58024800 	.word	0x58024800

2400f518 <HAL_PWR_DisableBkUpAccess>:
  * @note   If the HSE divided by 2, 3, ..31 is used as the RTC clock, the
  *         Backup Domain Access should be kept enabled.
  * @retval None.
  */
void HAL_PWR_DisableBkUpAccess (void)
{
2400f518:	b480      	push	{r7}
2400f51a:	af00      	add	r7, sp, #0
  /* Disable access to RTC and backup registers */
  CLEAR_BIT (PWR->CR1, PWR_CR1_DBP);
2400f51c:	4b05      	ldr	r3, [pc, #20]	; (2400f534 <HAL_PWR_DisableBkUpAccess+0x1c>)
2400f51e:	681b      	ldr	r3, [r3, #0]
2400f520:	4a04      	ldr	r2, [pc, #16]	; (2400f534 <HAL_PWR_DisableBkUpAccess+0x1c>)
2400f522:	f423 7380 	bic.w	r3, r3, #256	; 0x100
2400f526:	6013      	str	r3, [r2, #0]
}
2400f528:	bf00      	nop
2400f52a:	46bd      	mov	sp, r7
2400f52c:	f85d 7b04 	ldr.w	r7, [sp], #4
2400f530:	4770      	bx	lr
2400f532:	bf00      	nop
2400f534:	58024800 	.word	0x58024800

2400f538 <HAL_PWR_ConfigPVD>:
  *         driver. All combination are allowed: wake up only Cortex-M7, wake up
  *         only Cortex-M4 or wake up Cortex-M7 and Cortex-M4.
  * @retval None.
  */
void HAL_PWR_ConfigPVD (PWR_PVDTypeDef *sConfigPVD)
{
2400f538:	b480      	push	{r7}
2400f53a:	b083      	sub	sp, #12
2400f53c:	af00      	add	r7, sp, #0
2400f53e:	6078      	str	r0, [r7, #4]
  /* Check the PVD configuration parameter */
  if (sConfigPVD == NULL)
2400f540:	687b      	ldr	r3, [r7, #4]
2400f542:	2b00      	cmp	r3, #0
2400f544:	d069      	beq.n	2400f61a <HAL_PWR_ConfigPVD+0xe2>
  /* Check the parameters */
  assert_param (IS_PWR_PVD_LEVEL (sConfigPVD->PVDLevel));
  assert_param (IS_PWR_PVD_MODE (sConfigPVD->Mode));

  /* Set PLS[7:5] bits according to PVDLevel value */
  MODIFY_REG (PWR->CR1, PWR_CR1_PLS, sConfigPVD->PVDLevel);
2400f546:	4b38      	ldr	r3, [pc, #224]	; (2400f628 <HAL_PWR_ConfigPVD+0xf0>)
2400f548:	681b      	ldr	r3, [r3, #0]
2400f54a:	f023 02e0 	bic.w	r2, r3, #224	; 0xe0
2400f54e:	687b      	ldr	r3, [r7, #4]
2400f550:	681b      	ldr	r3, [r3, #0]
2400f552:	4935      	ldr	r1, [pc, #212]	; (2400f628 <HAL_PWR_ConfigPVD+0xf0>)
2400f554:	4313      	orrs	r3, r2
2400f556:	600b      	str	r3, [r1, #0]

  /* Clear previous config */
#if !defined (DUAL_CORE)
  __HAL_PWR_PVD_EXTI_DISABLE_EVENT ();
2400f558:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
2400f55c:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
2400f560:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
2400f564:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
2400f568:	f8c2 3084 	str.w	r3, [r2, #132]	; 0x84
  __HAL_PWR_PVD_EXTI_DISABLE_IT ();
2400f56c:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
2400f570:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
2400f574:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
2400f578:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
2400f57c:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
#endif /* !defined (DUAL_CORE) */

  __HAL_PWR_PVD_EXTI_DISABLE_RISING_EDGE ();
2400f580:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
2400f584:	681b      	ldr	r3, [r3, #0]
2400f586:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
2400f58a:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
2400f58e:	6013      	str	r3, [r2, #0]
  __HAL_PWR_PVD_EXTI_DISABLE_FALLING_EDGE ();
2400f590:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
2400f594:	685b      	ldr	r3, [r3, #4]
2400f596:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
2400f59a:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
2400f59e:	6053      	str	r3, [r2, #4]

#if !defined (DUAL_CORE)
  /* Interrupt mode configuration */
  if ((sConfigPVD->Mode & PVD_MODE_IT) == PVD_MODE_IT)
2400f5a0:	687b      	ldr	r3, [r7, #4]
2400f5a2:	685b      	ldr	r3, [r3, #4]
2400f5a4:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
2400f5a8:	2b00      	cmp	r3, #0
2400f5aa:	d009      	beq.n	2400f5c0 <HAL_PWR_ConfigPVD+0x88>
  {
    __HAL_PWR_PVD_EXTI_ENABLE_IT ();
2400f5ac:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
2400f5b0:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
2400f5b4:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
2400f5b8:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
2400f5bc:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
  }

  /* Event mode configuration */
  if ((sConfigPVD->Mode & PVD_MODE_EVT) == PVD_MODE_EVT)
2400f5c0:	687b      	ldr	r3, [r7, #4]
2400f5c2:	685b      	ldr	r3, [r3, #4]
2400f5c4:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
2400f5c8:	2b00      	cmp	r3, #0
2400f5ca:	d009      	beq.n	2400f5e0 <HAL_PWR_ConfigPVD+0xa8>
  {
    __HAL_PWR_PVD_EXTI_ENABLE_EVENT ();
2400f5cc:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
2400f5d0:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
2400f5d4:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
2400f5d8:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
2400f5dc:	f8c2 3084 	str.w	r3, [r2, #132]	; 0x84
  }
#endif /* !defined (DUAL_CORE) */

  /* Rising edge configuration */
  if ((sConfigPVD->Mode & PVD_RISING_EDGE) == PVD_RISING_EDGE)
2400f5e0:	687b      	ldr	r3, [r7, #4]
2400f5e2:	685b      	ldr	r3, [r3, #4]
2400f5e4:	f003 0301 	and.w	r3, r3, #1
2400f5e8:	2b00      	cmp	r3, #0
2400f5ea:	d007      	beq.n	2400f5fc <HAL_PWR_ConfigPVD+0xc4>
  {
    __HAL_PWR_PVD_EXTI_ENABLE_RISING_EDGE ();
2400f5ec:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
2400f5f0:	681b      	ldr	r3, [r3, #0]
2400f5f2:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
2400f5f6:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
2400f5fa:	6013      	str	r3, [r2, #0]
  }

  /* Falling edge configuration */
  if ((sConfigPVD->Mode & PVD_FALLING_EDGE) == PVD_FALLING_EDGE)
2400f5fc:	687b      	ldr	r3, [r7, #4]
2400f5fe:	685b      	ldr	r3, [r3, #4]
2400f600:	f003 0302 	and.w	r3, r3, #2
2400f604:	2b00      	cmp	r3, #0
2400f606:	d009      	beq.n	2400f61c <HAL_PWR_ConfigPVD+0xe4>
  {
    __HAL_PWR_PVD_EXTI_ENABLE_FALLING_EDGE ();
2400f608:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
2400f60c:	685b      	ldr	r3, [r3, #4]
2400f60e:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
2400f612:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
2400f616:	6053      	str	r3, [r2, #4]
2400f618:	e000      	b.n	2400f61c <HAL_PWR_ConfigPVD+0xe4>
    return;
2400f61a:	bf00      	nop
  }
}
2400f61c:	370c      	adds	r7, #12
2400f61e:	46bd      	mov	sp, r7
2400f620:	f85d 7b04 	ldr.w	r7, [sp], #4
2400f624:	4770      	bx	lr
2400f626:	bf00      	nop
2400f628:	58024800 	.word	0x58024800

2400f62c <HAL_PWR_EnablePVD>:
/**
  * @brief Enable the Programmable Voltage Detector (PVD).
  * @retval None.
  */
void HAL_PWR_EnablePVD (void)
{
2400f62c:	b480      	push	{r7}
2400f62e:	af00      	add	r7, sp, #0
  /* Enable the power voltage detector */
  SET_BIT (PWR->CR1, PWR_CR1_PVDEN);
2400f630:	4b05      	ldr	r3, [pc, #20]	; (2400f648 <HAL_PWR_EnablePVD+0x1c>)
2400f632:	681b      	ldr	r3, [r3, #0]
2400f634:	4a04      	ldr	r2, [pc, #16]	; (2400f648 <HAL_PWR_EnablePVD+0x1c>)
2400f636:	f043 0310 	orr.w	r3, r3, #16
2400f63a:	6013      	str	r3, [r2, #0]
}
2400f63c:	bf00      	nop
2400f63e:	46bd      	mov	sp, r7
2400f640:	f85d 7b04 	ldr.w	r7, [sp], #4
2400f644:	4770      	bx	lr
2400f646:	bf00      	nop
2400f648:	58024800 	.word	0x58024800

2400f64c <HAL_PWR_DisablePVD>:
/**
  * @brief Disable the Programmable Voltage Detector (PVD).
  * @retval None.
  */
void HAL_PWR_DisablePVD (void)
{
2400f64c:	b480      	push	{r7}
2400f64e:	af00      	add	r7, sp, #0
  /* Disable the power voltage detector */
  CLEAR_BIT (PWR->CR1, PWR_CR1_PVDEN);
2400f650:	4b05      	ldr	r3, [pc, #20]	; (2400f668 <HAL_PWR_DisablePVD+0x1c>)
2400f652:	681b      	ldr	r3, [r3, #0]
2400f654:	4a04      	ldr	r2, [pc, #16]	; (2400f668 <HAL_PWR_DisablePVD+0x1c>)
2400f656:	f023 0310 	bic.w	r3, r3, #16
2400f65a:	6013      	str	r3, [r2, #0]
}
2400f65c:	bf00      	nop
2400f65e:	46bd      	mov	sp, r7
2400f660:	f85d 7b04 	ldr.w	r7, [sp], #4
2400f664:	4770      	bx	lr
2400f666:	bf00      	nop
2400f668:	58024800 	.word	0x58024800

2400f66c <HAL_PWR_EnableWakeUpPin>:
  *                 PWR_WAKEUP_PIN6_HIGH, PWR_WAKEUP_PIN6_LOW.
  * @note   PWR_WAKEUP_PINx and PWR_WAKEUP_PINx_HIGH are equivalent.
  * @retval None.
  */
void HAL_PWR_EnableWakeUpPin (uint32_t WakeUpPinPolarity)
{
2400f66c:	b480      	push	{r7}
2400f66e:	b083      	sub	sp, #12
2400f670:	af00      	add	r7, sp, #0
2400f672:	6078      	str	r0, [r7, #4]

  /*
     Enable and Specify the Wake-Up pin polarity and the pull configuration
     for the event detection (rising or falling edge).
  */
  MODIFY_REG (PWR->WKUPEPR, PWR_EWUP_MASK, WakeUpPinPolarity);
2400f674:	4b06      	ldr	r3, [pc, #24]	; (2400f690 <HAL_PWR_EnableWakeUpPin+0x24>)
2400f676:	6a9a      	ldr	r2, [r3, #40]	; 0x28
2400f678:	4b06      	ldr	r3, [pc, #24]	; (2400f694 <HAL_PWR_EnableWakeUpPin+0x28>)
2400f67a:	4013      	ands	r3, r2
2400f67c:	4904      	ldr	r1, [pc, #16]	; (2400f690 <HAL_PWR_EnableWakeUpPin+0x24>)
2400f67e:	687a      	ldr	r2, [r7, #4]
2400f680:	4313      	orrs	r3, r2
2400f682:	628b      	str	r3, [r1, #40]	; 0x28
}
2400f684:	bf00      	nop
2400f686:	370c      	adds	r7, #12
2400f688:	46bd      	mov	sp, r7
2400f68a:	f85d 7b04 	ldr.w	r7, [sp], #4
2400f68e:	4770      	bx	lr
2400f690:	58024800 	.word	0x58024800
2400f694:	f000c0c0 	.word	0xf000c0c0

2400f698 <HAL_PWR_DisableWakeUpPin>:
  *                 PWR_WAKEUP_PIN5_HIGH, PWR_WAKEUP_PIN5_LOW,
  *                 PWR_WAKEUP_PIN6_HIGH, PWR_WAKEUP_PIN6_LOW.
  * @retval None.
  */
void HAL_PWR_DisableWakeUpPin (uint32_t WakeUpPinx)
{
2400f698:	b480      	push	{r7}
2400f69a:	b083      	sub	sp, #12
2400f69c:	af00      	add	r7, sp, #0
2400f69e:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param (IS_PWR_WAKEUP_PIN (WakeUpPinx));

  /* Disable the wake up pin selected */
  CLEAR_BIT (PWR->WKUPEPR, (PWR_WKUPEPR_WKUPEN & WakeUpPinx));
2400f6a0:	4b07      	ldr	r3, [pc, #28]	; (2400f6c0 <HAL_PWR_DisableWakeUpPin+0x28>)
2400f6a2:	6a9a      	ldr	r2, [r3, #40]	; 0x28
2400f6a4:	687b      	ldr	r3, [r7, #4]
2400f6a6:	f003 033f 	and.w	r3, r3, #63	; 0x3f
2400f6aa:	43db      	mvns	r3, r3
2400f6ac:	4904      	ldr	r1, [pc, #16]	; (2400f6c0 <HAL_PWR_DisableWakeUpPin+0x28>)
2400f6ae:	4013      	ands	r3, r2
2400f6b0:	628b      	str	r3, [r1, #40]	; 0x28
}
2400f6b2:	bf00      	nop
2400f6b4:	370c      	adds	r7, #12
2400f6b6:	46bd      	mov	sp, r7
2400f6b8:	f85d 7b04 	ldr.w	r7, [sp], #4
2400f6bc:	4770      	bx	lr
2400f6be:	bf00      	nop
2400f6c0:	58024800 	.word	0x58024800

2400f6c4 <HAL_PWR_EnterSLEEPMode>:
  * @note   Ensure to clear pending events before calling this API through
  *         HAL_PWREx_ClearPendingEvent() when the SLEEP entry is WFE.
  * @retval None.
  */
void HAL_PWR_EnterSLEEPMode (uint32_t Regulator, uint8_t SLEEPEntry)
{
2400f6c4:	b480      	push	{r7}
2400f6c6:	b083      	sub	sp, #12
2400f6c8:	af00      	add	r7, sp, #0
2400f6ca:	6078      	str	r0, [r7, #4]
2400f6cc:	460b      	mov	r3, r1
2400f6ce:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param (IS_PWR_REGULATOR (Regulator));
  assert_param (IS_PWR_SLEEP_ENTRY (SLEEPEntry));

  /* Clear SLEEPDEEP bit of Cortex System Control Register */
  CLEAR_BIT (SCB->SCR, SCB_SCR_SLEEPDEEP_Msk);
2400f6d0:	4b08      	ldr	r3, [pc, #32]	; (2400f6f4 <HAL_PWR_EnterSLEEPMode+0x30>)
2400f6d2:	691b      	ldr	r3, [r3, #16]
2400f6d4:	4a07      	ldr	r2, [pc, #28]	; (2400f6f4 <HAL_PWR_EnterSLEEPMode+0x30>)
2400f6d6:	f023 0304 	bic.w	r3, r3, #4
2400f6da:	6113      	str	r3, [r2, #16]

  /* Select SLEEP mode entry */
  if (SLEEPEntry == PWR_SLEEPENTRY_WFI)
2400f6dc:	78fb      	ldrb	r3, [r7, #3]
2400f6de:	2b01      	cmp	r3, #1
2400f6e0:	d101      	bne.n	2400f6e6 <HAL_PWR_EnterSLEEPMode+0x22>
  {
    /* Request Wait For Interrupt */
    __WFI ();
2400f6e2:	bf30      	wfi
  else
  {
    /* Request Wait For Event */
    __WFE ();
  }
}
2400f6e4:	e000      	b.n	2400f6e8 <HAL_PWR_EnterSLEEPMode+0x24>
    __WFE ();
2400f6e6:	bf20      	wfe
}
2400f6e8:	bf00      	nop
2400f6ea:	370c      	adds	r7, #12
2400f6ec:	46bd      	mov	sp, r7
2400f6ee:	f85d 7b04 	ldr.w	r7, [sp], #4
2400f6f2:	4770      	bx	lr
2400f6f4:	e000ed00 	.word	0xe000ed00

2400f6f8 <HAL_PWR_EnterSTOPMode>:
  *         is waking up. By keeping the internal regulator ON during STOP mode,
  *         the consumption is higher although the startup time is reduced.
  * @retval None.
  */
void HAL_PWR_EnterSTOPMode (uint32_t Regulator, uint8_t STOPEntry)
{
2400f6f8:	b480      	push	{r7}
2400f6fa:	b083      	sub	sp, #12
2400f6fc:	af00      	add	r7, sp, #0
2400f6fe:	6078      	str	r0, [r7, #4]
2400f700:	460b      	mov	r3, r1
2400f702:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param (IS_PWR_REGULATOR (Regulator));
  assert_param (IS_PWR_STOP_ENTRY (STOPEntry));

  /* Select the regulator state in STOP mode */
  MODIFY_REG (PWR->CR1, PWR_CR1_LPDS, Regulator);
2400f704:	4b17      	ldr	r3, [pc, #92]	; (2400f764 <HAL_PWR_EnterSTOPMode+0x6c>)
2400f706:	681b      	ldr	r3, [r3, #0]
2400f708:	f023 0201 	bic.w	r2, r3, #1
2400f70c:	4915      	ldr	r1, [pc, #84]	; (2400f764 <HAL_PWR_EnterSTOPMode+0x6c>)
2400f70e:	687b      	ldr	r3, [r7, #4]
2400f710:	4313      	orrs	r3, r2
2400f712:	600b      	str	r3, [r1, #0]
    /* Keep DSTOP mode when Cortex-M4 enters DEEP-SLEEP */
    CLEAR_BIT (PWR->CPUCR, (PWR_CPUCR_PDDS_D2 | PWR_CPUCR_PDDS_D3));
  }
#else /* Single core devices */
  /* Keep DSTOP mode when Cortex-M7 enter in DEEP-SLEEP */
  CLEAR_BIT (PWR->CPUCR, (PWR_CPUCR_PDDS_D1 | PWR_CPUCR_PDDS_D3));
2400f714:	4b13      	ldr	r3, [pc, #76]	; (2400f764 <HAL_PWR_EnterSTOPMode+0x6c>)
2400f716:	691b      	ldr	r3, [r3, #16]
2400f718:	4a12      	ldr	r2, [pc, #72]	; (2400f764 <HAL_PWR_EnterSTOPMode+0x6c>)
2400f71a:	f023 0305 	bic.w	r3, r3, #5
2400f71e:	6113      	str	r3, [r2, #16]

#if defined (PWR_CPUCR_PDDS_D2)
  /* Keep DSTOP mode when Cortex-M7 enter in DEEP-SLEEP */
  CLEAR_BIT (PWR->CPUCR, PWR_CPUCR_PDDS_D2);
2400f720:	4b10      	ldr	r3, [pc, #64]	; (2400f764 <HAL_PWR_EnterSTOPMode+0x6c>)
2400f722:	691b      	ldr	r3, [r3, #16]
2400f724:	4a0f      	ldr	r2, [pc, #60]	; (2400f764 <HAL_PWR_EnterSTOPMode+0x6c>)
2400f726:	f023 0302 	bic.w	r3, r3, #2
2400f72a:	6113      	str	r3, [r2, #16]
#endif /* PWR_CPUCR_PDDS_D2 */
#endif /* defined (DUAL_CORE) */

  /* Set SLEEPDEEP bit of Cortex System Control Register */
  SET_BIT (SCB->SCR, SCB_SCR_SLEEPDEEP_Msk);
2400f72c:	4b0e      	ldr	r3, [pc, #56]	; (2400f768 <HAL_PWR_EnterSTOPMode+0x70>)
2400f72e:	691b      	ldr	r3, [r3, #16]
2400f730:	4a0d      	ldr	r2, [pc, #52]	; (2400f768 <HAL_PWR_EnterSTOPMode+0x70>)
2400f732:	f043 0304 	orr.w	r3, r3, #4
2400f736:	6113      	str	r3, [r2, #16]
2400f738:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
2400f73c:	f3bf 8f6f 	isb	sy
  /* Ensure that all instructions are done before entering STOP mode */
  __DSB ();
  __ISB ();

  /* Select STOP mode entry */
  if (STOPEntry == PWR_STOPENTRY_WFI)
2400f740:	78fb      	ldrb	r3, [r7, #3]
2400f742:	2b01      	cmp	r3, #1
2400f744:	d101      	bne.n	2400f74a <HAL_PWR_EnterSTOPMode+0x52>
  {
    /* Request Wait For Interrupt */
    __WFI ();
2400f746:	bf30      	wfi
2400f748:	e000      	b.n	2400f74c <HAL_PWR_EnterSTOPMode+0x54>
  }
  else
  {
    /* Request Wait For Event */
    __WFE ();
2400f74a:	bf20      	wfe
  }

  /* Clear SLEEPDEEP bit of Cortex-Mx in the System Control Register */
  CLEAR_BIT (SCB->SCR, SCB_SCR_SLEEPDEEP_Msk);
2400f74c:	4b06      	ldr	r3, [pc, #24]	; (2400f768 <HAL_PWR_EnterSTOPMode+0x70>)
2400f74e:	691b      	ldr	r3, [r3, #16]
2400f750:	4a05      	ldr	r2, [pc, #20]	; (2400f768 <HAL_PWR_EnterSTOPMode+0x70>)
2400f752:	f023 0304 	bic.w	r3, r3, #4
2400f756:	6113      	str	r3, [r2, #16]
}
2400f758:	bf00      	nop
2400f75a:	370c      	adds	r7, #12
2400f75c:	46bd      	mov	sp, r7
2400f75e:	f85d 7b04 	ldr.w	r7, [sp], #4
2400f762:	4770      	bx	lr
2400f764:	58024800 	.word	0x58024800
2400f768:	e000ed00 	.word	0xe000ed00

2400f76c <HAL_PWR_EnterSTANDBYMode>:
  * @note   When the System exit STANDBY mode by issuing an interrupt or a
  *         wakeup event, the HSI RC oscillator is selected as system clock.
  * @retval None.
  */
void HAL_PWR_EnterSTANDBYMode (void)
{
2400f76c:	b480      	push	{r7}
2400f76e:	af00      	add	r7, sp, #0
    SET_BIT (PWR->CPUCR, (PWR_CPUCR_PDDS_D2 | PWR_CPUCR_PDDS_D3));
    SET_BIT (PWR->CPU2CR, (PWR_CPU2CR_PDDS_D2 | PWR_CPU2CR_PDDS_D3));
  }
#else /* Single core devices */
  /* Enter DSTANDBY mode when Cortex-M7 enters DEEP-SLEEP */
  SET_BIT (PWR->CPUCR, (PWR_CPUCR_PDDS_D1 | PWR_CPUCR_PDDS_D3));
2400f770:	4b0d      	ldr	r3, [pc, #52]	; (2400f7a8 <HAL_PWR_EnterSTANDBYMode+0x3c>)
2400f772:	691b      	ldr	r3, [r3, #16]
2400f774:	4a0c      	ldr	r2, [pc, #48]	; (2400f7a8 <HAL_PWR_EnterSTANDBYMode+0x3c>)
2400f776:	f043 0305 	orr.w	r3, r3, #5
2400f77a:	6113      	str	r3, [r2, #16]

#if defined (PWR_CPUCR_PDDS_D2)
  /* Enter DSTANDBY mode when Cortex-M7 enters DEEP-SLEEP */
  SET_BIT (PWR->CPUCR, PWR_CPUCR_PDDS_D2);
2400f77c:	4b0a      	ldr	r3, [pc, #40]	; (2400f7a8 <HAL_PWR_EnterSTANDBYMode+0x3c>)
2400f77e:	691b      	ldr	r3, [r3, #16]
2400f780:	4a09      	ldr	r2, [pc, #36]	; (2400f7a8 <HAL_PWR_EnterSTANDBYMode+0x3c>)
2400f782:	f043 0302 	orr.w	r3, r3, #2
2400f786:	6113      	str	r3, [r2, #16]
#endif /* PWR_CPUCR_PDDS_D2 */
#endif /* defined (DUAL_CORE) */

  /* Set SLEEPDEEP bit of Cortex System Control Register */
  SET_BIT (SCB->SCR, SCB_SCR_SLEEPDEEP_Msk);
2400f788:	4b08      	ldr	r3, [pc, #32]	; (2400f7ac <HAL_PWR_EnterSTANDBYMode+0x40>)
2400f78a:	691b      	ldr	r3, [r3, #16]
2400f78c:	4a07      	ldr	r2, [pc, #28]	; (2400f7ac <HAL_PWR_EnterSTANDBYMode+0x40>)
2400f78e:	f043 0304 	orr.w	r3, r3, #4
2400f792:	6113      	str	r3, [r2, #16]
  __ASM volatile ("dsb 0xF":::"memory");
2400f794:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
2400f798:	f3bf 8f6f 	isb	sy
#if defined (__CC_ARM)
  __force_stores();
#endif /* defined (__CC_ARM) */

  /* Request Wait For Interrupt */
  __WFI ();
2400f79c:	bf30      	wfi
}
2400f79e:	bf00      	nop
2400f7a0:	46bd      	mov	sp, r7
2400f7a2:	f85d 7b04 	ldr.w	r7, [sp], #4
2400f7a6:	4770      	bx	lr
2400f7a8:	58024800 	.word	0x58024800
2400f7ac:	e000ed00 	.word	0xe000ed00

2400f7b0 <HAL_PWR_EnableSleepOnExit>:
  *         Setting this bit is useful when the processor is expected to run
  *         only on interruptions handling.
  * @retval None.
  */
void HAL_PWR_EnableSleepOnExit (void)
{
2400f7b0:	b480      	push	{r7}
2400f7b2:	af00      	add	r7, sp, #0
  /* Set SLEEPONEXIT bit of Cortex-Mx System Control Register */
  SET_BIT (SCB->SCR, SCB_SCR_SLEEPONEXIT_Msk);
2400f7b4:	4b05      	ldr	r3, [pc, #20]	; (2400f7cc <HAL_PWR_EnableSleepOnExit+0x1c>)
2400f7b6:	691b      	ldr	r3, [r3, #16]
2400f7b8:	4a04      	ldr	r2, [pc, #16]	; (2400f7cc <HAL_PWR_EnableSleepOnExit+0x1c>)
2400f7ba:	f043 0302 	orr.w	r3, r3, #2
2400f7be:	6113      	str	r3, [r2, #16]
}
2400f7c0:	bf00      	nop
2400f7c2:	46bd      	mov	sp, r7
2400f7c4:	f85d 7b04 	ldr.w	r7, [sp], #4
2400f7c8:	4770      	bx	lr
2400f7ca:	bf00      	nop
2400f7cc:	e000ed00 	.word	0xe000ed00

2400f7d0 <HAL_PWR_DisableSleepOnExit>:
  * @note   Clears SLEEPONEXIT bit of SCR register. When this bit is set, the
  *         processor re-enters SLEEP mode when an interruption handling is over.
  * @retval None
  */
void HAL_PWR_DisableSleepOnExit (void)
{
2400f7d0:	b480      	push	{r7}
2400f7d2:	af00      	add	r7, sp, #0
  /* Clear SLEEPONEXIT bit of Cortex-Mx System Control Register */
  CLEAR_BIT (SCB->SCR, SCB_SCR_SLEEPONEXIT_Msk);
2400f7d4:	4b05      	ldr	r3, [pc, #20]	; (2400f7ec <HAL_PWR_DisableSleepOnExit+0x1c>)
2400f7d6:	691b      	ldr	r3, [r3, #16]
2400f7d8:	4a04      	ldr	r2, [pc, #16]	; (2400f7ec <HAL_PWR_DisableSleepOnExit+0x1c>)
2400f7da:	f023 0302 	bic.w	r3, r3, #2
2400f7de:	6113      	str	r3, [r2, #16]
}
2400f7e0:	bf00      	nop
2400f7e2:	46bd      	mov	sp, r7
2400f7e4:	f85d 7b04 	ldr.w	r7, [sp], #4
2400f7e8:	4770      	bx	lr
2400f7ea:	bf00      	nop
2400f7ec:	e000ed00 	.word	0xe000ed00

2400f7f0 <HAL_PWR_EnableSEVOnPend>:
  *         pending event / interrupt even if it's disabled or has insufficient
  *         priority to cause exception entry wakes up the Cortex-Mx.
  * @retval None.
  */
void HAL_PWR_EnableSEVOnPend (void)
{
2400f7f0:	b480      	push	{r7}
2400f7f2:	af00      	add	r7, sp, #0
  /* Set SEVONPEND bit of Cortex-Mx System Control Register */
  SET_BIT (SCB->SCR, SCB_SCR_SEVONPEND_Msk);
2400f7f4:	4b05      	ldr	r3, [pc, #20]	; (2400f80c <HAL_PWR_EnableSEVOnPend+0x1c>)
2400f7f6:	691b      	ldr	r3, [r3, #16]
2400f7f8:	4a04      	ldr	r2, [pc, #16]	; (2400f80c <HAL_PWR_EnableSEVOnPend+0x1c>)
2400f7fa:	f043 0310 	orr.w	r3, r3, #16
2400f7fe:	6113      	str	r3, [r2, #16]
}
2400f800:	bf00      	nop
2400f802:	46bd      	mov	sp, r7
2400f804:	f85d 7b04 	ldr.w	r7, [sp], #4
2400f808:	4770      	bx	lr
2400f80a:	bf00      	nop
2400f80c:	e000ed00 	.word	0xe000ed00

2400f810 <HAL_PWR_DisableSEVOnPend>:
  * @note   Resets SEVONPEND bit of SCR register. When this bit is reset, only
  *         enabled pending causes exception entry wakes up the Cortex-Mx.
  * @retval None.
  */
void HAL_PWR_DisableSEVOnPend (void)
{
2400f810:	b480      	push	{r7}
2400f812:	af00      	add	r7, sp, #0
  /* Clear SEVONPEND bit of Cortex System Control Register */
  CLEAR_BIT (SCB->SCR, SCB_SCR_SEVONPEND_Msk);
2400f814:	4b05      	ldr	r3, [pc, #20]	; (2400f82c <HAL_PWR_DisableSEVOnPend+0x1c>)
2400f816:	691b      	ldr	r3, [r3, #16]
2400f818:	4a04      	ldr	r2, [pc, #16]	; (2400f82c <HAL_PWR_DisableSEVOnPend+0x1c>)
2400f81a:	f023 0310 	bic.w	r3, r3, #16
2400f81e:	6113      	str	r3, [r2, #16]
}
2400f820:	bf00      	nop
2400f822:	46bd      	mov	sp, r7
2400f824:	f85d 7b04 	ldr.w	r7, [sp], #4
2400f828:	4770      	bx	lr
2400f82a:	bf00      	nop
2400f82c:	e000ed00 	.word	0xe000ed00

2400f830 <HAL_PWR_PVD_IRQHandler>:
  * @brief  This function handles the PWR PVD interrupt request.
  * @note   This API should be called under the PVD_AVD_IRQHandler().
  * @retval None.
  */
void HAL_PWR_PVD_IRQHandler (void)
{
2400f830:	b580      	push	{r7, lr}
2400f832:	af00      	add	r7, sp, #0
      HAL_PWR_PVDCallback ();
    }
  }
#else /* Single core devices */
  /* PVD EXTI line interrupt detected */
  if (__HAL_PWR_PVD_EXTI_GET_FLAG () != 0U)
2400f834:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
2400f838:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
2400f83c:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
2400f840:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
2400f844:	d10b      	bne.n	2400f85e <HAL_PWR_PVD_IRQHandler+0x2e>
  {
    /* Clear PWR EXTI pending bit */
    __HAL_PWR_PVD_EXTI_CLEAR_FLAG ();
2400f846:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
2400f84a:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
2400f84e:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
2400f852:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
2400f856:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88

    /* PWR PVD interrupt user callback */
    HAL_PWR_PVDCallback ();
2400f85a:	f000 f802 	bl	2400f862 <HAL_PWR_PVDCallback>
  }
#endif /* defined (DUAL_CORE) */
}
2400f85e:	bf00      	nop
2400f860:	bd80      	pop	{r7, pc}

2400f862 <HAL_PWR_PVDCallback>:
/**
  * @brief  PWR PVD interrupt callback.
  * @retval None.
  */
__weak void HAL_PWR_PVDCallback (void)
{
2400f862:	b480      	push	{r7}
2400f864:	af00      	add	r7, sp, #0
  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_PWR_PVDCallback can be implemented in the user file
  */
}
2400f866:	bf00      	nop
2400f868:	46bd      	mov	sp, r7
2400f86a:	f85d 7b04 	ldr.w	r7, [sp], #4
2400f86e:	4770      	bx	lr

2400f870 <HAL_PWREx_ConfigSupply>:
  *         PWR_SMPS_2V5_SUPPLIES_EXT are used only for lines that supports SMPS
  *         regulator.
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_PWREx_ConfigSupply (uint32_t SupplySource)
{
2400f870:	b580      	push	{r7, lr}
2400f872:	b084      	sub	sp, #16
2400f874:	af00      	add	r7, sp, #0
2400f876:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param (IS_PWR_SUPPLY (SupplySource));

  /* Check if supply source was configured */
#if defined (PWR_FLAG_SCUEN)
  if (__HAL_PWR_GET_FLAG (PWR_FLAG_SCUEN) == 0U)
2400f878:	4b19      	ldr	r3, [pc, #100]	; (2400f8e0 <HAL_PWREx_ConfigSupply+0x70>)
2400f87a:	68db      	ldr	r3, [r3, #12]
2400f87c:	f003 0304 	and.w	r3, r3, #4
2400f880:	2b04      	cmp	r3, #4
2400f882:	d00a      	beq.n	2400f89a <HAL_PWREx_ConfigSupply+0x2a>
#else
  if ((PWR->CR3 & (PWR_CR3_SMPSEN | PWR_CR3_LDOEN | PWR_CR3_BYPASS)) != (PWR_CR3_SMPSEN | PWR_CR3_LDOEN))
#endif /* defined (PWR_FLAG_SCUEN) */
  {
    /* Check supply configuration */
    if ((PWR->CR3 & PWR_SUPPLY_CONFIG_MASK) != SupplySource)
2400f884:	4b16      	ldr	r3, [pc, #88]	; (2400f8e0 <HAL_PWREx_ConfigSupply+0x70>)
2400f886:	68db      	ldr	r3, [r3, #12]
2400f888:	f003 0307 	and.w	r3, r3, #7
2400f88c:	687a      	ldr	r2, [r7, #4]
2400f88e:	429a      	cmp	r2, r3
2400f890:	d001      	beq.n	2400f896 <HAL_PWREx_ConfigSupply+0x26>
    {
      /* Supply configuration update locked, can't apply a new supply config */
      return HAL_ERROR;
2400f892:	2301      	movs	r3, #1
2400f894:	e01f      	b.n	2400f8d6 <HAL_PWREx_ConfigSupply+0x66>
    else
    {
      /* Supply configuration update locked, but new supply configuration
         matches with old supply configuration : nothing to do
      */
      return HAL_OK;
2400f896:	2300      	movs	r3, #0
2400f898:	e01d      	b.n	2400f8d6 <HAL_PWREx_ConfigSupply+0x66>
    }
  }

  /* Set the power supply configuration */
  MODIFY_REG (PWR->CR3, PWR_SUPPLY_CONFIG_MASK, SupplySource);
2400f89a:	4b11      	ldr	r3, [pc, #68]	; (2400f8e0 <HAL_PWREx_ConfigSupply+0x70>)
2400f89c:	68db      	ldr	r3, [r3, #12]
2400f89e:	f023 0207 	bic.w	r2, r3, #7
2400f8a2:	490f      	ldr	r1, [pc, #60]	; (2400f8e0 <HAL_PWREx_ConfigSupply+0x70>)
2400f8a4:	687b      	ldr	r3, [r7, #4]
2400f8a6:	4313      	orrs	r3, r2
2400f8a8:	60cb      	str	r3, [r1, #12]

  /* Get tick */
  tickstart = HAL_GetTick ();
2400f8aa:	f7f0 ffd1 	bl	24000850 <HAL_GetTick>
2400f8ae:	60f8      	str	r0, [r7, #12]

  /* Wait till voltage level flag is set */
  while (__HAL_PWR_GET_FLAG (PWR_FLAG_ACTVOSRDY) == 0U)
2400f8b0:	e009      	b.n	2400f8c6 <HAL_PWREx_ConfigSupply+0x56>
  {
    if ((HAL_GetTick () - tickstart) > PWR_FLAG_SETTING_DELAY)
2400f8b2:	f7f0 ffcd 	bl	24000850 <HAL_GetTick>
2400f8b6:	4602      	mov	r2, r0
2400f8b8:	68fb      	ldr	r3, [r7, #12]
2400f8ba:	1ad3      	subs	r3, r2, r3
2400f8bc:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
2400f8c0:	d901      	bls.n	2400f8c6 <HAL_PWREx_ConfigSupply+0x56>
    {
      return HAL_ERROR;
2400f8c2:	2301      	movs	r3, #1
2400f8c4:	e007      	b.n	2400f8d6 <HAL_PWREx_ConfigSupply+0x66>
  while (__HAL_PWR_GET_FLAG (PWR_FLAG_ACTVOSRDY) == 0U)
2400f8c6:	4b06      	ldr	r3, [pc, #24]	; (2400f8e0 <HAL_PWREx_ConfigSupply+0x70>)
2400f8c8:	685b      	ldr	r3, [r3, #4]
2400f8ca:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
2400f8ce:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
2400f8d2:	d1ee      	bne.n	2400f8b2 <HAL_PWREx_ConfigSupply+0x42>
      }
    }
  }
#endif /* defined (SMPS) */

  return HAL_OK;
2400f8d4:	2300      	movs	r3, #0
}
2400f8d6:	4618      	mov	r0, r3
2400f8d8:	3710      	adds	r7, #16
2400f8da:	46bd      	mov	sp, r7
2400f8dc:	bd80      	pop	{r7, pc}
2400f8de:	bf00      	nop
2400f8e0:	58024800 	.word	0x58024800

2400f8e4 <HAL_PWREx_GetSupplyConfig>:
/**
  * @brief Get the power supply configuration.
  * @retval The supply configuration.
  */
uint32_t HAL_PWREx_GetSupplyConfig (void)
{
2400f8e4:	b480      	push	{r7}
2400f8e6:	af00      	add	r7, sp, #0
  return (PWR->CR3 & PWR_SUPPLY_CONFIG_MASK);
2400f8e8:	4b04      	ldr	r3, [pc, #16]	; (2400f8fc <HAL_PWREx_GetSupplyConfig+0x18>)
2400f8ea:	68db      	ldr	r3, [r3, #12]
2400f8ec:	f003 0307 	and.w	r3, r3, #7
}
2400f8f0:	4618      	mov	r0, r3
2400f8f2:	46bd      	mov	sp, r7
2400f8f4:	f85d 7b04 	ldr.w	r7, [sp], #4
2400f8f8:	4770      	bx	lr
2400f8fa:	bf00      	nop
2400f8fc:	58024800 	.word	0x58024800

2400f900 <HAL_PWREx_ControlVoltageScaling>:
  *            @arg PWR_REGULATOR_VOLTAGE_SCALE3 : Regulator voltage output
  *                                                range 3 mode.
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_PWREx_ControlVoltageScaling (uint32_t VoltageScaling)
{
2400f900:	b580      	push	{r7, lr}
2400f902:	b084      	sub	sp, #16
2400f904:	af00      	add	r7, sp, #0
2400f906:	6078      	str	r0, [r7, #4]

  /* Check the parameters */
  assert_param (IS_PWR_REGULATOR_VOLTAGE (VoltageScaling));

  /* Get the voltage scaling  */
  if ((PWR->CSR1 & PWR_CSR1_ACTVOS) == VoltageScaling)
2400f908:	4b3f      	ldr	r3, [pc, #252]	; (2400fa08 <HAL_PWREx_ControlVoltageScaling+0x108>)
2400f90a:	685b      	ldr	r3, [r3, #4]
2400f90c:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
2400f910:	687a      	ldr	r2, [r7, #4]
2400f912:	429a      	cmp	r2, r3
2400f914:	d101      	bne.n	2400f91a <HAL_PWREx_ControlVoltageScaling+0x1a>
  {
    /* Old and new voltage scaling configuration match : nothing to do */
    return HAL_OK;
2400f916:	2300      	movs	r3, #0
2400f918:	e072      	b.n	2400fa00 <HAL_PWREx_ControlVoltageScaling+0x100>

#if defined (PWR_SRDCR_VOS)
  /* Set the voltage range */
  MODIFY_REG (PWR->SRDCR, PWR_SRDCR_VOS, VoltageScaling);
#else
  if (VoltageScaling == PWR_REGULATOR_VOLTAGE_SCALE0)
2400f91a:	687b      	ldr	r3, [r7, #4]
2400f91c:	2b00      	cmp	r3, #0
2400f91e:	d129      	bne.n	2400f974 <HAL_PWREx_ControlVoltageScaling+0x74>
  {
    if ((PWR->CR3 & PWR_CR3_LDOEN) == PWR_CR3_LDOEN)
2400f920:	4b39      	ldr	r3, [pc, #228]	; (2400fa08 <HAL_PWREx_ControlVoltageScaling+0x108>)
2400f922:	68db      	ldr	r3, [r3, #12]
2400f924:	f003 0302 	and.w	r3, r3, #2
2400f928:	2b02      	cmp	r3, #2
2400f92a:	d121      	bne.n	2400f970 <HAL_PWREx_ControlVoltageScaling+0x70>
    {
      /* Set the voltage range */
      MODIFY_REG (PWR->D3CR, PWR_D3CR_VOS, PWR_REGULATOR_VOLTAGE_SCALE1);
2400f92c:	4b36      	ldr	r3, [pc, #216]	; (2400fa08 <HAL_PWREx_ControlVoltageScaling+0x108>)
2400f92e:	699b      	ldr	r3, [r3, #24]
2400f930:	4a35      	ldr	r2, [pc, #212]	; (2400fa08 <HAL_PWREx_ControlVoltageScaling+0x108>)
2400f932:	f443 4340 	orr.w	r3, r3, #49152	; 0xc000
2400f936:	6193      	str	r3, [r2, #24]

      /* Get tick */
      tickstart = HAL_GetTick ();
2400f938:	f7f0 ff8a 	bl	24000850 <HAL_GetTick>
2400f93c:	60f8      	str	r0, [r7, #12]

      /* Wait till voltage level flag is set */
      while (__HAL_PWR_GET_FLAG (PWR_FLAG_ACTVOSRDY) == 0U)
2400f93e:	e009      	b.n	2400f954 <HAL_PWREx_ControlVoltageScaling+0x54>
      {
        if ((HAL_GetTick () - tickstart) > PWR_FLAG_SETTING_DELAY)
2400f940:	f7f0 ff86 	bl	24000850 <HAL_GetTick>
2400f944:	4602      	mov	r2, r0
2400f946:	68fb      	ldr	r3, [r7, #12]
2400f948:	1ad3      	subs	r3, r2, r3
2400f94a:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
2400f94e:	d901      	bls.n	2400f954 <HAL_PWREx_ControlVoltageScaling+0x54>
        {
          return HAL_ERROR;
2400f950:	2301      	movs	r3, #1
2400f952:	e055      	b.n	2400fa00 <HAL_PWREx_ControlVoltageScaling+0x100>
      while (__HAL_PWR_GET_FLAG (PWR_FLAG_ACTVOSRDY) == 0U)
2400f954:	4b2c      	ldr	r3, [pc, #176]	; (2400fa08 <HAL_PWREx_ControlVoltageScaling+0x108>)
2400f956:	685b      	ldr	r3, [r3, #4]
2400f958:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
2400f95c:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
2400f960:	d1ee      	bne.n	2400f940 <HAL_PWREx_ControlVoltageScaling+0x40>
        }
      }

      /* Enable the PWR overdrive */
      SET_BIT (SYSCFG->PWRCR, SYSCFG_PWRCR_ODEN);
2400f962:	4b2a      	ldr	r3, [pc, #168]	; (2400fa0c <HAL_PWREx_ControlVoltageScaling+0x10c>)
2400f964:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2400f966:	4a29      	ldr	r2, [pc, #164]	; (2400fa0c <HAL_PWREx_ControlVoltageScaling+0x10c>)
2400f968:	f043 0301 	orr.w	r3, r3, #1
2400f96c:	62d3      	str	r3, [r2, #44]	; 0x2c
2400f96e:	e031      	b.n	2400f9d4 <HAL_PWREx_ControlVoltageScaling+0xd4>
    }
    else
    {
      /* The voltage scale 0 is only possible when LDO regulator is enabled */
      return HAL_ERROR;
2400f970:	2301      	movs	r3, #1
2400f972:	e045      	b.n	2400fa00 <HAL_PWREx_ControlVoltageScaling+0x100>
    }
  }
  else
  {
    if ((PWR->CSR1 & PWR_CSR1_ACTVOS) == PWR_REGULATOR_VOLTAGE_SCALE1)
2400f974:	4b24      	ldr	r3, [pc, #144]	; (2400fa08 <HAL_PWREx_ControlVoltageScaling+0x108>)
2400f976:	685b      	ldr	r3, [r3, #4]
2400f978:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
2400f97c:	f5b3 4f40 	cmp.w	r3, #49152	; 0xc000
2400f980:	d120      	bne.n	2400f9c4 <HAL_PWREx_ControlVoltageScaling+0xc4>
    {
      if ((SYSCFG->PWRCR & SYSCFG_PWRCR_ODEN) != 0U)
2400f982:	4b22      	ldr	r3, [pc, #136]	; (2400fa0c <HAL_PWREx_ControlVoltageScaling+0x10c>)
2400f984:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2400f986:	f003 0301 	and.w	r3, r3, #1
2400f98a:	2b00      	cmp	r3, #0
2400f98c:	d01a      	beq.n	2400f9c4 <HAL_PWREx_ControlVoltageScaling+0xc4>
      {
        /* Disable the PWR overdrive */
        CLEAR_BIT(SYSCFG->PWRCR, SYSCFG_PWRCR_ODEN);
2400f98e:	4b1f      	ldr	r3, [pc, #124]	; (2400fa0c <HAL_PWREx_ControlVoltageScaling+0x10c>)
2400f990:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2400f992:	4a1e      	ldr	r2, [pc, #120]	; (2400fa0c <HAL_PWREx_ControlVoltageScaling+0x10c>)
2400f994:	f023 0301 	bic.w	r3, r3, #1
2400f998:	62d3      	str	r3, [r2, #44]	; 0x2c

        /* Get tick */
        tickstart = HAL_GetTick ();
2400f99a:	f7f0 ff59 	bl	24000850 <HAL_GetTick>
2400f99e:	60f8      	str	r0, [r7, #12]

        /* Wait till voltage level flag is set */
        while (__HAL_PWR_GET_FLAG (PWR_FLAG_ACTVOSRDY) == 0U)
2400f9a0:	e009      	b.n	2400f9b6 <HAL_PWREx_ControlVoltageScaling+0xb6>
        {
          if ((HAL_GetTick () - tickstart) > PWR_FLAG_SETTING_DELAY)
2400f9a2:	f7f0 ff55 	bl	24000850 <HAL_GetTick>
2400f9a6:	4602      	mov	r2, r0
2400f9a8:	68fb      	ldr	r3, [r7, #12]
2400f9aa:	1ad3      	subs	r3, r2, r3
2400f9ac:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
2400f9b0:	d901      	bls.n	2400f9b6 <HAL_PWREx_ControlVoltageScaling+0xb6>
          {
            return HAL_ERROR;
2400f9b2:	2301      	movs	r3, #1
2400f9b4:	e024      	b.n	2400fa00 <HAL_PWREx_ControlVoltageScaling+0x100>
        while (__HAL_PWR_GET_FLAG (PWR_FLAG_ACTVOSRDY) == 0U)
2400f9b6:	4b14      	ldr	r3, [pc, #80]	; (2400fa08 <HAL_PWREx_ControlVoltageScaling+0x108>)
2400f9b8:	685b      	ldr	r3, [r3, #4]
2400f9ba:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
2400f9be:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
2400f9c2:	d1ee      	bne.n	2400f9a2 <HAL_PWREx_ControlVoltageScaling+0xa2>
        }
      }
    }

    /* Set the voltage range */
    MODIFY_REG (PWR->D3CR, PWR_D3CR_VOS, VoltageScaling);
2400f9c4:	4b10      	ldr	r3, [pc, #64]	; (2400fa08 <HAL_PWREx_ControlVoltageScaling+0x108>)
2400f9c6:	699b      	ldr	r3, [r3, #24]
2400f9c8:	f423 4240 	bic.w	r2, r3, #49152	; 0xc000
2400f9cc:	490e      	ldr	r1, [pc, #56]	; (2400fa08 <HAL_PWREx_ControlVoltageScaling+0x108>)
2400f9ce:	687b      	ldr	r3, [r7, #4]
2400f9d0:	4313      	orrs	r3, r2
2400f9d2:	618b      	str	r3, [r1, #24]
  }
#endif /* defined (PWR_SRDCR_VOS) */

  /* Get tick */
  tickstart = HAL_GetTick ();
2400f9d4:	f7f0 ff3c 	bl	24000850 <HAL_GetTick>
2400f9d8:	60f8      	str	r0, [r7, #12]

  /* Wait till voltage level flag is set */
  while (__HAL_PWR_GET_FLAG (PWR_FLAG_ACTVOSRDY) == 0U)
2400f9da:	e009      	b.n	2400f9f0 <HAL_PWREx_ControlVoltageScaling+0xf0>
  {
    if ((HAL_GetTick() - tickstart) > PWR_FLAG_SETTING_DELAY)
2400f9dc:	f7f0 ff38 	bl	24000850 <HAL_GetTick>
2400f9e0:	4602      	mov	r2, r0
2400f9e2:	68fb      	ldr	r3, [r7, #12]
2400f9e4:	1ad3      	subs	r3, r2, r3
2400f9e6:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
2400f9ea:	d901      	bls.n	2400f9f0 <HAL_PWREx_ControlVoltageScaling+0xf0>
    {
      return HAL_ERROR;
2400f9ec:	2301      	movs	r3, #1
2400f9ee:	e007      	b.n	2400fa00 <HAL_PWREx_ControlVoltageScaling+0x100>
  while (__HAL_PWR_GET_FLAG (PWR_FLAG_ACTVOSRDY) == 0U)
2400f9f0:	4b05      	ldr	r3, [pc, #20]	; (2400fa08 <HAL_PWREx_ControlVoltageScaling+0x108>)
2400f9f2:	685b      	ldr	r3, [r3, #4]
2400f9f4:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
2400f9f8:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
2400f9fc:	d1ee      	bne.n	2400f9dc <HAL_PWREx_ControlVoltageScaling+0xdc>
    }
  }

  return HAL_OK;
2400f9fe:	2300      	movs	r3, #0
}
2400fa00:	4618      	mov	r0, r3
2400fa02:	3710      	adds	r7, #16
2400fa04:	46bd      	mov	sp, r7
2400fa06:	bd80      	pop	{r7, pc}
2400fa08:	58024800 	.word	0x58024800
2400fa0c:	58000400 	.word	0x58000400

2400fa10 <HAL_PWREx_GetVoltageRange>:
  * @brief Get the main internal regulator output voltage. Reflecting the last
  *        VOS value applied to the PMU.
  * @retval The current applied VOS selection.
  */
uint32_t HAL_PWREx_GetVoltageRange (void)
{
2400fa10:	b480      	push	{r7}
2400fa12:	af00      	add	r7, sp, #0
  /* Get the active voltage scaling */
  return (PWR->CSR1 & PWR_CSR1_ACTVOS);
2400fa14:	4b04      	ldr	r3, [pc, #16]	; (2400fa28 <HAL_PWREx_GetVoltageRange+0x18>)
2400fa16:	685b      	ldr	r3, [r3, #4]
2400fa18:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
}
2400fa1c:	4618      	mov	r0, r3
2400fa1e:	46bd      	mov	sp, r7
2400fa20:	f85d 7b04 	ldr.w	r7, [sp], #4
2400fa24:	4770      	bx	lr
2400fa26:	bf00      	nop
2400fa28:	58024800 	.word	0x58024800

2400fa2c <HAL_PWREx_ControlStopModeVoltageScaling>:
  * @note   The selected SVOS4 and SVOS5 levels add an additional startup delay
  *         when exiting from system Stop mode.
  * @retval HAL Status.
  */
HAL_StatusTypeDef HAL_PWREx_ControlStopModeVoltageScaling (uint32_t VoltageScaling)
{
2400fa2c:	b480      	push	{r7}
2400fa2e:	b083      	sub	sp, #12
2400fa30:	af00      	add	r7, sp, #0
2400fa32:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param (IS_PWR_STOP_MODE_REGULATOR_VOLTAGE (VoltageScaling));

  /* Return the stop mode voltage range */
  MODIFY_REG (PWR->CR1, PWR_CR1_SVOS, VoltageScaling);
2400fa34:	4b07      	ldr	r3, [pc, #28]	; (2400fa54 <HAL_PWREx_ControlStopModeVoltageScaling+0x28>)
2400fa36:	681b      	ldr	r3, [r3, #0]
2400fa38:	f423 4240 	bic.w	r2, r3, #49152	; 0xc000
2400fa3c:	4905      	ldr	r1, [pc, #20]	; (2400fa54 <HAL_PWREx_ControlStopModeVoltageScaling+0x28>)
2400fa3e:	687b      	ldr	r3, [r7, #4]
2400fa40:	4313      	orrs	r3, r2
2400fa42:	600b      	str	r3, [r1, #0]

  return HAL_OK;
2400fa44:	2300      	movs	r3, #0
}
2400fa46:	4618      	mov	r0, r3
2400fa48:	370c      	adds	r7, #12
2400fa4a:	46bd      	mov	sp, r7
2400fa4c:	f85d 7b04 	ldr.w	r7, [sp], #4
2400fa50:	4770      	bx	lr
2400fa52:	bf00      	nop
2400fa54:	58024800 	.word	0x58024800

2400fa58 <HAL_PWREx_GetStopModeVoltageRange>:
/**
  * @brief Get the main internal regulator output voltage in STOP mode.
  * @retval The actual applied VOS selection.
  */
uint32_t HAL_PWREx_GetStopModeVoltageRange (void)
{
2400fa58:	b480      	push	{r7}
2400fa5a:	af00      	add	r7, sp, #0
  /* Return the stop voltage scaling */
  return (PWR->CR1 & PWR_CR1_SVOS);
2400fa5c:	4b04      	ldr	r3, [pc, #16]	; (2400fa70 <HAL_PWREx_GetStopModeVoltageRange+0x18>)
2400fa5e:	681b      	ldr	r3, [r3, #0]
2400fa60:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
}
2400fa64:	4618      	mov	r0, r3
2400fa66:	46bd      	mov	sp, r7
2400fa68:	f85d 7b04 	ldr.w	r7, [sp], #4
2400fa6c:	4770      	bx	lr
2400fa6e:	bf00      	nop
2400fa70:	58024800 	.word	0x58024800

2400fa74 <HAL_PWREx_EnterSTOPMode>:
  *            @arg PWR_D2_DOMAIN : Enter D2 Domain to DSTOP mode.
  *            @arg PWR_D3_DOMAIN : Enter D3/SRD Domain to DSTOP mode.
  * @retval None.
  */
void HAL_PWREx_EnterSTOPMode (uint32_t Regulator, uint8_t STOPEntry, uint32_t Domain)
{
2400fa74:	b480      	push	{r7}
2400fa76:	b085      	sub	sp, #20
2400fa78:	af00      	add	r7, sp, #0
2400fa7a:	60f8      	str	r0, [r7, #12]
2400fa7c:	460b      	mov	r3, r1
2400fa7e:	607a      	str	r2, [r7, #4]
2400fa80:	72fb      	strb	r3, [r7, #11]
  assert_param (IS_PWR_REGULATOR (Regulator));
  assert_param (IS_PWR_STOP_ENTRY (STOPEntry));
  assert_param (IS_PWR_DOMAIN (Domain));

  /* Select the regulator state in Stop mode */
  MODIFY_REG (PWR->CR1, PWR_CR1_LPDS, Regulator);
2400fa82:	4b1f      	ldr	r3, [pc, #124]	; (2400fb00 <HAL_PWREx_EnterSTOPMode+0x8c>)
2400fa84:	681b      	ldr	r3, [r3, #0]
2400fa86:	f023 0201 	bic.w	r2, r3, #1
2400fa8a:	491d      	ldr	r1, [pc, #116]	; (2400fb00 <HAL_PWREx_EnterSTOPMode+0x8c>)
2400fa8c:	68fb      	ldr	r3, [r7, #12]
2400fa8e:	4313      	orrs	r3, r2
2400fa90:	600b      	str	r3, [r1, #0]

  /* Select the domain Power Down DeepSleep */
  if (Domain == PWR_D1_DOMAIN)
2400fa92:	687b      	ldr	r3, [r7, #4]
2400fa94:	2b00      	cmp	r3, #0
2400fa96:	d11c      	bne.n	2400fad2 <HAL_PWREx_EnterSTOPMode+0x5e>
      return;
    }
#endif /* defined (DUAL_CORE) */

    /* Keep DSTOP mode when D1/CD domain enters Deepsleep */
    CLEAR_BIT (PWR->CPUCR, PWR_CPUCR_PDDS_D1);
2400fa98:	4b19      	ldr	r3, [pc, #100]	; (2400fb00 <HAL_PWREx_EnterSTOPMode+0x8c>)
2400fa9a:	691b      	ldr	r3, [r3, #16]
2400fa9c:	4a18      	ldr	r2, [pc, #96]	; (2400fb00 <HAL_PWREx_EnterSTOPMode+0x8c>)
2400fa9e:	f023 0301 	bic.w	r3, r3, #1
2400faa2:	6113      	str	r3, [r2, #16]

    /* Set SLEEPDEEP bit of Cortex System Control Register */
    SET_BIT (SCB->SCR, SCB_SCR_SLEEPDEEP_Msk);
2400faa4:	4b17      	ldr	r3, [pc, #92]	; (2400fb04 <HAL_PWREx_EnterSTOPMode+0x90>)
2400faa6:	691b      	ldr	r3, [r3, #16]
2400faa8:	4a16      	ldr	r2, [pc, #88]	; (2400fb04 <HAL_PWREx_EnterSTOPMode+0x90>)
2400faaa:	f043 0304 	orr.w	r3, r3, #4
2400faae:	6113      	str	r3, [r2, #16]
  __ASM volatile ("dsb 0xF":::"memory");
2400fab0:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
2400fab4:	f3bf 8f6f 	isb	sy
    /* Ensure that all instructions are done before entering STOP mode */
    __DSB ();
    __ISB ();

    /* Select Stop mode entry */
    if (STOPEntry == PWR_STOPENTRY_WFI)
2400fab8:	7afb      	ldrb	r3, [r7, #11]
2400faba:	2b01      	cmp	r3, #1
2400fabc:	d101      	bne.n	2400fac2 <HAL_PWREx_EnterSTOPMode+0x4e>
    {
      /* Request Wait For Interrupt */
      __WFI ();
2400fabe:	bf30      	wfi
2400fac0:	e000      	b.n	2400fac4 <HAL_PWREx_EnterSTOPMode+0x50>
    }
    else
    {
      /* Request Wait For Event */
      __WFE ();
2400fac2:	bf20      	wfe
    }

    /* Clear SLEEPDEEP bit of Cortex-Mx in the System Control Register */
    CLEAR_BIT (SCB->SCR, SCB_SCR_SLEEPDEEP_Msk);
2400fac4:	4b0f      	ldr	r3, [pc, #60]	; (2400fb04 <HAL_PWREx_EnterSTOPMode+0x90>)
2400fac6:	691b      	ldr	r3, [r3, #16]
2400fac8:	4a0e      	ldr	r2, [pc, #56]	; (2400fb04 <HAL_PWREx_EnterSTOPMode+0x90>)
2400faca:	f023 0304 	bic.w	r3, r3, #4
2400face:	6113      	str	r3, [r2, #16]
  else
  {
    /* Keep DSTOP mode when D3/SRD domain enters Deepsleep */
    CLEAR_BIT (PWR->CPUCR, PWR_CPUCR_PDDS_D3);
  }
}
2400fad0:	e00f      	b.n	2400faf2 <HAL_PWREx_EnterSTOPMode+0x7e>
  else if (Domain == PWR_D2_DOMAIN)
2400fad2:	687b      	ldr	r3, [r7, #4]
2400fad4:	2b01      	cmp	r3, #1
2400fad6:	d106      	bne.n	2400fae6 <HAL_PWREx_EnterSTOPMode+0x72>
    CLEAR_BIT (PWR->CPUCR, PWR_CPUCR_PDDS_D2);
2400fad8:	4b09      	ldr	r3, [pc, #36]	; (2400fb00 <HAL_PWREx_EnterSTOPMode+0x8c>)
2400fada:	691b      	ldr	r3, [r3, #16]
2400fadc:	4a08      	ldr	r2, [pc, #32]	; (2400fb00 <HAL_PWREx_EnterSTOPMode+0x8c>)
2400fade:	f023 0302 	bic.w	r3, r3, #2
2400fae2:	6113      	str	r3, [r2, #16]
}
2400fae4:	e005      	b.n	2400faf2 <HAL_PWREx_EnterSTOPMode+0x7e>
    CLEAR_BIT (PWR->CPUCR, PWR_CPUCR_PDDS_D3);
2400fae6:	4b06      	ldr	r3, [pc, #24]	; (2400fb00 <HAL_PWREx_EnterSTOPMode+0x8c>)
2400fae8:	691b      	ldr	r3, [r3, #16]
2400faea:	4a05      	ldr	r2, [pc, #20]	; (2400fb00 <HAL_PWREx_EnterSTOPMode+0x8c>)
2400faec:	f023 0304 	bic.w	r3, r3, #4
2400faf0:	6113      	str	r3, [r2, #16]
}
2400faf2:	bf00      	nop
2400faf4:	3714      	adds	r7, #20
2400faf6:	46bd      	mov	sp, r7
2400faf8:	f85d 7b04 	ldr.w	r7, [sp], #4
2400fafc:	4770      	bx	lr
2400fafe:	bf00      	nop
2400fb00:	58024800 	.word	0x58024800
2400fb04:	e000ed00 	.word	0xe000ed00

2400fb08 <HAL_PWREx_ClearPendingEvent>:
  *         to CSLEEP or CSTOP. It should be called just before APIs performing
  *         enter low power mode using Wait For Event request.
  * @retval None.
  */
void HAL_PWREx_ClearPendingEvent (void)
{
2400fb08:	b480      	push	{r7}
2400fb0a:	af00      	add	r7, sp, #0
  {
    __SEV ();
    __WFE ();
  }
#else
  __WFE ();
2400fb0c:	bf20      	wfe
#endif /* defined (DUAL_CORE) */
}
2400fb0e:	bf00      	nop
2400fb10:	46bd      	mov	sp, r7
2400fb12:	f85d 7b04 	ldr.w	r7, [sp], #4
2400fb16:	4770      	bx	lr

2400fb18 <HAL_PWREx_EnterSTANDBYMode>:
  *            @arg PWR_D2_DOMAIN: Enter D2 Domain to DSTANDBY mode.
  *            @arg PWR_D3_DOMAIN: Enter D3/SRD Domain to DSTANDBY mode.
  * @retval None
  */
void HAL_PWREx_EnterSTANDBYMode (uint32_t Domain)
{
2400fb18:	b480      	push	{r7}
2400fb1a:	b083      	sub	sp, #12
2400fb1c:	af00      	add	r7, sp, #0
2400fb1e:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param (IS_PWR_DOMAIN (Domain));

  /* Select the domain Power Down DeepSleep */
  if (Domain == PWR_D1_DOMAIN)
2400fb20:	687b      	ldr	r3, [r7, #4]
2400fb22:	2b00      	cmp	r3, #0
2400fb24:	d10d      	bne.n	2400fb42 <HAL_PWREx_EnterSTANDBYMode+0x2a>
      return;
    }
#endif /* defined (DUAL_CORE) */

    /* Allow DSTANDBY mode when D1/CD domain enters Deepsleep */
    SET_BIT (PWR-> CPUCR, PWR_CPUCR_PDDS_D1);
2400fb26:	4b12      	ldr	r3, [pc, #72]	; (2400fb70 <HAL_PWREx_EnterSTANDBYMode+0x58>)
2400fb28:	691b      	ldr	r3, [r3, #16]
2400fb2a:	4a11      	ldr	r2, [pc, #68]	; (2400fb70 <HAL_PWREx_EnterSTANDBYMode+0x58>)
2400fb2c:	f043 0301 	orr.w	r3, r3, #1
2400fb30:	6113      	str	r3, [r2, #16]
    /* Allow DSTANDBY mode when D1/CD domain enters Deepsleep */
    SET_BIT (PWR-> CPU2CR, PWR_CPU2CR_PDDS_D1);
#endif /*DUAL_CORE*/

    /* Set SLEEPDEEP bit of Cortex System Control Register */
    SET_BIT (SCB->SCR, SCB_SCR_SLEEPDEEP_Msk);
2400fb32:	4b10      	ldr	r3, [pc, #64]	; (2400fb74 <HAL_PWREx_EnterSTANDBYMode+0x5c>)
2400fb34:	691b      	ldr	r3, [r3, #16]
2400fb36:	4a0f      	ldr	r2, [pc, #60]	; (2400fb74 <HAL_PWREx_EnterSTANDBYMode+0x5c>)
2400fb38:	f043 0304 	orr.w	r3, r3, #4
2400fb3c:	6113      	str	r3, [r2, #16]
#if defined (__CC_ARM)
    __force_stores ();
#endif /* defined (__CC_ARM) */

    /* Request Wait For Interrupt */
    __WFI ();
2400fb3e:	bf30      	wfi
#if defined (DUAL_CORE)
    /* Allow DSTANDBY mode when D3/SRD domain enters Deepsleep */
    SET_BIT (PWR-> CPU2CR, PWR_CPU2CR_PDDS_D3);
#endif /* defined (DUAL_CORE) */
  }
}
2400fb40:	e00f      	b.n	2400fb62 <HAL_PWREx_EnterSTANDBYMode+0x4a>
  else if (Domain == PWR_D2_DOMAIN)
2400fb42:	687b      	ldr	r3, [r7, #4]
2400fb44:	2b01      	cmp	r3, #1
2400fb46:	d106      	bne.n	2400fb56 <HAL_PWREx_EnterSTANDBYMode+0x3e>
    SET_BIT (PWR-> CPUCR, PWR_CPUCR_PDDS_D2);
2400fb48:	4b09      	ldr	r3, [pc, #36]	; (2400fb70 <HAL_PWREx_EnterSTANDBYMode+0x58>)
2400fb4a:	691b      	ldr	r3, [r3, #16]
2400fb4c:	4a08      	ldr	r2, [pc, #32]	; (2400fb70 <HAL_PWREx_EnterSTANDBYMode+0x58>)
2400fb4e:	f043 0302 	orr.w	r3, r3, #2
2400fb52:	6113      	str	r3, [r2, #16]
}
2400fb54:	e005      	b.n	2400fb62 <HAL_PWREx_EnterSTANDBYMode+0x4a>
    SET_BIT (PWR-> CPUCR, PWR_CPUCR_PDDS_D3);
2400fb56:	4b06      	ldr	r3, [pc, #24]	; (2400fb70 <HAL_PWREx_EnterSTANDBYMode+0x58>)
2400fb58:	691b      	ldr	r3, [r3, #16]
2400fb5a:	4a05      	ldr	r2, [pc, #20]	; (2400fb70 <HAL_PWREx_EnterSTANDBYMode+0x58>)
2400fb5c:	f043 0304 	orr.w	r3, r3, #4
2400fb60:	6113      	str	r3, [r2, #16]
}
2400fb62:	bf00      	nop
2400fb64:	370c      	adds	r7, #12
2400fb66:	46bd      	mov	sp, r7
2400fb68:	f85d 7b04 	ldr.w	r7, [sp], #4
2400fb6c:	4770      	bx	lr
2400fb6e:	bf00      	nop
2400fb70:	58024800 	.word	0x58024800
2400fb74:	e000ed00 	.word	0xe000ed00

2400fb78 <HAL_PWREx_ConfigD3Domain>:
  *                                     regardless of the CPU sub-system low
  *                                     power mode.
  * @retval None
  */
void HAL_PWREx_ConfigD3Domain (uint32_t D3State)
{
2400fb78:	b480      	push	{r7}
2400fb7a:	b083      	sub	sp, #12
2400fb7c:	af00      	add	r7, sp, #0
2400fb7e:	6078      	str	r0, [r7, #4]
  /* Check the parameter */
  assert_param (IS_D3_STATE (D3State));

  /* Keep D3/SRD in run mode */
  MODIFY_REG (PWR->CPUCR, PWR_CPUCR_RUN_D3, D3State);
2400fb80:	4b06      	ldr	r3, [pc, #24]	; (2400fb9c <HAL_PWREx_ConfigD3Domain+0x24>)
2400fb82:	691b      	ldr	r3, [r3, #16]
2400fb84:	f423 6200 	bic.w	r2, r3, #2048	; 0x800
2400fb88:	4904      	ldr	r1, [pc, #16]	; (2400fb9c <HAL_PWREx_ConfigD3Domain+0x24>)
2400fb8a:	687b      	ldr	r3, [r7, #4]
2400fb8c:	4313      	orrs	r3, r2
2400fb8e:	610b      	str	r3, [r1, #16]
}
2400fb90:	bf00      	nop
2400fb92:	370c      	adds	r7, #12
2400fb94:	46bd      	mov	sp, r7
2400fb96:	f85d 7b04 	ldr.w	r7, [sp], #4
2400fb9a:	4770      	bx	lr
2400fb9c:	58024800 	.word	0x58024800

2400fba0 <HAL_PWREx_EnableFlashPowerDown>:
  *         obtain the best trade-off between low-power consumption and restart
  *         time when exiting from DStop mode.
  * @retval None.
  */
void HAL_PWREx_EnableFlashPowerDown (void)
{
2400fba0:	b480      	push	{r7}
2400fba2:	af00      	add	r7, sp, #0
  /* Enable the Flash Power Down */
  SET_BIT (PWR->CR1, PWR_CR1_FLPS);
2400fba4:	4b05      	ldr	r3, [pc, #20]	; (2400fbbc <HAL_PWREx_EnableFlashPowerDown+0x1c>)
2400fba6:	681b      	ldr	r3, [r3, #0]
2400fba8:	4a04      	ldr	r2, [pc, #16]	; (2400fbbc <HAL_PWREx_EnableFlashPowerDown+0x1c>)
2400fbaa:	f443 7300 	orr.w	r3, r3, #512	; 0x200
2400fbae:	6013      	str	r3, [r2, #0]
}
2400fbb0:	bf00      	nop
2400fbb2:	46bd      	mov	sp, r7
2400fbb4:	f85d 7b04 	ldr.w	r7, [sp], #4
2400fbb8:	4770      	bx	lr
2400fbba:	bf00      	nop
2400fbbc:	58024800 	.word	0x58024800

2400fbc0 <HAL_PWREx_DisableFlashPowerDown>:
  *         to obtain the best trade-off between low-power consumption and
  *         restart time when exiting from DStop mode.
  * @retval None.
  */
void HAL_PWREx_DisableFlashPowerDown (void)
{
2400fbc0:	b480      	push	{r7}
2400fbc2:	af00      	add	r7, sp, #0
  /* Disable the Flash Power Down */
  CLEAR_BIT (PWR->CR1, PWR_CR1_FLPS);
2400fbc4:	4b05      	ldr	r3, [pc, #20]	; (2400fbdc <HAL_PWREx_DisableFlashPowerDown+0x1c>)
2400fbc6:	681b      	ldr	r3, [r3, #0]
2400fbc8:	4a04      	ldr	r2, [pc, #16]	; (2400fbdc <HAL_PWREx_DisableFlashPowerDown+0x1c>)
2400fbca:	f423 7300 	bic.w	r3, r3, #512	; 0x200
2400fbce:	6013      	str	r3, [r2, #0]
}
2400fbd0:	bf00      	nop
2400fbd2:	46bd      	mov	sp, r7
2400fbd4:	f85d 7b04 	ldr.w	r7, [sp], #4
2400fbd8:	4770      	bx	lr
2400fbda:	bf00      	nop
2400fbdc:	58024800 	.word	0x58024800

2400fbe0 <HAL_PWREx_EnableWakeUpPin>:
  *         Cortex-M7, wake up only Cortex-M4 and wake up Cortex-M7 and
  *         Cortex-M4.
  * @retval None.
  */
void HAL_PWREx_EnableWakeUpPin (PWREx_WakeupPinTypeDef *sPinParams)
{
2400fbe0:	b480      	push	{r7}
2400fbe2:	b08f      	sub	sp, #60	; 0x3c
2400fbe4:	af00      	add	r7, sp, #0
2400fbe6:	6078      	str	r0, [r7, #4]
  uint32_t pinConfig;
  uint32_t regMask;
  const uint32_t pullMask = PWR_WKUPEPR_WKUPPUPD1;
2400fbe8:	f44f 3340 	mov.w	r3, #196608	; 0x30000
2400fbec:	637b      	str	r3, [r7, #52]	; 0x34
  /* Check the parameters */
  assert_param (IS_PWR_WAKEUP_PIN (sPinParams->WakeUpPin));
  assert_param (IS_PWR_WAKEUP_PIN_POLARITY (sPinParams->PinPolarity));
  assert_param (IS_PWR_WAKEUP_PIN_PULL (sPinParams->PinPull));

  pinConfig = sPinParams->WakeUpPin | \
2400fbee:	687b      	ldr	r3, [r7, #4]
2400fbf0:	681a      	ldr	r2, [r3, #0]
              (sPinParams->PinPolarity << ((POSITION_VAL(sPinParams->WakeUpPin) + PWR_WKUPEPR_WKUPP1_Pos) & 0x1FU)) | \
2400fbf2:	687b      	ldr	r3, [r7, #4]
2400fbf4:	6859      	ldr	r1, [r3, #4]
2400fbf6:	687b      	ldr	r3, [r7, #4]
2400fbf8:	681b      	ldr	r3, [r3, #0]
2400fbfa:	613b      	str	r3, [r7, #16]
  uint32_t result;

#if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
     (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
     (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
2400fbfc:	693b      	ldr	r3, [r7, #16]
2400fbfe:	fa93 f3a3 	rbit	r3, r3
2400fc02:	60fb      	str	r3, [r7, #12]
    result |= value & 1U;
    s--;
  }
  result <<= s;                        /* shift when v's highest bits are zero */
#endif
  return result;
2400fc04:	68fb      	ldr	r3, [r7, #12]
2400fc06:	fab3 f383 	clz	r3, r3
2400fc0a:	b2db      	uxtb	r3, r3
2400fc0c:	3308      	adds	r3, #8
2400fc0e:	f003 031f 	and.w	r3, r3, #31
2400fc12:	fa01 f303 	lsl.w	r3, r1, r3
  pinConfig = sPinParams->WakeUpPin | \
2400fc16:	431a      	orrs	r2, r3
              (sPinParams->PinPull << (((POSITION_VAL(sPinParams->WakeUpPin) * PWR_WAKEUP_PINS_PULL_SHIFT_OFFSET) + PWR_WKUPEPR_WKUPPUPD1_Pos) & 0x1FU));
2400fc18:	687b      	ldr	r3, [r7, #4]
2400fc1a:	6899      	ldr	r1, [r3, #8]
2400fc1c:	687b      	ldr	r3, [r7, #4]
2400fc1e:	681b      	ldr	r3, [r3, #0]
2400fc20:	61bb      	str	r3, [r7, #24]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
2400fc22:	69bb      	ldr	r3, [r7, #24]
2400fc24:	fa93 f3a3 	rbit	r3, r3
2400fc28:	617b      	str	r3, [r7, #20]
  return result;
2400fc2a:	697b      	ldr	r3, [r7, #20]
2400fc2c:	fab3 f383 	clz	r3, r3
2400fc30:	b2db      	uxtb	r3, r3
2400fc32:	3308      	adds	r3, #8
2400fc34:	005b      	lsls	r3, r3, #1
2400fc36:	f003 031e 	and.w	r3, r3, #30
2400fc3a:	fa01 f303 	lsl.w	r3, r1, r3
  pinConfig = sPinParams->WakeUpPin | \
2400fc3e:	4313      	orrs	r3, r2
2400fc40:	633b      	str	r3, [r7, #48]	; 0x30

  regMask   = sPinParams->WakeUpPin | \
2400fc42:	687b      	ldr	r3, [r7, #4]
2400fc44:	681a      	ldr	r2, [r3, #0]
              (PWR_WKUPEPR_WKUPP1 << (POSITION_VAL(sPinParams->WakeUpPin) & 0x1FU)) | \
2400fc46:	687b      	ldr	r3, [r7, #4]
2400fc48:	681b      	ldr	r3, [r3, #0]
2400fc4a:	623b      	str	r3, [r7, #32]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
2400fc4c:	6a3b      	ldr	r3, [r7, #32]
2400fc4e:	fa93 f3a3 	rbit	r3, r3
2400fc52:	61fb      	str	r3, [r7, #28]
  return result;
2400fc54:	69fb      	ldr	r3, [r7, #28]
2400fc56:	fab3 f383 	clz	r3, r3
2400fc5a:	b2db      	uxtb	r3, r3
2400fc5c:	f003 031f 	and.w	r3, r3, #31
2400fc60:	f44f 7180 	mov.w	r1, #256	; 0x100
2400fc64:	fa01 f303 	lsl.w	r3, r1, r3
  regMask   = sPinParams->WakeUpPin | \
2400fc68:	431a      	orrs	r2, r3
              (pullMask << ((POSITION_VAL(sPinParams->WakeUpPin) * PWR_WAKEUP_PINS_PULL_SHIFT_OFFSET) & 0x1FU));
2400fc6a:	687b      	ldr	r3, [r7, #4]
2400fc6c:	681b      	ldr	r3, [r3, #0]
2400fc6e:	62bb      	str	r3, [r7, #40]	; 0x28
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
2400fc70:	6abb      	ldr	r3, [r7, #40]	; 0x28
2400fc72:	fa93 f3a3 	rbit	r3, r3
2400fc76:	627b      	str	r3, [r7, #36]	; 0x24
  return result;
2400fc78:	6a7b      	ldr	r3, [r7, #36]	; 0x24
2400fc7a:	fab3 f383 	clz	r3, r3
2400fc7e:	b2db      	uxtb	r3, r3
2400fc80:	005b      	lsls	r3, r3, #1
2400fc82:	f003 031e 	and.w	r3, r3, #30
2400fc86:	6b79      	ldr	r1, [r7, #52]	; 0x34
2400fc88:	fa01 f303 	lsl.w	r3, r1, r3
  regMask   = sPinParams->WakeUpPin | \
2400fc8c:	4313      	orrs	r3, r2
2400fc8e:	62fb      	str	r3, [r7, #44]	; 0x2c

  /* Enable and Specify the Wake-Up pin polarity and the pull configuration
     for the event detection (rising or falling edge) */
  MODIFY_REG (PWR->WKUPEPR, regMask, pinConfig);
2400fc90:	4b0e      	ldr	r3, [pc, #56]	; (2400fccc <HAL_PWREx_EnableWakeUpPin+0xec>)
2400fc92:	6a9a      	ldr	r2, [r3, #40]	; 0x28
2400fc94:	6afb      	ldr	r3, [r7, #44]	; 0x2c
2400fc96:	43db      	mvns	r3, r3
2400fc98:	401a      	ands	r2, r3
2400fc9a:	490c      	ldr	r1, [pc, #48]	; (2400fccc <HAL_PWREx_EnableWakeUpPin+0xec>)
2400fc9c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
2400fc9e:	4313      	orrs	r3, r2
2400fca0:	628b      	str	r3, [r1, #40]	; 0x28
#ifndef DUAL_CORE
  /* Configure the Wakeup Pin EXTI Line */
  MODIFY_REG (EXTI->IMR2, PWR_EXTI_WAKEUP_PINS_MASK, (sPinParams->WakeUpPin << EXTI_IMR2_IM55_Pos));
2400fca2:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
2400fca6:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
2400fcaa:	f023 52fc 	bic.w	r2, r3, #528482304	; 0x1f800000
2400fcae:	687b      	ldr	r3, [r7, #4]
2400fcb0:	681b      	ldr	r3, [r3, #0]
2400fcb2:	05db      	lsls	r3, r3, #23
2400fcb4:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
2400fcb8:	4313      	orrs	r3, r2
2400fcba:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
#endif /* !DUAL_CORE */
}
2400fcbe:	bf00      	nop
2400fcc0:	373c      	adds	r7, #60	; 0x3c
2400fcc2:	46bd      	mov	sp, r7
2400fcc4:	f85d 7b04 	ldr.w	r7, [sp], #4
2400fcc8:	4770      	bx	lr
2400fcca:	bf00      	nop
2400fccc:	58024800 	.word	0x58024800

2400fcd0 <HAL_PWREx_DisableWakeUpPin>:
  *           @arg PWR_WAKEUP_PIN5 : Disable PI11 wake-up PIN.
  *           @arg PWR_WAKEUP_PIN6 : Disable PC1  wake-up PIN.
  * @retval None
  */
void HAL_PWREx_DisableWakeUpPin (uint32_t WakeUpPin)
{
2400fcd0:	b480      	push	{r7}
2400fcd2:	b083      	sub	sp, #12
2400fcd4:	af00      	add	r7, sp, #0
2400fcd6:	6078      	str	r0, [r7, #4]
  /* Check the parameter */
  assert_param (IS_PWR_WAKEUP_PIN (WakeUpPin));

  /* Disable the WakeUpPin */
  CLEAR_BIT (PWR->WKUPEPR, WakeUpPin);
2400fcd8:	4b06      	ldr	r3, [pc, #24]	; (2400fcf4 <HAL_PWREx_DisableWakeUpPin+0x24>)
2400fcda:	6a9a      	ldr	r2, [r3, #40]	; 0x28
2400fcdc:	687b      	ldr	r3, [r7, #4]
2400fcde:	43db      	mvns	r3, r3
2400fce0:	4904      	ldr	r1, [pc, #16]	; (2400fcf4 <HAL_PWREx_DisableWakeUpPin+0x24>)
2400fce2:	4013      	ands	r3, r2
2400fce4:	628b      	str	r3, [r1, #40]	; 0x28
}
2400fce6:	bf00      	nop
2400fce8:	370c      	adds	r7, #12
2400fcea:	46bd      	mov	sp, r7
2400fcec:	f85d 7b04 	ldr.w	r7, [sp], #4
2400fcf0:	4770      	bx	lr
2400fcf2:	bf00      	nop
2400fcf4:	58024800 	.word	0x58024800

2400fcf8 <HAL_PWREx_GetWakeupFlag>:
  *            @arg PWR_WAKEUP_FLAG_ALL : Get Wakeup event received from all
  *                                      wake up pins.
  * @retval The Wake-Up pin flag.
  */
uint32_t HAL_PWREx_GetWakeupFlag (uint32_t WakeUpFlag)
{
2400fcf8:	b480      	push	{r7}
2400fcfa:	b083      	sub	sp, #12
2400fcfc:	af00      	add	r7, sp, #0
2400fcfe:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param (IS_PWR_WAKEUP_FLAG (WakeUpFlag));

  /* Return the wake up pin flag */
  return (PWR->WKUPFR & WakeUpFlag);
2400fd00:	4b04      	ldr	r3, [pc, #16]	; (2400fd14 <HAL_PWREx_GetWakeupFlag+0x1c>)
2400fd02:	6a5a      	ldr	r2, [r3, #36]	; 0x24
2400fd04:	687b      	ldr	r3, [r7, #4]
2400fd06:	4013      	ands	r3, r2
}
2400fd08:	4618      	mov	r0, r3
2400fd0a:	370c      	adds	r7, #12
2400fd0c:	46bd      	mov	sp, r7
2400fd0e:	f85d 7b04 	ldr.w	r7, [sp], #4
2400fd12:	4770      	bx	lr
2400fd14:	58024800 	.word	0x58024800

2400fd18 <HAL_PWREx_ClearWakeupFlag>:
  *            @arg PWR_WAKEUP_FLAG_ALL : Clear the wakeup events received from
  *                                      all wake up pins.
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_PWREx_ClearWakeupFlag (uint32_t WakeUpFlag)
{
2400fd18:	b480      	push	{r7}
2400fd1a:	b083      	sub	sp, #12
2400fd1c:	af00      	add	r7, sp, #0
2400fd1e:	6078      	str	r0, [r7, #4]
  /* Check the parameter */
  assert_param (IS_PWR_WAKEUP_FLAG (WakeUpFlag));

  /* Clear the wake up event received from wake up pin x */
  SET_BIT (PWR->WKUPCR, WakeUpFlag);
2400fd20:	4b0a      	ldr	r3, [pc, #40]	; (2400fd4c <HAL_PWREx_ClearWakeupFlag+0x34>)
2400fd22:	6a1a      	ldr	r2, [r3, #32]
2400fd24:	4909      	ldr	r1, [pc, #36]	; (2400fd4c <HAL_PWREx_ClearWakeupFlag+0x34>)
2400fd26:	687b      	ldr	r3, [r7, #4]
2400fd28:	4313      	orrs	r3, r2
2400fd2a:	620b      	str	r3, [r1, #32]

  /* Check if the wake up event is well cleared */
  if ((PWR->WKUPFR & WakeUpFlag) != 0U)
2400fd2c:	4b07      	ldr	r3, [pc, #28]	; (2400fd4c <HAL_PWREx_ClearWakeupFlag+0x34>)
2400fd2e:	6a5a      	ldr	r2, [r3, #36]	; 0x24
2400fd30:	687b      	ldr	r3, [r7, #4]
2400fd32:	4013      	ands	r3, r2
2400fd34:	2b00      	cmp	r3, #0
2400fd36:	d001      	beq.n	2400fd3c <HAL_PWREx_ClearWakeupFlag+0x24>
  {
    return HAL_ERROR;
2400fd38:	2301      	movs	r3, #1
2400fd3a:	e000      	b.n	2400fd3e <HAL_PWREx_ClearWakeupFlag+0x26>
  }

  return HAL_OK;
2400fd3c:	2300      	movs	r3, #0
}
2400fd3e:	4618      	mov	r0, r3
2400fd40:	370c      	adds	r7, #12
2400fd42:	46bd      	mov	sp, r7
2400fd44:	f85d 7b04 	ldr.w	r7, [sp], #4
2400fd48:	4770      	bx	lr
2400fd4a:	bf00      	nop
2400fd4c:	58024800 	.word	0x58024800

2400fd50 <HAL_PWREx_WAKEUP_PIN_IRQHandler>:
  * @brief This function handles the PWR WAKEUP PIN interrupt request.
  * @note   This API should be called under the WAKEUP_PIN_IRQHandler().
  * @retval None.
  */
void HAL_PWREx_WAKEUP_PIN_IRQHandler (void)
{
2400fd50:	b580      	push	{r7, lr}
2400fd52:	af00      	add	r7, sp, #0
  /* Wakeup pin EXTI line interrupt detected */
  if (READ_BIT(PWR->WKUPFR, PWR_WKUPFR_WKUPF1) != 0U)
2400fd54:	4b2a      	ldr	r3, [pc, #168]	; (2400fe00 <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xb0>)
2400fd56:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400fd58:	f003 0301 	and.w	r3, r3, #1
2400fd5c:	2b00      	cmp	r3, #0
2400fd5e:	d008      	beq.n	2400fd72 <HAL_PWREx_WAKEUP_PIN_IRQHandler+0x22>
  {
    /* Clear PWR WKUPF1 flag */
    __HAL_PWR_CLEAR_WAKEUPFLAG (PWR_FLAG_WKUP1);
2400fd60:	4b27      	ldr	r3, [pc, #156]	; (2400fe00 <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xb0>)
2400fd62:	6a1b      	ldr	r3, [r3, #32]
2400fd64:	4a26      	ldr	r2, [pc, #152]	; (2400fe00 <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xb0>)
2400fd66:	f043 0301 	orr.w	r3, r3, #1
2400fd6a:	6213      	str	r3, [r2, #32]

    /* PWR WKUP1 interrupt user callback */
    HAL_PWREx_WKUP1_Callback ();
2400fd6c:	f000 f84a 	bl	2400fe04 <HAL_PWREx_WKUP1_Callback>
    __HAL_PWR_CLEAR_WAKEUPFLAG (PWR_FLAG_WKUP6);

    /* PWR WKUP6 interrupt user callback */
    HAL_PWREx_WKUP6_Callback ();
  }
}
2400fd70:	e043      	b.n	2400fdfa <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xaa>
  else if (READ_BIT (PWR->WKUPFR, PWR_WKUPFR_WKUPF2) != 0U)
2400fd72:	4b23      	ldr	r3, [pc, #140]	; (2400fe00 <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xb0>)
2400fd74:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400fd76:	f003 0302 	and.w	r3, r3, #2
2400fd7a:	2b00      	cmp	r3, #0
2400fd7c:	d008      	beq.n	2400fd90 <HAL_PWREx_WAKEUP_PIN_IRQHandler+0x40>
    __HAL_PWR_CLEAR_WAKEUPFLAG (PWR_FLAG_WKUP2);
2400fd7e:	4b20      	ldr	r3, [pc, #128]	; (2400fe00 <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xb0>)
2400fd80:	6a1b      	ldr	r3, [r3, #32]
2400fd82:	4a1f      	ldr	r2, [pc, #124]	; (2400fe00 <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xb0>)
2400fd84:	f043 0302 	orr.w	r3, r3, #2
2400fd88:	6213      	str	r3, [r2, #32]
    HAL_PWREx_WKUP2_Callback ();
2400fd8a:	f000 f842 	bl	2400fe12 <HAL_PWREx_WKUP2_Callback>
}
2400fd8e:	e034      	b.n	2400fdfa <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xaa>
  else if (READ_BIT (PWR->WKUPFR, PWR_WKUPFR_WKUPF3) != 0U)
2400fd90:	4b1b      	ldr	r3, [pc, #108]	; (2400fe00 <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xb0>)
2400fd92:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400fd94:	f003 0304 	and.w	r3, r3, #4
2400fd98:	2b00      	cmp	r3, #0
2400fd9a:	d008      	beq.n	2400fdae <HAL_PWREx_WAKEUP_PIN_IRQHandler+0x5e>
    __HAL_PWR_CLEAR_WAKEUPFLAG (PWR_FLAG_WKUP3);
2400fd9c:	4b18      	ldr	r3, [pc, #96]	; (2400fe00 <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xb0>)
2400fd9e:	6a1b      	ldr	r3, [r3, #32]
2400fda0:	4a17      	ldr	r2, [pc, #92]	; (2400fe00 <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xb0>)
2400fda2:	f043 0304 	orr.w	r3, r3, #4
2400fda6:	6213      	str	r3, [r2, #32]
    HAL_PWREx_WKUP3_Callback ();
2400fda8:	f000 f83a 	bl	2400fe20 <HAL_PWREx_WKUP3_Callback>
}
2400fdac:	e025      	b.n	2400fdfa <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xaa>
  else if (READ_BIT (PWR->WKUPFR, PWR_WKUPFR_WKUPF4) != 0U)
2400fdae:	4b14      	ldr	r3, [pc, #80]	; (2400fe00 <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xb0>)
2400fdb0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400fdb2:	f003 0308 	and.w	r3, r3, #8
2400fdb6:	2b00      	cmp	r3, #0
2400fdb8:	d008      	beq.n	2400fdcc <HAL_PWREx_WAKEUP_PIN_IRQHandler+0x7c>
    __HAL_PWR_CLEAR_WAKEUPFLAG (PWR_FLAG_WKUP4);
2400fdba:	4b11      	ldr	r3, [pc, #68]	; (2400fe00 <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xb0>)
2400fdbc:	6a1b      	ldr	r3, [r3, #32]
2400fdbe:	4a10      	ldr	r2, [pc, #64]	; (2400fe00 <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xb0>)
2400fdc0:	f043 0308 	orr.w	r3, r3, #8
2400fdc4:	6213      	str	r3, [r2, #32]
    HAL_PWREx_WKUP4_Callback ();
2400fdc6:	f000 f832 	bl	2400fe2e <HAL_PWREx_WKUP4_Callback>
}
2400fdca:	e016      	b.n	2400fdfa <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xaa>
  else if (READ_BIT (PWR->WKUPFR, PWR_WKUPFR_WKUPF5) != 0U)
2400fdcc:	4b0c      	ldr	r3, [pc, #48]	; (2400fe00 <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xb0>)
2400fdce:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400fdd0:	f003 0310 	and.w	r3, r3, #16
2400fdd4:	2b00      	cmp	r3, #0
2400fdd6:	d008      	beq.n	2400fdea <HAL_PWREx_WAKEUP_PIN_IRQHandler+0x9a>
    __HAL_PWR_CLEAR_WAKEUPFLAG (PWR_FLAG_WKUP5);
2400fdd8:	4b09      	ldr	r3, [pc, #36]	; (2400fe00 <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xb0>)
2400fdda:	6a1b      	ldr	r3, [r3, #32]
2400fddc:	4a08      	ldr	r2, [pc, #32]	; (2400fe00 <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xb0>)
2400fdde:	f043 0310 	orr.w	r3, r3, #16
2400fde2:	6213      	str	r3, [r2, #32]
    HAL_PWREx_WKUP5_Callback ();
2400fde4:	f000 f82a 	bl	2400fe3c <HAL_PWREx_WKUP5_Callback>
}
2400fde8:	e007      	b.n	2400fdfa <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xaa>
    __HAL_PWR_CLEAR_WAKEUPFLAG (PWR_FLAG_WKUP6);
2400fdea:	4b05      	ldr	r3, [pc, #20]	; (2400fe00 <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xb0>)
2400fdec:	6a1b      	ldr	r3, [r3, #32]
2400fdee:	4a04      	ldr	r2, [pc, #16]	; (2400fe00 <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xb0>)
2400fdf0:	f043 0320 	orr.w	r3, r3, #32
2400fdf4:	6213      	str	r3, [r2, #32]
    HAL_PWREx_WKUP6_Callback ();
2400fdf6:	f000 f828 	bl	2400fe4a <HAL_PWREx_WKUP6_Callback>
}
2400fdfa:	bf00      	nop
2400fdfc:	bd80      	pop	{r7, pc}
2400fdfe:	bf00      	nop
2400fe00:	58024800 	.word	0x58024800

2400fe04 <HAL_PWREx_WKUP1_Callback>:
/**
  * @brief PWR WKUP1 interrupt callback.
  * @retval None.
  */
__weak void HAL_PWREx_WKUP1_Callback (void)
{
2400fe04:	b480      	push	{r7}
2400fe06:	af00      	add	r7, sp, #0
  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_PWREx_WKUP1Callback can be implemented in the user file
  */
}
2400fe08:	bf00      	nop
2400fe0a:	46bd      	mov	sp, r7
2400fe0c:	f85d 7b04 	ldr.w	r7, [sp], #4
2400fe10:	4770      	bx	lr

2400fe12 <HAL_PWREx_WKUP2_Callback>:
/**
  * @brief PWR WKUP2 interrupt callback.
  * @retval None.
  */
__weak void HAL_PWREx_WKUP2_Callback (void)
{
2400fe12:	b480      	push	{r7}
2400fe14:	af00      	add	r7, sp, #0
  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_PWREx_WKUP2Callback can be implemented in the user file
  */
}
2400fe16:	bf00      	nop
2400fe18:	46bd      	mov	sp, r7
2400fe1a:	f85d 7b04 	ldr.w	r7, [sp], #4
2400fe1e:	4770      	bx	lr

2400fe20 <HAL_PWREx_WKUP3_Callback>:
/**
  * @brief PWR WKUP3 interrupt callback.
  * @retval None.
  */
__weak void HAL_PWREx_WKUP3_Callback (void)
{
2400fe20:	b480      	push	{r7}
2400fe22:	af00      	add	r7, sp, #0
  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_PWREx_WKUP3Callback can be implemented in the user file
  */
}
2400fe24:	bf00      	nop
2400fe26:	46bd      	mov	sp, r7
2400fe28:	f85d 7b04 	ldr.w	r7, [sp], #4
2400fe2c:	4770      	bx	lr

2400fe2e <HAL_PWREx_WKUP4_Callback>:
/**
  * @brief PWR WKUP4 interrupt callback.
  * @retval None.
  */
__weak void HAL_PWREx_WKUP4_Callback (void)
{
2400fe2e:	b480      	push	{r7}
2400fe30:	af00      	add	r7, sp, #0
  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_PWREx_WKUP4Callback can be implemented in the user file
  */
}
2400fe32:	bf00      	nop
2400fe34:	46bd      	mov	sp, r7
2400fe36:	f85d 7b04 	ldr.w	r7, [sp], #4
2400fe3a:	4770      	bx	lr

2400fe3c <HAL_PWREx_WKUP5_Callback>:
/**
  * @brief PWR WKUP5 interrupt callback.
  * @retval None.
  */
__weak void HAL_PWREx_WKUP5_Callback (void)
{
2400fe3c:	b480      	push	{r7}
2400fe3e:	af00      	add	r7, sp, #0
  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_PWREx_WKUP5Callback can be implemented in the user file
  */
}
2400fe40:	bf00      	nop
2400fe42:	46bd      	mov	sp, r7
2400fe44:	f85d 7b04 	ldr.w	r7, [sp], #4
2400fe48:	4770      	bx	lr

2400fe4a <HAL_PWREx_WKUP6_Callback>:
/**
  * @brief PWR WKUP6 interrupt callback.
  * @retval None.
  */
__weak void HAL_PWREx_WKUP6_Callback (void)
{
2400fe4a:	b480      	push	{r7}
2400fe4c:	af00      	add	r7, sp, #0
  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_PWREx_WKUP6Callback can be implemented in the user file
  */
}
2400fe4e:	bf00      	nop
2400fe50:	46bd      	mov	sp, r7
2400fe52:	f85d 7b04 	ldr.w	r7, [sp], #4
2400fe56:	4770      	bx	lr

2400fe58 <HAL_PWREx_EnableBkUpReg>:
/**
  * @brief Enable the Backup Regulator.
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_PWREx_EnableBkUpReg (void)
{
2400fe58:	b580      	push	{r7, lr}
2400fe5a:	b082      	sub	sp, #8
2400fe5c:	af00      	add	r7, sp, #0
  uint32_t tickstart;

  /* Enable the Backup regulator */
  SET_BIT (PWR->CR2, PWR_CR2_BREN);
2400fe5e:	4b10      	ldr	r3, [pc, #64]	; (2400fea0 <HAL_PWREx_EnableBkUpReg+0x48>)
2400fe60:	689b      	ldr	r3, [r3, #8]
2400fe62:	4a0f      	ldr	r2, [pc, #60]	; (2400fea0 <HAL_PWREx_EnableBkUpReg+0x48>)
2400fe64:	f043 0301 	orr.w	r3, r3, #1
2400fe68:	6093      	str	r3, [r2, #8]

  /* Get tick */
  tickstart = HAL_GetTick ();
2400fe6a:	f7f0 fcf1 	bl	24000850 <HAL_GetTick>
2400fe6e:	6078      	str	r0, [r7, #4]

  /* Wait till Backup regulator ready flag is set */
  while (__HAL_PWR_GET_FLAG (PWR_FLAG_BRR) == 0U)
2400fe70:	e009      	b.n	2400fe86 <HAL_PWREx_EnableBkUpReg+0x2e>
  {
    if ((HAL_GetTick() - tickstart ) > PWR_FLAG_SETTING_DELAY)
2400fe72:	f7f0 fced 	bl	24000850 <HAL_GetTick>
2400fe76:	4602      	mov	r2, r0
2400fe78:	687b      	ldr	r3, [r7, #4]
2400fe7a:	1ad3      	subs	r3, r2, r3
2400fe7c:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
2400fe80:	d901      	bls.n	2400fe86 <HAL_PWREx_EnableBkUpReg+0x2e>
    {
      return HAL_ERROR;
2400fe82:	2301      	movs	r3, #1
2400fe84:	e007      	b.n	2400fe96 <HAL_PWREx_EnableBkUpReg+0x3e>
  while (__HAL_PWR_GET_FLAG (PWR_FLAG_BRR) == 0U)
2400fe86:	4b06      	ldr	r3, [pc, #24]	; (2400fea0 <HAL_PWREx_EnableBkUpReg+0x48>)
2400fe88:	689b      	ldr	r3, [r3, #8]
2400fe8a:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
2400fe8e:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
2400fe92:	d1ee      	bne.n	2400fe72 <HAL_PWREx_EnableBkUpReg+0x1a>
    }
  }

  return HAL_OK;
2400fe94:	2300      	movs	r3, #0
}
2400fe96:	4618      	mov	r0, r3
2400fe98:	3708      	adds	r7, #8
2400fe9a:	46bd      	mov	sp, r7
2400fe9c:	bd80      	pop	{r7, pc}
2400fe9e:	bf00      	nop
2400fea0:	58024800 	.word	0x58024800

2400fea4 <HAL_PWREx_DisableBkUpReg>:
/**
  * @brief Disable the Backup Regulator.
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_PWREx_DisableBkUpReg (void)
{
2400fea4:	b580      	push	{r7, lr}
2400fea6:	b082      	sub	sp, #8
2400fea8:	af00      	add	r7, sp, #0
  uint32_t tickstart;

  /* Disable the Backup regulator */
  CLEAR_BIT (PWR->CR2, PWR_CR2_BREN);
2400feaa:	4b10      	ldr	r3, [pc, #64]	; (2400feec <HAL_PWREx_DisableBkUpReg+0x48>)
2400feac:	689b      	ldr	r3, [r3, #8]
2400feae:	4a0f      	ldr	r2, [pc, #60]	; (2400feec <HAL_PWREx_DisableBkUpReg+0x48>)
2400feb0:	f023 0301 	bic.w	r3, r3, #1
2400feb4:	6093      	str	r3, [r2, #8]

  /* Get tick */
  tickstart = HAL_GetTick ();
2400feb6:	f7f0 fccb 	bl	24000850 <HAL_GetTick>
2400feba:	6078      	str	r0, [r7, #4]

  /* Wait till Backup regulator ready flag is reset */
  while (__HAL_PWR_GET_FLAG (PWR_FLAG_BRR) != 0U)
2400febc:	e009      	b.n	2400fed2 <HAL_PWREx_DisableBkUpReg+0x2e>
  {
    if ((HAL_GetTick() - tickstart ) > PWR_FLAG_SETTING_DELAY)
2400febe:	f7f0 fcc7 	bl	24000850 <HAL_GetTick>
2400fec2:	4602      	mov	r2, r0
2400fec4:	687b      	ldr	r3, [r7, #4]
2400fec6:	1ad3      	subs	r3, r2, r3
2400fec8:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
2400fecc:	d901      	bls.n	2400fed2 <HAL_PWREx_DisableBkUpReg+0x2e>
    {
      return HAL_ERROR;
2400fece:	2301      	movs	r3, #1
2400fed0:	e007      	b.n	2400fee2 <HAL_PWREx_DisableBkUpReg+0x3e>
  while (__HAL_PWR_GET_FLAG (PWR_FLAG_BRR) != 0U)
2400fed2:	4b06      	ldr	r3, [pc, #24]	; (2400feec <HAL_PWREx_DisableBkUpReg+0x48>)
2400fed4:	689b      	ldr	r3, [r3, #8]
2400fed6:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
2400feda:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
2400fede:	d0ee      	beq.n	2400febe <HAL_PWREx_DisableBkUpReg+0x1a>
    }
  }

  return HAL_OK;
2400fee0:	2300      	movs	r3, #0
}
2400fee2:	4618      	mov	r0, r3
2400fee4:	3708      	adds	r7, #8
2400fee6:	46bd      	mov	sp, r7
2400fee8:	bd80      	pop	{r7, pc}
2400feea:	bf00      	nop
2400feec:	58024800 	.word	0x58024800

2400fef0 <HAL_PWREx_EnableUSBReg>:
/**
  * @brief Enable the USB Regulator.
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_PWREx_EnableUSBReg (void)
{
2400fef0:	b580      	push	{r7, lr}
2400fef2:	b082      	sub	sp, #8
2400fef4:	af00      	add	r7, sp, #0
  uint32_t tickstart;

  /* Enable the USB regulator */
  SET_BIT (PWR->CR3, PWR_CR3_USBREGEN);
2400fef6:	4b10      	ldr	r3, [pc, #64]	; (2400ff38 <HAL_PWREx_EnableUSBReg+0x48>)
2400fef8:	68db      	ldr	r3, [r3, #12]
2400fefa:	4a0f      	ldr	r2, [pc, #60]	; (2400ff38 <HAL_PWREx_EnableUSBReg+0x48>)
2400fefc:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
2400ff00:	60d3      	str	r3, [r2, #12]

  /* Get tick */
  tickstart = HAL_GetTick ();
2400ff02:	f7f0 fca5 	bl	24000850 <HAL_GetTick>
2400ff06:	6078      	str	r0, [r7, #4]

  /* Wait till the USB regulator ready flag is set */
  while (__HAL_PWR_GET_FLAG (PWR_FLAG_USB33RDY) == 0U)
2400ff08:	e009      	b.n	2400ff1e <HAL_PWREx_EnableUSBReg+0x2e>
  {
    if ((HAL_GetTick() - tickstart ) > PWR_FLAG_SETTING_DELAY)
2400ff0a:	f7f0 fca1 	bl	24000850 <HAL_GetTick>
2400ff0e:	4602      	mov	r2, r0
2400ff10:	687b      	ldr	r3, [r7, #4]
2400ff12:	1ad3      	subs	r3, r2, r3
2400ff14:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
2400ff18:	d901      	bls.n	2400ff1e <HAL_PWREx_EnableUSBReg+0x2e>
    {
      return HAL_ERROR;
2400ff1a:	2301      	movs	r3, #1
2400ff1c:	e007      	b.n	2400ff2e <HAL_PWREx_EnableUSBReg+0x3e>
  while (__HAL_PWR_GET_FLAG (PWR_FLAG_USB33RDY) == 0U)
2400ff1e:	4b06      	ldr	r3, [pc, #24]	; (2400ff38 <HAL_PWREx_EnableUSBReg+0x48>)
2400ff20:	68db      	ldr	r3, [r3, #12]
2400ff22:	f003 6380 	and.w	r3, r3, #67108864	; 0x4000000
2400ff26:	f1b3 6f80 	cmp.w	r3, #67108864	; 0x4000000
2400ff2a:	d1ee      	bne.n	2400ff0a <HAL_PWREx_EnableUSBReg+0x1a>
    }
  }

  return HAL_OK;
2400ff2c:	2300      	movs	r3, #0
}
2400ff2e:	4618      	mov	r0, r3
2400ff30:	3708      	adds	r7, #8
2400ff32:	46bd      	mov	sp, r7
2400ff34:	bd80      	pop	{r7, pc}
2400ff36:	bf00      	nop
2400ff38:	58024800 	.word	0x58024800

2400ff3c <HAL_PWREx_DisableUSBReg>:
/**
  * @brief Disable the USB Regulator.
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_PWREx_DisableUSBReg (void)
{
2400ff3c:	b580      	push	{r7, lr}
2400ff3e:	b082      	sub	sp, #8
2400ff40:	af00      	add	r7, sp, #0
  uint32_t tickstart;

  /* Disable the USB regulator */
  CLEAR_BIT (PWR->CR3, PWR_CR3_USBREGEN);
2400ff42:	4b10      	ldr	r3, [pc, #64]	; (2400ff84 <HAL_PWREx_DisableUSBReg+0x48>)
2400ff44:	68db      	ldr	r3, [r3, #12]
2400ff46:	4a0f      	ldr	r2, [pc, #60]	; (2400ff84 <HAL_PWREx_DisableUSBReg+0x48>)
2400ff48:	f023 7300 	bic.w	r3, r3, #33554432	; 0x2000000
2400ff4c:	60d3      	str	r3, [r2, #12]

  /* Get tick */
  tickstart = HAL_GetTick ();
2400ff4e:	f7f0 fc7f 	bl	24000850 <HAL_GetTick>
2400ff52:	6078      	str	r0, [r7, #4]

  /* Wait till the USB regulator ready flag is reset */
  while(__HAL_PWR_GET_FLAG (PWR_FLAG_USB33RDY) != 0U)
2400ff54:	e009      	b.n	2400ff6a <HAL_PWREx_DisableUSBReg+0x2e>
  {
    if ((HAL_GetTick() - tickstart ) > PWR_FLAG_SETTING_DELAY)
2400ff56:	f7f0 fc7b 	bl	24000850 <HAL_GetTick>
2400ff5a:	4602      	mov	r2, r0
2400ff5c:	687b      	ldr	r3, [r7, #4]
2400ff5e:	1ad3      	subs	r3, r2, r3
2400ff60:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
2400ff64:	d901      	bls.n	2400ff6a <HAL_PWREx_DisableUSBReg+0x2e>
    {
      return HAL_ERROR;
2400ff66:	2301      	movs	r3, #1
2400ff68:	e007      	b.n	2400ff7a <HAL_PWREx_DisableUSBReg+0x3e>
  while(__HAL_PWR_GET_FLAG (PWR_FLAG_USB33RDY) != 0U)
2400ff6a:	4b06      	ldr	r3, [pc, #24]	; (2400ff84 <HAL_PWREx_DisableUSBReg+0x48>)
2400ff6c:	68db      	ldr	r3, [r3, #12]
2400ff6e:	f003 6380 	and.w	r3, r3, #67108864	; 0x4000000
2400ff72:	f1b3 6f80 	cmp.w	r3, #67108864	; 0x4000000
2400ff76:	d0ee      	beq.n	2400ff56 <HAL_PWREx_DisableUSBReg+0x1a>
    }
  }

  return HAL_OK;
2400ff78:	2300      	movs	r3, #0
}
2400ff7a:	4618      	mov	r0, r3
2400ff7c:	3708      	adds	r7, #8
2400ff7e:	46bd      	mov	sp, r7
2400ff80:	bd80      	pop	{r7, pc}
2400ff82:	bf00      	nop
2400ff84:	58024800 	.word	0x58024800

2400ff88 <HAL_PWREx_EnableUSBVoltageDetector>:
/**
  * @brief Enable the USB voltage level detector.
  * @retval None.
  */
void HAL_PWREx_EnableUSBVoltageDetector (void)
{
2400ff88:	b480      	push	{r7}
2400ff8a:	af00      	add	r7, sp, #0
  /* Enable the USB voltage detector */
  SET_BIT (PWR->CR3, PWR_CR3_USB33DEN);
2400ff8c:	4b05      	ldr	r3, [pc, #20]	; (2400ffa4 <HAL_PWREx_EnableUSBVoltageDetector+0x1c>)
2400ff8e:	68db      	ldr	r3, [r3, #12]
2400ff90:	4a04      	ldr	r2, [pc, #16]	; (2400ffa4 <HAL_PWREx_EnableUSBVoltageDetector+0x1c>)
2400ff92:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
2400ff96:	60d3      	str	r3, [r2, #12]
}
2400ff98:	bf00      	nop
2400ff9a:	46bd      	mov	sp, r7
2400ff9c:	f85d 7b04 	ldr.w	r7, [sp], #4
2400ffa0:	4770      	bx	lr
2400ffa2:	bf00      	nop
2400ffa4:	58024800 	.word	0x58024800

2400ffa8 <HAL_PWREx_DisableUSBVoltageDetector>:
/**
  * @brief Disable the USB voltage level detector.
  * @retval None.
  */
void HAL_PWREx_DisableUSBVoltageDetector (void)
{
2400ffa8:	b480      	push	{r7}
2400ffaa:	af00      	add	r7, sp, #0
  /* Disable the USB voltage detector */
  CLEAR_BIT (PWR->CR3, PWR_CR3_USB33DEN);
2400ffac:	4b05      	ldr	r3, [pc, #20]	; (2400ffc4 <HAL_PWREx_DisableUSBVoltageDetector+0x1c>)
2400ffae:	68db      	ldr	r3, [r3, #12]
2400ffb0:	4a04      	ldr	r2, [pc, #16]	; (2400ffc4 <HAL_PWREx_DisableUSBVoltageDetector+0x1c>)
2400ffb2:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
2400ffb6:	60d3      	str	r3, [r2, #12]
}
2400ffb8:	bf00      	nop
2400ffba:	46bd      	mov	sp, r7
2400ffbc:	f85d 7b04 	ldr.w	r7, [sp], #4
2400ffc0:	4770      	bx	lr
2400ffc2:	bf00      	nop
2400ffc4:	58024800 	.word	0x58024800

2400ffc8 <HAL_PWREx_EnableBatteryCharging>:
  *            @arg PWR_BATTERY_CHARGING_RESISTOR_5 : 5 KOhm resistor.
  *            @arg PWR_BATTERY_CHARGING_RESISTOR_1_5 : 1.5 KOhm resistor.
  * @retval None.
  */
void HAL_PWREx_EnableBatteryCharging (uint32_t ResistorValue)
{
2400ffc8:	b480      	push	{r7}
2400ffca:	b083      	sub	sp, #12
2400ffcc:	af00      	add	r7, sp, #0
2400ffce:	6078      	str	r0, [r7, #4]
  /* Check the parameter */
  assert_param (IS_PWR_BATTERY_RESISTOR_SELECT (ResistorValue));

  /* Specify the charging resistor */
  MODIFY_REG (PWR->CR3, PWR_CR3_VBRS, ResistorValue);
2400ffd0:	4b09      	ldr	r3, [pc, #36]	; (2400fff8 <HAL_PWREx_EnableBatteryCharging+0x30>)
2400ffd2:	68db      	ldr	r3, [r3, #12]
2400ffd4:	f423 7200 	bic.w	r2, r3, #512	; 0x200
2400ffd8:	4907      	ldr	r1, [pc, #28]	; (2400fff8 <HAL_PWREx_EnableBatteryCharging+0x30>)
2400ffda:	687b      	ldr	r3, [r7, #4]
2400ffdc:	4313      	orrs	r3, r2
2400ffde:	60cb      	str	r3, [r1, #12]

  /* Enable the Battery charging */
  SET_BIT (PWR->CR3, PWR_CR3_VBE);
2400ffe0:	4b05      	ldr	r3, [pc, #20]	; (2400fff8 <HAL_PWREx_EnableBatteryCharging+0x30>)
2400ffe2:	68db      	ldr	r3, [r3, #12]
2400ffe4:	4a04      	ldr	r2, [pc, #16]	; (2400fff8 <HAL_PWREx_EnableBatteryCharging+0x30>)
2400ffe6:	f443 7380 	orr.w	r3, r3, #256	; 0x100
2400ffea:	60d3      	str	r3, [r2, #12]
}
2400ffec:	bf00      	nop
2400ffee:	370c      	adds	r7, #12
2400fff0:	46bd      	mov	sp, r7
2400fff2:	f85d 7b04 	ldr.w	r7, [sp], #4
2400fff6:	4770      	bx	lr
2400fff8:	58024800 	.word	0x58024800

2400fffc <HAL_PWREx_DisableBatteryCharging>:
/**
  * @brief Disable the Battery charging.
  * @retval None.
  */
void HAL_PWREx_DisableBatteryCharging (void)
{
2400fffc:	b480      	push	{r7}
2400fffe:	af00      	add	r7, sp, #0
  /* Disable the Battery charging */
  CLEAR_BIT (PWR->CR3, PWR_CR3_VBE);
24010000:	4b05      	ldr	r3, [pc, #20]	; (24010018 <HAL_PWREx_DisableBatteryCharging+0x1c>)
24010002:	68db      	ldr	r3, [r3, #12]
24010004:	4a04      	ldr	r2, [pc, #16]	; (24010018 <HAL_PWREx_DisableBatteryCharging+0x1c>)
24010006:	f423 7380 	bic.w	r3, r3, #256	; 0x100
2401000a:	60d3      	str	r3, [r2, #12]
}
2401000c:	bf00      	nop
2401000e:	46bd      	mov	sp, r7
24010010:	f85d 7b04 	ldr.w	r7, [sp], #4
24010014:	4770      	bx	lr
24010016:	bf00      	nop
24010018:	58024800 	.word	0x58024800

2401001c <HAL_PWREx_EnableMonitoring>:
/**
  * @brief Enable the VBAT and temperature monitoring.
  * @retval HAL status.
  */
void HAL_PWREx_EnableMonitoring (void)
{
2401001c:	b480      	push	{r7}
2401001e:	af00      	add	r7, sp, #0
  /* Enable the VBAT and Temperature monitoring */
  SET_BIT (PWR->CR2, PWR_CR2_MONEN);
24010020:	4b05      	ldr	r3, [pc, #20]	; (24010038 <HAL_PWREx_EnableMonitoring+0x1c>)
24010022:	689b      	ldr	r3, [r3, #8]
24010024:	4a04      	ldr	r2, [pc, #16]	; (24010038 <HAL_PWREx_EnableMonitoring+0x1c>)
24010026:	f043 0310 	orr.w	r3, r3, #16
2401002a:	6093      	str	r3, [r2, #8]
}
2401002c:	bf00      	nop
2401002e:	46bd      	mov	sp, r7
24010030:	f85d 7b04 	ldr.w	r7, [sp], #4
24010034:	4770      	bx	lr
24010036:	bf00      	nop
24010038:	58024800 	.word	0x58024800

2401003c <HAL_PWREx_DisableMonitoring>:
/**
  * @brief Disable the VBAT and temperature monitoring.
  * @retval HAL status.
  */
void HAL_PWREx_DisableMonitoring (void)
{
2401003c:	b480      	push	{r7}
2401003e:	af00      	add	r7, sp, #0
  /* Disable the VBAT and Temperature monitoring */
  CLEAR_BIT (PWR->CR2, PWR_CR2_MONEN);
24010040:	4b05      	ldr	r3, [pc, #20]	; (24010058 <HAL_PWREx_DisableMonitoring+0x1c>)
24010042:	689b      	ldr	r3, [r3, #8]
24010044:	4a04      	ldr	r2, [pc, #16]	; (24010058 <HAL_PWREx_DisableMonitoring+0x1c>)
24010046:	f023 0310 	bic.w	r3, r3, #16
2401004a:	6093      	str	r3, [r2, #8]
}
2401004c:	bf00      	nop
2401004e:	46bd      	mov	sp, r7
24010050:	f85d 7b04 	ldr.w	r7, [sp], #4
24010054:	4770      	bx	lr
24010056:	bf00      	nop
24010058:	58024800 	.word	0x58024800

2401005c <HAL_PWREx_GetTemperatureLevel>:
  * @brief Indicate whether the junction temperature is between, above or below
  *        the thresholds.
  * @retval Temperature level.
  */
uint32_t HAL_PWREx_GetTemperatureLevel (void)
{
2401005c:	b480      	push	{r7}
2401005e:	b083      	sub	sp, #12
24010060:	af00      	add	r7, sp, #0
  uint32_t tempLevel, regValue;

  /* Read the temperature flags */
  regValue = READ_BIT (PWR->CR2, (PWR_CR2_TEMPH | PWR_CR2_TEMPL));
24010062:	4b0f      	ldr	r3, [pc, #60]	; (240100a0 <HAL_PWREx_GetTemperatureLevel+0x44>)
24010064:	689b      	ldr	r3, [r3, #8]
24010066:	f403 0340 	and.w	r3, r3, #12582912	; 0xc00000
2401006a:	603b      	str	r3, [r7, #0]

  /* Check if the temperature is below the threshold */
  if (regValue == PWR_CR2_TEMPL)
2401006c:	683b      	ldr	r3, [r7, #0]
2401006e:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
24010072:	d103      	bne.n	2401007c <HAL_PWREx_GetTemperatureLevel+0x20>
  {
    tempLevel = PWR_TEMP_BELOW_LOW_THRESHOLD;
24010074:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
24010078:	607b      	str	r3, [r7, #4]
2401007a:	e009      	b.n	24010090 <HAL_PWREx_GetTemperatureLevel+0x34>
  }
  /* Check if the temperature is above the threshold */
  else if (regValue == PWR_CR2_TEMPH)
2401007c:	683b      	ldr	r3, [r7, #0]
2401007e:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
24010082:	d103      	bne.n	2401008c <HAL_PWREx_GetTemperatureLevel+0x30>
  {
    tempLevel = PWR_TEMP_ABOVE_HIGH_THRESHOLD;
24010084:	f44f 0300 	mov.w	r3, #8388608	; 0x800000
24010088:	607b      	str	r3, [r7, #4]
2401008a:	e001      	b.n	24010090 <HAL_PWREx_GetTemperatureLevel+0x34>
  }
  /* The temperature is between the thresholds */
  else
  {
    tempLevel = PWR_TEMP_BETWEEN_HIGH_LOW_THRESHOLD;
2401008c:	2300      	movs	r3, #0
2401008e:	607b      	str	r3, [r7, #4]
  }

  return tempLevel;
24010090:	687b      	ldr	r3, [r7, #4]
}
24010092:	4618      	mov	r0, r3
24010094:	370c      	adds	r7, #12
24010096:	46bd      	mov	sp, r7
24010098:	f85d 7b04 	ldr.w	r7, [sp], #4
2401009c:	4770      	bx	lr
2401009e:	bf00      	nop
240100a0:	58024800 	.word	0x58024800

240100a4 <HAL_PWREx_GetVBATLevel>:
  * @brief Indicate whether the Battery voltage level is between, above or below
  *        the thresholds.
  * @retval VBAT level.
  */
uint32_t HAL_PWREx_GetVBATLevel (void)
{
240100a4:	b480      	push	{r7}
240100a6:	b083      	sub	sp, #12
240100a8:	af00      	add	r7, sp, #0
  uint32_t VBATLevel, regValue;

  /* Read the VBAT flags */
  regValue = READ_BIT (PWR->CR2, (PWR_CR2_VBATH | PWR_CR2_VBATL));
240100aa:	4b0f      	ldr	r3, [pc, #60]	; (240100e8 <HAL_PWREx_GetVBATLevel+0x44>)
240100ac:	689b      	ldr	r3, [r3, #8]
240100ae:	f403 1340 	and.w	r3, r3, #3145728	; 0x300000
240100b2:	603b      	str	r3, [r7, #0]

  /* Check if the VBAT is below the threshold */
  if (regValue == PWR_CR2_VBATL)
240100b4:	683b      	ldr	r3, [r7, #0]
240100b6:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
240100ba:	d103      	bne.n	240100c4 <HAL_PWREx_GetVBATLevel+0x20>
  {
    VBATLevel = PWR_VBAT_BELOW_LOW_THRESHOLD;
240100bc:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
240100c0:	607b      	str	r3, [r7, #4]
240100c2:	e009      	b.n	240100d8 <HAL_PWREx_GetVBATLevel+0x34>
  }
  /* Check if the VBAT is above the threshold */
  else if (regValue == PWR_CR2_VBATH)
240100c4:	683b      	ldr	r3, [r7, #0]
240100c6:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
240100ca:	d103      	bne.n	240100d4 <HAL_PWREx_GetVBATLevel+0x30>
  {
    VBATLevel = PWR_VBAT_ABOVE_HIGH_THRESHOLD;
240100cc:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
240100d0:	607b      	str	r3, [r7, #4]
240100d2:	e001      	b.n	240100d8 <HAL_PWREx_GetVBATLevel+0x34>
  }
  /* The VBAT is between the thresholds */
  else
  {
    VBATLevel = PWR_VBAT_BETWEEN_HIGH_LOW_THRESHOLD;
240100d4:	2300      	movs	r3, #0
240100d6:	607b      	str	r3, [r7, #4]
  }

  return VBATLevel;
240100d8:	687b      	ldr	r3, [r7, #4]
}
240100da:	4618      	mov	r0, r3
240100dc:	370c      	adds	r7, #12
240100de:	46bd      	mov	sp, r7
240100e0:	f85d 7b04 	ldr.w	r7, [sp], #4
240100e4:	4770      	bx	lr
240100e6:	bf00      	nop
240100e8:	58024800 	.word	0x58024800

240100ec <HAL_PWREx_ConfigAVD>:
  *         driver. All combination are allowed: wake up only Cortex-M7, wake up
  *         only Cortex-M4 and wake up Cortex-M7 and Cortex-M4.
  * @retval None.
  */
void HAL_PWREx_ConfigAVD (PWREx_AVDTypeDef *sConfigAVD)
{
240100ec:	b480      	push	{r7}
240100ee:	b083      	sub	sp, #12
240100f0:	af00      	add	r7, sp, #0
240100f2:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param (IS_PWR_AVD_LEVEL (sConfigAVD->AVDLevel));
  assert_param (IS_PWR_AVD_MODE (sConfigAVD->Mode));

  /* Set the ALS[18:17] bits according to AVDLevel value */
  MODIFY_REG (PWR->CR1, PWR_CR1_ALS, sConfigAVD->AVDLevel);
240100f4:	4b37      	ldr	r3, [pc, #220]	; (240101d4 <HAL_PWREx_ConfigAVD+0xe8>)
240100f6:	681b      	ldr	r3, [r3, #0]
240100f8:	f423 22c0 	bic.w	r2, r3, #393216	; 0x60000
240100fc:	687b      	ldr	r3, [r7, #4]
240100fe:	681b      	ldr	r3, [r3, #0]
24010100:	4934      	ldr	r1, [pc, #208]	; (240101d4 <HAL_PWREx_ConfigAVD+0xe8>)
24010102:	4313      	orrs	r3, r2
24010104:	600b      	str	r3, [r1, #0]

  /* Clear any previous config */
#if !defined (DUAL_CORE)
  __HAL_PWR_AVD_EXTI_DISABLE_EVENT ();
24010106:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
2401010a:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
2401010e:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
24010112:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
24010116:	f8c2 3084 	str.w	r3, [r2, #132]	; 0x84
  __HAL_PWR_AVD_EXTI_DISABLE_IT ();
2401011a:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
2401011e:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
24010122:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
24010126:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
2401012a:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
#endif /* !defined (DUAL_CORE) */

  __HAL_PWR_AVD_EXTI_DISABLE_RISING_EDGE ();
2401012e:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
24010132:	681b      	ldr	r3, [r3, #0]
24010134:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
24010138:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
2401013c:	6013      	str	r3, [r2, #0]
  __HAL_PWR_AVD_EXTI_DISABLE_FALLING_EDGE ();
2401013e:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
24010142:	685b      	ldr	r3, [r3, #4]
24010144:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
24010148:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
2401014c:	6053      	str	r3, [r2, #4]

#if !defined (DUAL_CORE)
  /* Configure the interrupt mode */
  if ((sConfigAVD->Mode & AVD_MODE_IT) == AVD_MODE_IT)
2401014e:	687b      	ldr	r3, [r7, #4]
24010150:	685b      	ldr	r3, [r3, #4]
24010152:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
24010156:	2b00      	cmp	r3, #0
24010158:	d009      	beq.n	2401016e <HAL_PWREx_ConfigAVD+0x82>
  {
    __HAL_PWR_AVD_EXTI_ENABLE_IT ();
2401015a:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
2401015e:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
24010162:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
24010166:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
2401016a:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
  }

  /* Configure the event mode */
  if ((sConfigAVD->Mode & AVD_MODE_EVT) == AVD_MODE_EVT)
2401016e:	687b      	ldr	r3, [r7, #4]
24010170:	685b      	ldr	r3, [r3, #4]
24010172:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
24010176:	2b00      	cmp	r3, #0
24010178:	d009      	beq.n	2401018e <HAL_PWREx_ConfigAVD+0xa2>
  {
    __HAL_PWR_AVD_EXTI_ENABLE_EVENT ();
2401017a:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
2401017e:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
24010182:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
24010186:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
2401018a:	f8c2 3084 	str.w	r3, [r2, #132]	; 0x84
  }
#endif /* !defined (DUAL_CORE) */

  /* Rising edge configuration */
  if ((sConfigAVD->Mode & AVD_RISING_EDGE) == AVD_RISING_EDGE)
2401018e:	687b      	ldr	r3, [r7, #4]
24010190:	685b      	ldr	r3, [r3, #4]
24010192:	f003 0301 	and.w	r3, r3, #1
24010196:	2b00      	cmp	r3, #0
24010198:	d007      	beq.n	240101aa <HAL_PWREx_ConfigAVD+0xbe>
  {
    __HAL_PWR_AVD_EXTI_ENABLE_RISING_EDGE ();
2401019a:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
2401019e:	681b      	ldr	r3, [r3, #0]
240101a0:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
240101a4:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
240101a8:	6013      	str	r3, [r2, #0]
  }

  /* Falling edge configuration */
  if ((sConfigAVD->Mode & AVD_FALLING_EDGE) == AVD_FALLING_EDGE)
240101aa:	687b      	ldr	r3, [r7, #4]
240101ac:	685b      	ldr	r3, [r3, #4]
240101ae:	f003 0302 	and.w	r3, r3, #2
240101b2:	2b00      	cmp	r3, #0
240101b4:	d007      	beq.n	240101c6 <HAL_PWREx_ConfigAVD+0xda>
  {
    __HAL_PWR_AVD_EXTI_ENABLE_FALLING_EDGE ();
240101b6:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
240101ba:	685b      	ldr	r3, [r3, #4]
240101bc:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
240101c0:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
240101c4:	6053      	str	r3, [r2, #4]
  }
}
240101c6:	bf00      	nop
240101c8:	370c      	adds	r7, #12
240101ca:	46bd      	mov	sp, r7
240101cc:	f85d 7b04 	ldr.w	r7, [sp], #4
240101d0:	4770      	bx	lr
240101d2:	bf00      	nop
240101d4:	58024800 	.word	0x58024800

240101d8 <HAL_PWREx_EnableAVD>:
/**
  * @brief Enable the Analog Voltage Detector (AVD).
  * @retval None.
  */
void HAL_PWREx_EnableAVD (void)
{
240101d8:	b480      	push	{r7}
240101da:	af00      	add	r7, sp, #0
  /* Enable the Analog Voltage Detector */
  SET_BIT (PWR->CR1, PWR_CR1_AVDEN);
240101dc:	4b05      	ldr	r3, [pc, #20]	; (240101f4 <HAL_PWREx_EnableAVD+0x1c>)
240101de:	681b      	ldr	r3, [r3, #0]
240101e0:	4a04      	ldr	r2, [pc, #16]	; (240101f4 <HAL_PWREx_EnableAVD+0x1c>)
240101e2:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
240101e6:	6013      	str	r3, [r2, #0]
}
240101e8:	bf00      	nop
240101ea:	46bd      	mov	sp, r7
240101ec:	f85d 7b04 	ldr.w	r7, [sp], #4
240101f0:	4770      	bx	lr
240101f2:	bf00      	nop
240101f4:	58024800 	.word	0x58024800

240101f8 <HAL_PWREx_DisableAVD>:
/**
  * @brief Disable the Analog Voltage Detector(AVD).
  * @retval None.
  */
void HAL_PWREx_DisableAVD (void)
{
240101f8:	b480      	push	{r7}
240101fa:	af00      	add	r7, sp, #0
  /* Disable the Analog Voltage Detector */
  CLEAR_BIT (PWR->CR1, PWR_CR1_AVDEN);
240101fc:	4b05      	ldr	r3, [pc, #20]	; (24010214 <HAL_PWREx_DisableAVD+0x1c>)
240101fe:	681b      	ldr	r3, [r3, #0]
24010200:	4a04      	ldr	r2, [pc, #16]	; (24010214 <HAL_PWREx_DisableAVD+0x1c>)
24010202:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
24010206:	6013      	str	r3, [r2, #0]
}
24010208:	bf00      	nop
2401020a:	46bd      	mov	sp, r7
2401020c:	f85d 7b04 	ldr.w	r7, [sp], #4
24010210:	4770      	bx	lr
24010212:	bf00      	nop
24010214:	58024800 	.word	0x58024800

24010218 <HAL_PWREx_PVD_AVD_IRQHandler>:
  * @brief  This function handles the PWR PVD/AVD interrupt request.
  * @note   This API should be called under the PVD_AVD_IRQHandler().
  * @retval None
  */
void HAL_PWREx_PVD_AVD_IRQHandler (void)
{
24010218:	b580      	push	{r7, lr}
2401021a:	af00      	add	r7, sp, #0
  /* Check if the Programmable Voltage Detector is enabled (PVD) */
  if(READ_BIT (PWR->CR1, PWR_CR1_PVDEN) != 0U)
2401021c:	4b1b      	ldr	r3, [pc, #108]	; (2401028c <HAL_PWREx_PVD_AVD_IRQHandler+0x74>)
2401021e:	681b      	ldr	r3, [r3, #0]
24010220:	f003 0310 	and.w	r3, r3, #16
24010224:	2b00      	cmp	r3, #0
24010226:	d014      	beq.n	24010252 <HAL_PWREx_PVD_AVD_IRQHandler+0x3a>
#if defined (DUAL_CORE)
    if (HAL_GetCurrentCPUID () == CM7_CPUID)
#endif /* defined (DUAL_CORE) */
    {
      /* Check PWR D1/CD EXTI flag */
      if(__HAL_PWR_PVD_EXTI_GET_FLAG () != 0U)
24010228:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
2401022c:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
24010230:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
24010234:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
24010238:	d10b      	bne.n	24010252 <HAL_PWREx_PVD_AVD_IRQHandler+0x3a>
      {
        /* PWR PVD interrupt user callback */
        HAL_PWR_PVDCallback ();
2401023a:	f7ff fb12 	bl	2400f862 <HAL_PWR_PVDCallback>

        /* Clear PWR EXTI D1/CD pending bit */
        __HAL_PWR_PVD_EXTI_CLEAR_FLAG ();
2401023e:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
24010242:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
24010246:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
2401024a:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
2401024e:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
    }
#endif /* defined (DUAL_CORE) */
  }

  /* Check if the Analog Voltage Detector is enabled (AVD) */
  if (READ_BIT (PWR->CR1, PWR_CR1_AVDEN) != 0U)
24010252:	4b0e      	ldr	r3, [pc, #56]	; (2401028c <HAL_PWREx_PVD_AVD_IRQHandler+0x74>)
24010254:	681b      	ldr	r3, [r3, #0]
24010256:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
2401025a:	2b00      	cmp	r3, #0
2401025c:	d014      	beq.n	24010288 <HAL_PWREx_PVD_AVD_IRQHandler+0x70>
#if defined (DUAL_CORE)
    if (HAL_GetCurrentCPUID () == CM7_CPUID)
#endif /* defined (DUAL_CORE) */
    {
      /* Check PWR EXTI D1/CD flag */
      if (__HAL_PWR_AVD_EXTI_GET_FLAG () != 0U)
2401025e:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
24010262:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
24010266:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
2401026a:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
2401026e:	d10b      	bne.n	24010288 <HAL_PWREx_PVD_AVD_IRQHandler+0x70>
      {
        /* PWR AVD interrupt user callback */
        HAL_PWREx_AVDCallback ();
24010270:	f000 f80e 	bl	24010290 <HAL_PWREx_AVDCallback>

        /* Clear PWR EXTI D1/CD pending bit */
        __HAL_PWR_AVD_EXTI_CLEAR_FLAG ();
24010274:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
24010278:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
2401027c:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
24010280:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
24010284:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
        __HAL_PWR_AVD_EXTID2_CLEAR_FLAG ();
      }
    }
#endif /* defined (DUAL_CORE) */
  }
}
24010288:	bf00      	nop
2401028a:	bd80      	pop	{r7, pc}
2401028c:	58024800 	.word	0x58024800

24010290 <HAL_PWREx_AVDCallback>:
/**
  * @brief PWR AVD interrupt callback.
  * @retval None.
  */
__weak void HAL_PWREx_AVDCallback (void)
{
24010290:	b480      	push	{r7}
24010292:	af00      	add	r7, sp, #0
  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_PWR_AVDCallback can be implemented in the user file
  */
}
24010294:	bf00      	nop
24010296:	46bd      	mov	sp, r7
24010298:	f85d 7b04 	ldr.w	r7, [sp], #4
2401029c:	4770      	bx	lr
	...

240102a0 <HAL_QSPI_Init>:
  *        in the QSPI_InitTypeDef and initialize the associated handle.
  * @param hqspi : QSPI handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_QSPI_Init(QSPI_HandleTypeDef *hqspi)
{
240102a0:	b580      	push	{r7, lr}
240102a2:	b086      	sub	sp, #24
240102a4:	af02      	add	r7, sp, #8
240102a6:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status;
  uint32_t tickstart = HAL_GetTick();
240102a8:	f7f0 fad2 	bl	24000850 <HAL_GetTick>
240102ac:	60f8      	str	r0, [r7, #12]

  /* Check the QSPI handle allocation */
  if(hqspi == NULL)
240102ae:	687b      	ldr	r3, [r7, #4]
240102b0:	2b00      	cmp	r3, #0
240102b2:	d101      	bne.n	240102b8 <HAL_QSPI_Init+0x18>
  {
    return HAL_ERROR;
240102b4:	2301      	movs	r3, #1
240102b6:	e05f      	b.n	24010378 <HAL_QSPI_Init+0xd8>
  if (hqspi->Init.DualFlash != QSPI_DUALFLASH_ENABLE )
  {
    assert_param(IS_QSPI_FLASH_ID(hqspi->Init.FlashID));
  }

  if(hqspi->State == HAL_QSPI_STATE_RESET)
240102b8:	687b      	ldr	r3, [r7, #4]
240102ba:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
240102be:	b2db      	uxtb	r3, r3
240102c0:	2b00      	cmp	r3, #0
240102c2:	d107      	bne.n	240102d4 <HAL_QSPI_Init+0x34>

    /* Init the low level hardware */
    hqspi->MspInitCallback(hqspi);
#else
    /* Init the low level hardware : GPIO, CLOCK */
    HAL_QSPI_MspInit(hqspi);
240102c4:	6878      	ldr	r0, [r7, #4]
240102c6:	f006 f8d7 	bl	24016478 <HAL_QSPI_MspInit>
#endif

    /* Configure the default timeout for the QSPI memory access */
    HAL_QSPI_SetTimeout(hqspi, HAL_QSPI_TIMEOUT_DEFAULT_VALUE);
240102ca:	f241 3188 	movw	r1, #5000	; 0x1388
240102ce:	6878      	ldr	r0, [r7, #4]
240102d0:	f001 f97a 	bl	240115c8 <HAL_QSPI_SetTimeout>
  }

  /* Configure QSPI FIFO Threshold */
  MODIFY_REG(hqspi->Instance->CR, QUADSPI_CR_FTHRES,
240102d4:	687b      	ldr	r3, [r7, #4]
240102d6:	681b      	ldr	r3, [r3, #0]
240102d8:	681b      	ldr	r3, [r3, #0]
240102da:	f423 6170 	bic.w	r1, r3, #3840	; 0xf00
240102de:	687b      	ldr	r3, [r7, #4]
240102e0:	689b      	ldr	r3, [r3, #8]
240102e2:	3b01      	subs	r3, #1
240102e4:	021a      	lsls	r2, r3, #8
240102e6:	687b      	ldr	r3, [r7, #4]
240102e8:	681b      	ldr	r3, [r3, #0]
240102ea:	430a      	orrs	r2, r1
240102ec:	601a      	str	r2, [r3, #0]
             ((hqspi->Init.FifoThreshold - 1U) << QUADSPI_CR_FTHRES_Pos));

  /* Wait till BUSY flag reset */
  status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, hqspi->Timeout);
240102ee:	687b      	ldr	r3, [r7, #4]
240102f0:	6c9b      	ldr	r3, [r3, #72]	; 0x48
240102f2:	9300      	str	r3, [sp, #0]
240102f4:	68fb      	ldr	r3, [r7, #12]
240102f6:	2200      	movs	r2, #0
240102f8:	2120      	movs	r1, #32
240102fa:	6878      	ldr	r0, [r7, #4]
240102fc:	f001 fa73 	bl	240117e6 <QSPI_WaitFlagStateUntilTimeout>
24010300:	4603      	mov	r3, r0
24010302:	72fb      	strb	r3, [r7, #11]

  if(status == HAL_OK)
24010304:	7afb      	ldrb	r3, [r7, #11]
24010306:	2b00      	cmp	r3, #0
24010308:	d135      	bne.n	24010376 <HAL_QSPI_Init+0xd6>
  {
    /* Configure QSPI Clock Prescaler and Sample Shift */
    MODIFY_REG(hqspi->Instance->CR, (QUADSPI_CR_PRESCALER | QUADSPI_CR_SSHIFT | QUADSPI_CR_FSEL | QUADSPI_CR_DFM),
2401030a:	687b      	ldr	r3, [r7, #4]
2401030c:	681b      	ldr	r3, [r3, #0]
2401030e:	681a      	ldr	r2, [r3, #0]
24010310:	4b1b      	ldr	r3, [pc, #108]	; (24010380 <HAL_QSPI_Init+0xe0>)
24010312:	4013      	ands	r3, r2
24010314:	687a      	ldr	r2, [r7, #4]
24010316:	6852      	ldr	r2, [r2, #4]
24010318:	0611      	lsls	r1, r2, #24
2401031a:	687a      	ldr	r2, [r7, #4]
2401031c:	68d2      	ldr	r2, [r2, #12]
2401031e:	4311      	orrs	r1, r2
24010320:	687a      	ldr	r2, [r7, #4]
24010322:	69d2      	ldr	r2, [r2, #28]
24010324:	4311      	orrs	r1, r2
24010326:	687a      	ldr	r2, [r7, #4]
24010328:	6a12      	ldr	r2, [r2, #32]
2401032a:	4311      	orrs	r1, r2
2401032c:	687a      	ldr	r2, [r7, #4]
2401032e:	6812      	ldr	r2, [r2, #0]
24010330:	430b      	orrs	r3, r1
24010332:	6013      	str	r3, [r2, #0]
               ((hqspi->Init.ClockPrescaler << QUADSPI_CR_PRESCALER_Pos) |
                hqspi->Init.SampleShifting  | hqspi->Init.FlashID | hqspi->Init.DualFlash));

    /* Configure QSPI Flash Size, CS High Time and Clock Mode */
    MODIFY_REG(hqspi->Instance->DCR, (QUADSPI_DCR_FSIZE | QUADSPI_DCR_CSHT | QUADSPI_DCR_CKMODE),
24010334:	687b      	ldr	r3, [r7, #4]
24010336:	681b      	ldr	r3, [r3, #0]
24010338:	685a      	ldr	r2, [r3, #4]
2401033a:	4b12      	ldr	r3, [pc, #72]	; (24010384 <HAL_QSPI_Init+0xe4>)
2401033c:	4013      	ands	r3, r2
2401033e:	687a      	ldr	r2, [r7, #4]
24010340:	6912      	ldr	r2, [r2, #16]
24010342:	0411      	lsls	r1, r2, #16
24010344:	687a      	ldr	r2, [r7, #4]
24010346:	6952      	ldr	r2, [r2, #20]
24010348:	4311      	orrs	r1, r2
2401034a:	687a      	ldr	r2, [r7, #4]
2401034c:	6992      	ldr	r2, [r2, #24]
2401034e:	4311      	orrs	r1, r2
24010350:	687a      	ldr	r2, [r7, #4]
24010352:	6812      	ldr	r2, [r2, #0]
24010354:	430b      	orrs	r3, r1
24010356:	6053      	str	r3, [r2, #4]
               ((hqspi->Init.FlashSize << QUADSPI_DCR_FSIZE_Pos) |
                hqspi->Init.ChipSelectHighTime | hqspi->Init.ClockMode));

    /* Enable the QSPI peripheral */
    __HAL_QSPI_ENABLE(hqspi);
24010358:	687b      	ldr	r3, [r7, #4]
2401035a:	681b      	ldr	r3, [r3, #0]
2401035c:	681a      	ldr	r2, [r3, #0]
2401035e:	687b      	ldr	r3, [r7, #4]
24010360:	681b      	ldr	r3, [r3, #0]
24010362:	f042 0201 	orr.w	r2, r2, #1
24010366:	601a      	str	r2, [r3, #0]

    /* Set QSPI error code to none */
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
24010368:	687b      	ldr	r3, [r7, #4]
2401036a:	2200      	movs	r2, #0
2401036c:	645a      	str	r2, [r3, #68]	; 0x44

    /* Initialize the QSPI state */
    hqspi->State = HAL_QSPI_STATE_READY;
2401036e:	687b      	ldr	r3, [r7, #4]
24010370:	2201      	movs	r2, #1
24010372:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
  }

  /* Return function status */
  return status;
24010376:	7afb      	ldrb	r3, [r7, #11]
}
24010378:	4618      	mov	r0, r3
2401037a:	3710      	adds	r7, #16
2401037c:	46bd      	mov	sp, r7
2401037e:	bd80      	pop	{r7, pc}
24010380:	00ffff2f 	.word	0x00ffff2f
24010384:	ffe0f8fe 	.word	0xffe0f8fe

24010388 <HAL_QSPI_DeInit>:
  * @brief De-Initialize the QSPI peripheral.
  * @param hqspi : QSPI handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_QSPI_DeInit(QSPI_HandleTypeDef *hqspi)
{
24010388:	b580      	push	{r7, lr}
2401038a:	b082      	sub	sp, #8
2401038c:	af00      	add	r7, sp, #0
2401038e:	6078      	str	r0, [r7, #4]
  /* Check the QSPI handle allocation */
  if(hqspi == NULL)
24010390:	687b      	ldr	r3, [r7, #4]
24010392:	2b00      	cmp	r3, #0
24010394:	d101      	bne.n	2401039a <HAL_QSPI_DeInit+0x12>
  {
    return HAL_ERROR;
24010396:	2301      	movs	r3, #1
24010398:	e012      	b.n	240103c0 <HAL_QSPI_DeInit+0x38>
  }

  /* Disable the QSPI Peripheral Clock */
  __HAL_QSPI_DISABLE(hqspi);
2401039a:	687b      	ldr	r3, [r7, #4]
2401039c:	681b      	ldr	r3, [r3, #0]
2401039e:	681a      	ldr	r2, [r3, #0]
240103a0:	687b      	ldr	r3, [r7, #4]
240103a2:	681b      	ldr	r3, [r3, #0]
240103a4:	f022 0201 	bic.w	r2, r2, #1
240103a8:	601a      	str	r2, [r3, #0]

  /* DeInit the low level hardware */
  hqspi->MspDeInitCallback(hqspi);
#else
  /* DeInit the low level hardware: GPIO, CLOCK, NVIC... */
  HAL_QSPI_MspDeInit(hqspi);
240103aa:	6878      	ldr	r0, [r7, #4]
240103ac:	f006 f8e0 	bl	24016570 <HAL_QSPI_MspDeInit>
#endif

  /* Set QSPI error code to none */
  hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
240103b0:	687b      	ldr	r3, [r7, #4]
240103b2:	2200      	movs	r2, #0
240103b4:	645a      	str	r2, [r3, #68]	; 0x44

  /* Initialize the QSPI state */
  hqspi->State = HAL_QSPI_STATE_RESET;
240103b6:	687b      	ldr	r3, [r7, #4]
240103b8:	2200      	movs	r2, #0
240103ba:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

  return HAL_OK;
240103be:	2300      	movs	r3, #0
}
240103c0:	4618      	mov	r0, r3
240103c2:	3708      	adds	r7, #8
240103c4:	46bd      	mov	sp, r7
240103c6:	bd80      	pop	{r7, pc}
  * @brief Initialize the QSPI MSP.
  * @param hqspi : QSPI handle
  * @retval None
  */
__weak void HAL_QSPI_MspInit(QSPI_HandleTypeDef *hqspi)
{
240103c8:	b480      	push	{r7}
240103ca:	b083      	sub	sp, #12
240103cc:	af00      	add	r7, sp, #0
240103ce:	6078      	str	r0, [r7, #4]
  UNUSED(hqspi);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_QSPI_MspInit can be implemented in the user file
   */
}
240103d0:	bf00      	nop
240103d2:	370c      	adds	r7, #12
240103d4:	46bd      	mov	sp, r7
240103d6:	f85d 7b04 	ldr.w	r7, [sp], #4
240103da:	4770      	bx	lr
  * @brief DeInitialize the QSPI MSP.
  * @param hqspi : QSPI handle
  * @retval None
  */
__weak void HAL_QSPI_MspDeInit(QSPI_HandleTypeDef *hqspi)
{
240103dc:	b480      	push	{r7}
240103de:	b083      	sub	sp, #12
240103e0:	af00      	add	r7, sp, #0
240103e2:	6078      	str	r0, [r7, #4]
  UNUSED(hqspi);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_QSPI_MspDeInit can be implemented in the user file
   */
}
240103e4:	bf00      	nop
240103e6:	370c      	adds	r7, #12
240103e8:	46bd      	mov	sp, r7
240103ea:	f85d 7b04 	ldr.w	r7, [sp], #4
240103ee:	4770      	bx	lr

240103f0 <HAL_QSPI_IRQHandler>:
  * @brief Handle QSPI interrupt request.
  * @param hqspi : QSPI handle
  * @retval None
  */
void HAL_QSPI_IRQHandler(QSPI_HandleTypeDef *hqspi)
{
240103f0:	b580      	push	{r7, lr}
240103f2:	b086      	sub	sp, #24
240103f4:	af00      	add	r7, sp, #0
240103f6:	6078      	str	r0, [r7, #4]
  __IO uint32_t *data_reg;
  uint32_t flag = READ_REG(hqspi->Instance->SR);
240103f8:	687b      	ldr	r3, [r7, #4]
240103fa:	681b      	ldr	r3, [r3, #0]
240103fc:	689b      	ldr	r3, [r3, #8]
240103fe:	617b      	str	r3, [r7, #20]
  uint32_t itsource = READ_REG(hqspi->Instance->CR);
24010400:	687b      	ldr	r3, [r7, #4]
24010402:	681b      	ldr	r3, [r3, #0]
24010404:	681b      	ldr	r3, [r3, #0]
24010406:	613b      	str	r3, [r7, #16]

  /* QSPI Fifo Threshold interrupt occurred ----------------------------------*/
  if(((flag & QSPI_FLAG_FT) != 0U) && ((itsource & QSPI_IT_FT) != 0U))
24010408:	697b      	ldr	r3, [r7, #20]
2401040a:	f003 0304 	and.w	r3, r3, #4
2401040e:	2b00      	cmp	r3, #0
24010410:	d064      	beq.n	240104dc <HAL_QSPI_IRQHandler+0xec>
24010412:	693b      	ldr	r3, [r7, #16]
24010414:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
24010418:	2b00      	cmp	r3, #0
2401041a:	d05f      	beq.n	240104dc <HAL_QSPI_IRQHandler+0xec>
  {
    data_reg = &hqspi->Instance->DR;
2401041c:	687b      	ldr	r3, [r7, #4]
2401041e:	681b      	ldr	r3, [r3, #0]
24010420:	3320      	adds	r3, #32
24010422:	60fb      	str	r3, [r7, #12]

    if(hqspi->State == HAL_QSPI_STATE_BUSY_INDIRECT_TX)
24010424:	687b      	ldr	r3, [r7, #4]
24010426:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2401042a:	b2db      	uxtb	r3, r3
2401042c:	2b12      	cmp	r3, #18
2401042e:	d125      	bne.n	2401047c <HAL_QSPI_IRQHandler+0x8c>
    {
      /* Transmission process */
      while(__HAL_QSPI_GET_FLAG(hqspi, QSPI_FLAG_FT) != RESET)
24010430:	e01c      	b.n	2401046c <HAL_QSPI_IRQHandler+0x7c>
      {
        if (hqspi->TxXferCount > 0U)
24010432:	687b      	ldr	r3, [r7, #4]
24010434:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24010436:	2b00      	cmp	r3, #0
24010438:	d00f      	beq.n	2401045a <HAL_QSPI_IRQHandler+0x6a>
        {
          /* Fill the FIFO until the threshold is reached */
          *((__IO uint8_t *)data_reg) = *hqspi->pTxBuffPtr;
2401043a:	687b      	ldr	r3, [r7, #4]
2401043c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2401043e:	781a      	ldrb	r2, [r3, #0]
24010440:	68fb      	ldr	r3, [r7, #12]
24010442:	701a      	strb	r2, [r3, #0]
          hqspi->pTxBuffPtr++;
24010444:	687b      	ldr	r3, [r7, #4]
24010446:	6a5b      	ldr	r3, [r3, #36]	; 0x24
24010448:	1c5a      	adds	r2, r3, #1
2401044a:	687b      	ldr	r3, [r7, #4]
2401044c:	625a      	str	r2, [r3, #36]	; 0x24
          hqspi->TxXferCount--;
2401044e:	687b      	ldr	r3, [r7, #4]
24010450:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24010452:	1e5a      	subs	r2, r3, #1
24010454:	687b      	ldr	r3, [r7, #4]
24010456:	62da      	str	r2, [r3, #44]	; 0x2c
24010458:	e008      	b.n	2401046c <HAL_QSPI_IRQHandler+0x7c>
        }
        else
        {
          /* No more data available for the transfer */
          /* Disable the QSPI FIFO Threshold Interrupt */
          __HAL_QSPI_DISABLE_IT(hqspi, QSPI_IT_FT);
2401045a:	687b      	ldr	r3, [r7, #4]
2401045c:	681b      	ldr	r3, [r3, #0]
2401045e:	681a      	ldr	r2, [r3, #0]
24010460:	687b      	ldr	r3, [r7, #4]
24010462:	681b      	ldr	r3, [r3, #0]
24010464:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
24010468:	601a      	str	r2, [r3, #0]
          break;
2401046a:	e033      	b.n	240104d4 <HAL_QSPI_IRQHandler+0xe4>
      while(__HAL_QSPI_GET_FLAG(hqspi, QSPI_FLAG_FT) != RESET)
2401046c:	687b      	ldr	r3, [r7, #4]
2401046e:	681b      	ldr	r3, [r3, #0]
24010470:	689b      	ldr	r3, [r3, #8]
24010472:	f003 0304 	and.w	r3, r3, #4
24010476:	2b00      	cmp	r3, #0
24010478:	d1db      	bne.n	24010432 <HAL_QSPI_IRQHandler+0x42>
2401047a:	e02b      	b.n	240104d4 <HAL_QSPI_IRQHandler+0xe4>
        }
      }
    }
    else if(hqspi->State == HAL_QSPI_STATE_BUSY_INDIRECT_RX)
2401047c:	687b      	ldr	r3, [r7, #4]
2401047e:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
24010482:	b2db      	uxtb	r3, r3
24010484:	2b22      	cmp	r3, #34	; 0x22
24010486:	d125      	bne.n	240104d4 <HAL_QSPI_IRQHandler+0xe4>
    {
      /* Receiving Process */
      while(__HAL_QSPI_GET_FLAG(hqspi, QSPI_FLAG_FT) != RESET)
24010488:	e01d      	b.n	240104c6 <HAL_QSPI_IRQHandler+0xd6>
      {
        if (hqspi->RxXferCount > 0U)
2401048a:	687b      	ldr	r3, [r7, #4]
2401048c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2401048e:	2b00      	cmp	r3, #0
24010490:	d010      	beq.n	240104b4 <HAL_QSPI_IRQHandler+0xc4>
        {
          /* Read the FIFO until the threshold is reached */
          *hqspi->pRxBuffPtr = *((__IO uint8_t *)data_reg);
24010492:	687b      	ldr	r3, [r7, #4]
24010494:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24010496:	68fa      	ldr	r2, [r7, #12]
24010498:	7812      	ldrb	r2, [r2, #0]
2401049a:	b2d2      	uxtb	r2, r2
2401049c:	701a      	strb	r2, [r3, #0]
          hqspi->pRxBuffPtr++;
2401049e:	687b      	ldr	r3, [r7, #4]
240104a0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
240104a2:	1c5a      	adds	r2, r3, #1
240104a4:	687b      	ldr	r3, [r7, #4]
240104a6:	631a      	str	r2, [r3, #48]	; 0x30
          hqspi->RxXferCount--;
240104a8:	687b      	ldr	r3, [r7, #4]
240104aa:	6b9b      	ldr	r3, [r3, #56]	; 0x38
240104ac:	1e5a      	subs	r2, r3, #1
240104ae:	687b      	ldr	r3, [r7, #4]
240104b0:	639a      	str	r2, [r3, #56]	; 0x38
240104b2:	e008      	b.n	240104c6 <HAL_QSPI_IRQHandler+0xd6>
        }
        else
        {
          /* All data have been received for the transfer */
          /* Disable the QSPI FIFO Threshold Interrupt */
          __HAL_QSPI_DISABLE_IT(hqspi, QSPI_IT_FT);
240104b4:	687b      	ldr	r3, [r7, #4]
240104b6:	681b      	ldr	r3, [r3, #0]
240104b8:	681a      	ldr	r2, [r3, #0]
240104ba:	687b      	ldr	r3, [r7, #4]
240104bc:	681b      	ldr	r3, [r3, #0]
240104be:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
240104c2:	601a      	str	r2, [r3, #0]
          break;
240104c4:	e006      	b.n	240104d4 <HAL_QSPI_IRQHandler+0xe4>
      while(__HAL_QSPI_GET_FLAG(hqspi, QSPI_FLAG_FT) != RESET)
240104c6:	687b      	ldr	r3, [r7, #4]
240104c8:	681b      	ldr	r3, [r3, #0]
240104ca:	689b      	ldr	r3, [r3, #8]
240104cc:	f003 0304 	and.w	r3, r3, #4
240104d0:	2b00      	cmp	r3, #0
240104d2:	d1da      	bne.n	2401048a <HAL_QSPI_IRQHandler+0x9a>

    /* FIFO Threshold callback */
#if (USE_HAL_QSPI_REGISTER_CALLBACKS == 1)
    hqspi->FifoThresholdCallback(hqspi);
#else
    HAL_QSPI_FifoThresholdCallback(hqspi);
240104d4:	6878      	ldr	r0, [r7, #4]
240104d6:	f000 ff76 	bl	240113c6 <HAL_QSPI_FifoThresholdCallback>
240104da:	e13c      	b.n	24010756 <HAL_QSPI_IRQHandler+0x366>
#endif
  }

  /* QSPI Transfer Complete interrupt occurred -------------------------------*/
  else if(((flag & QSPI_FLAG_TC) != 0U) && ((itsource & QSPI_IT_TC) != 0U))
240104dc:	697b      	ldr	r3, [r7, #20]
240104de:	f003 0302 	and.w	r3, r3, #2
240104e2:	2b00      	cmp	r3, #0
240104e4:	f000 80b0 	beq.w	24010648 <HAL_QSPI_IRQHandler+0x258>
240104e8:	693b      	ldr	r3, [r7, #16]
240104ea:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
240104ee:	2b00      	cmp	r3, #0
240104f0:	f000 80aa 	beq.w	24010648 <HAL_QSPI_IRQHandler+0x258>
  {
    /* Clear interrupt */
    WRITE_REG(hqspi->Instance->FCR, QSPI_FLAG_TC);
240104f4:	687b      	ldr	r3, [r7, #4]
240104f6:	681b      	ldr	r3, [r3, #0]
240104f8:	2202      	movs	r2, #2
240104fa:	60da      	str	r2, [r3, #12]

    /* Disable the QSPI FIFO Threshold, Transfer Error and Transfer complete Interrupts */
    __HAL_QSPI_DISABLE_IT(hqspi, QSPI_IT_TC | QSPI_IT_TE | QSPI_IT_FT);
240104fc:	687b      	ldr	r3, [r7, #4]
240104fe:	681b      	ldr	r3, [r3, #0]
24010500:	681a      	ldr	r2, [r3, #0]
24010502:	687b      	ldr	r3, [r7, #4]
24010504:	681b      	ldr	r3, [r3, #0]
24010506:	f422 22e0 	bic.w	r2, r2, #458752	; 0x70000
2401050a:	601a      	str	r2, [r3, #0]

    /* Transfer complete callback */
    if(hqspi->State == HAL_QSPI_STATE_BUSY_INDIRECT_TX)
2401050c:	687b      	ldr	r3, [r7, #4]
2401050e:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
24010512:	b2db      	uxtb	r3, r3
24010514:	2b12      	cmp	r3, #18
24010516:	d120      	bne.n	2401055a <HAL_QSPI_IRQHandler+0x16a>
    {
      if ((hqspi->Instance->CR & QUADSPI_CR_DMAEN) != 0U)
24010518:	687b      	ldr	r3, [r7, #4]
2401051a:	681b      	ldr	r3, [r3, #0]
2401051c:	681b      	ldr	r3, [r3, #0]
2401051e:	f003 0304 	and.w	r3, r3, #4
24010522:	2b00      	cmp	r3, #0
24010524:	d011      	beq.n	2401054a <HAL_QSPI_IRQHandler+0x15a>
      {
        /* Disable the DMA transfer by clearing the DMAEN bit in the QSPI CR register */
        CLEAR_BIT(hqspi->Instance->CR, QUADSPI_CR_DMAEN);
24010526:	687b      	ldr	r3, [r7, #4]
24010528:	681b      	ldr	r3, [r3, #0]
2401052a:	681a      	ldr	r2, [r3, #0]
2401052c:	687b      	ldr	r3, [r7, #4]
2401052e:	681b      	ldr	r3, [r3, #0]
24010530:	f022 0204 	bic.w	r2, r2, #4
24010534:	601a      	str	r2, [r3, #0]

        /* Disable the MDMA channel */
        __HAL_MDMA_DISABLE(hqspi->hmdma);
24010536:	687b      	ldr	r3, [r7, #4]
24010538:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2401053a:	681b      	ldr	r3, [r3, #0]
2401053c:	68da      	ldr	r2, [r3, #12]
2401053e:	687b      	ldr	r3, [r7, #4]
24010540:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24010542:	681b      	ldr	r3, [r3, #0]
24010544:	f022 0201 	bic.w	r2, r2, #1
24010548:	60da      	str	r2, [r3, #12]
      }


      /* Change state of QSPI */
      hqspi->State = HAL_QSPI_STATE_READY;
2401054a:	687b      	ldr	r3, [r7, #4]
2401054c:	2201      	movs	r2, #1
2401054e:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

      /* TX Complete callback */
#if (USE_HAL_QSPI_REGISTER_CALLBACKS == 1)
      hqspi->TxCpltCallback(hqspi);
#else
      HAL_QSPI_TxCpltCallback(hqspi);
24010552:	6878      	ldr	r0, [r7, #4]
24010554:	f000 ff2d 	bl	240113b2 <HAL_QSPI_TxCpltCallback>
    if(hqspi->State == HAL_QSPI_STATE_BUSY_INDIRECT_TX)
24010558:	e0fa      	b.n	24010750 <HAL_QSPI_IRQHandler+0x360>
#endif
    }
    else if(hqspi->State == HAL_QSPI_STATE_BUSY_INDIRECT_RX)
2401055a:	687b      	ldr	r3, [r7, #4]
2401055c:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
24010560:	b2db      	uxtb	r3, r3
24010562:	2b22      	cmp	r3, #34	; 0x22
24010564:	d143      	bne.n	240105ee <HAL_QSPI_IRQHandler+0x1fe>
    {
      if ((hqspi->Instance->CR & QUADSPI_CR_DMAEN) != 0U)
24010566:	687b      	ldr	r3, [r7, #4]
24010568:	681b      	ldr	r3, [r3, #0]
2401056a:	681b      	ldr	r3, [r3, #0]
2401056c:	f003 0304 	and.w	r3, r3, #4
24010570:	2b00      	cmp	r3, #0
24010572:	d012      	beq.n	2401059a <HAL_QSPI_IRQHandler+0x1aa>
      {
        /* Disable the DMA transfer by clearing the DMAEN bit in the QSPI CR register */
        CLEAR_BIT(hqspi->Instance->CR, QUADSPI_CR_DMAEN);
24010574:	687b      	ldr	r3, [r7, #4]
24010576:	681b      	ldr	r3, [r3, #0]
24010578:	681a      	ldr	r2, [r3, #0]
2401057a:	687b      	ldr	r3, [r7, #4]
2401057c:	681b      	ldr	r3, [r3, #0]
2401057e:	f022 0204 	bic.w	r2, r2, #4
24010582:	601a      	str	r2, [r3, #0]

        /* Disable the MDMA channel */
        __HAL_MDMA_DISABLE(hqspi->hmdma);
24010584:	687b      	ldr	r3, [r7, #4]
24010586:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24010588:	681b      	ldr	r3, [r3, #0]
2401058a:	68da      	ldr	r2, [r3, #12]
2401058c:	687b      	ldr	r3, [r7, #4]
2401058e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24010590:	681b      	ldr	r3, [r3, #0]
24010592:	f022 0201 	bic.w	r2, r2, #1
24010596:	60da      	str	r2, [r3, #12]
24010598:	e021      	b.n	240105de <HAL_QSPI_IRQHandler+0x1ee>
      }
      else
      {
        data_reg = &hqspi->Instance->DR;
2401059a:	687b      	ldr	r3, [r7, #4]
2401059c:	681b      	ldr	r3, [r3, #0]
2401059e:	3320      	adds	r3, #32
240105a0:	60fb      	str	r3, [r7, #12]
        while(READ_BIT(hqspi->Instance->SR, QUADSPI_SR_FLEVEL) != 0U)
240105a2:	e013      	b.n	240105cc <HAL_QSPI_IRQHandler+0x1dc>
        {
          if (hqspi->RxXferCount > 0U)
240105a4:	687b      	ldr	r3, [r7, #4]
240105a6:	6b9b      	ldr	r3, [r3, #56]	; 0x38
240105a8:	2b00      	cmp	r3, #0
240105aa:	d017      	beq.n	240105dc <HAL_QSPI_IRQHandler+0x1ec>
          {
            /* Read the last data received in the FIFO until it is empty */
            *hqspi->pRxBuffPtr = *((__IO uint8_t *)data_reg);
240105ac:	687b      	ldr	r3, [r7, #4]
240105ae:	6b1b      	ldr	r3, [r3, #48]	; 0x30
240105b0:	68fa      	ldr	r2, [r7, #12]
240105b2:	7812      	ldrb	r2, [r2, #0]
240105b4:	b2d2      	uxtb	r2, r2
240105b6:	701a      	strb	r2, [r3, #0]
            hqspi->pRxBuffPtr++;
240105b8:	687b      	ldr	r3, [r7, #4]
240105ba:	6b1b      	ldr	r3, [r3, #48]	; 0x30
240105bc:	1c5a      	adds	r2, r3, #1
240105be:	687b      	ldr	r3, [r7, #4]
240105c0:	631a      	str	r2, [r3, #48]	; 0x30
            hqspi->RxXferCount--;
240105c2:	687b      	ldr	r3, [r7, #4]
240105c4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
240105c6:	1e5a      	subs	r2, r3, #1
240105c8:	687b      	ldr	r3, [r7, #4]
240105ca:	639a      	str	r2, [r3, #56]	; 0x38
        while(READ_BIT(hqspi->Instance->SR, QUADSPI_SR_FLEVEL) != 0U)
240105cc:	687b      	ldr	r3, [r7, #4]
240105ce:	681b      	ldr	r3, [r3, #0]
240105d0:	689b      	ldr	r3, [r3, #8]
240105d2:	f403 537c 	and.w	r3, r3, #16128	; 0x3f00
240105d6:	2b00      	cmp	r3, #0
240105d8:	d1e4      	bne.n	240105a4 <HAL_QSPI_IRQHandler+0x1b4>
240105da:	e000      	b.n	240105de <HAL_QSPI_IRQHandler+0x1ee>
          }
          else
          {
            /* All data have been received for the transfer */
            break;
240105dc:	bf00      	nop
        }
      }


      /* Change state of QSPI */
      hqspi->State = HAL_QSPI_STATE_READY;
240105de:	687b      	ldr	r3, [r7, #4]
240105e0:	2201      	movs	r2, #1
240105e2:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

      /* RX Complete callback */
#if (USE_HAL_QSPI_REGISTER_CALLBACKS == 1)
      hqspi->RxCpltCallback(hqspi);
#else
      HAL_QSPI_RxCpltCallback(hqspi);
240105e6:	6878      	ldr	r0, [r7, #4]
240105e8:	f000 fed9 	bl	2401139e <HAL_QSPI_RxCpltCallback>
    if(hqspi->State == HAL_QSPI_STATE_BUSY_INDIRECT_TX)
240105ec:	e0b0      	b.n	24010750 <HAL_QSPI_IRQHandler+0x360>
#endif
    }
    else if(hqspi->State == HAL_QSPI_STATE_BUSY)
240105ee:	687b      	ldr	r3, [r7, #4]
240105f0:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
240105f4:	b2db      	uxtb	r3, r3
240105f6:	2b02      	cmp	r3, #2
240105f8:	d107      	bne.n	2401060a <HAL_QSPI_IRQHandler+0x21a>
    {
      /* Change state of QSPI */
      hqspi->State = HAL_QSPI_STATE_READY;
240105fa:	687b      	ldr	r3, [r7, #4]
240105fc:	2201      	movs	r2, #1
240105fe:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

      /* Command Complete callback */
#if (USE_HAL_QSPI_REGISTER_CALLBACKS == 1)
      hqspi->CmdCpltCallback(hqspi);
#else
      HAL_QSPI_CmdCpltCallback(hqspi);
24010602:	6878      	ldr	r0, [r7, #4]
24010604:	f000 fec1 	bl	2401138a <HAL_QSPI_CmdCpltCallback>
    if(hqspi->State == HAL_QSPI_STATE_BUSY_INDIRECT_TX)
24010608:	e0a2      	b.n	24010750 <HAL_QSPI_IRQHandler+0x360>
#endif
    }
    else if(hqspi->State == HAL_QSPI_STATE_ABORT)
2401060a:	687b      	ldr	r3, [r7, #4]
2401060c:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
24010610:	b2db      	uxtb	r3, r3
24010612:	2b08      	cmp	r3, #8
24010614:	f040 809c 	bne.w	24010750 <HAL_QSPI_IRQHandler+0x360>
    {
      /* Reset functional mode configuration to indirect write mode by default */
      CLEAR_BIT(hqspi->Instance->CCR, QUADSPI_CCR_FMODE);
24010618:	687b      	ldr	r3, [r7, #4]
2401061a:	681b      	ldr	r3, [r3, #0]
2401061c:	695a      	ldr	r2, [r3, #20]
2401061e:	687b      	ldr	r3, [r7, #4]
24010620:	681b      	ldr	r3, [r3, #0]
24010622:	f022 6240 	bic.w	r2, r2, #201326592	; 0xc000000
24010626:	615a      	str	r2, [r3, #20]

      /* Change state of QSPI */
      hqspi->State = HAL_QSPI_STATE_READY;
24010628:	687b      	ldr	r3, [r7, #4]
2401062a:	2201      	movs	r2, #1
2401062c:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

      if (hqspi->ErrorCode == HAL_QSPI_ERROR_NONE)
24010630:	687b      	ldr	r3, [r7, #4]
24010632:	6c5b      	ldr	r3, [r3, #68]	; 0x44
24010634:	2b00      	cmp	r3, #0
24010636:	d103      	bne.n	24010640 <HAL_QSPI_IRQHandler+0x250>

        /* Abort Complete callback */
#if (USE_HAL_QSPI_REGISTER_CALLBACKS == 1)
        hqspi->AbortCpltCallback(hqspi);
#else
        HAL_QSPI_AbortCpltCallback(hqspi);
24010638:	6878      	ldr	r0, [r7, #4]
2401063a:	f000 fe9c 	bl	24011376 <HAL_QSPI_AbortCpltCallback>
    if(hqspi->State == HAL_QSPI_STATE_BUSY_INDIRECT_TX)
2401063e:	e087      	b.n	24010750 <HAL_QSPI_IRQHandler+0x360>

        /* Error callback */
#if (USE_HAL_QSPI_REGISTER_CALLBACKS == 1)
        hqspi->ErrorCallback(hqspi);
#else
        HAL_QSPI_ErrorCallback(hqspi);
24010640:	6878      	ldr	r0, [r7, #4]
24010642:	f000 fe8e 	bl	24011362 <HAL_QSPI_ErrorCallback>
    if(hqspi->State == HAL_QSPI_STATE_BUSY_INDIRECT_TX)
24010646:	e083      	b.n	24010750 <HAL_QSPI_IRQHandler+0x360>
     /* Nothing to do */
    }
  }

  /* QSPI Status Match interrupt occurred ------------------------------------*/
  else if(((flag & QSPI_FLAG_SM) != 0U) && ((itsource & QSPI_IT_SM) != 0U))
24010648:	697b      	ldr	r3, [r7, #20]
2401064a:	f003 0308 	and.w	r3, r3, #8
2401064e:	2b00      	cmp	r3, #0
24010650:	d01f      	beq.n	24010692 <HAL_QSPI_IRQHandler+0x2a2>
24010652:	693b      	ldr	r3, [r7, #16]
24010654:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
24010658:	2b00      	cmp	r3, #0
2401065a:	d01a      	beq.n	24010692 <HAL_QSPI_IRQHandler+0x2a2>
  {
    /* Clear interrupt */
    WRITE_REG(hqspi->Instance->FCR, QSPI_FLAG_SM);
2401065c:	687b      	ldr	r3, [r7, #4]
2401065e:	681b      	ldr	r3, [r3, #0]
24010660:	2208      	movs	r2, #8
24010662:	60da      	str	r2, [r3, #12]

    /* Check if the automatic poll mode stop is activated */
    if(READ_BIT(hqspi->Instance->CR, QUADSPI_CR_APMS) != 0U)
24010664:	687b      	ldr	r3, [r7, #4]
24010666:	681b      	ldr	r3, [r3, #0]
24010668:	681b      	ldr	r3, [r3, #0]
2401066a:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
2401066e:	2b00      	cmp	r3, #0
24010670:	d00b      	beq.n	2401068a <HAL_QSPI_IRQHandler+0x29a>
    {
      /* Disable the QSPI Transfer Error and Status Match Interrupts */
      __HAL_QSPI_DISABLE_IT(hqspi, (QSPI_IT_SM | QSPI_IT_TE));
24010672:	687b      	ldr	r3, [r7, #4]
24010674:	681b      	ldr	r3, [r3, #0]
24010676:	681a      	ldr	r2, [r3, #0]
24010678:	687b      	ldr	r3, [r7, #4]
2401067a:	681b      	ldr	r3, [r3, #0]
2401067c:	f422 2210 	bic.w	r2, r2, #589824	; 0x90000
24010680:	601a      	str	r2, [r3, #0]

      /* Change state of QSPI */
      hqspi->State = HAL_QSPI_STATE_READY;
24010682:	687b      	ldr	r3, [r7, #4]
24010684:	2201      	movs	r2, #1
24010686:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Status match callback */
#if (USE_HAL_QSPI_REGISTER_CALLBACKS == 1)
    hqspi->StatusMatchCallback(hqspi);
#else
    HAL_QSPI_StatusMatchCallback(hqspi);
2401068a:	6878      	ldr	r0, [r7, #4]
2401068c:	f000 fea5 	bl	240113da <HAL_QSPI_StatusMatchCallback>
24010690:	e061      	b.n	24010756 <HAL_QSPI_IRQHandler+0x366>
#endif
  }

  /* QSPI Transfer Error interrupt occurred ----------------------------------*/
  else if(((flag & QSPI_FLAG_TE) != 0U) && ((itsource & QSPI_IT_TE) != 0U))
24010692:	697b      	ldr	r3, [r7, #20]
24010694:	f003 0301 	and.w	r3, r3, #1
24010698:	2b00      	cmp	r3, #0
2401069a:	d047      	beq.n	2401072c <HAL_QSPI_IRQHandler+0x33c>
2401069c:	693b      	ldr	r3, [r7, #16]
2401069e:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
240106a2:	2b00      	cmp	r3, #0
240106a4:	d042      	beq.n	2401072c <HAL_QSPI_IRQHandler+0x33c>
  {
    /* Clear interrupt */
    WRITE_REG(hqspi->Instance->FCR, QSPI_FLAG_TE);
240106a6:	687b      	ldr	r3, [r7, #4]
240106a8:	681b      	ldr	r3, [r3, #0]
240106aa:	2201      	movs	r2, #1
240106ac:	60da      	str	r2, [r3, #12]

    /* Disable all the QSPI Interrupts */
    __HAL_QSPI_DISABLE_IT(hqspi, QSPI_IT_SM | QSPI_IT_TC | QSPI_IT_TE | QSPI_IT_FT);
240106ae:	687b      	ldr	r3, [r7, #4]
240106b0:	681b      	ldr	r3, [r3, #0]
240106b2:	681a      	ldr	r2, [r3, #0]
240106b4:	687b      	ldr	r3, [r7, #4]
240106b6:	681b      	ldr	r3, [r3, #0]
240106b8:	f422 2270 	bic.w	r2, r2, #983040	; 0xf0000
240106bc:	601a      	str	r2, [r3, #0]

    /* Set error code */
    hqspi->ErrorCode |= HAL_QSPI_ERROR_TRANSFER;
240106be:	687b      	ldr	r3, [r7, #4]
240106c0:	6c5b      	ldr	r3, [r3, #68]	; 0x44
240106c2:	f043 0202 	orr.w	r2, r3, #2
240106c6:	687b      	ldr	r3, [r7, #4]
240106c8:	645a      	str	r2, [r3, #68]	; 0x44

    if ((hqspi->Instance->CR & QUADSPI_CR_DMAEN) != 0U)
240106ca:	687b      	ldr	r3, [r7, #4]
240106cc:	681b      	ldr	r3, [r3, #0]
240106ce:	681b      	ldr	r3, [r3, #0]
240106d0:	f003 0304 	and.w	r3, r3, #4
240106d4:	2b00      	cmp	r3, #0
240106d6:	d021      	beq.n	2401071c <HAL_QSPI_IRQHandler+0x32c>
    {
      /* Disable the DMA transfer by clearing the DMAEN bit in the QSPI CR register */
      CLEAR_BIT(hqspi->Instance->CR, QUADSPI_CR_DMAEN);
240106d8:	687b      	ldr	r3, [r7, #4]
240106da:	681b      	ldr	r3, [r3, #0]
240106dc:	681a      	ldr	r2, [r3, #0]
240106de:	687b      	ldr	r3, [r7, #4]
240106e0:	681b      	ldr	r3, [r3, #0]
240106e2:	f022 0204 	bic.w	r2, r2, #4
240106e6:	601a      	str	r2, [r3, #0]

      /* Disable the MDMA channel */
      hqspi->hmdma->XferAbortCallback = QSPI_DMAAbortCplt;
240106e8:	687b      	ldr	r3, [r7, #4]
240106ea:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
240106ec:	4a1c      	ldr	r2, [pc, #112]	; (24010760 <HAL_QSPI_IRQHandler+0x370>)
240106ee:	659a      	str	r2, [r3, #88]	; 0x58
      if (HAL_MDMA_Abort_IT(hqspi->hmdma) != HAL_OK)
240106f0:	687b      	ldr	r3, [r7, #4]
240106f2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
240106f4:	4618      	mov	r0, r3
240106f6:	f7fe fb54 	bl	2400eda2 <HAL_MDMA_Abort_IT>
240106fa:	4603      	mov	r3, r0
240106fc:	2b00      	cmp	r3, #0
240106fe:	d029      	beq.n	24010754 <HAL_QSPI_IRQHandler+0x364>
      {
        /* Set error code to DMA */
        hqspi->ErrorCode |= HAL_QSPI_ERROR_DMA;
24010700:	687b      	ldr	r3, [r7, #4]
24010702:	6c5b      	ldr	r3, [r3, #68]	; 0x44
24010704:	f043 0204 	orr.w	r2, r3, #4
24010708:	687b      	ldr	r3, [r7, #4]
2401070a:	645a      	str	r2, [r3, #68]	; 0x44

        /* Change state of QSPI */
        hqspi->State = HAL_QSPI_STATE_READY;
2401070c:	687b      	ldr	r3, [r7, #4]
2401070e:	2201      	movs	r2, #1
24010710:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

        /* Error callback */
#if (USE_HAL_QSPI_REGISTER_CALLBACKS == 1)
        hqspi->ErrorCallback(hqspi);
#else
        HAL_QSPI_ErrorCallback(hqspi);
24010714:	6878      	ldr	r0, [r7, #4]
24010716:	f000 fe24 	bl	24011362 <HAL_QSPI_ErrorCallback>
    if ((hqspi->Instance->CR & QUADSPI_CR_DMAEN) != 0U)
2401071a:	e01b      	b.n	24010754 <HAL_QSPI_IRQHandler+0x364>
      }
    }
    else
    {
      /* Change state of QSPI */
      hqspi->State = HAL_QSPI_STATE_READY;
2401071c:	687b      	ldr	r3, [r7, #4]
2401071e:	2201      	movs	r2, #1
24010720:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

      /* Error callback */
#if (USE_HAL_QSPI_REGISTER_CALLBACKS == 1)
      hqspi->ErrorCallback(hqspi);
#else
      HAL_QSPI_ErrorCallback(hqspi);
24010724:	6878      	ldr	r0, [r7, #4]
24010726:	f000 fe1c 	bl	24011362 <HAL_QSPI_ErrorCallback>
    if ((hqspi->Instance->CR & QUADSPI_CR_DMAEN) != 0U)
2401072a:	e013      	b.n	24010754 <HAL_QSPI_IRQHandler+0x364>
#endif
    }
  }

  /* QSPI Timeout interrupt occurred -----------------------------------------*/
  else if(((flag & QSPI_FLAG_TO) != 0U) && ((itsource & QSPI_IT_TO) != 0U))
2401072c:	697b      	ldr	r3, [r7, #20]
2401072e:	f003 0310 	and.w	r3, r3, #16
24010732:	2b00      	cmp	r3, #0
24010734:	d00f      	beq.n	24010756 <HAL_QSPI_IRQHandler+0x366>
24010736:	693b      	ldr	r3, [r7, #16]
24010738:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
2401073c:	2b00      	cmp	r3, #0
2401073e:	d00a      	beq.n	24010756 <HAL_QSPI_IRQHandler+0x366>
  {
    /* Clear interrupt */
    WRITE_REG(hqspi->Instance->FCR, QSPI_FLAG_TO);
24010740:	687b      	ldr	r3, [r7, #4]
24010742:	681b      	ldr	r3, [r3, #0]
24010744:	2210      	movs	r2, #16
24010746:	60da      	str	r2, [r3, #12]

    /* Timeout callback */
#if (USE_HAL_QSPI_REGISTER_CALLBACKS == 1)
    hqspi->TimeOutCallback(hqspi);
#else
    HAL_QSPI_TimeOutCallback(hqspi);
24010748:	6878      	ldr	r0, [r7, #4]
2401074a:	f000 fe50 	bl	240113ee <HAL_QSPI_TimeOutCallback>

   else
  {
   /* Nothing to do */
  }
}
2401074e:	e002      	b.n	24010756 <HAL_QSPI_IRQHandler+0x366>
    if(hqspi->State == HAL_QSPI_STATE_BUSY_INDIRECT_TX)
24010750:	bf00      	nop
24010752:	e000      	b.n	24010756 <HAL_QSPI_IRQHandler+0x366>
    if ((hqspi->Instance->CR & QUADSPI_CR_DMAEN) != 0U)
24010754:	bf00      	nop
}
24010756:	bf00      	nop
24010758:	3718      	adds	r7, #24
2401075a:	46bd      	mov	sp, r7
2401075c:	bd80      	pop	{r7, pc}
2401075e:	bf00      	nop
24010760:	24011781 	.word	0x24011781

24010764 <HAL_QSPI_Command>:
  * @param Timeout : Timeout duration
  * @note   This function is used only in Indirect Read or Write Modes
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_QSPI_Command(QSPI_HandleTypeDef *hqspi, QSPI_CommandTypeDef *cmd, uint32_t Timeout)
{
24010764:	b580      	push	{r7, lr}
24010766:	b088      	sub	sp, #32
24010768:	af02      	add	r7, sp, #8
2401076a:	60f8      	str	r0, [r7, #12]
2401076c:	60b9      	str	r1, [r7, #8]
2401076e:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status;
  uint32_t tickstart = HAL_GetTick();
24010770:	f7f0 f86e 	bl	24000850 <HAL_GetTick>
24010774:	6138      	str	r0, [r7, #16]
  assert_param(IS_QSPI_DDR_MODE(cmd->DdrMode));
  assert_param(IS_QSPI_DDR_HHC(cmd->DdrHoldHalfCycle));
  assert_param(IS_QSPI_SIOO_MODE(cmd->SIOOMode));

  /* Process locked */
  __HAL_LOCK(hqspi);
24010776:	68fb      	ldr	r3, [r7, #12]
24010778:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2401077c:	b2db      	uxtb	r3, r3
2401077e:	2b01      	cmp	r3, #1
24010780:	d101      	bne.n	24010786 <HAL_QSPI_Command+0x22>
24010782:	2302      	movs	r3, #2
24010784:	e048      	b.n	24010818 <HAL_QSPI_Command+0xb4>
24010786:	68fb      	ldr	r3, [r7, #12]
24010788:	2201      	movs	r2, #1
2401078a:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  if(hqspi->State == HAL_QSPI_STATE_READY)
2401078e:	68fb      	ldr	r3, [r7, #12]
24010790:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
24010794:	b2db      	uxtb	r3, r3
24010796:	2b01      	cmp	r3, #1
24010798:	d137      	bne.n	2401080a <HAL_QSPI_Command+0xa6>
  {
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
2401079a:	68fb      	ldr	r3, [r7, #12]
2401079c:	2200      	movs	r2, #0
2401079e:	645a      	str	r2, [r3, #68]	; 0x44

    /* Update QSPI state */
    hqspi->State = HAL_QSPI_STATE_BUSY;
240107a0:	68fb      	ldr	r3, [r7, #12]
240107a2:	2202      	movs	r2, #2
240107a4:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Wait till BUSY flag reset */
    status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, Timeout);
240107a8:	687b      	ldr	r3, [r7, #4]
240107aa:	9300      	str	r3, [sp, #0]
240107ac:	693b      	ldr	r3, [r7, #16]
240107ae:	2200      	movs	r2, #0
240107b0:	2120      	movs	r1, #32
240107b2:	68f8      	ldr	r0, [r7, #12]
240107b4:	f001 f817 	bl	240117e6 <QSPI_WaitFlagStateUntilTimeout>
240107b8:	4603      	mov	r3, r0
240107ba:	75fb      	strb	r3, [r7, #23]

    if (status == HAL_OK)
240107bc:	7dfb      	ldrb	r3, [r7, #23]
240107be:	2b00      	cmp	r3, #0
240107c0:	d125      	bne.n	2401080e <HAL_QSPI_Command+0xaa>
    {
      /* Call the configuration function */
      QSPI_Config(hqspi, cmd, QSPI_FUNCTIONAL_MODE_INDIRECT_WRITE);
240107c2:	2200      	movs	r2, #0
240107c4:	68b9      	ldr	r1, [r7, #8]
240107c6:	68f8      	ldr	r0, [r7, #12]
240107c8:	f001 f844 	bl	24011854 <QSPI_Config>

      if (cmd->DataMode == QSPI_DATA_NONE)
240107cc:	68bb      	ldr	r3, [r7, #8]
240107ce:	6a5b      	ldr	r3, [r3, #36]	; 0x24
240107d0:	2b00      	cmp	r3, #0
240107d2:	d115      	bne.n	24010800 <HAL_QSPI_Command+0x9c>
      {
        /* When there is no data phase, the transfer start as soon as the configuration is done
        so wait until TC flag is set to go back in idle state */
        status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_TC, SET, tickstart, Timeout);
240107d4:	687b      	ldr	r3, [r7, #4]
240107d6:	9300      	str	r3, [sp, #0]
240107d8:	693b      	ldr	r3, [r7, #16]
240107da:	2201      	movs	r2, #1
240107dc:	2102      	movs	r1, #2
240107de:	68f8      	ldr	r0, [r7, #12]
240107e0:	f001 f801 	bl	240117e6 <QSPI_WaitFlagStateUntilTimeout>
240107e4:	4603      	mov	r3, r0
240107e6:	75fb      	strb	r3, [r7, #23]

        if (status == HAL_OK)
240107e8:	7dfb      	ldrb	r3, [r7, #23]
240107ea:	2b00      	cmp	r3, #0
240107ec:	d10f      	bne.n	2401080e <HAL_QSPI_Command+0xaa>
        {
          __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TC);
240107ee:	68fb      	ldr	r3, [r7, #12]
240107f0:	681b      	ldr	r3, [r3, #0]
240107f2:	2202      	movs	r2, #2
240107f4:	60da      	str	r2, [r3, #12]

          /* Update QSPI state */
          hqspi->State = HAL_QSPI_STATE_READY;
240107f6:	68fb      	ldr	r3, [r7, #12]
240107f8:	2201      	movs	r2, #1
240107fa:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
240107fe:	e006      	b.n	2401080e <HAL_QSPI_Command+0xaa>
        }
      }
      else
      {
        /* Update QSPI state */
        hqspi->State = HAL_QSPI_STATE_READY;
24010800:	68fb      	ldr	r3, [r7, #12]
24010802:	2201      	movs	r2, #1
24010804:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
24010808:	e001      	b.n	2401080e <HAL_QSPI_Command+0xaa>
      }
    }
  }
  else
  {
    status = HAL_BUSY;
2401080a:	2302      	movs	r3, #2
2401080c:	75fb      	strb	r3, [r7, #23]
  }

  /* Process unlocked */
  __HAL_UNLOCK(hqspi);
2401080e:	68fb      	ldr	r3, [r7, #12]
24010810:	2200      	movs	r2, #0
24010812:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  /* Return function status */
  return status;
24010816:	7dfb      	ldrb	r3, [r7, #23]
}
24010818:	4618      	mov	r0, r3
2401081a:	3718      	adds	r7, #24
2401081c:	46bd      	mov	sp, r7
2401081e:	bd80      	pop	{r7, pc}

24010820 <HAL_QSPI_Command_IT>:
  * @param cmd : structure that contains the command configuration information
  * @note   This function is used only in Indirect Read or Write Modes
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_QSPI_Command_IT(QSPI_HandleTypeDef *hqspi, QSPI_CommandTypeDef *cmd)
{
24010820:	b580      	push	{r7, lr}
24010822:	b086      	sub	sp, #24
24010824:	af02      	add	r7, sp, #8
24010826:	6078      	str	r0, [r7, #4]
24010828:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status;
  uint32_t tickstart = HAL_GetTick();
2401082a:	f7f0 f811 	bl	24000850 <HAL_GetTick>
2401082e:	60b8      	str	r0, [r7, #8]
  assert_param(IS_QSPI_DDR_MODE(cmd->DdrMode));
  assert_param(IS_QSPI_DDR_HHC(cmd->DdrHoldHalfCycle));
  assert_param(IS_QSPI_SIOO_MODE(cmd->SIOOMode));

  /* Process locked */
  __HAL_LOCK(hqspi);
24010830:	687b      	ldr	r3, [r7, #4]
24010832:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
24010836:	b2db      	uxtb	r3, r3
24010838:	2b01      	cmp	r3, #1
2401083a:	d101      	bne.n	24010840 <HAL_QSPI_Command_IT+0x20>
2401083c:	2302      	movs	r3, #2
2401083e:	e051      	b.n	240108e4 <HAL_QSPI_Command_IT+0xc4>
24010840:	687b      	ldr	r3, [r7, #4]
24010842:	2201      	movs	r2, #1
24010844:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  if(hqspi->State == HAL_QSPI_STATE_READY)
24010848:	687b      	ldr	r3, [r7, #4]
2401084a:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2401084e:	b2db      	uxtb	r3, r3
24010850:	2b01      	cmp	r3, #1
24010852:	d140      	bne.n	240108d6 <HAL_QSPI_Command_IT+0xb6>
  {
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
24010854:	687b      	ldr	r3, [r7, #4]
24010856:	2200      	movs	r2, #0
24010858:	645a      	str	r2, [r3, #68]	; 0x44

    /* Update QSPI state */
    hqspi->State = HAL_QSPI_STATE_BUSY;
2401085a:	687b      	ldr	r3, [r7, #4]
2401085c:	2202      	movs	r2, #2
2401085e:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Wait till BUSY flag reset */
    status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, hqspi->Timeout);
24010862:	687b      	ldr	r3, [r7, #4]
24010864:	6c9b      	ldr	r3, [r3, #72]	; 0x48
24010866:	9300      	str	r3, [sp, #0]
24010868:	68bb      	ldr	r3, [r7, #8]
2401086a:	2200      	movs	r2, #0
2401086c:	2120      	movs	r1, #32
2401086e:	6878      	ldr	r0, [r7, #4]
24010870:	f000 ffb9 	bl	240117e6 <QSPI_WaitFlagStateUntilTimeout>
24010874:	4603      	mov	r3, r0
24010876:	73fb      	strb	r3, [r7, #15]

    if (status == HAL_OK)
24010878:	7bfb      	ldrb	r3, [r7, #15]
2401087a:	2b00      	cmp	r3, #0
2401087c:	d126      	bne.n	240108cc <HAL_QSPI_Command_IT+0xac>
    {
      if (cmd->DataMode == QSPI_DATA_NONE)
2401087e:	683b      	ldr	r3, [r7, #0]
24010880:	6a5b      	ldr	r3, [r3, #36]	; 0x24
24010882:	2b00      	cmp	r3, #0
24010884:	d103      	bne.n	2401088e <HAL_QSPI_Command_IT+0x6e>
      {
        /* Clear interrupt */
        __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TE | QSPI_FLAG_TC);
24010886:	687b      	ldr	r3, [r7, #4]
24010888:	681b      	ldr	r3, [r3, #0]
2401088a:	2203      	movs	r2, #3
2401088c:	60da      	str	r2, [r3, #12]
      }

      /* Call the configuration function */
      QSPI_Config(hqspi, cmd, QSPI_FUNCTIONAL_MODE_INDIRECT_WRITE);
2401088e:	2200      	movs	r2, #0
24010890:	6839      	ldr	r1, [r7, #0]
24010892:	6878      	ldr	r0, [r7, #4]
24010894:	f000 ffde 	bl	24011854 <QSPI_Config>

      if (cmd->DataMode == QSPI_DATA_NONE)
24010898:	683b      	ldr	r3, [r7, #0]
2401089a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2401089c:	2b00      	cmp	r3, #0
2401089e:	d10c      	bne.n	240108ba <HAL_QSPI_Command_IT+0x9a>
      {
        /* When there is no data phase, the transfer start as soon as the configuration is done
        so activate TC and TE interrupts */
        /* Process unlocked */
        __HAL_UNLOCK(hqspi);
240108a0:	687b      	ldr	r3, [r7, #4]
240108a2:	2200      	movs	r2, #0
240108a4:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

        /* Enable the QSPI Transfer Error Interrupt */
        __HAL_QSPI_ENABLE_IT(hqspi, QSPI_IT_TE | QSPI_IT_TC);
240108a8:	687b      	ldr	r3, [r7, #4]
240108aa:	681b      	ldr	r3, [r3, #0]
240108ac:	681a      	ldr	r2, [r3, #0]
240108ae:	687b      	ldr	r3, [r7, #4]
240108b0:	681b      	ldr	r3, [r3, #0]
240108b2:	f442 3240 	orr.w	r2, r2, #196608	; 0x30000
240108b6:	601a      	str	r2, [r3, #0]
240108b8:	e013      	b.n	240108e2 <HAL_QSPI_Command_IT+0xc2>
      }
      else
      {
        /* Update QSPI state */
        hqspi->State = HAL_QSPI_STATE_READY;
240108ba:	687b      	ldr	r3, [r7, #4]
240108bc:	2201      	movs	r2, #1
240108be:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

        /* Process unlocked */
        __HAL_UNLOCK(hqspi);
240108c2:	687b      	ldr	r3, [r7, #4]
240108c4:	2200      	movs	r2, #0
240108c6:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
240108ca:	e00a      	b.n	240108e2 <HAL_QSPI_Command_IT+0xc2>
      }
    }
    else
    {
      /* Process unlocked */
      __HAL_UNLOCK(hqspi);
240108cc:	687b      	ldr	r3, [r7, #4]
240108ce:	2200      	movs	r2, #0
240108d0:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
240108d4:	e005      	b.n	240108e2 <HAL_QSPI_Command_IT+0xc2>
    }
  }
  else
  {
    status = HAL_BUSY;
240108d6:	2302      	movs	r3, #2
240108d8:	73fb      	strb	r3, [r7, #15]

    /* Process unlocked */
    __HAL_UNLOCK(hqspi);
240108da:	687b      	ldr	r3, [r7, #4]
240108dc:	2200      	movs	r2, #0
240108de:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
  }

  /* Return function status */
  return status;
240108e2:	7bfb      	ldrb	r3, [r7, #15]
}
240108e4:	4618      	mov	r0, r3
240108e6:	3710      	adds	r7, #16
240108e8:	46bd      	mov	sp, r7
240108ea:	bd80      	pop	{r7, pc}

240108ec <HAL_QSPI_Transmit>:
  * @note   This function is used only in Indirect Write Mode
  
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_QSPI_Transmit(QSPI_HandleTypeDef *hqspi, uint8_t *pData, uint32_t Timeout)
{
240108ec:	b580      	push	{r7, lr}
240108ee:	b08a      	sub	sp, #40	; 0x28
240108f0:	af02      	add	r7, sp, #8
240108f2:	60f8      	str	r0, [r7, #12]
240108f4:	60b9      	str	r1, [r7, #8]
240108f6:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
240108f8:	2300      	movs	r3, #0
240108fa:	77fb      	strb	r3, [r7, #31]
  uint32_t tickstart = HAL_GetTick();
240108fc:	f7ef ffa8 	bl	24000850 <HAL_GetTick>
24010900:	61b8      	str	r0, [r7, #24]
  __IO uint32_t *data_reg = &hqspi->Instance->DR;
24010902:	68fb      	ldr	r3, [r7, #12]
24010904:	681b      	ldr	r3, [r3, #0]
24010906:	3320      	adds	r3, #32
24010908:	617b      	str	r3, [r7, #20]

  /* Process locked */
  __HAL_LOCK(hqspi);
2401090a:	68fb      	ldr	r3, [r7, #12]
2401090c:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
24010910:	b2db      	uxtb	r3, r3
24010912:	2b01      	cmp	r3, #1
24010914:	d101      	bne.n	2401091a <HAL_QSPI_Transmit+0x2e>
24010916:	2302      	movs	r3, #2
24010918:	e076      	b.n	24010a08 <HAL_QSPI_Transmit+0x11c>
2401091a:	68fb      	ldr	r3, [r7, #12]
2401091c:	2201      	movs	r2, #1
2401091e:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  if(hqspi->State == HAL_QSPI_STATE_READY)
24010922:	68fb      	ldr	r3, [r7, #12]
24010924:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
24010928:	b2db      	uxtb	r3, r3
2401092a:	2b01      	cmp	r3, #1
2401092c:	d165      	bne.n	240109fa <HAL_QSPI_Transmit+0x10e>
  {
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
2401092e:	68fb      	ldr	r3, [r7, #12]
24010930:	2200      	movs	r2, #0
24010932:	645a      	str	r2, [r3, #68]	; 0x44

    if(pData != NULL )
24010934:	68bb      	ldr	r3, [r7, #8]
24010936:	2b00      	cmp	r3, #0
24010938:	d056      	beq.n	240109e8 <HAL_QSPI_Transmit+0xfc>
    {
      /* Update state */
      hqspi->State = HAL_QSPI_STATE_BUSY_INDIRECT_TX;
2401093a:	68fb      	ldr	r3, [r7, #12]
2401093c:	2212      	movs	r2, #18
2401093e:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

      /* Configure counters and size of the handle */
      hqspi->TxXferCount = READ_REG(hqspi->Instance->DLR) + 1U;
24010942:	68fb      	ldr	r3, [r7, #12]
24010944:	681b      	ldr	r3, [r3, #0]
24010946:	691b      	ldr	r3, [r3, #16]
24010948:	1c5a      	adds	r2, r3, #1
2401094a:	68fb      	ldr	r3, [r7, #12]
2401094c:	62da      	str	r2, [r3, #44]	; 0x2c
      hqspi->TxXferSize = READ_REG(hqspi->Instance->DLR) + 1U;
2401094e:	68fb      	ldr	r3, [r7, #12]
24010950:	681b      	ldr	r3, [r3, #0]
24010952:	691b      	ldr	r3, [r3, #16]
24010954:	1c5a      	adds	r2, r3, #1
24010956:	68fb      	ldr	r3, [r7, #12]
24010958:	629a      	str	r2, [r3, #40]	; 0x28
      hqspi->pTxBuffPtr = pData;
2401095a:	68fb      	ldr	r3, [r7, #12]
2401095c:	68ba      	ldr	r2, [r7, #8]
2401095e:	625a      	str	r2, [r3, #36]	; 0x24

      /* Configure QSPI: CCR register with functional as indirect write */
      MODIFY_REG(hqspi->Instance->CCR, QUADSPI_CCR_FMODE, QSPI_FUNCTIONAL_MODE_INDIRECT_WRITE);
24010960:	68fb      	ldr	r3, [r7, #12]
24010962:	681b      	ldr	r3, [r3, #0]
24010964:	695a      	ldr	r2, [r3, #20]
24010966:	68fb      	ldr	r3, [r7, #12]
24010968:	681b      	ldr	r3, [r3, #0]
2401096a:	f022 6240 	bic.w	r2, r2, #201326592	; 0xc000000
2401096e:	615a      	str	r2, [r3, #20]

      while(hqspi->TxXferCount > 0U)
24010970:	e01b      	b.n	240109aa <HAL_QSPI_Transmit+0xbe>
      {
        /* Wait until FT flag is set to send data */
        status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_FT, SET, tickstart, Timeout);
24010972:	687b      	ldr	r3, [r7, #4]
24010974:	9300      	str	r3, [sp, #0]
24010976:	69bb      	ldr	r3, [r7, #24]
24010978:	2201      	movs	r2, #1
2401097a:	2104      	movs	r1, #4
2401097c:	68f8      	ldr	r0, [r7, #12]
2401097e:	f000 ff32 	bl	240117e6 <QSPI_WaitFlagStateUntilTimeout>
24010982:	4603      	mov	r3, r0
24010984:	77fb      	strb	r3, [r7, #31]

        if (status != HAL_OK)
24010986:	7ffb      	ldrb	r3, [r7, #31]
24010988:	2b00      	cmp	r3, #0
2401098a:	d113      	bne.n	240109b4 <HAL_QSPI_Transmit+0xc8>
        {
          break;
        }

        *((__IO uint8_t *)data_reg) = *hqspi->pTxBuffPtr;
2401098c:	68fb      	ldr	r3, [r7, #12]
2401098e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
24010990:	781a      	ldrb	r2, [r3, #0]
24010992:	697b      	ldr	r3, [r7, #20]
24010994:	701a      	strb	r2, [r3, #0]
        hqspi->pTxBuffPtr++;
24010996:	68fb      	ldr	r3, [r7, #12]
24010998:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2401099a:	1c5a      	adds	r2, r3, #1
2401099c:	68fb      	ldr	r3, [r7, #12]
2401099e:	625a      	str	r2, [r3, #36]	; 0x24
        hqspi->TxXferCount--;
240109a0:	68fb      	ldr	r3, [r7, #12]
240109a2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
240109a4:	1e5a      	subs	r2, r3, #1
240109a6:	68fb      	ldr	r3, [r7, #12]
240109a8:	62da      	str	r2, [r3, #44]	; 0x2c
      while(hqspi->TxXferCount > 0U)
240109aa:	68fb      	ldr	r3, [r7, #12]
240109ac:	6adb      	ldr	r3, [r3, #44]	; 0x2c
240109ae:	2b00      	cmp	r3, #0
240109b0:	d1df      	bne.n	24010972 <HAL_QSPI_Transmit+0x86>
240109b2:	e000      	b.n	240109b6 <HAL_QSPI_Transmit+0xca>
          break;
240109b4:	bf00      	nop
      }

      if (status == HAL_OK)
240109b6:	7ffb      	ldrb	r3, [r7, #31]
240109b8:	2b00      	cmp	r3, #0
240109ba:	d110      	bne.n	240109de <HAL_QSPI_Transmit+0xf2>
      {
        /* Wait until TC flag is set to go back in idle state */
        status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_TC, SET, tickstart, Timeout);
240109bc:	687b      	ldr	r3, [r7, #4]
240109be:	9300      	str	r3, [sp, #0]
240109c0:	69bb      	ldr	r3, [r7, #24]
240109c2:	2201      	movs	r2, #1
240109c4:	2102      	movs	r1, #2
240109c6:	68f8      	ldr	r0, [r7, #12]
240109c8:	f000 ff0d 	bl	240117e6 <QSPI_WaitFlagStateUntilTimeout>
240109cc:	4603      	mov	r3, r0
240109ce:	77fb      	strb	r3, [r7, #31]

        if (status == HAL_OK)
240109d0:	7ffb      	ldrb	r3, [r7, #31]
240109d2:	2b00      	cmp	r3, #0
240109d4:	d103      	bne.n	240109de <HAL_QSPI_Transmit+0xf2>
        {
          /* Clear Transfer Complete bit */
          __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TC);
240109d6:	68fb      	ldr	r3, [r7, #12]
240109d8:	681b      	ldr	r3, [r3, #0]
240109da:	2202      	movs	r2, #2
240109dc:	60da      	str	r2, [r3, #12]

        }
      }

      /* Update QSPI state */
      hqspi->State = HAL_QSPI_STATE_READY;
240109de:	68fb      	ldr	r3, [r7, #12]
240109e0:	2201      	movs	r2, #1
240109e2:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
240109e6:	e00a      	b.n	240109fe <HAL_QSPI_Transmit+0x112>
    }
    else
    {
      hqspi->ErrorCode |= HAL_QSPI_ERROR_INVALID_PARAM;
240109e8:	68fb      	ldr	r3, [r7, #12]
240109ea:	6c5b      	ldr	r3, [r3, #68]	; 0x44
240109ec:	f043 0208 	orr.w	r2, r3, #8
240109f0:	68fb      	ldr	r3, [r7, #12]
240109f2:	645a      	str	r2, [r3, #68]	; 0x44
      status = HAL_ERROR;
240109f4:	2301      	movs	r3, #1
240109f6:	77fb      	strb	r3, [r7, #31]
240109f8:	e001      	b.n	240109fe <HAL_QSPI_Transmit+0x112>
    }
  }
  else
  {
    status = HAL_BUSY;
240109fa:	2302      	movs	r3, #2
240109fc:	77fb      	strb	r3, [r7, #31]
  }

  /* Process unlocked */
  __HAL_UNLOCK(hqspi);
240109fe:	68fb      	ldr	r3, [r7, #12]
24010a00:	2200      	movs	r2, #0
24010a02:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  return status;
24010a06:	7ffb      	ldrb	r3, [r7, #31]
}
24010a08:	4618      	mov	r0, r3
24010a0a:	3720      	adds	r7, #32
24010a0c:	46bd      	mov	sp, r7
24010a0e:	bd80      	pop	{r7, pc}

24010a10 <HAL_QSPI_Receive>:
  * @param Timeout : Timeout duration
  * @note   This function is used only in Indirect Read Mode
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_QSPI_Receive(QSPI_HandleTypeDef *hqspi, uint8_t *pData, uint32_t Timeout)
{
24010a10:	b580      	push	{r7, lr}
24010a12:	b08a      	sub	sp, #40	; 0x28
24010a14:	af02      	add	r7, sp, #8
24010a16:	60f8      	str	r0, [r7, #12]
24010a18:	60b9      	str	r1, [r7, #8]
24010a1a:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
24010a1c:	2300      	movs	r3, #0
24010a1e:	77fb      	strb	r3, [r7, #31]
  uint32_t tickstart = HAL_GetTick();
24010a20:	f7ef ff16 	bl	24000850 <HAL_GetTick>
24010a24:	61b8      	str	r0, [r7, #24]
  uint32_t addr_reg = READ_REG(hqspi->Instance->AR);
24010a26:	68fb      	ldr	r3, [r7, #12]
24010a28:	681b      	ldr	r3, [r3, #0]
24010a2a:	699b      	ldr	r3, [r3, #24]
24010a2c:	617b      	str	r3, [r7, #20]
  __IO uint32_t *data_reg = &hqspi->Instance->DR;
24010a2e:	68fb      	ldr	r3, [r7, #12]
24010a30:	681b      	ldr	r3, [r3, #0]
24010a32:	3320      	adds	r3, #32
24010a34:	613b      	str	r3, [r7, #16]

  /* Process locked */
  __HAL_LOCK(hqspi);
24010a36:	68fb      	ldr	r3, [r7, #12]
24010a38:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
24010a3c:	b2db      	uxtb	r3, r3
24010a3e:	2b01      	cmp	r3, #1
24010a40:	d101      	bne.n	24010a46 <HAL_QSPI_Receive+0x36>
24010a42:	2302      	movs	r3, #2
24010a44:	e07d      	b.n	24010b42 <HAL_QSPI_Receive+0x132>
24010a46:	68fb      	ldr	r3, [r7, #12]
24010a48:	2201      	movs	r2, #1
24010a4a:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  if(hqspi->State == HAL_QSPI_STATE_READY)
24010a4e:	68fb      	ldr	r3, [r7, #12]
24010a50:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
24010a54:	b2db      	uxtb	r3, r3
24010a56:	2b01      	cmp	r3, #1
24010a58:	d16c      	bne.n	24010b34 <HAL_QSPI_Receive+0x124>
  {
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
24010a5a:	68fb      	ldr	r3, [r7, #12]
24010a5c:	2200      	movs	r2, #0
24010a5e:	645a      	str	r2, [r3, #68]	; 0x44

    if(pData != NULL )
24010a60:	68bb      	ldr	r3, [r7, #8]
24010a62:	2b00      	cmp	r3, #0
24010a64:	d05d      	beq.n	24010b22 <HAL_QSPI_Receive+0x112>
    {
      /* Update state */
      hqspi->State = HAL_QSPI_STATE_BUSY_INDIRECT_RX;
24010a66:	68fb      	ldr	r3, [r7, #12]
24010a68:	2222      	movs	r2, #34	; 0x22
24010a6a:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

      /* Configure counters and size of the handle */
      hqspi->RxXferCount = READ_REG(hqspi->Instance->DLR) + 1U;
24010a6e:	68fb      	ldr	r3, [r7, #12]
24010a70:	681b      	ldr	r3, [r3, #0]
24010a72:	691b      	ldr	r3, [r3, #16]
24010a74:	1c5a      	adds	r2, r3, #1
24010a76:	68fb      	ldr	r3, [r7, #12]
24010a78:	639a      	str	r2, [r3, #56]	; 0x38
      hqspi->RxXferSize = READ_REG(hqspi->Instance->DLR) + 1U;
24010a7a:	68fb      	ldr	r3, [r7, #12]
24010a7c:	681b      	ldr	r3, [r3, #0]
24010a7e:	691b      	ldr	r3, [r3, #16]
24010a80:	1c5a      	adds	r2, r3, #1
24010a82:	68fb      	ldr	r3, [r7, #12]
24010a84:	635a      	str	r2, [r3, #52]	; 0x34
      hqspi->pRxBuffPtr = pData;
24010a86:	68fb      	ldr	r3, [r7, #12]
24010a88:	68ba      	ldr	r2, [r7, #8]
24010a8a:	631a      	str	r2, [r3, #48]	; 0x30

      /* Configure QSPI: CCR register with functional as indirect read */
      MODIFY_REG(hqspi->Instance->CCR, QUADSPI_CCR_FMODE, QSPI_FUNCTIONAL_MODE_INDIRECT_READ);
24010a8c:	68fb      	ldr	r3, [r7, #12]
24010a8e:	681b      	ldr	r3, [r3, #0]
24010a90:	695b      	ldr	r3, [r3, #20]
24010a92:	f023 6240 	bic.w	r2, r3, #201326592	; 0xc000000
24010a96:	68fb      	ldr	r3, [r7, #12]
24010a98:	681b      	ldr	r3, [r3, #0]
24010a9a:	f042 6280 	orr.w	r2, r2, #67108864	; 0x4000000
24010a9e:	615a      	str	r2, [r3, #20]

      /* Start the transfer by re-writing the address in AR register */
      WRITE_REG(hqspi->Instance->AR, addr_reg);
24010aa0:	68fb      	ldr	r3, [r7, #12]
24010aa2:	681b      	ldr	r3, [r3, #0]
24010aa4:	697a      	ldr	r2, [r7, #20]
24010aa6:	619a      	str	r2, [r3, #24]

      while(hqspi->RxXferCount > 0U)
24010aa8:	e01c      	b.n	24010ae4 <HAL_QSPI_Receive+0xd4>
      {
        /* Wait until FT or TC flag is set to read received data */
        status = QSPI_WaitFlagStateUntilTimeout(hqspi, (QSPI_FLAG_FT | QSPI_FLAG_TC), SET, tickstart, Timeout);
24010aaa:	687b      	ldr	r3, [r7, #4]
24010aac:	9300      	str	r3, [sp, #0]
24010aae:	69bb      	ldr	r3, [r7, #24]
24010ab0:	2201      	movs	r2, #1
24010ab2:	2106      	movs	r1, #6
24010ab4:	68f8      	ldr	r0, [r7, #12]
24010ab6:	f000 fe96 	bl	240117e6 <QSPI_WaitFlagStateUntilTimeout>
24010aba:	4603      	mov	r3, r0
24010abc:	77fb      	strb	r3, [r7, #31]

        if  (status != HAL_OK)
24010abe:	7ffb      	ldrb	r3, [r7, #31]
24010ac0:	2b00      	cmp	r3, #0
24010ac2:	d114      	bne.n	24010aee <HAL_QSPI_Receive+0xde>
        {
          break;
        }

        *hqspi->pRxBuffPtr = *((__IO uint8_t *)data_reg);
24010ac4:	68fb      	ldr	r3, [r7, #12]
24010ac6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24010ac8:	693a      	ldr	r2, [r7, #16]
24010aca:	7812      	ldrb	r2, [r2, #0]
24010acc:	b2d2      	uxtb	r2, r2
24010ace:	701a      	strb	r2, [r3, #0]
        hqspi->pRxBuffPtr++;
24010ad0:	68fb      	ldr	r3, [r7, #12]
24010ad2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24010ad4:	1c5a      	adds	r2, r3, #1
24010ad6:	68fb      	ldr	r3, [r7, #12]
24010ad8:	631a      	str	r2, [r3, #48]	; 0x30
        hqspi->RxXferCount--;
24010ada:	68fb      	ldr	r3, [r7, #12]
24010adc:	6b9b      	ldr	r3, [r3, #56]	; 0x38
24010ade:	1e5a      	subs	r2, r3, #1
24010ae0:	68fb      	ldr	r3, [r7, #12]
24010ae2:	639a      	str	r2, [r3, #56]	; 0x38
      while(hqspi->RxXferCount > 0U)
24010ae4:	68fb      	ldr	r3, [r7, #12]
24010ae6:	6b9b      	ldr	r3, [r3, #56]	; 0x38
24010ae8:	2b00      	cmp	r3, #0
24010aea:	d1de      	bne.n	24010aaa <HAL_QSPI_Receive+0x9a>
24010aec:	e000      	b.n	24010af0 <HAL_QSPI_Receive+0xe0>
          break;
24010aee:	bf00      	nop
      }

      if (status == HAL_OK)
24010af0:	7ffb      	ldrb	r3, [r7, #31]
24010af2:	2b00      	cmp	r3, #0
24010af4:	d110      	bne.n	24010b18 <HAL_QSPI_Receive+0x108>
      {
        /* Wait until TC flag is set to go back in idle state */
        status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_TC, SET, tickstart, Timeout);
24010af6:	687b      	ldr	r3, [r7, #4]
24010af8:	9300      	str	r3, [sp, #0]
24010afa:	69bb      	ldr	r3, [r7, #24]
24010afc:	2201      	movs	r2, #1
24010afe:	2102      	movs	r1, #2
24010b00:	68f8      	ldr	r0, [r7, #12]
24010b02:	f000 fe70 	bl	240117e6 <QSPI_WaitFlagStateUntilTimeout>
24010b06:	4603      	mov	r3, r0
24010b08:	77fb      	strb	r3, [r7, #31]

        if  (status == HAL_OK)
24010b0a:	7ffb      	ldrb	r3, [r7, #31]
24010b0c:	2b00      	cmp	r3, #0
24010b0e:	d103      	bne.n	24010b18 <HAL_QSPI_Receive+0x108>
        {
          /* Clear Transfer Complete bit */
          __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TC);
24010b10:	68fb      	ldr	r3, [r7, #12]
24010b12:	681b      	ldr	r3, [r3, #0]
24010b14:	2202      	movs	r2, #2
24010b16:	60da      	str	r2, [r3, #12]

        }
      }

      /* Update QSPI state */
      hqspi->State = HAL_QSPI_STATE_READY;
24010b18:	68fb      	ldr	r3, [r7, #12]
24010b1a:	2201      	movs	r2, #1
24010b1c:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
24010b20:	e00a      	b.n	24010b38 <HAL_QSPI_Receive+0x128>
    }
    else
    {
      hqspi->ErrorCode |= HAL_QSPI_ERROR_INVALID_PARAM;
24010b22:	68fb      	ldr	r3, [r7, #12]
24010b24:	6c5b      	ldr	r3, [r3, #68]	; 0x44
24010b26:	f043 0208 	orr.w	r2, r3, #8
24010b2a:	68fb      	ldr	r3, [r7, #12]
24010b2c:	645a      	str	r2, [r3, #68]	; 0x44
      status = HAL_ERROR;
24010b2e:	2301      	movs	r3, #1
24010b30:	77fb      	strb	r3, [r7, #31]
24010b32:	e001      	b.n	24010b38 <HAL_QSPI_Receive+0x128>
    }
  }
  else
  {
    status = HAL_BUSY;
24010b34:	2302      	movs	r3, #2
24010b36:	77fb      	strb	r3, [r7, #31]
  }

  /* Process unlocked */
  __HAL_UNLOCK(hqspi);
24010b38:	68fb      	ldr	r3, [r7, #12]
24010b3a:	2200      	movs	r2, #0
24010b3c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  return status;
24010b40:	7ffb      	ldrb	r3, [r7, #31]
}
24010b42:	4618      	mov	r0, r3
24010b44:	3720      	adds	r7, #32
24010b46:	46bd      	mov	sp, r7
24010b48:	bd80      	pop	{r7, pc}

24010b4a <HAL_QSPI_Transmit_IT>:
  * @param  pData : pointer to data buffer
  * @note   This function is used only in Indirect Write Mode
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_QSPI_Transmit_IT(QSPI_HandleTypeDef *hqspi, uint8_t *pData)
{
24010b4a:	b480      	push	{r7}
24010b4c:	b085      	sub	sp, #20
24010b4e:	af00      	add	r7, sp, #0
24010b50:	6078      	str	r0, [r7, #4]
24010b52:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
24010b54:	2300      	movs	r3, #0
24010b56:	73fb      	strb	r3, [r7, #15]

  /* Process locked */
  __HAL_LOCK(hqspi);
24010b58:	687b      	ldr	r3, [r7, #4]
24010b5a:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
24010b5e:	b2db      	uxtb	r3, r3
24010b60:	2b01      	cmp	r3, #1
24010b62:	d101      	bne.n	24010b68 <HAL_QSPI_Transmit_IT+0x1e>
24010b64:	2302      	movs	r3, #2
24010b66:	e04f      	b.n	24010c08 <HAL_QSPI_Transmit_IT+0xbe>
24010b68:	687b      	ldr	r3, [r7, #4]
24010b6a:	2201      	movs	r2, #1
24010b6c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  if(hqspi->State == HAL_QSPI_STATE_READY)
24010b70:	687b      	ldr	r3, [r7, #4]
24010b72:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
24010b76:	b2db      	uxtb	r3, r3
24010b78:	2b01      	cmp	r3, #1
24010b7a:	d13e      	bne.n	24010bfa <HAL_QSPI_Transmit_IT+0xb0>
  {
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
24010b7c:	687b      	ldr	r3, [r7, #4]
24010b7e:	2200      	movs	r2, #0
24010b80:	645a      	str	r2, [r3, #68]	; 0x44

    if(pData != NULL )
24010b82:	683b      	ldr	r3, [r7, #0]
24010b84:	2b00      	cmp	r3, #0
24010b86:	d02b      	beq.n	24010be0 <HAL_QSPI_Transmit_IT+0x96>
    {
      /* Update state */
      hqspi->State = HAL_QSPI_STATE_BUSY_INDIRECT_TX;
24010b88:	687b      	ldr	r3, [r7, #4]
24010b8a:	2212      	movs	r2, #18
24010b8c:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

      /* Configure counters and size of the handle */
      hqspi->TxXferCount = READ_REG(hqspi->Instance->DLR) + 1U;
24010b90:	687b      	ldr	r3, [r7, #4]
24010b92:	681b      	ldr	r3, [r3, #0]
24010b94:	691b      	ldr	r3, [r3, #16]
24010b96:	1c5a      	adds	r2, r3, #1
24010b98:	687b      	ldr	r3, [r7, #4]
24010b9a:	62da      	str	r2, [r3, #44]	; 0x2c
      hqspi->TxXferSize = READ_REG(hqspi->Instance->DLR) + 1U;
24010b9c:	687b      	ldr	r3, [r7, #4]
24010b9e:	681b      	ldr	r3, [r3, #0]
24010ba0:	691b      	ldr	r3, [r3, #16]
24010ba2:	1c5a      	adds	r2, r3, #1
24010ba4:	687b      	ldr	r3, [r7, #4]
24010ba6:	629a      	str	r2, [r3, #40]	; 0x28
      hqspi->pTxBuffPtr = pData;
24010ba8:	687b      	ldr	r3, [r7, #4]
24010baa:	683a      	ldr	r2, [r7, #0]
24010bac:	625a      	str	r2, [r3, #36]	; 0x24

      /* Clear interrupt */
      __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TE | QSPI_FLAG_TC);
24010bae:	687b      	ldr	r3, [r7, #4]
24010bb0:	681b      	ldr	r3, [r3, #0]
24010bb2:	2203      	movs	r2, #3
24010bb4:	60da      	str	r2, [r3, #12]

      /* Configure QSPI: CCR register with functional as indirect write */
      MODIFY_REG(hqspi->Instance->CCR, QUADSPI_CCR_FMODE, QSPI_FUNCTIONAL_MODE_INDIRECT_WRITE);
24010bb6:	687b      	ldr	r3, [r7, #4]
24010bb8:	681b      	ldr	r3, [r3, #0]
24010bba:	695a      	ldr	r2, [r3, #20]
24010bbc:	687b      	ldr	r3, [r7, #4]
24010bbe:	681b      	ldr	r3, [r3, #0]
24010bc0:	f022 6240 	bic.w	r2, r2, #201326592	; 0xc000000
24010bc4:	615a      	str	r2, [r3, #20]

      /* Process unlocked */
      __HAL_UNLOCK(hqspi);
24010bc6:	687b      	ldr	r3, [r7, #4]
24010bc8:	2200      	movs	r2, #0
24010bca:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

      /* Enable the QSPI transfer error, FIFO threshold and transfer complete Interrupts */
      __HAL_QSPI_ENABLE_IT(hqspi, QSPI_IT_TE | QSPI_IT_FT | QSPI_IT_TC);
24010bce:	687b      	ldr	r3, [r7, #4]
24010bd0:	681b      	ldr	r3, [r3, #0]
24010bd2:	681a      	ldr	r2, [r3, #0]
24010bd4:	687b      	ldr	r3, [r7, #4]
24010bd6:	681b      	ldr	r3, [r3, #0]
24010bd8:	f442 22e0 	orr.w	r2, r2, #458752	; 0x70000
24010bdc:	601a      	str	r2, [r3, #0]
24010bde:	e012      	b.n	24010c06 <HAL_QSPI_Transmit_IT+0xbc>
    }
    else
    {
      hqspi->ErrorCode |= HAL_QSPI_ERROR_INVALID_PARAM;
24010be0:	687b      	ldr	r3, [r7, #4]
24010be2:	6c5b      	ldr	r3, [r3, #68]	; 0x44
24010be4:	f043 0208 	orr.w	r2, r3, #8
24010be8:	687b      	ldr	r3, [r7, #4]
24010bea:	645a      	str	r2, [r3, #68]	; 0x44
      status = HAL_ERROR;
24010bec:	2301      	movs	r3, #1
24010bee:	73fb      	strb	r3, [r7, #15]

      /* Process unlocked */
      __HAL_UNLOCK(hqspi);
24010bf0:	687b      	ldr	r3, [r7, #4]
24010bf2:	2200      	movs	r2, #0
24010bf4:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
24010bf8:	e005      	b.n	24010c06 <HAL_QSPI_Transmit_IT+0xbc>
    }
  }
  else
  {
    status = HAL_BUSY;
24010bfa:	2302      	movs	r3, #2
24010bfc:	73fb      	strb	r3, [r7, #15]

    /* Process unlocked */
    __HAL_UNLOCK(hqspi);
24010bfe:	687b      	ldr	r3, [r7, #4]
24010c00:	2200      	movs	r2, #0
24010c02:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
  }

  return status;
24010c06:	7bfb      	ldrb	r3, [r7, #15]
}
24010c08:	4618      	mov	r0, r3
24010c0a:	3714      	adds	r7, #20
24010c0c:	46bd      	mov	sp, r7
24010c0e:	f85d 7b04 	ldr.w	r7, [sp], #4
24010c12:	4770      	bx	lr

24010c14 <HAL_QSPI_Receive_IT>:
  * @param  pData : pointer to data buffer
  * @note   This function is used only in Indirect Read Mode
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_QSPI_Receive_IT(QSPI_HandleTypeDef *hqspi, uint8_t *pData)
{
24010c14:	b480      	push	{r7}
24010c16:	b085      	sub	sp, #20
24010c18:	af00      	add	r7, sp, #0
24010c1a:	6078      	str	r0, [r7, #4]
24010c1c:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
24010c1e:	2300      	movs	r3, #0
24010c20:	73fb      	strb	r3, [r7, #15]
  uint32_t addr_reg = READ_REG(hqspi->Instance->AR);
24010c22:	687b      	ldr	r3, [r7, #4]
24010c24:	681b      	ldr	r3, [r3, #0]
24010c26:	699b      	ldr	r3, [r3, #24]
24010c28:	60bb      	str	r3, [r7, #8]

  /* Process locked */
  __HAL_LOCK(hqspi);
24010c2a:	687b      	ldr	r3, [r7, #4]
24010c2c:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
24010c30:	b2db      	uxtb	r3, r3
24010c32:	2b01      	cmp	r3, #1
24010c34:	d101      	bne.n	24010c3a <HAL_QSPI_Receive_IT+0x26>
24010c36:	2302      	movs	r3, #2
24010c38:	e055      	b.n	24010ce6 <HAL_QSPI_Receive_IT+0xd2>
24010c3a:	687b      	ldr	r3, [r7, #4]
24010c3c:	2201      	movs	r2, #1
24010c3e:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  if(hqspi->State == HAL_QSPI_STATE_READY)
24010c42:	687b      	ldr	r3, [r7, #4]
24010c44:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
24010c48:	b2db      	uxtb	r3, r3
24010c4a:	2b01      	cmp	r3, #1
24010c4c:	d144      	bne.n	24010cd8 <HAL_QSPI_Receive_IT+0xc4>
  {
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
24010c4e:	687b      	ldr	r3, [r7, #4]
24010c50:	2200      	movs	r2, #0
24010c52:	645a      	str	r2, [r3, #68]	; 0x44

    if(pData != NULL )
24010c54:	683b      	ldr	r3, [r7, #0]
24010c56:	2b00      	cmp	r3, #0
24010c58:	d031      	beq.n	24010cbe <HAL_QSPI_Receive_IT+0xaa>
    {
      /* Update state */
      hqspi->State = HAL_QSPI_STATE_BUSY_INDIRECT_RX;
24010c5a:	687b      	ldr	r3, [r7, #4]
24010c5c:	2222      	movs	r2, #34	; 0x22
24010c5e:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

      /* Configure counters and size of the handle */
      hqspi->RxXferCount = READ_REG(hqspi->Instance->DLR) + 1U;
24010c62:	687b      	ldr	r3, [r7, #4]
24010c64:	681b      	ldr	r3, [r3, #0]
24010c66:	691b      	ldr	r3, [r3, #16]
24010c68:	1c5a      	adds	r2, r3, #1
24010c6a:	687b      	ldr	r3, [r7, #4]
24010c6c:	639a      	str	r2, [r3, #56]	; 0x38
      hqspi->RxXferSize = READ_REG(hqspi->Instance->DLR) + 1U;
24010c6e:	687b      	ldr	r3, [r7, #4]
24010c70:	681b      	ldr	r3, [r3, #0]
24010c72:	691b      	ldr	r3, [r3, #16]
24010c74:	1c5a      	adds	r2, r3, #1
24010c76:	687b      	ldr	r3, [r7, #4]
24010c78:	635a      	str	r2, [r3, #52]	; 0x34
      hqspi->pRxBuffPtr = pData;
24010c7a:	687b      	ldr	r3, [r7, #4]
24010c7c:	683a      	ldr	r2, [r7, #0]
24010c7e:	631a      	str	r2, [r3, #48]	; 0x30

      /* Clear interrupt */
      __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TE | QSPI_FLAG_TC);
24010c80:	687b      	ldr	r3, [r7, #4]
24010c82:	681b      	ldr	r3, [r3, #0]
24010c84:	2203      	movs	r2, #3
24010c86:	60da      	str	r2, [r3, #12]

      /* Configure QSPI: CCR register with functional as indirect read */
      MODIFY_REG(hqspi->Instance->CCR, QUADSPI_CCR_FMODE, QSPI_FUNCTIONAL_MODE_INDIRECT_READ);
24010c88:	687b      	ldr	r3, [r7, #4]
24010c8a:	681b      	ldr	r3, [r3, #0]
24010c8c:	695b      	ldr	r3, [r3, #20]
24010c8e:	f023 6240 	bic.w	r2, r3, #201326592	; 0xc000000
24010c92:	687b      	ldr	r3, [r7, #4]
24010c94:	681b      	ldr	r3, [r3, #0]
24010c96:	f042 6280 	orr.w	r2, r2, #67108864	; 0x4000000
24010c9a:	615a      	str	r2, [r3, #20]

      /* Start the transfer by re-writing the address in AR register */
      WRITE_REG(hqspi->Instance->AR, addr_reg);
24010c9c:	687b      	ldr	r3, [r7, #4]
24010c9e:	681b      	ldr	r3, [r3, #0]
24010ca0:	68ba      	ldr	r2, [r7, #8]
24010ca2:	619a      	str	r2, [r3, #24]

      /* Process unlocked */
      __HAL_UNLOCK(hqspi);
24010ca4:	687b      	ldr	r3, [r7, #4]
24010ca6:	2200      	movs	r2, #0
24010ca8:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

      /* Enable the QSPI transfer error, FIFO threshold and transfer complete Interrupts */
      __HAL_QSPI_ENABLE_IT(hqspi, QSPI_IT_TE | QSPI_IT_FT | QSPI_IT_TC);
24010cac:	687b      	ldr	r3, [r7, #4]
24010cae:	681b      	ldr	r3, [r3, #0]
24010cb0:	681a      	ldr	r2, [r3, #0]
24010cb2:	687b      	ldr	r3, [r7, #4]
24010cb4:	681b      	ldr	r3, [r3, #0]
24010cb6:	f442 22e0 	orr.w	r2, r2, #458752	; 0x70000
24010cba:	601a      	str	r2, [r3, #0]
24010cbc:	e012      	b.n	24010ce4 <HAL_QSPI_Receive_IT+0xd0>
    }
    else
    {
      hqspi->ErrorCode |= HAL_QSPI_ERROR_INVALID_PARAM;
24010cbe:	687b      	ldr	r3, [r7, #4]
24010cc0:	6c5b      	ldr	r3, [r3, #68]	; 0x44
24010cc2:	f043 0208 	orr.w	r2, r3, #8
24010cc6:	687b      	ldr	r3, [r7, #4]
24010cc8:	645a      	str	r2, [r3, #68]	; 0x44
      status = HAL_ERROR;
24010cca:	2301      	movs	r3, #1
24010ccc:	73fb      	strb	r3, [r7, #15]

      /* Process unlocked */
      __HAL_UNLOCK(hqspi);
24010cce:	687b      	ldr	r3, [r7, #4]
24010cd0:	2200      	movs	r2, #0
24010cd2:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
24010cd6:	e005      	b.n	24010ce4 <HAL_QSPI_Receive_IT+0xd0>
    }
  }
  else
  {
    status = HAL_BUSY;
24010cd8:	2302      	movs	r3, #2
24010cda:	73fb      	strb	r3, [r7, #15]

    /* Process unlocked */
    __HAL_UNLOCK(hqspi);
24010cdc:	687b      	ldr	r3, [r7, #4]
24010cde:	2200      	movs	r2, #0
24010ce0:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
  }

  return status;
24010ce4:	7bfb      	ldrb	r3, [r7, #15]
}
24010ce6:	4618      	mov	r0, r3
24010ce8:	3714      	adds	r7, #20
24010cea:	46bd      	mov	sp, r7
24010cec:	f85d 7b04 	ldr.w	r7, [sp], #4
24010cf0:	4770      	bx	lr
	...

24010cf4 <HAL_QSPI_Transmit_DMA>:
  * @param  pData : pointer to data buffer
  * @note   This function is used only in Indirect Write Mode
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_QSPI_Transmit_DMA(QSPI_HandleTypeDef *hqspi, uint8_t *pData)
{
24010cf4:	b590      	push	{r4, r7, lr}
24010cf6:	b087      	sub	sp, #28
24010cf8:	af02      	add	r7, sp, #8
24010cfa:	6078      	str	r0, [r7, #4]
24010cfc:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
24010cfe:	2300      	movs	r3, #0
24010d00:	73fb      	strb	r3, [r7, #15]
  uint32_t data_size = (READ_REG(hqspi->Instance->DLR) + 1U);
24010d02:	687b      	ldr	r3, [r7, #4]
24010d04:	681b      	ldr	r3, [r3, #0]
24010d06:	691b      	ldr	r3, [r3, #16]
24010d08:	3301      	adds	r3, #1
24010d0a:	60bb      	str	r3, [r7, #8]

  /* Process locked */
  __HAL_LOCK(hqspi);
24010d0c:	687b      	ldr	r3, [r7, #4]
24010d0e:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
24010d12:	b2db      	uxtb	r3, r3
24010d14:	2b01      	cmp	r3, #1
24010d16:	d101      	bne.n	24010d1c <HAL_QSPI_Transmit_DMA+0x28>
24010d18:	2302      	movs	r3, #2
24010d1a:	e0cc      	b.n	24010eb6 <HAL_QSPI_Transmit_DMA+0x1c2>
24010d1c:	687b      	ldr	r3, [r7, #4]
24010d1e:	2201      	movs	r2, #1
24010d20:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  if(hqspi->State == HAL_QSPI_STATE_READY)
24010d24:	687b      	ldr	r3, [r7, #4]
24010d26:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
24010d2a:	b2db      	uxtb	r3, r3
24010d2c:	2b01      	cmp	r3, #1
24010d2e:	f040 80bb 	bne.w	24010ea8 <HAL_QSPI_Transmit_DMA+0x1b4>
  {
    /* Clear the error code */
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
24010d32:	687b      	ldr	r3, [r7, #4]
24010d34:	2200      	movs	r2, #0
24010d36:	645a      	str	r2, [r3, #68]	; 0x44

    if(pData != NULL )
24010d38:	683b      	ldr	r3, [r7, #0]
24010d3a:	2b00      	cmp	r3, #0
24010d3c:	f000 80a7 	beq.w	24010e8e <HAL_QSPI_Transmit_DMA+0x19a>
    {
      /* Configure counters of the handle */
      hqspi->TxXferCount = data_size;
24010d40:	687b      	ldr	r3, [r7, #4]
24010d42:	68ba      	ldr	r2, [r7, #8]
24010d44:	62da      	str	r2, [r3, #44]	; 0x2c

        /* Update state */
        hqspi->State = HAL_QSPI_STATE_BUSY_INDIRECT_TX;
24010d46:	687b      	ldr	r3, [r7, #4]
24010d48:	2212      	movs	r2, #18
24010d4a:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

        /* Clear interrupt */
        __HAL_QSPI_CLEAR_FLAG(hqspi, (QSPI_FLAG_TE | QSPI_FLAG_TC));
24010d4e:	687b      	ldr	r3, [r7, #4]
24010d50:	681b      	ldr	r3, [r3, #0]
24010d52:	2203      	movs	r2, #3
24010d54:	60da      	str	r2, [r3, #12]

        /* Configure size and pointer of the handle */
        hqspi->TxXferSize = hqspi->TxXferCount;
24010d56:	687b      	ldr	r3, [r7, #4]
24010d58:	6ada      	ldr	r2, [r3, #44]	; 0x2c
24010d5a:	687b      	ldr	r3, [r7, #4]
24010d5c:	629a      	str	r2, [r3, #40]	; 0x28
        hqspi->pTxBuffPtr = pData;
24010d5e:	687b      	ldr	r3, [r7, #4]
24010d60:	683a      	ldr	r2, [r7, #0]
24010d62:	625a      	str	r2, [r3, #36]	; 0x24

        /* Configure QSPI: CCR register with functional mode as indirect write */
        MODIFY_REG(hqspi->Instance->CCR, QUADSPI_CCR_FMODE, QSPI_FUNCTIONAL_MODE_INDIRECT_WRITE);
24010d64:	687b      	ldr	r3, [r7, #4]
24010d66:	681b      	ldr	r3, [r3, #0]
24010d68:	695a      	ldr	r2, [r3, #20]
24010d6a:	687b      	ldr	r3, [r7, #4]
24010d6c:	681b      	ldr	r3, [r3, #0]
24010d6e:	f022 6240 	bic.w	r2, r2, #201326592	; 0xc000000
24010d72:	615a      	str	r2, [r3, #20]

        /* Set the QSPI MDMA transfer complete callback */
        hqspi->hmdma->XferCpltCallback = QSPI_DMATxCplt;
24010d74:	687b      	ldr	r3, [r7, #4]
24010d76:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24010d78:	4a51      	ldr	r2, [pc, #324]	; (24010ec0 <HAL_QSPI_Transmit_DMA+0x1cc>)
24010d7a:	645a      	str	r2, [r3, #68]	; 0x44

        /* Set the MDMA error callback */
        hqspi->hmdma->XferErrorCallback = QSPI_DMAError;
24010d7c:	687b      	ldr	r3, [r7, #4]
24010d7e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24010d80:	4a50      	ldr	r2, [pc, #320]	; (24010ec4 <HAL_QSPI_Transmit_DMA+0x1d0>)
24010d82:	655a      	str	r2, [r3, #84]	; 0x54

        /* Clear the MDMA abort callback */
        hqspi->hmdma->XferAbortCallback = NULL;
24010d84:	687b      	ldr	r3, [r7, #4]
24010d86:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24010d88:	2200      	movs	r2, #0
24010d8a:	659a      	str	r2, [r3, #88]	; 0x58

        /* In Transmit mode , the MDMA destination is the QSPI DR register : Force the MDMA Destination Increment to disable */
        MODIFY_REG(hqspi->hmdma->Instance->CTCR, (MDMA_CTCR_DINC | MDMA_CTCR_DINCOS) ,MDMA_DEST_INC_DISABLE);
24010d8c:	687b      	ldr	r3, [r7, #4]
24010d8e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24010d90:	681b      	ldr	r3, [r3, #0]
24010d92:	6919      	ldr	r1, [r3, #16]
24010d94:	687b      	ldr	r3, [r7, #4]
24010d96:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24010d98:	681a      	ldr	r2, [r3, #0]
24010d9a:	4b4b      	ldr	r3, [pc, #300]	; (24010ec8 <HAL_QSPI_Transmit_DMA+0x1d4>)
24010d9c:	400b      	ands	r3, r1
24010d9e:	6113      	str	r3, [r2, #16]

        /* Update MDMA configuration with the correct SourceInc field for Write operation */
        if (hqspi->hmdma->Init.SourceDataSize == MDMA_SRC_DATASIZE_BYTE)
24010da0:	687b      	ldr	r3, [r7, #4]
24010da2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24010da4:	69db      	ldr	r3, [r3, #28]
24010da6:	2b00      	cmp	r3, #0
24010da8:	d10c      	bne.n	24010dc4 <HAL_QSPI_Transmit_DMA+0xd0>
        {
          MODIFY_REG(hqspi->hmdma->Instance->CTCR, (MDMA_CTCR_SINC | MDMA_CTCR_SINCOS) , MDMA_SRC_INC_BYTE);
24010daa:	687b      	ldr	r3, [r7, #4]
24010dac:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24010dae:	681b      	ldr	r3, [r3, #0]
24010db0:	691a      	ldr	r2, [r3, #16]
24010db2:	4b46      	ldr	r3, [pc, #280]	; (24010ecc <HAL_QSPI_Transmit_DMA+0x1d8>)
24010db4:	4013      	ands	r3, r2
24010db6:	687a      	ldr	r2, [r7, #4]
24010db8:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
24010dba:	6812      	ldr	r2, [r2, #0]
24010dbc:	f043 0302 	orr.w	r3, r3, #2
24010dc0:	6113      	str	r3, [r2, #16]
24010dc2:	e02c      	b.n	24010e1e <HAL_QSPI_Transmit_DMA+0x12a>
        }
        else if (hqspi->hmdma->Init.SourceDataSize == MDMA_SRC_DATASIZE_HALFWORD)
24010dc4:	687b      	ldr	r3, [r7, #4]
24010dc6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24010dc8:	69db      	ldr	r3, [r3, #28]
24010dca:	2b10      	cmp	r3, #16
24010dcc:	d10c      	bne.n	24010de8 <HAL_QSPI_Transmit_DMA+0xf4>
        {
          MODIFY_REG(hqspi->hmdma->Instance->CTCR, (MDMA_CTCR_SINC | MDMA_CTCR_SINCOS) , MDMA_SRC_INC_HALFWORD);
24010dce:	687b      	ldr	r3, [r7, #4]
24010dd0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24010dd2:	681b      	ldr	r3, [r3, #0]
24010dd4:	691a      	ldr	r2, [r3, #16]
24010dd6:	4b3d      	ldr	r3, [pc, #244]	; (24010ecc <HAL_QSPI_Transmit_DMA+0x1d8>)
24010dd8:	4013      	ands	r3, r2
24010dda:	687a      	ldr	r2, [r7, #4]
24010ddc:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
24010dde:	6812      	ldr	r2, [r2, #0]
24010de0:	f443 7381 	orr.w	r3, r3, #258	; 0x102
24010de4:	6113      	str	r3, [r2, #16]
24010de6:	e01a      	b.n	24010e1e <HAL_QSPI_Transmit_DMA+0x12a>
        }
        else if (hqspi->hmdma->Init.SourceDataSize == MDMA_SRC_DATASIZE_WORD)
24010de8:	687b      	ldr	r3, [r7, #4]
24010dea:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24010dec:	69db      	ldr	r3, [r3, #28]
24010dee:	2b20      	cmp	r3, #32
24010df0:	d10d      	bne.n	24010e0e <HAL_QSPI_Transmit_DMA+0x11a>
        {
          MODIFY_REG(hqspi->hmdma->Instance->CTCR, (MDMA_CTCR_SINC | MDMA_CTCR_SINCOS) , MDMA_SRC_INC_WORD);
24010df2:	687b      	ldr	r3, [r7, #4]
24010df4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24010df6:	681b      	ldr	r3, [r3, #0]
24010df8:	691b      	ldr	r3, [r3, #16]
24010dfa:	4a34      	ldr	r2, [pc, #208]	; (24010ecc <HAL_QSPI_Transmit_DMA+0x1d8>)
24010dfc:	401a      	ands	r2, r3
24010dfe:	687b      	ldr	r3, [r7, #4]
24010e00:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24010e02:	6819      	ldr	r1, [r3, #0]
24010e04:	f240 2302 	movw	r3, #514	; 0x202
24010e08:	4313      	orrs	r3, r2
24010e0a:	610b      	str	r3, [r1, #16]
24010e0c:	e007      	b.n	24010e1e <HAL_QSPI_Transmit_DMA+0x12a>
        }
        else
        {
          /* in case of incorrect source data size */
          hqspi->ErrorCode |= HAL_QSPI_ERROR_DMA;
24010e0e:	687b      	ldr	r3, [r7, #4]
24010e10:	6c5b      	ldr	r3, [r3, #68]	; 0x44
24010e12:	f043 0204 	orr.w	r2, r3, #4
24010e16:	687b      	ldr	r3, [r7, #4]
24010e18:	645a      	str	r2, [r3, #68]	; 0x44
          status = HAL_ERROR;
24010e1a:	2301      	movs	r3, #1
24010e1c:	73fb      	strb	r3, [r7, #15]
        }

        /* Enable the QSPI transmit MDMA */
        if (HAL_MDMA_Start_IT(hqspi->hmdma, (uint32_t)pData, (uint32_t)&hqspi->Instance->DR, hqspi->TxXferSize, 1) == HAL_OK)
24010e1e:	687b      	ldr	r3, [r7, #4]
24010e20:	6bd8      	ldr	r0, [r3, #60]	; 0x3c
24010e22:	6839      	ldr	r1, [r7, #0]
24010e24:	687b      	ldr	r3, [r7, #4]
24010e26:	681b      	ldr	r3, [r3, #0]
24010e28:	3320      	adds	r3, #32
24010e2a:	461c      	mov	r4, r3
24010e2c:	687b      	ldr	r3, [r7, #4]
24010e2e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
24010e30:	2301      	movs	r3, #1
24010e32:	9300      	str	r3, [sp, #0]
24010e34:	4613      	mov	r3, r2
24010e36:	4622      	mov	r2, r4
24010e38:	f7fd fed7 	bl	2400ebea <HAL_MDMA_Start_IT>
24010e3c:	4603      	mov	r3, r0
24010e3e:	2b00      	cmp	r3, #0
24010e40:	d114      	bne.n	24010e6c <HAL_QSPI_Transmit_DMA+0x178>
        {
          /* Process unlocked */
          __HAL_UNLOCK(hqspi);
24010e42:	687b      	ldr	r3, [r7, #4]
24010e44:	2200      	movs	r2, #0
24010e46:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

          /* Enable the QSPI transfer error Interrupt */
          __HAL_QSPI_ENABLE_IT(hqspi, QSPI_IT_TE);
24010e4a:	687b      	ldr	r3, [r7, #4]
24010e4c:	681b      	ldr	r3, [r3, #0]
24010e4e:	681a      	ldr	r2, [r3, #0]
24010e50:	687b      	ldr	r3, [r7, #4]
24010e52:	681b      	ldr	r3, [r3, #0]
24010e54:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
24010e58:	601a      	str	r2, [r3, #0]

          /* Enable the MDMA transfer by setting the DMAEN bit in the QSPI CR register */
          SET_BIT(hqspi->Instance->CR, QUADSPI_CR_DMAEN);
24010e5a:	687b      	ldr	r3, [r7, #4]
24010e5c:	681b      	ldr	r3, [r3, #0]
24010e5e:	681a      	ldr	r2, [r3, #0]
24010e60:	687b      	ldr	r3, [r7, #4]
24010e62:	681b      	ldr	r3, [r3, #0]
24010e64:	f042 0204 	orr.w	r2, r2, #4
24010e68:	601a      	str	r2, [r3, #0]
24010e6a:	e023      	b.n	24010eb4 <HAL_QSPI_Transmit_DMA+0x1c0>
        }
        else
        {
          status = HAL_ERROR;
24010e6c:	2301      	movs	r3, #1
24010e6e:	73fb      	strb	r3, [r7, #15]
          hqspi->ErrorCode |= HAL_QSPI_ERROR_DMA;
24010e70:	687b      	ldr	r3, [r7, #4]
24010e72:	6c5b      	ldr	r3, [r3, #68]	; 0x44
24010e74:	f043 0204 	orr.w	r2, r3, #4
24010e78:	687b      	ldr	r3, [r7, #4]
24010e7a:	645a      	str	r2, [r3, #68]	; 0x44
          hqspi->State = HAL_QSPI_STATE_READY;
24010e7c:	687b      	ldr	r3, [r7, #4]
24010e7e:	2201      	movs	r2, #1
24010e80:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

          /* Process unlocked */
          __HAL_UNLOCK(hqspi);
24010e84:	687b      	ldr	r3, [r7, #4]
24010e86:	2200      	movs	r2, #0
24010e88:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
24010e8c:	e012      	b.n	24010eb4 <HAL_QSPI_Transmit_DMA+0x1c0>
        }
    }
    else
    {
      hqspi->ErrorCode |= HAL_QSPI_ERROR_INVALID_PARAM;
24010e8e:	687b      	ldr	r3, [r7, #4]
24010e90:	6c5b      	ldr	r3, [r3, #68]	; 0x44
24010e92:	f043 0208 	orr.w	r2, r3, #8
24010e96:	687b      	ldr	r3, [r7, #4]
24010e98:	645a      	str	r2, [r3, #68]	; 0x44
      status = HAL_ERROR;
24010e9a:	2301      	movs	r3, #1
24010e9c:	73fb      	strb	r3, [r7, #15]

      /* Process unlocked */
      __HAL_UNLOCK(hqspi);
24010e9e:	687b      	ldr	r3, [r7, #4]
24010ea0:	2200      	movs	r2, #0
24010ea2:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
24010ea6:	e005      	b.n	24010eb4 <HAL_QSPI_Transmit_DMA+0x1c0>
    }
  }
  else
  {
    status = HAL_BUSY;
24010ea8:	2302      	movs	r3, #2
24010eaa:	73fb      	strb	r3, [r7, #15]

    /* Process unlocked */
    __HAL_UNLOCK(hqspi);
24010eac:	687b      	ldr	r3, [r7, #4]
24010eae:	2200      	movs	r2, #0
24010eb0:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
  }

  return status;
24010eb4:	7bfb      	ldrb	r3, [r7, #15]
}
24010eb6:	4618      	mov	r0, r3
24010eb8:	3714      	adds	r7, #20
24010eba:	46bd      	mov	sp, r7
24010ebc:	bd90      	pop	{r4, r7, pc}
24010ebe:	bf00      	nop
24010ec0:	2401170d 	.word	0x2401170d
24010ec4:	2401173d 	.word	0x2401173d
24010ec8:	fffff3f3 	.word	0xfffff3f3
24010ecc:	fffffcfc 	.word	0xfffffcfc

24010ed0 <HAL_QSPI_Receive_DMA>:
  * @param  pData : pointer to data buffer.
  * @note   This function is used only in Indirect Read Mode
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_QSPI_Receive_DMA(QSPI_HandleTypeDef *hqspi, uint8_t *pData)
{
24010ed0:	b590      	push	{r4, r7, lr}
24010ed2:	b089      	sub	sp, #36	; 0x24
24010ed4:	af02      	add	r7, sp, #8
24010ed6:	6078      	str	r0, [r7, #4]
24010ed8:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
24010eda:	2300      	movs	r3, #0
24010edc:	75fb      	strb	r3, [r7, #23]
  uint32_t addr_reg = READ_REG(hqspi->Instance->AR);
24010ede:	687b      	ldr	r3, [r7, #4]
24010ee0:	681b      	ldr	r3, [r3, #0]
24010ee2:	699b      	ldr	r3, [r3, #24]
24010ee4:	613b      	str	r3, [r7, #16]
  uint32_t data_size = (READ_REG(hqspi->Instance->DLR) + 1U);
24010ee6:	687b      	ldr	r3, [r7, #4]
24010ee8:	681b      	ldr	r3, [r3, #0]
24010eea:	691b      	ldr	r3, [r3, #16]
24010eec:	3301      	adds	r3, #1
24010eee:	60fb      	str	r3, [r7, #12]

  /* Process locked */
  __HAL_LOCK(hqspi);
24010ef0:	687b      	ldr	r3, [r7, #4]
24010ef2:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
24010ef6:	b2db      	uxtb	r3, r3
24010ef8:	2b01      	cmp	r3, #1
24010efa:	d101      	bne.n	24010f00 <HAL_QSPI_Receive_DMA+0x30>
24010efc:	2302      	movs	r3, #2
24010efe:	e0d2      	b.n	240110a6 <HAL_QSPI_Receive_DMA+0x1d6>
24010f00:	687b      	ldr	r3, [r7, #4]
24010f02:	2201      	movs	r2, #1
24010f04:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  if(hqspi->State == HAL_QSPI_STATE_READY)
24010f08:	687b      	ldr	r3, [r7, #4]
24010f0a:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
24010f0e:	b2db      	uxtb	r3, r3
24010f10:	2b01      	cmp	r3, #1
24010f12:	f040 80c1 	bne.w	24011098 <HAL_QSPI_Receive_DMA+0x1c8>
  {
    /* Clear the error code */
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
24010f16:	687b      	ldr	r3, [r7, #4]
24010f18:	2200      	movs	r2, #0
24010f1a:	645a      	str	r2, [r3, #68]	; 0x44

    if(pData != NULL )
24010f1c:	683b      	ldr	r3, [r7, #0]
24010f1e:	2b00      	cmp	r3, #0
24010f20:	f000 80ad 	beq.w	2401107e <HAL_QSPI_Receive_DMA+0x1ae>
    {
      /* Configure counters of the handle */
      hqspi->RxXferCount = data_size;
24010f24:	687b      	ldr	r3, [r7, #4]
24010f26:	68fa      	ldr	r2, [r7, #12]
24010f28:	639a      	str	r2, [r3, #56]	; 0x38
        /* Update state */
        hqspi->State = HAL_QSPI_STATE_BUSY_INDIRECT_RX;
24010f2a:	687b      	ldr	r3, [r7, #4]
24010f2c:	2222      	movs	r2, #34	; 0x22
24010f2e:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

        /* Clear interrupt */
        __HAL_QSPI_CLEAR_FLAG(hqspi, (QSPI_FLAG_TE | QSPI_FLAG_TC));
24010f32:	687b      	ldr	r3, [r7, #4]
24010f34:	681b      	ldr	r3, [r3, #0]
24010f36:	2203      	movs	r2, #3
24010f38:	60da      	str	r2, [r3, #12]

        /* Configure size and pointer of the handle */
        hqspi->RxXferSize = hqspi->RxXferCount;
24010f3a:	687b      	ldr	r3, [r7, #4]
24010f3c:	6b9a      	ldr	r2, [r3, #56]	; 0x38
24010f3e:	687b      	ldr	r3, [r7, #4]
24010f40:	635a      	str	r2, [r3, #52]	; 0x34
        hqspi->pRxBuffPtr = pData;
24010f42:	687b      	ldr	r3, [r7, #4]
24010f44:	683a      	ldr	r2, [r7, #0]
24010f46:	631a      	str	r2, [r3, #48]	; 0x30

        /* Set the QSPI MDMA transfer complete callback */
        hqspi->hmdma->XferCpltCallback = QSPI_DMARxCplt;
24010f48:	687b      	ldr	r3, [r7, #4]
24010f4a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24010f4c:	4a58      	ldr	r2, [pc, #352]	; (240110b0 <HAL_QSPI_Receive_DMA+0x1e0>)
24010f4e:	645a      	str	r2, [r3, #68]	; 0x44

        /* Set the MDMA error callback */
        hqspi->hmdma->XferErrorCallback = QSPI_DMAError;
24010f50:	687b      	ldr	r3, [r7, #4]
24010f52:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24010f54:	4a57      	ldr	r2, [pc, #348]	; (240110b4 <HAL_QSPI_Receive_DMA+0x1e4>)
24010f56:	655a      	str	r2, [r3, #84]	; 0x54

        /* Clear the MDMA abort callback */
        hqspi->hmdma->XferAbortCallback = NULL;
24010f58:	687b      	ldr	r3, [r7, #4]
24010f5a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24010f5c:	2200      	movs	r2, #0
24010f5e:	659a      	str	r2, [r3, #88]	; 0x58

      /* In Receive mode , the MDMA source is the QSPI DR register : Force the MDMA Source Increment to disable */
      MODIFY_REG(hqspi->hmdma->Instance->CTCR, (MDMA_CTCR_SINC | MDMA_CTCR_SINCOS) , MDMA_SRC_INC_DISABLE);
24010f60:	687b      	ldr	r3, [r7, #4]
24010f62:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24010f64:	681b      	ldr	r3, [r3, #0]
24010f66:	6919      	ldr	r1, [r3, #16]
24010f68:	687b      	ldr	r3, [r7, #4]
24010f6a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24010f6c:	681a      	ldr	r2, [r3, #0]
24010f6e:	4b52      	ldr	r3, [pc, #328]	; (240110b8 <HAL_QSPI_Receive_DMA+0x1e8>)
24010f70:	400b      	ands	r3, r1
24010f72:	6113      	str	r3, [r2, #16]

      /* Update MDMA configuration with the correct DestinationInc field for read operation */
      if (hqspi->hmdma->Init.DestDataSize == MDMA_DEST_DATASIZE_BYTE)
24010f74:	687b      	ldr	r3, [r7, #4]
24010f76:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24010f78:	6a1b      	ldr	r3, [r3, #32]
24010f7a:	2b00      	cmp	r3, #0
24010f7c:	d10c      	bne.n	24010f98 <HAL_QSPI_Receive_DMA+0xc8>
      {
        MODIFY_REG(hqspi->hmdma->Instance->CTCR, (MDMA_CTCR_DINC | MDMA_CTCR_DINCOS) , MDMA_DEST_INC_BYTE);
24010f7e:	687b      	ldr	r3, [r7, #4]
24010f80:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24010f82:	681b      	ldr	r3, [r3, #0]
24010f84:	691a      	ldr	r2, [r3, #16]
24010f86:	4b4d      	ldr	r3, [pc, #308]	; (240110bc <HAL_QSPI_Receive_DMA+0x1ec>)
24010f88:	4013      	ands	r3, r2
24010f8a:	687a      	ldr	r2, [r7, #4]
24010f8c:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
24010f8e:	6812      	ldr	r2, [r2, #0]
24010f90:	f043 0308 	orr.w	r3, r3, #8
24010f94:	6113      	str	r3, [r2, #16]
24010f96:	e02c      	b.n	24010ff2 <HAL_QSPI_Receive_DMA+0x122>
      }
      else if (hqspi->hmdma->Init.DestDataSize == MDMA_DEST_DATASIZE_HALFWORD)
24010f98:	687b      	ldr	r3, [r7, #4]
24010f9a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24010f9c:	6a1b      	ldr	r3, [r3, #32]
24010f9e:	2b40      	cmp	r3, #64	; 0x40
24010fa0:	d10c      	bne.n	24010fbc <HAL_QSPI_Receive_DMA+0xec>
      {
        MODIFY_REG(hqspi->hmdma->Instance->CTCR, (MDMA_CTCR_DINC | MDMA_CTCR_DINCOS) , MDMA_DEST_INC_HALFWORD);
24010fa2:	687b      	ldr	r3, [r7, #4]
24010fa4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24010fa6:	681b      	ldr	r3, [r3, #0]
24010fa8:	691a      	ldr	r2, [r3, #16]
24010faa:	4b44      	ldr	r3, [pc, #272]	; (240110bc <HAL_QSPI_Receive_DMA+0x1ec>)
24010fac:	4013      	ands	r3, r2
24010fae:	687a      	ldr	r2, [r7, #4]
24010fb0:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
24010fb2:	6812      	ldr	r2, [r2, #0]
24010fb4:	f443 6381 	orr.w	r3, r3, #1032	; 0x408
24010fb8:	6113      	str	r3, [r2, #16]
24010fba:	e01a      	b.n	24010ff2 <HAL_QSPI_Receive_DMA+0x122>
      }
      else if (hqspi->hmdma->Init.DestDataSize == MDMA_DEST_DATASIZE_WORD)
24010fbc:	687b      	ldr	r3, [r7, #4]
24010fbe:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24010fc0:	6a1b      	ldr	r3, [r3, #32]
24010fc2:	2b80      	cmp	r3, #128	; 0x80
24010fc4:	d10d      	bne.n	24010fe2 <HAL_QSPI_Receive_DMA+0x112>
      {
        MODIFY_REG(hqspi->hmdma->Instance->CTCR, (MDMA_CTCR_DINC | MDMA_CTCR_DINCOS) , MDMA_DEST_INC_WORD);
24010fc6:	687b      	ldr	r3, [r7, #4]
24010fc8:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24010fca:	681b      	ldr	r3, [r3, #0]
24010fcc:	691b      	ldr	r3, [r3, #16]
24010fce:	4a3b      	ldr	r2, [pc, #236]	; (240110bc <HAL_QSPI_Receive_DMA+0x1ec>)
24010fd0:	401a      	ands	r2, r3
24010fd2:	687b      	ldr	r3, [r7, #4]
24010fd4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24010fd6:	6819      	ldr	r1, [r3, #0]
24010fd8:	f640 0308 	movw	r3, #2056	; 0x808
24010fdc:	4313      	orrs	r3, r2
24010fde:	610b      	str	r3, [r1, #16]
24010fe0:	e007      	b.n	24010ff2 <HAL_QSPI_Receive_DMA+0x122>
      }
      else
      {
       /* in case of incorrect destination data size */
        hqspi->ErrorCode |= HAL_QSPI_ERROR_DMA;
24010fe2:	687b      	ldr	r3, [r7, #4]
24010fe4:	6c5b      	ldr	r3, [r3, #68]	; 0x44
24010fe6:	f043 0204 	orr.w	r2, r3, #4
24010fea:	687b      	ldr	r3, [r7, #4]
24010fec:	645a      	str	r2, [r3, #68]	; 0x44
        status = HAL_ERROR;
24010fee:	2301      	movs	r3, #1
24010ff0:	75fb      	strb	r3, [r7, #23]
      }
          /* Configure QSPI: CCR register with functional as indirect read */
          MODIFY_REG(hqspi->Instance->CCR, QUADSPI_CCR_FMODE, QSPI_FUNCTIONAL_MODE_INDIRECT_READ);
24010ff2:	687b      	ldr	r3, [r7, #4]
24010ff4:	681b      	ldr	r3, [r3, #0]
24010ff6:	695b      	ldr	r3, [r3, #20]
24010ff8:	f023 6240 	bic.w	r2, r3, #201326592	; 0xc000000
24010ffc:	687b      	ldr	r3, [r7, #4]
24010ffe:	681b      	ldr	r3, [r3, #0]
24011000:	f042 6280 	orr.w	r2, r2, #67108864	; 0x4000000
24011004:	615a      	str	r2, [r3, #20]

          /* Start the transfer by re-writing the address in AR register */
          WRITE_REG(hqspi->Instance->AR, addr_reg);
24011006:	687b      	ldr	r3, [r7, #4]
24011008:	681b      	ldr	r3, [r3, #0]
2401100a:	693a      	ldr	r2, [r7, #16]
2401100c:	619a      	str	r2, [r3, #24]

        /* Enable the MDMA */
        if (HAL_MDMA_Start_IT(hqspi->hmdma, (uint32_t)&hqspi->Instance->DR, (uint32_t)pData, hqspi->RxXferSize, 1) == HAL_OK)
2401100e:	687b      	ldr	r3, [r7, #4]
24011010:	6bd8      	ldr	r0, [r3, #60]	; 0x3c
24011012:	687b      	ldr	r3, [r7, #4]
24011014:	681b      	ldr	r3, [r3, #0]
24011016:	3320      	adds	r3, #32
24011018:	461c      	mov	r4, r3
2401101a:	683a      	ldr	r2, [r7, #0]
2401101c:	687b      	ldr	r3, [r7, #4]
2401101e:	6b59      	ldr	r1, [r3, #52]	; 0x34
24011020:	2301      	movs	r3, #1
24011022:	9300      	str	r3, [sp, #0]
24011024:	460b      	mov	r3, r1
24011026:	4621      	mov	r1, r4
24011028:	f7fd fddf 	bl	2400ebea <HAL_MDMA_Start_IT>
2401102c:	4603      	mov	r3, r0
2401102e:	2b00      	cmp	r3, #0
24011030:	d114      	bne.n	2401105c <HAL_QSPI_Receive_DMA+0x18c>
        {
          /* Process unlocked */
          __HAL_UNLOCK(hqspi);
24011032:	687b      	ldr	r3, [r7, #4]
24011034:	2200      	movs	r2, #0
24011036:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

          /* Enable the QSPI transfer error Interrupt */
          __HAL_QSPI_ENABLE_IT(hqspi, QSPI_IT_TE);
2401103a:	687b      	ldr	r3, [r7, #4]
2401103c:	681b      	ldr	r3, [r3, #0]
2401103e:	681a      	ldr	r2, [r3, #0]
24011040:	687b      	ldr	r3, [r7, #4]
24011042:	681b      	ldr	r3, [r3, #0]
24011044:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
24011048:	601a      	str	r2, [r3, #0]

          /* Enable the MDMA transfer by setting the DMAEN bit in the QSPI CR register */
          SET_BIT(hqspi->Instance->CR, QUADSPI_CR_DMAEN);
2401104a:	687b      	ldr	r3, [r7, #4]
2401104c:	681b      	ldr	r3, [r3, #0]
2401104e:	681a      	ldr	r2, [r3, #0]
24011050:	687b      	ldr	r3, [r7, #4]
24011052:	681b      	ldr	r3, [r3, #0]
24011054:	f042 0204 	orr.w	r2, r2, #4
24011058:	601a      	str	r2, [r3, #0]
2401105a:	e023      	b.n	240110a4 <HAL_QSPI_Receive_DMA+0x1d4>
        }
        else
        {
          status = HAL_ERROR;
2401105c:	2301      	movs	r3, #1
2401105e:	75fb      	strb	r3, [r7, #23]
          hqspi->ErrorCode |= HAL_QSPI_ERROR_DMA;
24011060:	687b      	ldr	r3, [r7, #4]
24011062:	6c5b      	ldr	r3, [r3, #68]	; 0x44
24011064:	f043 0204 	orr.w	r2, r3, #4
24011068:	687b      	ldr	r3, [r7, #4]
2401106a:	645a      	str	r2, [r3, #68]	; 0x44
          hqspi->State = HAL_QSPI_STATE_READY;
2401106c:	687b      	ldr	r3, [r7, #4]
2401106e:	2201      	movs	r2, #1
24011070:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

          /* Process unlocked */
          __HAL_UNLOCK(hqspi);
24011074:	687b      	ldr	r3, [r7, #4]
24011076:	2200      	movs	r2, #0
24011078:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
2401107c:	e012      	b.n	240110a4 <HAL_QSPI_Receive_DMA+0x1d4>
        }
    }
    else
    {
      hqspi->ErrorCode |= HAL_QSPI_ERROR_INVALID_PARAM;
2401107e:	687b      	ldr	r3, [r7, #4]
24011080:	6c5b      	ldr	r3, [r3, #68]	; 0x44
24011082:	f043 0208 	orr.w	r2, r3, #8
24011086:	687b      	ldr	r3, [r7, #4]
24011088:	645a      	str	r2, [r3, #68]	; 0x44
      status = HAL_ERROR;
2401108a:	2301      	movs	r3, #1
2401108c:	75fb      	strb	r3, [r7, #23]

      /* Process unlocked */
      __HAL_UNLOCK(hqspi);
2401108e:	687b      	ldr	r3, [r7, #4]
24011090:	2200      	movs	r2, #0
24011092:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
24011096:	e005      	b.n	240110a4 <HAL_QSPI_Receive_DMA+0x1d4>
    }
  }
  else
  {
    status = HAL_BUSY;
24011098:	2302      	movs	r3, #2
2401109a:	75fb      	strb	r3, [r7, #23]

    /* Process unlocked */
    __HAL_UNLOCK(hqspi);
2401109c:	687b      	ldr	r3, [r7, #4]
2401109e:	2200      	movs	r2, #0
240110a0:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
  }

  return status;
240110a4:	7dfb      	ldrb	r3, [r7, #23]
}
240110a6:	4618      	mov	r0, r3
240110a8:	371c      	adds	r7, #28
240110aa:	46bd      	mov	sp, r7
240110ac:	bd90      	pop	{r4, r7, pc}
240110ae:	bf00      	nop
240110b0:	240116dd 	.word	0x240116dd
240110b4:	2401173d 	.word	0x2401173d
240110b8:	fffffcfc 	.word	0xfffffcfc
240110bc:	fffff3f3 	.word	0xfffff3f3

240110c0 <HAL_QSPI_AutoPolling>:
  * @param  Timeout : Timeout duration
  * @note   This function is used only in Automatic Polling Mode
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_QSPI_AutoPolling(QSPI_HandleTypeDef *hqspi, QSPI_CommandTypeDef *cmd, QSPI_AutoPollingTypeDef *cfg, uint32_t Timeout)
{
240110c0:	b580      	push	{r7, lr}
240110c2:	b088      	sub	sp, #32
240110c4:	af02      	add	r7, sp, #8
240110c6:	60f8      	str	r0, [r7, #12]
240110c8:	60b9      	str	r1, [r7, #8]
240110ca:	607a      	str	r2, [r7, #4]
240110cc:	603b      	str	r3, [r7, #0]
  HAL_StatusTypeDef status;
  uint32_t tickstart = HAL_GetTick();
240110ce:	f7ef fbbf 	bl	24000850 <HAL_GetTick>
240110d2:	6138      	str	r0, [r7, #16]
  assert_param(IS_QSPI_INTERVAL(cfg->Interval));
  assert_param(IS_QSPI_STATUS_BYTES_SIZE(cfg->StatusBytesSize));
  assert_param(IS_QSPI_MATCH_MODE(cfg->MatchMode));

  /* Process locked */
  __HAL_LOCK(hqspi);
240110d4:	68fb      	ldr	r3, [r7, #12]
240110d6:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
240110da:	b2db      	uxtb	r3, r3
240110dc:	2b01      	cmp	r3, #1
240110de:	d101      	bne.n	240110e4 <HAL_QSPI_AutoPolling+0x24>
240110e0:	2302      	movs	r3, #2
240110e2:	e060      	b.n	240111a6 <HAL_QSPI_AutoPolling+0xe6>
240110e4:	68fb      	ldr	r3, [r7, #12]
240110e6:	2201      	movs	r2, #1
240110e8:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  if(hqspi->State == HAL_QSPI_STATE_READY)
240110ec:	68fb      	ldr	r3, [r7, #12]
240110ee:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
240110f2:	b2db      	uxtb	r3, r3
240110f4:	2b01      	cmp	r3, #1
240110f6:	d14f      	bne.n	24011198 <HAL_QSPI_AutoPolling+0xd8>
  {
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
240110f8:	68fb      	ldr	r3, [r7, #12]
240110fa:	2200      	movs	r2, #0
240110fc:	645a      	str	r2, [r3, #68]	; 0x44

    /* Update state */
    hqspi->State = HAL_QSPI_STATE_BUSY_AUTO_POLLING;
240110fe:	68fb      	ldr	r3, [r7, #12]
24011100:	2242      	movs	r2, #66	; 0x42
24011102:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Wait till BUSY flag reset */
    status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, Timeout);
24011106:	683b      	ldr	r3, [r7, #0]
24011108:	9300      	str	r3, [sp, #0]
2401110a:	693b      	ldr	r3, [r7, #16]
2401110c:	2200      	movs	r2, #0
2401110e:	2120      	movs	r1, #32
24011110:	68f8      	ldr	r0, [r7, #12]
24011112:	f000 fb68 	bl	240117e6 <QSPI_WaitFlagStateUntilTimeout>
24011116:	4603      	mov	r3, r0
24011118:	75fb      	strb	r3, [r7, #23]

    if (status == HAL_OK)
2401111a:	7dfb      	ldrb	r3, [r7, #23]
2401111c:	2b00      	cmp	r3, #0
2401111e:	d13d      	bne.n	2401119c <HAL_QSPI_AutoPolling+0xdc>
    {
      /* Configure QSPI: PSMAR register with the status match value */
      WRITE_REG(hqspi->Instance->PSMAR, cfg->Match);
24011120:	68fb      	ldr	r3, [r7, #12]
24011122:	681b      	ldr	r3, [r3, #0]
24011124:	687a      	ldr	r2, [r7, #4]
24011126:	6812      	ldr	r2, [r2, #0]
24011128:	629a      	str	r2, [r3, #40]	; 0x28

      /* Configure QSPI: PSMKR register with the status mask value */
      WRITE_REG(hqspi->Instance->PSMKR, cfg->Mask);
2401112a:	68fb      	ldr	r3, [r7, #12]
2401112c:	681b      	ldr	r3, [r3, #0]
2401112e:	687a      	ldr	r2, [r7, #4]
24011130:	6852      	ldr	r2, [r2, #4]
24011132:	625a      	str	r2, [r3, #36]	; 0x24

      /* Configure QSPI: PIR register with the interval value */
      WRITE_REG(hqspi->Instance->PIR, cfg->Interval);
24011134:	68fb      	ldr	r3, [r7, #12]
24011136:	681b      	ldr	r3, [r3, #0]
24011138:	687a      	ldr	r2, [r7, #4]
2401113a:	6892      	ldr	r2, [r2, #8]
2401113c:	62da      	str	r2, [r3, #44]	; 0x2c

      /* Configure QSPI: CR register with Match mode and Automatic stop enabled
      (otherwise there will be an infinite loop in blocking mode) */
      MODIFY_REG(hqspi->Instance->CR, (QUADSPI_CR_PMM | QUADSPI_CR_APMS),
2401113e:	68fb      	ldr	r3, [r7, #12]
24011140:	681b      	ldr	r3, [r3, #0]
24011142:	681b      	ldr	r3, [r3, #0]
24011144:	f423 0240 	bic.w	r2, r3, #12582912	; 0xc00000
24011148:	687b      	ldr	r3, [r7, #4]
2401114a:	691b      	ldr	r3, [r3, #16]
2401114c:	431a      	orrs	r2, r3
2401114e:	68fb      	ldr	r3, [r7, #12]
24011150:	681b      	ldr	r3, [r3, #0]
24011152:	f442 0280 	orr.w	r2, r2, #4194304	; 0x400000
24011156:	601a      	str	r2, [r3, #0]
               (cfg->MatchMode | QSPI_AUTOMATIC_STOP_ENABLE));

      /* Call the configuration function */
      cmd->NbData = cfg->StatusBytesSize;
24011158:	687b      	ldr	r3, [r7, #4]
2401115a:	68da      	ldr	r2, [r3, #12]
2401115c:	68bb      	ldr	r3, [r7, #8]
2401115e:	629a      	str	r2, [r3, #40]	; 0x28
      QSPI_Config(hqspi, cmd, QSPI_FUNCTIONAL_MODE_AUTO_POLLING);
24011160:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
24011164:	68b9      	ldr	r1, [r7, #8]
24011166:	68f8      	ldr	r0, [r7, #12]
24011168:	f000 fb74 	bl	24011854 <QSPI_Config>

      /* Wait until SM flag is set to go back in idle state */
      status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_SM, SET, tickstart, Timeout);
2401116c:	683b      	ldr	r3, [r7, #0]
2401116e:	9300      	str	r3, [sp, #0]
24011170:	693b      	ldr	r3, [r7, #16]
24011172:	2201      	movs	r2, #1
24011174:	2108      	movs	r1, #8
24011176:	68f8      	ldr	r0, [r7, #12]
24011178:	f000 fb35 	bl	240117e6 <QSPI_WaitFlagStateUntilTimeout>
2401117c:	4603      	mov	r3, r0
2401117e:	75fb      	strb	r3, [r7, #23]

      if (status == HAL_OK)
24011180:	7dfb      	ldrb	r3, [r7, #23]
24011182:	2b00      	cmp	r3, #0
24011184:	d10a      	bne.n	2401119c <HAL_QSPI_AutoPolling+0xdc>
      {
        __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_SM);
24011186:	68fb      	ldr	r3, [r7, #12]
24011188:	681b      	ldr	r3, [r3, #0]
2401118a:	2208      	movs	r2, #8
2401118c:	60da      	str	r2, [r3, #12]

        /* Update state */
        hqspi->State = HAL_QSPI_STATE_READY;
2401118e:	68fb      	ldr	r3, [r7, #12]
24011190:	2201      	movs	r2, #1
24011192:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
24011196:	e001      	b.n	2401119c <HAL_QSPI_AutoPolling+0xdc>
      }
    }
  }
  else
  {
    status = HAL_BUSY;
24011198:	2302      	movs	r3, #2
2401119a:	75fb      	strb	r3, [r7, #23]
  }

  /* Process unlocked */
  __HAL_UNLOCK(hqspi);
2401119c:	68fb      	ldr	r3, [r7, #12]
2401119e:	2200      	movs	r2, #0
240111a0:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  /* Return function status */
  return status;
240111a4:	7dfb      	ldrb	r3, [r7, #23]
}
240111a6:	4618      	mov	r0, r3
240111a8:	3718      	adds	r7, #24
240111aa:	46bd      	mov	sp, r7
240111ac:	bd80      	pop	{r7, pc}

240111ae <HAL_QSPI_AutoPolling_IT>:
  * @param  cfg : structure that contains the polling configuration information.
  * @note   This function is used only in Automatic Polling Mode
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_QSPI_AutoPolling_IT(QSPI_HandleTypeDef *hqspi, QSPI_CommandTypeDef *cmd, QSPI_AutoPollingTypeDef *cfg)
{
240111ae:	b580      	push	{r7, lr}
240111b0:	b088      	sub	sp, #32
240111b2:	af02      	add	r7, sp, #8
240111b4:	60f8      	str	r0, [r7, #12]
240111b6:	60b9      	str	r1, [r7, #8]
240111b8:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status;
  uint32_t tickstart = HAL_GetTick();
240111ba:	f7ef fb49 	bl	24000850 <HAL_GetTick>
240111be:	6138      	str	r0, [r7, #16]
  assert_param(IS_QSPI_STATUS_BYTES_SIZE(cfg->StatusBytesSize));
  assert_param(IS_QSPI_MATCH_MODE(cfg->MatchMode));
  assert_param(IS_QSPI_AUTOMATIC_STOP(cfg->AutomaticStop));

  /* Process locked */
  __HAL_LOCK(hqspi);
240111c0:	68fb      	ldr	r3, [r7, #12]
240111c2:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
240111c6:	b2db      	uxtb	r3, r3
240111c8:	2b01      	cmp	r3, #1
240111ca:	d101      	bne.n	240111d0 <HAL_QSPI_AutoPolling_IT+0x22>
240111cc:	2302      	movs	r3, #2
240111ce:	e062      	b.n	24011296 <HAL_QSPI_AutoPolling_IT+0xe8>
240111d0:	68fb      	ldr	r3, [r7, #12]
240111d2:	2201      	movs	r2, #1
240111d4:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  if(hqspi->State == HAL_QSPI_STATE_READY)
240111d8:	68fb      	ldr	r3, [r7, #12]
240111da:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
240111de:	b2db      	uxtb	r3, r3
240111e0:	2b01      	cmp	r3, #1
240111e2:	d151      	bne.n	24011288 <HAL_QSPI_AutoPolling_IT+0xda>
  {
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
240111e4:	68fb      	ldr	r3, [r7, #12]
240111e6:	2200      	movs	r2, #0
240111e8:	645a      	str	r2, [r3, #68]	; 0x44

    /* Update state */
    hqspi->State = HAL_QSPI_STATE_BUSY_AUTO_POLLING;
240111ea:	68fb      	ldr	r3, [r7, #12]
240111ec:	2242      	movs	r2, #66	; 0x42
240111ee:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Wait till BUSY flag reset */
    status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, hqspi->Timeout);
240111f2:	68fb      	ldr	r3, [r7, #12]
240111f4:	6c9b      	ldr	r3, [r3, #72]	; 0x48
240111f6:	9300      	str	r3, [sp, #0]
240111f8:	693b      	ldr	r3, [r7, #16]
240111fa:	2200      	movs	r2, #0
240111fc:	2120      	movs	r1, #32
240111fe:	68f8      	ldr	r0, [r7, #12]
24011200:	f000 faf1 	bl	240117e6 <QSPI_WaitFlagStateUntilTimeout>
24011204:	4603      	mov	r3, r0
24011206:	75fb      	strb	r3, [r7, #23]

    if (status == HAL_OK)
24011208:	7dfb      	ldrb	r3, [r7, #23]
2401120a:	2b00      	cmp	r3, #0
2401120c:	d137      	bne.n	2401127e <HAL_QSPI_AutoPolling_IT+0xd0>
    {
      /* Configure QSPI: PSMAR register with the status match value */
      WRITE_REG(hqspi->Instance->PSMAR, cfg->Match);
2401120e:	68fb      	ldr	r3, [r7, #12]
24011210:	681b      	ldr	r3, [r3, #0]
24011212:	687a      	ldr	r2, [r7, #4]
24011214:	6812      	ldr	r2, [r2, #0]
24011216:	629a      	str	r2, [r3, #40]	; 0x28

      /* Configure QSPI: PSMKR register with the status mask value */
      WRITE_REG(hqspi->Instance->PSMKR, cfg->Mask);
24011218:	68fb      	ldr	r3, [r7, #12]
2401121a:	681b      	ldr	r3, [r3, #0]
2401121c:	687a      	ldr	r2, [r7, #4]
2401121e:	6852      	ldr	r2, [r2, #4]
24011220:	625a      	str	r2, [r3, #36]	; 0x24

      /* Configure QSPI: PIR register with the interval value */
      WRITE_REG(hqspi->Instance->PIR, cfg->Interval);
24011222:	68fb      	ldr	r3, [r7, #12]
24011224:	681b      	ldr	r3, [r3, #0]
24011226:	687a      	ldr	r2, [r7, #4]
24011228:	6892      	ldr	r2, [r2, #8]
2401122a:	62da      	str	r2, [r3, #44]	; 0x2c

      /* Configure QSPI: CR register with Match mode and Automatic stop mode */
      MODIFY_REG(hqspi->Instance->CR, (QUADSPI_CR_PMM | QUADSPI_CR_APMS),
2401122c:	68fb      	ldr	r3, [r7, #12]
2401122e:	681b      	ldr	r3, [r3, #0]
24011230:	681b      	ldr	r3, [r3, #0]
24011232:	f423 0140 	bic.w	r1, r3, #12582912	; 0xc00000
24011236:	687b      	ldr	r3, [r7, #4]
24011238:	691a      	ldr	r2, [r3, #16]
2401123a:	687b      	ldr	r3, [r7, #4]
2401123c:	695b      	ldr	r3, [r3, #20]
2401123e:	431a      	orrs	r2, r3
24011240:	68fb      	ldr	r3, [r7, #12]
24011242:	681b      	ldr	r3, [r3, #0]
24011244:	430a      	orrs	r2, r1
24011246:	601a      	str	r2, [r3, #0]
               (cfg->MatchMode | cfg->AutomaticStop));

      /* Clear interrupt */
      __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TE | QSPI_FLAG_SM);
24011248:	68fb      	ldr	r3, [r7, #12]
2401124a:	681b      	ldr	r3, [r3, #0]
2401124c:	2209      	movs	r2, #9
2401124e:	60da      	str	r2, [r3, #12]

      /* Call the configuration function */
      cmd->NbData = cfg->StatusBytesSize;
24011250:	687b      	ldr	r3, [r7, #4]
24011252:	68da      	ldr	r2, [r3, #12]
24011254:	68bb      	ldr	r3, [r7, #8]
24011256:	629a      	str	r2, [r3, #40]	; 0x28
      QSPI_Config(hqspi, cmd, QSPI_FUNCTIONAL_MODE_AUTO_POLLING);
24011258:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
2401125c:	68b9      	ldr	r1, [r7, #8]
2401125e:	68f8      	ldr	r0, [r7, #12]
24011260:	f000 faf8 	bl	24011854 <QSPI_Config>

      /* Process unlocked */
      __HAL_UNLOCK(hqspi);
24011264:	68fb      	ldr	r3, [r7, #12]
24011266:	2200      	movs	r2, #0
24011268:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

      /* Enable the QSPI Transfer Error and status match Interrupt */
      __HAL_QSPI_ENABLE_IT(hqspi, (QSPI_IT_SM | QSPI_IT_TE));
2401126c:	68fb      	ldr	r3, [r7, #12]
2401126e:	681b      	ldr	r3, [r3, #0]
24011270:	681a      	ldr	r2, [r3, #0]
24011272:	68fb      	ldr	r3, [r7, #12]
24011274:	681b      	ldr	r3, [r3, #0]
24011276:	f442 2210 	orr.w	r2, r2, #589824	; 0x90000
2401127a:	601a      	str	r2, [r3, #0]
2401127c:	e00a      	b.n	24011294 <HAL_QSPI_AutoPolling_IT+0xe6>

    }
    else
    {
      /* Process unlocked */
      __HAL_UNLOCK(hqspi);
2401127e:	68fb      	ldr	r3, [r7, #12]
24011280:	2200      	movs	r2, #0
24011282:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
24011286:	e005      	b.n	24011294 <HAL_QSPI_AutoPolling_IT+0xe6>
    }
  }
  else
  {
    status = HAL_BUSY;
24011288:	2302      	movs	r3, #2
2401128a:	75fb      	strb	r3, [r7, #23]

    /* Process unlocked */
    __HAL_UNLOCK(hqspi);
2401128c:	68fb      	ldr	r3, [r7, #12]
2401128e:	2200      	movs	r2, #0
24011290:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
  }

  /* Return function status */
  return status;
24011294:	7dfb      	ldrb	r3, [r7, #23]
}
24011296:	4618      	mov	r0, r3
24011298:	3718      	adds	r7, #24
2401129a:	46bd      	mov	sp, r7
2401129c:	bd80      	pop	{r7, pc}

2401129e <HAL_QSPI_MemoryMapped>:
  * @param  cfg : structure that contains the memory mapped configuration information.
  * @note   This function is used only in Memory mapped Mode
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_QSPI_MemoryMapped(QSPI_HandleTypeDef *hqspi, QSPI_CommandTypeDef *cmd, QSPI_MemoryMappedTypeDef *cfg)
{
2401129e:	b580      	push	{r7, lr}
240112a0:	b088      	sub	sp, #32
240112a2:	af02      	add	r7, sp, #8
240112a4:	60f8      	str	r0, [r7, #12]
240112a6:	60b9      	str	r1, [r7, #8]
240112a8:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status;
  uint32_t tickstart = HAL_GetTick();
240112aa:	f7ef fad1 	bl	24000850 <HAL_GetTick>
240112ae:	6138      	str	r0, [r7, #16]
  assert_param(IS_QSPI_SIOO_MODE(cmd->SIOOMode));

  assert_param(IS_QSPI_TIMEOUT_ACTIVATION(cfg->TimeOutActivation));

  /* Process locked */
  __HAL_LOCK(hqspi);
240112b0:	68fb      	ldr	r3, [r7, #12]
240112b2:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
240112b6:	b2db      	uxtb	r3, r3
240112b8:	2b01      	cmp	r3, #1
240112ba:	d101      	bne.n	240112c0 <HAL_QSPI_MemoryMapped+0x22>
240112bc:	2302      	movs	r3, #2
240112be:	e04c      	b.n	2401135a <HAL_QSPI_MemoryMapped+0xbc>
240112c0:	68fb      	ldr	r3, [r7, #12]
240112c2:	2201      	movs	r2, #1
240112c4:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  if(hqspi->State == HAL_QSPI_STATE_READY)
240112c8:	68fb      	ldr	r3, [r7, #12]
240112ca:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
240112ce:	b2db      	uxtb	r3, r3
240112d0:	2b01      	cmp	r3, #1
240112d2:	d13b      	bne.n	2401134c <HAL_QSPI_MemoryMapped+0xae>
  {
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
240112d4:	68fb      	ldr	r3, [r7, #12]
240112d6:	2200      	movs	r2, #0
240112d8:	645a      	str	r2, [r3, #68]	; 0x44

    /* Update state */
    hqspi->State = HAL_QSPI_STATE_BUSY_MEM_MAPPED;
240112da:	68fb      	ldr	r3, [r7, #12]
240112dc:	2282      	movs	r2, #130	; 0x82
240112de:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Wait till BUSY flag reset */
    status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, hqspi->Timeout);
240112e2:	68fb      	ldr	r3, [r7, #12]
240112e4:	6c9b      	ldr	r3, [r3, #72]	; 0x48
240112e6:	9300      	str	r3, [sp, #0]
240112e8:	693b      	ldr	r3, [r7, #16]
240112ea:	2200      	movs	r2, #0
240112ec:	2120      	movs	r1, #32
240112ee:	68f8      	ldr	r0, [r7, #12]
240112f0:	f000 fa79 	bl	240117e6 <QSPI_WaitFlagStateUntilTimeout>
240112f4:	4603      	mov	r3, r0
240112f6:	75fb      	strb	r3, [r7, #23]

    if (status == HAL_OK)
240112f8:	7dfb      	ldrb	r3, [r7, #23]
240112fa:	2b00      	cmp	r3, #0
240112fc:	d128      	bne.n	24011350 <HAL_QSPI_MemoryMapped+0xb2>
    {
      /* Configure QSPI: CR register with timeout counter enable */
    MODIFY_REG(hqspi->Instance->CR, QUADSPI_CR_TCEN, cfg->TimeOutActivation);
240112fe:	68fb      	ldr	r3, [r7, #12]
24011300:	681b      	ldr	r3, [r3, #0]
24011302:	681b      	ldr	r3, [r3, #0]
24011304:	f023 0108 	bic.w	r1, r3, #8
24011308:	687b      	ldr	r3, [r7, #4]
2401130a:	685a      	ldr	r2, [r3, #4]
2401130c:	68fb      	ldr	r3, [r7, #12]
2401130e:	681b      	ldr	r3, [r3, #0]
24011310:	430a      	orrs	r2, r1
24011312:	601a      	str	r2, [r3, #0]

    if (cfg->TimeOutActivation == QSPI_TIMEOUT_COUNTER_ENABLE)
24011314:	687b      	ldr	r3, [r7, #4]
24011316:	685b      	ldr	r3, [r3, #4]
24011318:	2b08      	cmp	r3, #8
2401131a:	d110      	bne.n	2401133e <HAL_QSPI_MemoryMapped+0xa0>
      {
        assert_param(IS_QSPI_TIMEOUT_PERIOD(cfg->TimeOutPeriod));

        /* Configure QSPI: LPTR register with the low-power timeout value */
        WRITE_REG(hqspi->Instance->LPTR, cfg->TimeOutPeriod);
2401131c:	68fb      	ldr	r3, [r7, #12]
2401131e:	681b      	ldr	r3, [r3, #0]
24011320:	687a      	ldr	r2, [r7, #4]
24011322:	6812      	ldr	r2, [r2, #0]
24011324:	631a      	str	r2, [r3, #48]	; 0x30

        /* Clear interrupt */
        __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TO);
24011326:	68fb      	ldr	r3, [r7, #12]
24011328:	681b      	ldr	r3, [r3, #0]
2401132a:	2210      	movs	r2, #16
2401132c:	60da      	str	r2, [r3, #12]

        /* Enable the QSPI TimeOut Interrupt */
        __HAL_QSPI_ENABLE_IT(hqspi, QSPI_IT_TO);
2401132e:	68fb      	ldr	r3, [r7, #12]
24011330:	681b      	ldr	r3, [r3, #0]
24011332:	681a      	ldr	r2, [r3, #0]
24011334:	68fb      	ldr	r3, [r7, #12]
24011336:	681b      	ldr	r3, [r3, #0]
24011338:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
2401133c:	601a      	str	r2, [r3, #0]
      }

      /* Call the configuration function */
      QSPI_Config(hqspi, cmd, QSPI_FUNCTIONAL_MODE_MEMORY_MAPPED);
2401133e:	f04f 6240 	mov.w	r2, #201326592	; 0xc000000
24011342:	68b9      	ldr	r1, [r7, #8]
24011344:	68f8      	ldr	r0, [r7, #12]
24011346:	f000 fa85 	bl	24011854 <QSPI_Config>
2401134a:	e001      	b.n	24011350 <HAL_QSPI_MemoryMapped+0xb2>
    }
  }
  else
  {
    status = HAL_BUSY;
2401134c:	2302      	movs	r3, #2
2401134e:	75fb      	strb	r3, [r7, #23]
  }

  /* Process unlocked */
  __HAL_UNLOCK(hqspi);
24011350:	68fb      	ldr	r3, [r7, #12]
24011352:	2200      	movs	r2, #0
24011354:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  /* Return function status */
  return status;
24011358:	7dfb      	ldrb	r3, [r7, #23]
}
2401135a:	4618      	mov	r0, r3
2401135c:	3718      	adds	r7, #24
2401135e:	46bd      	mov	sp, r7
24011360:	bd80      	pop	{r7, pc}

24011362 <HAL_QSPI_ErrorCallback>:
  * @brief  Transfer Error callback.
  * @param  hqspi : QSPI handle
  * @retval None
  */
__weak void HAL_QSPI_ErrorCallback(QSPI_HandleTypeDef *hqspi)
{
24011362:	b480      	push	{r7}
24011364:	b083      	sub	sp, #12
24011366:	af00      	add	r7, sp, #0
24011368:	6078      	str	r0, [r7, #4]
  UNUSED(hqspi);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_QSPI_ErrorCallback could be implemented in the user file
   */
}
2401136a:	bf00      	nop
2401136c:	370c      	adds	r7, #12
2401136e:	46bd      	mov	sp, r7
24011370:	f85d 7b04 	ldr.w	r7, [sp], #4
24011374:	4770      	bx	lr

24011376 <HAL_QSPI_AbortCpltCallback>:
  * @brief  Abort completed callback.
  * @param  hqspi : QSPI handle
  * @retval None
  */
__weak void HAL_QSPI_AbortCpltCallback(QSPI_HandleTypeDef *hqspi)
{
24011376:	b480      	push	{r7}
24011378:	b083      	sub	sp, #12
2401137a:	af00      	add	r7, sp, #0
2401137c:	6078      	str	r0, [r7, #4]
  UNUSED(hqspi);

  /* NOTE: This function should not be modified, when the callback is needed,
           the HAL_QSPI_AbortCpltCallback could be implemented in the user file
   */
}
2401137e:	bf00      	nop
24011380:	370c      	adds	r7, #12
24011382:	46bd      	mov	sp, r7
24011384:	f85d 7b04 	ldr.w	r7, [sp], #4
24011388:	4770      	bx	lr

2401138a <HAL_QSPI_CmdCpltCallback>:
  * @brief  Command completed callback.
  * @param  hqspi : QSPI handle
  * @retval None
  */
__weak void HAL_QSPI_CmdCpltCallback(QSPI_HandleTypeDef *hqspi)
{
2401138a:	b480      	push	{r7}
2401138c:	b083      	sub	sp, #12
2401138e:	af00      	add	r7, sp, #0
24011390:	6078      	str	r0, [r7, #4]
  UNUSED(hqspi);

  /* NOTE: This function should not be modified, when the callback is needed,
           the HAL_QSPI_CmdCpltCallback could be implemented in the user file
   */
}
24011392:	bf00      	nop
24011394:	370c      	adds	r7, #12
24011396:	46bd      	mov	sp, r7
24011398:	f85d 7b04 	ldr.w	r7, [sp], #4
2401139c:	4770      	bx	lr

2401139e <HAL_QSPI_RxCpltCallback>:
  * @brief  Rx Transfer completed callback.
  * @param  hqspi : QSPI handle
  * @retval None
  */
__weak void HAL_QSPI_RxCpltCallback(QSPI_HandleTypeDef *hqspi)
{
2401139e:	b480      	push	{r7}
240113a0:	b083      	sub	sp, #12
240113a2:	af00      	add	r7, sp, #0
240113a4:	6078      	str	r0, [r7, #4]
  UNUSED(hqspi);

  /* NOTE: This function should not be modified, when the callback is needed,
           the HAL_QSPI_RxCpltCallback could be implemented in the user file
   */
}
240113a6:	bf00      	nop
240113a8:	370c      	adds	r7, #12
240113aa:	46bd      	mov	sp, r7
240113ac:	f85d 7b04 	ldr.w	r7, [sp], #4
240113b0:	4770      	bx	lr

240113b2 <HAL_QSPI_TxCpltCallback>:
  * @brief  Tx Transfer completed callback.
  * @param  hqspi : QSPI handle
  * @retval None
  */
__weak void HAL_QSPI_TxCpltCallback(QSPI_HandleTypeDef *hqspi)
{
240113b2:	b480      	push	{r7}
240113b4:	b083      	sub	sp, #12
240113b6:	af00      	add	r7, sp, #0
240113b8:	6078      	str	r0, [r7, #4]
  UNUSED(hqspi);

  /* NOTE: This function should not be modified, when the callback is needed,
           the HAL_QSPI_TxCpltCallback could be implemented in the user file
   */
}
240113ba:	bf00      	nop
240113bc:	370c      	adds	r7, #12
240113be:	46bd      	mov	sp, r7
240113c0:	f85d 7b04 	ldr.w	r7, [sp], #4
240113c4:	4770      	bx	lr

240113c6 <HAL_QSPI_FifoThresholdCallback>:
  * @brief  FIFO Threshold callback.
  * @param  hqspi : QSPI handle
  * @retval None
  */
__weak void HAL_QSPI_FifoThresholdCallback(QSPI_HandleTypeDef *hqspi)
{
240113c6:	b480      	push	{r7}
240113c8:	b083      	sub	sp, #12
240113ca:	af00      	add	r7, sp, #0
240113cc:	6078      	str	r0, [r7, #4]
  UNUSED(hqspi);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_QSPI_FIFOThresholdCallback could be implemented in the user file
   */
}
240113ce:	bf00      	nop
240113d0:	370c      	adds	r7, #12
240113d2:	46bd      	mov	sp, r7
240113d4:	f85d 7b04 	ldr.w	r7, [sp], #4
240113d8:	4770      	bx	lr

240113da <HAL_QSPI_StatusMatchCallback>:
  * @brief  Status Match callback.
  * @param  hqspi : QSPI handle
  * @retval None
  */
__weak void HAL_QSPI_StatusMatchCallback(QSPI_HandleTypeDef *hqspi)
{
240113da:	b480      	push	{r7}
240113dc:	b083      	sub	sp, #12
240113de:	af00      	add	r7, sp, #0
240113e0:	6078      	str	r0, [r7, #4]
  UNUSED(hqspi);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_QSPI_StatusMatchCallback could be implemented in the user file
   */
}
240113e2:	bf00      	nop
240113e4:	370c      	adds	r7, #12
240113e6:	46bd      	mov	sp, r7
240113e8:	f85d 7b04 	ldr.w	r7, [sp], #4
240113ec:	4770      	bx	lr

240113ee <HAL_QSPI_TimeOutCallback>:
  * @brief  Timeout callback.
  * @param  hqspi : QSPI handle
  * @retval None
  */
__weak void HAL_QSPI_TimeOutCallback(QSPI_HandleTypeDef *hqspi)
{
240113ee:	b480      	push	{r7}
240113f0:	b083      	sub	sp, #12
240113f2:	af00      	add	r7, sp, #0
240113f4:	6078      	str	r0, [r7, #4]
  UNUSED(hqspi);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_QSPI_TimeOutCallback could be implemented in the user file
   */
}
240113f6:	bf00      	nop
240113f8:	370c      	adds	r7, #12
240113fa:	46bd      	mov	sp, r7
240113fc:	f85d 7b04 	ldr.w	r7, [sp], #4
24011400:	4770      	bx	lr

24011402 <HAL_QSPI_GetState>:
  * @brief  Return the QSPI handle state.
  * @param  hqspi : QSPI handle
  * @retval HAL state
  */
HAL_QSPI_StateTypeDef HAL_QSPI_GetState(QSPI_HandleTypeDef *hqspi)
{
24011402:	b480      	push	{r7}
24011404:	b083      	sub	sp, #12
24011406:	af00      	add	r7, sp, #0
24011408:	6078      	str	r0, [r7, #4]
  /* Return QSPI handle state */
  return hqspi->State;
2401140a:	687b      	ldr	r3, [r7, #4]
2401140c:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
24011410:	b2db      	uxtb	r3, r3
}
24011412:	4618      	mov	r0, r3
24011414:	370c      	adds	r7, #12
24011416:	46bd      	mov	sp, r7
24011418:	f85d 7b04 	ldr.w	r7, [sp], #4
2401141c:	4770      	bx	lr

2401141e <HAL_QSPI_GetError>:
* @brief  Return the QSPI error code.
* @param  hqspi : QSPI handle
* @retval QSPI Error Code
*/
uint32_t HAL_QSPI_GetError(QSPI_HandleTypeDef *hqspi)
{
2401141e:	b480      	push	{r7}
24011420:	b083      	sub	sp, #12
24011422:	af00      	add	r7, sp, #0
24011424:	6078      	str	r0, [r7, #4]
  return hqspi->ErrorCode;
24011426:	687b      	ldr	r3, [r7, #4]
24011428:	6c5b      	ldr	r3, [r3, #68]	; 0x44
}
2401142a:	4618      	mov	r0, r3
2401142c:	370c      	adds	r7, #12
2401142e:	46bd      	mov	sp, r7
24011430:	f85d 7b04 	ldr.w	r7, [sp], #4
24011434:	4770      	bx	lr

24011436 <HAL_QSPI_Abort>:
* @brief  Abort the current transmission.
* @param  hqspi : QSPI handle
* @retval HAL status
*/
HAL_StatusTypeDef HAL_QSPI_Abort(QSPI_HandleTypeDef *hqspi)
{
24011436:	b580      	push	{r7, lr}
24011438:	b086      	sub	sp, #24
2401143a:	af02      	add	r7, sp, #8
2401143c:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
2401143e:	2300      	movs	r3, #0
24011440:	73fb      	strb	r3, [r7, #15]
  uint32_t tickstart = HAL_GetTick();
24011442:	f7ef fa05 	bl	24000850 <HAL_GetTick>
24011446:	60b8      	str	r0, [r7, #8]

  /* Check if the state is in one of the busy states */
  if (((uint32_t)hqspi->State & 0x2U) != 0U)
24011448:	687b      	ldr	r3, [r7, #4]
2401144a:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2401144e:	b2db      	uxtb	r3, r3
24011450:	f003 0302 	and.w	r3, r3, #2
24011454:	2b00      	cmp	r3, #0
24011456:	d056      	beq.n	24011506 <HAL_QSPI_Abort+0xd0>
  {
    /* Process unlocked */
    __HAL_UNLOCK(hqspi);
24011458:	687b      	ldr	r3, [r7, #4]
2401145a:	2200      	movs	r2, #0
2401145c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    if ((hqspi->Instance->CR & QUADSPI_CR_DMAEN) != 0U)
24011460:	687b      	ldr	r3, [r7, #4]
24011462:	681b      	ldr	r3, [r3, #0]
24011464:	681b      	ldr	r3, [r3, #0]
24011466:	f003 0304 	and.w	r3, r3, #4
2401146a:	2b00      	cmp	r3, #0
2401146c:	d017      	beq.n	2401149e <HAL_QSPI_Abort+0x68>
    {
      /* Disable the DMA transfer by clearing the DMAEN bit in the QSPI CR register */
      CLEAR_BIT(hqspi->Instance->CR, QUADSPI_CR_DMAEN);
2401146e:	687b      	ldr	r3, [r7, #4]
24011470:	681b      	ldr	r3, [r3, #0]
24011472:	681a      	ldr	r2, [r3, #0]
24011474:	687b      	ldr	r3, [r7, #4]
24011476:	681b      	ldr	r3, [r3, #0]
24011478:	f022 0204 	bic.w	r2, r2, #4
2401147c:	601a      	str	r2, [r3, #0]

      /* Abort MDMA */
      status = HAL_MDMA_Abort(hqspi->hmdma);
2401147e:	687b      	ldr	r3, [r7, #4]
24011480:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24011482:	4618      	mov	r0, r3
24011484:	f7fd fc32 	bl	2400ecec <HAL_MDMA_Abort>
24011488:	4603      	mov	r3, r0
2401148a:	73fb      	strb	r3, [r7, #15]
      if(status != HAL_OK)
2401148c:	7bfb      	ldrb	r3, [r7, #15]
2401148e:	2b00      	cmp	r3, #0
24011490:	d005      	beq.n	2401149e <HAL_QSPI_Abort+0x68>
      {
        hqspi->ErrorCode |= HAL_QSPI_ERROR_DMA;
24011492:	687b      	ldr	r3, [r7, #4]
24011494:	6c5b      	ldr	r3, [r3, #68]	; 0x44
24011496:	f043 0204 	orr.w	r2, r3, #4
2401149a:	687b      	ldr	r3, [r7, #4]
2401149c:	645a      	str	r2, [r3, #68]	; 0x44
      }
    }

    /* Configure QSPI: CR register with Abort request */
    SET_BIT(hqspi->Instance->CR, QUADSPI_CR_ABORT);
2401149e:	687b      	ldr	r3, [r7, #4]
240114a0:	681b      	ldr	r3, [r3, #0]
240114a2:	681a      	ldr	r2, [r3, #0]
240114a4:	687b      	ldr	r3, [r7, #4]
240114a6:	681b      	ldr	r3, [r3, #0]
240114a8:	f042 0202 	orr.w	r2, r2, #2
240114ac:	601a      	str	r2, [r3, #0]

    /* Wait until TC flag is set to go back in idle state */
    status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_TC, SET, tickstart, hqspi->Timeout);
240114ae:	687b      	ldr	r3, [r7, #4]
240114b0:	6c9b      	ldr	r3, [r3, #72]	; 0x48
240114b2:	9300      	str	r3, [sp, #0]
240114b4:	68bb      	ldr	r3, [r7, #8]
240114b6:	2201      	movs	r2, #1
240114b8:	2102      	movs	r1, #2
240114ba:	6878      	ldr	r0, [r7, #4]
240114bc:	f000 f993 	bl	240117e6 <QSPI_WaitFlagStateUntilTimeout>
240114c0:	4603      	mov	r3, r0
240114c2:	73fb      	strb	r3, [r7, #15]

    if (status == HAL_OK)
240114c4:	7bfb      	ldrb	r3, [r7, #15]
240114c6:	2b00      	cmp	r3, #0
240114c8:	d10e      	bne.n	240114e8 <HAL_QSPI_Abort+0xb2>
    {
      __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TC);
240114ca:	687b      	ldr	r3, [r7, #4]
240114cc:	681b      	ldr	r3, [r3, #0]
240114ce:	2202      	movs	r2, #2
240114d0:	60da      	str	r2, [r3, #12]

      /* Wait until BUSY flag is reset */
      status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, hqspi->Timeout);
240114d2:	687b      	ldr	r3, [r7, #4]
240114d4:	6c9b      	ldr	r3, [r3, #72]	; 0x48
240114d6:	9300      	str	r3, [sp, #0]
240114d8:	68bb      	ldr	r3, [r7, #8]
240114da:	2200      	movs	r2, #0
240114dc:	2120      	movs	r1, #32
240114de:	6878      	ldr	r0, [r7, #4]
240114e0:	f000 f981 	bl	240117e6 <QSPI_WaitFlagStateUntilTimeout>
240114e4:	4603      	mov	r3, r0
240114e6:	73fb      	strb	r3, [r7, #15]
    }

    if (status == HAL_OK)
240114e8:	7bfb      	ldrb	r3, [r7, #15]
240114ea:	2b00      	cmp	r3, #0
240114ec:	d10b      	bne.n	24011506 <HAL_QSPI_Abort+0xd0>
    {
      /* Reset functional mode configuration to indirect write mode by default */
      CLEAR_BIT(hqspi->Instance->CCR, QUADSPI_CCR_FMODE);
240114ee:	687b      	ldr	r3, [r7, #4]
240114f0:	681b      	ldr	r3, [r3, #0]
240114f2:	695a      	ldr	r2, [r3, #20]
240114f4:	687b      	ldr	r3, [r7, #4]
240114f6:	681b      	ldr	r3, [r3, #0]
240114f8:	f022 6240 	bic.w	r2, r2, #201326592	; 0xc000000
240114fc:	615a      	str	r2, [r3, #20]

      /* Update state */
      hqspi->State = HAL_QSPI_STATE_READY;
240114fe:	687b      	ldr	r3, [r7, #4]
24011500:	2201      	movs	r2, #1
24011502:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    }
  }

  return status;
24011506:	7bfb      	ldrb	r3, [r7, #15]
}
24011508:	4618      	mov	r0, r3
2401150a:	3710      	adds	r7, #16
2401150c:	46bd      	mov	sp, r7
2401150e:	bd80      	pop	{r7, pc}

24011510 <HAL_QSPI_Abort_IT>:
* @brief  Abort the current transmission (non-blocking function)
* @param  hqspi : QSPI handle
* @retval HAL status
*/
HAL_StatusTypeDef HAL_QSPI_Abort_IT(QSPI_HandleTypeDef *hqspi)
{
24011510:	b580      	push	{r7, lr}
24011512:	b084      	sub	sp, #16
24011514:	af00      	add	r7, sp, #0
24011516:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
24011518:	2300      	movs	r3, #0
2401151a:	73fb      	strb	r3, [r7, #15]

  /* Check if the state is in one of the busy states */
  if (((uint32_t)hqspi->State & 0x2U) != 0U)
2401151c:	687b      	ldr	r3, [r7, #4]
2401151e:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
24011522:	b2db      	uxtb	r3, r3
24011524:	f003 0302 	and.w	r3, r3, #2
24011528:	2b00      	cmp	r3, #0
2401152a:	d046      	beq.n	240115ba <HAL_QSPI_Abort_IT+0xaa>
  {
    /* Process unlocked */
    __HAL_UNLOCK(hqspi);
2401152c:	687b      	ldr	r3, [r7, #4]
2401152e:	2200      	movs	r2, #0
24011530:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Update QSPI state */
    hqspi->State = HAL_QSPI_STATE_ABORT;
24011534:	687b      	ldr	r3, [r7, #4]
24011536:	2208      	movs	r2, #8
24011538:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Disable all interrupts */
    __HAL_QSPI_DISABLE_IT(hqspi, (QSPI_IT_TO | QSPI_IT_SM | QSPI_IT_FT | QSPI_IT_TC | QSPI_IT_TE));
2401153c:	687b      	ldr	r3, [r7, #4]
2401153e:	681b      	ldr	r3, [r3, #0]
24011540:	681a      	ldr	r2, [r3, #0]
24011542:	687b      	ldr	r3, [r7, #4]
24011544:	681b      	ldr	r3, [r3, #0]
24011546:	f422 12f8 	bic.w	r2, r2, #2031616	; 0x1f0000
2401154a:	601a      	str	r2, [r3, #0]

    if ((hqspi->Instance->CR & QUADSPI_CR_DMAEN) != 0U)
2401154c:	687b      	ldr	r3, [r7, #4]
2401154e:	681b      	ldr	r3, [r3, #0]
24011550:	681b      	ldr	r3, [r3, #0]
24011552:	f003 0304 	and.w	r3, r3, #4
24011556:	2b00      	cmp	r3, #0
24011558:	d01b      	beq.n	24011592 <HAL_QSPI_Abort_IT+0x82>
    {
      /* Disable the DMA transfer by clearing the DMAEN bit in the QSPI CR register */
      CLEAR_BIT(hqspi->Instance->CR, QUADSPI_CR_DMAEN);
2401155a:	687b      	ldr	r3, [r7, #4]
2401155c:	681b      	ldr	r3, [r3, #0]
2401155e:	681a      	ldr	r2, [r3, #0]
24011560:	687b      	ldr	r3, [r7, #4]
24011562:	681b      	ldr	r3, [r3, #0]
24011564:	f022 0204 	bic.w	r2, r2, #4
24011568:	601a      	str	r2, [r3, #0]

      /* Abort MDMA channel */
      hqspi->hmdma->XferAbortCallback = QSPI_DMAAbortCplt;
2401156a:	687b      	ldr	r3, [r7, #4]
2401156c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2401156e:	4a15      	ldr	r2, [pc, #84]	; (240115c4 <HAL_QSPI_Abort_IT+0xb4>)
24011570:	659a      	str	r2, [r3, #88]	; 0x58
      if (HAL_MDMA_Abort_IT(hqspi->hmdma) != HAL_OK)
24011572:	687b      	ldr	r3, [r7, #4]
24011574:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24011576:	4618      	mov	r0, r3
24011578:	f7fd fc13 	bl	2400eda2 <HAL_MDMA_Abort_IT>
2401157c:	4603      	mov	r3, r0
2401157e:	2b00      	cmp	r3, #0
24011580:	d01b      	beq.n	240115ba <HAL_QSPI_Abort_IT+0xaa>
      {
        /* Change state of QSPI */
        hqspi->State = HAL_QSPI_STATE_READY;
24011582:	687b      	ldr	r3, [r7, #4]
24011584:	2201      	movs	r2, #1
24011586:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

        /* Abort Complete callback */
#if (USE_HAL_QSPI_REGISTER_CALLBACKS == 1)
        hqspi->AbortCpltCallback(hqspi);
#else
        HAL_QSPI_AbortCpltCallback(hqspi);
2401158a:	6878      	ldr	r0, [r7, #4]
2401158c:	f7ff fef3 	bl	24011376 <HAL_QSPI_AbortCpltCallback>
24011590:	e013      	b.n	240115ba <HAL_QSPI_Abort_IT+0xaa>
      }
    }
    else
    {
      /* Clear interrupt */
      __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TC);
24011592:	687b      	ldr	r3, [r7, #4]
24011594:	681b      	ldr	r3, [r3, #0]
24011596:	2202      	movs	r2, #2
24011598:	60da      	str	r2, [r3, #12]

      /* Enable the QSPI Transfer Complete Interrupt */
      __HAL_QSPI_ENABLE_IT(hqspi, QSPI_IT_TC);
2401159a:	687b      	ldr	r3, [r7, #4]
2401159c:	681b      	ldr	r3, [r3, #0]
2401159e:	681a      	ldr	r2, [r3, #0]
240115a0:	687b      	ldr	r3, [r7, #4]
240115a2:	681b      	ldr	r3, [r3, #0]
240115a4:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
240115a8:	601a      	str	r2, [r3, #0]

      /* Configure QSPI: CR register with Abort request */
      SET_BIT(hqspi->Instance->CR, QUADSPI_CR_ABORT);
240115aa:	687b      	ldr	r3, [r7, #4]
240115ac:	681b      	ldr	r3, [r3, #0]
240115ae:	681a      	ldr	r2, [r3, #0]
240115b0:	687b      	ldr	r3, [r7, #4]
240115b2:	681b      	ldr	r3, [r3, #0]
240115b4:	f042 0202 	orr.w	r2, r2, #2
240115b8:	601a      	str	r2, [r3, #0]
    }
  }
  return status;
240115ba:	7bfb      	ldrb	r3, [r7, #15]
}
240115bc:	4618      	mov	r0, r3
240115be:	3710      	adds	r7, #16
240115c0:	46bd      	mov	sp, r7
240115c2:	bd80      	pop	{r7, pc}
240115c4:	24011781 	.word	0x24011781

240115c8 <HAL_QSPI_SetTimeout>:
  * @param  hqspi : QSPI handle.
  * @param  Timeout : Timeout for the QSPI memory access.
  * @retval None
  */
void HAL_QSPI_SetTimeout(QSPI_HandleTypeDef *hqspi, uint32_t Timeout)
{
240115c8:	b480      	push	{r7}
240115ca:	b083      	sub	sp, #12
240115cc:	af00      	add	r7, sp, #0
240115ce:	6078      	str	r0, [r7, #4]
240115d0:	6039      	str	r1, [r7, #0]
  hqspi->Timeout = Timeout;
240115d2:	687b      	ldr	r3, [r7, #4]
240115d4:	683a      	ldr	r2, [r7, #0]
240115d6:	649a      	str	r2, [r3, #72]	; 0x48
}
240115d8:	bf00      	nop
240115da:	370c      	adds	r7, #12
240115dc:	46bd      	mov	sp, r7
240115de:	f85d 7b04 	ldr.w	r7, [sp], #4
240115e2:	4770      	bx	lr

240115e4 <HAL_QSPI_SetFifoThreshold>:
  * @param  hqspi : QSPI handle.
  * @param  Threshold : Threshold of the Fifo (value between 1 and 16).
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_QSPI_SetFifoThreshold(QSPI_HandleTypeDef *hqspi, uint32_t Threshold)
{
240115e4:	b480      	push	{r7}
240115e6:	b085      	sub	sp, #20
240115e8:	af00      	add	r7, sp, #0
240115ea:	6078      	str	r0, [r7, #4]
240115ec:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
240115ee:	2300      	movs	r3, #0
240115f0:	73fb      	strb	r3, [r7, #15]

  /* Process locked */
  __HAL_LOCK(hqspi);
240115f2:	687b      	ldr	r3, [r7, #4]
240115f4:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
240115f8:	b2db      	uxtb	r3, r3
240115fa:	2b01      	cmp	r3, #1
240115fc:	d101      	bne.n	24011602 <HAL_QSPI_SetFifoThreshold+0x1e>
240115fe:	2302      	movs	r3, #2
24011600:	e021      	b.n	24011646 <HAL_QSPI_SetFifoThreshold+0x62>
24011602:	687b      	ldr	r3, [r7, #4]
24011604:	2201      	movs	r2, #1
24011606:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  if(hqspi->State == HAL_QSPI_STATE_READY)
2401160a:	687b      	ldr	r3, [r7, #4]
2401160c:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
24011610:	b2db      	uxtb	r3, r3
24011612:	2b01      	cmp	r3, #1
24011614:	d110      	bne.n	24011638 <HAL_QSPI_SetFifoThreshold+0x54>
  {
    /* Synchronize init structure with new FIFO threshold value */
    hqspi->Init.FifoThreshold = Threshold;
24011616:	687b      	ldr	r3, [r7, #4]
24011618:	683a      	ldr	r2, [r7, #0]
2401161a:	609a      	str	r2, [r3, #8]

    /* Configure QSPI FIFO Threshold */
    MODIFY_REG(hqspi->Instance->CR, QUADSPI_CR_FTHRES,
2401161c:	687b      	ldr	r3, [r7, #4]
2401161e:	681b      	ldr	r3, [r3, #0]
24011620:	681b      	ldr	r3, [r3, #0]
24011622:	f423 6170 	bic.w	r1, r3, #3840	; 0xf00
24011626:	687b      	ldr	r3, [r7, #4]
24011628:	689b      	ldr	r3, [r3, #8]
2401162a:	3b01      	subs	r3, #1
2401162c:	021a      	lsls	r2, r3, #8
2401162e:	687b      	ldr	r3, [r7, #4]
24011630:	681b      	ldr	r3, [r3, #0]
24011632:	430a      	orrs	r2, r1
24011634:	601a      	str	r2, [r3, #0]
24011636:	e001      	b.n	2401163c <HAL_QSPI_SetFifoThreshold+0x58>
               ((hqspi->Init.FifoThreshold - 1U) << QUADSPI_CR_FTHRES_Pos));
  }
  else
  {
    status = HAL_BUSY;
24011638:	2302      	movs	r3, #2
2401163a:	73fb      	strb	r3, [r7, #15]
  }

  /* Process unlocked */
  __HAL_UNLOCK(hqspi);
2401163c:	687b      	ldr	r3, [r7, #4]
2401163e:	2200      	movs	r2, #0
24011640:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  /* Return function status */
  return status;
24011644:	7bfb      	ldrb	r3, [r7, #15]
}
24011646:	4618      	mov	r0, r3
24011648:	3714      	adds	r7, #20
2401164a:	46bd      	mov	sp, r7
2401164c:	f85d 7b04 	ldr.w	r7, [sp], #4
24011650:	4770      	bx	lr

24011652 <HAL_QSPI_GetFifoThreshold>:
/** @brief Get QSPI Fifo threshold.
  * @param  hqspi : QSPI handle.
  * @retval Fifo threshold (value between 1 and 16)
  */
uint32_t HAL_QSPI_GetFifoThreshold(QSPI_HandleTypeDef *hqspi)
{
24011652:	b480      	push	{r7}
24011654:	b083      	sub	sp, #12
24011656:	af00      	add	r7, sp, #0
24011658:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(hqspi->Instance->CR, QUADSPI_CR_FTHRES) >> QUADSPI_CR_FTHRES_Pos) + 1U);
2401165a:	687b      	ldr	r3, [r7, #4]
2401165c:	681b      	ldr	r3, [r3, #0]
2401165e:	681b      	ldr	r3, [r3, #0]
24011660:	0a1b      	lsrs	r3, r3, #8
24011662:	f003 030f 	and.w	r3, r3, #15
24011666:	3301      	adds	r3, #1
}
24011668:	4618      	mov	r0, r3
2401166a:	370c      	adds	r7, #12
2401166c:	46bd      	mov	sp, r7
2401166e:	f85d 7b04 	ldr.w	r7, [sp], #4
24011672:	4770      	bx	lr

24011674 <HAL_QSPI_SetFlashID>:
  *                   This parameter can be a value of @ref QSPI_Flash_Select.
  * @note   The FlashID is ignored when dual flash mode is enabled.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_QSPI_SetFlashID(QSPI_HandleTypeDef *hqspi, uint32_t FlashID)
{
24011674:	b480      	push	{r7}
24011676:	b085      	sub	sp, #20
24011678:	af00      	add	r7, sp, #0
2401167a:	6078      	str	r0, [r7, #4]
2401167c:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
2401167e:	2300      	movs	r3, #0
24011680:	73fb      	strb	r3, [r7, #15]

  /* Check the parameter */
  assert_param(IS_QSPI_FLASH_ID(FlashID));

  /* Process locked */
  __HAL_LOCK(hqspi);
24011682:	687b      	ldr	r3, [r7, #4]
24011684:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
24011688:	b2db      	uxtb	r3, r3
2401168a:	2b01      	cmp	r3, #1
2401168c:	d101      	bne.n	24011692 <HAL_QSPI_SetFlashID+0x1e>
2401168e:	2302      	movs	r3, #2
24011690:	e01e      	b.n	240116d0 <HAL_QSPI_SetFlashID+0x5c>
24011692:	687b      	ldr	r3, [r7, #4]
24011694:	2201      	movs	r2, #1
24011696:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  if(hqspi->State == HAL_QSPI_STATE_READY)
2401169a:	687b      	ldr	r3, [r7, #4]
2401169c:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
240116a0:	b2db      	uxtb	r3, r3
240116a2:	2b01      	cmp	r3, #1
240116a4:	d10d      	bne.n	240116c2 <HAL_QSPI_SetFlashID+0x4e>
  {
    /* Synchronize init structure with new FlashID value */
    hqspi->Init.FlashID = FlashID;
240116a6:	687b      	ldr	r3, [r7, #4]
240116a8:	683a      	ldr	r2, [r7, #0]
240116aa:	61da      	str	r2, [r3, #28]

    /* Configure QSPI FlashID */
    MODIFY_REG(hqspi->Instance->CR, QUADSPI_CR_FSEL, FlashID);
240116ac:	687b      	ldr	r3, [r7, #4]
240116ae:	681b      	ldr	r3, [r3, #0]
240116b0:	681b      	ldr	r3, [r3, #0]
240116b2:	f023 0180 	bic.w	r1, r3, #128	; 0x80
240116b6:	687b      	ldr	r3, [r7, #4]
240116b8:	681b      	ldr	r3, [r3, #0]
240116ba:	683a      	ldr	r2, [r7, #0]
240116bc:	430a      	orrs	r2, r1
240116be:	601a      	str	r2, [r3, #0]
240116c0:	e001      	b.n	240116c6 <HAL_QSPI_SetFlashID+0x52>
  }
  else
  {
    status = HAL_BUSY;
240116c2:	2302      	movs	r3, #2
240116c4:	73fb      	strb	r3, [r7, #15]
  }

  /* Process unlocked */
  __HAL_UNLOCK(hqspi);
240116c6:	687b      	ldr	r3, [r7, #4]
240116c8:	2200      	movs	r2, #0
240116ca:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  /* Return function status */
  return status;
240116ce:	7bfb      	ldrb	r3, [r7, #15]
}
240116d0:	4618      	mov	r0, r3
240116d2:	3714      	adds	r7, #20
240116d4:	46bd      	mov	sp, r7
240116d6:	f85d 7b04 	ldr.w	r7, [sp], #4
240116da:	4770      	bx	lr

240116dc <QSPI_DMARxCplt>:
  * @brief  DMA QSPI receive process complete callback.
  * @param  hmdma : MDMA handle
  * @retval None
  */
static void QSPI_DMARxCplt(MDMA_HandleTypeDef *hmdma)
{
240116dc:	b480      	push	{r7}
240116de:	b085      	sub	sp, #20
240116e0:	af00      	add	r7, sp, #0
240116e2:	6078      	str	r0, [r7, #4]
  QSPI_HandleTypeDef* hqspi = (QSPI_HandleTypeDef*)(hmdma->Parent);
240116e4:	687b      	ldr	r3, [r7, #4]
240116e6:	6c1b      	ldr	r3, [r3, #64]	; 0x40
240116e8:	60fb      	str	r3, [r7, #12]
  hqspi->RxXferCount = 0U;
240116ea:	68fb      	ldr	r3, [r7, #12]
240116ec:	2200      	movs	r2, #0
240116ee:	639a      	str	r2, [r3, #56]	; 0x38

  /* Enable the QSPI transfer complete Interrupt */
  __HAL_QSPI_ENABLE_IT(hqspi, QSPI_IT_TC);
240116f0:	68fb      	ldr	r3, [r7, #12]
240116f2:	681b      	ldr	r3, [r3, #0]
240116f4:	681a      	ldr	r2, [r3, #0]
240116f6:	68fb      	ldr	r3, [r7, #12]
240116f8:	681b      	ldr	r3, [r3, #0]
240116fa:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
240116fe:	601a      	str	r2, [r3, #0]
}
24011700:	bf00      	nop
24011702:	3714      	adds	r7, #20
24011704:	46bd      	mov	sp, r7
24011706:	f85d 7b04 	ldr.w	r7, [sp], #4
2401170a:	4770      	bx	lr

2401170c <QSPI_DMATxCplt>:
  * @brief  DMA QSPI transmit process complete callback.
  * @param  hmdma : MDMA handle
  * @retval None
  */
static void QSPI_DMATxCplt(MDMA_HandleTypeDef *hmdma)
{
2401170c:	b480      	push	{r7}
2401170e:	b085      	sub	sp, #20
24011710:	af00      	add	r7, sp, #0
24011712:	6078      	str	r0, [r7, #4]
  QSPI_HandleTypeDef* hqspi = (QSPI_HandleTypeDef*)(hmdma->Parent);
24011714:	687b      	ldr	r3, [r7, #4]
24011716:	6c1b      	ldr	r3, [r3, #64]	; 0x40
24011718:	60fb      	str	r3, [r7, #12]
  hqspi->TxXferCount = 0U;
2401171a:	68fb      	ldr	r3, [r7, #12]
2401171c:	2200      	movs	r2, #0
2401171e:	62da      	str	r2, [r3, #44]	; 0x2c

  /* Enable the QSPI transfer complete Interrupt */
  __HAL_QSPI_ENABLE_IT(hqspi, QSPI_IT_TC);
24011720:	68fb      	ldr	r3, [r7, #12]
24011722:	681b      	ldr	r3, [r3, #0]
24011724:	681a      	ldr	r2, [r3, #0]
24011726:	68fb      	ldr	r3, [r7, #12]
24011728:	681b      	ldr	r3, [r3, #0]
2401172a:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
2401172e:	601a      	str	r2, [r3, #0]
}
24011730:	bf00      	nop
24011732:	3714      	adds	r7, #20
24011734:	46bd      	mov	sp, r7
24011736:	f85d 7b04 	ldr.w	r7, [sp], #4
2401173a:	4770      	bx	lr

2401173c <QSPI_DMAError>:
  * @brief  DMA QSPI communication error callback.
  * @param  hmdma : MDMA handle
  * @retval None
  */
static void QSPI_DMAError(MDMA_HandleTypeDef *hmdma)
{
2401173c:	b580      	push	{r7, lr}
2401173e:	b084      	sub	sp, #16
24011740:	af00      	add	r7, sp, #0
24011742:	6078      	str	r0, [r7, #4]
  QSPI_HandleTypeDef* hqspi = ( QSPI_HandleTypeDef* )(hmdma->Parent);
24011744:	687b      	ldr	r3, [r7, #4]
24011746:	6c1b      	ldr	r3, [r3, #64]	; 0x40
24011748:	60fb      	str	r3, [r7, #12]

  hqspi->RxXferCount = 0U;
2401174a:	68fb      	ldr	r3, [r7, #12]
2401174c:	2200      	movs	r2, #0
2401174e:	639a      	str	r2, [r3, #56]	; 0x38
  hqspi->TxXferCount = 0U;
24011750:	68fb      	ldr	r3, [r7, #12]
24011752:	2200      	movs	r2, #0
24011754:	62da      	str	r2, [r3, #44]	; 0x2c
  hqspi->ErrorCode   |= HAL_QSPI_ERROR_DMA;
24011756:	68fb      	ldr	r3, [r7, #12]
24011758:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2401175a:	f043 0204 	orr.w	r2, r3, #4
2401175e:	68fb      	ldr	r3, [r7, #12]
24011760:	645a      	str	r2, [r3, #68]	; 0x44

  /* Disable the MDMA transfer by clearing the DMAEN bit in the QSPI CR register */
  CLEAR_BIT(hqspi->Instance->CR, QUADSPI_CR_DMAEN);
24011762:	68fb      	ldr	r3, [r7, #12]
24011764:	681b      	ldr	r3, [r3, #0]
24011766:	681a      	ldr	r2, [r3, #0]
24011768:	68fb      	ldr	r3, [r7, #12]
2401176a:	681b      	ldr	r3, [r3, #0]
2401176c:	f022 0204 	bic.w	r2, r2, #4
24011770:	601a      	str	r2, [r3, #0]

  /* Abort the QSPI */
  (void)HAL_QSPI_Abort_IT(hqspi);
24011772:	68f8      	ldr	r0, [r7, #12]
24011774:	f7ff fecc 	bl	24011510 <HAL_QSPI_Abort_IT>

}
24011778:	bf00      	nop
2401177a:	3710      	adds	r7, #16
2401177c:	46bd      	mov	sp, r7
2401177e:	bd80      	pop	{r7, pc}

24011780 <QSPI_DMAAbortCplt>:
  * @brief  MDMA QSPI abort complete callback.
  * @param  hmdma : MDMA handle
  * @retval None
  */
static void QSPI_DMAAbortCplt(MDMA_HandleTypeDef *hmdma)
{
24011780:	b580      	push	{r7, lr}
24011782:	b084      	sub	sp, #16
24011784:	af00      	add	r7, sp, #0
24011786:	6078      	str	r0, [r7, #4]
  QSPI_HandleTypeDef* hqspi = ( QSPI_HandleTypeDef* )(hmdma->Parent);
24011788:	687b      	ldr	r3, [r7, #4]
2401178a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
2401178c:	60fb      	str	r3, [r7, #12]

  hqspi->RxXferCount = 0U;
2401178e:	68fb      	ldr	r3, [r7, #12]
24011790:	2200      	movs	r2, #0
24011792:	639a      	str	r2, [r3, #56]	; 0x38
  hqspi->TxXferCount = 0U;
24011794:	68fb      	ldr	r3, [r7, #12]
24011796:	2200      	movs	r2, #0
24011798:	62da      	str	r2, [r3, #44]	; 0x2c

  if(hqspi->State == HAL_QSPI_STATE_ABORT)
2401179a:	68fb      	ldr	r3, [r7, #12]
2401179c:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
240117a0:	b2db      	uxtb	r3, r3
240117a2:	2b08      	cmp	r3, #8
240117a4:	d114      	bne.n	240117d0 <QSPI_DMAAbortCplt+0x50>
  {
    /* MDMA Abort called by QSPI abort */
    /* Clear interrupt */
    __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TC);
240117a6:	68fb      	ldr	r3, [r7, #12]
240117a8:	681b      	ldr	r3, [r3, #0]
240117aa:	2202      	movs	r2, #2
240117ac:	60da      	str	r2, [r3, #12]

    /* Enable the QSPI Transfer Complete Interrupt */
    __HAL_QSPI_ENABLE_IT(hqspi, QSPI_IT_TC);
240117ae:	68fb      	ldr	r3, [r7, #12]
240117b0:	681b      	ldr	r3, [r3, #0]
240117b2:	681a      	ldr	r2, [r3, #0]
240117b4:	68fb      	ldr	r3, [r7, #12]
240117b6:	681b      	ldr	r3, [r3, #0]
240117b8:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
240117bc:	601a      	str	r2, [r3, #0]

    /* Configure QSPI: CR register with Abort request */
    SET_BIT(hqspi->Instance->CR, QUADSPI_CR_ABORT);
240117be:	68fb      	ldr	r3, [r7, #12]
240117c0:	681b      	ldr	r3, [r3, #0]
240117c2:	681a      	ldr	r2, [r3, #0]
240117c4:	68fb      	ldr	r3, [r7, #12]
240117c6:	681b      	ldr	r3, [r3, #0]
240117c8:	f042 0202 	orr.w	r2, r2, #2
240117cc:	601a      	str	r2, [r3, #0]
    hqspi->ErrorCallback(hqspi);
#else
    HAL_QSPI_ErrorCallback(hqspi);
#endif
  }
}
240117ce:	e006      	b.n	240117de <QSPI_DMAAbortCplt+0x5e>
    hqspi->State = HAL_QSPI_STATE_READY;
240117d0:	68fb      	ldr	r3, [r7, #12]
240117d2:	2201      	movs	r2, #1
240117d4:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    HAL_QSPI_ErrorCallback(hqspi);
240117d8:	68f8      	ldr	r0, [r7, #12]
240117da:	f7ff fdc2 	bl	24011362 <HAL_QSPI_ErrorCallback>
}
240117de:	bf00      	nop
240117e0:	3710      	adds	r7, #16
240117e2:	46bd      	mov	sp, r7
240117e4:	bd80      	pop	{r7, pc}

240117e6 <QSPI_WaitFlagStateUntilTimeout>:
  * @param  Timeout : Duration of the timeout
  * @retval HAL status
  */
static HAL_StatusTypeDef QSPI_WaitFlagStateUntilTimeout(QSPI_HandleTypeDef *hqspi, uint32_t Flag,
                                                        FlagStatus State, uint32_t Tickstart, uint32_t Timeout)
{
240117e6:	b580      	push	{r7, lr}
240117e8:	b084      	sub	sp, #16
240117ea:	af00      	add	r7, sp, #0
240117ec:	60f8      	str	r0, [r7, #12]
240117ee:	60b9      	str	r1, [r7, #8]
240117f0:	603b      	str	r3, [r7, #0]
240117f2:	4613      	mov	r3, r2
240117f4:	71fb      	strb	r3, [r7, #7]
  /* Wait until flag is in expected state */
  while((__HAL_QSPI_GET_FLAG(hqspi, Flag)) != State)
240117f6:	e01a      	b.n	2401182e <QSPI_WaitFlagStateUntilTimeout+0x48>
  {
    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
240117f8:	69bb      	ldr	r3, [r7, #24]
240117fa:	f1b3 3fff 	cmp.w	r3, #4294967295
240117fe:	d016      	beq.n	2401182e <QSPI_WaitFlagStateUntilTimeout+0x48>
    {
      if(((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
24011800:	f7ef f826 	bl	24000850 <HAL_GetTick>
24011804:	4602      	mov	r2, r0
24011806:	683b      	ldr	r3, [r7, #0]
24011808:	1ad3      	subs	r3, r2, r3
2401180a:	69ba      	ldr	r2, [r7, #24]
2401180c:	429a      	cmp	r2, r3
2401180e:	d302      	bcc.n	24011816 <QSPI_WaitFlagStateUntilTimeout+0x30>
24011810:	69bb      	ldr	r3, [r7, #24]
24011812:	2b00      	cmp	r3, #0
24011814:	d10b      	bne.n	2401182e <QSPI_WaitFlagStateUntilTimeout+0x48>
      {
        hqspi->State     = HAL_QSPI_STATE_ERROR;
24011816:	68fb      	ldr	r3, [r7, #12]
24011818:	2204      	movs	r2, #4
2401181a:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
        hqspi->ErrorCode |= HAL_QSPI_ERROR_TIMEOUT;
2401181e:	68fb      	ldr	r3, [r7, #12]
24011820:	6c5b      	ldr	r3, [r3, #68]	; 0x44
24011822:	f043 0201 	orr.w	r2, r3, #1
24011826:	68fb      	ldr	r3, [r7, #12]
24011828:	645a      	str	r2, [r3, #68]	; 0x44

        return HAL_ERROR;
2401182a:	2301      	movs	r3, #1
2401182c:	e00e      	b.n	2401184c <QSPI_WaitFlagStateUntilTimeout+0x66>
  while((__HAL_QSPI_GET_FLAG(hqspi, Flag)) != State)
2401182e:	68fb      	ldr	r3, [r7, #12]
24011830:	681b      	ldr	r3, [r3, #0]
24011832:	689a      	ldr	r2, [r3, #8]
24011834:	68bb      	ldr	r3, [r7, #8]
24011836:	4013      	ands	r3, r2
24011838:	2b00      	cmp	r3, #0
2401183a:	bf14      	ite	ne
2401183c:	2301      	movne	r3, #1
2401183e:	2300      	moveq	r3, #0
24011840:	b2db      	uxtb	r3, r3
24011842:	461a      	mov	r2, r3
24011844:	79fb      	ldrb	r3, [r7, #7]
24011846:	429a      	cmp	r2, r3
24011848:	d1d6      	bne.n	240117f8 <QSPI_WaitFlagStateUntilTimeout+0x12>
      }
    }
  }
  return HAL_OK;
2401184a:	2300      	movs	r3, #0
}
2401184c:	4618      	mov	r0, r3
2401184e:	3710      	adds	r7, #16
24011850:	46bd      	mov	sp, r7
24011852:	bd80      	pop	{r7, pc}

24011854 <QSPI_Config>:
  *            @arg QSPI_FUNCTIONAL_MODE_AUTO_POLLING: Automatic polling mode
  *            @arg QSPI_FUNCTIONAL_MODE_MEMORY_MAPPED: Memory-mapped mode
  * @retval None
  */
static void QSPI_Config(QSPI_HandleTypeDef *hqspi, QSPI_CommandTypeDef *cmd, uint32_t FunctionalMode)
{
24011854:	b480      	push	{r7}
24011856:	b085      	sub	sp, #20
24011858:	af00      	add	r7, sp, #0
2401185a:	60f8      	str	r0, [r7, #12]
2401185c:	60b9      	str	r1, [r7, #8]
2401185e:	607a      	str	r2, [r7, #4]
  assert_param(IS_QSPI_FUNCTIONAL_MODE(FunctionalMode));

  if ((cmd->DataMode != QSPI_DATA_NONE) && (FunctionalMode != QSPI_FUNCTIONAL_MODE_MEMORY_MAPPED))
24011860:	68bb      	ldr	r3, [r7, #8]
24011862:	6a5b      	ldr	r3, [r3, #36]	; 0x24
24011864:	2b00      	cmp	r3, #0
24011866:	d009      	beq.n	2401187c <QSPI_Config+0x28>
24011868:	687b      	ldr	r3, [r7, #4]
2401186a:	f1b3 6f40 	cmp.w	r3, #201326592	; 0xc000000
2401186e:	d005      	beq.n	2401187c <QSPI_Config+0x28>
  {
    /* Configure QSPI: DLR register with the number of data to read or write */
    WRITE_REG(hqspi->Instance->DLR, (cmd->NbData - 1U));
24011870:	68bb      	ldr	r3, [r7, #8]
24011872:	6a9a      	ldr	r2, [r3, #40]	; 0x28
24011874:	68fb      	ldr	r3, [r7, #12]
24011876:	681b      	ldr	r3, [r3, #0]
24011878:	3a01      	subs	r2, #1
2401187a:	611a      	str	r2, [r3, #16]
  }

  if (cmd->InstructionMode != QSPI_INSTRUCTION_NONE)
2401187c:	68bb      	ldr	r3, [r7, #8]
2401187e:	699b      	ldr	r3, [r3, #24]
24011880:	2b00      	cmp	r3, #0
24011882:	f000 80b9 	beq.w	240119f8 <QSPI_Config+0x1a4>
  {
    if (cmd->AlternateByteMode != QSPI_ALTERNATE_BYTES_NONE)
24011886:	68bb      	ldr	r3, [r7, #8]
24011888:	6a1b      	ldr	r3, [r3, #32]
2401188a:	2b00      	cmp	r3, #0
2401188c:	d05f      	beq.n	2401194e <QSPI_Config+0xfa>
    {
      /* Configure QSPI: ABR register with alternate bytes value */
      WRITE_REG(hqspi->Instance->ABR, cmd->AlternateBytes);
2401188e:	68fb      	ldr	r3, [r7, #12]
24011890:	681b      	ldr	r3, [r3, #0]
24011892:	68ba      	ldr	r2, [r7, #8]
24011894:	6892      	ldr	r2, [r2, #8]
24011896:	61da      	str	r2, [r3, #28]

      if (cmd->AddressMode != QSPI_ADDRESS_NONE)
24011898:	68bb      	ldr	r3, [r7, #8]
2401189a:	69db      	ldr	r3, [r3, #28]
2401189c:	2b00      	cmp	r3, #0
2401189e:	d031      	beq.n	24011904 <QSPI_Config+0xb0>
      {
        /*---- Command with instruction, address and alternate bytes ----*/
        /* Configure QSPI: CCR register with all communications parameters */
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
240118a0:	68bb      	ldr	r3, [r7, #8]
240118a2:	6ada      	ldr	r2, [r3, #44]	; 0x2c
240118a4:	68bb      	ldr	r3, [r7, #8]
240118a6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
240118a8:	431a      	orrs	r2, r3
240118aa:	68bb      	ldr	r3, [r7, #8]
240118ac:	6b5b      	ldr	r3, [r3, #52]	; 0x34
240118ae:	431a      	orrs	r2, r3
240118b0:	68bb      	ldr	r3, [r7, #8]
240118b2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
240118b4:	431a      	orrs	r2, r3
240118b6:	68bb      	ldr	r3, [r7, #8]
240118b8:	695b      	ldr	r3, [r3, #20]
240118ba:	049b      	lsls	r3, r3, #18
240118bc:	431a      	orrs	r2, r3
240118be:	68bb      	ldr	r3, [r7, #8]
240118c0:	691b      	ldr	r3, [r3, #16]
240118c2:	431a      	orrs	r2, r3
240118c4:	68bb      	ldr	r3, [r7, #8]
240118c6:	6a1b      	ldr	r3, [r3, #32]
240118c8:	431a      	orrs	r2, r3
240118ca:	68bb      	ldr	r3, [r7, #8]
240118cc:	68db      	ldr	r3, [r3, #12]
240118ce:	431a      	orrs	r2, r3
240118d0:	68bb      	ldr	r3, [r7, #8]
240118d2:	69db      	ldr	r3, [r3, #28]
240118d4:	431a      	orrs	r2, r3
240118d6:	68bb      	ldr	r3, [r7, #8]
240118d8:	699b      	ldr	r3, [r3, #24]
240118da:	431a      	orrs	r2, r3
240118dc:	68bb      	ldr	r3, [r7, #8]
240118de:	681b      	ldr	r3, [r3, #0]
240118e0:	ea42 0103 	orr.w	r1, r2, r3
240118e4:	68fb      	ldr	r3, [r7, #12]
240118e6:	681b      	ldr	r3, [r3, #0]
240118e8:	687a      	ldr	r2, [r7, #4]
240118ea:	430a      	orrs	r2, r1
240118ec:	615a      	str	r2, [r3, #20]
                                         cmd->DataMode | (cmd->DummyCycles << QUADSPI_CCR_DCYC_Pos) |
                                         cmd->AlternateBytesSize | cmd->AlternateByteMode |
                                         cmd->AddressSize | cmd->AddressMode | cmd->InstructionMode |
                                         cmd->Instruction | FunctionalMode));

        if (FunctionalMode != QSPI_FUNCTIONAL_MODE_MEMORY_MAPPED)
240118ee:	687b      	ldr	r3, [r7, #4]
240118f0:	f1b3 6f40 	cmp.w	r3, #201326592	; 0xc000000
240118f4:	f000 812e 	beq.w	24011b54 <QSPI_Config+0x300>
        {
          /* Configure QSPI: AR register with address value */
          WRITE_REG(hqspi->Instance->AR, cmd->Address);
240118f8:	68fb      	ldr	r3, [r7, #12]
240118fa:	681b      	ldr	r3, [r3, #0]
240118fc:	68ba      	ldr	r2, [r7, #8]
240118fe:	6852      	ldr	r2, [r2, #4]
24011900:	619a      	str	r2, [r3, #24]
                                           cmd->InstructionMode | FunctionalMode));
        }
      }
    }
  }
}
24011902:	e127      	b.n	24011b54 <QSPI_Config+0x300>
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
24011904:	68bb      	ldr	r3, [r7, #8]
24011906:	6ada      	ldr	r2, [r3, #44]	; 0x2c
24011908:	68bb      	ldr	r3, [r7, #8]
2401190a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2401190c:	431a      	orrs	r2, r3
2401190e:	68bb      	ldr	r3, [r7, #8]
24011910:	6b5b      	ldr	r3, [r3, #52]	; 0x34
24011912:	431a      	orrs	r2, r3
24011914:	68bb      	ldr	r3, [r7, #8]
24011916:	6a5b      	ldr	r3, [r3, #36]	; 0x24
24011918:	431a      	orrs	r2, r3
2401191a:	68bb      	ldr	r3, [r7, #8]
2401191c:	695b      	ldr	r3, [r3, #20]
2401191e:	049b      	lsls	r3, r3, #18
24011920:	431a      	orrs	r2, r3
24011922:	68bb      	ldr	r3, [r7, #8]
24011924:	691b      	ldr	r3, [r3, #16]
24011926:	431a      	orrs	r2, r3
24011928:	68bb      	ldr	r3, [r7, #8]
2401192a:	6a1b      	ldr	r3, [r3, #32]
2401192c:	431a      	orrs	r2, r3
2401192e:	68bb      	ldr	r3, [r7, #8]
24011930:	69db      	ldr	r3, [r3, #28]
24011932:	431a      	orrs	r2, r3
24011934:	68bb      	ldr	r3, [r7, #8]
24011936:	699b      	ldr	r3, [r3, #24]
24011938:	431a      	orrs	r2, r3
2401193a:	68bb      	ldr	r3, [r7, #8]
2401193c:	681b      	ldr	r3, [r3, #0]
2401193e:	ea42 0103 	orr.w	r1, r2, r3
24011942:	68fb      	ldr	r3, [r7, #12]
24011944:	681b      	ldr	r3, [r3, #0]
24011946:	687a      	ldr	r2, [r7, #4]
24011948:	430a      	orrs	r2, r1
2401194a:	615a      	str	r2, [r3, #20]
}
2401194c:	e102      	b.n	24011b54 <QSPI_Config+0x300>
      if (cmd->AddressMode != QSPI_ADDRESS_NONE)
2401194e:	68bb      	ldr	r3, [r7, #8]
24011950:	69db      	ldr	r3, [r3, #28]
24011952:	2b00      	cmp	r3, #0
24011954:	d02e      	beq.n	240119b4 <QSPI_Config+0x160>
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
24011956:	68bb      	ldr	r3, [r7, #8]
24011958:	6ada      	ldr	r2, [r3, #44]	; 0x2c
2401195a:	68bb      	ldr	r3, [r7, #8]
2401195c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2401195e:	431a      	orrs	r2, r3
24011960:	68bb      	ldr	r3, [r7, #8]
24011962:	6b5b      	ldr	r3, [r3, #52]	; 0x34
24011964:	431a      	orrs	r2, r3
24011966:	68bb      	ldr	r3, [r7, #8]
24011968:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2401196a:	431a      	orrs	r2, r3
2401196c:	68bb      	ldr	r3, [r7, #8]
2401196e:	695b      	ldr	r3, [r3, #20]
24011970:	049b      	lsls	r3, r3, #18
24011972:	431a      	orrs	r2, r3
24011974:	68bb      	ldr	r3, [r7, #8]
24011976:	6a1b      	ldr	r3, [r3, #32]
24011978:	431a      	orrs	r2, r3
2401197a:	68bb      	ldr	r3, [r7, #8]
2401197c:	68db      	ldr	r3, [r3, #12]
2401197e:	431a      	orrs	r2, r3
24011980:	68bb      	ldr	r3, [r7, #8]
24011982:	69db      	ldr	r3, [r3, #28]
24011984:	431a      	orrs	r2, r3
24011986:	68bb      	ldr	r3, [r7, #8]
24011988:	699b      	ldr	r3, [r3, #24]
2401198a:	431a      	orrs	r2, r3
2401198c:	68bb      	ldr	r3, [r7, #8]
2401198e:	681b      	ldr	r3, [r3, #0]
24011990:	ea42 0103 	orr.w	r1, r2, r3
24011994:	68fb      	ldr	r3, [r7, #12]
24011996:	681b      	ldr	r3, [r3, #0]
24011998:	687a      	ldr	r2, [r7, #4]
2401199a:	430a      	orrs	r2, r1
2401199c:	615a      	str	r2, [r3, #20]
        if (FunctionalMode != QSPI_FUNCTIONAL_MODE_MEMORY_MAPPED)
2401199e:	687b      	ldr	r3, [r7, #4]
240119a0:	f1b3 6f40 	cmp.w	r3, #201326592	; 0xc000000
240119a4:	f000 80d6 	beq.w	24011b54 <QSPI_Config+0x300>
          WRITE_REG(hqspi->Instance->AR, cmd->Address);
240119a8:	68fb      	ldr	r3, [r7, #12]
240119aa:	681b      	ldr	r3, [r3, #0]
240119ac:	68ba      	ldr	r2, [r7, #8]
240119ae:	6852      	ldr	r2, [r2, #4]
240119b0:	619a      	str	r2, [r3, #24]
}
240119b2:	e0cf      	b.n	24011b54 <QSPI_Config+0x300>
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
240119b4:	68bb      	ldr	r3, [r7, #8]
240119b6:	6ada      	ldr	r2, [r3, #44]	; 0x2c
240119b8:	68bb      	ldr	r3, [r7, #8]
240119ba:	6b1b      	ldr	r3, [r3, #48]	; 0x30
240119bc:	431a      	orrs	r2, r3
240119be:	68bb      	ldr	r3, [r7, #8]
240119c0:	6b5b      	ldr	r3, [r3, #52]	; 0x34
240119c2:	431a      	orrs	r2, r3
240119c4:	68bb      	ldr	r3, [r7, #8]
240119c6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
240119c8:	431a      	orrs	r2, r3
240119ca:	68bb      	ldr	r3, [r7, #8]
240119cc:	695b      	ldr	r3, [r3, #20]
240119ce:	049b      	lsls	r3, r3, #18
240119d0:	431a      	orrs	r2, r3
240119d2:	68bb      	ldr	r3, [r7, #8]
240119d4:	6a1b      	ldr	r3, [r3, #32]
240119d6:	431a      	orrs	r2, r3
240119d8:	68bb      	ldr	r3, [r7, #8]
240119da:	69db      	ldr	r3, [r3, #28]
240119dc:	431a      	orrs	r2, r3
240119de:	68bb      	ldr	r3, [r7, #8]
240119e0:	699b      	ldr	r3, [r3, #24]
240119e2:	431a      	orrs	r2, r3
240119e4:	68bb      	ldr	r3, [r7, #8]
240119e6:	681b      	ldr	r3, [r3, #0]
240119e8:	ea42 0103 	orr.w	r1, r2, r3
240119ec:	68fb      	ldr	r3, [r7, #12]
240119ee:	681b      	ldr	r3, [r3, #0]
240119f0:	687a      	ldr	r2, [r7, #4]
240119f2:	430a      	orrs	r2, r1
240119f4:	615a      	str	r2, [r3, #20]
}
240119f6:	e0ad      	b.n	24011b54 <QSPI_Config+0x300>
    if (cmd->AlternateByteMode != QSPI_ALTERNATE_BYTES_NONE)
240119f8:	68bb      	ldr	r3, [r7, #8]
240119fa:	6a1b      	ldr	r3, [r3, #32]
240119fc:	2b00      	cmp	r3, #0
240119fe:	d058      	beq.n	24011ab2 <QSPI_Config+0x25e>
      WRITE_REG(hqspi->Instance->ABR, cmd->AlternateBytes);
24011a00:	68fb      	ldr	r3, [r7, #12]
24011a02:	681b      	ldr	r3, [r3, #0]
24011a04:	68ba      	ldr	r2, [r7, #8]
24011a06:	6892      	ldr	r2, [r2, #8]
24011a08:	61da      	str	r2, [r3, #28]
      if (cmd->AddressMode != QSPI_ADDRESS_NONE)
24011a0a:	68bb      	ldr	r3, [r7, #8]
24011a0c:	69db      	ldr	r3, [r3, #28]
24011a0e:	2b00      	cmp	r3, #0
24011a10:	d02d      	beq.n	24011a6e <QSPI_Config+0x21a>
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
24011a12:	68bb      	ldr	r3, [r7, #8]
24011a14:	6ada      	ldr	r2, [r3, #44]	; 0x2c
24011a16:	68bb      	ldr	r3, [r7, #8]
24011a18:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24011a1a:	431a      	orrs	r2, r3
24011a1c:	68bb      	ldr	r3, [r7, #8]
24011a1e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
24011a20:	431a      	orrs	r2, r3
24011a22:	68bb      	ldr	r3, [r7, #8]
24011a24:	6a5b      	ldr	r3, [r3, #36]	; 0x24
24011a26:	431a      	orrs	r2, r3
24011a28:	68bb      	ldr	r3, [r7, #8]
24011a2a:	695b      	ldr	r3, [r3, #20]
24011a2c:	049b      	lsls	r3, r3, #18
24011a2e:	431a      	orrs	r2, r3
24011a30:	68bb      	ldr	r3, [r7, #8]
24011a32:	691b      	ldr	r3, [r3, #16]
24011a34:	431a      	orrs	r2, r3
24011a36:	68bb      	ldr	r3, [r7, #8]
24011a38:	6a1b      	ldr	r3, [r3, #32]
24011a3a:	431a      	orrs	r2, r3
24011a3c:	68bb      	ldr	r3, [r7, #8]
24011a3e:	68db      	ldr	r3, [r3, #12]
24011a40:	431a      	orrs	r2, r3
24011a42:	68bb      	ldr	r3, [r7, #8]
24011a44:	69db      	ldr	r3, [r3, #28]
24011a46:	431a      	orrs	r2, r3
24011a48:	68bb      	ldr	r3, [r7, #8]
24011a4a:	699b      	ldr	r3, [r3, #24]
24011a4c:	ea42 0103 	orr.w	r1, r2, r3
24011a50:	68fb      	ldr	r3, [r7, #12]
24011a52:	681b      	ldr	r3, [r3, #0]
24011a54:	687a      	ldr	r2, [r7, #4]
24011a56:	430a      	orrs	r2, r1
24011a58:	615a      	str	r2, [r3, #20]
        if (FunctionalMode != QSPI_FUNCTIONAL_MODE_MEMORY_MAPPED)
24011a5a:	687b      	ldr	r3, [r7, #4]
24011a5c:	f1b3 6f40 	cmp.w	r3, #201326592	; 0xc000000
24011a60:	d078      	beq.n	24011b54 <QSPI_Config+0x300>
          WRITE_REG(hqspi->Instance->AR, cmd->Address);
24011a62:	68fb      	ldr	r3, [r7, #12]
24011a64:	681b      	ldr	r3, [r3, #0]
24011a66:	68ba      	ldr	r2, [r7, #8]
24011a68:	6852      	ldr	r2, [r2, #4]
24011a6a:	619a      	str	r2, [r3, #24]
}
24011a6c:	e072      	b.n	24011b54 <QSPI_Config+0x300>
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
24011a6e:	68bb      	ldr	r3, [r7, #8]
24011a70:	6ada      	ldr	r2, [r3, #44]	; 0x2c
24011a72:	68bb      	ldr	r3, [r7, #8]
24011a74:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24011a76:	431a      	orrs	r2, r3
24011a78:	68bb      	ldr	r3, [r7, #8]
24011a7a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
24011a7c:	431a      	orrs	r2, r3
24011a7e:	68bb      	ldr	r3, [r7, #8]
24011a80:	6a5b      	ldr	r3, [r3, #36]	; 0x24
24011a82:	431a      	orrs	r2, r3
24011a84:	68bb      	ldr	r3, [r7, #8]
24011a86:	695b      	ldr	r3, [r3, #20]
24011a88:	049b      	lsls	r3, r3, #18
24011a8a:	431a      	orrs	r2, r3
24011a8c:	68bb      	ldr	r3, [r7, #8]
24011a8e:	691b      	ldr	r3, [r3, #16]
24011a90:	431a      	orrs	r2, r3
24011a92:	68bb      	ldr	r3, [r7, #8]
24011a94:	6a1b      	ldr	r3, [r3, #32]
24011a96:	431a      	orrs	r2, r3
24011a98:	68bb      	ldr	r3, [r7, #8]
24011a9a:	69db      	ldr	r3, [r3, #28]
24011a9c:	431a      	orrs	r2, r3
24011a9e:	68bb      	ldr	r3, [r7, #8]
24011aa0:	699b      	ldr	r3, [r3, #24]
24011aa2:	ea42 0103 	orr.w	r1, r2, r3
24011aa6:	68fb      	ldr	r3, [r7, #12]
24011aa8:	681b      	ldr	r3, [r3, #0]
24011aaa:	687a      	ldr	r2, [r7, #4]
24011aac:	430a      	orrs	r2, r1
24011aae:	615a      	str	r2, [r3, #20]
}
24011ab0:	e050      	b.n	24011b54 <QSPI_Config+0x300>
      if (cmd->AddressMode != QSPI_ADDRESS_NONE)
24011ab2:	68bb      	ldr	r3, [r7, #8]
24011ab4:	69db      	ldr	r3, [r3, #28]
24011ab6:	2b00      	cmp	r3, #0
24011ab8:	d02a      	beq.n	24011b10 <QSPI_Config+0x2bc>
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
24011aba:	68bb      	ldr	r3, [r7, #8]
24011abc:	6ada      	ldr	r2, [r3, #44]	; 0x2c
24011abe:	68bb      	ldr	r3, [r7, #8]
24011ac0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24011ac2:	431a      	orrs	r2, r3
24011ac4:	68bb      	ldr	r3, [r7, #8]
24011ac6:	6b5b      	ldr	r3, [r3, #52]	; 0x34
24011ac8:	431a      	orrs	r2, r3
24011aca:	68bb      	ldr	r3, [r7, #8]
24011acc:	6a5b      	ldr	r3, [r3, #36]	; 0x24
24011ace:	431a      	orrs	r2, r3
24011ad0:	68bb      	ldr	r3, [r7, #8]
24011ad2:	695b      	ldr	r3, [r3, #20]
24011ad4:	049b      	lsls	r3, r3, #18
24011ad6:	431a      	orrs	r2, r3
24011ad8:	68bb      	ldr	r3, [r7, #8]
24011ada:	6a1b      	ldr	r3, [r3, #32]
24011adc:	431a      	orrs	r2, r3
24011ade:	68bb      	ldr	r3, [r7, #8]
24011ae0:	68db      	ldr	r3, [r3, #12]
24011ae2:	431a      	orrs	r2, r3
24011ae4:	68bb      	ldr	r3, [r7, #8]
24011ae6:	69db      	ldr	r3, [r3, #28]
24011ae8:	431a      	orrs	r2, r3
24011aea:	68bb      	ldr	r3, [r7, #8]
24011aec:	699b      	ldr	r3, [r3, #24]
24011aee:	ea42 0103 	orr.w	r1, r2, r3
24011af2:	68fb      	ldr	r3, [r7, #12]
24011af4:	681b      	ldr	r3, [r3, #0]
24011af6:	687a      	ldr	r2, [r7, #4]
24011af8:	430a      	orrs	r2, r1
24011afa:	615a      	str	r2, [r3, #20]
        if (FunctionalMode != QSPI_FUNCTIONAL_MODE_MEMORY_MAPPED)
24011afc:	687b      	ldr	r3, [r7, #4]
24011afe:	f1b3 6f40 	cmp.w	r3, #201326592	; 0xc000000
24011b02:	d027      	beq.n	24011b54 <QSPI_Config+0x300>
          WRITE_REG(hqspi->Instance->AR, cmd->Address);
24011b04:	68fb      	ldr	r3, [r7, #12]
24011b06:	681b      	ldr	r3, [r3, #0]
24011b08:	68ba      	ldr	r2, [r7, #8]
24011b0a:	6852      	ldr	r2, [r2, #4]
24011b0c:	619a      	str	r2, [r3, #24]
}
24011b0e:	e021      	b.n	24011b54 <QSPI_Config+0x300>
        if (cmd->DataMode != QSPI_DATA_NONE)
24011b10:	68bb      	ldr	r3, [r7, #8]
24011b12:	6a5b      	ldr	r3, [r3, #36]	; 0x24
24011b14:	2b00      	cmp	r3, #0
24011b16:	d01d      	beq.n	24011b54 <QSPI_Config+0x300>
          WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
24011b18:	68bb      	ldr	r3, [r7, #8]
24011b1a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
24011b1c:	68bb      	ldr	r3, [r7, #8]
24011b1e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24011b20:	431a      	orrs	r2, r3
24011b22:	68bb      	ldr	r3, [r7, #8]
24011b24:	6b5b      	ldr	r3, [r3, #52]	; 0x34
24011b26:	431a      	orrs	r2, r3
24011b28:	68bb      	ldr	r3, [r7, #8]
24011b2a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
24011b2c:	431a      	orrs	r2, r3
24011b2e:	68bb      	ldr	r3, [r7, #8]
24011b30:	695b      	ldr	r3, [r3, #20]
24011b32:	049b      	lsls	r3, r3, #18
24011b34:	431a      	orrs	r2, r3
24011b36:	68bb      	ldr	r3, [r7, #8]
24011b38:	6a1b      	ldr	r3, [r3, #32]
24011b3a:	431a      	orrs	r2, r3
24011b3c:	68bb      	ldr	r3, [r7, #8]
24011b3e:	69db      	ldr	r3, [r3, #28]
24011b40:	431a      	orrs	r2, r3
24011b42:	68bb      	ldr	r3, [r7, #8]
24011b44:	699b      	ldr	r3, [r3, #24]
24011b46:	ea42 0103 	orr.w	r1, r2, r3
24011b4a:	68fb      	ldr	r3, [r7, #12]
24011b4c:	681b      	ldr	r3, [r3, #0]
24011b4e:	687a      	ldr	r2, [r7, #4]
24011b50:	430a      	orrs	r2, r1
24011b52:	615a      	str	r2, [r3, #20]
}
24011b54:	bf00      	nop
24011b56:	3714      	adds	r7, #20
24011b58:	46bd      	mov	sp, r7
24011b5a:	f85d 7b04 	ldr.w	r7, [sp], #4
24011b5e:	4770      	bx	lr

24011b60 <HAL_RCC_DeInit>:
  *            - Peripheral clocks
  *            - LSI, LSE and RTC clocks
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_DeInit(void)
{
24011b60:	b580      	push	{r7, lr}
24011b62:	b082      	sub	sp, #8
24011b64:	af00      	add	r7, sp, #0
  uint32_t tickstart;

        /* Increasing the CPU frequency */
  if(FLASH_LATENCY_DEFAULT  > __HAL_FLASH_GET_LATENCY())
24011b66:	4b89      	ldr	r3, [pc, #548]	; (24011d8c <HAL_RCC_DeInit+0x22c>)
24011b68:	681b      	ldr	r3, [r3, #0]
24011b6a:	f003 030f 	and.w	r3, r3, #15
24011b6e:	2b06      	cmp	r3, #6
24011b70:	d80f      	bhi.n	24011b92 <HAL_RCC_DeInit+0x32>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLASH_LATENCY_DEFAULT);
24011b72:	4b86      	ldr	r3, [pc, #536]	; (24011d8c <HAL_RCC_DeInit+0x22c>)
24011b74:	681b      	ldr	r3, [r3, #0]
24011b76:	f023 030f 	bic.w	r3, r3, #15
24011b7a:	4a84      	ldr	r2, [pc, #528]	; (24011d8c <HAL_RCC_DeInit+0x22c>)
24011b7c:	f043 0307 	orr.w	r3, r3, #7
24011b80:	6013      	str	r3, [r2, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if(__HAL_FLASH_GET_LATENCY() != FLASH_LATENCY_DEFAULT)
24011b82:	4b82      	ldr	r3, [pc, #520]	; (24011d8c <HAL_RCC_DeInit+0x22c>)
24011b84:	681b      	ldr	r3, [r3, #0]
24011b86:	f003 030f 	and.w	r3, r3, #15
24011b8a:	2b07      	cmp	r3, #7
24011b8c:	d001      	beq.n	24011b92 <HAL_RCC_DeInit+0x32>
    {
      return HAL_ERROR;
24011b8e:	2301      	movs	r3, #1
24011b90:	e0f7      	b.n	24011d82 <HAL_RCC_DeInit+0x222>

  }


  /* Get Start Tick */
  tickstart = HAL_GetTick();
24011b92:	f7ee fe5d 	bl	24000850 <HAL_GetTick>
24011b96:	6078      	str	r0, [r7, #4]

  /* Set HSION bit */
  SET_BIT(RCC->CR, RCC_CR_HSION);
24011b98:	4b7d      	ldr	r3, [pc, #500]	; (24011d90 <HAL_RCC_DeInit+0x230>)
24011b9a:	681b      	ldr	r3, [r3, #0]
24011b9c:	4a7c      	ldr	r2, [pc, #496]	; (24011d90 <HAL_RCC_DeInit+0x230>)
24011b9e:	f043 0301 	orr.w	r3, r3, #1
24011ba2:	6013      	str	r3, [r2, #0]

  /* Wait till HSI is ready */
  while (READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
24011ba4:	e008      	b.n	24011bb8 <HAL_RCC_DeInit+0x58>
  {
    if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
24011ba6:	f7ee fe53 	bl	24000850 <HAL_GetTick>
24011baa:	4602      	mov	r2, r0
24011bac:	687b      	ldr	r3, [r7, #4]
24011bae:	1ad3      	subs	r3, r2, r3
24011bb0:	2b02      	cmp	r3, #2
24011bb2:	d901      	bls.n	24011bb8 <HAL_RCC_DeInit+0x58>
    {
      return HAL_TIMEOUT;
24011bb4:	2303      	movs	r3, #3
24011bb6:	e0e4      	b.n	24011d82 <HAL_RCC_DeInit+0x222>
  while (READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
24011bb8:	4b75      	ldr	r3, [pc, #468]	; (24011d90 <HAL_RCC_DeInit+0x230>)
24011bba:	681b      	ldr	r3, [r3, #0]
24011bbc:	f003 0304 	and.w	r3, r3, #4
24011bc0:	2b00      	cmp	r3, #0
24011bc2:	d0f0      	beq.n	24011ba6 <HAL_RCC_DeInit+0x46>
    }
  }

  /* Set HSITRIM[6:0] bits to the reset value */
  SET_BIT(RCC->HSICFGR, RCC_HSICFGR_HSITRIM_6);
24011bc4:	4b72      	ldr	r3, [pc, #456]	; (24011d90 <HAL_RCC_DeInit+0x230>)
24011bc6:	685b      	ldr	r3, [r3, #4]
24011bc8:	4a71      	ldr	r2, [pc, #452]	; (24011d90 <HAL_RCC_DeInit+0x230>)
24011bca:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
24011bce:	6053      	str	r3, [r2, #4]

  /* Reset CFGR register */
  CLEAR_REG(RCC->CFGR);
24011bd0:	4b6f      	ldr	r3, [pc, #444]	; (24011d90 <HAL_RCC_DeInit+0x230>)
24011bd2:	2200      	movs	r2, #0
24011bd4:	611a      	str	r2, [r3, #16]

  /* Update the SystemCoreClock and SystemD2Clock global variables */
  SystemCoreClock = HSI_VALUE;
24011bd6:	4b6f      	ldr	r3, [pc, #444]	; (24011d94 <HAL_RCC_DeInit+0x234>)
24011bd8:	4a6f      	ldr	r2, [pc, #444]	; (24011d98 <HAL_RCC_DeInit+0x238>)
24011bda:	601a      	str	r2, [r3, #0]
  SystemD2Clock = HSI_VALUE;
24011bdc:	4b6f      	ldr	r3, [pc, #444]	; (24011d9c <HAL_RCC_DeInit+0x23c>)
24011bde:	4a6e      	ldr	r2, [pc, #440]	; (24011d98 <HAL_RCC_DeInit+0x238>)
24011be0:	601a      	str	r2, [r3, #0]

  /* Adapt Systick interrupt period */
  if(HAL_InitTick(uwTickPrio) != HAL_OK)
24011be2:	4b6f      	ldr	r3, [pc, #444]	; (24011da0 <HAL_RCC_DeInit+0x240>)
24011be4:	681b      	ldr	r3, [r3, #0]
24011be6:	4618      	mov	r0, r3
24011be8:	f7ee fde8 	bl	240007bc <HAL_InitTick>
24011bec:	4603      	mov	r3, r0
24011bee:	2b00      	cmp	r3, #0
24011bf0:	d001      	beq.n	24011bf6 <HAL_RCC_DeInit+0x96>
  {
    return HAL_ERROR;
24011bf2:	2301      	movs	r3, #1
24011bf4:	e0c5      	b.n	24011d82 <HAL_RCC_DeInit+0x222>
  }

  /* Get Start Tick */
  tickstart = HAL_GetTick();
24011bf6:	f7ee fe2b 	bl	24000850 <HAL_GetTick>
24011bfa:	6078      	str	r0, [r7, #4]

  /* Wait till clock switch is ready */
  while (READ_BIT(RCC->CFGR, RCC_CFGR_SWS) != 0U)
24011bfc:	e00a      	b.n	24011c14 <HAL_RCC_DeInit+0xb4>
  {
    if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
24011bfe:	f7ee fe27 	bl	24000850 <HAL_GetTick>
24011c02:	4602      	mov	r2, r0
24011c04:	687b      	ldr	r3, [r7, #4]
24011c06:	1ad3      	subs	r3, r2, r3
24011c08:	f241 3288 	movw	r2, #5000	; 0x1388
24011c0c:	4293      	cmp	r3, r2
24011c0e:	d901      	bls.n	24011c14 <HAL_RCC_DeInit+0xb4>
    {
      return HAL_TIMEOUT;
24011c10:	2303      	movs	r3, #3
24011c12:	e0b6      	b.n	24011d82 <HAL_RCC_DeInit+0x222>
  while (READ_BIT(RCC->CFGR, RCC_CFGR_SWS) != 0U)
24011c14:	4b5e      	ldr	r3, [pc, #376]	; (24011d90 <HAL_RCC_DeInit+0x230>)
24011c16:	691b      	ldr	r3, [r3, #16]
24011c18:	f003 0338 	and.w	r3, r3, #56	; 0x38
24011c1c:	2b00      	cmp	r3, #0
24011c1e:	d1ee      	bne.n	24011bfe <HAL_RCC_DeInit+0x9e>
    }
  }

  /* Get Start Tick */
  tickstart = HAL_GetTick();
24011c20:	f7ee fe16 	bl	24000850 <HAL_GetTick>
24011c24:	6078      	str	r0, [r7, #4]

  /* Reset CSION, CSIKERON, HSEON, HSI48ON, HSECSSON, HSIDIV bits */
  CLEAR_BIT(RCC->CR, RCC_CR_HSEON | RCC_CR_HSIKERON| RCC_CR_HSIDIV| RCC_CR_HSIDIVF| RCC_CR_CSION | RCC_CR_CSIKERON  \
24011c26:	4b5a      	ldr	r3, [pc, #360]	; (24011d90 <HAL_RCC_DeInit+0x230>)
24011c28:	681a      	ldr	r2, [r3, #0]
24011c2a:	4959      	ldr	r1, [pc, #356]	; (24011d90 <HAL_RCC_DeInit+0x230>)
24011c2c:	4b5d      	ldr	r3, [pc, #372]	; (24011da4 <HAL_RCC_DeInit+0x244>)
24011c2e:	4013      	ands	r3, r2
24011c30:	600b      	str	r3, [r1, #0]
  | RCC_CR_HSI48ON | RCC_CR_CSSHSEON);

  /* Wait till HSE is disabled */
  while (READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U)
24011c32:	e008      	b.n	24011c46 <HAL_RCC_DeInit+0xe6>
  {
    if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
24011c34:	f7ee fe0c 	bl	24000850 <HAL_GetTick>
24011c38:	4602      	mov	r2, r0
24011c3a:	687b      	ldr	r3, [r7, #4]
24011c3c:	1ad3      	subs	r3, r2, r3
24011c3e:	2b64      	cmp	r3, #100	; 0x64
24011c40:	d901      	bls.n	24011c46 <HAL_RCC_DeInit+0xe6>
    {
      return HAL_TIMEOUT;
24011c42:	2303      	movs	r3, #3
24011c44:	e09d      	b.n	24011d82 <HAL_RCC_DeInit+0x222>
  while (READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U)
24011c46:	4b52      	ldr	r3, [pc, #328]	; (24011d90 <HAL_RCC_DeInit+0x230>)
24011c48:	681b      	ldr	r3, [r3, #0]
24011c4a:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
24011c4e:	2b00      	cmp	r3, #0
24011c50:	d1f0      	bne.n	24011c34 <HAL_RCC_DeInit+0xd4>
    }
  }

  /* Get Start Tick */
  tickstart = HAL_GetTick();
24011c52:	f7ee fdfd 	bl	24000850 <HAL_GetTick>
24011c56:	6078      	str	r0, [r7, #4]

  /* Clear PLLON bit */
  CLEAR_BIT(RCC->CR, RCC_CR_PLL1ON);
24011c58:	4b4d      	ldr	r3, [pc, #308]	; (24011d90 <HAL_RCC_DeInit+0x230>)
24011c5a:	681b      	ldr	r3, [r3, #0]
24011c5c:	4a4c      	ldr	r2, [pc, #304]	; (24011d90 <HAL_RCC_DeInit+0x230>)
24011c5e:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
24011c62:	6013      	str	r3, [r2, #0]

  /* Wait till PLL is disabled */
  while (READ_BIT(RCC->CR, RCC_CR_PLL1RDY) != 0U)
24011c64:	e008      	b.n	24011c78 <HAL_RCC_DeInit+0x118>
  {
    if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
24011c66:	f7ee fdf3 	bl	24000850 <HAL_GetTick>
24011c6a:	4602      	mov	r2, r0
24011c6c:	687b      	ldr	r3, [r7, #4]
24011c6e:	1ad3      	subs	r3, r2, r3
24011c70:	2b02      	cmp	r3, #2
24011c72:	d901      	bls.n	24011c78 <HAL_RCC_DeInit+0x118>
    {
      return HAL_TIMEOUT;
24011c74:	2303      	movs	r3, #3
24011c76:	e084      	b.n	24011d82 <HAL_RCC_DeInit+0x222>
  while (READ_BIT(RCC->CR, RCC_CR_PLL1RDY) != 0U)
24011c78:	4b45      	ldr	r3, [pc, #276]	; (24011d90 <HAL_RCC_DeInit+0x230>)
24011c7a:	681b      	ldr	r3, [r3, #0]
24011c7c:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
24011c80:	2b00      	cmp	r3, #0
24011c82:	d1f0      	bne.n	24011c66 <HAL_RCC_DeInit+0x106>
    }
  }

  /* Get Start Tick */
  tickstart = HAL_GetTick();
24011c84:	f7ee fde4 	bl	24000850 <HAL_GetTick>
24011c88:	6078      	str	r0, [r7, #4]

  /* Reset PLL2ON bit */
  CLEAR_BIT(RCC->CR, RCC_CR_PLL2ON);
24011c8a:	4b41      	ldr	r3, [pc, #260]	; (24011d90 <HAL_RCC_DeInit+0x230>)
24011c8c:	681b      	ldr	r3, [r3, #0]
24011c8e:	4a40      	ldr	r2, [pc, #256]	; (24011d90 <HAL_RCC_DeInit+0x230>)
24011c90:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
24011c94:	6013      	str	r3, [r2, #0]

  /* Wait till PLL2 is disabled */
  while (READ_BIT(RCC->CR, RCC_CR_PLL2RDY) != 0U)
24011c96:	e008      	b.n	24011caa <HAL_RCC_DeInit+0x14a>
  {
    if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
24011c98:	f7ee fdda 	bl	24000850 <HAL_GetTick>
24011c9c:	4602      	mov	r2, r0
24011c9e:	687b      	ldr	r3, [r7, #4]
24011ca0:	1ad3      	subs	r3, r2, r3
24011ca2:	2b02      	cmp	r3, #2
24011ca4:	d901      	bls.n	24011caa <HAL_RCC_DeInit+0x14a>
    {
      return HAL_TIMEOUT;
24011ca6:	2303      	movs	r3, #3
24011ca8:	e06b      	b.n	24011d82 <HAL_RCC_DeInit+0x222>
  while (READ_BIT(RCC->CR, RCC_CR_PLL2RDY) != 0U)
24011caa:	4b39      	ldr	r3, [pc, #228]	; (24011d90 <HAL_RCC_DeInit+0x230>)
24011cac:	681b      	ldr	r3, [r3, #0]
24011cae:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
24011cb2:	2b00      	cmp	r3, #0
24011cb4:	d1f0      	bne.n	24011c98 <HAL_RCC_DeInit+0x138>
    }
  }

  /* Get Start Tick */
  tickstart = HAL_GetTick();
24011cb6:	f7ee fdcb 	bl	24000850 <HAL_GetTick>
24011cba:	6078      	str	r0, [r7, #4]

  /* Reset PLL3 bit */
  CLEAR_BIT(RCC->CR, RCC_CR_PLL3ON);
24011cbc:	4b34      	ldr	r3, [pc, #208]	; (24011d90 <HAL_RCC_DeInit+0x230>)
24011cbe:	681b      	ldr	r3, [r3, #0]
24011cc0:	4a33      	ldr	r2, [pc, #204]	; (24011d90 <HAL_RCC_DeInit+0x230>)
24011cc2:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
24011cc6:	6013      	str	r3, [r2, #0]

  /* Wait till PLL3 is disabled */
  while (READ_BIT(RCC->CR, RCC_CR_PLL3RDY) != 0U)
24011cc8:	e008      	b.n	24011cdc <HAL_RCC_DeInit+0x17c>
  {
    if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
24011cca:	f7ee fdc1 	bl	24000850 <HAL_GetTick>
24011cce:	4602      	mov	r2, r0
24011cd0:	687b      	ldr	r3, [r7, #4]
24011cd2:	1ad3      	subs	r3, r2, r3
24011cd4:	2b02      	cmp	r3, #2
24011cd6:	d901      	bls.n	24011cdc <HAL_RCC_DeInit+0x17c>
    {
      return HAL_TIMEOUT;
24011cd8:	2303      	movs	r3, #3
24011cda:	e052      	b.n	24011d82 <HAL_RCC_DeInit+0x222>
  while (READ_BIT(RCC->CR, RCC_CR_PLL3RDY) != 0U)
24011cdc:	4b2c      	ldr	r3, [pc, #176]	; (24011d90 <HAL_RCC_DeInit+0x230>)
24011cde:	681b      	ldr	r3, [r3, #0]
24011ce0:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
24011ce4:	2b00      	cmp	r3, #0
24011ce6:	d1f0      	bne.n	24011cca <HAL_RCC_DeInit+0x16a>
    }
  }

#if defined(RCC_D1CFGR_HPRE)
  /* Reset D1CFGR register */
  CLEAR_REG(RCC->D1CFGR);
24011ce8:	4b29      	ldr	r3, [pc, #164]	; (24011d90 <HAL_RCC_DeInit+0x230>)
24011cea:	2200      	movs	r2, #0
24011cec:	619a      	str	r2, [r3, #24]

  /* Reset D2CFGR register */
  CLEAR_REG(RCC->D2CFGR);
24011cee:	4b28      	ldr	r3, [pc, #160]	; (24011d90 <HAL_RCC_DeInit+0x230>)
24011cf0:	2200      	movs	r2, #0
24011cf2:	61da      	str	r2, [r3, #28]

  /* Reset D3CFGR register */
  CLEAR_REG(RCC->D3CFGR);
24011cf4:	4b26      	ldr	r3, [pc, #152]	; (24011d90 <HAL_RCC_DeInit+0x230>)
24011cf6:	2200      	movs	r2, #0
24011cf8:	621a      	str	r2, [r3, #32]
  /* Reset SRDCFGR register */
  CLEAR_REG(RCC->SRDCFGR);
#endif

  /* Reset PLLCKSELR register to default value */
  RCC->PLLCKSELR= RCC_PLLCKSELR_DIVM1_5|RCC_PLLCKSELR_DIVM2_5|RCC_PLLCKSELR_DIVM3_5;
24011cfa:	4b25      	ldr	r3, [pc, #148]	; (24011d90 <HAL_RCC_DeInit+0x230>)
24011cfc:	4a2a      	ldr	r2, [pc, #168]	; (24011da8 <HAL_RCC_DeInit+0x248>)
24011cfe:	629a      	str	r2, [r3, #40]	; 0x28

  /* Reset PLLCFGR register to default value */
  WRITE_REG(RCC->PLLCFGR, 0x01FF0000U);
24011d00:	4b23      	ldr	r3, [pc, #140]	; (24011d90 <HAL_RCC_DeInit+0x230>)
24011d02:	4a2a      	ldr	r2, [pc, #168]	; (24011dac <HAL_RCC_DeInit+0x24c>)
24011d04:	62da      	str	r2, [r3, #44]	; 0x2c

  /* Reset PLL1DIVR register to default value */
  WRITE_REG(RCC->PLL1DIVR,0x01010280U);
24011d06:	4b22      	ldr	r3, [pc, #136]	; (24011d90 <HAL_RCC_DeInit+0x230>)
24011d08:	4a29      	ldr	r2, [pc, #164]	; (24011db0 <HAL_RCC_DeInit+0x250>)
24011d0a:	631a      	str	r2, [r3, #48]	; 0x30

  /* Reset PLL1FRACR register */
  CLEAR_REG(RCC->PLL1FRACR);
24011d0c:	4b20      	ldr	r3, [pc, #128]	; (24011d90 <HAL_RCC_DeInit+0x230>)
24011d0e:	2200      	movs	r2, #0
24011d10:	635a      	str	r2, [r3, #52]	; 0x34

  /* Reset PLL2DIVR register to default value */
  WRITE_REG(RCC->PLL2DIVR,0x01010280U);
24011d12:	4b1f      	ldr	r3, [pc, #124]	; (24011d90 <HAL_RCC_DeInit+0x230>)
24011d14:	4a26      	ldr	r2, [pc, #152]	; (24011db0 <HAL_RCC_DeInit+0x250>)
24011d16:	639a      	str	r2, [r3, #56]	; 0x38

  /* Reset PLL2FRACR register */
  CLEAR_REG(RCC->PLL2FRACR);
24011d18:	4b1d      	ldr	r3, [pc, #116]	; (24011d90 <HAL_RCC_DeInit+0x230>)
24011d1a:	2200      	movs	r2, #0
24011d1c:	63da      	str	r2, [r3, #60]	; 0x3c

  /* Reset PLL3DIVR register to default value */
  WRITE_REG(RCC->PLL3DIVR,0x01010280U);
24011d1e:	4b1c      	ldr	r3, [pc, #112]	; (24011d90 <HAL_RCC_DeInit+0x230>)
24011d20:	4a23      	ldr	r2, [pc, #140]	; (24011db0 <HAL_RCC_DeInit+0x250>)
24011d22:	641a      	str	r2, [r3, #64]	; 0x40

  /* Reset PLL3FRACR register */
  CLEAR_REG(RCC->PLL3FRACR);
24011d24:	4b1a      	ldr	r3, [pc, #104]	; (24011d90 <HAL_RCC_DeInit+0x230>)
24011d26:	2200      	movs	r2, #0
24011d28:	645a      	str	r2, [r3, #68]	; 0x44

  /* Reset HSEBYP bit */
  CLEAR_BIT(RCC->CR, RCC_CR_HSEBYP);
24011d2a:	4b19      	ldr	r3, [pc, #100]	; (24011d90 <HAL_RCC_DeInit+0x230>)
24011d2c:	681b      	ldr	r3, [r3, #0]
24011d2e:	4a18      	ldr	r2, [pc, #96]	; (24011d90 <HAL_RCC_DeInit+0x230>)
24011d30:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
24011d34:	6013      	str	r3, [r2, #0]

  /* Disable all interrupts */
  CLEAR_REG(RCC->CIER);
24011d36:	4b16      	ldr	r3, [pc, #88]	; (24011d90 <HAL_RCC_DeInit+0x230>)
24011d38:	2200      	movs	r2, #0
24011d3a:	661a      	str	r2, [r3, #96]	; 0x60

  /* Clear all interrupts flags */
  WRITE_REG(RCC->CICR,0xFFFFFFFFU);
24011d3c:	4b14      	ldr	r3, [pc, #80]	; (24011d90 <HAL_RCC_DeInit+0x230>)
24011d3e:	f04f 32ff 	mov.w	r2, #4294967295
24011d42:	669a      	str	r2, [r3, #104]	; 0x68

  /* Reset all RSR flags */
  SET_BIT(RCC->RSR, RCC_RSR_RMVF);
24011d44:	4b12      	ldr	r3, [pc, #72]	; (24011d90 <HAL_RCC_DeInit+0x230>)
24011d46:	f8d3 30d0 	ldr.w	r3, [r3, #208]	; 0xd0
24011d4a:	4a11      	ldr	r2, [pc, #68]	; (24011d90 <HAL_RCC_DeInit+0x230>)
24011d4c:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
24011d50:	f8c2 30d0 	str.w	r3, [r2, #208]	; 0xd0

      /* Decreasing the number of wait states because of lower CPU frequency */
  if(FLASH_LATENCY_DEFAULT  < __HAL_FLASH_GET_LATENCY())
24011d54:	4b0d      	ldr	r3, [pc, #52]	; (24011d8c <HAL_RCC_DeInit+0x22c>)
24011d56:	681b      	ldr	r3, [r3, #0]
24011d58:	f003 030f 	and.w	r3, r3, #15
24011d5c:	2b07      	cmp	r3, #7
24011d5e:	d90f      	bls.n	24011d80 <HAL_RCC_DeInit+0x220>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLASH_LATENCY_DEFAULT);
24011d60:	4b0a      	ldr	r3, [pc, #40]	; (24011d8c <HAL_RCC_DeInit+0x22c>)
24011d62:	681b      	ldr	r3, [r3, #0]
24011d64:	f023 030f 	bic.w	r3, r3, #15
24011d68:	4a08      	ldr	r2, [pc, #32]	; (24011d8c <HAL_RCC_DeInit+0x22c>)
24011d6a:	f043 0307 	orr.w	r3, r3, #7
24011d6e:	6013      	str	r3, [r2, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if(__HAL_FLASH_GET_LATENCY() != FLASH_LATENCY_DEFAULT)
24011d70:	4b06      	ldr	r3, [pc, #24]	; (24011d8c <HAL_RCC_DeInit+0x22c>)
24011d72:	681b      	ldr	r3, [r3, #0]
24011d74:	f003 030f 	and.w	r3, r3, #15
24011d78:	2b07      	cmp	r3, #7
24011d7a:	d001      	beq.n	24011d80 <HAL_RCC_DeInit+0x220>
    {
      return HAL_ERROR;
24011d7c:	2301      	movs	r3, #1
24011d7e:	e000      	b.n	24011d82 <HAL_RCC_DeInit+0x222>
    }

}

  return HAL_OK;
24011d80:	2300      	movs	r3, #0
}
24011d82:	4618      	mov	r0, r3
24011d84:	3708      	adds	r7, #8
24011d86:	46bd      	mov	sp, r7
24011d88:	bd80      	pop	{r7, pc}
24011d8a:	bf00      	nop
24011d8c:	52002000 	.word	0x52002000
24011d90:	58024400 	.word	0x58024400
24011d94:	240004b8 	.word	0x240004b8
24011d98:	03d09000 	.word	0x03d09000
24011d9c:	240004bc 	.word	0x240004bc
24011da0:	240004ac 	.word	0x240004ac
24011da4:	fff6ed45 	.word	0xfff6ed45
24011da8:	02020200 	.word	0x02020200
24011dac:	01ff0000 	.word	0x01ff0000
24011db0:	01010280 	.word	0x01010280

24011db4 <HAL_RCC_OscConfig>:
  *         supported by this function. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
24011db4:	b580      	push	{r7, lr}
24011db6:	b08c      	sub	sp, #48	; 0x30
24011db8:	af00      	add	r7, sp, #0
24011dba:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;
  uint32_t temp1_pllckcfg, temp2_pllckcfg;

    /* Check Null pointer */
  if(RCC_OscInitStruct == NULL)
24011dbc:	687b      	ldr	r3, [r7, #4]
24011dbe:	2b00      	cmp	r3, #0
24011dc0:	d101      	bne.n	24011dc6 <HAL_RCC_OscConfig+0x12>
  {
    return HAL_ERROR;
24011dc2:	2301      	movs	r3, #1
24011dc4:	e3c4      	b.n	24012550 <HAL_RCC_OscConfig+0x79c>
  }

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  /*------------------------------- HSE Configuration ------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
24011dc6:	687b      	ldr	r3, [r7, #4]
24011dc8:	681b      	ldr	r3, [r3, #0]
24011dca:	f003 0301 	and.w	r3, r3, #1
24011dce:	2b00      	cmp	r3, #0
24011dd0:	f000 8087 	beq.w	24011ee2 <HAL_RCC_OscConfig+0x12e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));

    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
24011dd4:	4ba2      	ldr	r3, [pc, #648]	; (24012060 <HAL_RCC_OscConfig+0x2ac>)
24011dd6:	691b      	ldr	r3, [r3, #16]
24011dd8:	f003 0338 	and.w	r3, r3, #56	; 0x38
24011ddc:	62fb      	str	r3, [r7, #44]	; 0x2c
    const uint32_t temp_pllckselr = RCC->PLLCKSELR;
24011dde:	4ba0      	ldr	r3, [pc, #640]	; (24012060 <HAL_RCC_OscConfig+0x2ac>)
24011de0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
24011de2:	62bb      	str	r3, [r7, #40]	; 0x28
    /* When the HSE is used as system clock or clock source for PLL in these cases HSE will not disabled */
    if((temp_sysclksrc == RCC_CFGR_SWS_HSE) || ((temp_sysclksrc == RCC_CFGR_SWS_PLL1) && ((temp_pllckselr & RCC_PLLCKSELR_PLLSRC) == RCC_PLLCKSELR_PLLSRC_HSE)))
24011de4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
24011de6:	2b10      	cmp	r3, #16
24011de8:	d007      	beq.n	24011dfa <HAL_RCC_OscConfig+0x46>
24011dea:	6afb      	ldr	r3, [r7, #44]	; 0x2c
24011dec:	2b18      	cmp	r3, #24
24011dee:	d110      	bne.n	24011e12 <HAL_RCC_OscConfig+0x5e>
24011df0:	6abb      	ldr	r3, [r7, #40]	; 0x28
24011df2:	f003 0303 	and.w	r3, r3, #3
24011df6:	2b02      	cmp	r3, #2
24011df8:	d10b      	bne.n	24011e12 <HAL_RCC_OscConfig+0x5e>
    {
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
24011dfa:	4b99      	ldr	r3, [pc, #612]	; (24012060 <HAL_RCC_OscConfig+0x2ac>)
24011dfc:	681b      	ldr	r3, [r3, #0]
24011dfe:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
24011e02:	2b00      	cmp	r3, #0
24011e04:	d06c      	beq.n	24011ee0 <HAL_RCC_OscConfig+0x12c>
24011e06:	687b      	ldr	r3, [r7, #4]
24011e08:	685b      	ldr	r3, [r3, #4]
24011e0a:	2b00      	cmp	r3, #0
24011e0c:	d168      	bne.n	24011ee0 <HAL_RCC_OscConfig+0x12c>
      {
        return HAL_ERROR;
24011e0e:	2301      	movs	r3, #1
24011e10:	e39e      	b.n	24012550 <HAL_RCC_OscConfig+0x79c>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
24011e12:	687b      	ldr	r3, [r7, #4]
24011e14:	685b      	ldr	r3, [r3, #4]
24011e16:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
24011e1a:	d106      	bne.n	24011e2a <HAL_RCC_OscConfig+0x76>
24011e1c:	4b90      	ldr	r3, [pc, #576]	; (24012060 <HAL_RCC_OscConfig+0x2ac>)
24011e1e:	681b      	ldr	r3, [r3, #0]
24011e20:	4a8f      	ldr	r2, [pc, #572]	; (24012060 <HAL_RCC_OscConfig+0x2ac>)
24011e22:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
24011e26:	6013      	str	r3, [r2, #0]
24011e28:	e02e      	b.n	24011e88 <HAL_RCC_OscConfig+0xd4>
24011e2a:	687b      	ldr	r3, [r7, #4]
24011e2c:	685b      	ldr	r3, [r3, #4]
24011e2e:	2b00      	cmp	r3, #0
24011e30:	d10c      	bne.n	24011e4c <HAL_RCC_OscConfig+0x98>
24011e32:	4b8b      	ldr	r3, [pc, #556]	; (24012060 <HAL_RCC_OscConfig+0x2ac>)
24011e34:	681b      	ldr	r3, [r3, #0]
24011e36:	4a8a      	ldr	r2, [pc, #552]	; (24012060 <HAL_RCC_OscConfig+0x2ac>)
24011e38:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
24011e3c:	6013      	str	r3, [r2, #0]
24011e3e:	4b88      	ldr	r3, [pc, #544]	; (24012060 <HAL_RCC_OscConfig+0x2ac>)
24011e40:	681b      	ldr	r3, [r3, #0]
24011e42:	4a87      	ldr	r2, [pc, #540]	; (24012060 <HAL_RCC_OscConfig+0x2ac>)
24011e44:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
24011e48:	6013      	str	r3, [r2, #0]
24011e4a:	e01d      	b.n	24011e88 <HAL_RCC_OscConfig+0xd4>
24011e4c:	687b      	ldr	r3, [r7, #4]
24011e4e:	685b      	ldr	r3, [r3, #4]
24011e50:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
24011e54:	d10c      	bne.n	24011e70 <HAL_RCC_OscConfig+0xbc>
24011e56:	4b82      	ldr	r3, [pc, #520]	; (24012060 <HAL_RCC_OscConfig+0x2ac>)
24011e58:	681b      	ldr	r3, [r3, #0]
24011e5a:	4a81      	ldr	r2, [pc, #516]	; (24012060 <HAL_RCC_OscConfig+0x2ac>)
24011e5c:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
24011e60:	6013      	str	r3, [r2, #0]
24011e62:	4b7f      	ldr	r3, [pc, #508]	; (24012060 <HAL_RCC_OscConfig+0x2ac>)
24011e64:	681b      	ldr	r3, [r3, #0]
24011e66:	4a7e      	ldr	r2, [pc, #504]	; (24012060 <HAL_RCC_OscConfig+0x2ac>)
24011e68:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
24011e6c:	6013      	str	r3, [r2, #0]
24011e6e:	e00b      	b.n	24011e88 <HAL_RCC_OscConfig+0xd4>
24011e70:	4b7b      	ldr	r3, [pc, #492]	; (24012060 <HAL_RCC_OscConfig+0x2ac>)
24011e72:	681b      	ldr	r3, [r3, #0]
24011e74:	4a7a      	ldr	r2, [pc, #488]	; (24012060 <HAL_RCC_OscConfig+0x2ac>)
24011e76:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
24011e7a:	6013      	str	r3, [r2, #0]
24011e7c:	4b78      	ldr	r3, [pc, #480]	; (24012060 <HAL_RCC_OscConfig+0x2ac>)
24011e7e:	681b      	ldr	r3, [r3, #0]
24011e80:	4a77      	ldr	r2, [pc, #476]	; (24012060 <HAL_RCC_OscConfig+0x2ac>)
24011e82:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
24011e86:	6013      	str	r3, [r2, #0]

      /* Check the HSE State */
      if(RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
24011e88:	687b      	ldr	r3, [r7, #4]
24011e8a:	685b      	ldr	r3, [r3, #4]
24011e8c:	2b00      	cmp	r3, #0
24011e8e:	d013      	beq.n	24011eb8 <HAL_RCC_OscConfig+0x104>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
24011e90:	f7ee fcde 	bl	24000850 <HAL_GetTick>
24011e94:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till HSE is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
24011e96:	e008      	b.n	24011eaa <HAL_RCC_OscConfig+0xf6>
        {
          if((uint32_t) (HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
24011e98:	f7ee fcda 	bl	24000850 <HAL_GetTick>
24011e9c:	4602      	mov	r2, r0
24011e9e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
24011ea0:	1ad3      	subs	r3, r2, r3
24011ea2:	2b64      	cmp	r3, #100	; 0x64
24011ea4:	d901      	bls.n	24011eaa <HAL_RCC_OscConfig+0xf6>
          {
            return HAL_TIMEOUT;
24011ea6:	2303      	movs	r3, #3
24011ea8:	e352      	b.n	24012550 <HAL_RCC_OscConfig+0x79c>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
24011eaa:	4b6d      	ldr	r3, [pc, #436]	; (24012060 <HAL_RCC_OscConfig+0x2ac>)
24011eac:	681b      	ldr	r3, [r3, #0]
24011eae:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
24011eb2:	2b00      	cmp	r3, #0
24011eb4:	d0f0      	beq.n	24011e98 <HAL_RCC_OscConfig+0xe4>
24011eb6:	e014      	b.n	24011ee2 <HAL_RCC_OscConfig+0x12e>
        }
      }
      else
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
24011eb8:	f7ee fcca 	bl	24000850 <HAL_GetTick>
24011ebc:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till HSE is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U)
24011ebe:	e008      	b.n	24011ed2 <HAL_RCC_OscConfig+0x11e>
        {
          if((uint32_t) (HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
24011ec0:	f7ee fcc6 	bl	24000850 <HAL_GetTick>
24011ec4:	4602      	mov	r2, r0
24011ec6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
24011ec8:	1ad3      	subs	r3, r2, r3
24011eca:	2b64      	cmp	r3, #100	; 0x64
24011ecc:	d901      	bls.n	24011ed2 <HAL_RCC_OscConfig+0x11e>
          {
            return HAL_TIMEOUT;
24011ece:	2303      	movs	r3, #3
24011ed0:	e33e      	b.n	24012550 <HAL_RCC_OscConfig+0x79c>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U)
24011ed2:	4b63      	ldr	r3, [pc, #396]	; (24012060 <HAL_RCC_OscConfig+0x2ac>)
24011ed4:	681b      	ldr	r3, [r3, #0]
24011ed6:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
24011eda:	2b00      	cmp	r3, #0
24011edc:	d1f0      	bne.n	24011ec0 <HAL_RCC_OscConfig+0x10c>
24011ede:	e000      	b.n	24011ee2 <HAL_RCC_OscConfig+0x12e>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
24011ee0:	bf00      	nop
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
24011ee2:	687b      	ldr	r3, [r7, #4]
24011ee4:	681b      	ldr	r3, [r3, #0]
24011ee6:	f003 0302 	and.w	r3, r3, #2
24011eea:	2b00      	cmp	r3, #0
24011eec:	f000 8092 	beq.w	24012014 <HAL_RCC_OscConfig+0x260>
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_HSICALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));

    /* When the HSI is used as system clock it will not be disabled */
    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
24011ef0:	4b5b      	ldr	r3, [pc, #364]	; (24012060 <HAL_RCC_OscConfig+0x2ac>)
24011ef2:	691b      	ldr	r3, [r3, #16]
24011ef4:	f003 0338 	and.w	r3, r3, #56	; 0x38
24011ef8:	623b      	str	r3, [r7, #32]
    const uint32_t temp_pllckselr = RCC->PLLCKSELR;
24011efa:	4b59      	ldr	r3, [pc, #356]	; (24012060 <HAL_RCC_OscConfig+0x2ac>)
24011efc:	6a9b      	ldr	r3, [r3, #40]	; 0x28
24011efe:	61fb      	str	r3, [r7, #28]
    if((temp_sysclksrc == RCC_CFGR_SWS_HSI) || ((temp_sysclksrc == RCC_CFGR_SWS_PLL1) && ((temp_pllckselr & RCC_PLLCKSELR_PLLSRC) == RCC_PLLCKSELR_PLLSRC_HSI)))
24011f00:	6a3b      	ldr	r3, [r7, #32]
24011f02:	2b00      	cmp	r3, #0
24011f04:	d007      	beq.n	24011f16 <HAL_RCC_OscConfig+0x162>
24011f06:	6a3b      	ldr	r3, [r7, #32]
24011f08:	2b18      	cmp	r3, #24
24011f0a:	d12d      	bne.n	24011f68 <HAL_RCC_OscConfig+0x1b4>
24011f0c:	69fb      	ldr	r3, [r7, #28]
24011f0e:	f003 0303 	and.w	r3, r3, #3
24011f12:	2b00      	cmp	r3, #0
24011f14:	d128      	bne.n	24011f68 <HAL_RCC_OscConfig+0x1b4>
    {
      /* When HSI is used as system clock it will not be disabled */
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
24011f16:	4b52      	ldr	r3, [pc, #328]	; (24012060 <HAL_RCC_OscConfig+0x2ac>)
24011f18:	681b      	ldr	r3, [r3, #0]
24011f1a:	f003 0304 	and.w	r3, r3, #4
24011f1e:	2b00      	cmp	r3, #0
24011f20:	d005      	beq.n	24011f2e <HAL_RCC_OscConfig+0x17a>
24011f22:	687b      	ldr	r3, [r7, #4]
24011f24:	68db      	ldr	r3, [r3, #12]
24011f26:	2b00      	cmp	r3, #0
24011f28:	d101      	bne.n	24011f2e <HAL_RCC_OscConfig+0x17a>
      {
        return HAL_ERROR;
24011f2a:	2301      	movs	r3, #1
24011f2c:	e310      	b.n	24012550 <HAL_RCC_OscConfig+0x79c>
      }
      /* Otherwise, just the calibration is allowed */
      else
      {
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
24011f2e:	f7ee fd27 	bl	24000980 <HAL_GetREVID>
24011f32:	4602      	mov	r2, r0
24011f34:	f241 0303 	movw	r3, #4099	; 0x1003
24011f38:	429a      	cmp	r2, r3
24011f3a:	d80a      	bhi.n	24011f52 <HAL_RCC_OscConfig+0x19e>
24011f3c:	4b48      	ldr	r3, [pc, #288]	; (24012060 <HAL_RCC_OscConfig+0x2ac>)
24011f3e:	685b      	ldr	r3, [r3, #4]
24011f40:	f423 327c 	bic.w	r2, r3, #258048	; 0x3f000
24011f44:	687b      	ldr	r3, [r7, #4]
24011f46:	691b      	ldr	r3, [r3, #16]
24011f48:	031b      	lsls	r3, r3, #12
24011f4a:	4945      	ldr	r1, [pc, #276]	; (24012060 <HAL_RCC_OscConfig+0x2ac>)
24011f4c:	4313      	orrs	r3, r2
24011f4e:	604b      	str	r3, [r1, #4]
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
24011f50:	e060      	b.n	24012014 <HAL_RCC_OscConfig+0x260>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
24011f52:	4b43      	ldr	r3, [pc, #268]	; (24012060 <HAL_RCC_OscConfig+0x2ac>)
24011f54:	685b      	ldr	r3, [r3, #4]
24011f56:	f023 42fe 	bic.w	r2, r3, #2130706432	; 0x7f000000
24011f5a:	687b      	ldr	r3, [r7, #4]
24011f5c:	691b      	ldr	r3, [r3, #16]
24011f5e:	061b      	lsls	r3, r3, #24
24011f60:	493f      	ldr	r1, [pc, #252]	; (24012060 <HAL_RCC_OscConfig+0x2ac>)
24011f62:	4313      	orrs	r3, r2
24011f64:	604b      	str	r3, [r1, #4]
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
24011f66:	e055      	b.n	24012014 <HAL_RCC_OscConfig+0x260>
    }

    else
    {
      /* Check the HSI State */
      if((RCC_OscInitStruct->HSIState)!= RCC_HSI_OFF)
24011f68:	687b      	ldr	r3, [r7, #4]
24011f6a:	68db      	ldr	r3, [r3, #12]
24011f6c:	2b00      	cmp	r3, #0
24011f6e:	d038      	beq.n	24011fe2 <HAL_RCC_OscConfig+0x22e>
      {
     /* Enable the Internal High Speed oscillator (HSI, HSIDIV2,HSIDIV4, or HSIDIV8) */
        __HAL_RCC_HSI_CONFIG(RCC_OscInitStruct->HSIState);
24011f70:	4b3b      	ldr	r3, [pc, #236]	; (24012060 <HAL_RCC_OscConfig+0x2ac>)
24011f72:	681b      	ldr	r3, [r3, #0]
24011f74:	f023 0219 	bic.w	r2, r3, #25
24011f78:	687b      	ldr	r3, [r7, #4]
24011f7a:	68db      	ldr	r3, [r3, #12]
24011f7c:	4938      	ldr	r1, [pc, #224]	; (24012060 <HAL_RCC_OscConfig+0x2ac>)
24011f7e:	4313      	orrs	r3, r2
24011f80:	600b      	str	r3, [r1, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
24011f82:	f7ee fc65 	bl	24000850 <HAL_GetTick>
24011f86:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till HSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
24011f88:	e008      	b.n	24011f9c <HAL_RCC_OscConfig+0x1e8>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
24011f8a:	f7ee fc61 	bl	24000850 <HAL_GetTick>
24011f8e:	4602      	mov	r2, r0
24011f90:	6a7b      	ldr	r3, [r7, #36]	; 0x24
24011f92:	1ad3      	subs	r3, r2, r3
24011f94:	2b02      	cmp	r3, #2
24011f96:	d901      	bls.n	24011f9c <HAL_RCC_OscConfig+0x1e8>
          {
            return HAL_TIMEOUT;
24011f98:	2303      	movs	r3, #3
24011f9a:	e2d9      	b.n	24012550 <HAL_RCC_OscConfig+0x79c>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
24011f9c:	4b30      	ldr	r3, [pc, #192]	; (24012060 <HAL_RCC_OscConfig+0x2ac>)
24011f9e:	681b      	ldr	r3, [r3, #0]
24011fa0:	f003 0304 	and.w	r3, r3, #4
24011fa4:	2b00      	cmp	r3, #0
24011fa6:	d0f0      	beq.n	24011f8a <HAL_RCC_OscConfig+0x1d6>
          }
        }

        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
24011fa8:	f7ee fcea 	bl	24000980 <HAL_GetREVID>
24011fac:	4602      	mov	r2, r0
24011fae:	f241 0303 	movw	r3, #4099	; 0x1003
24011fb2:	429a      	cmp	r2, r3
24011fb4:	d80a      	bhi.n	24011fcc <HAL_RCC_OscConfig+0x218>
24011fb6:	4b2a      	ldr	r3, [pc, #168]	; (24012060 <HAL_RCC_OscConfig+0x2ac>)
24011fb8:	685b      	ldr	r3, [r3, #4]
24011fba:	f423 327c 	bic.w	r2, r3, #258048	; 0x3f000
24011fbe:	687b      	ldr	r3, [r7, #4]
24011fc0:	691b      	ldr	r3, [r3, #16]
24011fc2:	031b      	lsls	r3, r3, #12
24011fc4:	4926      	ldr	r1, [pc, #152]	; (24012060 <HAL_RCC_OscConfig+0x2ac>)
24011fc6:	4313      	orrs	r3, r2
24011fc8:	604b      	str	r3, [r1, #4]
24011fca:	e023      	b.n	24012014 <HAL_RCC_OscConfig+0x260>
24011fcc:	4b24      	ldr	r3, [pc, #144]	; (24012060 <HAL_RCC_OscConfig+0x2ac>)
24011fce:	685b      	ldr	r3, [r3, #4]
24011fd0:	f023 42fe 	bic.w	r2, r3, #2130706432	; 0x7f000000
24011fd4:	687b      	ldr	r3, [r7, #4]
24011fd6:	691b      	ldr	r3, [r3, #16]
24011fd8:	061b      	lsls	r3, r3, #24
24011fda:	4921      	ldr	r1, [pc, #132]	; (24012060 <HAL_RCC_OscConfig+0x2ac>)
24011fdc:	4313      	orrs	r3, r2
24011fde:	604b      	str	r3, [r1, #4]
24011fe0:	e018      	b.n	24012014 <HAL_RCC_OscConfig+0x260>
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_DISABLE();
24011fe2:	4b1f      	ldr	r3, [pc, #124]	; (24012060 <HAL_RCC_OscConfig+0x2ac>)
24011fe4:	681b      	ldr	r3, [r3, #0]
24011fe6:	4a1e      	ldr	r2, [pc, #120]	; (24012060 <HAL_RCC_OscConfig+0x2ac>)
24011fe8:	f023 0301 	bic.w	r3, r3, #1
24011fec:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
24011fee:	f7ee fc2f 	bl	24000850 <HAL_GetTick>
24011ff2:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till HSI is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U)
24011ff4:	e008      	b.n	24012008 <HAL_RCC_OscConfig+0x254>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
24011ff6:	f7ee fc2b 	bl	24000850 <HAL_GetTick>
24011ffa:	4602      	mov	r2, r0
24011ffc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
24011ffe:	1ad3      	subs	r3, r2, r3
24012000:	2b02      	cmp	r3, #2
24012002:	d901      	bls.n	24012008 <HAL_RCC_OscConfig+0x254>
          {
            return HAL_TIMEOUT;
24012004:	2303      	movs	r3, #3
24012006:	e2a3      	b.n	24012550 <HAL_RCC_OscConfig+0x79c>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U)
24012008:	4b15      	ldr	r3, [pc, #84]	; (24012060 <HAL_RCC_OscConfig+0x2ac>)
2401200a:	681b      	ldr	r3, [r3, #0]
2401200c:	f003 0304 	and.w	r3, r3, #4
24012010:	2b00      	cmp	r3, #0
24012012:	d1f0      	bne.n	24011ff6 <HAL_RCC_OscConfig+0x242>
        }
      }
    }
  }
  /*----------------------------- CSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_CSI) == RCC_OSCILLATORTYPE_CSI)
24012014:	687b      	ldr	r3, [r7, #4]
24012016:	681b      	ldr	r3, [r3, #0]
24012018:	f003 0310 	and.w	r3, r3, #16
2401201c:	2b00      	cmp	r3, #0
2401201e:	f000 8091 	beq.w	24012144 <HAL_RCC_OscConfig+0x390>
    /* Check the parameters */
    assert_param(IS_RCC_CSI(RCC_OscInitStruct->CSIState));
    assert_param(IS_RCC_CSICALIBRATION_VALUE(RCC_OscInitStruct->CSICalibrationValue));

    /* When the CSI is used as system clock it will not disabled */
    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
24012022:	4b0f      	ldr	r3, [pc, #60]	; (24012060 <HAL_RCC_OscConfig+0x2ac>)
24012024:	691b      	ldr	r3, [r3, #16]
24012026:	f003 0338 	and.w	r3, r3, #56	; 0x38
2401202a:	61bb      	str	r3, [r7, #24]
    const uint32_t temp_pllckselr = RCC->PLLCKSELR;
2401202c:	4b0c      	ldr	r3, [pc, #48]	; (24012060 <HAL_RCC_OscConfig+0x2ac>)
2401202e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
24012030:	617b      	str	r3, [r7, #20]
    if((temp_sysclksrc == RCC_CFGR_SWS_CSI) || ((temp_sysclksrc == RCC_CFGR_SWS_PLL1) && ((temp_pllckselr & RCC_PLLCKSELR_PLLSRC) == RCC_PLLCKSELR_PLLSRC_CSI)))
24012032:	69bb      	ldr	r3, [r7, #24]
24012034:	2b08      	cmp	r3, #8
24012036:	d007      	beq.n	24012048 <HAL_RCC_OscConfig+0x294>
24012038:	69bb      	ldr	r3, [r7, #24]
2401203a:	2b18      	cmp	r3, #24
2401203c:	d12f      	bne.n	2401209e <HAL_RCC_OscConfig+0x2ea>
2401203e:	697b      	ldr	r3, [r7, #20]
24012040:	f003 0303 	and.w	r3, r3, #3
24012044:	2b01      	cmp	r3, #1
24012046:	d12a      	bne.n	2401209e <HAL_RCC_OscConfig+0x2ea>
    {
      /* When CSI is used as system clock it will not disabled */
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) != 0U) && (RCC_OscInitStruct->CSIState != RCC_CSI_ON))
24012048:	4b05      	ldr	r3, [pc, #20]	; (24012060 <HAL_RCC_OscConfig+0x2ac>)
2401204a:	681b      	ldr	r3, [r3, #0]
2401204c:	f403 7380 	and.w	r3, r3, #256	; 0x100
24012050:	2b00      	cmp	r3, #0
24012052:	d007      	beq.n	24012064 <HAL_RCC_OscConfig+0x2b0>
24012054:	687b      	ldr	r3, [r7, #4]
24012056:	69db      	ldr	r3, [r3, #28]
24012058:	2b80      	cmp	r3, #128	; 0x80
2401205a:	d003      	beq.n	24012064 <HAL_RCC_OscConfig+0x2b0>
      {
        return HAL_ERROR;
2401205c:	2301      	movs	r3, #1
2401205e:	e277      	b.n	24012550 <HAL_RCC_OscConfig+0x79c>
24012060:	58024400 	.word	0x58024400
      }
      /* Otherwise, just the calibration is allowed */
      else
      {
        /* Adjusts the Internal High Speed oscillator (CSI) calibration value.*/
        __HAL_RCC_CSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->CSICalibrationValue);
24012064:	f7ee fc8c 	bl	24000980 <HAL_GetREVID>
24012068:	4602      	mov	r2, r0
2401206a:	f241 0303 	movw	r3, #4099	; 0x1003
2401206e:	429a      	cmp	r2, r3
24012070:	d80a      	bhi.n	24012088 <HAL_RCC_OscConfig+0x2d4>
24012072:	4ba2      	ldr	r3, [pc, #648]	; (240122fc <HAL_RCC_OscConfig+0x548>)
24012074:	685b      	ldr	r3, [r3, #4]
24012076:	f023 42f8 	bic.w	r2, r3, #2080374784	; 0x7c000000
2401207a:	687b      	ldr	r3, [r7, #4]
2401207c:	6a1b      	ldr	r3, [r3, #32]
2401207e:	069b      	lsls	r3, r3, #26
24012080:	499e      	ldr	r1, [pc, #632]	; (240122fc <HAL_RCC_OscConfig+0x548>)
24012082:	4313      	orrs	r3, r2
24012084:	604b      	str	r3, [r1, #4]
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) != 0U) && (RCC_OscInitStruct->CSIState != RCC_CSI_ON))
24012086:	e05d      	b.n	24012144 <HAL_RCC_OscConfig+0x390>
        __HAL_RCC_CSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->CSICalibrationValue);
24012088:	4b9c      	ldr	r3, [pc, #624]	; (240122fc <HAL_RCC_OscConfig+0x548>)
2401208a:	68db      	ldr	r3, [r3, #12]
2401208c:	f023 527c 	bic.w	r2, r3, #1056964608	; 0x3f000000
24012090:	687b      	ldr	r3, [r7, #4]
24012092:	6a1b      	ldr	r3, [r3, #32]
24012094:	061b      	lsls	r3, r3, #24
24012096:	4999      	ldr	r1, [pc, #612]	; (240122fc <HAL_RCC_OscConfig+0x548>)
24012098:	4313      	orrs	r3, r2
2401209a:	60cb      	str	r3, [r1, #12]
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) != 0U) && (RCC_OscInitStruct->CSIState != RCC_CSI_ON))
2401209c:	e052      	b.n	24012144 <HAL_RCC_OscConfig+0x390>
      }
    }
    else
    {
      /* Check the CSI State */
      if((RCC_OscInitStruct->CSIState)!= RCC_CSI_OFF)
2401209e:	687b      	ldr	r3, [r7, #4]
240120a0:	69db      	ldr	r3, [r3, #28]
240120a2:	2b00      	cmp	r3, #0
240120a4:	d035      	beq.n	24012112 <HAL_RCC_OscConfig+0x35e>
      {
        /* Enable the Internal High Speed oscillator (CSI). */
        __HAL_RCC_CSI_ENABLE();
240120a6:	4b95      	ldr	r3, [pc, #596]	; (240122fc <HAL_RCC_OscConfig+0x548>)
240120a8:	681b      	ldr	r3, [r3, #0]
240120aa:	4a94      	ldr	r2, [pc, #592]	; (240122fc <HAL_RCC_OscConfig+0x548>)
240120ac:	f043 0380 	orr.w	r3, r3, #128	; 0x80
240120b0:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
240120b2:	f7ee fbcd 	bl	24000850 <HAL_GetTick>
240120b6:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till CSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) == 0U)
240120b8:	e008      	b.n	240120cc <HAL_RCC_OscConfig+0x318>
        {
          if((HAL_GetTick() - tickstart ) > CSI_TIMEOUT_VALUE)
240120ba:	f7ee fbc9 	bl	24000850 <HAL_GetTick>
240120be:	4602      	mov	r2, r0
240120c0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
240120c2:	1ad3      	subs	r3, r2, r3
240120c4:	2b02      	cmp	r3, #2
240120c6:	d901      	bls.n	240120cc <HAL_RCC_OscConfig+0x318>
          {
            return HAL_TIMEOUT;
240120c8:	2303      	movs	r3, #3
240120ca:	e241      	b.n	24012550 <HAL_RCC_OscConfig+0x79c>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) == 0U)
240120cc:	4b8b      	ldr	r3, [pc, #556]	; (240122fc <HAL_RCC_OscConfig+0x548>)
240120ce:	681b      	ldr	r3, [r3, #0]
240120d0:	f403 7380 	and.w	r3, r3, #256	; 0x100
240120d4:	2b00      	cmp	r3, #0
240120d6:	d0f0      	beq.n	240120ba <HAL_RCC_OscConfig+0x306>
          }
        }

        /* Adjusts the Internal High Speed oscillator (CSI) calibration value.*/
        __HAL_RCC_CSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->CSICalibrationValue);
240120d8:	f7ee fc52 	bl	24000980 <HAL_GetREVID>
240120dc:	4602      	mov	r2, r0
240120de:	f241 0303 	movw	r3, #4099	; 0x1003
240120e2:	429a      	cmp	r2, r3
240120e4:	d80a      	bhi.n	240120fc <HAL_RCC_OscConfig+0x348>
240120e6:	4b85      	ldr	r3, [pc, #532]	; (240122fc <HAL_RCC_OscConfig+0x548>)
240120e8:	685b      	ldr	r3, [r3, #4]
240120ea:	f023 42f8 	bic.w	r2, r3, #2080374784	; 0x7c000000
240120ee:	687b      	ldr	r3, [r7, #4]
240120f0:	6a1b      	ldr	r3, [r3, #32]
240120f2:	069b      	lsls	r3, r3, #26
240120f4:	4981      	ldr	r1, [pc, #516]	; (240122fc <HAL_RCC_OscConfig+0x548>)
240120f6:	4313      	orrs	r3, r2
240120f8:	604b      	str	r3, [r1, #4]
240120fa:	e023      	b.n	24012144 <HAL_RCC_OscConfig+0x390>
240120fc:	4b7f      	ldr	r3, [pc, #508]	; (240122fc <HAL_RCC_OscConfig+0x548>)
240120fe:	68db      	ldr	r3, [r3, #12]
24012100:	f023 527c 	bic.w	r2, r3, #1056964608	; 0x3f000000
24012104:	687b      	ldr	r3, [r7, #4]
24012106:	6a1b      	ldr	r3, [r3, #32]
24012108:	061b      	lsls	r3, r3, #24
2401210a:	497c      	ldr	r1, [pc, #496]	; (240122fc <HAL_RCC_OscConfig+0x548>)
2401210c:	4313      	orrs	r3, r2
2401210e:	60cb      	str	r3, [r1, #12]
24012110:	e018      	b.n	24012144 <HAL_RCC_OscConfig+0x390>
      }
      else
      {
        /* Disable the Internal High Speed oscillator (CSI). */
        __HAL_RCC_CSI_DISABLE();
24012112:	4b7a      	ldr	r3, [pc, #488]	; (240122fc <HAL_RCC_OscConfig+0x548>)
24012114:	681b      	ldr	r3, [r3, #0]
24012116:	4a79      	ldr	r2, [pc, #484]	; (240122fc <HAL_RCC_OscConfig+0x548>)
24012118:	f023 0380 	bic.w	r3, r3, #128	; 0x80
2401211c:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
2401211e:	f7ee fb97 	bl	24000850 <HAL_GetTick>
24012122:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till CSI is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) != 0U)
24012124:	e008      	b.n	24012138 <HAL_RCC_OscConfig+0x384>
        {
          if((HAL_GetTick() - tickstart ) > CSI_TIMEOUT_VALUE)
24012126:	f7ee fb93 	bl	24000850 <HAL_GetTick>
2401212a:	4602      	mov	r2, r0
2401212c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
2401212e:	1ad3      	subs	r3, r2, r3
24012130:	2b02      	cmp	r3, #2
24012132:	d901      	bls.n	24012138 <HAL_RCC_OscConfig+0x384>
          {
            return HAL_TIMEOUT;
24012134:	2303      	movs	r3, #3
24012136:	e20b      	b.n	24012550 <HAL_RCC_OscConfig+0x79c>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) != 0U)
24012138:	4b70      	ldr	r3, [pc, #448]	; (240122fc <HAL_RCC_OscConfig+0x548>)
2401213a:	681b      	ldr	r3, [r3, #0]
2401213c:	f403 7380 	and.w	r3, r3, #256	; 0x100
24012140:	2b00      	cmp	r3, #0
24012142:	d1f0      	bne.n	24012126 <HAL_RCC_OscConfig+0x372>
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
24012144:	687b      	ldr	r3, [r7, #4]
24012146:	681b      	ldr	r3, [r3, #0]
24012148:	f003 0308 	and.w	r3, r3, #8
2401214c:	2b00      	cmp	r3, #0
2401214e:	d036      	beq.n	240121be <HAL_RCC_OscConfig+0x40a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if((RCC_OscInitStruct->LSIState)!= RCC_LSI_OFF)
24012150:	687b      	ldr	r3, [r7, #4]
24012152:	695b      	ldr	r3, [r3, #20]
24012154:	2b00      	cmp	r3, #0
24012156:	d019      	beq.n	2401218c <HAL_RCC_OscConfig+0x3d8>
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
24012158:	4b68      	ldr	r3, [pc, #416]	; (240122fc <HAL_RCC_OscConfig+0x548>)
2401215a:	6f5b      	ldr	r3, [r3, #116]	; 0x74
2401215c:	4a67      	ldr	r2, [pc, #412]	; (240122fc <HAL_RCC_OscConfig+0x548>)
2401215e:	f043 0301 	orr.w	r3, r3, #1
24012162:	6753      	str	r3, [r2, #116]	; 0x74

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
24012164:	f7ee fb74 	bl	24000850 <HAL_GetTick>
24012168:	6278      	str	r0, [r7, #36]	; 0x24

      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == 0U)
2401216a:	e008      	b.n	2401217e <HAL_RCC_OscConfig+0x3ca>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
2401216c:	f7ee fb70 	bl	24000850 <HAL_GetTick>
24012170:	4602      	mov	r2, r0
24012172:	6a7b      	ldr	r3, [r7, #36]	; 0x24
24012174:	1ad3      	subs	r3, r2, r3
24012176:	2b02      	cmp	r3, #2
24012178:	d901      	bls.n	2401217e <HAL_RCC_OscConfig+0x3ca>
        {
          return HAL_TIMEOUT;
2401217a:	2303      	movs	r3, #3
2401217c:	e1e8      	b.n	24012550 <HAL_RCC_OscConfig+0x79c>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == 0U)
2401217e:	4b5f      	ldr	r3, [pc, #380]	; (240122fc <HAL_RCC_OscConfig+0x548>)
24012180:	6f5b      	ldr	r3, [r3, #116]	; 0x74
24012182:	f003 0302 	and.w	r3, r3, #2
24012186:	2b00      	cmp	r3, #0
24012188:	d0f0      	beq.n	2401216c <HAL_RCC_OscConfig+0x3b8>
2401218a:	e018      	b.n	240121be <HAL_RCC_OscConfig+0x40a>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
2401218c:	4b5b      	ldr	r3, [pc, #364]	; (240122fc <HAL_RCC_OscConfig+0x548>)
2401218e:	6f5b      	ldr	r3, [r3, #116]	; 0x74
24012190:	4a5a      	ldr	r2, [pc, #360]	; (240122fc <HAL_RCC_OscConfig+0x548>)
24012192:	f023 0301 	bic.w	r3, r3, #1
24012196:	6753      	str	r3, [r2, #116]	; 0x74

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
24012198:	f7ee fb5a 	bl	24000850 <HAL_GetTick>
2401219c:	6278      	str	r0, [r7, #36]	; 0x24

      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != 0U)
2401219e:	e008      	b.n	240121b2 <HAL_RCC_OscConfig+0x3fe>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
240121a0:	f7ee fb56 	bl	24000850 <HAL_GetTick>
240121a4:	4602      	mov	r2, r0
240121a6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
240121a8:	1ad3      	subs	r3, r2, r3
240121aa:	2b02      	cmp	r3, #2
240121ac:	d901      	bls.n	240121b2 <HAL_RCC_OscConfig+0x3fe>
        {
          return HAL_TIMEOUT;
240121ae:	2303      	movs	r3, #3
240121b0:	e1ce      	b.n	24012550 <HAL_RCC_OscConfig+0x79c>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != 0U)
240121b2:	4b52      	ldr	r3, [pc, #328]	; (240122fc <HAL_RCC_OscConfig+0x548>)
240121b4:	6f5b      	ldr	r3, [r3, #116]	; 0x74
240121b6:	f003 0302 	and.w	r3, r3, #2
240121ba:	2b00      	cmp	r3, #0
240121bc:	d1f0      	bne.n	240121a0 <HAL_RCC_OscConfig+0x3ec>
      }
    }
  }

  /*------------------------------ HSI48 Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI48) == RCC_OSCILLATORTYPE_HSI48)
240121be:	687b      	ldr	r3, [r7, #4]
240121c0:	681b      	ldr	r3, [r3, #0]
240121c2:	f003 0320 	and.w	r3, r3, #32
240121c6:	2b00      	cmp	r3, #0
240121c8:	d036      	beq.n	24012238 <HAL_RCC_OscConfig+0x484>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSI48(RCC_OscInitStruct->HSI48State));

    /* Check the HSI48 State */
    if((RCC_OscInitStruct->HSI48State)!= RCC_HSI48_OFF)
240121ca:	687b      	ldr	r3, [r7, #4]
240121cc:	699b      	ldr	r3, [r3, #24]
240121ce:	2b00      	cmp	r3, #0
240121d0:	d019      	beq.n	24012206 <HAL_RCC_OscConfig+0x452>
    {
      /* Enable the Internal Low Speed oscillator (HSI48). */
      __HAL_RCC_HSI48_ENABLE();
240121d2:	4b4a      	ldr	r3, [pc, #296]	; (240122fc <HAL_RCC_OscConfig+0x548>)
240121d4:	681b      	ldr	r3, [r3, #0]
240121d6:	4a49      	ldr	r2, [pc, #292]	; (240122fc <HAL_RCC_OscConfig+0x548>)
240121d8:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
240121dc:	6013      	str	r3, [r2, #0]

      /* Get time-out */
      tickstart = HAL_GetTick();
240121de:	f7ee fb37 	bl	24000850 <HAL_GetTick>
240121e2:	6278      	str	r0, [r7, #36]	; 0x24

      /* Wait till HSI48 is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) == 0U)
240121e4:	e008      	b.n	240121f8 <HAL_RCC_OscConfig+0x444>
      {
        if((HAL_GetTick() - tickstart ) > HSI48_TIMEOUT_VALUE)
240121e6:	f7ee fb33 	bl	24000850 <HAL_GetTick>
240121ea:	4602      	mov	r2, r0
240121ec:	6a7b      	ldr	r3, [r7, #36]	; 0x24
240121ee:	1ad3      	subs	r3, r2, r3
240121f0:	2b02      	cmp	r3, #2
240121f2:	d901      	bls.n	240121f8 <HAL_RCC_OscConfig+0x444>
        {
          return HAL_TIMEOUT;
240121f4:	2303      	movs	r3, #3
240121f6:	e1ab      	b.n	24012550 <HAL_RCC_OscConfig+0x79c>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) == 0U)
240121f8:	4b40      	ldr	r3, [pc, #256]	; (240122fc <HAL_RCC_OscConfig+0x548>)
240121fa:	681b      	ldr	r3, [r3, #0]
240121fc:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
24012200:	2b00      	cmp	r3, #0
24012202:	d0f0      	beq.n	240121e6 <HAL_RCC_OscConfig+0x432>
24012204:	e018      	b.n	24012238 <HAL_RCC_OscConfig+0x484>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (HSI48). */
      __HAL_RCC_HSI48_DISABLE();
24012206:	4b3d      	ldr	r3, [pc, #244]	; (240122fc <HAL_RCC_OscConfig+0x548>)
24012208:	681b      	ldr	r3, [r3, #0]
2401220a:	4a3c      	ldr	r2, [pc, #240]	; (240122fc <HAL_RCC_OscConfig+0x548>)
2401220c:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
24012210:	6013      	str	r3, [r2, #0]

      /* Get time-out */
      tickstart = HAL_GetTick();
24012212:	f7ee fb1d 	bl	24000850 <HAL_GetTick>
24012216:	6278      	str	r0, [r7, #36]	; 0x24

      /* Wait till HSI48 is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) != 0U)
24012218:	e008      	b.n	2401222c <HAL_RCC_OscConfig+0x478>
      {
        if((HAL_GetTick() - tickstart ) > HSI48_TIMEOUT_VALUE)
2401221a:	f7ee fb19 	bl	24000850 <HAL_GetTick>
2401221e:	4602      	mov	r2, r0
24012220:	6a7b      	ldr	r3, [r7, #36]	; 0x24
24012222:	1ad3      	subs	r3, r2, r3
24012224:	2b02      	cmp	r3, #2
24012226:	d901      	bls.n	2401222c <HAL_RCC_OscConfig+0x478>
        {
          return HAL_TIMEOUT;
24012228:	2303      	movs	r3, #3
2401222a:	e191      	b.n	24012550 <HAL_RCC_OscConfig+0x79c>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) != 0U)
2401222c:	4b33      	ldr	r3, [pc, #204]	; (240122fc <HAL_RCC_OscConfig+0x548>)
2401222e:	681b      	ldr	r3, [r3, #0]
24012230:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
24012234:	2b00      	cmp	r3, #0
24012236:	d1f0      	bne.n	2401221a <HAL_RCC_OscConfig+0x466>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
24012238:	687b      	ldr	r3, [r7, #4]
2401223a:	681b      	ldr	r3, [r3, #0]
2401223c:	f003 0304 	and.w	r3, r3, #4
24012240:	2b00      	cmp	r3, #0
24012242:	f000 8086 	beq.w	24012352 <HAL_RCC_OscConfig+0x59e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));

    /* Enable write access to Backup domain */
    PWR->CR1 |= PWR_CR1_DBP;
24012246:	4b2e      	ldr	r3, [pc, #184]	; (24012300 <HAL_RCC_OscConfig+0x54c>)
24012248:	681b      	ldr	r3, [r3, #0]
2401224a:	4a2d      	ldr	r2, [pc, #180]	; (24012300 <HAL_RCC_OscConfig+0x54c>)
2401224c:	f443 7380 	orr.w	r3, r3, #256	; 0x100
24012250:	6013      	str	r3, [r2, #0]

    /* Wait for Backup domain Write protection disable */
    tickstart = HAL_GetTick();
24012252:	f7ee fafd 	bl	24000850 <HAL_GetTick>
24012256:	6278      	str	r0, [r7, #36]	; 0x24

    while((PWR->CR1 & PWR_CR1_DBP) == 0U)
24012258:	e008      	b.n	2401226c <HAL_RCC_OscConfig+0x4b8>
    {
      if((HAL_GetTick() - tickstart ) > RCC_DBP_TIMEOUT_VALUE)
2401225a:	f7ee faf9 	bl	24000850 <HAL_GetTick>
2401225e:	4602      	mov	r2, r0
24012260:	6a7b      	ldr	r3, [r7, #36]	; 0x24
24012262:	1ad3      	subs	r3, r2, r3
24012264:	2b64      	cmp	r3, #100	; 0x64
24012266:	d901      	bls.n	2401226c <HAL_RCC_OscConfig+0x4b8>
      {
        return HAL_TIMEOUT;
24012268:	2303      	movs	r3, #3
2401226a:	e171      	b.n	24012550 <HAL_RCC_OscConfig+0x79c>
    while((PWR->CR1 & PWR_CR1_DBP) == 0U)
2401226c:	4b24      	ldr	r3, [pc, #144]	; (24012300 <HAL_RCC_OscConfig+0x54c>)
2401226e:	681b      	ldr	r3, [r3, #0]
24012270:	f403 7380 	and.w	r3, r3, #256	; 0x100
24012274:	2b00      	cmp	r3, #0
24012276:	d0f0      	beq.n	2401225a <HAL_RCC_OscConfig+0x4a6>
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
24012278:	687b      	ldr	r3, [r7, #4]
2401227a:	689b      	ldr	r3, [r3, #8]
2401227c:	2b01      	cmp	r3, #1
2401227e:	d106      	bne.n	2401228e <HAL_RCC_OscConfig+0x4da>
24012280:	4b1e      	ldr	r3, [pc, #120]	; (240122fc <HAL_RCC_OscConfig+0x548>)
24012282:	6f1b      	ldr	r3, [r3, #112]	; 0x70
24012284:	4a1d      	ldr	r2, [pc, #116]	; (240122fc <HAL_RCC_OscConfig+0x548>)
24012286:	f043 0301 	orr.w	r3, r3, #1
2401228a:	6713      	str	r3, [r2, #112]	; 0x70
2401228c:	e02d      	b.n	240122ea <HAL_RCC_OscConfig+0x536>
2401228e:	687b      	ldr	r3, [r7, #4]
24012290:	689b      	ldr	r3, [r3, #8]
24012292:	2b00      	cmp	r3, #0
24012294:	d10c      	bne.n	240122b0 <HAL_RCC_OscConfig+0x4fc>
24012296:	4b19      	ldr	r3, [pc, #100]	; (240122fc <HAL_RCC_OscConfig+0x548>)
24012298:	6f1b      	ldr	r3, [r3, #112]	; 0x70
2401229a:	4a18      	ldr	r2, [pc, #96]	; (240122fc <HAL_RCC_OscConfig+0x548>)
2401229c:	f023 0301 	bic.w	r3, r3, #1
240122a0:	6713      	str	r3, [r2, #112]	; 0x70
240122a2:	4b16      	ldr	r3, [pc, #88]	; (240122fc <HAL_RCC_OscConfig+0x548>)
240122a4:	6f1b      	ldr	r3, [r3, #112]	; 0x70
240122a6:	4a15      	ldr	r2, [pc, #84]	; (240122fc <HAL_RCC_OscConfig+0x548>)
240122a8:	f023 0304 	bic.w	r3, r3, #4
240122ac:	6713      	str	r3, [r2, #112]	; 0x70
240122ae:	e01c      	b.n	240122ea <HAL_RCC_OscConfig+0x536>
240122b0:	687b      	ldr	r3, [r7, #4]
240122b2:	689b      	ldr	r3, [r3, #8]
240122b4:	2b05      	cmp	r3, #5
240122b6:	d10c      	bne.n	240122d2 <HAL_RCC_OscConfig+0x51e>
240122b8:	4b10      	ldr	r3, [pc, #64]	; (240122fc <HAL_RCC_OscConfig+0x548>)
240122ba:	6f1b      	ldr	r3, [r3, #112]	; 0x70
240122bc:	4a0f      	ldr	r2, [pc, #60]	; (240122fc <HAL_RCC_OscConfig+0x548>)
240122be:	f043 0304 	orr.w	r3, r3, #4
240122c2:	6713      	str	r3, [r2, #112]	; 0x70
240122c4:	4b0d      	ldr	r3, [pc, #52]	; (240122fc <HAL_RCC_OscConfig+0x548>)
240122c6:	6f1b      	ldr	r3, [r3, #112]	; 0x70
240122c8:	4a0c      	ldr	r2, [pc, #48]	; (240122fc <HAL_RCC_OscConfig+0x548>)
240122ca:	f043 0301 	orr.w	r3, r3, #1
240122ce:	6713      	str	r3, [r2, #112]	; 0x70
240122d0:	e00b      	b.n	240122ea <HAL_RCC_OscConfig+0x536>
240122d2:	4b0a      	ldr	r3, [pc, #40]	; (240122fc <HAL_RCC_OscConfig+0x548>)
240122d4:	6f1b      	ldr	r3, [r3, #112]	; 0x70
240122d6:	4a09      	ldr	r2, [pc, #36]	; (240122fc <HAL_RCC_OscConfig+0x548>)
240122d8:	f023 0301 	bic.w	r3, r3, #1
240122dc:	6713      	str	r3, [r2, #112]	; 0x70
240122de:	4b07      	ldr	r3, [pc, #28]	; (240122fc <HAL_RCC_OscConfig+0x548>)
240122e0:	6f1b      	ldr	r3, [r3, #112]	; 0x70
240122e2:	4a06      	ldr	r2, [pc, #24]	; (240122fc <HAL_RCC_OscConfig+0x548>)
240122e4:	f023 0304 	bic.w	r3, r3, #4
240122e8:	6713      	str	r3, [r2, #112]	; 0x70
    /* Check the LSE State */
    if((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
240122ea:	687b      	ldr	r3, [r7, #4]
240122ec:	689b      	ldr	r3, [r3, #8]
240122ee:	2b00      	cmp	r3, #0
240122f0:	d01a      	beq.n	24012328 <HAL_RCC_OscConfig+0x574>
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
240122f2:	f7ee faad 	bl	24000850 <HAL_GetTick>
240122f6:	6278      	str	r0, [r7, #36]	; 0x24

      /* Wait till LSE is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
240122f8:	e00f      	b.n	2401231a <HAL_RCC_OscConfig+0x566>
240122fa:	bf00      	nop
240122fc:	58024400 	.word	0x58024400
24012300:	58024800 	.word	0x58024800
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
24012304:	f7ee faa4 	bl	24000850 <HAL_GetTick>
24012308:	4602      	mov	r2, r0
2401230a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
2401230c:	1ad3      	subs	r3, r2, r3
2401230e:	f241 3288 	movw	r2, #5000	; 0x1388
24012312:	4293      	cmp	r3, r2
24012314:	d901      	bls.n	2401231a <HAL_RCC_OscConfig+0x566>
        {
          return HAL_TIMEOUT;
24012316:	2303      	movs	r3, #3
24012318:	e11a      	b.n	24012550 <HAL_RCC_OscConfig+0x79c>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
2401231a:	4b8f      	ldr	r3, [pc, #572]	; (24012558 <HAL_RCC_OscConfig+0x7a4>)
2401231c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
2401231e:	f003 0302 	and.w	r3, r3, #2
24012322:	2b00      	cmp	r3, #0
24012324:	d0ee      	beq.n	24012304 <HAL_RCC_OscConfig+0x550>
24012326:	e014      	b.n	24012352 <HAL_RCC_OscConfig+0x59e>
      }
    }
    else
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
24012328:	f7ee fa92 	bl	24000850 <HAL_GetTick>
2401232c:	6278      	str	r0, [r7, #36]	; 0x24

      /* Wait till LSE is disabled */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != 0U)
2401232e:	e00a      	b.n	24012346 <HAL_RCC_OscConfig+0x592>
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
24012330:	f7ee fa8e 	bl	24000850 <HAL_GetTick>
24012334:	4602      	mov	r2, r0
24012336:	6a7b      	ldr	r3, [r7, #36]	; 0x24
24012338:	1ad3      	subs	r3, r2, r3
2401233a:	f241 3288 	movw	r2, #5000	; 0x1388
2401233e:	4293      	cmp	r3, r2
24012340:	d901      	bls.n	24012346 <HAL_RCC_OscConfig+0x592>
        {
          return HAL_TIMEOUT;
24012342:	2303      	movs	r3, #3
24012344:	e104      	b.n	24012550 <HAL_RCC_OscConfig+0x79c>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != 0U)
24012346:	4b84      	ldr	r3, [pc, #528]	; (24012558 <HAL_RCC_OscConfig+0x7a4>)
24012348:	6f1b      	ldr	r3, [r3, #112]	; 0x70
2401234a:	f003 0302 	and.w	r3, r3, #2
2401234e:	2b00      	cmp	r3, #0
24012350:	d1ee      	bne.n	24012330 <HAL_RCC_OscConfig+0x57c>
    }
  }
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
24012352:	687b      	ldr	r3, [r7, #4]
24012354:	6a5b      	ldr	r3, [r3, #36]	; 0x24
24012356:	2b00      	cmp	r3, #0
24012358:	f000 80f9 	beq.w	2401254e <HAL_RCC_OscConfig+0x79a>
  {
    /* Check if the PLL is used as system clock or not */
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL1)
2401235c:	4b7e      	ldr	r3, [pc, #504]	; (24012558 <HAL_RCC_OscConfig+0x7a4>)
2401235e:	691b      	ldr	r3, [r3, #16]
24012360:	f003 0338 	and.w	r3, r3, #56	; 0x38
24012364:	2b18      	cmp	r3, #24
24012366:	f000 80b4 	beq.w	240124d2 <HAL_RCC_OscConfig+0x71e>
    {
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
2401236a:	687b      	ldr	r3, [r7, #4]
2401236c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2401236e:	2b02      	cmp	r3, #2
24012370:	f040 8095 	bne.w	2401249e <HAL_RCC_OscConfig+0x6ea>
        assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));
        assert_param(IS_RCC_PLLR_VALUE(RCC_OscInitStruct->PLL.PLLR));
        assert_param(IS_RCC_PLLFRACN_VALUE(RCC_OscInitStruct->PLL.PLLFRACN));

        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
24012374:	4b78      	ldr	r3, [pc, #480]	; (24012558 <HAL_RCC_OscConfig+0x7a4>)
24012376:	681b      	ldr	r3, [r3, #0]
24012378:	4a77      	ldr	r2, [pc, #476]	; (24012558 <HAL_RCC_OscConfig+0x7a4>)
2401237a:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
2401237e:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
24012380:	f7ee fa66 	bl	24000850 <HAL_GetTick>
24012384:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till PLL is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != 0U)
24012386:	e008      	b.n	2401239a <HAL_RCC_OscConfig+0x5e6>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
24012388:	f7ee fa62 	bl	24000850 <HAL_GetTick>
2401238c:	4602      	mov	r2, r0
2401238e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
24012390:	1ad3      	subs	r3, r2, r3
24012392:	2b02      	cmp	r3, #2
24012394:	d901      	bls.n	2401239a <HAL_RCC_OscConfig+0x5e6>
          {
            return HAL_TIMEOUT;
24012396:	2303      	movs	r3, #3
24012398:	e0da      	b.n	24012550 <HAL_RCC_OscConfig+0x79c>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != 0U)
2401239a:	4b6f      	ldr	r3, [pc, #444]	; (24012558 <HAL_RCC_OscConfig+0x7a4>)
2401239c:	681b      	ldr	r3, [r3, #0]
2401239e:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
240123a2:	2b00      	cmp	r3, #0
240123a4:	d1f0      	bne.n	24012388 <HAL_RCC_OscConfig+0x5d4>
          }
        }

        /* Configure the main PLL clock source, multiplication and division factors. */
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
240123a6:	4b6c      	ldr	r3, [pc, #432]	; (24012558 <HAL_RCC_OscConfig+0x7a4>)
240123a8:	6a9a      	ldr	r2, [r3, #40]	; 0x28
240123aa:	4b6c      	ldr	r3, [pc, #432]	; (2401255c <HAL_RCC_OscConfig+0x7a8>)
240123ac:	4013      	ands	r3, r2
240123ae:	687a      	ldr	r2, [r7, #4]
240123b0:	6a91      	ldr	r1, [r2, #40]	; 0x28
240123b2:	687a      	ldr	r2, [r7, #4]
240123b4:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
240123b6:	0112      	lsls	r2, r2, #4
240123b8:	430a      	orrs	r2, r1
240123ba:	4967      	ldr	r1, [pc, #412]	; (24012558 <HAL_RCC_OscConfig+0x7a4>)
240123bc:	4313      	orrs	r3, r2
240123be:	628b      	str	r3, [r1, #40]	; 0x28
240123c0:	687b      	ldr	r3, [r7, #4]
240123c2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
240123c4:	3b01      	subs	r3, #1
240123c6:	f3c3 0208 	ubfx	r2, r3, #0, #9
240123ca:	687b      	ldr	r3, [r7, #4]
240123cc:	6b5b      	ldr	r3, [r3, #52]	; 0x34
240123ce:	3b01      	subs	r3, #1
240123d0:	025b      	lsls	r3, r3, #9
240123d2:	b29b      	uxth	r3, r3
240123d4:	431a      	orrs	r2, r3
240123d6:	687b      	ldr	r3, [r7, #4]
240123d8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
240123da:	3b01      	subs	r3, #1
240123dc:	041b      	lsls	r3, r3, #16
240123de:	f403 03fe 	and.w	r3, r3, #8323072	; 0x7f0000
240123e2:	431a      	orrs	r2, r3
240123e4:	687b      	ldr	r3, [r7, #4]
240123e6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
240123e8:	3b01      	subs	r3, #1
240123ea:	061b      	lsls	r3, r3, #24
240123ec:	f003 43fe 	and.w	r3, r3, #2130706432	; 0x7f000000
240123f0:	4959      	ldr	r1, [pc, #356]	; (24012558 <HAL_RCC_OscConfig+0x7a4>)
240123f2:	4313      	orrs	r3, r2
240123f4:	630b      	str	r3, [r1, #48]	; 0x30
                             RCC_OscInitStruct->PLL.PLLP,
                             RCC_OscInitStruct->PLL.PLLQ,
                             RCC_OscInitStruct->PLL.PLLR);

         /* Disable PLLFRACN . */
         __HAL_RCC_PLLFRACN_DISABLE();
240123f6:	4b58      	ldr	r3, [pc, #352]	; (24012558 <HAL_RCC_OscConfig+0x7a4>)
240123f8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
240123fa:	4a57      	ldr	r2, [pc, #348]	; (24012558 <HAL_RCC_OscConfig+0x7a4>)
240123fc:	f023 0301 	bic.w	r3, r3, #1
24012400:	62d3      	str	r3, [r2, #44]	; 0x2c

         /* Configure PLL PLL1FRACN */
         __HAL_RCC_PLLFRACN_CONFIG(RCC_OscInitStruct->PLL.PLLFRACN);
24012402:	4b55      	ldr	r3, [pc, #340]	; (24012558 <HAL_RCC_OscConfig+0x7a4>)
24012404:	6b5a      	ldr	r2, [r3, #52]	; 0x34
24012406:	4b56      	ldr	r3, [pc, #344]	; (24012560 <HAL_RCC_OscConfig+0x7ac>)
24012408:	4013      	ands	r3, r2
2401240a:	687a      	ldr	r2, [r7, #4]
2401240c:	6c92      	ldr	r2, [r2, #72]	; 0x48
2401240e:	00d2      	lsls	r2, r2, #3
24012410:	4951      	ldr	r1, [pc, #324]	; (24012558 <HAL_RCC_OscConfig+0x7a4>)
24012412:	4313      	orrs	r3, r2
24012414:	634b      	str	r3, [r1, #52]	; 0x34

        /* Select PLL1 input reference frequency range: VCI */
        __HAL_RCC_PLL_VCIRANGE(RCC_OscInitStruct->PLL.PLLRGE) ;
24012416:	4b50      	ldr	r3, [pc, #320]	; (24012558 <HAL_RCC_OscConfig+0x7a4>)
24012418:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2401241a:	f023 020c 	bic.w	r2, r3, #12
2401241e:	687b      	ldr	r3, [r7, #4]
24012420:	6c1b      	ldr	r3, [r3, #64]	; 0x40
24012422:	494d      	ldr	r1, [pc, #308]	; (24012558 <HAL_RCC_OscConfig+0x7a4>)
24012424:	4313      	orrs	r3, r2
24012426:	62cb      	str	r3, [r1, #44]	; 0x2c

        /* Select PLL1 output frequency range : VCO */
        __HAL_RCC_PLL_VCORANGE(RCC_OscInitStruct->PLL.PLLVCOSEL) ;
24012428:	4b4b      	ldr	r3, [pc, #300]	; (24012558 <HAL_RCC_OscConfig+0x7a4>)
2401242a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2401242c:	f023 0202 	bic.w	r2, r3, #2
24012430:	687b      	ldr	r3, [r7, #4]
24012432:	6c5b      	ldr	r3, [r3, #68]	; 0x44
24012434:	4948      	ldr	r1, [pc, #288]	; (24012558 <HAL_RCC_OscConfig+0x7a4>)
24012436:	4313      	orrs	r3, r2
24012438:	62cb      	str	r3, [r1, #44]	; 0x2c

        /* Enable PLL System Clock output. */
         __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVP);
2401243a:	4b47      	ldr	r3, [pc, #284]	; (24012558 <HAL_RCC_OscConfig+0x7a4>)
2401243c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2401243e:	4a46      	ldr	r2, [pc, #280]	; (24012558 <HAL_RCC_OscConfig+0x7a4>)
24012440:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
24012444:	62d3      	str	r3, [r2, #44]	; 0x2c

        /* Enable PLL1Q Clock output. */
         __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
24012446:	4b44      	ldr	r3, [pc, #272]	; (24012558 <HAL_RCC_OscConfig+0x7a4>)
24012448:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2401244a:	4a43      	ldr	r2, [pc, #268]	; (24012558 <HAL_RCC_OscConfig+0x7a4>)
2401244c:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
24012450:	62d3      	str	r3, [r2, #44]	; 0x2c

        /* Enable PLL1R  Clock output. */
         __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVR);
24012452:	4b41      	ldr	r3, [pc, #260]	; (24012558 <HAL_RCC_OscConfig+0x7a4>)
24012454:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24012456:	4a40      	ldr	r2, [pc, #256]	; (24012558 <HAL_RCC_OscConfig+0x7a4>)
24012458:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
2401245c:	62d3      	str	r3, [r2, #44]	; 0x2c

        /* Enable PLL1FRACN . */
         __HAL_RCC_PLLFRACN_ENABLE();
2401245e:	4b3e      	ldr	r3, [pc, #248]	; (24012558 <HAL_RCC_OscConfig+0x7a4>)
24012460:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24012462:	4a3d      	ldr	r2, [pc, #244]	; (24012558 <HAL_RCC_OscConfig+0x7a4>)
24012464:	f043 0301 	orr.w	r3, r3, #1
24012468:	62d3      	str	r3, [r2, #44]	; 0x2c

        /* Enable the main PLL. */
        __HAL_RCC_PLL_ENABLE();
2401246a:	4b3b      	ldr	r3, [pc, #236]	; (24012558 <HAL_RCC_OscConfig+0x7a4>)
2401246c:	681b      	ldr	r3, [r3, #0]
2401246e:	4a3a      	ldr	r2, [pc, #232]	; (24012558 <HAL_RCC_OscConfig+0x7a4>)
24012470:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
24012474:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
24012476:	f7ee f9eb 	bl	24000850 <HAL_GetTick>
2401247a:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == 0U)
2401247c:	e008      	b.n	24012490 <HAL_RCC_OscConfig+0x6dc>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
2401247e:	f7ee f9e7 	bl	24000850 <HAL_GetTick>
24012482:	4602      	mov	r2, r0
24012484:	6a7b      	ldr	r3, [r7, #36]	; 0x24
24012486:	1ad3      	subs	r3, r2, r3
24012488:	2b02      	cmp	r3, #2
2401248a:	d901      	bls.n	24012490 <HAL_RCC_OscConfig+0x6dc>
          {
            return HAL_TIMEOUT;
2401248c:	2303      	movs	r3, #3
2401248e:	e05f      	b.n	24012550 <HAL_RCC_OscConfig+0x79c>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == 0U)
24012490:	4b31      	ldr	r3, [pc, #196]	; (24012558 <HAL_RCC_OscConfig+0x7a4>)
24012492:	681b      	ldr	r3, [r3, #0]
24012494:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
24012498:	2b00      	cmp	r3, #0
2401249a:	d0f0      	beq.n	2401247e <HAL_RCC_OscConfig+0x6ca>
2401249c:	e057      	b.n	2401254e <HAL_RCC_OscConfig+0x79a>
        }
      }
      else
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
2401249e:	4b2e      	ldr	r3, [pc, #184]	; (24012558 <HAL_RCC_OscConfig+0x7a4>)
240124a0:	681b      	ldr	r3, [r3, #0]
240124a2:	4a2d      	ldr	r2, [pc, #180]	; (24012558 <HAL_RCC_OscConfig+0x7a4>)
240124a4:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
240124a8:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
240124aa:	f7ee f9d1 	bl	24000850 <HAL_GetTick>
240124ae:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till PLL is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != 0U)
240124b0:	e008      	b.n	240124c4 <HAL_RCC_OscConfig+0x710>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
240124b2:	f7ee f9cd 	bl	24000850 <HAL_GetTick>
240124b6:	4602      	mov	r2, r0
240124b8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
240124ba:	1ad3      	subs	r3, r2, r3
240124bc:	2b02      	cmp	r3, #2
240124be:	d901      	bls.n	240124c4 <HAL_RCC_OscConfig+0x710>
          {
            return HAL_TIMEOUT;
240124c0:	2303      	movs	r3, #3
240124c2:	e045      	b.n	24012550 <HAL_RCC_OscConfig+0x79c>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != 0U)
240124c4:	4b24      	ldr	r3, [pc, #144]	; (24012558 <HAL_RCC_OscConfig+0x7a4>)
240124c6:	681b      	ldr	r3, [r3, #0]
240124c8:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
240124cc:	2b00      	cmp	r3, #0
240124ce:	d1f0      	bne.n	240124b2 <HAL_RCC_OscConfig+0x6fe>
240124d0:	e03d      	b.n	2401254e <HAL_RCC_OscConfig+0x79a>
      }
    }
    else
    {
      /* Do not return HAL_ERROR if request repeats the current configuration */
      temp1_pllckcfg = RCC->PLLCKSELR;
240124d2:	4b21      	ldr	r3, [pc, #132]	; (24012558 <HAL_RCC_OscConfig+0x7a4>)
240124d4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
240124d6:	613b      	str	r3, [r7, #16]
      temp2_pllckcfg = RCC->PLL1DIVR;
240124d8:	4b1f      	ldr	r3, [pc, #124]	; (24012558 <HAL_RCC_OscConfig+0x7a4>)
240124da:	6b1b      	ldr	r3, [r3, #48]	; 0x30
240124dc:	60fb      	str	r3, [r7, #12]
      if(((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
240124de:	687b      	ldr	r3, [r7, #4]
240124e0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
240124e2:	2b01      	cmp	r3, #1
240124e4:	d031      	beq.n	2401254a <HAL_RCC_OscConfig+0x796>
	 (READ_BIT(temp1_pllckcfg, RCC_PLLCKSELR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
240124e6:	693b      	ldr	r3, [r7, #16]
240124e8:	f003 0203 	and.w	r2, r3, #3
240124ec:	687b      	ldr	r3, [r7, #4]
240124ee:	6a9b      	ldr	r3, [r3, #40]	; 0x28
      if(((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
240124f0:	429a      	cmp	r2, r3
240124f2:	d12a      	bne.n	2401254a <HAL_RCC_OscConfig+0x796>
         ((READ_BIT(temp1_pllckcfg, RCC_PLLCKSELR_DIVM1) >> RCC_PLLCKSELR_DIVM1_Pos) != RCC_OscInitStruct->PLL.PLLM) ||
240124f4:	693b      	ldr	r3, [r7, #16]
240124f6:	091b      	lsrs	r3, r3, #4
240124f8:	f003 023f 	and.w	r2, r3, #63	; 0x3f
240124fc:	687b      	ldr	r3, [r7, #4]
240124fe:	6adb      	ldr	r3, [r3, #44]	; 0x2c
	 (READ_BIT(temp1_pllckcfg, RCC_PLLCKSELR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
24012500:	429a      	cmp	r2, r3
24012502:	d122      	bne.n	2401254a <HAL_RCC_OscConfig+0x796>
         (READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_N1) != (RCC_OscInitStruct->PLL.PLLN - 1U)) ||
24012504:	68fb      	ldr	r3, [r7, #12]
24012506:	f3c3 0208 	ubfx	r2, r3, #0, #9
2401250a:	687b      	ldr	r3, [r7, #4]
2401250c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2401250e:	3b01      	subs	r3, #1
         ((READ_BIT(temp1_pllckcfg, RCC_PLLCKSELR_DIVM1) >> RCC_PLLCKSELR_DIVM1_Pos) != RCC_OscInitStruct->PLL.PLLM) ||
24012510:	429a      	cmp	r2, r3
24012512:	d11a      	bne.n	2401254a <HAL_RCC_OscConfig+0x796>
         ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_P1) >> RCC_PLL1DIVR_P1_Pos) != (RCC_OscInitStruct->PLL.PLLP - 1U)) ||
24012514:	68fb      	ldr	r3, [r7, #12]
24012516:	0a5b      	lsrs	r3, r3, #9
24012518:	f003 027f 	and.w	r2, r3, #127	; 0x7f
2401251c:	687b      	ldr	r3, [r7, #4]
2401251e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
24012520:	3b01      	subs	r3, #1
         (READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_N1) != (RCC_OscInitStruct->PLL.PLLN - 1U)) ||
24012522:	429a      	cmp	r2, r3
24012524:	d111      	bne.n	2401254a <HAL_RCC_OscConfig+0x796>
         ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_Q1) >> RCC_PLL1DIVR_Q1_Pos) != (RCC_OscInitStruct->PLL.PLLQ - 1U)) ||
24012526:	68fb      	ldr	r3, [r7, #12]
24012528:	0c1b      	lsrs	r3, r3, #16
2401252a:	f003 027f 	and.w	r2, r3, #127	; 0x7f
2401252e:	687b      	ldr	r3, [r7, #4]
24012530:	6b9b      	ldr	r3, [r3, #56]	; 0x38
24012532:	3b01      	subs	r3, #1
         ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_P1) >> RCC_PLL1DIVR_P1_Pos) != (RCC_OscInitStruct->PLL.PLLP - 1U)) ||
24012534:	429a      	cmp	r2, r3
24012536:	d108      	bne.n	2401254a <HAL_RCC_OscConfig+0x796>
         ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_R1) >> RCC_PLL1DIVR_R1_Pos) != (RCC_OscInitStruct->PLL.PLLR - 1U)))
24012538:	68fb      	ldr	r3, [r7, #12]
2401253a:	0e1b      	lsrs	r3, r3, #24
2401253c:	f003 027f 	and.w	r2, r3, #127	; 0x7f
24012540:	687b      	ldr	r3, [r7, #4]
24012542:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24012544:	3b01      	subs	r3, #1
         ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_Q1) >> RCC_PLL1DIVR_Q1_Pos) != (RCC_OscInitStruct->PLL.PLLQ - 1U)) ||
24012546:	429a      	cmp	r2, r3
24012548:	d001      	beq.n	2401254e <HAL_RCC_OscConfig+0x79a>
      {
        return HAL_ERROR;
2401254a:	2301      	movs	r3, #1
2401254c:	e000      	b.n	24012550 <HAL_RCC_OscConfig+0x79c>
      }
    }
  }
  return HAL_OK;
2401254e:	2300      	movs	r3, #0
}
24012550:	4618      	mov	r0, r3
24012552:	3730      	adds	r7, #48	; 0x30
24012554:	46bd      	mov	sp, r7
24012556:	bd80      	pop	{r7, pc}
24012558:	58024400 	.word	0x58024400
2401255c:	fffffc0c 	.word	0xfffffc0c
24012560:	ffff0007 	.word	0xffff0007

24012564 <HAL_RCC_ClockConfig>:
  *         D1CPRE[3:0] bits to ensure that  Domain1 core clock not exceed the maximum allowed frequency
  *         (for more details refer to section above "Initialization/de-initialization functions")
  * @retval None
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
24012564:	b580      	push	{r7, lr}
24012566:	b086      	sub	sp, #24
24012568:	af00      	add	r7, sp, #0
2401256a:	6078      	str	r0, [r7, #4]
2401256c:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef halstatus;
  uint32_t tickstart;
  uint32_t common_system_clock;

   /* Check Null pointer */
  if(RCC_ClkInitStruct == NULL)
2401256e:	687b      	ldr	r3, [r7, #4]
24012570:	2b00      	cmp	r3, #0
24012572:	d101      	bne.n	24012578 <HAL_RCC_ClockConfig+0x14>
  {
    return HAL_ERROR;
24012574:	2301      	movs	r3, #1
24012576:	e19c      	b.n	240128b2 <HAL_RCC_ClockConfig+0x34e>
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
    must be correctly programmed according to the frequency of the CPU clock
    (HCLK) and the supply voltage of the device. */

  /* Increasing the CPU frequency */
  if(FLatency > __HAL_FLASH_GET_LATENCY())
24012578:	4b8a      	ldr	r3, [pc, #552]	; (240127a4 <HAL_RCC_ClockConfig+0x240>)
2401257a:	681b      	ldr	r3, [r3, #0]
2401257c:	f003 030f 	and.w	r3, r3, #15
24012580:	683a      	ldr	r2, [r7, #0]
24012582:	429a      	cmp	r2, r3
24012584:	d910      	bls.n	240125a8 <HAL_RCC_ClockConfig+0x44>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
24012586:	4b87      	ldr	r3, [pc, #540]	; (240127a4 <HAL_RCC_ClockConfig+0x240>)
24012588:	681b      	ldr	r3, [r3, #0]
2401258a:	f023 020f 	bic.w	r2, r3, #15
2401258e:	4985      	ldr	r1, [pc, #532]	; (240127a4 <HAL_RCC_ClockConfig+0x240>)
24012590:	683b      	ldr	r3, [r7, #0]
24012592:	4313      	orrs	r3, r2
24012594:	600b      	str	r3, [r1, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
24012596:	4b83      	ldr	r3, [pc, #524]	; (240127a4 <HAL_RCC_ClockConfig+0x240>)
24012598:	681b      	ldr	r3, [r3, #0]
2401259a:	f003 030f 	and.w	r3, r3, #15
2401259e:	683a      	ldr	r2, [r7, #0]
240125a0:	429a      	cmp	r2, r3
240125a2:	d001      	beq.n	240125a8 <HAL_RCC_ClockConfig+0x44>
    {
      return HAL_ERROR;
240125a4:	2301      	movs	r3, #1
240125a6:	e184      	b.n	240128b2 <HAL_RCC_ClockConfig+0x34e>

  }

  /* Increasing the BUS frequency divider */
  /*-------------------------- D1PCLK1/CDPCLK1 Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_D1PCLK1) == RCC_CLOCKTYPE_D1PCLK1)
240125a8:	687b      	ldr	r3, [r7, #4]
240125aa:	681b      	ldr	r3, [r3, #0]
240125ac:	f003 0304 	and.w	r3, r3, #4
240125b0:	2b00      	cmp	r3, #0
240125b2:	d010      	beq.n	240125d6 <HAL_RCC_ClockConfig+0x72>
  {
#if defined (RCC_D1CFGR_D1PPRE)
    if((RCC_ClkInitStruct->APB3CLKDivider) > (RCC->D1CFGR & RCC_D1CFGR_D1PPRE))
240125b4:	687b      	ldr	r3, [r7, #4]
240125b6:	691a      	ldr	r2, [r3, #16]
240125b8:	4b7b      	ldr	r3, [pc, #492]	; (240127a8 <HAL_RCC_ClockConfig+0x244>)
240125ba:	699b      	ldr	r3, [r3, #24]
240125bc:	f003 0370 	and.w	r3, r3, #112	; 0x70
240125c0:	429a      	cmp	r2, r3
240125c2:	d908      	bls.n	240125d6 <HAL_RCC_ClockConfig+0x72>
    {
      assert_param(IS_RCC_D1PCLK1(RCC_ClkInitStruct->APB3CLKDivider));
      MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_D1PPRE, RCC_ClkInitStruct->APB3CLKDivider);
240125c4:	4b78      	ldr	r3, [pc, #480]	; (240127a8 <HAL_RCC_ClockConfig+0x244>)
240125c6:	699b      	ldr	r3, [r3, #24]
240125c8:	f023 0270 	bic.w	r2, r3, #112	; 0x70
240125cc:	687b      	ldr	r3, [r7, #4]
240125ce:	691b      	ldr	r3, [r3, #16]
240125d0:	4975      	ldr	r1, [pc, #468]	; (240127a8 <HAL_RCC_ClockConfig+0x244>)
240125d2:	4313      	orrs	r3, r2
240125d4:	618b      	str	r3, [r1, #24]
    }
#endif
  }

  /*-------------------------- PCLK1 Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
240125d6:	687b      	ldr	r3, [r7, #4]
240125d8:	681b      	ldr	r3, [r3, #0]
240125da:	f003 0308 	and.w	r3, r3, #8
240125de:	2b00      	cmp	r3, #0
240125e0:	d010      	beq.n	24012604 <HAL_RCC_ClockConfig+0xa0>
  {
#if defined (RCC_D2CFGR_D2PPRE1)
    if((RCC_ClkInitStruct->APB1CLKDivider) > (RCC->D2CFGR & RCC_D2CFGR_D2PPRE1))
240125e2:	687b      	ldr	r3, [r7, #4]
240125e4:	695a      	ldr	r2, [r3, #20]
240125e6:	4b70      	ldr	r3, [pc, #448]	; (240127a8 <HAL_RCC_ClockConfig+0x244>)
240125e8:	69db      	ldr	r3, [r3, #28]
240125ea:	f003 0370 	and.w	r3, r3, #112	; 0x70
240125ee:	429a      	cmp	r2, r3
240125f0:	d908      	bls.n	24012604 <HAL_RCC_ClockConfig+0xa0>
    {
      assert_param(IS_RCC_PCLK1(RCC_ClkInitStruct->APB1CLKDivider));
      MODIFY_REG(RCC->D2CFGR, RCC_D2CFGR_D2PPRE1, (RCC_ClkInitStruct->APB1CLKDivider));
240125f2:	4b6d      	ldr	r3, [pc, #436]	; (240127a8 <HAL_RCC_ClockConfig+0x244>)
240125f4:	69db      	ldr	r3, [r3, #28]
240125f6:	f023 0270 	bic.w	r2, r3, #112	; 0x70
240125fa:	687b      	ldr	r3, [r7, #4]
240125fc:	695b      	ldr	r3, [r3, #20]
240125fe:	496a      	ldr	r1, [pc, #424]	; (240127a8 <HAL_RCC_ClockConfig+0x244>)
24012600:	4313      	orrs	r3, r2
24012602:	61cb      	str	r3, [r1, #28]
      MODIFY_REG(RCC->CDCFGR2, RCC_CDCFGR2_CDPPRE1, (RCC_ClkInitStruct->APB1CLKDivider));
  }
#endif
    }
  /*-------------------------- PCLK2 Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
24012604:	687b      	ldr	r3, [r7, #4]
24012606:	681b      	ldr	r3, [r3, #0]
24012608:	f003 0310 	and.w	r3, r3, #16
2401260c:	2b00      	cmp	r3, #0
2401260e:	d010      	beq.n	24012632 <HAL_RCC_ClockConfig+0xce>
  {
#if defined(RCC_D2CFGR_D2PPRE2)
    if((RCC_ClkInitStruct->APB2CLKDivider) > (RCC->D2CFGR & RCC_D2CFGR_D2PPRE2))
24012610:	687b      	ldr	r3, [r7, #4]
24012612:	699a      	ldr	r2, [r3, #24]
24012614:	4b64      	ldr	r3, [pc, #400]	; (240127a8 <HAL_RCC_ClockConfig+0x244>)
24012616:	69db      	ldr	r3, [r3, #28]
24012618:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
2401261c:	429a      	cmp	r2, r3
2401261e:	d908      	bls.n	24012632 <HAL_RCC_ClockConfig+0xce>
    {
      assert_param(IS_RCC_PCLK2(RCC_ClkInitStruct->APB2CLKDivider));
      MODIFY_REG(RCC->D2CFGR, RCC_D2CFGR_D2PPRE2, (RCC_ClkInitStruct->APB2CLKDivider));
24012620:	4b61      	ldr	r3, [pc, #388]	; (240127a8 <HAL_RCC_ClockConfig+0x244>)
24012622:	69db      	ldr	r3, [r3, #28]
24012624:	f423 62e0 	bic.w	r2, r3, #1792	; 0x700
24012628:	687b      	ldr	r3, [r7, #4]
2401262a:	699b      	ldr	r3, [r3, #24]
2401262c:	495e      	ldr	r1, [pc, #376]	; (240127a8 <HAL_RCC_ClockConfig+0x244>)
2401262e:	4313      	orrs	r3, r2
24012630:	61cb      	str	r3, [r1, #28]
    }
#endif
  }

  /*-------------------------- D3PCLK1 Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_D3PCLK1) == RCC_CLOCKTYPE_D3PCLK1)
24012632:	687b      	ldr	r3, [r7, #4]
24012634:	681b      	ldr	r3, [r3, #0]
24012636:	f003 0320 	and.w	r3, r3, #32
2401263a:	2b00      	cmp	r3, #0
2401263c:	d010      	beq.n	24012660 <HAL_RCC_ClockConfig+0xfc>
  {
#if defined(RCC_D3CFGR_D3PPRE)
    if((RCC_ClkInitStruct->APB4CLKDivider) > (RCC->D3CFGR & RCC_D3CFGR_D3PPRE))
2401263e:	687b      	ldr	r3, [r7, #4]
24012640:	69da      	ldr	r2, [r3, #28]
24012642:	4b59      	ldr	r3, [pc, #356]	; (240127a8 <HAL_RCC_ClockConfig+0x244>)
24012644:	6a1b      	ldr	r3, [r3, #32]
24012646:	f003 0370 	and.w	r3, r3, #112	; 0x70
2401264a:	429a      	cmp	r2, r3
2401264c:	d908      	bls.n	24012660 <HAL_RCC_ClockConfig+0xfc>
    {
      assert_param(IS_RCC_D3PCLK1(RCC_ClkInitStruct->APB4CLKDivider));
      MODIFY_REG(RCC->D3CFGR, RCC_D3CFGR_D3PPRE, (RCC_ClkInitStruct->APB4CLKDivider) );
2401264e:	4b56      	ldr	r3, [pc, #344]	; (240127a8 <HAL_RCC_ClockConfig+0x244>)
24012650:	6a1b      	ldr	r3, [r3, #32]
24012652:	f023 0270 	bic.w	r2, r3, #112	; 0x70
24012656:	687b      	ldr	r3, [r7, #4]
24012658:	69db      	ldr	r3, [r3, #28]
2401265a:	4953      	ldr	r1, [pc, #332]	; (240127a8 <HAL_RCC_ClockConfig+0x244>)
2401265c:	4313      	orrs	r3, r2
2401265e:	620b      	str	r3, [r1, #32]
    }
#endif
  }

   /*-------------------------- HCLK Configuration --------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
24012660:	687b      	ldr	r3, [r7, #4]
24012662:	681b      	ldr	r3, [r3, #0]
24012664:	f003 0302 	and.w	r3, r3, #2
24012668:	2b00      	cmp	r3, #0
2401266a:	d010      	beq.n	2401268e <HAL_RCC_ClockConfig+0x12a>
  {
#if defined (RCC_D1CFGR_HPRE)
    if((RCC_ClkInitStruct->AHBCLKDivider) > (RCC->D1CFGR & RCC_D1CFGR_HPRE))
2401266c:	687b      	ldr	r3, [r7, #4]
2401266e:	68da      	ldr	r2, [r3, #12]
24012670:	4b4d      	ldr	r3, [pc, #308]	; (240127a8 <HAL_RCC_ClockConfig+0x244>)
24012672:	699b      	ldr	r3, [r3, #24]
24012674:	f003 030f 	and.w	r3, r3, #15
24012678:	429a      	cmp	r2, r3
2401267a:	d908      	bls.n	2401268e <HAL_RCC_ClockConfig+0x12a>
    {
      /* Set the new HCLK clock divider */
      assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
      MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
2401267c:	4b4a      	ldr	r3, [pc, #296]	; (240127a8 <HAL_RCC_ClockConfig+0x244>)
2401267e:	699b      	ldr	r3, [r3, #24]
24012680:	f023 020f 	bic.w	r2, r3, #15
24012684:	687b      	ldr	r3, [r7, #4]
24012686:	68db      	ldr	r3, [r3, #12]
24012688:	4947      	ldr	r1, [pc, #284]	; (240127a8 <HAL_RCC_ClockConfig+0x244>)
2401268a:	4313      	orrs	r3, r2
2401268c:	618b      	str	r3, [r1, #24]
    }
#endif
  }

    /*------------------------- SYSCLK Configuration -------------------------*/
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
2401268e:	687b      	ldr	r3, [r7, #4]
24012690:	681b      	ldr	r3, [r3, #0]
24012692:	f003 0301 	and.w	r3, r3, #1
24012696:	2b00      	cmp	r3, #0
24012698:	d055      	beq.n	24012746 <HAL_RCC_ClockConfig+0x1e2>
    {
      assert_param(IS_RCC_SYSCLK(RCC_ClkInitStruct->SYSCLKDivider));
      assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));
#if defined(RCC_D1CFGR_D1CPRE)
      MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_D1CPRE, RCC_ClkInitStruct->SYSCLKDivider);
2401269a:	4b43      	ldr	r3, [pc, #268]	; (240127a8 <HAL_RCC_ClockConfig+0x244>)
2401269c:	699b      	ldr	r3, [r3, #24]
2401269e:	f423 6270 	bic.w	r2, r3, #3840	; 0xf00
240126a2:	687b      	ldr	r3, [r7, #4]
240126a4:	689b      	ldr	r3, [r3, #8]
240126a6:	4940      	ldr	r1, [pc, #256]	; (240127a8 <HAL_RCC_ClockConfig+0x244>)
240126a8:	4313      	orrs	r3, r2
240126aa:	618b      	str	r3, [r1, #24]
#else
      MODIFY_REG(RCC->CDCFGR1, RCC_CDCFGR1_CDCPRE, RCC_ClkInitStruct->SYSCLKDivider);
#endif
      /* HSE is selected as System Clock Source */
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
240126ac:	687b      	ldr	r3, [r7, #4]
240126ae:	685b      	ldr	r3, [r3, #4]
240126b0:	2b02      	cmp	r3, #2
240126b2:	d107      	bne.n	240126c4 <HAL_RCC_ClockConfig+0x160>
      {
        /* Check the HSE ready flag */
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
240126b4:	4b3c      	ldr	r3, [pc, #240]	; (240127a8 <HAL_RCC_ClockConfig+0x244>)
240126b6:	681b      	ldr	r3, [r3, #0]
240126b8:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
240126bc:	2b00      	cmp	r3, #0
240126be:	d121      	bne.n	24012704 <HAL_RCC_ClockConfig+0x1a0>
        {
          return HAL_ERROR;
240126c0:	2301      	movs	r3, #1
240126c2:	e0f6      	b.n	240128b2 <HAL_RCC_ClockConfig+0x34e>
        }
      }
      /* PLL is selected as System Clock Source */
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
240126c4:	687b      	ldr	r3, [r7, #4]
240126c6:	685b      	ldr	r3, [r3, #4]
240126c8:	2b03      	cmp	r3, #3
240126ca:	d107      	bne.n	240126dc <HAL_RCC_ClockConfig+0x178>
      {
        /* Check the PLL ready flag */
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == 0U)
240126cc:	4b36      	ldr	r3, [pc, #216]	; (240127a8 <HAL_RCC_ClockConfig+0x244>)
240126ce:	681b      	ldr	r3, [r3, #0]
240126d0:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
240126d4:	2b00      	cmp	r3, #0
240126d6:	d115      	bne.n	24012704 <HAL_RCC_ClockConfig+0x1a0>
        {
          return HAL_ERROR;
240126d8:	2301      	movs	r3, #1
240126da:	e0ea      	b.n	240128b2 <HAL_RCC_ClockConfig+0x34e>
        }
      }
      /* CSI is selected as System Clock Source */
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_CSI)
240126dc:	687b      	ldr	r3, [r7, #4]
240126de:	685b      	ldr	r3, [r3, #4]
240126e0:	2b01      	cmp	r3, #1
240126e2:	d107      	bne.n	240126f4 <HAL_RCC_ClockConfig+0x190>
      {
        /* Check the PLL ready flag */
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) == 0U)
240126e4:	4b30      	ldr	r3, [pc, #192]	; (240127a8 <HAL_RCC_ClockConfig+0x244>)
240126e6:	681b      	ldr	r3, [r3, #0]
240126e8:	f403 7380 	and.w	r3, r3, #256	; 0x100
240126ec:	2b00      	cmp	r3, #0
240126ee:	d109      	bne.n	24012704 <HAL_RCC_ClockConfig+0x1a0>
        {
          return HAL_ERROR;
240126f0:	2301      	movs	r3, #1
240126f2:	e0de      	b.n	240128b2 <HAL_RCC_ClockConfig+0x34e>
      }
      /* HSI is selected as System Clock Source */
      else
      {
        /* Check the HSI ready flag */
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
240126f4:	4b2c      	ldr	r3, [pc, #176]	; (240127a8 <HAL_RCC_ClockConfig+0x244>)
240126f6:	681b      	ldr	r3, [r3, #0]
240126f8:	f003 0304 	and.w	r3, r3, #4
240126fc:	2b00      	cmp	r3, #0
240126fe:	d101      	bne.n	24012704 <HAL_RCC_ClockConfig+0x1a0>
        {
          return HAL_ERROR;
24012700:	2301      	movs	r3, #1
24012702:	e0d6      	b.n	240128b2 <HAL_RCC_ClockConfig+0x34e>
        }
      }
      MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);
24012704:	4b28      	ldr	r3, [pc, #160]	; (240127a8 <HAL_RCC_ClockConfig+0x244>)
24012706:	691b      	ldr	r3, [r3, #16]
24012708:	f023 0207 	bic.w	r2, r3, #7
2401270c:	687b      	ldr	r3, [r7, #4]
2401270e:	685b      	ldr	r3, [r3, #4]
24012710:	4925      	ldr	r1, [pc, #148]	; (240127a8 <HAL_RCC_ClockConfig+0x244>)
24012712:	4313      	orrs	r3, r2
24012714:	610b      	str	r3, [r1, #16]

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
24012716:	f7ee f89b 	bl	24000850 <HAL_GetTick>
2401271a:	6178      	str	r0, [r7, #20]

        while (__HAL_RCC_GET_SYSCLK_SOURCE() !=  (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
2401271c:	e00a      	b.n	24012734 <HAL_RCC_ClockConfig+0x1d0>
        {
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
2401271e:	f7ee f897 	bl	24000850 <HAL_GetTick>
24012722:	4602      	mov	r2, r0
24012724:	697b      	ldr	r3, [r7, #20]
24012726:	1ad3      	subs	r3, r2, r3
24012728:	f241 3288 	movw	r2, #5000	; 0x1388
2401272c:	4293      	cmp	r3, r2
2401272e:	d901      	bls.n	24012734 <HAL_RCC_ClockConfig+0x1d0>
          {
            return HAL_TIMEOUT;
24012730:	2303      	movs	r3, #3
24012732:	e0be      	b.n	240128b2 <HAL_RCC_ClockConfig+0x34e>
        while (__HAL_RCC_GET_SYSCLK_SOURCE() !=  (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
24012734:	4b1c      	ldr	r3, [pc, #112]	; (240127a8 <HAL_RCC_ClockConfig+0x244>)
24012736:	691b      	ldr	r3, [r3, #16]
24012738:	f003 0238 	and.w	r2, r3, #56	; 0x38
2401273c:	687b      	ldr	r3, [r7, #4]
2401273e:	685b      	ldr	r3, [r3, #4]
24012740:	00db      	lsls	r3, r3, #3
24012742:	429a      	cmp	r2, r3
24012744:	d1eb      	bne.n	2401271e <HAL_RCC_ClockConfig+0x1ba>

    }

    /* Decreasing the BUS frequency divider */
   /*-------------------------- HCLK Configuration --------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
24012746:	687b      	ldr	r3, [r7, #4]
24012748:	681b      	ldr	r3, [r3, #0]
2401274a:	f003 0302 	and.w	r3, r3, #2
2401274e:	2b00      	cmp	r3, #0
24012750:	d010      	beq.n	24012774 <HAL_RCC_ClockConfig+0x210>
  {
#if defined(RCC_D1CFGR_HPRE)
    if((RCC_ClkInitStruct->AHBCLKDivider) < (RCC->D1CFGR & RCC_D1CFGR_HPRE))
24012752:	687b      	ldr	r3, [r7, #4]
24012754:	68da      	ldr	r2, [r3, #12]
24012756:	4b14      	ldr	r3, [pc, #80]	; (240127a8 <HAL_RCC_ClockConfig+0x244>)
24012758:	699b      	ldr	r3, [r3, #24]
2401275a:	f003 030f 	and.w	r3, r3, #15
2401275e:	429a      	cmp	r2, r3
24012760:	d208      	bcs.n	24012774 <HAL_RCC_ClockConfig+0x210>
    {
      /* Set the new HCLK clock divider */
      assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
      MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
24012762:	4b11      	ldr	r3, [pc, #68]	; (240127a8 <HAL_RCC_ClockConfig+0x244>)
24012764:	699b      	ldr	r3, [r3, #24]
24012766:	f023 020f 	bic.w	r2, r3, #15
2401276a:	687b      	ldr	r3, [r7, #4]
2401276c:	68db      	ldr	r3, [r3, #12]
2401276e:	490e      	ldr	r1, [pc, #56]	; (240127a8 <HAL_RCC_ClockConfig+0x244>)
24012770:	4313      	orrs	r3, r2
24012772:	618b      	str	r3, [r1, #24]
    }
#endif
  }

  /* Decreasing the number of wait states because of lower CPU frequency */
  if(FLatency < __HAL_FLASH_GET_LATENCY())
24012774:	4b0b      	ldr	r3, [pc, #44]	; (240127a4 <HAL_RCC_ClockConfig+0x240>)
24012776:	681b      	ldr	r3, [r3, #0]
24012778:	f003 030f 	and.w	r3, r3, #15
2401277c:	683a      	ldr	r2, [r7, #0]
2401277e:	429a      	cmp	r2, r3
24012780:	d214      	bcs.n	240127ac <HAL_RCC_ClockConfig+0x248>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
24012782:	4b08      	ldr	r3, [pc, #32]	; (240127a4 <HAL_RCC_ClockConfig+0x240>)
24012784:	681b      	ldr	r3, [r3, #0]
24012786:	f023 020f 	bic.w	r2, r3, #15
2401278a:	4906      	ldr	r1, [pc, #24]	; (240127a4 <HAL_RCC_ClockConfig+0x240>)
2401278c:	683b      	ldr	r3, [r7, #0]
2401278e:	4313      	orrs	r3, r2
24012790:	600b      	str	r3, [r1, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
24012792:	4b04      	ldr	r3, [pc, #16]	; (240127a4 <HAL_RCC_ClockConfig+0x240>)
24012794:	681b      	ldr	r3, [r3, #0]
24012796:	f003 030f 	and.w	r3, r3, #15
2401279a:	683a      	ldr	r2, [r7, #0]
2401279c:	429a      	cmp	r2, r3
2401279e:	d005      	beq.n	240127ac <HAL_RCC_ClockConfig+0x248>
    {
      return HAL_ERROR;
240127a0:	2301      	movs	r3, #1
240127a2:	e086      	b.n	240128b2 <HAL_RCC_ClockConfig+0x34e>
240127a4:	52002000 	.word	0x52002000
240127a8:	58024400 	.word	0x58024400
    }
 }

  /*-------------------------- D1PCLK1/CDPCLK Configuration ---------------------------*/
 if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_D1PCLK1) == RCC_CLOCKTYPE_D1PCLK1)
240127ac:	687b      	ldr	r3, [r7, #4]
240127ae:	681b      	ldr	r3, [r3, #0]
240127b0:	f003 0304 	and.w	r3, r3, #4
240127b4:	2b00      	cmp	r3, #0
240127b6:	d010      	beq.n	240127da <HAL_RCC_ClockConfig+0x276>
 {
#if defined(RCC_D1CFGR_D1PPRE)
   if((RCC_ClkInitStruct->APB3CLKDivider) < (RCC->D1CFGR & RCC_D1CFGR_D1PPRE))
240127b8:	687b      	ldr	r3, [r7, #4]
240127ba:	691a      	ldr	r2, [r3, #16]
240127bc:	4b3f      	ldr	r3, [pc, #252]	; (240128bc <HAL_RCC_ClockConfig+0x358>)
240127be:	699b      	ldr	r3, [r3, #24]
240127c0:	f003 0370 	and.w	r3, r3, #112	; 0x70
240127c4:	429a      	cmp	r2, r3
240127c6:	d208      	bcs.n	240127da <HAL_RCC_ClockConfig+0x276>
   {
     assert_param(IS_RCC_D1PCLK1(RCC_ClkInitStruct->APB3CLKDivider));
     MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_D1PPRE, RCC_ClkInitStruct->APB3CLKDivider);
240127c8:	4b3c      	ldr	r3, [pc, #240]	; (240128bc <HAL_RCC_ClockConfig+0x358>)
240127ca:	699b      	ldr	r3, [r3, #24]
240127cc:	f023 0270 	bic.w	r2, r3, #112	; 0x70
240127d0:	687b      	ldr	r3, [r7, #4]
240127d2:	691b      	ldr	r3, [r3, #16]
240127d4:	4939      	ldr	r1, [pc, #228]	; (240128bc <HAL_RCC_ClockConfig+0x358>)
240127d6:	4313      	orrs	r3, r2
240127d8:	618b      	str	r3, [r1, #24]
   }
#endif
 }

  /*-------------------------- PCLK1 Configuration ---------------------------*/
 if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
240127da:	687b      	ldr	r3, [r7, #4]
240127dc:	681b      	ldr	r3, [r3, #0]
240127de:	f003 0308 	and.w	r3, r3, #8
240127e2:	2b00      	cmp	r3, #0
240127e4:	d010      	beq.n	24012808 <HAL_RCC_ClockConfig+0x2a4>
 {
#if defined(RCC_D2CFGR_D2PPRE1)
   if((RCC_ClkInitStruct->APB1CLKDivider) < (RCC->D2CFGR & RCC_D2CFGR_D2PPRE1))
240127e6:	687b      	ldr	r3, [r7, #4]
240127e8:	695a      	ldr	r2, [r3, #20]
240127ea:	4b34      	ldr	r3, [pc, #208]	; (240128bc <HAL_RCC_ClockConfig+0x358>)
240127ec:	69db      	ldr	r3, [r3, #28]
240127ee:	f003 0370 	and.w	r3, r3, #112	; 0x70
240127f2:	429a      	cmp	r2, r3
240127f4:	d208      	bcs.n	24012808 <HAL_RCC_ClockConfig+0x2a4>
   {
     assert_param(IS_RCC_PCLK1(RCC_ClkInitStruct->APB1CLKDivider));
     MODIFY_REG(RCC->D2CFGR, RCC_D2CFGR_D2PPRE1, (RCC_ClkInitStruct->APB1CLKDivider));
240127f6:	4b31      	ldr	r3, [pc, #196]	; (240128bc <HAL_RCC_ClockConfig+0x358>)
240127f8:	69db      	ldr	r3, [r3, #28]
240127fa:	f023 0270 	bic.w	r2, r3, #112	; 0x70
240127fe:	687b      	ldr	r3, [r7, #4]
24012800:	695b      	ldr	r3, [r3, #20]
24012802:	492e      	ldr	r1, [pc, #184]	; (240128bc <HAL_RCC_ClockConfig+0x358>)
24012804:	4313      	orrs	r3, r2
24012806:	61cb      	str	r3, [r1, #28]
   }
#endif
 }

  /*-------------------------- PCLK2 Configuration ---------------------------*/
 if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
24012808:	687b      	ldr	r3, [r7, #4]
2401280a:	681b      	ldr	r3, [r3, #0]
2401280c:	f003 0310 	and.w	r3, r3, #16
24012810:	2b00      	cmp	r3, #0
24012812:	d010      	beq.n	24012836 <HAL_RCC_ClockConfig+0x2d2>
 {
#if defined (RCC_D2CFGR_D2PPRE2)
   if((RCC_ClkInitStruct->APB2CLKDivider) < (RCC->D2CFGR & RCC_D2CFGR_D2PPRE2))
24012814:	687b      	ldr	r3, [r7, #4]
24012816:	699a      	ldr	r2, [r3, #24]
24012818:	4b28      	ldr	r3, [pc, #160]	; (240128bc <HAL_RCC_ClockConfig+0x358>)
2401281a:	69db      	ldr	r3, [r3, #28]
2401281c:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
24012820:	429a      	cmp	r2, r3
24012822:	d208      	bcs.n	24012836 <HAL_RCC_ClockConfig+0x2d2>
   {
     assert_param(IS_RCC_PCLK2(RCC_ClkInitStruct->APB2CLKDivider));
     MODIFY_REG(RCC->D2CFGR, RCC_D2CFGR_D2PPRE2, (RCC_ClkInitStruct->APB2CLKDivider));
24012824:	4b25      	ldr	r3, [pc, #148]	; (240128bc <HAL_RCC_ClockConfig+0x358>)
24012826:	69db      	ldr	r3, [r3, #28]
24012828:	f423 62e0 	bic.w	r2, r3, #1792	; 0x700
2401282c:	687b      	ldr	r3, [r7, #4]
2401282e:	699b      	ldr	r3, [r3, #24]
24012830:	4922      	ldr	r1, [pc, #136]	; (240128bc <HAL_RCC_ClockConfig+0x358>)
24012832:	4313      	orrs	r3, r2
24012834:	61cb      	str	r3, [r1, #28]
   }
#endif
 }

  /*-------------------------- D3PCLK1/SRDPCLK1 Configuration ---------------------------*/
 if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_D3PCLK1) == RCC_CLOCKTYPE_D3PCLK1)
24012836:	687b      	ldr	r3, [r7, #4]
24012838:	681b      	ldr	r3, [r3, #0]
2401283a:	f003 0320 	and.w	r3, r3, #32
2401283e:	2b00      	cmp	r3, #0
24012840:	d010      	beq.n	24012864 <HAL_RCC_ClockConfig+0x300>
 {
#if defined(RCC_D3CFGR_D3PPRE)
   if((RCC_ClkInitStruct->APB4CLKDivider) < (RCC->D3CFGR & RCC_D3CFGR_D3PPRE))
24012842:	687b      	ldr	r3, [r7, #4]
24012844:	69da      	ldr	r2, [r3, #28]
24012846:	4b1d      	ldr	r3, [pc, #116]	; (240128bc <HAL_RCC_ClockConfig+0x358>)
24012848:	6a1b      	ldr	r3, [r3, #32]
2401284a:	f003 0370 	and.w	r3, r3, #112	; 0x70
2401284e:	429a      	cmp	r2, r3
24012850:	d208      	bcs.n	24012864 <HAL_RCC_ClockConfig+0x300>
   {
     assert_param(IS_RCC_D3PCLK1(RCC_ClkInitStruct->APB4CLKDivider));
     MODIFY_REG(RCC->D3CFGR, RCC_D3CFGR_D3PPRE, (RCC_ClkInitStruct->APB4CLKDivider) );
24012852:	4b1a      	ldr	r3, [pc, #104]	; (240128bc <HAL_RCC_ClockConfig+0x358>)
24012854:	6a1b      	ldr	r3, [r3, #32]
24012856:	f023 0270 	bic.w	r2, r3, #112	; 0x70
2401285a:	687b      	ldr	r3, [r7, #4]
2401285c:	69db      	ldr	r3, [r3, #28]
2401285e:	4917      	ldr	r1, [pc, #92]	; (240128bc <HAL_RCC_ClockConfig+0x358>)
24012860:	4313      	orrs	r3, r2
24012862:	620b      	str	r3, [r1, #32]
#endif
 }

  /* Update the SystemCoreClock global variable */
#if defined(RCC_D1CFGR_D1CPRE)
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
24012864:	f000 f8be 	bl	240129e4 <HAL_RCC_GetSysClockFreq>
24012868:	4601      	mov	r1, r0
2401286a:	4b14      	ldr	r3, [pc, #80]	; (240128bc <HAL_RCC_ClockConfig+0x358>)
2401286c:	699b      	ldr	r3, [r3, #24]
2401286e:	0a1b      	lsrs	r3, r3, #8
24012870:	f003 030f 	and.w	r3, r3, #15
24012874:	4a12      	ldr	r2, [pc, #72]	; (240128c0 <HAL_RCC_ClockConfig+0x35c>)
24012876:	5cd3      	ldrb	r3, [r2, r3]
24012878:	f003 031f 	and.w	r3, r3, #31
2401287c:	fa21 f303 	lsr.w	r3, r1, r3
24012880:	613b      	str	r3, [r7, #16]
#else
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->CDCFGR1 & RCC_CDCFGR1_CDCPRE)>> RCC_CDCFGR1_CDCPRE_Pos]) & 0x1FU);
#endif

#if defined(RCC_D1CFGR_HPRE)
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
24012882:	4b0e      	ldr	r3, [pc, #56]	; (240128bc <HAL_RCC_ClockConfig+0x358>)
24012884:	699b      	ldr	r3, [r3, #24]
24012886:	f003 030f 	and.w	r3, r3, #15
2401288a:	4a0d      	ldr	r2, [pc, #52]	; (240128c0 <HAL_RCC_ClockConfig+0x35c>)
2401288c:	5cd3      	ldrb	r3, [r2, r3]
2401288e:	f003 031f 	and.w	r3, r3, #31
24012892:	693a      	ldr	r2, [r7, #16]
24012894:	fa22 f303 	lsr.w	r3, r2, r3
24012898:	4a0a      	ldr	r2, [pc, #40]	; (240128c4 <HAL_RCC_ClockConfig+0x360>)
2401289a:	6013      	str	r3, [r2, #0]
#endif

#if defined(DUAL_CORE) && defined(CORE_CM4)
  SystemCoreClock = SystemD2Clock;
#else
  SystemCoreClock = common_system_clock;
2401289c:	4a0a      	ldr	r2, [pc, #40]	; (240128c8 <HAL_RCC_ClockConfig+0x364>)
2401289e:	693b      	ldr	r3, [r7, #16]
240128a0:	6013      	str	r3, [r2, #0]
#endif /* DUAL_CORE && CORE_CM4 */

  /* Configure the source of time base considering new system clocks settings*/
  halstatus = HAL_InitTick (uwTickPrio);
240128a2:	4b0a      	ldr	r3, [pc, #40]	; (240128cc <HAL_RCC_ClockConfig+0x368>)
240128a4:	681b      	ldr	r3, [r3, #0]
240128a6:	4618      	mov	r0, r3
240128a8:	f7ed ff88 	bl	240007bc <HAL_InitTick>
240128ac:	4603      	mov	r3, r0
240128ae:	73fb      	strb	r3, [r7, #15]

  return halstatus;
240128b0:	7bfb      	ldrb	r3, [r7, #15]
}
240128b2:	4618      	mov	r0, r3
240128b4:	3718      	adds	r7, #24
240128b6:	46bd      	mov	sp, r7
240128b8:	bd80      	pop	{r7, pc}
240128ba:	bf00      	nop
240128bc:	58024400 	.word	0x58024400
240128c0:	24016db8 	.word	0x24016db8
240128c4:	240004bc 	.word	0x240004bc
240128c8:	240004b8 	.word	0x240004b8
240128cc:	240004ac 	.word	0x240004ac

240128d0 <HAL_RCC_MCOConfig>:
  *          This parameter can be one of the following values:
  *            @arg RCC_MCODIV_1 up to RCC_MCODIV_15  : divider applied to MCOx clock
  * @retval None
  */
void HAL_RCC_MCOConfig(uint32_t RCC_MCOx, uint32_t RCC_MCOSource, uint32_t RCC_MCODiv)
{
240128d0:	b580      	push	{r7, lr}
240128d2:	b08c      	sub	sp, #48	; 0x30
240128d4:	af00      	add	r7, sp, #0
240128d6:	60f8      	str	r0, [r7, #12]
240128d8:	60b9      	str	r1, [r7, #8]
240128da:	607a      	str	r2, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStruct;
  /* Check the parameters */
  assert_param(IS_RCC_MCO(RCC_MCOx));
  assert_param(IS_RCC_MCODIV(RCC_MCODiv));
  /* RCC_MCO1 */
  if(RCC_MCOx == RCC_MCO1)
240128dc:	68fb      	ldr	r3, [r7, #12]
240128de:	2b00      	cmp	r3, #0
240128e0:	d12a      	bne.n	24012938 <HAL_RCC_MCOConfig+0x68>
  {
    assert_param(IS_RCC_MCO1SOURCE(RCC_MCOSource));

    /* MCO1 Clock Enable */
    MCO1_CLK_ENABLE();
240128e2:	4b2d      	ldr	r3, [pc, #180]	; (24012998 <HAL_RCC_MCOConfig+0xc8>)
240128e4:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
240128e8:	4a2b      	ldr	r2, [pc, #172]	; (24012998 <HAL_RCC_MCOConfig+0xc8>)
240128ea:	f043 0301 	orr.w	r3, r3, #1
240128ee:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
240128f2:	4b29      	ldr	r3, [pc, #164]	; (24012998 <HAL_RCC_MCOConfig+0xc8>)
240128f4:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
240128f8:	f003 0301 	and.w	r3, r3, #1
240128fc:	61bb      	str	r3, [r7, #24]
240128fe:	69bb      	ldr	r3, [r7, #24]

    /* Configure the MCO1 pin in alternate function mode */
    GPIO_InitStruct.Pin = MCO1_PIN;
24012900:	f44f 7380 	mov.w	r3, #256	; 0x100
24012904:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
24012906:	2302      	movs	r3, #2
24012908:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
2401290a:	2303      	movs	r3, #3
2401290c:	62bb      	str	r3, [r7, #40]	; 0x28
    GPIO_InitStruct.Pull = GPIO_NOPULL;
2401290e:	2300      	movs	r3, #0
24012910:	627b      	str	r3, [r7, #36]	; 0x24
    GPIO_InitStruct.Alternate = GPIO_AF0_MCO;
24012912:	2300      	movs	r3, #0
24012914:	62fb      	str	r3, [r7, #44]	; 0x2c
    HAL_GPIO_Init(MCO1_GPIO_PORT, &GPIO_InitStruct);
24012916:	f107 031c 	add.w	r3, r7, #28
2401291a:	4619      	mov	r1, r3
2401291c:	481f      	ldr	r0, [pc, #124]	; (2401299c <HAL_RCC_MCOConfig+0xcc>)
2401291e:	f7f5 fe33 	bl	24008588 <HAL_GPIO_Init>

    /* Mask MCO1 and MCO1PRE[3:0] bits then Select MCO1 clock source and pre-scaler */
    MODIFY_REG(RCC->CFGR, (RCC_CFGR_MCO1 | RCC_CFGR_MCO1PRE), (RCC_MCOSource | RCC_MCODiv));
24012922:	4b1d      	ldr	r3, [pc, #116]	; (24012998 <HAL_RCC_MCOConfig+0xc8>)
24012924:	691b      	ldr	r3, [r3, #16]
24012926:	f023 72fe 	bic.w	r2, r3, #33292288	; 0x1fc0000
2401292a:	68b9      	ldr	r1, [r7, #8]
2401292c:	687b      	ldr	r3, [r7, #4]
2401292e:	430b      	orrs	r3, r1
24012930:	4919      	ldr	r1, [pc, #100]	; (24012998 <HAL_RCC_MCOConfig+0xc8>)
24012932:	4313      	orrs	r3, r2
24012934:	610b      	str	r3, [r1, #16]
    HAL_GPIO_Init(MCO2_GPIO_PORT, &GPIO_InitStruct);

    /* Mask MCO2 and MCO2PRE[3:0] bits then Select MCO2 clock source and pre-scaler */
    MODIFY_REG(RCC->CFGR, (RCC_CFGR_MCO2 | RCC_CFGR_MCO2PRE), (RCC_MCOSource | (RCC_MCODiv << 7U)));
  }
}
24012936:	e02a      	b.n	2401298e <HAL_RCC_MCOConfig+0xbe>
    MCO2_CLK_ENABLE();
24012938:	4b17      	ldr	r3, [pc, #92]	; (24012998 <HAL_RCC_MCOConfig+0xc8>)
2401293a:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
2401293e:	4a16      	ldr	r2, [pc, #88]	; (24012998 <HAL_RCC_MCOConfig+0xc8>)
24012940:	f043 0304 	orr.w	r3, r3, #4
24012944:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
24012948:	4b13      	ldr	r3, [pc, #76]	; (24012998 <HAL_RCC_MCOConfig+0xc8>)
2401294a:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
2401294e:	f003 0304 	and.w	r3, r3, #4
24012952:	617b      	str	r3, [r7, #20]
24012954:	697b      	ldr	r3, [r7, #20]
    GPIO_InitStruct.Pin = MCO2_PIN;
24012956:	f44f 7300 	mov.w	r3, #512	; 0x200
2401295a:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
2401295c:	2302      	movs	r3, #2
2401295e:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
24012960:	2303      	movs	r3, #3
24012962:	62bb      	str	r3, [r7, #40]	; 0x28
    GPIO_InitStruct.Pull = GPIO_NOPULL;
24012964:	2300      	movs	r3, #0
24012966:	627b      	str	r3, [r7, #36]	; 0x24
    GPIO_InitStruct.Alternate = GPIO_AF0_MCO;
24012968:	2300      	movs	r3, #0
2401296a:	62fb      	str	r3, [r7, #44]	; 0x2c
    HAL_GPIO_Init(MCO2_GPIO_PORT, &GPIO_InitStruct);
2401296c:	f107 031c 	add.w	r3, r7, #28
24012970:	4619      	mov	r1, r3
24012972:	480b      	ldr	r0, [pc, #44]	; (240129a0 <HAL_RCC_MCOConfig+0xd0>)
24012974:	f7f5 fe08 	bl	24008588 <HAL_GPIO_Init>
    MODIFY_REG(RCC->CFGR, (RCC_CFGR_MCO2 | RCC_CFGR_MCO2PRE), (RCC_MCOSource | (RCC_MCODiv << 7U)));
24012978:	4b07      	ldr	r3, [pc, #28]	; (24012998 <HAL_RCC_MCOConfig+0xc8>)
2401297a:	691b      	ldr	r3, [r3, #16]
2401297c:	f023 427e 	bic.w	r2, r3, #4261412864	; 0xfe000000
24012980:	687b      	ldr	r3, [r7, #4]
24012982:	01d9      	lsls	r1, r3, #7
24012984:	68bb      	ldr	r3, [r7, #8]
24012986:	430b      	orrs	r3, r1
24012988:	4903      	ldr	r1, [pc, #12]	; (24012998 <HAL_RCC_MCOConfig+0xc8>)
2401298a:	4313      	orrs	r3, r2
2401298c:	610b      	str	r3, [r1, #16]
}
2401298e:	bf00      	nop
24012990:	3730      	adds	r7, #48	; 0x30
24012992:	46bd      	mov	sp, r7
24012994:	bd80      	pop	{r7, pc}
24012996:	bf00      	nop
24012998:	58024400 	.word	0x58024400
2401299c:	58020000 	.word	0x58020000
240129a0:	58020800 	.word	0x58020800

240129a4 <HAL_RCC_EnableCSS>:
  *         allowing the MCU to perform rescue operations. The CSSI is linked to
  *         the Cortex-M NMI (Non-Mask-able Interrupt) exception vector.
  * @retval None
  */
void HAL_RCC_EnableCSS(void)
{
240129a4:	b480      	push	{r7}
240129a6:	af00      	add	r7, sp, #0
  SET_BIT(RCC->CR, RCC_CR_CSSHSEON) ;
240129a8:	4b05      	ldr	r3, [pc, #20]	; (240129c0 <HAL_RCC_EnableCSS+0x1c>)
240129aa:	681b      	ldr	r3, [r3, #0]
240129ac:	4a04      	ldr	r2, [pc, #16]	; (240129c0 <HAL_RCC_EnableCSS+0x1c>)
240129ae:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
240129b2:	6013      	str	r3, [r2, #0]
}
240129b4:	bf00      	nop
240129b6:	46bd      	mov	sp, r7
240129b8:	f85d 7b04 	ldr.w	r7, [sp], #4
240129bc:	4770      	bx	lr
240129be:	bf00      	nop
240129c0:	58024400 	.word	0x58024400

240129c4 <HAL_RCC_DisableCSS>:
/**
  * @brief  Disables the Clock Security System.
  * @retval None
  */
void HAL_RCC_DisableCSS(void)
{
240129c4:	b480      	push	{r7}
240129c6:	af00      	add	r7, sp, #0
  CLEAR_BIT(RCC->CR, RCC_CR_CSSHSEON);
240129c8:	4b05      	ldr	r3, [pc, #20]	; (240129e0 <HAL_RCC_DisableCSS+0x1c>)
240129ca:	681b      	ldr	r3, [r3, #0]
240129cc:	4a04      	ldr	r2, [pc, #16]	; (240129e0 <HAL_RCC_DisableCSS+0x1c>)
240129ce:	f423 2300 	bic.w	r3, r3, #524288	; 0x80000
240129d2:	6013      	str	r3, [r2, #0]
}
240129d4:	bf00      	nop
240129d6:	46bd      	mov	sp, r7
240129d8:	f85d 7b04 	ldr.w	r7, [sp], #4
240129dc:	4770      	bx	lr
240129de:	bf00      	nop
240129e0:	58024400 	.word	0x58024400

240129e4 <HAL_RCC_GetSysClockFreq>:
  *
  *
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
240129e4:	b480      	push	{r7}
240129e6:	b089      	sub	sp, #36	; 0x24
240129e8:	af00      	add	r7, sp, #0
  float_t fracn1, pllvco;
  uint32_t sysclockfreq;

  /* Get SYSCLK source -------------------------------------------------------*/

  switch (RCC->CFGR & RCC_CFGR_SWS)
240129ea:	4baf      	ldr	r3, [pc, #700]	; (24012ca8 <HAL_RCC_GetSysClockFreq+0x2c4>)
240129ec:	691b      	ldr	r3, [r3, #16]
240129ee:	f003 0338 	and.w	r3, r3, #56	; 0x38
240129f2:	2b18      	cmp	r3, #24
240129f4:	f200 814e 	bhi.w	24012c94 <HAL_RCC_GetSysClockFreq+0x2b0>
240129f8:	a201      	add	r2, pc, #4	; (adr r2, 24012a00 <HAL_RCC_GetSysClockFreq+0x1c>)
240129fa:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
240129fe:	bf00      	nop
24012a00:	24012a65 	.word	0x24012a65
24012a04:	24012c95 	.word	0x24012c95
24012a08:	24012c95 	.word	0x24012c95
24012a0c:	24012c95 	.word	0x24012c95
24012a10:	24012c95 	.word	0x24012c95
24012a14:	24012c95 	.word	0x24012c95
24012a18:	24012c95 	.word	0x24012c95
24012a1c:	24012c95 	.word	0x24012c95
24012a20:	24012a8b 	.word	0x24012a8b
24012a24:	24012c95 	.word	0x24012c95
24012a28:	24012c95 	.word	0x24012c95
24012a2c:	24012c95 	.word	0x24012c95
24012a30:	24012c95 	.word	0x24012c95
24012a34:	24012c95 	.word	0x24012c95
24012a38:	24012c95 	.word	0x24012c95
24012a3c:	24012c95 	.word	0x24012c95
24012a40:	24012a91 	.word	0x24012a91
24012a44:	24012c95 	.word	0x24012c95
24012a48:	24012c95 	.word	0x24012c95
24012a4c:	24012c95 	.word	0x24012c95
24012a50:	24012c95 	.word	0x24012c95
24012a54:	24012c95 	.word	0x24012c95
24012a58:	24012c95 	.word	0x24012c95
24012a5c:	24012c95 	.word	0x24012c95
24012a60:	24012a97 	.word	0x24012a97
  {
  case RCC_CFGR_SWS_HSI:  /* HSI used as system clock source */

   if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
24012a64:	4b90      	ldr	r3, [pc, #576]	; (24012ca8 <HAL_RCC_GetSysClockFreq+0x2c4>)
24012a66:	681b      	ldr	r3, [r3, #0]
24012a68:	f003 0320 	and.w	r3, r3, #32
24012a6c:	2b00      	cmp	r3, #0
24012a6e:	d009      	beq.n	24012a84 <HAL_RCC_GetSysClockFreq+0xa0>
      {
        sysclockfreq = (uint32_t) (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
24012a70:	4b8d      	ldr	r3, [pc, #564]	; (24012ca8 <HAL_RCC_GetSysClockFreq+0x2c4>)
24012a72:	681b      	ldr	r3, [r3, #0]
24012a74:	08db      	lsrs	r3, r3, #3
24012a76:	f003 0303 	and.w	r3, r3, #3
24012a7a:	4a8c      	ldr	r2, [pc, #560]	; (24012cac <HAL_RCC_GetSysClockFreq+0x2c8>)
24012a7c:	fa22 f303 	lsr.w	r3, r2, r3
24012a80:	61bb      	str	r3, [r7, #24]
      else
      {
        sysclockfreq = (uint32_t) HSI_VALUE;
      }

    break;
24012a82:	e10a      	b.n	24012c9a <HAL_RCC_GetSysClockFreq+0x2b6>
        sysclockfreq = (uint32_t) HSI_VALUE;
24012a84:	4b89      	ldr	r3, [pc, #548]	; (24012cac <HAL_RCC_GetSysClockFreq+0x2c8>)
24012a86:	61bb      	str	r3, [r7, #24]
    break;
24012a88:	e107      	b.n	24012c9a <HAL_RCC_GetSysClockFreq+0x2b6>

  case RCC_CFGR_SWS_CSI:  /* CSI used as system clock  source */
    sysclockfreq = CSI_VALUE;
24012a8a:	4b89      	ldr	r3, [pc, #548]	; (24012cb0 <HAL_RCC_GetSysClockFreq+0x2cc>)
24012a8c:	61bb      	str	r3, [r7, #24]
    break;
24012a8e:	e104      	b.n	24012c9a <HAL_RCC_GetSysClockFreq+0x2b6>

  case RCC_CFGR_SWS_HSE:  /* HSE used as system clock  source */
    sysclockfreq = HSE_VALUE;
24012a90:	4b88      	ldr	r3, [pc, #544]	; (24012cb4 <HAL_RCC_GetSysClockFreq+0x2d0>)
24012a92:	61bb      	str	r3, [r7, #24]
    break;
24012a94:	e101      	b.n	24012c9a <HAL_RCC_GetSysClockFreq+0x2b6>
  case RCC_CFGR_SWS_PLL1:  /* PLL1 used as system clock  source */

    /* PLL_VCO = (HSE_VALUE or HSI_VALUE or CSI_VALUE/ PLLM) * PLLN
    SYSCLK = PLL_VCO / PLLR
    */
    pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
24012a96:	4b84      	ldr	r3, [pc, #528]	; (24012ca8 <HAL_RCC_GetSysClockFreq+0x2c4>)
24012a98:	6a9b      	ldr	r3, [r3, #40]	; 0x28
24012a9a:	f003 0303 	and.w	r3, r3, #3
24012a9e:	617b      	str	r3, [r7, #20]
    pllm = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM1)>> 4)  ;
24012aa0:	4b81      	ldr	r3, [pc, #516]	; (24012ca8 <HAL_RCC_GetSysClockFreq+0x2c4>)
24012aa2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
24012aa4:	091b      	lsrs	r3, r3, #4
24012aa6:	f003 033f 	and.w	r3, r3, #63	; 0x3f
24012aaa:	613b      	str	r3, [r7, #16]
    pllfracen = ((RCC-> PLLCFGR & RCC_PLLCFGR_PLL1FRACEN)>>RCC_PLLCFGR_PLL1FRACEN_Pos);
24012aac:	4b7e      	ldr	r3, [pc, #504]	; (24012ca8 <HAL_RCC_GetSysClockFreq+0x2c4>)
24012aae:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24012ab0:	f003 0301 	and.w	r3, r3, #1
24012ab4:	60fb      	str	r3, [r7, #12]
    fracn1 = (float_t)(uint32_t)(pllfracen* ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));
24012ab6:	4b7c      	ldr	r3, [pc, #496]	; (24012ca8 <HAL_RCC_GetSysClockFreq+0x2c4>)
24012ab8:	6b5b      	ldr	r3, [r3, #52]	; 0x34
24012aba:	08db      	lsrs	r3, r3, #3
24012abc:	f3c3 030c 	ubfx	r3, r3, #0, #13
24012ac0:	68fa      	ldr	r2, [r7, #12]
24012ac2:	fb02 f303 	mul.w	r3, r2, r3
24012ac6:	ee07 3a90 	vmov	s15, r3
24012aca:	eef8 7a67 	vcvt.f32.u32	s15, s15
24012ace:	edc7 7a02 	vstr	s15, [r7, #8]

    if (pllm != 0U)
24012ad2:	693b      	ldr	r3, [r7, #16]
24012ad4:	2b00      	cmp	r3, #0
24012ad6:	f000 80da 	beq.w	24012c8e <HAL_RCC_GetSysClockFreq+0x2aa>
    {
      switch (pllsource)
24012ada:	697b      	ldr	r3, [r7, #20]
24012adc:	2b01      	cmp	r3, #1
24012ade:	d05a      	beq.n	24012b96 <HAL_RCC_GetSysClockFreq+0x1b2>
24012ae0:	2b01      	cmp	r3, #1
24012ae2:	d302      	bcc.n	24012aea <HAL_RCC_GetSysClockFreq+0x106>
24012ae4:	2b02      	cmp	r3, #2
24012ae6:	d078      	beq.n	24012bda <HAL_RCC_GetSysClockFreq+0x1f6>
24012ae8:	e099      	b.n	24012c1e <HAL_RCC_GetSysClockFreq+0x23a>
      {
      case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */

       if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
24012aea:	4b6f      	ldr	r3, [pc, #444]	; (24012ca8 <HAL_RCC_GetSysClockFreq+0x2c4>)
24012aec:	681b      	ldr	r3, [r3, #0]
24012aee:	f003 0320 	and.w	r3, r3, #32
24012af2:	2b00      	cmp	r3, #0
24012af4:	d02d      	beq.n	24012b52 <HAL_RCC_GetSysClockFreq+0x16e>
        {
          hsivalue= (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
24012af6:	4b6c      	ldr	r3, [pc, #432]	; (24012ca8 <HAL_RCC_GetSysClockFreq+0x2c4>)
24012af8:	681b      	ldr	r3, [r3, #0]
24012afa:	08db      	lsrs	r3, r3, #3
24012afc:	f003 0303 	and.w	r3, r3, #3
24012b00:	4a6a      	ldr	r2, [pc, #424]	; (24012cac <HAL_RCC_GetSysClockFreq+0x2c8>)
24012b02:	fa22 f303 	lsr.w	r3, r2, r3
24012b06:	607b      	str	r3, [r7, #4]
          pllvco = ( (float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
24012b08:	687b      	ldr	r3, [r7, #4]
24012b0a:	ee07 3a90 	vmov	s15, r3
24012b0e:	eef8 6a67 	vcvt.f32.u32	s13, s15
24012b12:	693b      	ldr	r3, [r7, #16]
24012b14:	ee07 3a90 	vmov	s15, r3
24012b18:	eef8 7a67 	vcvt.f32.u32	s15, s15
24012b1c:	ee86 7aa7 	vdiv.f32	s14, s13, s15
24012b20:	4b61      	ldr	r3, [pc, #388]	; (24012ca8 <HAL_RCC_GetSysClockFreq+0x2c4>)
24012b22:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24012b24:	f3c3 0308 	ubfx	r3, r3, #0, #9
24012b28:	ee07 3a90 	vmov	s15, r3
24012b2c:	eef8 6a67 	vcvt.f32.u32	s13, s15
24012b30:	ed97 6a02 	vldr	s12, [r7, #8]
24012b34:	eddf 5a60 	vldr	s11, [pc, #384]	; 24012cb8 <HAL_RCC_GetSysClockFreq+0x2d4>
24012b38:	eec6 7a25 	vdiv.f32	s15, s12, s11
24012b3c:	ee76 7aa7 	vadd.f32	s15, s13, s15
24012b40:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
24012b44:	ee77 7aa6 	vadd.f32	s15, s15, s13
24012b48:	ee67 7a27 	vmul.f32	s15, s14, s15
24012b4c:	edc7 7a07 	vstr	s15, [r7, #28]
        }
        else
        {
          pllvco = ((float_t)HSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
        }
        break;
24012b50:	e087      	b.n	24012c62 <HAL_RCC_GetSysClockFreq+0x27e>
          pllvco = ((float_t)HSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
24012b52:	693b      	ldr	r3, [r7, #16]
24012b54:	ee07 3a90 	vmov	s15, r3
24012b58:	eef8 7a67 	vcvt.f32.u32	s15, s15
24012b5c:	eddf 6a57 	vldr	s13, [pc, #348]	; 24012cbc <HAL_RCC_GetSysClockFreq+0x2d8>
24012b60:	ee86 7aa7 	vdiv.f32	s14, s13, s15
24012b64:	4b50      	ldr	r3, [pc, #320]	; (24012ca8 <HAL_RCC_GetSysClockFreq+0x2c4>)
24012b66:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24012b68:	f3c3 0308 	ubfx	r3, r3, #0, #9
24012b6c:	ee07 3a90 	vmov	s15, r3
24012b70:	eef8 6a67 	vcvt.f32.u32	s13, s15
24012b74:	ed97 6a02 	vldr	s12, [r7, #8]
24012b78:	eddf 5a4f 	vldr	s11, [pc, #316]	; 24012cb8 <HAL_RCC_GetSysClockFreq+0x2d4>
24012b7c:	eec6 7a25 	vdiv.f32	s15, s12, s11
24012b80:	ee76 7aa7 	vadd.f32	s15, s13, s15
24012b84:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
24012b88:	ee77 7aa6 	vadd.f32	s15, s15, s13
24012b8c:	ee67 7a27 	vmul.f32	s15, s14, s15
24012b90:	edc7 7a07 	vstr	s15, [r7, #28]
        break;
24012b94:	e065      	b.n	24012c62 <HAL_RCC_GetSysClockFreq+0x27e>

      case RCC_PLLSOURCE_CSI:  /* CSI used as PLL clock source */
        pllvco = ((float_t)CSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
24012b96:	693b      	ldr	r3, [r7, #16]
24012b98:	ee07 3a90 	vmov	s15, r3
24012b9c:	eef8 7a67 	vcvt.f32.u32	s15, s15
24012ba0:	eddf 6a47 	vldr	s13, [pc, #284]	; 24012cc0 <HAL_RCC_GetSysClockFreq+0x2dc>
24012ba4:	ee86 7aa7 	vdiv.f32	s14, s13, s15
24012ba8:	4b3f      	ldr	r3, [pc, #252]	; (24012ca8 <HAL_RCC_GetSysClockFreq+0x2c4>)
24012baa:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24012bac:	f3c3 0308 	ubfx	r3, r3, #0, #9
24012bb0:	ee07 3a90 	vmov	s15, r3
24012bb4:	eef8 6a67 	vcvt.f32.u32	s13, s15
24012bb8:	ed97 6a02 	vldr	s12, [r7, #8]
24012bbc:	eddf 5a3e 	vldr	s11, [pc, #248]	; 24012cb8 <HAL_RCC_GetSysClockFreq+0x2d4>
24012bc0:	eec6 7a25 	vdiv.f32	s15, s12, s11
24012bc4:	ee76 7aa7 	vadd.f32	s15, s13, s15
24012bc8:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
24012bcc:	ee77 7aa6 	vadd.f32	s15, s15, s13
24012bd0:	ee67 7a27 	vmul.f32	s15, s14, s15
24012bd4:	edc7 7a07 	vstr	s15, [r7, #28]
        break;
24012bd8:	e043      	b.n	24012c62 <HAL_RCC_GetSysClockFreq+0x27e>

      case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
        pllvco = ((float_t)HSE_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
24012bda:	693b      	ldr	r3, [r7, #16]
24012bdc:	ee07 3a90 	vmov	s15, r3
24012be0:	eef8 7a67 	vcvt.f32.u32	s15, s15
24012be4:	eddf 6a37 	vldr	s13, [pc, #220]	; 24012cc4 <HAL_RCC_GetSysClockFreq+0x2e0>
24012be8:	ee86 7aa7 	vdiv.f32	s14, s13, s15
24012bec:	4b2e      	ldr	r3, [pc, #184]	; (24012ca8 <HAL_RCC_GetSysClockFreq+0x2c4>)
24012bee:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24012bf0:	f3c3 0308 	ubfx	r3, r3, #0, #9
24012bf4:	ee07 3a90 	vmov	s15, r3
24012bf8:	eef8 6a67 	vcvt.f32.u32	s13, s15
24012bfc:	ed97 6a02 	vldr	s12, [r7, #8]
24012c00:	eddf 5a2d 	vldr	s11, [pc, #180]	; 24012cb8 <HAL_RCC_GetSysClockFreq+0x2d4>
24012c04:	eec6 7a25 	vdiv.f32	s15, s12, s11
24012c08:	ee76 7aa7 	vadd.f32	s15, s13, s15
24012c0c:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
24012c10:	ee77 7aa6 	vadd.f32	s15, s15, s13
24012c14:	ee67 7a27 	vmul.f32	s15, s14, s15
24012c18:	edc7 7a07 	vstr	s15, [r7, #28]
        break;
24012c1c:	e021      	b.n	24012c62 <HAL_RCC_GetSysClockFreq+0x27e>

      default:
        pllvco = ((float_t)CSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
24012c1e:	693b      	ldr	r3, [r7, #16]
24012c20:	ee07 3a90 	vmov	s15, r3
24012c24:	eef8 7a67 	vcvt.f32.u32	s15, s15
24012c28:	eddf 6a25 	vldr	s13, [pc, #148]	; 24012cc0 <HAL_RCC_GetSysClockFreq+0x2dc>
24012c2c:	ee86 7aa7 	vdiv.f32	s14, s13, s15
24012c30:	4b1d      	ldr	r3, [pc, #116]	; (24012ca8 <HAL_RCC_GetSysClockFreq+0x2c4>)
24012c32:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24012c34:	f3c3 0308 	ubfx	r3, r3, #0, #9
24012c38:	ee07 3a90 	vmov	s15, r3
24012c3c:	eef8 6a67 	vcvt.f32.u32	s13, s15
24012c40:	ed97 6a02 	vldr	s12, [r7, #8]
24012c44:	eddf 5a1c 	vldr	s11, [pc, #112]	; 24012cb8 <HAL_RCC_GetSysClockFreq+0x2d4>
24012c48:	eec6 7a25 	vdiv.f32	s15, s12, s11
24012c4c:	ee76 7aa7 	vadd.f32	s15, s13, s15
24012c50:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
24012c54:	ee77 7aa6 	vadd.f32	s15, s15, s13
24012c58:	ee67 7a27 	vmul.f32	s15, s14, s15
24012c5c:	edc7 7a07 	vstr	s15, [r7, #28]
        break;
24012c60:	bf00      	nop
      }
      pllp = (((RCC->PLL1DIVR & RCC_PLL1DIVR_P1) >>9) + 1U ) ;
24012c62:	4b11      	ldr	r3, [pc, #68]	; (24012ca8 <HAL_RCC_GetSysClockFreq+0x2c4>)
24012c64:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24012c66:	0a5b      	lsrs	r3, r3, #9
24012c68:	f003 037f 	and.w	r3, r3, #127	; 0x7f
24012c6c:	3301      	adds	r3, #1
24012c6e:	603b      	str	r3, [r7, #0]
      sysclockfreq =  (uint32_t)(float_t)(pllvco/(float_t)pllp);
24012c70:	683b      	ldr	r3, [r7, #0]
24012c72:	ee07 3a90 	vmov	s15, r3
24012c76:	eeb8 7a67 	vcvt.f32.u32	s14, s15
24012c7a:	edd7 6a07 	vldr	s13, [r7, #28]
24012c7e:	eec6 7a87 	vdiv.f32	s15, s13, s14
24012c82:	eefc 7ae7 	vcvt.u32.f32	s15, s15
24012c86:	ee17 3a90 	vmov	r3, s15
24012c8a:	61bb      	str	r3, [r7, #24]
    }
    else
    {
      sysclockfreq = 0U;
    }
    break;
24012c8c:	e005      	b.n	24012c9a <HAL_RCC_GetSysClockFreq+0x2b6>
      sysclockfreq = 0U;
24012c8e:	2300      	movs	r3, #0
24012c90:	61bb      	str	r3, [r7, #24]
    break;
24012c92:	e002      	b.n	24012c9a <HAL_RCC_GetSysClockFreq+0x2b6>

  default:
    sysclockfreq = CSI_VALUE;
24012c94:	4b06      	ldr	r3, [pc, #24]	; (24012cb0 <HAL_RCC_GetSysClockFreq+0x2cc>)
24012c96:	61bb      	str	r3, [r7, #24]
    break;
24012c98:	bf00      	nop
  }

  return sysclockfreq;
24012c9a:	69bb      	ldr	r3, [r7, #24]
}
24012c9c:	4618      	mov	r0, r3
24012c9e:	3724      	adds	r7, #36	; 0x24
24012ca0:	46bd      	mov	sp, r7
24012ca2:	f85d 7b04 	ldr.w	r7, [sp], #4
24012ca6:	4770      	bx	lr
24012ca8:	58024400 	.word	0x58024400
24012cac:	03d09000 	.word	0x03d09000
24012cb0:	003d0900 	.word	0x003d0900
24012cb4:	017d7840 	.word	0x017d7840
24012cb8:	46000000 	.word	0x46000000
24012cbc:	4c742400 	.word	0x4c742400
24012cc0:	4a742400 	.word	0x4a742400
24012cc4:	4bbebc20 	.word	0x4bbebc20

24012cc8 <HAL_RCC_GetHCLKFreq>:
  * @note   The SystemD2Clock CMSIS variable is used to store System domain2 Clock Frequency
  *         and updated within this function
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
24012cc8:	b580      	push	{r7, lr}
24012cca:	b082      	sub	sp, #8
24012ccc:	af00      	add	r7, sp, #0
uint32_t common_system_clock;

#if defined(RCC_D1CFGR_D1CPRE)
  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos] & 0x1FU);
24012cce:	f7ff fe89 	bl	240129e4 <HAL_RCC_GetSysClockFreq>
24012cd2:	4601      	mov	r1, r0
24012cd4:	4b10      	ldr	r3, [pc, #64]	; (24012d18 <HAL_RCC_GetHCLKFreq+0x50>)
24012cd6:	699b      	ldr	r3, [r3, #24]
24012cd8:	0a1b      	lsrs	r3, r3, #8
24012cda:	f003 030f 	and.w	r3, r3, #15
24012cde:	4a0f      	ldr	r2, [pc, #60]	; (24012d1c <HAL_RCC_GetHCLKFreq+0x54>)
24012ce0:	5cd3      	ldrb	r3, [r2, r3]
24012ce2:	f003 031f 	and.w	r3, r3, #31
24012ce6:	fa21 f303 	lsr.w	r3, r1, r3
24012cea:	607b      	str	r3, [r7, #4]
#else
  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->CDCFGR1 & RCC_CDCFGR1_CDCPRE)>> RCC_CDCFGR1_CDCPRE_Pos] & 0x1FU);
#endif

#if defined(RCC_D1CFGR_HPRE)
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
24012cec:	4b0a      	ldr	r3, [pc, #40]	; (24012d18 <HAL_RCC_GetHCLKFreq+0x50>)
24012cee:	699b      	ldr	r3, [r3, #24]
24012cf0:	f003 030f 	and.w	r3, r3, #15
24012cf4:	4a09      	ldr	r2, [pc, #36]	; (24012d1c <HAL_RCC_GetHCLKFreq+0x54>)
24012cf6:	5cd3      	ldrb	r3, [r2, r3]
24012cf8:	f003 031f 	and.w	r3, r3, #31
24012cfc:	687a      	ldr	r2, [r7, #4]
24012cfe:	fa22 f303 	lsr.w	r3, r2, r3
24012d02:	4a07      	ldr	r2, [pc, #28]	; (24012d20 <HAL_RCC_GetHCLKFreq+0x58>)
24012d04:	6013      	str	r3, [r2, #0]
#endif

#if defined(DUAL_CORE) && defined(CORE_CM4)
  SystemCoreClock = SystemD2Clock;
#else
  SystemCoreClock = common_system_clock;
24012d06:	4a07      	ldr	r2, [pc, #28]	; (24012d24 <HAL_RCC_GetHCLKFreq+0x5c>)
24012d08:	687b      	ldr	r3, [r7, #4]
24012d0a:	6013      	str	r3, [r2, #0]
#endif /* DUAL_CORE && CORE_CM4 */

  return SystemD2Clock;
24012d0c:	4b04      	ldr	r3, [pc, #16]	; (24012d20 <HAL_RCC_GetHCLKFreq+0x58>)
24012d0e:	681b      	ldr	r3, [r3, #0]
}
24012d10:	4618      	mov	r0, r3
24012d12:	3708      	adds	r7, #8
24012d14:	46bd      	mov	sp, r7
24012d16:	bd80      	pop	{r7, pc}
24012d18:	58024400 	.word	0x58024400
24012d1c:	24016db8 	.word	0x24016db8
24012d20:	240004bc 	.word	0x240004bc
24012d24:	240004b8 	.word	0x240004b8

24012d28 <HAL_RCC_GetPCLK1Freq>:
  * @note   Each time PCLK1 changes, this function must be called to update the
  *         right PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
24012d28:	b580      	push	{r7, lr}
24012d2a:	af00      	add	r7, sp, #0
#if defined (RCC_D2CFGR_D2PPRE1)
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> ((D1CorePrescTable[(RCC->D2CFGR & RCC_D2CFGR_D2PPRE1)>> RCC_D2CFGR_D2PPRE1_Pos]) & 0x1FU));
24012d2c:	f7ff ffcc 	bl	24012cc8 <HAL_RCC_GetHCLKFreq>
24012d30:	4601      	mov	r1, r0
24012d32:	4b06      	ldr	r3, [pc, #24]	; (24012d4c <HAL_RCC_GetPCLK1Freq+0x24>)
24012d34:	69db      	ldr	r3, [r3, #28]
24012d36:	091b      	lsrs	r3, r3, #4
24012d38:	f003 0307 	and.w	r3, r3, #7
24012d3c:	4a04      	ldr	r2, [pc, #16]	; (24012d50 <HAL_RCC_GetPCLK1Freq+0x28>)
24012d3e:	5cd3      	ldrb	r3, [r2, r3]
24012d40:	f003 031f 	and.w	r3, r3, #31
24012d44:	fa21 f303 	lsr.w	r3, r1, r3
#else
 /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> ((D1CorePrescTable[(RCC->CDCFGR2 & RCC_CDCFGR2_CDPPRE1)>> RCC_CDCFGR2_CDPPRE1_Pos]) & 0x1FU));
#endif
}
24012d48:	4618      	mov	r0, r3
24012d4a:	bd80      	pop	{r7, pc}
24012d4c:	58024400 	.word	0x58024400
24012d50:	24016db8 	.word	0x24016db8

24012d54 <HAL_RCC_GetPCLK2Freq>:
  * @note   Each time PCLK2 changes, this function must be called to update the
  *         right PCLK2 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK2Freq(void)
{
24012d54:	b580      	push	{r7, lr}
24012d56:	af00      	add	r7, sp, #0
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
#if defined(RCC_D2CFGR_D2PPRE2)
  return (HAL_RCC_GetHCLKFreq() >> ((D1CorePrescTable[(RCC->D2CFGR & RCC_D2CFGR_D2PPRE2)>> RCC_D2CFGR_D2PPRE2_Pos]) & 0x1FU));
24012d58:	f7ff ffb6 	bl	24012cc8 <HAL_RCC_GetHCLKFreq>
24012d5c:	4601      	mov	r1, r0
24012d5e:	4b06      	ldr	r3, [pc, #24]	; (24012d78 <HAL_RCC_GetPCLK2Freq+0x24>)
24012d60:	69db      	ldr	r3, [r3, #28]
24012d62:	0a1b      	lsrs	r3, r3, #8
24012d64:	f003 0307 	and.w	r3, r3, #7
24012d68:	4a04      	ldr	r2, [pc, #16]	; (24012d7c <HAL_RCC_GetPCLK2Freq+0x28>)
24012d6a:	5cd3      	ldrb	r3, [r2, r3]
24012d6c:	f003 031f 	and.w	r3, r3, #31
24012d70:	fa21 f303 	lsr.w	r3, r1, r3
#else
  return (HAL_RCC_GetHCLKFreq() >> ((D1CorePrescTable[(RCC->CDCFGR2 & RCC_CDCFGR2_CDPPRE2)>> RCC_CDCFGR2_CDPPRE2_Pos]) & 0x1FU));
#endif
}
24012d74:	4618      	mov	r0, r3
24012d76:	bd80      	pop	{r7, pc}
24012d78:	58024400 	.word	0x58024400
24012d7c:	24016db8 	.word	0x24016db8

24012d80 <HAL_RCC_GetOscConfig>:
  * @param  RCC_OscInitStruct: pointer to an RCC_OscInitTypeDef structure that
  * will be configured.
  * @retval None
  */
void HAL_RCC_GetOscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
24012d80:	b580      	push	{r7, lr}
24012d82:	b082      	sub	sp, #8
24012d84:	af00      	add	r7, sp, #0
24012d86:	6078      	str	r0, [r7, #4]
  /* Set all possible values for the Oscillator type parameter ---------------*/
  RCC_OscInitStruct->OscillatorType = RCC_OSCILLATORTYPE_HSE | RCC_OSCILLATORTYPE_HSI | RCC_OSCILLATORTYPE_CSI | \
24012d88:	687b      	ldr	r3, [r7, #4]
24012d8a:	223f      	movs	r2, #63	; 0x3f
24012d8c:	601a      	str	r2, [r3, #0]
  else
  {
    RCC_OscInitStruct->HSEState = RCC_HSE_OFF;
  }
#else
  if((RCC->CR &RCC_CR_HSEBYP) == RCC_CR_HSEBYP)
24012d8e:	4b72      	ldr	r3, [pc, #456]	; (24012f58 <HAL_RCC_GetOscConfig+0x1d8>)
24012d90:	681b      	ldr	r3, [r3, #0]
24012d92:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
24012d96:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
24012d9a:	d104      	bne.n	24012da6 <HAL_RCC_GetOscConfig+0x26>
  {
    RCC_OscInitStruct->HSEState = RCC_HSE_BYPASS;
24012d9c:	687b      	ldr	r3, [r7, #4]
24012d9e:	f44f 22a0 	mov.w	r2, #327680	; 0x50000
24012da2:	605a      	str	r2, [r3, #4]
24012da4:	e00e      	b.n	24012dc4 <HAL_RCC_GetOscConfig+0x44>
  }
  else if((RCC->CR &RCC_CR_HSEON) == RCC_CR_HSEON)
24012da6:	4b6c      	ldr	r3, [pc, #432]	; (24012f58 <HAL_RCC_GetOscConfig+0x1d8>)
24012da8:	681b      	ldr	r3, [r3, #0]
24012daa:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
24012dae:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
24012db2:	d104      	bne.n	24012dbe <HAL_RCC_GetOscConfig+0x3e>
  {
    RCC_OscInitStruct->HSEState = RCC_HSE_ON;
24012db4:	687b      	ldr	r3, [r7, #4]
24012db6:	f44f 3280 	mov.w	r2, #65536	; 0x10000
24012dba:	605a      	str	r2, [r3, #4]
24012dbc:	e002      	b.n	24012dc4 <HAL_RCC_GetOscConfig+0x44>
  }
  else
  {
    RCC_OscInitStruct->HSEState = RCC_HSE_OFF;
24012dbe:	687b      	ldr	r3, [r7, #4]
24012dc0:	2200      	movs	r2, #0
24012dc2:	605a      	str	r2, [r3, #4]
  }
#endif /* RCC_CR_HSEEXT */

   /* Get the CSI configuration -----------------------------------------------*/
  if((RCC->CR &RCC_CR_CSION) == RCC_CR_CSION)
24012dc4:	4b64      	ldr	r3, [pc, #400]	; (24012f58 <HAL_RCC_GetOscConfig+0x1d8>)
24012dc6:	681b      	ldr	r3, [r3, #0]
24012dc8:	f003 0380 	and.w	r3, r3, #128	; 0x80
24012dcc:	2b80      	cmp	r3, #128	; 0x80
24012dce:	d103      	bne.n	24012dd8 <HAL_RCC_GetOscConfig+0x58>
  {
    RCC_OscInitStruct->CSIState = RCC_CSI_ON;
24012dd0:	687b      	ldr	r3, [r7, #4]
24012dd2:	2280      	movs	r2, #128	; 0x80
24012dd4:	61da      	str	r2, [r3, #28]
24012dd6:	e002      	b.n	24012dde <HAL_RCC_GetOscConfig+0x5e>
  }
  else
  {
    RCC_OscInitStruct->CSIState = RCC_CSI_OFF;
24012dd8:	687b      	ldr	r3, [r7, #4]
24012dda:	2200      	movs	r2, #0
24012ddc:	61da      	str	r2, [r3, #28]
  }

#if defined(RCC_VER_X)
  if(HAL_GetREVID() <= REV_ID_Y)
24012dde:	f7ed fdcf 	bl	24000980 <HAL_GetREVID>
24012de2:	4602      	mov	r2, r0
24012de4:	f241 0303 	movw	r3, #4099	; 0x1003
24012de8:	429a      	cmp	r2, r3
24012dea:	d807      	bhi.n	24012dfc <HAL_RCC_GetOscConfig+0x7c>
  {
    RCC_OscInitStruct->CSICalibrationValue = (uint32_t)(READ_BIT(RCC->HSICFGR, HAL_RCC_REV_Y_CSITRIM_Msk) >> HAL_RCC_REV_Y_CSITRIM_Pos);
24012dec:	4b5a      	ldr	r3, [pc, #360]	; (24012f58 <HAL_RCC_GetOscConfig+0x1d8>)
24012dee:	685b      	ldr	r3, [r3, #4]
24012df0:	0e9b      	lsrs	r3, r3, #26
24012df2:	f003 021f 	and.w	r2, r3, #31
24012df6:	687b      	ldr	r3, [r7, #4]
24012df8:	621a      	str	r2, [r3, #32]
24012dfa:	e006      	b.n	24012e0a <HAL_RCC_GetOscConfig+0x8a>
  }
  else
  {
    RCC_OscInitStruct->CSICalibrationValue = (uint32_t)(READ_BIT(RCC->CSICFGR, RCC_CSICFGR_CSITRIM) >> RCC_CSICFGR_CSITRIM_Pos);
24012dfc:	4b56      	ldr	r3, [pc, #344]	; (24012f58 <HAL_RCC_GetOscConfig+0x1d8>)
24012dfe:	68db      	ldr	r3, [r3, #12]
24012e00:	0e1b      	lsrs	r3, r3, #24
24012e02:	f003 023f 	and.w	r2, r3, #63	; 0x3f
24012e06:	687b      	ldr	r3, [r7, #4]
24012e08:	621a      	str	r2, [r3, #32]
#else
 RCC_OscInitStruct->CSICalibrationValue = (uint32_t)(READ_BIT(RCC->CSICFGR, RCC_CSICFGR_CSITRIM) >> RCC_CSICFGR_CSITRIM_Pos);
#endif /*RCC_VER_X*/

  /* Get the HSI configuration -----------------------------------------------*/
  if((RCC->CR &RCC_CR_HSION) == RCC_CR_HSION)
24012e0a:	4b53      	ldr	r3, [pc, #332]	; (24012f58 <HAL_RCC_GetOscConfig+0x1d8>)
24012e0c:	681b      	ldr	r3, [r3, #0]
24012e0e:	f003 0301 	and.w	r3, r3, #1
24012e12:	2b01      	cmp	r3, #1
24012e14:	d103      	bne.n	24012e1e <HAL_RCC_GetOscConfig+0x9e>
  {
    RCC_OscInitStruct->HSIState = RCC_HSI_ON;
24012e16:	687b      	ldr	r3, [r7, #4]
24012e18:	2201      	movs	r2, #1
24012e1a:	60da      	str	r2, [r3, #12]
24012e1c:	e002      	b.n	24012e24 <HAL_RCC_GetOscConfig+0xa4>
  }
  else
  {
    RCC_OscInitStruct->HSIState = RCC_HSI_OFF;
24012e1e:	687b      	ldr	r3, [r7, #4]
24012e20:	2200      	movs	r2, #0
24012e22:	60da      	str	r2, [r3, #12]
  }

#if defined(RCC_VER_X)
  if(HAL_GetREVID() <= REV_ID_Y)
24012e24:	f7ed fdac 	bl	24000980 <HAL_GetREVID>
24012e28:	4602      	mov	r2, r0
24012e2a:	f241 0303 	movw	r3, #4099	; 0x1003
24012e2e:	429a      	cmp	r2, r3
24012e30:	d807      	bhi.n	24012e42 <HAL_RCC_GetOscConfig+0xc2>
  {
    RCC_OscInitStruct->HSICalibrationValue = (uint32_t)(READ_BIT(RCC->HSICFGR, HAL_RCC_REV_Y_HSITRIM_Msk) >> HAL_RCC_REV_Y_HSITRIM_Pos);
24012e32:	4b49      	ldr	r3, [pc, #292]	; (24012f58 <HAL_RCC_GetOscConfig+0x1d8>)
24012e34:	685b      	ldr	r3, [r3, #4]
24012e36:	0b1b      	lsrs	r3, r3, #12
24012e38:	f003 023f 	and.w	r2, r3, #63	; 0x3f
24012e3c:	687b      	ldr	r3, [r7, #4]
24012e3e:	611a      	str	r2, [r3, #16]
24012e40:	e006      	b.n	24012e50 <HAL_RCC_GetOscConfig+0xd0>
  }
  else
  {
    RCC_OscInitStruct->HSICalibrationValue = (uint32_t)(READ_BIT(RCC->HSICFGR, RCC_HSICFGR_HSITRIM) >> RCC_HSICFGR_HSITRIM_Pos);
24012e42:	4b45      	ldr	r3, [pc, #276]	; (24012f58 <HAL_RCC_GetOscConfig+0x1d8>)
24012e44:	685b      	ldr	r3, [r3, #4]
24012e46:	0e1b      	lsrs	r3, r3, #24
24012e48:	f003 027f 	and.w	r2, r3, #127	; 0x7f
24012e4c:	687b      	ldr	r3, [r7, #4]
24012e4e:	611a      	str	r2, [r3, #16]
  else
  {
    RCC_OscInitStruct->LSEState = RCC_LSE_OFF;
  }
#else
  if((RCC->BDCR &RCC_BDCR_LSEBYP) == RCC_BDCR_LSEBYP)
24012e50:	4b41      	ldr	r3, [pc, #260]	; (24012f58 <HAL_RCC_GetOscConfig+0x1d8>)
24012e52:	6f1b      	ldr	r3, [r3, #112]	; 0x70
24012e54:	f003 0304 	and.w	r3, r3, #4
24012e58:	2b04      	cmp	r3, #4
24012e5a:	d103      	bne.n	24012e64 <HAL_RCC_GetOscConfig+0xe4>
  {
    RCC_OscInitStruct->LSEState = RCC_LSE_BYPASS;
24012e5c:	687b      	ldr	r3, [r7, #4]
24012e5e:	2205      	movs	r2, #5
24012e60:	609a      	str	r2, [r3, #8]
24012e62:	e00c      	b.n	24012e7e <HAL_RCC_GetOscConfig+0xfe>
  }
  else if((RCC->BDCR &RCC_BDCR_LSEON) == RCC_BDCR_LSEON)
24012e64:	4b3c      	ldr	r3, [pc, #240]	; (24012f58 <HAL_RCC_GetOscConfig+0x1d8>)
24012e66:	6f1b      	ldr	r3, [r3, #112]	; 0x70
24012e68:	f003 0301 	and.w	r3, r3, #1
24012e6c:	2b01      	cmp	r3, #1
24012e6e:	d103      	bne.n	24012e78 <HAL_RCC_GetOscConfig+0xf8>
  {
    RCC_OscInitStruct->LSEState = RCC_LSE_ON;
24012e70:	687b      	ldr	r3, [r7, #4]
24012e72:	2201      	movs	r2, #1
24012e74:	609a      	str	r2, [r3, #8]
24012e76:	e002      	b.n	24012e7e <HAL_RCC_GetOscConfig+0xfe>
  }
  else
  {
    RCC_OscInitStruct->LSEState = RCC_LSE_OFF;
24012e78:	687b      	ldr	r3, [r7, #4]
24012e7a:	2200      	movs	r2, #0
24012e7c:	609a      	str	r2, [r3, #8]
  }
#endif /* RCC_BDCR_LSEEXT */

  /* Get the LSI configuration -----------------------------------------------*/
  if((RCC->CSR &RCC_CSR_LSION) == RCC_CSR_LSION)
24012e7e:	4b36      	ldr	r3, [pc, #216]	; (24012f58 <HAL_RCC_GetOscConfig+0x1d8>)
24012e80:	6f5b      	ldr	r3, [r3, #116]	; 0x74
24012e82:	f003 0301 	and.w	r3, r3, #1
24012e86:	2b01      	cmp	r3, #1
24012e88:	d103      	bne.n	24012e92 <HAL_RCC_GetOscConfig+0x112>
  {
    RCC_OscInitStruct->LSIState = RCC_LSI_ON;
24012e8a:	687b      	ldr	r3, [r7, #4]
24012e8c:	2201      	movs	r2, #1
24012e8e:	615a      	str	r2, [r3, #20]
24012e90:	e002      	b.n	24012e98 <HAL_RCC_GetOscConfig+0x118>
  }
  else
  {
    RCC_OscInitStruct->LSIState = RCC_LSI_OFF;
24012e92:	687b      	ldr	r3, [r7, #4]
24012e94:	2200      	movs	r2, #0
24012e96:	615a      	str	r2, [r3, #20]
  }

  /* Get the HSI48 configuration ---------------------------------------------*/
  if((RCC->CR & RCC_CR_HSI48ON) == RCC_CR_HSI48ON)
24012e98:	4b2f      	ldr	r3, [pc, #188]	; (24012f58 <HAL_RCC_GetOscConfig+0x1d8>)
24012e9a:	681b      	ldr	r3, [r3, #0]
24012e9c:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
24012ea0:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
24012ea4:	d103      	bne.n	24012eae <HAL_RCC_GetOscConfig+0x12e>
  {
    RCC_OscInitStruct->HSI48State = RCC_HSI48_ON;
24012ea6:	687b      	ldr	r3, [r7, #4]
24012ea8:	2201      	movs	r2, #1
24012eaa:	619a      	str	r2, [r3, #24]
24012eac:	e002      	b.n	24012eb4 <HAL_RCC_GetOscConfig+0x134>
  }
  else
  {
    RCC_OscInitStruct->HSI48State = RCC_HSI48_OFF;
24012eae:	687b      	ldr	r3, [r7, #4]
24012eb0:	2200      	movs	r2, #0
24012eb2:	619a      	str	r2, [r3, #24]
  }

  /* Get the PLL configuration -----------------------------------------------*/
  if((RCC->CR &RCC_CR_PLLON) == RCC_CR_PLLON)
24012eb4:	4b28      	ldr	r3, [pc, #160]	; (24012f58 <HAL_RCC_GetOscConfig+0x1d8>)
24012eb6:	681b      	ldr	r3, [r3, #0]
24012eb8:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
24012ebc:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
24012ec0:	d103      	bne.n	24012eca <HAL_RCC_GetOscConfig+0x14a>
  {
    RCC_OscInitStruct->PLL.PLLState = RCC_PLL_ON;
24012ec2:	687b      	ldr	r3, [r7, #4]
24012ec4:	2202      	movs	r2, #2
24012ec6:	625a      	str	r2, [r3, #36]	; 0x24
24012ec8:	e002      	b.n	24012ed0 <HAL_RCC_GetOscConfig+0x150>
  }
  else
  {
    RCC_OscInitStruct->PLL.PLLState = RCC_PLL_OFF;
24012eca:	687b      	ldr	r3, [r7, #4]
24012ecc:	2201      	movs	r2, #1
24012ece:	625a      	str	r2, [r3, #36]	; 0x24
  }
  RCC_OscInitStruct->PLL.PLLSource = (uint32_t)(RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
24012ed0:	4b21      	ldr	r3, [pc, #132]	; (24012f58 <HAL_RCC_GetOscConfig+0x1d8>)
24012ed2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
24012ed4:	f003 0203 	and.w	r2, r3, #3
24012ed8:	687b      	ldr	r3, [r7, #4]
24012eda:	629a      	str	r2, [r3, #40]	; 0x28
  RCC_OscInitStruct->PLL.PLLM = (uint32_t)((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM1)>> RCC_PLLCKSELR_DIVM1_Pos);
24012edc:	4b1e      	ldr	r3, [pc, #120]	; (24012f58 <HAL_RCC_GetOscConfig+0x1d8>)
24012ede:	6a9b      	ldr	r3, [r3, #40]	; 0x28
24012ee0:	091b      	lsrs	r3, r3, #4
24012ee2:	f003 023f 	and.w	r2, r3, #63	; 0x3f
24012ee6:	687b      	ldr	r3, [r7, #4]
24012ee8:	62da      	str	r2, [r3, #44]	; 0x2c
  RCC_OscInitStruct->PLL.PLLN = (uint32_t)((RCC->PLL1DIVR & RCC_PLL1DIVR_N1) >> RCC_PLL1DIVR_N1_Pos)+ 1U;
24012eea:	4b1b      	ldr	r3, [pc, #108]	; (24012f58 <HAL_RCC_GetOscConfig+0x1d8>)
24012eec:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24012eee:	f3c3 0308 	ubfx	r3, r3, #0, #9
24012ef2:	1c5a      	adds	r2, r3, #1
24012ef4:	687b      	ldr	r3, [r7, #4]
24012ef6:	631a      	str	r2, [r3, #48]	; 0x30
  RCC_OscInitStruct->PLL.PLLR = (uint32_t)((RCC->PLL1DIVR & RCC_PLL1DIVR_R1) >> RCC_PLL1DIVR_R1_Pos)+ 1U;
24012ef8:	4b17      	ldr	r3, [pc, #92]	; (24012f58 <HAL_RCC_GetOscConfig+0x1d8>)
24012efa:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24012efc:	0e1b      	lsrs	r3, r3, #24
24012efe:	f003 037f 	and.w	r3, r3, #127	; 0x7f
24012f02:	1c5a      	adds	r2, r3, #1
24012f04:	687b      	ldr	r3, [r7, #4]
24012f06:	63da      	str	r2, [r3, #60]	; 0x3c
  RCC_OscInitStruct->PLL.PLLP = (uint32_t)((RCC->PLL1DIVR & RCC_PLL1DIVR_P1) >> RCC_PLL1DIVR_P1_Pos)+ 1U;
24012f08:	4b13      	ldr	r3, [pc, #76]	; (24012f58 <HAL_RCC_GetOscConfig+0x1d8>)
24012f0a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24012f0c:	0a5b      	lsrs	r3, r3, #9
24012f0e:	f003 037f 	and.w	r3, r3, #127	; 0x7f
24012f12:	1c5a      	adds	r2, r3, #1
24012f14:	687b      	ldr	r3, [r7, #4]
24012f16:	635a      	str	r2, [r3, #52]	; 0x34
  RCC_OscInitStruct->PLL.PLLQ = (uint32_t)((RCC->PLL1DIVR & RCC_PLL1DIVR_Q1) >> RCC_PLL1DIVR_Q1_Pos)+ 1U;
24012f18:	4b0f      	ldr	r3, [pc, #60]	; (24012f58 <HAL_RCC_GetOscConfig+0x1d8>)
24012f1a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24012f1c:	0c1b      	lsrs	r3, r3, #16
24012f1e:	f003 037f 	and.w	r3, r3, #127	; 0x7f
24012f22:	1c5a      	adds	r2, r3, #1
24012f24:	687b      	ldr	r3, [r7, #4]
24012f26:	639a      	str	r2, [r3, #56]	; 0x38
  RCC_OscInitStruct->PLL.PLLRGE = (uint32_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLL1RGE));
24012f28:	4b0b      	ldr	r3, [pc, #44]	; (24012f58 <HAL_RCC_GetOscConfig+0x1d8>)
24012f2a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24012f2c:	f003 020c 	and.w	r2, r3, #12
24012f30:	687b      	ldr	r3, [r7, #4]
24012f32:	641a      	str	r2, [r3, #64]	; 0x40
  RCC_OscInitStruct->PLL.PLLVCOSEL = (uint32_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLL1VCOSEL) >> RCC_PLLCFGR_PLL1VCOSEL_Pos);
24012f34:	4b08      	ldr	r3, [pc, #32]	; (24012f58 <HAL_RCC_GetOscConfig+0x1d8>)
24012f36:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24012f38:	085b      	lsrs	r3, r3, #1
24012f3a:	f003 0201 	and.w	r2, r3, #1
24012f3e:	687b      	ldr	r3, [r7, #4]
24012f40:	645a      	str	r2, [r3, #68]	; 0x44
  RCC_OscInitStruct->PLL.PLLFRACN = (uint32_t)(((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1) >> RCC_PLL1FRACR_FRACN1_Pos));
24012f42:	4b05      	ldr	r3, [pc, #20]	; (24012f58 <HAL_RCC_GetOscConfig+0x1d8>)
24012f44:	6b5b      	ldr	r3, [r3, #52]	; 0x34
24012f46:	08db      	lsrs	r3, r3, #3
24012f48:	f3c3 020c 	ubfx	r2, r3, #0, #13
24012f4c:	687b      	ldr	r3, [r7, #4]
24012f4e:	649a      	str	r2, [r3, #72]	; 0x48
}
24012f50:	bf00      	nop
24012f52:	3708      	adds	r7, #8
24012f54:	46bd      	mov	sp, r7
24012f56:	bd80      	pop	{r7, pc}
24012f58:	58024400 	.word	0x58024400

24012f5c <HAL_RCC_GetClockConfig>:
  * will be configured.
  * @param  pFLatency: Pointer on the Flash Latency.
  * @retval None
  */
void HAL_RCC_GetClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t *pFLatency)
{
24012f5c:	b480      	push	{r7}
24012f5e:	b083      	sub	sp, #12
24012f60:	af00      	add	r7, sp, #0
24012f62:	6078      	str	r0, [r7, #4]
24012f64:	6039      	str	r1, [r7, #0]
  /* Set all possible values for the Clock type parameter --------------------*/
  RCC_ClkInitStruct->ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_D1PCLK1 | RCC_CLOCKTYPE_PCLK1 |
24012f66:	687b      	ldr	r3, [r7, #4]
24012f68:	223f      	movs	r2, #63	; 0x3f
24012f6a:	601a      	str	r2, [r3, #0]
                                 RCC_CLOCKTYPE_PCLK2 |  RCC_CLOCKTYPE_D3PCLK1  ;

  /* Get the SYSCLK configuration --------------------------------------------*/
  RCC_ClkInitStruct->SYSCLKSource = (uint32_t)(RCC->CFGR & RCC_CFGR_SW);
24012f6c:	4b1a      	ldr	r3, [pc, #104]	; (24012fd8 <HAL_RCC_GetClockConfig+0x7c>)
24012f6e:	691b      	ldr	r3, [r3, #16]
24012f70:	f003 0207 	and.w	r2, r3, #7
24012f74:	687b      	ldr	r3, [r7, #4]
24012f76:	605a      	str	r2, [r3, #4]

#if defined(RCC_D1CFGR_D1CPRE)
  /* Get the SYSCLK configuration ----------------------------------------------*/
  RCC_ClkInitStruct->SYSCLKDivider = (uint32_t)(RCC->D1CFGR & RCC_D1CFGR_D1CPRE);
24012f78:	4b17      	ldr	r3, [pc, #92]	; (24012fd8 <HAL_RCC_GetClockConfig+0x7c>)
24012f7a:	699b      	ldr	r3, [r3, #24]
24012f7c:	f403 6270 	and.w	r2, r3, #3840	; 0xf00
24012f80:	687b      	ldr	r3, [r7, #4]
24012f82:	609a      	str	r2, [r3, #8]

  /* Get the D1HCLK configuration ----------------------------------------------*/
  RCC_ClkInitStruct->AHBCLKDivider = (uint32_t)(RCC->D1CFGR & RCC_D1CFGR_HPRE);
24012f84:	4b14      	ldr	r3, [pc, #80]	; (24012fd8 <HAL_RCC_GetClockConfig+0x7c>)
24012f86:	699b      	ldr	r3, [r3, #24]
24012f88:	f003 020f 	and.w	r2, r3, #15
24012f8c:	687b      	ldr	r3, [r7, #4]
24012f8e:	60da      	str	r2, [r3, #12]

  /* Get the APB3 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB3CLKDivider = (uint32_t)(RCC->D1CFGR & RCC_D1CFGR_D1PPRE);
24012f90:	4b11      	ldr	r3, [pc, #68]	; (24012fd8 <HAL_RCC_GetClockConfig+0x7c>)
24012f92:	699b      	ldr	r3, [r3, #24]
24012f94:	f003 0270 	and.w	r2, r3, #112	; 0x70
24012f98:	687b      	ldr	r3, [r7, #4]
24012f9a:	611a      	str	r2, [r3, #16]

  /* Get the APB1 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB1CLKDivider = (uint32_t)(RCC->D2CFGR & RCC_D2CFGR_D2PPRE1);
24012f9c:	4b0e      	ldr	r3, [pc, #56]	; (24012fd8 <HAL_RCC_GetClockConfig+0x7c>)
24012f9e:	69db      	ldr	r3, [r3, #28]
24012fa0:	f003 0270 	and.w	r2, r3, #112	; 0x70
24012fa4:	687b      	ldr	r3, [r7, #4]
24012fa6:	615a      	str	r2, [r3, #20]

  /* Get the APB2 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB2CLKDivider = (uint32_t)(RCC->D2CFGR & RCC_D2CFGR_D2PPRE2);
24012fa8:	4b0b      	ldr	r3, [pc, #44]	; (24012fd8 <HAL_RCC_GetClockConfig+0x7c>)
24012faa:	69db      	ldr	r3, [r3, #28]
24012fac:	f403 62e0 	and.w	r2, r3, #1792	; 0x700
24012fb0:	687b      	ldr	r3, [r7, #4]
24012fb2:	619a      	str	r2, [r3, #24]

  /* Get the APB4 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB4CLKDivider = (uint32_t)(RCC->D3CFGR & RCC_D3CFGR_D3PPRE);
24012fb4:	4b08      	ldr	r3, [pc, #32]	; (24012fd8 <HAL_RCC_GetClockConfig+0x7c>)
24012fb6:	6a1b      	ldr	r3, [r3, #32]
24012fb8:	f003 0270 	and.w	r2, r3, #112	; 0x70
24012fbc:	687b      	ldr	r3, [r7, #4]
24012fbe:	61da      	str	r2, [r3, #28]
  /* Get the APB4 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB4CLKDivider = (uint32_t)(RCC->SRDCFGR & RCC_SRDCFGR_SRDPPRE);
#endif

  /* Get the Flash Wait State (Latency) configuration ------------------------*/
  *pFLatency = (uint32_t)(FLASH->ACR & FLASH_ACR_LATENCY);
24012fc0:	4b06      	ldr	r3, [pc, #24]	; (24012fdc <HAL_RCC_GetClockConfig+0x80>)
24012fc2:	681b      	ldr	r3, [r3, #0]
24012fc4:	f003 020f 	and.w	r2, r3, #15
24012fc8:	683b      	ldr	r3, [r7, #0]
24012fca:	601a      	str	r2, [r3, #0]
}
24012fcc:	bf00      	nop
24012fce:	370c      	adds	r7, #12
24012fd0:	46bd      	mov	sp, r7
24012fd2:	f85d 7b04 	ldr.w	r7, [sp], #4
24012fd6:	4770      	bx	lr
24012fd8:	58024400 	.word	0x58024400
24012fdc:	52002000 	.word	0x52002000

24012fe0 <HAL_RCC_NMI_IRQHandler>:
  * @brief This function handles the RCC CSS interrupt request.
  * @note This API should be called under the NMI_Handler().
  * @retval None
  */
void HAL_RCC_NMI_IRQHandler(void)
{
24012fe0:	b580      	push	{r7, lr}
24012fe2:	af00      	add	r7, sp, #0
  /* Check RCC CSSF flag  */
  if(__HAL_RCC_GET_IT(RCC_IT_CSS))
24012fe4:	4b07      	ldr	r3, [pc, #28]	; (24013004 <HAL_RCC_NMI_IRQHandler+0x24>)
24012fe6:	6e5b      	ldr	r3, [r3, #100]	; 0x64
24012fe8:	f403 6380 	and.w	r3, r3, #1024	; 0x400
24012fec:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
24012ff0:	d105      	bne.n	24012ffe <HAL_RCC_NMI_IRQHandler+0x1e>
  {
    /* RCC Clock Security System interrupt user callback */
    HAL_RCC_CCSCallback();
24012ff2:	f000 f809 	bl	24013008 <HAL_RCC_CSSCallback>

    /* Clear RCC CSS pending bit */
    __HAL_RCC_CLEAR_IT(RCC_IT_CSS);
24012ff6:	4b03      	ldr	r3, [pc, #12]	; (24013004 <HAL_RCC_NMI_IRQHandler+0x24>)
24012ff8:	f44f 6280 	mov.w	r2, #1024	; 0x400
24012ffc:	669a      	str	r2, [r3, #104]	; 0x68
  }
}
24012ffe:	bf00      	nop
24013000:	bd80      	pop	{r7, pc}
24013002:	bf00      	nop
24013004:	58024400 	.word	0x58024400

24013008 <HAL_RCC_CSSCallback>:
/**
  * @brief  RCC Clock Security System interrupt callback
  * @retval none
  */
__weak void HAL_RCC_CCSCallback(void)
{
24013008:	b480      	push	{r7}
2401300a:	af00      	add	r7, sp, #0
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_RCC_CCSCallback could be implemented in the user file
   */
}
2401300c:	bf00      	nop
2401300e:	46bd      	mov	sp, r7
24013010:	f85d 7b04 	ldr.w	r7, [sp], #4
24013014:	4770      	bx	lr
	...

24013018 <HAL_RCCEx_PeriphCLKConfig>:
  * (*) : Available on some STM32H7 lines only.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
24013018:	b580      	push	{r7, lr}
2401301a:	b086      	sub	sp, #24
2401301c:	af00      	add	r7, sp, #0
2401301e:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg;
  uint32_t tickstart;
  HAL_StatusTypeDef ret = HAL_OK;      /* Intermediate status */
24013020:	2300      	movs	r3, #0
24013022:	75fb      	strb	r3, [r7, #23]
  HAL_StatusTypeDef status = HAL_OK;   /* Final status */
24013024:	2300      	movs	r3, #0
24013026:	75bb      	strb	r3, [r7, #22]

  /*---------------------------- SPDIFRX configuration -------------------------------*/

  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPDIFRX) == RCC_PERIPHCLK_SPDIFRX)
24013028:	687b      	ldr	r3, [r7, #4]
2401302a:	681b      	ldr	r3, [r3, #0]
2401302c:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
24013030:	2b00      	cmp	r3, #0
24013032:	d03d      	beq.n	240130b0 <HAL_RCCEx_PeriphCLKConfig+0x98>
  {

    switch(PeriphClkInit->SpdifrxClockSelection)
24013034:	687b      	ldr	r3, [r7, #4]
24013036:	6e5b      	ldr	r3, [r3, #100]	; 0x64
24013038:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
2401303c:	d013      	beq.n	24013066 <HAL_RCCEx_PeriphCLKConfig+0x4e>
2401303e:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
24013042:	d802      	bhi.n	2401304a <HAL_RCCEx_PeriphCLKConfig+0x32>
24013044:	2b00      	cmp	r3, #0
24013046:	d007      	beq.n	24013058 <HAL_RCCEx_PeriphCLKConfig+0x40>
24013048:	e01f      	b.n	2401308a <HAL_RCCEx_PeriphCLKConfig+0x72>
2401304a:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
2401304e:	d013      	beq.n	24013078 <HAL_RCCEx_PeriphCLKConfig+0x60>
24013050:	f5b3 1f40 	cmp.w	r3, #3145728	; 0x300000
24013054:	d01c      	beq.n	24013090 <HAL_RCCEx_PeriphCLKConfig+0x78>
24013056:	e018      	b.n	2401308a <HAL_RCCEx_PeriphCLKConfig+0x72>
    {
    case RCC_SPDIFRXCLKSOURCE_PLL:      /* PLL is used as clock source for SPDIFRX*/
      /* Enable PLL1Q Clock output generated form System PLL . */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
24013058:	4baf      	ldr	r3, [pc, #700]	; (24013318 <HAL_RCCEx_PeriphCLKConfig+0x300>)
2401305a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2401305c:	4aae      	ldr	r2, [pc, #696]	; (24013318 <HAL_RCCEx_PeriphCLKConfig+0x300>)
2401305e:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
24013062:	62d3      	str	r3, [r2, #44]	; 0x2c

      /* SPDIFRX clock source configuration done later after clock selection check */
      break;
24013064:	e015      	b.n	24013092 <HAL_RCCEx_PeriphCLKConfig+0x7a>

    case RCC_SPDIFRXCLKSOURCE_PLL2: /* PLL2 is used as clock source for SPDIFRX*/

      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_R_UPDATE);
24013066:	687b      	ldr	r3, [r7, #4]
24013068:	3304      	adds	r3, #4
2401306a:	2102      	movs	r1, #2
2401306c:	4618      	mov	r0, r3
2401306e:	f002 f8e1 	bl	24015234 <RCCEx_PLL2_Config>
24013072:	4603      	mov	r3, r0
24013074:	75fb      	strb	r3, [r7, #23]

      /* SPDIFRX clock source configuration done later after clock selection check */
      break;
24013076:	e00c      	b.n	24013092 <HAL_RCCEx_PeriphCLKConfig+0x7a>

    case RCC_SPDIFRXCLKSOURCE_PLL3:  /* PLL3 is used as clock source for SPDIFRX*/
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE);
24013078:	687b      	ldr	r3, [r7, #4]
2401307a:	3324      	adds	r3, #36	; 0x24
2401307c:	2102      	movs	r1, #2
2401307e:	4618      	mov	r0, r3
24013080:	f002 f98a 	bl	24015398 <RCCEx_PLL3_Config>
24013084:	4603      	mov	r3, r0
24013086:	75fb      	strb	r3, [r7, #23]

      /* SPDIFRX clock source configuration done later after clock selection check */
      break;
24013088:	e003      	b.n	24013092 <HAL_RCCEx_PeriphCLKConfig+0x7a>
      /* Internal OSC clock is used as source of SPDIFRX clock*/
      /* SPDIFRX clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
2401308a:	2301      	movs	r3, #1
2401308c:	75fb      	strb	r3, [r7, #23]
      break;
2401308e:	e000      	b.n	24013092 <HAL_RCCEx_PeriphCLKConfig+0x7a>
      break;
24013090:	bf00      	nop
    }

    if(ret == HAL_OK)
24013092:	7dfb      	ldrb	r3, [r7, #23]
24013094:	2b00      	cmp	r3, #0
24013096:	d109      	bne.n	240130ac <HAL_RCCEx_PeriphCLKConfig+0x94>
    {
      /* Set the source of SPDIFRX clock*/
      __HAL_RCC_SPDIFRX_CONFIG(PeriphClkInit->SpdifrxClockSelection);
24013098:	4b9f      	ldr	r3, [pc, #636]	; (24013318 <HAL_RCCEx_PeriphCLKConfig+0x300>)
2401309a:	6d1b      	ldr	r3, [r3, #80]	; 0x50
2401309c:	f423 1240 	bic.w	r2, r3, #3145728	; 0x300000
240130a0:	687b      	ldr	r3, [r7, #4]
240130a2:	6e5b      	ldr	r3, [r3, #100]	; 0x64
240130a4:	499c      	ldr	r1, [pc, #624]	; (24013318 <HAL_RCCEx_PeriphCLKConfig+0x300>)
240130a6:	4313      	orrs	r3, r2
240130a8:	650b      	str	r3, [r1, #80]	; 0x50
240130aa:	e001      	b.n	240130b0 <HAL_RCCEx_PeriphCLKConfig+0x98>
    }
    else
    {
      /* set overall return value */
      status = ret;
240130ac:	7dfb      	ldrb	r3, [r7, #23]
240130ae:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*---------------------------- SAI1 configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1)
240130b0:	687b      	ldr	r3, [r7, #4]
240130b2:	681b      	ldr	r3, [r3, #0]
240130b4:	f403 7380 	and.w	r3, r3, #256	; 0x100
240130b8:	2b00      	cmp	r3, #0
240130ba:	d03d      	beq.n	24013138 <HAL_RCCEx_PeriphCLKConfig+0x120>
  {
    switch(PeriphClkInit->Sai1ClockSelection)
240130bc:	687b      	ldr	r3, [r7, #4]
240130be:	6d5b      	ldr	r3, [r3, #84]	; 0x54
240130c0:	2b04      	cmp	r3, #4
240130c2:	d826      	bhi.n	24013112 <HAL_RCCEx_PeriphCLKConfig+0xfa>
240130c4:	a201      	add	r2, pc, #4	; (adr r2, 240130cc <HAL_RCCEx_PeriphCLKConfig+0xb4>)
240130c6:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
240130ca:	bf00      	nop
240130cc:	240130e1 	.word	0x240130e1
240130d0:	240130ef 	.word	0x240130ef
240130d4:	24013101 	.word	0x24013101
240130d8:	24013119 	.word	0x24013119
240130dc:	24013119 	.word	0x24013119
    {
    case RCC_SAI1CLKSOURCE_PLL:      /* PLL is used as clock source for SAI1*/
      /* Enable SAI Clock output generated form System PLL . */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
240130e0:	4b8d      	ldr	r3, [pc, #564]	; (24013318 <HAL_RCCEx_PeriphCLKConfig+0x300>)
240130e2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
240130e4:	4a8c      	ldr	r2, [pc, #560]	; (24013318 <HAL_RCCEx_PeriphCLKConfig+0x300>)
240130e6:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
240130ea:	62d3      	str	r3, [r2, #44]	; 0x2c

      /* SAI1 clock source configuration done later after clock selection check */
      break;
240130ec:	e015      	b.n	2401311a <HAL_RCCEx_PeriphCLKConfig+0x102>

    case RCC_SAI1CLKSOURCE_PLL2: /* PLL2 is used as clock source for SAI1*/

      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
240130ee:	687b      	ldr	r3, [r7, #4]
240130f0:	3304      	adds	r3, #4
240130f2:	2100      	movs	r1, #0
240130f4:	4618      	mov	r0, r3
240130f6:	f002 f89d 	bl	24015234 <RCCEx_PLL2_Config>
240130fa:	4603      	mov	r3, r0
240130fc:	75fb      	strb	r3, [r7, #23]

      /* SAI1 clock source configuration done later after clock selection check */
      break;
240130fe:	e00c      	b.n	2401311a <HAL_RCCEx_PeriphCLKConfig+0x102>

    case RCC_SAI1CLKSOURCE_PLL3:  /* PLL3 is used as clock source for SAI1*/
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_P_UPDATE);
24013100:	687b      	ldr	r3, [r7, #4]
24013102:	3324      	adds	r3, #36	; 0x24
24013104:	2100      	movs	r1, #0
24013106:	4618      	mov	r0, r3
24013108:	f002 f946 	bl	24015398 <RCCEx_PLL3_Config>
2401310c:	4603      	mov	r3, r0
2401310e:	75fb      	strb	r3, [r7, #23]

      /* SAI1 clock source configuration done later after clock selection check */
      break;
24013110:	e003      	b.n	2401311a <HAL_RCCEx_PeriphCLKConfig+0x102>
      /* HSI, HSE, or CSI oscillator is used as source of SAI1 clock */
      /* SAI1 clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
24013112:	2301      	movs	r3, #1
24013114:	75fb      	strb	r3, [r7, #23]
      break;
24013116:	e000      	b.n	2401311a <HAL_RCCEx_PeriphCLKConfig+0x102>
      break;
24013118:	bf00      	nop
    }

    if(ret == HAL_OK)
2401311a:	7dfb      	ldrb	r3, [r7, #23]
2401311c:	2b00      	cmp	r3, #0
2401311e:	d109      	bne.n	24013134 <HAL_RCCEx_PeriphCLKConfig+0x11c>
    {
      /* Set the source of SAI1 clock*/
      __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
24013120:	4b7d      	ldr	r3, [pc, #500]	; (24013318 <HAL_RCCEx_PeriphCLKConfig+0x300>)
24013122:	6d1b      	ldr	r3, [r3, #80]	; 0x50
24013124:	f023 0207 	bic.w	r2, r3, #7
24013128:	687b      	ldr	r3, [r7, #4]
2401312a:	6d5b      	ldr	r3, [r3, #84]	; 0x54
2401312c:	497a      	ldr	r1, [pc, #488]	; (24013318 <HAL_RCCEx_PeriphCLKConfig+0x300>)
2401312e:	4313      	orrs	r3, r2
24013130:	650b      	str	r3, [r1, #80]	; 0x50
24013132:	e001      	b.n	24013138 <HAL_RCCEx_PeriphCLKConfig+0x120>
    }
    else
    {
      /* set overall return value */
      status = ret;
24013134:	7dfb      	ldrb	r3, [r7, #23]
24013136:	75bb      	strb	r3, [r7, #22]
    }
  }

#if defined(SAI3)
  /*---------------------------- SAI2/3 configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI23) == RCC_PERIPHCLK_SAI23)
24013138:	687b      	ldr	r3, [r7, #4]
2401313a:	681b      	ldr	r3, [r3, #0]
2401313c:	f403 7300 	and.w	r3, r3, #512	; 0x200
24013140:	2b00      	cmp	r3, #0
24013142:	d03e      	beq.n	240131c2 <HAL_RCCEx_PeriphCLKConfig+0x1aa>
  {
    switch(PeriphClkInit->Sai23ClockSelection)
24013144:	687b      	ldr	r3, [r7, #4]
24013146:	6d9b      	ldr	r3, [r3, #88]	; 0x58
24013148:	2b80      	cmp	r3, #128	; 0x80
2401314a:	d01c      	beq.n	24013186 <HAL_RCCEx_PeriphCLKConfig+0x16e>
2401314c:	2b80      	cmp	r3, #128	; 0x80
2401314e:	d804      	bhi.n	2401315a <HAL_RCCEx_PeriphCLKConfig+0x142>
24013150:	2b00      	cmp	r3, #0
24013152:	d008      	beq.n	24013166 <HAL_RCCEx_PeriphCLKConfig+0x14e>
24013154:	2b40      	cmp	r3, #64	; 0x40
24013156:	d00d      	beq.n	24013174 <HAL_RCCEx_PeriphCLKConfig+0x15c>
24013158:	e01e      	b.n	24013198 <HAL_RCCEx_PeriphCLKConfig+0x180>
2401315a:	2bc0      	cmp	r3, #192	; 0xc0
2401315c:	d01f      	beq.n	2401319e <HAL_RCCEx_PeriphCLKConfig+0x186>
2401315e:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
24013162:	d01e      	beq.n	240131a2 <HAL_RCCEx_PeriphCLKConfig+0x18a>
24013164:	e018      	b.n	24013198 <HAL_RCCEx_PeriphCLKConfig+0x180>
    {
    case RCC_SAI23CLKSOURCE_PLL:      /* PLL is used as clock source for SAI2/3 */
      /* Enable SAI Clock output generated form System PLL . */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
24013166:	4b6c      	ldr	r3, [pc, #432]	; (24013318 <HAL_RCCEx_PeriphCLKConfig+0x300>)
24013168:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2401316a:	4a6b      	ldr	r2, [pc, #428]	; (24013318 <HAL_RCCEx_PeriphCLKConfig+0x300>)
2401316c:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
24013170:	62d3      	str	r3, [r2, #44]	; 0x2c

      /* SAI2/3 clock source configuration done later after clock selection check */
      break;
24013172:	e017      	b.n	240131a4 <HAL_RCCEx_PeriphCLKConfig+0x18c>

    case RCC_SAI23CLKSOURCE_PLL2: /* PLL2 is used as clock source for SAI2/3 */

      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
24013174:	687b      	ldr	r3, [r7, #4]
24013176:	3304      	adds	r3, #4
24013178:	2100      	movs	r1, #0
2401317a:	4618      	mov	r0, r3
2401317c:	f002 f85a 	bl	24015234 <RCCEx_PLL2_Config>
24013180:	4603      	mov	r3, r0
24013182:	75fb      	strb	r3, [r7, #23]

      /* SAI2/3 clock source configuration done later after clock selection check */
      break;
24013184:	e00e      	b.n	240131a4 <HAL_RCCEx_PeriphCLKConfig+0x18c>

    case RCC_SAI23CLKSOURCE_PLL3:  /* PLL3 is used as clock source for SAI2/3 */
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_P_UPDATE);
24013186:	687b      	ldr	r3, [r7, #4]
24013188:	3324      	adds	r3, #36	; 0x24
2401318a:	2100      	movs	r1, #0
2401318c:	4618      	mov	r0, r3
2401318e:	f002 f903 	bl	24015398 <RCCEx_PLL3_Config>
24013192:	4603      	mov	r3, r0
24013194:	75fb      	strb	r3, [r7, #23]

      /* SAI2/3 clock source configuration done later after clock selection check */
      break;
24013196:	e005      	b.n	240131a4 <HAL_RCCEx_PeriphCLKConfig+0x18c>
      /* HSI, HSE, or CSI oscillator is used as source of SAI2/3 clock */
      /* SAI2/3 clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
24013198:	2301      	movs	r3, #1
2401319a:	75fb      	strb	r3, [r7, #23]
      break;
2401319c:	e002      	b.n	240131a4 <HAL_RCCEx_PeriphCLKConfig+0x18c>
      break;
2401319e:	bf00      	nop
240131a0:	e000      	b.n	240131a4 <HAL_RCCEx_PeriphCLKConfig+0x18c>
      break;
240131a2:	bf00      	nop
    }

    if(ret == HAL_OK)
240131a4:	7dfb      	ldrb	r3, [r7, #23]
240131a6:	2b00      	cmp	r3, #0
240131a8:	d109      	bne.n	240131be <HAL_RCCEx_PeriphCLKConfig+0x1a6>
    {
      /* Set the source of SAI2/3 clock*/
      __HAL_RCC_SAI23_CONFIG(PeriphClkInit->Sai23ClockSelection);
240131aa:	4b5b      	ldr	r3, [pc, #364]	; (24013318 <HAL_RCCEx_PeriphCLKConfig+0x300>)
240131ac:	6d1b      	ldr	r3, [r3, #80]	; 0x50
240131ae:	f423 72e0 	bic.w	r2, r3, #448	; 0x1c0
240131b2:	687b      	ldr	r3, [r7, #4]
240131b4:	6d9b      	ldr	r3, [r3, #88]	; 0x58
240131b6:	4958      	ldr	r1, [pc, #352]	; (24013318 <HAL_RCCEx_PeriphCLKConfig+0x300>)
240131b8:	4313      	orrs	r3, r2
240131ba:	650b      	str	r3, [r1, #80]	; 0x50
240131bc:	e001      	b.n	240131c2 <HAL_RCCEx_PeriphCLKConfig+0x1aa>
    }
    else
    {
      /* set overall return value */
      status = ret;
240131be:	7dfb      	ldrb	r3, [r7, #23]
240131c0:	75bb      	strb	r3, [r7, #22]
  }
#endif  /*SAI2B*/

#if defined(SAI4)
  /*---------------------------- SAI4A configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI4A) == RCC_PERIPHCLK_SAI4A)
240131c2:	687b      	ldr	r3, [r7, #4]
240131c4:	681b      	ldr	r3, [r3, #0]
240131c6:	f403 6380 	and.w	r3, r3, #1024	; 0x400
240131ca:	2b00      	cmp	r3, #0
240131cc:	d044      	beq.n	24013258 <HAL_RCCEx_PeriphCLKConfig+0x240>
  {
    switch(PeriphClkInit->Sai4AClockSelection)
240131ce:	687b      	ldr	r3, [r7, #4]
240131d0:	f8d3 30a4 	ldr.w	r3, [r3, #164]	; 0xa4
240131d4:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
240131d8:	d01f      	beq.n	2401321a <HAL_RCCEx_PeriphCLKConfig+0x202>
240131da:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
240131de:	d805      	bhi.n	240131ec <HAL_RCCEx_PeriphCLKConfig+0x1d4>
240131e0:	2b00      	cmp	r3, #0
240131e2:	d00a      	beq.n	240131fa <HAL_RCCEx_PeriphCLKConfig+0x1e2>
240131e4:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
240131e8:	d00e      	beq.n	24013208 <HAL_RCCEx_PeriphCLKConfig+0x1f0>
240131ea:	e01f      	b.n	2401322c <HAL_RCCEx_PeriphCLKConfig+0x214>
240131ec:	f5b3 0fc0 	cmp.w	r3, #6291456	; 0x600000
240131f0:	d01f      	beq.n	24013232 <HAL_RCCEx_PeriphCLKConfig+0x21a>
240131f2:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
240131f6:	d01e      	beq.n	24013236 <HAL_RCCEx_PeriphCLKConfig+0x21e>
240131f8:	e018      	b.n	2401322c <HAL_RCCEx_PeriphCLKConfig+0x214>
    {
    case RCC_SAI4ACLKSOURCE_PLL:      /* PLL is used as clock source for SAI2*/
      /* Enable SAI Clock output generated form System PLL . */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
240131fa:	4b47      	ldr	r3, [pc, #284]	; (24013318 <HAL_RCCEx_PeriphCLKConfig+0x300>)
240131fc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
240131fe:	4a46      	ldr	r2, [pc, #280]	; (24013318 <HAL_RCCEx_PeriphCLKConfig+0x300>)
24013200:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
24013204:	62d3      	str	r3, [r2, #44]	; 0x2c

      /* SAI1 clock source configuration done later after clock selection check */
      break;
24013206:	e017      	b.n	24013238 <HAL_RCCEx_PeriphCLKConfig+0x220>

    case RCC_SAI4ACLKSOURCE_PLL2: /* PLL2 is used as clock source for SAI2*/

      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
24013208:	687b      	ldr	r3, [r7, #4]
2401320a:	3304      	adds	r3, #4
2401320c:	2100      	movs	r1, #0
2401320e:	4618      	mov	r0, r3
24013210:	f002 f810 	bl	24015234 <RCCEx_PLL2_Config>
24013214:	4603      	mov	r3, r0
24013216:	75fb      	strb	r3, [r7, #23]

      /* SAI2 clock source configuration done later after clock selection check */
      break;
24013218:	e00e      	b.n	24013238 <HAL_RCCEx_PeriphCLKConfig+0x220>

    case RCC_SAI4ACLKSOURCE_PLL3:  /* PLL3 is used as clock source for SAI2*/
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_P_UPDATE);
2401321a:	687b      	ldr	r3, [r7, #4]
2401321c:	3324      	adds	r3, #36	; 0x24
2401321e:	2100      	movs	r1, #0
24013220:	4618      	mov	r0, r3
24013222:	f002 f8b9 	bl	24015398 <RCCEx_PLL3_Config>
24013226:	4603      	mov	r3, r0
24013228:	75fb      	strb	r3, [r7, #23]

      /* SAI1 clock source configuration done later after clock selection check */
      break;
2401322a:	e005      	b.n	24013238 <HAL_RCCEx_PeriphCLKConfig+0x220>
      /* HSI, HSE, or CSI oscillator is used as source of SAI2 clock */
      /* SAI1 clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
2401322c:	2301      	movs	r3, #1
2401322e:	75fb      	strb	r3, [r7, #23]
      break;
24013230:	e002      	b.n	24013238 <HAL_RCCEx_PeriphCLKConfig+0x220>
      break;
24013232:	bf00      	nop
24013234:	e000      	b.n	24013238 <HAL_RCCEx_PeriphCLKConfig+0x220>
      break;
24013236:	bf00      	nop
    }

    if(ret == HAL_OK)
24013238:	7dfb      	ldrb	r3, [r7, #23]
2401323a:	2b00      	cmp	r3, #0
2401323c:	d10a      	bne.n	24013254 <HAL_RCCEx_PeriphCLKConfig+0x23c>
    {
      /* Set the source of SAI4A clock*/
      __HAL_RCC_SAI4A_CONFIG(PeriphClkInit->Sai4AClockSelection);
2401323e:	4b36      	ldr	r3, [pc, #216]	; (24013318 <HAL_RCCEx_PeriphCLKConfig+0x300>)
24013240:	6d9b      	ldr	r3, [r3, #88]	; 0x58
24013242:	f423 0260 	bic.w	r2, r3, #14680064	; 0xe00000
24013246:	687b      	ldr	r3, [r7, #4]
24013248:	f8d3 30a4 	ldr.w	r3, [r3, #164]	; 0xa4
2401324c:	4932      	ldr	r1, [pc, #200]	; (24013318 <HAL_RCCEx_PeriphCLKConfig+0x300>)
2401324e:	4313      	orrs	r3, r2
24013250:	658b      	str	r3, [r1, #88]	; 0x58
24013252:	e001      	b.n	24013258 <HAL_RCCEx_PeriphCLKConfig+0x240>
    }
    else
    {
      /* set overall return value */
      status = ret;
24013254:	7dfb      	ldrb	r3, [r7, #23]
24013256:	75bb      	strb	r3, [r7, #22]
    }
  }
  /*---------------------------- SAI4B configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI4B) == RCC_PERIPHCLK_SAI4B)
24013258:	687b      	ldr	r3, [r7, #4]
2401325a:	681b      	ldr	r3, [r3, #0]
2401325c:	f403 6300 	and.w	r3, r3, #2048	; 0x800
24013260:	2b00      	cmp	r3, #0
24013262:	d044      	beq.n	240132ee <HAL_RCCEx_PeriphCLKConfig+0x2d6>
  {
    switch(PeriphClkInit->Sai4BClockSelection)
24013264:	687b      	ldr	r3, [r7, #4]
24013266:	f8d3 30a8 	ldr.w	r3, [r3, #168]	; 0xa8
2401326a:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
2401326e:	d01f      	beq.n	240132b0 <HAL_RCCEx_PeriphCLKConfig+0x298>
24013270:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
24013274:	d805      	bhi.n	24013282 <HAL_RCCEx_PeriphCLKConfig+0x26a>
24013276:	2b00      	cmp	r3, #0
24013278:	d00a      	beq.n	24013290 <HAL_RCCEx_PeriphCLKConfig+0x278>
2401327a:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
2401327e:	d00e      	beq.n	2401329e <HAL_RCCEx_PeriphCLKConfig+0x286>
24013280:	e01f      	b.n	240132c2 <HAL_RCCEx_PeriphCLKConfig+0x2aa>
24013282:	f1b3 7f40 	cmp.w	r3, #50331648	; 0x3000000
24013286:	d01f      	beq.n	240132c8 <HAL_RCCEx_PeriphCLKConfig+0x2b0>
24013288:	f1b3 6f80 	cmp.w	r3, #67108864	; 0x4000000
2401328c:	d01e      	beq.n	240132cc <HAL_RCCEx_PeriphCLKConfig+0x2b4>
2401328e:	e018      	b.n	240132c2 <HAL_RCCEx_PeriphCLKConfig+0x2aa>
    {
    case RCC_SAI4BCLKSOURCE_PLL:      /* PLL is used as clock source for SAI2*/
      /* Enable SAI Clock output generated form System PLL . */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
24013290:	4b21      	ldr	r3, [pc, #132]	; (24013318 <HAL_RCCEx_PeriphCLKConfig+0x300>)
24013292:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24013294:	4a20      	ldr	r2, [pc, #128]	; (24013318 <HAL_RCCEx_PeriphCLKConfig+0x300>)
24013296:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
2401329a:	62d3      	str	r3, [r2, #44]	; 0x2c

      /* SAI1 clock source configuration done later after clock selection check */
      break;
2401329c:	e017      	b.n	240132ce <HAL_RCCEx_PeriphCLKConfig+0x2b6>

    case RCC_SAI4BCLKSOURCE_PLL2: /* PLL2 is used as clock source for SAI2*/

      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
2401329e:	687b      	ldr	r3, [r7, #4]
240132a0:	3304      	adds	r3, #4
240132a2:	2100      	movs	r1, #0
240132a4:	4618      	mov	r0, r3
240132a6:	f001 ffc5 	bl	24015234 <RCCEx_PLL2_Config>
240132aa:	4603      	mov	r3, r0
240132ac:	75fb      	strb	r3, [r7, #23]

      /* SAI2 clock source configuration done later after clock selection check */
      break;
240132ae:	e00e      	b.n	240132ce <HAL_RCCEx_PeriphCLKConfig+0x2b6>

    case RCC_SAI4BCLKSOURCE_PLL3:  /* PLL3 is used as clock source for SAI2*/
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_P_UPDATE);
240132b0:	687b      	ldr	r3, [r7, #4]
240132b2:	3324      	adds	r3, #36	; 0x24
240132b4:	2100      	movs	r1, #0
240132b6:	4618      	mov	r0, r3
240132b8:	f002 f86e 	bl	24015398 <RCCEx_PLL3_Config>
240132bc:	4603      	mov	r3, r0
240132be:	75fb      	strb	r3, [r7, #23]

      /* SAI1 clock source configuration done later after clock selection check */
      break;
240132c0:	e005      	b.n	240132ce <HAL_RCCEx_PeriphCLKConfig+0x2b6>
      /* HSI, HSE, or CSI oscillator is used as source of SAI2 clock */
      /* SAI1 clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
240132c2:	2301      	movs	r3, #1
240132c4:	75fb      	strb	r3, [r7, #23]
      break;
240132c6:	e002      	b.n	240132ce <HAL_RCCEx_PeriphCLKConfig+0x2b6>
      break;
240132c8:	bf00      	nop
240132ca:	e000      	b.n	240132ce <HAL_RCCEx_PeriphCLKConfig+0x2b6>
      break;
240132cc:	bf00      	nop
    }

    if(ret == HAL_OK)
240132ce:	7dfb      	ldrb	r3, [r7, #23]
240132d0:	2b00      	cmp	r3, #0
240132d2:	d10a      	bne.n	240132ea <HAL_RCCEx_PeriphCLKConfig+0x2d2>
    {
      /* Set the source of SAI4B clock*/
      __HAL_RCC_SAI4B_CONFIG(PeriphClkInit->Sai4BClockSelection);
240132d4:	4b10      	ldr	r3, [pc, #64]	; (24013318 <HAL_RCCEx_PeriphCLKConfig+0x300>)
240132d6:	6d9b      	ldr	r3, [r3, #88]	; 0x58
240132d8:	f023 62e0 	bic.w	r2, r3, #117440512	; 0x7000000
240132dc:	687b      	ldr	r3, [r7, #4]
240132de:	f8d3 30a8 	ldr.w	r3, [r3, #168]	; 0xa8
240132e2:	490d      	ldr	r1, [pc, #52]	; (24013318 <HAL_RCCEx_PeriphCLKConfig+0x300>)
240132e4:	4313      	orrs	r3, r2
240132e6:	658b      	str	r3, [r1, #88]	; 0x58
240132e8:	e001      	b.n	240132ee <HAL_RCCEx_PeriphCLKConfig+0x2d6>
    }
    else
    {
      /* set overall return value */
      status = ret;
240132ea:	7dfb      	ldrb	r3, [r7, #23]
240132ec:	75bb      	strb	r3, [r7, #22]
  }
#endif  /*SAI4*/

#if defined(QUADSPI)
  /*---------------------------- QSPI configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_QSPI) == RCC_PERIPHCLK_QSPI)
240132ee:	687b      	ldr	r3, [r7, #4]
240132f0:	681b      	ldr	r3, [r3, #0]
240132f2:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
240132f6:	2b00      	cmp	r3, #0
240132f8:	d035      	beq.n	24013366 <HAL_RCCEx_PeriphCLKConfig+0x34e>
  {
    switch(PeriphClkInit->QspiClockSelection)
240132fa:	687b      	ldr	r3, [r7, #4]
240132fc:	6c9b      	ldr	r3, [r3, #72]	; 0x48
240132fe:	2b10      	cmp	r3, #16
24013300:	d00c      	beq.n	2401331c <HAL_RCCEx_PeriphCLKConfig+0x304>
24013302:	2b10      	cmp	r3, #16
24013304:	d802      	bhi.n	2401330c <HAL_RCCEx_PeriphCLKConfig+0x2f4>
24013306:	2b00      	cmp	r3, #0
24013308:	d01b      	beq.n	24013342 <HAL_RCCEx_PeriphCLKConfig+0x32a>
2401330a:	e017      	b.n	2401333c <HAL_RCCEx_PeriphCLKConfig+0x324>
2401330c:	2b20      	cmp	r3, #32
2401330e:	d00c      	beq.n	2401332a <HAL_RCCEx_PeriphCLKConfig+0x312>
24013310:	2b30      	cmp	r3, #48	; 0x30
24013312:	d018      	beq.n	24013346 <HAL_RCCEx_PeriphCLKConfig+0x32e>
24013314:	e012      	b.n	2401333c <HAL_RCCEx_PeriphCLKConfig+0x324>
24013316:	bf00      	nop
24013318:	58024400 	.word	0x58024400
    {
    case RCC_QSPICLKSOURCE_PLL:      /* PLL is used as clock source for QSPI*/
      /* Enable QSPI Clock output generated form System PLL . */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
2401331c:	4baf      	ldr	r3, [pc, #700]	; (240135dc <HAL_RCCEx_PeriphCLKConfig+0x5c4>)
2401331e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24013320:	4aae      	ldr	r2, [pc, #696]	; (240135dc <HAL_RCCEx_PeriphCLKConfig+0x5c4>)
24013322:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
24013326:	62d3      	str	r3, [r2, #44]	; 0x2c

      /* QSPI clock source configuration done later after clock selection check */
      break;
24013328:	e00e      	b.n	24013348 <HAL_RCCEx_PeriphCLKConfig+0x330>

    case RCC_QSPICLKSOURCE_PLL2: /* PLL2 is used as clock source for QSPI*/

      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_R_UPDATE);
2401332a:	687b      	ldr	r3, [r7, #4]
2401332c:	3304      	adds	r3, #4
2401332e:	2102      	movs	r1, #2
24013330:	4618      	mov	r0, r3
24013332:	f001 ff7f 	bl	24015234 <RCCEx_PLL2_Config>
24013336:	4603      	mov	r3, r0
24013338:	75fb      	strb	r3, [r7, #23]

      /* QSPI clock source configuration done later after clock selection check */
      break;
2401333a:	e005      	b.n	24013348 <HAL_RCCEx_PeriphCLKConfig+0x330>
    case RCC_QSPICLKSOURCE_D1HCLK:
      /* Domain1 HCLK  clock selected as QSPI kernel peripheral clock */
      break;

    default:
      ret = HAL_ERROR;
2401333c:	2301      	movs	r3, #1
2401333e:	75fb      	strb	r3, [r7, #23]
      break;
24013340:	e002      	b.n	24013348 <HAL_RCCEx_PeriphCLKConfig+0x330>
      break;
24013342:	bf00      	nop
24013344:	e000      	b.n	24013348 <HAL_RCCEx_PeriphCLKConfig+0x330>
      break;
24013346:	bf00      	nop
    }

    if(ret == HAL_OK)
24013348:	7dfb      	ldrb	r3, [r7, #23]
2401334a:	2b00      	cmp	r3, #0
2401334c:	d109      	bne.n	24013362 <HAL_RCCEx_PeriphCLKConfig+0x34a>
    {
      /* Set the source of QSPI clock*/
      __HAL_RCC_QSPI_CONFIG(PeriphClkInit->QspiClockSelection);
2401334e:	4ba3      	ldr	r3, [pc, #652]	; (240135dc <HAL_RCCEx_PeriphCLKConfig+0x5c4>)
24013350:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
24013352:	f023 0230 	bic.w	r2, r3, #48	; 0x30
24013356:	687b      	ldr	r3, [r7, #4]
24013358:	6c9b      	ldr	r3, [r3, #72]	; 0x48
2401335a:	49a0      	ldr	r1, [pc, #640]	; (240135dc <HAL_RCCEx_PeriphCLKConfig+0x5c4>)
2401335c:	4313      	orrs	r3, r2
2401335e:	64cb      	str	r3, [r1, #76]	; 0x4c
24013360:	e001      	b.n	24013366 <HAL_RCCEx_PeriphCLKConfig+0x34e>
    }
    else
    {
      /* set overall return value */
      status = ret;
24013362:	7dfb      	ldrb	r3, [r7, #23]
24013364:	75bb      	strb	r3, [r7, #22]
    }
  }
#endif  /*OCTOSPI*/

  /*---------------------------- SPI1/2/3 configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI123) == RCC_PERIPHCLK_SPI123)
24013366:	687b      	ldr	r3, [r7, #4]
24013368:	681b      	ldr	r3, [r3, #0]
2401336a:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
2401336e:	2b00      	cmp	r3, #0
24013370:	d042      	beq.n	240133f8 <HAL_RCCEx_PeriphCLKConfig+0x3e0>
  {
    switch(PeriphClkInit->Spi123ClockSelection)
24013372:	687b      	ldr	r3, [r7, #4]
24013374:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24013376:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
2401337a:	d01f      	beq.n	240133bc <HAL_RCCEx_PeriphCLKConfig+0x3a4>
2401337c:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
24013380:	d805      	bhi.n	2401338e <HAL_RCCEx_PeriphCLKConfig+0x376>
24013382:	2b00      	cmp	r3, #0
24013384:	d00a      	beq.n	2401339c <HAL_RCCEx_PeriphCLKConfig+0x384>
24013386:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
2401338a:	d00e      	beq.n	240133aa <HAL_RCCEx_PeriphCLKConfig+0x392>
2401338c:	e01f      	b.n	240133ce <HAL_RCCEx_PeriphCLKConfig+0x3b6>
2401338e:	f5b3 5f40 	cmp.w	r3, #12288	; 0x3000
24013392:	d01f      	beq.n	240133d4 <HAL_RCCEx_PeriphCLKConfig+0x3bc>
24013394:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
24013398:	d01e      	beq.n	240133d8 <HAL_RCCEx_PeriphCLKConfig+0x3c0>
2401339a:	e018      	b.n	240133ce <HAL_RCCEx_PeriphCLKConfig+0x3b6>
    {
    case RCC_SPI123CLKSOURCE_PLL:      /* PLL is used as clock source for SPI1/2/3 */
      /* Enable SPI Clock output generated form System PLL . */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
2401339c:	4b8f      	ldr	r3, [pc, #572]	; (240135dc <HAL_RCCEx_PeriphCLKConfig+0x5c4>)
2401339e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
240133a0:	4a8e      	ldr	r2, [pc, #568]	; (240135dc <HAL_RCCEx_PeriphCLKConfig+0x5c4>)
240133a2:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
240133a6:	62d3      	str	r3, [r2, #44]	; 0x2c

      /* SPI1/2/3 clock source configuration done later after clock selection check */
      break;
240133a8:	e017      	b.n	240133da <HAL_RCCEx_PeriphCLKConfig+0x3c2>

    case RCC_SPI123CLKSOURCE_PLL2: /* PLL2 is used as clock source for SPI1/2/3 */
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
240133aa:	687b      	ldr	r3, [r7, #4]
240133ac:	3304      	adds	r3, #4
240133ae:	2100      	movs	r1, #0
240133b0:	4618      	mov	r0, r3
240133b2:	f001 ff3f 	bl	24015234 <RCCEx_PLL2_Config>
240133b6:	4603      	mov	r3, r0
240133b8:	75fb      	strb	r3, [r7, #23]

      /* SPI1/2/3 clock source configuration done later after clock selection check */
      break;
240133ba:	e00e      	b.n	240133da <HAL_RCCEx_PeriphCLKConfig+0x3c2>

    case RCC_SPI123CLKSOURCE_PLL3:  /* PLL3 is used as clock source for SPI1/2/3 */
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_P_UPDATE);
240133bc:	687b      	ldr	r3, [r7, #4]
240133be:	3324      	adds	r3, #36	; 0x24
240133c0:	2100      	movs	r1, #0
240133c2:	4618      	mov	r0, r3
240133c4:	f001 ffe8 	bl	24015398 <RCCEx_PLL3_Config>
240133c8:	4603      	mov	r3, r0
240133ca:	75fb      	strb	r3, [r7, #23]

      /* SPI1/2/3 clock source configuration done later after clock selection check */
      break;
240133cc:	e005      	b.n	240133da <HAL_RCCEx_PeriphCLKConfig+0x3c2>
      /* HSI, HSE, or CSI oscillator is used as source of SPI1/2/3 clock */
      /* SPI1/2/3 clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
240133ce:	2301      	movs	r3, #1
240133d0:	75fb      	strb	r3, [r7, #23]
      break;
240133d2:	e002      	b.n	240133da <HAL_RCCEx_PeriphCLKConfig+0x3c2>
      break;
240133d4:	bf00      	nop
240133d6:	e000      	b.n	240133da <HAL_RCCEx_PeriphCLKConfig+0x3c2>
      break;
240133d8:	bf00      	nop
    }

    if(ret == HAL_OK)
240133da:	7dfb      	ldrb	r3, [r7, #23]
240133dc:	2b00      	cmp	r3, #0
240133de:	d109      	bne.n	240133f4 <HAL_RCCEx_PeriphCLKConfig+0x3dc>
    {
      /* Set the source of SPI1/2/3 clock*/
      __HAL_RCC_SPI123_CONFIG(PeriphClkInit->Spi123ClockSelection);
240133e0:	4b7e      	ldr	r3, [pc, #504]	; (240135dc <HAL_RCCEx_PeriphCLKConfig+0x5c4>)
240133e2:	6d1b      	ldr	r3, [r3, #80]	; 0x50
240133e4:	f423 42e0 	bic.w	r2, r3, #28672	; 0x7000
240133e8:	687b      	ldr	r3, [r7, #4]
240133ea:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
240133ec:	497b      	ldr	r1, [pc, #492]	; (240135dc <HAL_RCCEx_PeriphCLKConfig+0x5c4>)
240133ee:	4313      	orrs	r3, r2
240133f0:	650b      	str	r3, [r1, #80]	; 0x50
240133f2:	e001      	b.n	240133f8 <HAL_RCCEx_PeriphCLKConfig+0x3e0>
    }
    else
    {
      /* set overall return value */
      status = ret;
240133f4:	7dfb      	ldrb	r3, [r7, #23]
240133f6:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*---------------------------- SPI4/5 configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI45) == RCC_PERIPHCLK_SPI45)
240133f8:	687b      	ldr	r3, [r7, #4]
240133fa:	681b      	ldr	r3, [r3, #0]
240133fc:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
24013400:	2b00      	cmp	r3, #0
24013402:	d042      	beq.n	2401348a <HAL_RCCEx_PeriphCLKConfig+0x472>
  {
    switch(PeriphClkInit->Spi45ClockSelection)
24013404:	687b      	ldr	r3, [r7, #4]
24013406:	6e1b      	ldr	r3, [r3, #96]	; 0x60
24013408:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
2401340c:	d01b      	beq.n	24013446 <HAL_RCCEx_PeriphCLKConfig+0x42e>
2401340e:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
24013412:	d805      	bhi.n	24013420 <HAL_RCCEx_PeriphCLKConfig+0x408>
24013414:	2b00      	cmp	r3, #0
24013416:	d022      	beq.n	2401345e <HAL_RCCEx_PeriphCLKConfig+0x446>
24013418:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
2401341c:	d00a      	beq.n	24013434 <HAL_RCCEx_PeriphCLKConfig+0x41c>
2401341e:	e01b      	b.n	24013458 <HAL_RCCEx_PeriphCLKConfig+0x440>
24013420:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
24013424:	d01d      	beq.n	24013462 <HAL_RCCEx_PeriphCLKConfig+0x44a>
24013426:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
2401342a:	d01c      	beq.n	24013466 <HAL_RCCEx_PeriphCLKConfig+0x44e>
2401342c:	f5b3 3f40 	cmp.w	r3, #196608	; 0x30000
24013430:	d01b      	beq.n	2401346a <HAL_RCCEx_PeriphCLKConfig+0x452>
24013432:	e011      	b.n	24013458 <HAL_RCCEx_PeriphCLKConfig+0x440>
      /* SPI4/5 clock source configuration done later after clock selection check */
      break;

    case RCC_SPI45CLKSOURCE_PLL2: /* PLL2 is used as clock source for SPI4/5 */

      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_Q_UPDATE);
24013434:	687b      	ldr	r3, [r7, #4]
24013436:	3304      	adds	r3, #4
24013438:	2101      	movs	r1, #1
2401343a:	4618      	mov	r0, r3
2401343c:	f001 fefa 	bl	24015234 <RCCEx_PLL2_Config>
24013440:	4603      	mov	r3, r0
24013442:	75fb      	strb	r3, [r7, #23]

      /* SPI4/5 clock source configuration done later after clock selection check */
      break;
24013444:	e012      	b.n	2401346c <HAL_RCCEx_PeriphCLKConfig+0x454>
    case RCC_SPI45CLKSOURCE_PLL3:  /* PLL3 is used as clock source for SPI4/5 */
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);
24013446:	687b      	ldr	r3, [r7, #4]
24013448:	3324      	adds	r3, #36	; 0x24
2401344a:	2101      	movs	r1, #1
2401344c:	4618      	mov	r0, r3
2401344e:	f001 ffa3 	bl	24015398 <RCCEx_PLL3_Config>
24013452:	4603      	mov	r3, r0
24013454:	75fb      	strb	r3, [r7, #23]
      /* SPI4/5 clock source configuration done later after clock selection check */
      break;
24013456:	e009      	b.n	2401346c <HAL_RCCEx_PeriphCLKConfig+0x454>
      /* HSE,  oscillator is used as source of SPI4/5 clock */
      /* SPI4/5 clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
24013458:	2301      	movs	r3, #1
2401345a:	75fb      	strb	r3, [r7, #23]
      break;
2401345c:	e006      	b.n	2401346c <HAL_RCCEx_PeriphCLKConfig+0x454>
      break;
2401345e:	bf00      	nop
24013460:	e004      	b.n	2401346c <HAL_RCCEx_PeriphCLKConfig+0x454>
      break;
24013462:	bf00      	nop
24013464:	e002      	b.n	2401346c <HAL_RCCEx_PeriphCLKConfig+0x454>
      break;
24013466:	bf00      	nop
24013468:	e000      	b.n	2401346c <HAL_RCCEx_PeriphCLKConfig+0x454>
      break;
2401346a:	bf00      	nop
    }

    if(ret == HAL_OK)
2401346c:	7dfb      	ldrb	r3, [r7, #23]
2401346e:	2b00      	cmp	r3, #0
24013470:	d109      	bne.n	24013486 <HAL_RCCEx_PeriphCLKConfig+0x46e>
    {
      /* Set the source of SPI4/5 clock*/
      __HAL_RCC_SPI45_CONFIG(PeriphClkInit->Spi45ClockSelection);
24013472:	4b5a      	ldr	r3, [pc, #360]	; (240135dc <HAL_RCCEx_PeriphCLKConfig+0x5c4>)
24013474:	6d1b      	ldr	r3, [r3, #80]	; 0x50
24013476:	f423 22e0 	bic.w	r2, r3, #458752	; 0x70000
2401347a:	687b      	ldr	r3, [r7, #4]
2401347c:	6e1b      	ldr	r3, [r3, #96]	; 0x60
2401347e:	4957      	ldr	r1, [pc, #348]	; (240135dc <HAL_RCCEx_PeriphCLKConfig+0x5c4>)
24013480:	4313      	orrs	r3, r2
24013482:	650b      	str	r3, [r1, #80]	; 0x50
24013484:	e001      	b.n	2401348a <HAL_RCCEx_PeriphCLKConfig+0x472>
    }
    else
    {
      /* set overall return value */
      status = ret;
24013486:	7dfb      	ldrb	r3, [r7, #23]
24013488:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*---------------------------- SPI6 configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI6) == RCC_PERIPHCLK_SPI6)
2401348a:	687b      	ldr	r3, [r7, #4]
2401348c:	681b      	ldr	r3, [r3, #0]
2401348e:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
24013492:	2b00      	cmp	r3, #0
24013494:	d044      	beq.n	24013520 <HAL_RCCEx_PeriphCLKConfig+0x508>
  {
    switch(PeriphClkInit->Spi6ClockSelection)
24013496:	687b      	ldr	r3, [r7, #4]
24013498:	f8d3 30ac 	ldr.w	r3, [r3, #172]	; 0xac
2401349c:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
240134a0:	d01b      	beq.n	240134da <HAL_RCCEx_PeriphCLKConfig+0x4c2>
240134a2:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
240134a6:	d805      	bhi.n	240134b4 <HAL_RCCEx_PeriphCLKConfig+0x49c>
240134a8:	2b00      	cmp	r3, #0
240134aa:	d022      	beq.n	240134f2 <HAL_RCCEx_PeriphCLKConfig+0x4da>
240134ac:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
240134b0:	d00a      	beq.n	240134c8 <HAL_RCCEx_PeriphCLKConfig+0x4b0>
240134b2:	e01b      	b.n	240134ec <HAL_RCCEx_PeriphCLKConfig+0x4d4>
240134b4:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
240134b8:	d01d      	beq.n	240134f6 <HAL_RCCEx_PeriphCLKConfig+0x4de>
240134ba:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
240134be:	d01c      	beq.n	240134fa <HAL_RCCEx_PeriphCLKConfig+0x4e2>
240134c0:	f1b3 5f40 	cmp.w	r3, #805306368	; 0x30000000
240134c4:	d01b      	beq.n	240134fe <HAL_RCCEx_PeriphCLKConfig+0x4e6>
240134c6:	e011      	b.n	240134ec <HAL_RCCEx_PeriphCLKConfig+0x4d4>
      /* SPI6 clock source configuration done later after clock selection check */
      break;

    case RCC_SPI6CLKSOURCE_PLL2: /* PLL2 is used as clock source for SPI6*/

      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_Q_UPDATE);
240134c8:	687b      	ldr	r3, [r7, #4]
240134ca:	3304      	adds	r3, #4
240134cc:	2101      	movs	r1, #1
240134ce:	4618      	mov	r0, r3
240134d0:	f001 feb0 	bl	24015234 <RCCEx_PLL2_Config>
240134d4:	4603      	mov	r3, r0
240134d6:	75fb      	strb	r3, [r7, #23]

      /* SPI6 clock source configuration done later after clock selection check */
      break;
240134d8:	e012      	b.n	24013500 <HAL_RCCEx_PeriphCLKConfig+0x4e8>
    case RCC_SPI6CLKSOURCE_PLL3:  /* PLL3 is used as clock source for SPI6*/
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);
240134da:	687b      	ldr	r3, [r7, #4]
240134dc:	3324      	adds	r3, #36	; 0x24
240134de:	2101      	movs	r1, #1
240134e0:	4618      	mov	r0, r3
240134e2:	f001 ff59 	bl	24015398 <RCCEx_PLL3_Config>
240134e6:	4603      	mov	r3, r0
240134e8:	75fb      	strb	r3, [r7, #23]
      /* SPI6 clock source configuration done later after clock selection check */
      break;
240134ea:	e009      	b.n	24013500 <HAL_RCCEx_PeriphCLKConfig+0x4e8>
      /* SPI6 clock source configuration done later after clock selection check */
      break;
#endif

    default:
      ret = HAL_ERROR;
240134ec:	2301      	movs	r3, #1
240134ee:	75fb      	strb	r3, [r7, #23]
      break;
240134f0:	e006      	b.n	24013500 <HAL_RCCEx_PeriphCLKConfig+0x4e8>
      break;
240134f2:	bf00      	nop
240134f4:	e004      	b.n	24013500 <HAL_RCCEx_PeriphCLKConfig+0x4e8>
      break;
240134f6:	bf00      	nop
240134f8:	e002      	b.n	24013500 <HAL_RCCEx_PeriphCLKConfig+0x4e8>
      break;
240134fa:	bf00      	nop
240134fc:	e000      	b.n	24013500 <HAL_RCCEx_PeriphCLKConfig+0x4e8>
      break;
240134fe:	bf00      	nop
    }

    if(ret == HAL_OK)
24013500:	7dfb      	ldrb	r3, [r7, #23]
24013502:	2b00      	cmp	r3, #0
24013504:	d10a      	bne.n	2401351c <HAL_RCCEx_PeriphCLKConfig+0x504>
    {
      /* Set the source of SPI6 clock*/
      __HAL_RCC_SPI6_CONFIG(PeriphClkInit->Spi6ClockSelection);
24013506:	4b35      	ldr	r3, [pc, #212]	; (240135dc <HAL_RCCEx_PeriphCLKConfig+0x5c4>)
24013508:	6d9b      	ldr	r3, [r3, #88]	; 0x58
2401350a:	f023 42e0 	bic.w	r2, r3, #1879048192	; 0x70000000
2401350e:	687b      	ldr	r3, [r7, #4]
24013510:	f8d3 30ac 	ldr.w	r3, [r3, #172]	; 0xac
24013514:	4931      	ldr	r1, [pc, #196]	; (240135dc <HAL_RCCEx_PeriphCLKConfig+0x5c4>)
24013516:	4313      	orrs	r3, r2
24013518:	658b      	str	r3, [r1, #88]	; 0x58
2401351a:	e001      	b.n	24013520 <HAL_RCCEx_PeriphCLKConfig+0x508>
    }
    else
    {
      /* set overall return value */
      status = ret;
2401351c:	7dfb      	ldrb	r3, [r7, #23]
2401351e:	75bb      	strb	r3, [r7, #22]
  }
#endif /*DSI*/

#if defined(FDCAN1) || defined(FDCAN2)
  /*---------------------------- FDCAN configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_FDCAN) == RCC_PERIPHCLK_FDCAN)
24013520:	687b      	ldr	r3, [r7, #4]
24013522:	681b      	ldr	r3, [r3, #0]
24013524:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
24013528:	2b00      	cmp	r3, #0
2401352a:	d02d      	beq.n	24013588 <HAL_RCCEx_PeriphCLKConfig+0x570>
  {
    switch(PeriphClkInit->FdcanClockSelection)
2401352c:	687b      	ldr	r3, [r7, #4]
2401352e:	6edb      	ldr	r3, [r3, #108]	; 0x6c
24013530:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
24013534:	d005      	beq.n	24013542 <HAL_RCCEx_PeriphCLKConfig+0x52a>
24013536:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
2401353a:	d009      	beq.n	24013550 <HAL_RCCEx_PeriphCLKConfig+0x538>
2401353c:	2b00      	cmp	r3, #0
2401353e:	d013      	beq.n	24013568 <HAL_RCCEx_PeriphCLKConfig+0x550>
24013540:	e00f      	b.n	24013562 <HAL_RCCEx_PeriphCLKConfig+0x54a>
    {
    case RCC_FDCANCLKSOURCE_PLL:      /* PLL is used as clock source for FDCAN*/
      /* Enable FDCAN Clock output generated form System PLL . */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
24013542:	4b26      	ldr	r3, [pc, #152]	; (240135dc <HAL_RCCEx_PeriphCLKConfig+0x5c4>)
24013544:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24013546:	4a25      	ldr	r2, [pc, #148]	; (240135dc <HAL_RCCEx_PeriphCLKConfig+0x5c4>)
24013548:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
2401354c:	62d3      	str	r3, [r2, #44]	; 0x2c

      /* FDCAN clock source configuration done later after clock selection check */
      break;
2401354e:	e00c      	b.n	2401356a <HAL_RCCEx_PeriphCLKConfig+0x552>

    case RCC_FDCANCLKSOURCE_PLL2: /* PLL2 is used as clock source for FDCAN*/

      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_Q_UPDATE);
24013550:	687b      	ldr	r3, [r7, #4]
24013552:	3304      	adds	r3, #4
24013554:	2101      	movs	r1, #1
24013556:	4618      	mov	r0, r3
24013558:	f001 fe6c 	bl	24015234 <RCCEx_PLL2_Config>
2401355c:	4603      	mov	r3, r0
2401355e:	75fb      	strb	r3, [r7, #23]

      /* FDCAN clock source configuration done later after clock selection check */
      break;
24013560:	e003      	b.n	2401356a <HAL_RCCEx_PeriphCLKConfig+0x552>
      /* HSE is used as clock source for FDCAN*/
      /* FDCAN clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
24013562:	2301      	movs	r3, #1
24013564:	75fb      	strb	r3, [r7, #23]
      break;
24013566:	e000      	b.n	2401356a <HAL_RCCEx_PeriphCLKConfig+0x552>
      break;
24013568:	bf00      	nop
    }

    if(ret == HAL_OK)
2401356a:	7dfb      	ldrb	r3, [r7, #23]
2401356c:	2b00      	cmp	r3, #0
2401356e:	d109      	bne.n	24013584 <HAL_RCCEx_PeriphCLKConfig+0x56c>
    {
      /* Set the source of FDCAN clock*/
      __HAL_RCC_FDCAN_CONFIG(PeriphClkInit->FdcanClockSelection);
24013570:	4b1a      	ldr	r3, [pc, #104]	; (240135dc <HAL_RCCEx_PeriphCLKConfig+0x5c4>)
24013572:	6d1b      	ldr	r3, [r3, #80]	; 0x50
24013574:	f023 5240 	bic.w	r2, r3, #805306368	; 0x30000000
24013578:	687b      	ldr	r3, [r7, #4]
2401357a:	6edb      	ldr	r3, [r3, #108]	; 0x6c
2401357c:	4917      	ldr	r1, [pc, #92]	; (240135dc <HAL_RCCEx_PeriphCLKConfig+0x5c4>)
2401357e:	4313      	orrs	r3, r2
24013580:	650b      	str	r3, [r1, #80]	; 0x50
24013582:	e001      	b.n	24013588 <HAL_RCCEx_PeriphCLKConfig+0x570>
    }
    else
    {
      /* set overall return value */
      status = ret;
24013584:	7dfb      	ldrb	r3, [r7, #23]
24013586:	75bb      	strb	r3, [r7, #22]
    }
  }
#endif /*FDCAN1 || FDCAN2*/

  /*---------------------------- FMC configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_FMC) == RCC_PERIPHCLK_FMC)
24013588:	687b      	ldr	r3, [r7, #4]
2401358a:	681b      	ldr	r3, [r3, #0]
2401358c:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
24013590:	2b00      	cmp	r3, #0
24013592:	d035      	beq.n	24013600 <HAL_RCCEx_PeriphCLKConfig+0x5e8>
  {
    switch(PeriphClkInit->FmcClockSelection)
24013594:	687b      	ldr	r3, [r7, #4]
24013596:	6c5b      	ldr	r3, [r3, #68]	; 0x44
24013598:	2b03      	cmp	r3, #3
2401359a:	d81b      	bhi.n	240135d4 <HAL_RCCEx_PeriphCLKConfig+0x5bc>
2401359c:	a201      	add	r2, pc, #4	; (adr r2, 240135a4 <HAL_RCCEx_PeriphCLKConfig+0x58c>)
2401359e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
240135a2:	bf00      	nop
240135a4:	240135e1 	.word	0x240135e1
240135a8:	240135b5 	.word	0x240135b5
240135ac:	240135c3 	.word	0x240135c3
240135b0:	240135e1 	.word	0x240135e1
    {
    case RCC_FMCCLKSOURCE_PLL:      /* PLL is used as clock source for FMC*/
      /* Enable FMC Clock output generated form System PLL . */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
240135b4:	4b09      	ldr	r3, [pc, #36]	; (240135dc <HAL_RCCEx_PeriphCLKConfig+0x5c4>)
240135b6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
240135b8:	4a08      	ldr	r2, [pc, #32]	; (240135dc <HAL_RCCEx_PeriphCLKConfig+0x5c4>)
240135ba:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
240135be:	62d3      	str	r3, [r2, #44]	; 0x2c

      /* FMC clock source configuration done later after clock selection check */
      break;
240135c0:	e00f      	b.n	240135e2 <HAL_RCCEx_PeriphCLKConfig+0x5ca>

    case RCC_FMCCLKSOURCE_PLL2: /* PLL2 is used as clock source for FMC*/

      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_R_UPDATE);
240135c2:	687b      	ldr	r3, [r7, #4]
240135c4:	3304      	adds	r3, #4
240135c6:	2102      	movs	r1, #2
240135c8:	4618      	mov	r0, r3
240135ca:	f001 fe33 	bl	24015234 <RCCEx_PLL2_Config>
240135ce:	4603      	mov	r3, r0
240135d0:	75fb      	strb	r3, [r7, #23]

      /* FMC clock source configuration done later after clock selection check */
      break;
240135d2:	e006      	b.n	240135e2 <HAL_RCCEx_PeriphCLKConfig+0x5ca>
    case RCC_FMCCLKSOURCE_HCLK:
      /* D1/CD HCLK  clock selected as FMC kernel peripheral clock */
      break;

    default:
      ret = HAL_ERROR;
240135d4:	2301      	movs	r3, #1
240135d6:	75fb      	strb	r3, [r7, #23]
      break;
240135d8:	e003      	b.n	240135e2 <HAL_RCCEx_PeriphCLKConfig+0x5ca>
240135da:	bf00      	nop
240135dc:	58024400 	.word	0x58024400
      break;
240135e0:	bf00      	nop
    }

    if(ret == HAL_OK)
240135e2:	7dfb      	ldrb	r3, [r7, #23]
240135e4:	2b00      	cmp	r3, #0
240135e6:	d109      	bne.n	240135fc <HAL_RCCEx_PeriphCLKConfig+0x5e4>
    {
      /* Set the source of FMC clock*/
      __HAL_RCC_FMC_CONFIG(PeriphClkInit->FmcClockSelection);
240135e8:	4bba      	ldr	r3, [pc, #744]	; (240138d4 <HAL_RCCEx_PeriphCLKConfig+0x8bc>)
240135ea:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
240135ec:	f023 0203 	bic.w	r2, r3, #3
240135f0:	687b      	ldr	r3, [r7, #4]
240135f2:	6c5b      	ldr	r3, [r3, #68]	; 0x44
240135f4:	49b7      	ldr	r1, [pc, #732]	; (240138d4 <HAL_RCCEx_PeriphCLKConfig+0x8bc>)
240135f6:	4313      	orrs	r3, r2
240135f8:	64cb      	str	r3, [r1, #76]	; 0x4c
240135fa:	e001      	b.n	24013600 <HAL_RCCEx_PeriphCLKConfig+0x5e8>
    }
    else
    {
      /* set overall return value */
      status = ret;
240135fc:	7dfb      	ldrb	r3, [r7, #23]
240135fe:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*---------------------------- RTC configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
24013600:	687b      	ldr	r3, [r7, #4]
24013602:	681b      	ldr	r3, [r3, #0]
24013604:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
24013608:	2b00      	cmp	r3, #0
2401360a:	f000 8086 	beq.w	2401371a <HAL_RCCEx_PeriphCLKConfig+0x702>
  {
    /* check for RTC Parameters used to output RTCCLK */
    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));

    /* Enable write access to Backup domain */
    SET_BIT(PWR->CR1, PWR_CR1_DBP);
2401360e:	4bb2      	ldr	r3, [pc, #712]	; (240138d8 <HAL_RCCEx_PeriphCLKConfig+0x8c0>)
24013610:	681b      	ldr	r3, [r3, #0]
24013612:	4ab1      	ldr	r2, [pc, #708]	; (240138d8 <HAL_RCCEx_PeriphCLKConfig+0x8c0>)
24013614:	f443 7380 	orr.w	r3, r3, #256	; 0x100
24013618:	6013      	str	r3, [r2, #0]

    /* Wait for Backup domain Write protection disable */
    tickstart = HAL_GetTick();
2401361a:	f7ed f919 	bl	24000850 <HAL_GetTick>
2401361e:	6138      	str	r0, [r7, #16]

    while((PWR->CR1 & PWR_CR1_DBP) == 0U)
24013620:	e009      	b.n	24013636 <HAL_RCCEx_PeriphCLKConfig+0x61e>
    {
      if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
24013622:	f7ed f915 	bl	24000850 <HAL_GetTick>
24013626:	4602      	mov	r2, r0
24013628:	693b      	ldr	r3, [r7, #16]
2401362a:	1ad3      	subs	r3, r2, r3
2401362c:	2b64      	cmp	r3, #100	; 0x64
2401362e:	d902      	bls.n	24013636 <HAL_RCCEx_PeriphCLKConfig+0x61e>
      {
        ret = HAL_TIMEOUT;
24013630:	2303      	movs	r3, #3
24013632:	75fb      	strb	r3, [r7, #23]
        break;
24013634:	e005      	b.n	24013642 <HAL_RCCEx_PeriphCLKConfig+0x62a>
    while((PWR->CR1 & PWR_CR1_DBP) == 0U)
24013636:	4ba8      	ldr	r3, [pc, #672]	; (240138d8 <HAL_RCCEx_PeriphCLKConfig+0x8c0>)
24013638:	681b      	ldr	r3, [r3, #0]
2401363a:	f403 7380 	and.w	r3, r3, #256	; 0x100
2401363e:	2b00      	cmp	r3, #0
24013640:	d0ef      	beq.n	24013622 <HAL_RCCEx_PeriphCLKConfig+0x60a>
      }
    }

    if(ret == HAL_OK)
24013642:	7dfb      	ldrb	r3, [r7, #23]
24013644:	2b00      	cmp	r3, #0
24013646:	d166      	bne.n	24013716 <HAL_RCCEx_PeriphCLKConfig+0x6fe>
    {
      /* Reset the Backup domain only if the RTC Clock source selection is modified */
      if((RCC->BDCR & RCC_BDCR_RTCSEL) != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL))
24013648:	4ba2      	ldr	r3, [pc, #648]	; (240138d4 <HAL_RCCEx_PeriphCLKConfig+0x8bc>)
2401364a:	6f1a      	ldr	r2, [r3, #112]	; 0x70
2401364c:	687b      	ldr	r3, [r7, #4]
2401364e:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
24013652:	4053      	eors	r3, r2
24013654:	f403 7340 	and.w	r3, r3, #768	; 0x300
24013658:	2b00      	cmp	r3, #0
2401365a:	d013      	beq.n	24013684 <HAL_RCCEx_PeriphCLKConfig+0x66c>
      {
        /* Store the content of BDCR register before the reset of Backup Domain */
        tmpreg = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
2401365c:	4b9d      	ldr	r3, [pc, #628]	; (240138d4 <HAL_RCCEx_PeriphCLKConfig+0x8bc>)
2401365e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
24013660:	f423 7340 	bic.w	r3, r3, #768	; 0x300
24013664:	60fb      	str	r3, [r7, #12]
        /* RTC Clock selection can be changed only if the Backup Domain is reset */
        __HAL_RCC_BACKUPRESET_FORCE();
24013666:	4b9b      	ldr	r3, [pc, #620]	; (240138d4 <HAL_RCCEx_PeriphCLKConfig+0x8bc>)
24013668:	6f1b      	ldr	r3, [r3, #112]	; 0x70
2401366a:	4a9a      	ldr	r2, [pc, #616]	; (240138d4 <HAL_RCCEx_PeriphCLKConfig+0x8bc>)
2401366c:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
24013670:	6713      	str	r3, [r2, #112]	; 0x70
        __HAL_RCC_BACKUPRESET_RELEASE();
24013672:	4b98      	ldr	r3, [pc, #608]	; (240138d4 <HAL_RCCEx_PeriphCLKConfig+0x8bc>)
24013674:	6f1b      	ldr	r3, [r3, #112]	; 0x70
24013676:	4a97      	ldr	r2, [pc, #604]	; (240138d4 <HAL_RCCEx_PeriphCLKConfig+0x8bc>)
24013678:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
2401367c:	6713      	str	r3, [r2, #112]	; 0x70
        /* Restore the Content of BDCR register */
        RCC->BDCR = tmpreg;
2401367e:	4a95      	ldr	r2, [pc, #596]	; (240138d4 <HAL_RCCEx_PeriphCLKConfig+0x8bc>)
24013680:	68fb      	ldr	r3, [r7, #12]
24013682:	6713      	str	r3, [r2, #112]	; 0x70
      }

      /* If LSE is selected as RTC clock source (and enabled prior to Backup Domain reset), wait for LSE reactivation */
      if(PeriphClkInit->RTCClockSelection == RCC_RTCCLKSOURCE_LSE)
24013684:	687b      	ldr	r3, [r7, #4]
24013686:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
2401368a:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
2401368e:	d115      	bne.n	240136bc <HAL_RCCEx_PeriphCLKConfig+0x6a4>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
24013690:	f7ed f8de 	bl	24000850 <HAL_GetTick>
24013694:	6138      	str	r0, [r7, #16]

        /* Wait till LSE is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
24013696:	e00b      	b.n	240136b0 <HAL_RCCEx_PeriphCLKConfig+0x698>
        {
          if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
24013698:	f7ed f8da 	bl	24000850 <HAL_GetTick>
2401369c:	4602      	mov	r2, r0
2401369e:	693b      	ldr	r3, [r7, #16]
240136a0:	1ad3      	subs	r3, r2, r3
240136a2:	f241 3288 	movw	r2, #5000	; 0x1388
240136a6:	4293      	cmp	r3, r2
240136a8:	d902      	bls.n	240136b0 <HAL_RCCEx_PeriphCLKConfig+0x698>
          {
            ret = HAL_TIMEOUT;
240136aa:	2303      	movs	r3, #3
240136ac:	75fb      	strb	r3, [r7, #23]
            break;
240136ae:	e005      	b.n	240136bc <HAL_RCCEx_PeriphCLKConfig+0x6a4>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
240136b0:	4b88      	ldr	r3, [pc, #544]	; (240138d4 <HAL_RCCEx_PeriphCLKConfig+0x8bc>)
240136b2:	6f1b      	ldr	r3, [r3, #112]	; 0x70
240136b4:	f003 0302 	and.w	r3, r3, #2
240136b8:	2b00      	cmp	r3, #0
240136ba:	d0ed      	beq.n	24013698 <HAL_RCCEx_PeriphCLKConfig+0x680>
          }
        }
      }

      if(ret == HAL_OK)
240136bc:	7dfb      	ldrb	r3, [r7, #23]
240136be:	2b00      	cmp	r3, #0
240136c0:	d126      	bne.n	24013710 <HAL_RCCEx_PeriphCLKConfig+0x6f8>
      {
        __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
240136c2:	687b      	ldr	r3, [r7, #4]
240136c4:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
240136c8:	f403 7340 	and.w	r3, r3, #768	; 0x300
240136cc:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
240136d0:	d10d      	bne.n	240136ee <HAL_RCCEx_PeriphCLKConfig+0x6d6>
240136d2:	4b80      	ldr	r3, [pc, #512]	; (240138d4 <HAL_RCCEx_PeriphCLKConfig+0x8bc>)
240136d4:	691b      	ldr	r3, [r3, #16]
240136d6:	f423 527c 	bic.w	r2, r3, #16128	; 0x3f00
240136da:	687b      	ldr	r3, [r7, #4]
240136dc:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
240136e0:	0919      	lsrs	r1, r3, #4
240136e2:	4b7e      	ldr	r3, [pc, #504]	; (240138dc <HAL_RCCEx_PeriphCLKConfig+0x8c4>)
240136e4:	400b      	ands	r3, r1
240136e6:	497b      	ldr	r1, [pc, #492]	; (240138d4 <HAL_RCCEx_PeriphCLKConfig+0x8bc>)
240136e8:	4313      	orrs	r3, r2
240136ea:	610b      	str	r3, [r1, #16]
240136ec:	e005      	b.n	240136fa <HAL_RCCEx_PeriphCLKConfig+0x6e2>
240136ee:	4b79      	ldr	r3, [pc, #484]	; (240138d4 <HAL_RCCEx_PeriphCLKConfig+0x8bc>)
240136f0:	691b      	ldr	r3, [r3, #16]
240136f2:	4a78      	ldr	r2, [pc, #480]	; (240138d4 <HAL_RCCEx_PeriphCLKConfig+0x8bc>)
240136f4:	f423 537c 	bic.w	r3, r3, #16128	; 0x3f00
240136f8:	6113      	str	r3, [r2, #16]
240136fa:	4b76      	ldr	r3, [pc, #472]	; (240138d4 <HAL_RCCEx_PeriphCLKConfig+0x8bc>)
240136fc:	6f1a      	ldr	r2, [r3, #112]	; 0x70
240136fe:	687b      	ldr	r3, [r7, #4]
24013700:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
24013704:	f3c3 030b 	ubfx	r3, r3, #0, #12
24013708:	4972      	ldr	r1, [pc, #456]	; (240138d4 <HAL_RCCEx_PeriphCLKConfig+0x8bc>)
2401370a:	4313      	orrs	r3, r2
2401370c:	670b      	str	r3, [r1, #112]	; 0x70
2401370e:	e004      	b.n	2401371a <HAL_RCCEx_PeriphCLKConfig+0x702>
      }
      else
      {
        /* set overall return value */
        status = ret;
24013710:	7dfb      	ldrb	r3, [r7, #23]
24013712:	75bb      	strb	r3, [r7, #22]
24013714:	e001      	b.n	2401371a <HAL_RCCEx_PeriphCLKConfig+0x702>
      }
    }
    else
    {
      /* set overall return value */
      status = ret;
24013716:	7dfb      	ldrb	r3, [r7, #23]
24013718:	75bb      	strb	r3, [r7, #22]
    }
  }


  /*-------------------------- USART1/6 configuration --------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART16) == RCC_PERIPHCLK_USART16)
2401371a:	687b      	ldr	r3, [r7, #4]
2401371c:	681b      	ldr	r3, [r3, #0]
2401371e:	f003 0301 	and.w	r3, r3, #1
24013722:	2b00      	cmp	r3, #0
24013724:	d07d      	beq.n	24013822 <HAL_RCCEx_PeriphCLKConfig+0x80a>
  {
    switch(PeriphClkInit->Usart16ClockSelection)
24013726:	687b      	ldr	r3, [r7, #4]
24013728:	6f9b      	ldr	r3, [r3, #120]	; 0x78
2401372a:	2b28      	cmp	r3, #40	; 0x28
2401372c:	d866      	bhi.n	240137fc <HAL_RCCEx_PeriphCLKConfig+0x7e4>
2401372e:	a201      	add	r2, pc, #4	; (adr r2, 24013734 <HAL_RCCEx_PeriphCLKConfig+0x71c>)
24013730:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
24013734:	24013803 	.word	0x24013803
24013738:	240137fd 	.word	0x240137fd
2401373c:	240137fd 	.word	0x240137fd
24013740:	240137fd 	.word	0x240137fd
24013744:	240137fd 	.word	0x240137fd
24013748:	240137fd 	.word	0x240137fd
2401374c:	240137fd 	.word	0x240137fd
24013750:	240137fd 	.word	0x240137fd
24013754:	240137d9 	.word	0x240137d9
24013758:	240137fd 	.word	0x240137fd
2401375c:	240137fd 	.word	0x240137fd
24013760:	240137fd 	.word	0x240137fd
24013764:	240137fd 	.word	0x240137fd
24013768:	240137fd 	.word	0x240137fd
2401376c:	240137fd 	.word	0x240137fd
24013770:	240137fd 	.word	0x240137fd
24013774:	240137eb 	.word	0x240137eb
24013778:	240137fd 	.word	0x240137fd
2401377c:	240137fd 	.word	0x240137fd
24013780:	240137fd 	.word	0x240137fd
24013784:	240137fd 	.word	0x240137fd
24013788:	240137fd 	.word	0x240137fd
2401378c:	240137fd 	.word	0x240137fd
24013790:	240137fd 	.word	0x240137fd
24013794:	24013803 	.word	0x24013803
24013798:	240137fd 	.word	0x240137fd
2401379c:	240137fd 	.word	0x240137fd
240137a0:	240137fd 	.word	0x240137fd
240137a4:	240137fd 	.word	0x240137fd
240137a8:	240137fd 	.word	0x240137fd
240137ac:	240137fd 	.word	0x240137fd
240137b0:	240137fd 	.word	0x240137fd
240137b4:	24013803 	.word	0x24013803
240137b8:	240137fd 	.word	0x240137fd
240137bc:	240137fd 	.word	0x240137fd
240137c0:	240137fd 	.word	0x240137fd
240137c4:	240137fd 	.word	0x240137fd
240137c8:	240137fd 	.word	0x240137fd
240137cc:	240137fd 	.word	0x240137fd
240137d0:	240137fd 	.word	0x240137fd
240137d4:	24013803 	.word	0x24013803
    case RCC_USART16CLKSOURCE_PCLK2: /* CD/D2 PCLK2 as clock source for USART1/6 */
      /* USART1/6 clock source configuration done later after clock selection check */
      break;

    case RCC_USART16CLKSOURCE_PLL2: /* PLL2 is used as clock source for USART1/6 */
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_Q_UPDATE);
240137d8:	687b      	ldr	r3, [r7, #4]
240137da:	3304      	adds	r3, #4
240137dc:	2101      	movs	r1, #1
240137de:	4618      	mov	r0, r3
240137e0:	f001 fd28 	bl	24015234 <RCCEx_PLL2_Config>
240137e4:	4603      	mov	r3, r0
240137e6:	75fb      	strb	r3, [r7, #23]
      /* USART1/6 clock source configuration done later after clock selection check */
      break;
240137e8:	e00c      	b.n	24013804 <HAL_RCCEx_PeriphCLKConfig+0x7ec>

    case RCC_USART16CLKSOURCE_PLL3: /* PLL3 is used as clock source for USART1/6 */
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);
240137ea:	687b      	ldr	r3, [r7, #4]
240137ec:	3324      	adds	r3, #36	; 0x24
240137ee:	2101      	movs	r1, #1
240137f0:	4618      	mov	r0, r3
240137f2:	f001 fdd1 	bl	24015398 <RCCEx_PLL3_Config>
240137f6:	4603      	mov	r3, r0
240137f8:	75fb      	strb	r3, [r7, #23]
      /* USART1/6 clock source configuration done later after clock selection check */
      break;
240137fa:	e003      	b.n	24013804 <HAL_RCCEx_PeriphCLKConfig+0x7ec>
      /* LSE,  oscillator is used as source of USART1/6 clock */
      /* USART1/6 clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
240137fc:	2301      	movs	r3, #1
240137fe:	75fb      	strb	r3, [r7, #23]
      break;
24013800:	e000      	b.n	24013804 <HAL_RCCEx_PeriphCLKConfig+0x7ec>
      break;
24013802:	bf00      	nop
    }

    if(ret == HAL_OK)
24013804:	7dfb      	ldrb	r3, [r7, #23]
24013806:	2b00      	cmp	r3, #0
24013808:	d109      	bne.n	2401381e <HAL_RCCEx_PeriphCLKConfig+0x806>
    {
      /* Set the source of USART1/6 clock */
      __HAL_RCC_USART16_CONFIG(PeriphClkInit->Usart16ClockSelection);
2401380a:	4b32      	ldr	r3, [pc, #200]	; (240138d4 <HAL_RCCEx_PeriphCLKConfig+0x8bc>)
2401380c:	6d5b      	ldr	r3, [r3, #84]	; 0x54
2401380e:	f023 0238 	bic.w	r2, r3, #56	; 0x38
24013812:	687b      	ldr	r3, [r7, #4]
24013814:	6f9b      	ldr	r3, [r3, #120]	; 0x78
24013816:	492f      	ldr	r1, [pc, #188]	; (240138d4 <HAL_RCCEx_PeriphCLKConfig+0x8bc>)
24013818:	4313      	orrs	r3, r2
2401381a:	654b      	str	r3, [r1, #84]	; 0x54
2401381c:	e001      	b.n	24013822 <HAL_RCCEx_PeriphCLKConfig+0x80a>
    }
    else
    {
      /* set overall return value */
      status = ret;
2401381e:	7dfb      	ldrb	r3, [r7, #23]
24013820:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*-------------------------- USART2/3/4/5/7/8 Configuration --------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART234578) == RCC_PERIPHCLK_USART234578)
24013822:	687b      	ldr	r3, [r7, #4]
24013824:	681b      	ldr	r3, [r3, #0]
24013826:	f003 0302 	and.w	r3, r3, #2
2401382a:	2b00      	cmp	r3, #0
2401382c:	d037      	beq.n	2401389e <HAL_RCCEx_PeriphCLKConfig+0x886>
  {
    switch(PeriphClkInit->Usart234578ClockSelection)
2401382e:	687b      	ldr	r3, [r7, #4]
24013830:	6f5b      	ldr	r3, [r3, #116]	; 0x74
24013832:	2b05      	cmp	r3, #5
24013834:	d820      	bhi.n	24013878 <HAL_RCCEx_PeriphCLKConfig+0x860>
24013836:	a201      	add	r2, pc, #4	; (adr r2, 2401383c <HAL_RCCEx_PeriphCLKConfig+0x824>)
24013838:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
2401383c:	2401387f 	.word	0x2401387f
24013840:	24013855 	.word	0x24013855
24013844:	24013867 	.word	0x24013867
24013848:	2401387f 	.word	0x2401387f
2401384c:	2401387f 	.word	0x2401387f
24013850:	2401387f 	.word	0x2401387f
    case RCC_USART234578CLKSOURCE_PCLK1: /* CD/D2 PCLK1 as clock source for USART2/3/4/5/7/8 */
      /* USART2/3/4/5/7/8 clock source configuration done later after clock selection check */
      break;

    case RCC_USART234578CLKSOURCE_PLL2: /* PLL2 is used as clock source for USART2/3/4/5/7/8 */
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_Q_UPDATE);
24013854:	687b      	ldr	r3, [r7, #4]
24013856:	3304      	adds	r3, #4
24013858:	2101      	movs	r1, #1
2401385a:	4618      	mov	r0, r3
2401385c:	f001 fcea 	bl	24015234 <RCCEx_PLL2_Config>
24013860:	4603      	mov	r3, r0
24013862:	75fb      	strb	r3, [r7, #23]
      /* USART2/3/4/5/7/8 clock source configuration done later after clock selection check */
      break;
24013864:	e00c      	b.n	24013880 <HAL_RCCEx_PeriphCLKConfig+0x868>

    case RCC_USART234578CLKSOURCE_PLL3: /* PLL3 is used as clock source for USART2/3/4/5/7/8 */
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);
24013866:	687b      	ldr	r3, [r7, #4]
24013868:	3324      	adds	r3, #36	; 0x24
2401386a:	2101      	movs	r1, #1
2401386c:	4618      	mov	r0, r3
2401386e:	f001 fd93 	bl	24015398 <RCCEx_PLL3_Config>
24013872:	4603      	mov	r3, r0
24013874:	75fb      	strb	r3, [r7, #23]
      /* USART2/3/4/5/7/8 clock source configuration done later after clock selection check */
      break;
24013876:	e003      	b.n	24013880 <HAL_RCCEx_PeriphCLKConfig+0x868>
      /* LSE,  oscillator is used as source of USART2/3/4/5/7/8 clock */
      /* USART2/3/4/5/7/8 clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
24013878:	2301      	movs	r3, #1
2401387a:	75fb      	strb	r3, [r7, #23]
      break;
2401387c:	e000      	b.n	24013880 <HAL_RCCEx_PeriphCLKConfig+0x868>
      break;
2401387e:	bf00      	nop
    }

    if(ret == HAL_OK)
24013880:	7dfb      	ldrb	r3, [r7, #23]
24013882:	2b00      	cmp	r3, #0
24013884:	d109      	bne.n	2401389a <HAL_RCCEx_PeriphCLKConfig+0x882>
    {
      /* Set the source of USART2/3/4/5/7/8 clock */
      __HAL_RCC_USART234578_CONFIG(PeriphClkInit->Usart234578ClockSelection);
24013886:	4b13      	ldr	r3, [pc, #76]	; (240138d4 <HAL_RCCEx_PeriphCLKConfig+0x8bc>)
24013888:	6d5b      	ldr	r3, [r3, #84]	; 0x54
2401388a:	f023 0207 	bic.w	r2, r3, #7
2401388e:	687b      	ldr	r3, [r7, #4]
24013890:	6f5b      	ldr	r3, [r3, #116]	; 0x74
24013892:	4910      	ldr	r1, [pc, #64]	; (240138d4 <HAL_RCCEx_PeriphCLKConfig+0x8bc>)
24013894:	4313      	orrs	r3, r2
24013896:	654b      	str	r3, [r1, #84]	; 0x54
24013898:	e001      	b.n	2401389e <HAL_RCCEx_PeriphCLKConfig+0x886>
    }
    else
    {
      /* set overall return value */
      status = ret;
2401389a:	7dfb      	ldrb	r3, [r7, #23]
2401389c:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*-------------------------- LPUART1 Configuration -------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1)
2401389e:	687b      	ldr	r3, [r7, #4]
240138a0:	681b      	ldr	r3, [r3, #0]
240138a2:	f003 0304 	and.w	r3, r3, #4
240138a6:	2b00      	cmp	r3, #0
240138a8:	d040      	beq.n	2401392c <HAL_RCCEx_PeriphCLKConfig+0x914>
  {
    switch(PeriphClkInit->Lpuart1ClockSelection)
240138aa:	687b      	ldr	r3, [r7, #4]
240138ac:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
240138b0:	2b05      	cmp	r3, #5
240138b2:	d827      	bhi.n	24013904 <HAL_RCCEx_PeriphCLKConfig+0x8ec>
240138b4:	a201      	add	r2, pc, #4	; (adr r2, 240138bc <HAL_RCCEx_PeriphCLKConfig+0x8a4>)
240138b6:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
240138ba:	bf00      	nop
240138bc:	2401390b 	.word	0x2401390b
240138c0:	240138e1 	.word	0x240138e1
240138c4:	240138f3 	.word	0x240138f3
240138c8:	2401390b 	.word	0x2401390b
240138cc:	2401390b 	.word	0x2401390b
240138d0:	2401390b 	.word	0x2401390b
240138d4:	58024400 	.word	0x58024400
240138d8:	58024800 	.word	0x58024800
240138dc:	00ffffcf 	.word	0x00ffffcf
    case RCC_LPUART1CLKSOURCE_PCLK4: /* SRD/D3 PCLK1 (PCLK4) as clock source for LPUART1 */
      /* LPUART1 clock source configuration done later after clock selection check */
      break;

    case RCC_LPUART1CLKSOURCE_PLL2: /* PLL2 is used as clock source for LPUART1 */
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_Q_UPDATE);
240138e0:	687b      	ldr	r3, [r7, #4]
240138e2:	3304      	adds	r3, #4
240138e4:	2101      	movs	r1, #1
240138e6:	4618      	mov	r0, r3
240138e8:	f001 fca4 	bl	24015234 <RCCEx_PLL2_Config>
240138ec:	4603      	mov	r3, r0
240138ee:	75fb      	strb	r3, [r7, #23]
      /* LPUART1 clock source configuration done later after clock selection check */
      break;
240138f0:	e00c      	b.n	2401390c <HAL_RCCEx_PeriphCLKConfig+0x8f4>

    case RCC_LPUART1CLKSOURCE_PLL3: /* PLL3 is used as clock source for LPUART1 */
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);
240138f2:	687b      	ldr	r3, [r7, #4]
240138f4:	3324      	adds	r3, #36	; 0x24
240138f6:	2101      	movs	r1, #1
240138f8:	4618      	mov	r0, r3
240138fa:	f001 fd4d 	bl	24015398 <RCCEx_PLL3_Config>
240138fe:	4603      	mov	r3, r0
24013900:	75fb      	strb	r3, [r7, #23]
      /* LPUART1 clock source configuration done later after clock selection check */
      break;
24013902:	e003      	b.n	2401390c <HAL_RCCEx_PeriphCLKConfig+0x8f4>
      /* LSE,  oscillator is used as source of LPUART1 clock */
      /* LPUART1 clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
24013904:	2301      	movs	r3, #1
24013906:	75fb      	strb	r3, [r7, #23]
      break;
24013908:	e000      	b.n	2401390c <HAL_RCCEx_PeriphCLKConfig+0x8f4>
      break;
2401390a:	bf00      	nop
    }

    if(ret == HAL_OK)
2401390c:	7dfb      	ldrb	r3, [r7, #23]
2401390e:	2b00      	cmp	r3, #0
24013910:	d10a      	bne.n	24013928 <HAL_RCCEx_PeriphCLKConfig+0x910>
    {
      /* Set the source of LPUART1 clock */
      __HAL_RCC_LPUART1_CONFIG(PeriphClkInit->Lpuart1ClockSelection);
24013912:	4bb2      	ldr	r3, [pc, #712]	; (24013bdc <HAL_RCCEx_PeriphCLKConfig+0xbc4>)
24013914:	6d9b      	ldr	r3, [r3, #88]	; 0x58
24013916:	f023 0207 	bic.w	r2, r3, #7
2401391a:	687b      	ldr	r3, [r7, #4]
2401391c:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
24013920:	49ae      	ldr	r1, [pc, #696]	; (24013bdc <HAL_RCCEx_PeriphCLKConfig+0xbc4>)
24013922:	4313      	orrs	r3, r2
24013924:	658b      	str	r3, [r1, #88]	; 0x58
24013926:	e001      	b.n	2401392c <HAL_RCCEx_PeriphCLKConfig+0x914>
    }
    else
    {
      /* set overall return value */
      status = ret;
24013928:	7dfb      	ldrb	r3, [r7, #23]
2401392a:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*---------------------------- LPTIM1 configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == RCC_PERIPHCLK_LPTIM1)
2401392c:	687b      	ldr	r3, [r7, #4]
2401392e:	681b      	ldr	r3, [r3, #0]
24013930:	f003 0320 	and.w	r3, r3, #32
24013934:	2b00      	cmp	r3, #0
24013936:	d044      	beq.n	240139c2 <HAL_RCCEx_PeriphCLKConfig+0x9aa>
  {
    switch(PeriphClkInit->Lptim1ClockSelection)
24013938:	687b      	ldr	r3, [r7, #4]
2401393a:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
2401393e:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
24013942:	d01b      	beq.n	2401397c <HAL_RCCEx_PeriphCLKConfig+0x964>
24013944:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
24013948:	d805      	bhi.n	24013956 <HAL_RCCEx_PeriphCLKConfig+0x93e>
2401394a:	2b00      	cmp	r3, #0
2401394c:	d022      	beq.n	24013994 <HAL_RCCEx_PeriphCLKConfig+0x97c>
2401394e:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
24013952:	d00a      	beq.n	2401396a <HAL_RCCEx_PeriphCLKConfig+0x952>
24013954:	e01b      	b.n	2401398e <HAL_RCCEx_PeriphCLKConfig+0x976>
24013956:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
2401395a:	d01d      	beq.n	24013998 <HAL_RCCEx_PeriphCLKConfig+0x980>
2401395c:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
24013960:	d01c      	beq.n	2401399c <HAL_RCCEx_PeriphCLKConfig+0x984>
24013962:	f1b3 5f40 	cmp.w	r3, #805306368	; 0x30000000
24013966:	d01b      	beq.n	240139a0 <HAL_RCCEx_PeriphCLKConfig+0x988>
24013968:	e011      	b.n	2401398e <HAL_RCCEx_PeriphCLKConfig+0x976>
      /* LPTIM1 clock source configuration done later after clock selection check */
      break;

    case RCC_LPTIM1CLKSOURCE_PLL2: /* PLL2 is used as clock source for LPTIM1*/

      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
2401396a:	687b      	ldr	r3, [r7, #4]
2401396c:	3304      	adds	r3, #4
2401396e:	2100      	movs	r1, #0
24013970:	4618      	mov	r0, r3
24013972:	f001 fc5f 	bl	24015234 <RCCEx_PLL2_Config>
24013976:	4603      	mov	r3, r0
24013978:	75fb      	strb	r3, [r7, #23]

      /* LPTIM1 clock source configuration done later after clock selection check */
      break;
2401397a:	e012      	b.n	240139a2 <HAL_RCCEx_PeriphCLKConfig+0x98a>

    case RCC_LPTIM1CLKSOURCE_PLL3:  /* PLL3 is used as clock source for LPTIM1*/
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE);
2401397c:	687b      	ldr	r3, [r7, #4]
2401397e:	3324      	adds	r3, #36	; 0x24
24013980:	2102      	movs	r1, #2
24013982:	4618      	mov	r0, r3
24013984:	f001 fd08 	bl	24015398 <RCCEx_PLL3_Config>
24013988:	4603      	mov	r3, r0
2401398a:	75fb      	strb	r3, [r7, #23]

      /* LPTIM1 clock source configuration done later after clock selection check */
      break;
2401398c:	e009      	b.n	240139a2 <HAL_RCCEx_PeriphCLKConfig+0x98a>
      /* HSI, HSE, or CSI oscillator is used as source of LPTIM1 clock */
      /* LPTIM1 clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
2401398e:	2301      	movs	r3, #1
24013990:	75fb      	strb	r3, [r7, #23]
      break;
24013992:	e006      	b.n	240139a2 <HAL_RCCEx_PeriphCLKConfig+0x98a>
      break;
24013994:	bf00      	nop
24013996:	e004      	b.n	240139a2 <HAL_RCCEx_PeriphCLKConfig+0x98a>
      break;
24013998:	bf00      	nop
2401399a:	e002      	b.n	240139a2 <HAL_RCCEx_PeriphCLKConfig+0x98a>
      break;
2401399c:	bf00      	nop
2401399e:	e000      	b.n	240139a2 <HAL_RCCEx_PeriphCLKConfig+0x98a>
      break;
240139a0:	bf00      	nop
    }

    if(ret == HAL_OK)
240139a2:	7dfb      	ldrb	r3, [r7, #23]
240139a4:	2b00      	cmp	r3, #0
240139a6:	d10a      	bne.n	240139be <HAL_RCCEx_PeriphCLKConfig+0x9a6>
    {
      /* Set the source of LPTIM1 clock*/
      __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
240139a8:	4b8c      	ldr	r3, [pc, #560]	; (24013bdc <HAL_RCCEx_PeriphCLKConfig+0xbc4>)
240139aa:	6d5b      	ldr	r3, [r3, #84]	; 0x54
240139ac:	f023 42e0 	bic.w	r2, r3, #1879048192	; 0x70000000
240139b0:	687b      	ldr	r3, [r7, #4]
240139b2:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
240139b6:	4989      	ldr	r1, [pc, #548]	; (24013bdc <HAL_RCCEx_PeriphCLKConfig+0xbc4>)
240139b8:	4313      	orrs	r3, r2
240139ba:	654b      	str	r3, [r1, #84]	; 0x54
240139bc:	e001      	b.n	240139c2 <HAL_RCCEx_PeriphCLKConfig+0x9aa>
    }
    else
    {
      /* set overall return value */
      status = ret;
240139be:	7dfb      	ldrb	r3, [r7, #23]
240139c0:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*---------------------------- LPTIM2 configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM2) == RCC_PERIPHCLK_LPTIM2)
240139c2:	687b      	ldr	r3, [r7, #4]
240139c4:	681b      	ldr	r3, [r3, #0]
240139c6:	f003 0340 	and.w	r3, r3, #64	; 0x40
240139ca:	2b00      	cmp	r3, #0
240139cc:	d044      	beq.n	24013a58 <HAL_RCCEx_PeriphCLKConfig+0xa40>
  {
    switch(PeriphClkInit->Lptim2ClockSelection)
240139ce:	687b      	ldr	r3, [r7, #4]
240139d0:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
240139d4:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
240139d8:	d01b      	beq.n	24013a12 <HAL_RCCEx_PeriphCLKConfig+0x9fa>
240139da:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
240139de:	d805      	bhi.n	240139ec <HAL_RCCEx_PeriphCLKConfig+0x9d4>
240139e0:	2b00      	cmp	r3, #0
240139e2:	d022      	beq.n	24013a2a <HAL_RCCEx_PeriphCLKConfig+0xa12>
240139e4:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
240139e8:	d00a      	beq.n	24013a00 <HAL_RCCEx_PeriphCLKConfig+0x9e8>
240139ea:	e01b      	b.n	24013a24 <HAL_RCCEx_PeriphCLKConfig+0xa0c>
240139ec:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
240139f0:	d01d      	beq.n	24013a2e <HAL_RCCEx_PeriphCLKConfig+0xa16>
240139f2:	f5b3 5fa0 	cmp.w	r3, #5120	; 0x1400
240139f6:	d01c      	beq.n	24013a32 <HAL_RCCEx_PeriphCLKConfig+0xa1a>
240139f8:	f5b3 6f40 	cmp.w	r3, #3072	; 0xc00
240139fc:	d01b      	beq.n	24013a36 <HAL_RCCEx_PeriphCLKConfig+0xa1e>
240139fe:	e011      	b.n	24013a24 <HAL_RCCEx_PeriphCLKConfig+0xa0c>
      /* LPTIM2 clock source configuration done later after clock selection check */
      break;

    case RCC_LPTIM2CLKSOURCE_PLL2: /* PLL2 is used as clock source for LPTIM2*/

      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
24013a00:	687b      	ldr	r3, [r7, #4]
24013a02:	3304      	adds	r3, #4
24013a04:	2100      	movs	r1, #0
24013a06:	4618      	mov	r0, r3
24013a08:	f001 fc14 	bl	24015234 <RCCEx_PLL2_Config>
24013a0c:	4603      	mov	r3, r0
24013a0e:	75fb      	strb	r3, [r7, #23]

      /* LPTIM2 clock source configuration done later after clock selection check */
      break;
24013a10:	e012      	b.n	24013a38 <HAL_RCCEx_PeriphCLKConfig+0xa20>

    case RCC_LPTIM2CLKSOURCE_PLL3:  /* PLL3 is used as clock source for LPTIM2*/
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE);
24013a12:	687b      	ldr	r3, [r7, #4]
24013a14:	3324      	adds	r3, #36	; 0x24
24013a16:	2102      	movs	r1, #2
24013a18:	4618      	mov	r0, r3
24013a1a:	f001 fcbd 	bl	24015398 <RCCEx_PLL3_Config>
24013a1e:	4603      	mov	r3, r0
24013a20:	75fb      	strb	r3, [r7, #23]

      /* LPTIM2 clock source configuration done later after clock selection check */
      break;
24013a22:	e009      	b.n	24013a38 <HAL_RCCEx_PeriphCLKConfig+0xa20>
      /* HSI, HSE, or CSI oscillator is used as source of LPTIM2 clock */
      /* LPTIM2 clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
24013a24:	2301      	movs	r3, #1
24013a26:	75fb      	strb	r3, [r7, #23]
      break;
24013a28:	e006      	b.n	24013a38 <HAL_RCCEx_PeriphCLKConfig+0xa20>
      break;
24013a2a:	bf00      	nop
24013a2c:	e004      	b.n	24013a38 <HAL_RCCEx_PeriphCLKConfig+0xa20>
      break;
24013a2e:	bf00      	nop
24013a30:	e002      	b.n	24013a38 <HAL_RCCEx_PeriphCLKConfig+0xa20>
      break;
24013a32:	bf00      	nop
24013a34:	e000      	b.n	24013a38 <HAL_RCCEx_PeriphCLKConfig+0xa20>
      break;
24013a36:	bf00      	nop
    }

    if(ret == HAL_OK)
24013a38:	7dfb      	ldrb	r3, [r7, #23]
24013a3a:	2b00      	cmp	r3, #0
24013a3c:	d10a      	bne.n	24013a54 <HAL_RCCEx_PeriphCLKConfig+0xa3c>
    {
      /* Set the source of LPTIM2 clock*/
      __HAL_RCC_LPTIM2_CONFIG(PeriphClkInit->Lptim2ClockSelection);
24013a3e:	4b67      	ldr	r3, [pc, #412]	; (24013bdc <HAL_RCCEx_PeriphCLKConfig+0xbc4>)
24013a40:	6d9b      	ldr	r3, [r3, #88]	; 0x58
24013a42:	f423 52e0 	bic.w	r2, r3, #7168	; 0x1c00
24013a46:	687b      	ldr	r3, [r7, #4]
24013a48:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
24013a4c:	4963      	ldr	r1, [pc, #396]	; (24013bdc <HAL_RCCEx_PeriphCLKConfig+0xbc4>)
24013a4e:	4313      	orrs	r3, r2
24013a50:	658b      	str	r3, [r1, #88]	; 0x58
24013a52:	e001      	b.n	24013a58 <HAL_RCCEx_PeriphCLKConfig+0xa40>
    }
    else
    {
      /* set overall return value */
      status = ret;
24013a54:	7dfb      	ldrb	r3, [r7, #23]
24013a56:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*---------------------------- LPTIM345 configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM345) == RCC_PERIPHCLK_LPTIM345)
24013a58:	687b      	ldr	r3, [r7, #4]
24013a5a:	681b      	ldr	r3, [r3, #0]
24013a5c:	f003 0380 	and.w	r3, r3, #128	; 0x80
24013a60:	2b00      	cmp	r3, #0
24013a62:	d044      	beq.n	24013aee <HAL_RCCEx_PeriphCLKConfig+0xad6>
  {
    switch(PeriphClkInit->Lptim345ClockSelection)
24013a64:	687b      	ldr	r3, [r7, #4]
24013a66:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
24013a6a:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
24013a6e:	d01b      	beq.n	24013aa8 <HAL_RCCEx_PeriphCLKConfig+0xa90>
24013a70:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
24013a74:	d805      	bhi.n	24013a82 <HAL_RCCEx_PeriphCLKConfig+0xa6a>
24013a76:	2b00      	cmp	r3, #0
24013a78:	d022      	beq.n	24013ac0 <HAL_RCCEx_PeriphCLKConfig+0xaa8>
24013a7a:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
24013a7e:	d00a      	beq.n	24013a96 <HAL_RCCEx_PeriphCLKConfig+0xa7e>
24013a80:	e01b      	b.n	24013aba <HAL_RCCEx_PeriphCLKConfig+0xaa2>
24013a82:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
24013a86:	d01d      	beq.n	24013ac4 <HAL_RCCEx_PeriphCLKConfig+0xaac>
24013a88:	f5b3 4f20 	cmp.w	r3, #40960	; 0xa000
24013a8c:	d01c      	beq.n	24013ac8 <HAL_RCCEx_PeriphCLKConfig+0xab0>
24013a8e:	f5b3 4fc0 	cmp.w	r3, #24576	; 0x6000
24013a92:	d01b      	beq.n	24013acc <HAL_RCCEx_PeriphCLKConfig+0xab4>
24013a94:	e011      	b.n	24013aba <HAL_RCCEx_PeriphCLKConfig+0xaa2>
    case RCC_LPTIM345CLKSOURCE_PCLK4:      /* SRD/D3 PCLK1 (PCLK4) as clock source for LPTIM3/4/5 */
      /* LPTIM3/4/5 clock source configuration done later after clock selection check */
      break;

    case RCC_LPTIM345CLKSOURCE_PLL2: /* PLL2 is used as clock source for LPTIM3/4/5 */
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
24013a96:	687b      	ldr	r3, [r7, #4]
24013a98:	3304      	adds	r3, #4
24013a9a:	2100      	movs	r1, #0
24013a9c:	4618      	mov	r0, r3
24013a9e:	f001 fbc9 	bl	24015234 <RCCEx_PLL2_Config>
24013aa2:	4603      	mov	r3, r0
24013aa4:	75fb      	strb	r3, [r7, #23]

      /* LPTIM3/4/5 clock source configuration done later after clock selection check */
      break;
24013aa6:	e012      	b.n	24013ace <HAL_RCCEx_PeriphCLKConfig+0xab6>

    case RCC_LPTIM345CLKSOURCE_PLL3:  /* PLL3 is used as clock source for LPTIM3/4/5 */
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE);
24013aa8:	687b      	ldr	r3, [r7, #4]
24013aaa:	3324      	adds	r3, #36	; 0x24
24013aac:	2102      	movs	r1, #2
24013aae:	4618      	mov	r0, r3
24013ab0:	f001 fc72 	bl	24015398 <RCCEx_PLL3_Config>
24013ab4:	4603      	mov	r3, r0
24013ab6:	75fb      	strb	r3, [r7, #23]

      /* LPTIM3/4/5 clock source configuration done later after clock selection check */
      break;
24013ab8:	e009      	b.n	24013ace <HAL_RCCEx_PeriphCLKConfig+0xab6>
      /* HSI, HSE, or CSI oscillator is used as source of LPTIM3/4/5 clock */
      /* LPTIM3/4/5 clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
24013aba:	2301      	movs	r3, #1
24013abc:	75fb      	strb	r3, [r7, #23]
      break;
24013abe:	e006      	b.n	24013ace <HAL_RCCEx_PeriphCLKConfig+0xab6>
      break;
24013ac0:	bf00      	nop
24013ac2:	e004      	b.n	24013ace <HAL_RCCEx_PeriphCLKConfig+0xab6>
      break;
24013ac4:	bf00      	nop
24013ac6:	e002      	b.n	24013ace <HAL_RCCEx_PeriphCLKConfig+0xab6>
      break;
24013ac8:	bf00      	nop
24013aca:	e000      	b.n	24013ace <HAL_RCCEx_PeriphCLKConfig+0xab6>
      break;
24013acc:	bf00      	nop
    }

    if(ret == HAL_OK)
24013ace:	7dfb      	ldrb	r3, [r7, #23]
24013ad0:	2b00      	cmp	r3, #0
24013ad2:	d10a      	bne.n	24013aea <HAL_RCCEx_PeriphCLKConfig+0xad2>
    {
      /* Set the source of LPTIM3/4/5 clock */
      __HAL_RCC_LPTIM345_CONFIG(PeriphClkInit->Lptim345ClockSelection);
24013ad4:	4b41      	ldr	r3, [pc, #260]	; (24013bdc <HAL_RCCEx_PeriphCLKConfig+0xbc4>)
24013ad6:	6d9b      	ldr	r3, [r3, #88]	; 0x58
24013ad8:	f423 4260 	bic.w	r2, r3, #57344	; 0xe000
24013adc:	687b      	ldr	r3, [r7, #4]
24013ade:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
24013ae2:	493e      	ldr	r1, [pc, #248]	; (24013bdc <HAL_RCCEx_PeriphCLKConfig+0xbc4>)
24013ae4:	4313      	orrs	r3, r2
24013ae6:	658b      	str	r3, [r1, #88]	; 0x58
24013ae8:	e001      	b.n	24013aee <HAL_RCCEx_PeriphCLKConfig+0xad6>
    }
    else
    {
      /* set overall return value */
      status = ret;
24013aea:	7dfb      	ldrb	r3, [r7, #23]
24013aec:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*------------------------------ I2C1/2/3 Configuration ------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C123) == RCC_PERIPHCLK_I2C123)
24013aee:	687b      	ldr	r3, [r7, #4]
24013af0:	681b      	ldr	r3, [r3, #0]
24013af2:	f003 0308 	and.w	r3, r3, #8
24013af6:	2b00      	cmp	r3, #0
24013af8:	d01a      	beq.n	24013b30 <HAL_RCCEx_PeriphCLKConfig+0xb18>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C123CLKSOURCE(PeriphClkInit->I2c123ClockSelection));

    if ((PeriphClkInit->I2c123ClockSelection )== RCC_I2C123CLKSOURCE_PLL3 )
24013afa:	687b      	ldr	r3, [r7, #4]
24013afc:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
24013b00:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
24013b04:	d10a      	bne.n	24013b1c <HAL_RCCEx_PeriphCLKConfig+0xb04>
    {
        if(RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE)!= HAL_OK)
24013b06:	687b      	ldr	r3, [r7, #4]
24013b08:	3324      	adds	r3, #36	; 0x24
24013b0a:	2102      	movs	r1, #2
24013b0c:	4618      	mov	r0, r3
24013b0e:	f001 fc43 	bl	24015398 <RCCEx_PLL3_Config>
24013b12:	4603      	mov	r3, r0
24013b14:	2b00      	cmp	r3, #0
24013b16:	d001      	beq.n	24013b1c <HAL_RCCEx_PeriphCLKConfig+0xb04>
        {
          status = HAL_ERROR;
24013b18:	2301      	movs	r3, #1
24013b1a:	75bb      	strb	r3, [r7, #22]
        }
    }

      __HAL_RCC_I2C123_CONFIG(PeriphClkInit->I2c123ClockSelection);
24013b1c:	4b2f      	ldr	r3, [pc, #188]	; (24013bdc <HAL_RCCEx_PeriphCLKConfig+0xbc4>)
24013b1e:	6d5b      	ldr	r3, [r3, #84]	; 0x54
24013b20:	f423 5240 	bic.w	r2, r3, #12288	; 0x3000
24013b24:	687b      	ldr	r3, [r7, #4]
24013b26:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
24013b2a:	492c      	ldr	r1, [pc, #176]	; (24013bdc <HAL_RCCEx_PeriphCLKConfig+0xbc4>)
24013b2c:	4313      	orrs	r3, r2
24013b2e:	654b      	str	r3, [r1, #84]	; 0x54

  }

  /*------------------------------ I2C4 Configuration ------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C4) == RCC_PERIPHCLK_I2C4)
24013b30:	687b      	ldr	r3, [r7, #4]
24013b32:	681b      	ldr	r3, [r3, #0]
24013b34:	f003 0310 	and.w	r3, r3, #16
24013b38:	2b00      	cmp	r3, #0
24013b3a:	d01a      	beq.n	24013b72 <HAL_RCCEx_PeriphCLKConfig+0xb5a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C4CLKSOURCE(PeriphClkInit->I2c4ClockSelection));

    if ((PeriphClkInit->I2c4ClockSelection) == RCC_I2C4CLKSOURCE_PLL3 )
24013b3c:	687b      	ldr	r3, [r7, #4]
24013b3e:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
24013b42:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
24013b46:	d10a      	bne.n	24013b5e <HAL_RCCEx_PeriphCLKConfig+0xb46>
    {
      if(RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE)!= HAL_OK)
24013b48:	687b      	ldr	r3, [r7, #4]
24013b4a:	3324      	adds	r3, #36	; 0x24
24013b4c:	2102      	movs	r1, #2
24013b4e:	4618      	mov	r0, r3
24013b50:	f001 fc22 	bl	24015398 <RCCEx_PLL3_Config>
24013b54:	4603      	mov	r3, r0
24013b56:	2b00      	cmp	r3, #0
24013b58:	d001      	beq.n	24013b5e <HAL_RCCEx_PeriphCLKConfig+0xb46>
      {
        status = HAL_ERROR;
24013b5a:	2301      	movs	r3, #1
24013b5c:	75bb      	strb	r3, [r7, #22]
      }
    }

      __HAL_RCC_I2C4_CONFIG(PeriphClkInit->I2c4ClockSelection);
24013b5e:	4b1f      	ldr	r3, [pc, #124]	; (24013bdc <HAL_RCCEx_PeriphCLKConfig+0xbc4>)
24013b60:	6d9b      	ldr	r3, [r3, #88]	; 0x58
24013b62:	f423 7240 	bic.w	r2, r3, #768	; 0x300
24013b66:	687b      	ldr	r3, [r7, #4]
24013b68:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
24013b6c:	491b      	ldr	r1, [pc, #108]	; (24013bdc <HAL_RCCEx_PeriphCLKConfig+0xbc4>)
24013b6e:	4313      	orrs	r3, r2
24013b70:	658b      	str	r3, [r1, #88]	; 0x58

  }

  /*---------------------------- ADC configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADC) == RCC_PERIPHCLK_ADC)
24013b72:	687b      	ldr	r3, [r7, #4]
24013b74:	681b      	ldr	r3, [r3, #0]
24013b76:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
24013b7a:	2b00      	cmp	r3, #0
24013b7c:	d032      	beq.n	24013be4 <HAL_RCCEx_PeriphCLKConfig+0xbcc>
  {
    switch(PeriphClkInit->AdcClockSelection)
24013b7e:	687b      	ldr	r3, [r7, #4]
24013b80:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
24013b84:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
24013b88:	d00d      	beq.n	24013ba6 <HAL_RCCEx_PeriphCLKConfig+0xb8e>
24013b8a:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
24013b8e:	d016      	beq.n	24013bbe <HAL_RCCEx_PeriphCLKConfig+0xba6>
24013b90:	2b00      	cmp	r3, #0
24013b92:	d111      	bne.n	24013bb8 <HAL_RCCEx_PeriphCLKConfig+0xba0>
    {

    case RCC_ADCCLKSOURCE_PLL2: /* PLL2 is used as clock source for ADC*/

      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
24013b94:	687b      	ldr	r3, [r7, #4]
24013b96:	3304      	adds	r3, #4
24013b98:	2100      	movs	r1, #0
24013b9a:	4618      	mov	r0, r3
24013b9c:	f001 fb4a 	bl	24015234 <RCCEx_PLL2_Config>
24013ba0:	4603      	mov	r3, r0
24013ba2:	75fb      	strb	r3, [r7, #23]

      /* ADC clock source configuration done later after clock selection check */
      break;
24013ba4:	e00c      	b.n	24013bc0 <HAL_RCCEx_PeriphCLKConfig+0xba8>

    case RCC_ADCCLKSOURCE_PLL3:  /* PLL3 is used as clock source for ADC*/
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE);
24013ba6:	687b      	ldr	r3, [r7, #4]
24013ba8:	3324      	adds	r3, #36	; 0x24
24013baa:	2102      	movs	r1, #2
24013bac:	4618      	mov	r0, r3
24013bae:	f001 fbf3 	bl	24015398 <RCCEx_PLL3_Config>
24013bb2:	4603      	mov	r3, r0
24013bb4:	75fb      	strb	r3, [r7, #23]

      /* ADC clock source configuration done later after clock selection check */
      break;
24013bb6:	e003      	b.n	24013bc0 <HAL_RCCEx_PeriphCLKConfig+0xba8>
      /* HSI, HSE, or CSI oscillator is used as source of ADC clock */
      /* ADC clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
24013bb8:	2301      	movs	r3, #1
24013bba:	75fb      	strb	r3, [r7, #23]
      break;
24013bbc:	e000      	b.n	24013bc0 <HAL_RCCEx_PeriphCLKConfig+0xba8>
      break;
24013bbe:	bf00      	nop
    }

    if(ret == HAL_OK)
24013bc0:	7dfb      	ldrb	r3, [r7, #23]
24013bc2:	2b00      	cmp	r3, #0
24013bc4:	d10c      	bne.n	24013be0 <HAL_RCCEx_PeriphCLKConfig+0xbc8>
    {
      /* Set the source of ADC clock*/
      __HAL_RCC_ADC_CONFIG(PeriphClkInit->AdcClockSelection);
24013bc6:	4b05      	ldr	r3, [pc, #20]	; (24013bdc <HAL_RCCEx_PeriphCLKConfig+0xbc4>)
24013bc8:	6d9b      	ldr	r3, [r3, #88]	; 0x58
24013bca:	f423 3240 	bic.w	r2, r3, #196608	; 0x30000
24013bce:	687b      	ldr	r3, [r7, #4]
24013bd0:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
24013bd4:	4901      	ldr	r1, [pc, #4]	; (24013bdc <HAL_RCCEx_PeriphCLKConfig+0xbc4>)
24013bd6:	4313      	orrs	r3, r2
24013bd8:	658b      	str	r3, [r1, #88]	; 0x58
24013bda:	e003      	b.n	24013be4 <HAL_RCCEx_PeriphCLKConfig+0xbcc>
24013bdc:	58024400 	.word	0x58024400
    }
    else
    {
      /* set overall return value */
      status = ret;
24013be0:	7dfb      	ldrb	r3, [r7, #23]
24013be2:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*------------------------------ USB Configuration -------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USB) == RCC_PERIPHCLK_USB)
24013be4:	687b      	ldr	r3, [r7, #4]
24013be6:	681b      	ldr	r3, [r3, #0]
24013be8:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
24013bec:	2b00      	cmp	r3, #0
24013bee:	d02f      	beq.n	24013c50 <HAL_RCCEx_PeriphCLKConfig+0xc38>
  {

    switch(PeriphClkInit->UsbClockSelection)
24013bf0:	687b      	ldr	r3, [r7, #4]
24013bf2:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
24013bf6:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
24013bfa:	d00c      	beq.n	24013c16 <HAL_RCCEx_PeriphCLKConfig+0xbfe>
24013bfc:	f5b3 1f40 	cmp.w	r3, #3145728	; 0x300000
24013c00:	d015      	beq.n	24013c2e <HAL_RCCEx_PeriphCLKConfig+0xc16>
24013c02:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
24013c06:	d10f      	bne.n	24013c28 <HAL_RCCEx_PeriphCLKConfig+0xc10>
    {
    case RCC_USBCLKSOURCE_PLL:      /* PLL is used as clock source for USB*/
      /* Enable USB Clock output generated form System USB . */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
24013c08:	4b71      	ldr	r3, [pc, #452]	; (24013dd0 <HAL_RCCEx_PeriphCLKConfig+0xdb8>)
24013c0a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24013c0c:	4a70      	ldr	r2, [pc, #448]	; (24013dd0 <HAL_RCCEx_PeriphCLKConfig+0xdb8>)
24013c0e:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
24013c12:	62d3      	str	r3, [r2, #44]	; 0x2c

      /* USB clock source configuration done later after clock selection check */
      break;
24013c14:	e00c      	b.n	24013c30 <HAL_RCCEx_PeriphCLKConfig+0xc18>

    case RCC_USBCLKSOURCE_PLL3: /* PLL3 is used as clock source for USB*/

      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);
24013c16:	687b      	ldr	r3, [r7, #4]
24013c18:	3324      	adds	r3, #36	; 0x24
24013c1a:	2101      	movs	r1, #1
24013c1c:	4618      	mov	r0, r3
24013c1e:	f001 fbbb 	bl	24015398 <RCCEx_PLL3_Config>
24013c22:	4603      	mov	r3, r0
24013c24:	75fb      	strb	r3, [r7, #23]

      /* USB clock source configuration done later after clock selection check */
      break;
24013c26:	e003      	b.n	24013c30 <HAL_RCCEx_PeriphCLKConfig+0xc18>
      /* HSI48 oscillator is used as source of USB clock */
      /* USB clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
24013c28:	2301      	movs	r3, #1
24013c2a:	75fb      	strb	r3, [r7, #23]
      break;
24013c2c:	e000      	b.n	24013c30 <HAL_RCCEx_PeriphCLKConfig+0xc18>
      break;
24013c2e:	bf00      	nop
    }

    if(ret == HAL_OK)
24013c30:	7dfb      	ldrb	r3, [r7, #23]
24013c32:	2b00      	cmp	r3, #0
24013c34:	d10a      	bne.n	24013c4c <HAL_RCCEx_PeriphCLKConfig+0xc34>
    {
      /* Set the source of USB clock*/
      __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
24013c36:	4b66      	ldr	r3, [pc, #408]	; (24013dd0 <HAL_RCCEx_PeriphCLKConfig+0xdb8>)
24013c38:	6d5b      	ldr	r3, [r3, #84]	; 0x54
24013c3a:	f423 1240 	bic.w	r2, r3, #3145728	; 0x300000
24013c3e:	687b      	ldr	r3, [r7, #4]
24013c40:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
24013c44:	4962      	ldr	r1, [pc, #392]	; (24013dd0 <HAL_RCCEx_PeriphCLKConfig+0xdb8>)
24013c46:	4313      	orrs	r3, r2
24013c48:	654b      	str	r3, [r1, #84]	; 0x54
24013c4a:	e001      	b.n	24013c50 <HAL_RCCEx_PeriphCLKConfig+0xc38>
    }
    else
    {
      /* set overall return value */
      status = ret;
24013c4c:	7dfb      	ldrb	r3, [r7, #23]
24013c4e:	75bb      	strb	r3, [r7, #22]
    }

  }

  /*------------------------------------- SDMMC Configuration ------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDMMC) == RCC_PERIPHCLK_SDMMC)
24013c50:	687b      	ldr	r3, [r7, #4]
24013c52:	681b      	ldr	r3, [r3, #0]
24013c54:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
24013c58:	2b00      	cmp	r3, #0
24013c5a:	d029      	beq.n	24013cb0 <HAL_RCCEx_PeriphCLKConfig+0xc98>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SDMMC(PeriphClkInit->SdmmcClockSelection));

    switch(PeriphClkInit->SdmmcClockSelection)
24013c5c:	687b      	ldr	r3, [r7, #4]
24013c5e:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
24013c60:	2b00      	cmp	r3, #0
24013c62:	d003      	beq.n	24013c6c <HAL_RCCEx_PeriphCLKConfig+0xc54>
24013c64:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
24013c68:	d007      	beq.n	24013c7a <HAL_RCCEx_PeriphCLKConfig+0xc62>
24013c6a:	e00f      	b.n	24013c8c <HAL_RCCEx_PeriphCLKConfig+0xc74>
    {
    case RCC_SDMMCCLKSOURCE_PLL:      /* PLL is used as clock source for SDMMC*/
      /* Enable SDMMC Clock output generated form System PLL . */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
24013c6c:	4b58      	ldr	r3, [pc, #352]	; (24013dd0 <HAL_RCCEx_PeriphCLKConfig+0xdb8>)
24013c6e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24013c70:	4a57      	ldr	r2, [pc, #348]	; (24013dd0 <HAL_RCCEx_PeriphCLKConfig+0xdb8>)
24013c72:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
24013c76:	62d3      	str	r3, [r2, #44]	; 0x2c

      /* SDMMC clock source configuration done later after clock selection check */
      break;
24013c78:	e00b      	b.n	24013c92 <HAL_RCCEx_PeriphCLKConfig+0xc7a>

    case RCC_SDMMCCLKSOURCE_PLL2: /* PLL2 is used as clock source for SDMMC*/

      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_R_UPDATE);
24013c7a:	687b      	ldr	r3, [r7, #4]
24013c7c:	3304      	adds	r3, #4
24013c7e:	2102      	movs	r1, #2
24013c80:	4618      	mov	r0, r3
24013c82:	f001 fad7 	bl	24015234 <RCCEx_PLL2_Config>
24013c86:	4603      	mov	r3, r0
24013c88:	75fb      	strb	r3, [r7, #23]

      /* SDMMC clock source configuration done later after clock selection check */
      break;
24013c8a:	e002      	b.n	24013c92 <HAL_RCCEx_PeriphCLKConfig+0xc7a>

    default:
      ret = HAL_ERROR;
24013c8c:	2301      	movs	r3, #1
24013c8e:	75fb      	strb	r3, [r7, #23]
      break;
24013c90:	bf00      	nop
    }

    if(ret == HAL_OK)
24013c92:	7dfb      	ldrb	r3, [r7, #23]
24013c94:	2b00      	cmp	r3, #0
24013c96:	d109      	bne.n	24013cac <HAL_RCCEx_PeriphCLKConfig+0xc94>
    {
      /* Set the source of SDMMC clock*/
      __HAL_RCC_SDMMC_CONFIG(PeriphClkInit->SdmmcClockSelection);
24013c98:	4b4d      	ldr	r3, [pc, #308]	; (24013dd0 <HAL_RCCEx_PeriphCLKConfig+0xdb8>)
24013c9a:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
24013c9c:	f423 3280 	bic.w	r2, r3, #65536	; 0x10000
24013ca0:	687b      	ldr	r3, [r7, #4]
24013ca2:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
24013ca4:	494a      	ldr	r1, [pc, #296]	; (24013dd0 <HAL_RCCEx_PeriphCLKConfig+0xdb8>)
24013ca6:	4313      	orrs	r3, r2
24013ca8:	64cb      	str	r3, [r1, #76]	; 0x4c
24013caa:	e001      	b.n	24013cb0 <HAL_RCCEx_PeriphCLKConfig+0xc98>
    }
    else
    {
      /* set overall return value */
      status = ret;
24013cac:	7dfb      	ldrb	r3, [r7, #23]
24013cae:	75bb      	strb	r3, [r7, #22]
    }
  }

#if defined(LTDC)
  /*-------------------------------------- LTDC Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LTDC) == RCC_PERIPHCLK_LTDC)
24013cb0:	687b      	ldr	r3, [r7, #4]
24013cb2:	681b      	ldr	r3, [r3, #0]
24013cb4:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
24013cb8:	2b00      	cmp	r3, #0
24013cba:	d00a      	beq.n	24013cd2 <HAL_RCCEx_PeriphCLKConfig+0xcba>
  {
    if(RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE)!=HAL_OK)
24013cbc:	687b      	ldr	r3, [r7, #4]
24013cbe:	3324      	adds	r3, #36	; 0x24
24013cc0:	2102      	movs	r1, #2
24013cc2:	4618      	mov	r0, r3
24013cc4:	f001 fb68 	bl	24015398 <RCCEx_PLL3_Config>
24013cc8:	4603      	mov	r3, r0
24013cca:	2b00      	cmp	r3, #0
24013ccc:	d001      	beq.n	24013cd2 <HAL_RCCEx_PeriphCLKConfig+0xcba>
    {
      status=HAL_ERROR;
24013cce:	2301      	movs	r3, #1
24013cd0:	75bb      	strb	r3, [r7, #22]
    }
  }
#endif /* LTDC */

  /*------------------------------ RNG Configuration -------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RNG) == RCC_PERIPHCLK_RNG)
24013cd2:	687b      	ldr	r3, [r7, #4]
24013cd4:	681b      	ldr	r3, [r3, #0]
24013cd6:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
24013cda:	2b00      	cmp	r3, #0
24013cdc:	d02f      	beq.n	24013d3e <HAL_RCCEx_PeriphCLKConfig+0xd26>
  {

    switch(PeriphClkInit->RngClockSelection)
24013cde:	687b      	ldr	r3, [r7, #4]
24013ce0:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
24013ce2:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
24013ce6:	d00c      	beq.n	24013d02 <HAL_RCCEx_PeriphCLKConfig+0xcea>
24013ce8:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
24013cec:	d802      	bhi.n	24013cf4 <HAL_RCCEx_PeriphCLKConfig+0xcdc>
24013cee:	2b00      	cmp	r3, #0
24013cf0:	d011      	beq.n	24013d16 <HAL_RCCEx_PeriphCLKConfig+0xcfe>
24013cf2:	e00d      	b.n	24013d10 <HAL_RCCEx_PeriphCLKConfig+0xcf8>
24013cf4:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
24013cf8:	d00f      	beq.n	24013d1a <HAL_RCCEx_PeriphCLKConfig+0xd02>
24013cfa:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
24013cfe:	d00e      	beq.n	24013d1e <HAL_RCCEx_PeriphCLKConfig+0xd06>
24013d00:	e006      	b.n	24013d10 <HAL_RCCEx_PeriphCLKConfig+0xcf8>
    {
    case RCC_RNGCLKSOURCE_PLL:     /* PLL is used as clock source for RNG*/
      /* Enable RNG Clock output generated form System RNG . */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
24013d02:	4b33      	ldr	r3, [pc, #204]	; (24013dd0 <HAL_RCCEx_PeriphCLKConfig+0xdb8>)
24013d04:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24013d06:	4a32      	ldr	r2, [pc, #200]	; (24013dd0 <HAL_RCCEx_PeriphCLKConfig+0xdb8>)
24013d08:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
24013d0c:	62d3      	str	r3, [r2, #44]	; 0x2c

      /* RNG clock source configuration done later after clock selection check */
      break;
24013d0e:	e007      	b.n	24013d20 <HAL_RCCEx_PeriphCLKConfig+0xd08>
      /* HSI48 oscillator is used as source of RNG clock */
      /* RNG clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
24013d10:	2301      	movs	r3, #1
24013d12:	75fb      	strb	r3, [r7, #23]
      break;
24013d14:	e004      	b.n	24013d20 <HAL_RCCEx_PeriphCLKConfig+0xd08>
      break;
24013d16:	bf00      	nop
24013d18:	e002      	b.n	24013d20 <HAL_RCCEx_PeriphCLKConfig+0xd08>
      break;
24013d1a:	bf00      	nop
24013d1c:	e000      	b.n	24013d20 <HAL_RCCEx_PeriphCLKConfig+0xd08>
      break;
24013d1e:	bf00      	nop
    }

    if(ret == HAL_OK)
24013d20:	7dfb      	ldrb	r3, [r7, #23]
24013d22:	2b00      	cmp	r3, #0
24013d24:	d109      	bne.n	24013d3a <HAL_RCCEx_PeriphCLKConfig+0xd22>
    {
      /* Set the source of RNG clock*/
      __HAL_RCC_RNG_CONFIG(PeriphClkInit->RngClockSelection);
24013d26:	4b2a      	ldr	r3, [pc, #168]	; (24013dd0 <HAL_RCCEx_PeriphCLKConfig+0xdb8>)
24013d28:	6d5b      	ldr	r3, [r3, #84]	; 0x54
24013d2a:	f423 7240 	bic.w	r2, r3, #768	; 0x300
24013d2e:	687b      	ldr	r3, [r7, #4]
24013d30:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
24013d32:	4927      	ldr	r1, [pc, #156]	; (24013dd0 <HAL_RCCEx_PeriphCLKConfig+0xdb8>)
24013d34:	4313      	orrs	r3, r2
24013d36:	654b      	str	r3, [r1, #84]	; 0x54
24013d38:	e001      	b.n	24013d3e <HAL_RCCEx_PeriphCLKConfig+0xd26>
    }
    else
    {
      /* set overall return value */
      status = ret;
24013d3a:	7dfb      	ldrb	r3, [r7, #23]
24013d3c:	75bb      	strb	r3, [r7, #22]
    }

  }

  /*------------------------------ SWPMI1 Configuration ------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SWPMI1) == RCC_PERIPHCLK_SWPMI1)
24013d3e:	687b      	ldr	r3, [r7, #4]
24013d40:	681b      	ldr	r3, [r3, #0]
24013d42:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
24013d46:	2b00      	cmp	r3, #0
24013d48:	d008      	beq.n	24013d5c <HAL_RCCEx_PeriphCLKConfig+0xd44>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SWPMI1CLKSOURCE(PeriphClkInit->Swpmi1ClockSelection));

    /* Configure the SWPMI1 interface clock source */
    __HAL_RCC_SWPMI1_CONFIG(PeriphClkInit->Swpmi1ClockSelection);
24013d4a:	4b21      	ldr	r3, [pc, #132]	; (24013dd0 <HAL_RCCEx_PeriphCLKConfig+0xdb8>)
24013d4c:	6d1b      	ldr	r3, [r3, #80]	; 0x50
24013d4e:	f023 4200 	bic.w	r2, r3, #2147483648	; 0x80000000
24013d52:	687b      	ldr	r3, [r7, #4]
24013d54:	6f1b      	ldr	r3, [r3, #112]	; 0x70
24013d56:	491e      	ldr	r1, [pc, #120]	; (24013dd0 <HAL_RCCEx_PeriphCLKConfig+0xdb8>)
24013d58:	4313      	orrs	r3, r2
24013d5a:	650b      	str	r3, [r1, #80]	; 0x50
    /* Configure the HRTIM1 clock source */
    __HAL_RCC_HRTIM1_CONFIG(PeriphClkInit->Hrtim1ClockSelection);
  }
#endif  /*HRTIM*/
  /*------------------------------ DFSDM1 Configuration ------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_DFSDM1) == RCC_PERIPHCLK_DFSDM1)
24013d5c:	687b      	ldr	r3, [r7, #4]
24013d5e:	681b      	ldr	r3, [r3, #0]
24013d60:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
24013d64:	2b00      	cmp	r3, #0
24013d66:	d008      	beq.n	24013d7a <HAL_RCCEx_PeriphCLKConfig+0xd62>
  {
    /* Check the parameters */
    assert_param(IS_RCC_DFSDM1CLKSOURCE(PeriphClkInit->Dfsdm1ClockSelection));

    /* Configure the DFSDM1 interface clock source */
    __HAL_RCC_DFSDM1_CONFIG(PeriphClkInit->Dfsdm1ClockSelection);
24013d68:	4b19      	ldr	r3, [pc, #100]	; (24013dd0 <HAL_RCCEx_PeriphCLKConfig+0xdb8>)
24013d6a:	6d1b      	ldr	r3, [r3, #80]	; 0x50
24013d6c:	f023 7280 	bic.w	r2, r3, #16777216	; 0x1000000
24013d70:	687b      	ldr	r3, [r7, #4]
24013d72:	6e9b      	ldr	r3, [r3, #104]	; 0x68
24013d74:	4916      	ldr	r1, [pc, #88]	; (24013dd0 <HAL_RCCEx_PeriphCLKConfig+0xdb8>)
24013d76:	4313      	orrs	r3, r2
24013d78:	650b      	str	r3, [r1, #80]	; 0x50
    __HAL_RCC_DFSDM2_CONFIG(PeriphClkInit->Dfsdm2ClockSelection);
  }
#endif  /* DFSDM2 */

  /*------------------------------------ TIM configuration --------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_TIM) == RCC_PERIPHCLK_TIM)
24013d7a:	687b      	ldr	r3, [r7, #4]
24013d7c:	681b      	ldr	r3, [r3, #0]
24013d7e:	f003 4380 	and.w	r3, r3, #1073741824	; 0x40000000
24013d82:	2b00      	cmp	r3, #0
24013d84:	d00d      	beq.n	24013da2 <HAL_RCCEx_PeriphCLKConfig+0xd8a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_TIMPRES(PeriphClkInit->TIMPresSelection));

    /* Configure Timer Prescaler */
    __HAL_RCC_TIMCLKPRESCALER(PeriphClkInit->TIMPresSelection);
24013d86:	4b12      	ldr	r3, [pc, #72]	; (24013dd0 <HAL_RCCEx_PeriphCLKConfig+0xdb8>)
24013d88:	691b      	ldr	r3, [r3, #16]
24013d8a:	4a11      	ldr	r2, [pc, #68]	; (24013dd0 <HAL_RCCEx_PeriphCLKConfig+0xdb8>)
24013d8c:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
24013d90:	6113      	str	r3, [r2, #16]
24013d92:	4b0f      	ldr	r3, [pc, #60]	; (24013dd0 <HAL_RCCEx_PeriphCLKConfig+0xdb8>)
24013d94:	691a      	ldr	r2, [r3, #16]
24013d96:	687b      	ldr	r3, [r7, #4]
24013d98:	f8d3 30b8 	ldr.w	r3, [r3, #184]	; 0xb8
24013d9c:	490c      	ldr	r1, [pc, #48]	; (24013dd0 <HAL_RCCEx_PeriphCLKConfig+0xdb8>)
24013d9e:	4313      	orrs	r3, r2
24013da0:	610b      	str	r3, [r1, #16]
  }

  /*------------------------------------ CKPER configuration --------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CKPER) == RCC_PERIPHCLK_CKPER)
24013da2:	687b      	ldr	r3, [r7, #4]
24013da4:	681b      	ldr	r3, [r3, #0]
24013da6:	2b00      	cmp	r3, #0
24013da8:	da08      	bge.n	24013dbc <HAL_RCCEx_PeriphCLKConfig+0xda4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_CLKPSOURCE(PeriphClkInit->CkperClockSelection));

    /* Configure the CKPER clock source */
    __HAL_RCC_CLKP_CONFIG(PeriphClkInit->CkperClockSelection);
24013daa:	4b09      	ldr	r3, [pc, #36]	; (24013dd0 <HAL_RCCEx_PeriphCLKConfig+0xdb8>)
24013dac:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
24013dae:	f023 5240 	bic.w	r2, r3, #805306368	; 0x30000000
24013db2:	687b      	ldr	r3, [r7, #4]
24013db4:	6d1b      	ldr	r3, [r3, #80]	; 0x50
24013db6:	4906      	ldr	r1, [pc, #24]	; (24013dd0 <HAL_RCCEx_PeriphCLKConfig+0xdb8>)
24013db8:	4313      	orrs	r3, r2
24013dba:	64cb      	str	r3, [r1, #76]	; 0x4c
  }

  if (status == HAL_OK)
24013dbc:	7dbb      	ldrb	r3, [r7, #22]
24013dbe:	2b00      	cmp	r3, #0
24013dc0:	d101      	bne.n	24013dc6 <HAL_RCCEx_PeriphCLKConfig+0xdae>
  {
    return HAL_OK;
24013dc2:	2300      	movs	r3, #0
24013dc4:	e000      	b.n	24013dc8 <HAL_RCCEx_PeriphCLKConfig+0xdb0>
  }
  return HAL_ERROR;
24013dc6:	2301      	movs	r3, #1
}
24013dc8:	4618      	mov	r0, r3
24013dca:	3718      	adds	r7, #24
24013dcc:	46bd      	mov	sp, r7
24013dce:	bd80      	pop	{r7, pc}
24013dd0:	58024400 	.word	0x58024400

24013dd4 <HAL_RCCEx_GetPeriphCLKConfig>:
  * @retval None
  *
  *   (*) : Available on some STM32H7 lines only.
  */
void HAL_RCCEx_GetPeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
24013dd4:	b480      	push	{r7}
24013dd6:	b083      	sub	sp, #12
24013dd8:	af00      	add	r7, sp, #0
24013dda:	6078      	str	r0, [r7, #4]
  /* Set all possible values for the extended clock type parameter------------*/
  PeriphClkInit->PeriphClockSelection =
24013ddc:	687b      	ldr	r3, [r7, #4]
24013dde:	4aa3      	ldr	r2, [pc, #652]	; (2401406c <HAL_RCCEx_GetPeriphCLKConfig+0x298>)
24013de0:	601a      	str	r2, [r3, #0]
	         RCC_PERIPHCLK_FDCAN   | RCC_PERIPHCLK_SDMMC       | RCC_PERIPHCLK_RNG     | RCC_PERIPHCLK_USB      |
	         RCC_PERIPHCLK_ADC     | RCC_PERIPHCLK_SWPMI1      | RCC_PERIPHCLK_DFSDM1  | RCC_PERIPHCLK_RTC      |
	         RCC_PERIPHCLK_CEC     | RCC_PERIPHCLK_FMC         | RCC_PERIPHCLK_SPDIFRX | RCC_PERIPHCLK_TIM      |
	         RCC_PERIPHCLK_CKPER;

PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_I2C123;
24013de2:	687b      	ldr	r3, [r7, #4]
24013de4:	681b      	ldr	r3, [r3, #0]
24013de6:	f043 0208 	orr.w	r2, r3, #8
24013dea:	687b      	ldr	r3, [r7, #4]
24013dec:	601a      	str	r2, [r3, #0]
#endif /* RCC_CDCCIP1R_SAI2ASEL */
#if defined(RCC_CDCCIP1R_SAI2BSEL)
  PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_SAI2B;
#endif /* RCC_CDCCIP1R_SAI2BSEL */
#if defined(SAI3)
  PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_SAI23;
24013dee:	687b      	ldr	r3, [r7, #4]
24013df0:	681b      	ldr	r3, [r3, #0]
24013df2:	f443 7200 	orr.w	r2, r3, #512	; 0x200
24013df6:	687b      	ldr	r3, [r7, #4]
24013df8:	601a      	str	r2, [r3, #0]
#endif /* SAI3 */
#if defined(SAI4)
  PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_SAI4A;
24013dfa:	687b      	ldr	r3, [r7, #4]
24013dfc:	681b      	ldr	r3, [r3, #0]
24013dfe:	f443 6280 	orr.w	r2, r3, #1024	; 0x400
24013e02:	687b      	ldr	r3, [r7, #4]
24013e04:	601a      	str	r2, [r3, #0]
  PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_SAI4B;
24013e06:	687b      	ldr	r3, [r7, #4]
24013e08:	681b      	ldr	r3, [r3, #0]
24013e0a:	f443 6200 	orr.w	r2, r3, #2048	; 0x800
24013e0e:	687b      	ldr	r3, [r7, #4]
24013e10:	601a      	str	r2, [r3, #0]
#endif /* SAI4 */
#if defined(DFSDM2_BASE)
  PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_DFSDM2;
#endif /* DFSDM2 */
#if defined(QUADSPI)
  PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_QSPI;
24013e12:	687b      	ldr	r3, [r7, #4]
24013e14:	681b      	ldr	r3, [r3, #0]
24013e16:	f043 7200 	orr.w	r2, r3, #33554432	; 0x2000000
24013e1a:	687b      	ldr	r3, [r7, #4]
24013e1c:	601a      	str	r2, [r3, #0]
#endif /* OCTOSPI1 || OCTOSPI2 */
#if defined(HRTIM)
  PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_HRTIM1;
#endif /* HRTIM */
#if defined(LTDC)
  PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_LTDC;
24013e1e:	687b      	ldr	r3, [r7, #4]
24013e20:	681b      	ldr	r3, [r3, #0]
24013e22:	f043 5200 	orr.w	r2, r3, #536870912	; 0x20000000
24013e26:	687b      	ldr	r3, [r7, #4]
24013e28:	601a      	str	r2, [r3, #0]
#if defined(DSI)
  PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_DSI;
#endif /* DSI */

  /* Get the PLL3 Clock configuration -----------------------------------------------*/
  PeriphClkInit->PLL3.PLL3M = (uint32_t)((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM3)>> RCC_PLLCKSELR_DIVM3_Pos);
24013e2a:	4b91      	ldr	r3, [pc, #580]	; (24014070 <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
24013e2c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
24013e2e:	0d1b      	lsrs	r3, r3, #20
24013e30:	f003 023f 	and.w	r2, r3, #63	; 0x3f
24013e34:	687b      	ldr	r3, [r7, #4]
24013e36:	625a      	str	r2, [r3, #36]	; 0x24
  PeriphClkInit->PLL3.PLL3N = (uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_N3) >> RCC_PLL3DIVR_N3_Pos)+ 1U;
24013e38:	4b8d      	ldr	r3, [pc, #564]	; (24014070 <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
24013e3a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
24013e3c:	f3c3 0308 	ubfx	r3, r3, #0, #9
24013e40:	1c5a      	adds	r2, r3, #1
24013e42:	687b      	ldr	r3, [r7, #4]
24013e44:	629a      	str	r2, [r3, #40]	; 0x28
  PeriphClkInit->PLL3.PLL3R = (uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_R3) >> RCC_PLL3DIVR_R3_Pos)+ 1U;
24013e46:	4b8a      	ldr	r3, [pc, #552]	; (24014070 <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
24013e48:	6c1b      	ldr	r3, [r3, #64]	; 0x40
24013e4a:	0e1b      	lsrs	r3, r3, #24
24013e4c:	f003 037f 	and.w	r3, r3, #127	; 0x7f
24013e50:	1c5a      	adds	r2, r3, #1
24013e52:	687b      	ldr	r3, [r7, #4]
24013e54:	635a      	str	r2, [r3, #52]	; 0x34
  PeriphClkInit->PLL3.PLL3P = (uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_P3) >> RCC_PLL3DIVR_P3_Pos)+ 1U;
24013e56:	4b86      	ldr	r3, [pc, #536]	; (24014070 <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
24013e58:	6c1b      	ldr	r3, [r3, #64]	; 0x40
24013e5a:	0a5b      	lsrs	r3, r3, #9
24013e5c:	f003 037f 	and.w	r3, r3, #127	; 0x7f
24013e60:	1c5a      	adds	r2, r3, #1
24013e62:	687b      	ldr	r3, [r7, #4]
24013e64:	62da      	str	r2, [r3, #44]	; 0x2c
  PeriphClkInit->PLL3.PLL3Q = (uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_Q3) >> RCC_PLL3DIVR_Q3_Pos)+ 1U;
24013e66:	4b82      	ldr	r3, [pc, #520]	; (24014070 <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
24013e68:	6c1b      	ldr	r3, [r3, #64]	; 0x40
24013e6a:	0c1b      	lsrs	r3, r3, #16
24013e6c:	f003 037f 	and.w	r3, r3, #127	; 0x7f
24013e70:	1c5a      	adds	r2, r3, #1
24013e72:	687b      	ldr	r3, [r7, #4]
24013e74:	631a      	str	r2, [r3, #48]	; 0x30
  PeriphClkInit->PLL3.PLL3RGE = (uint32_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLL3RGE) >> RCC_PLLCFGR_PLL3RGE_Pos);
24013e76:	4b7e      	ldr	r3, [pc, #504]	; (24014070 <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
24013e78:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24013e7a:	0a9b      	lsrs	r3, r3, #10
24013e7c:	f003 0203 	and.w	r2, r3, #3
24013e80:	687b      	ldr	r3, [r7, #4]
24013e82:	639a      	str	r2, [r3, #56]	; 0x38
  PeriphClkInit->PLL3.PLL3VCOSEL = (uint32_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLL3VCOSEL) >> RCC_PLLCFGR_PLL3VCOSEL_Pos);
24013e84:	4b7a      	ldr	r3, [pc, #488]	; (24014070 <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
24013e86:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24013e88:	0a5b      	lsrs	r3, r3, #9
24013e8a:	f003 0201 	and.w	r2, r3, #1
24013e8e:	687b      	ldr	r3, [r7, #4]
24013e90:	63da      	str	r2, [r3, #60]	; 0x3c

  /* Get the PLL2 Clock configuration -----------------------------------------------*/
  PeriphClkInit->PLL2.PLL2M = (uint32_t)((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM2)>> RCC_PLLCKSELR_DIVM2_Pos);
24013e92:	4b77      	ldr	r3, [pc, #476]	; (24014070 <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
24013e94:	6a9b      	ldr	r3, [r3, #40]	; 0x28
24013e96:	0b1b      	lsrs	r3, r3, #12
24013e98:	f003 023f 	and.w	r2, r3, #63	; 0x3f
24013e9c:	687b      	ldr	r3, [r7, #4]
24013e9e:	605a      	str	r2, [r3, #4]
  PeriphClkInit->PLL2.PLL2N = (uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_N2) >> RCC_PLL2DIVR_N2_Pos)+ 1U;
24013ea0:	4b73      	ldr	r3, [pc, #460]	; (24014070 <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
24013ea2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
24013ea4:	f3c3 0308 	ubfx	r3, r3, #0, #9
24013ea8:	1c5a      	adds	r2, r3, #1
24013eaa:	687b      	ldr	r3, [r7, #4]
24013eac:	609a      	str	r2, [r3, #8]
  PeriphClkInit->PLL2.PLL2R = (uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_R2) >> RCC_PLL2DIVR_R2_Pos)+ 1U;
24013eae:	4b70      	ldr	r3, [pc, #448]	; (24014070 <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
24013eb0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
24013eb2:	0e1b      	lsrs	r3, r3, #24
24013eb4:	f003 037f 	and.w	r3, r3, #127	; 0x7f
24013eb8:	1c5a      	adds	r2, r3, #1
24013eba:	687b      	ldr	r3, [r7, #4]
24013ebc:	615a      	str	r2, [r3, #20]
  PeriphClkInit->PLL2.PLL2P = (uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_P2) >> RCC_PLL2DIVR_P2_Pos)+ 1U;
24013ebe:	4b6c      	ldr	r3, [pc, #432]	; (24014070 <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
24013ec0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
24013ec2:	0a5b      	lsrs	r3, r3, #9
24013ec4:	f003 037f 	and.w	r3, r3, #127	; 0x7f
24013ec8:	1c5a      	adds	r2, r3, #1
24013eca:	687b      	ldr	r3, [r7, #4]
24013ecc:	60da      	str	r2, [r3, #12]
  PeriphClkInit->PLL2.PLL2Q = (uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_Q2) >> RCC_PLL2DIVR_Q2_Pos)+ 1U;
24013ece:	4b68      	ldr	r3, [pc, #416]	; (24014070 <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
24013ed0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
24013ed2:	0c1b      	lsrs	r3, r3, #16
24013ed4:	f003 037f 	and.w	r3, r3, #127	; 0x7f
24013ed8:	1c5a      	adds	r2, r3, #1
24013eda:	687b      	ldr	r3, [r7, #4]
24013edc:	611a      	str	r2, [r3, #16]
  PeriphClkInit->PLL2.PLL2RGE = (uint32_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLL2RGE) >> RCC_PLLCFGR_PLL2RGE_Pos);
24013ede:	4b64      	ldr	r3, [pc, #400]	; (24014070 <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
24013ee0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24013ee2:	099b      	lsrs	r3, r3, #6
24013ee4:	f003 0203 	and.w	r2, r3, #3
24013ee8:	687b      	ldr	r3, [r7, #4]
24013eea:	619a      	str	r2, [r3, #24]
  PeriphClkInit->PLL2.PLL2VCOSEL = (uint32_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLL2VCOSEL) >> RCC_PLLCFGR_PLL2VCOSEL_Pos);
24013eec:	4b60      	ldr	r3, [pc, #384]	; (24014070 <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
24013eee:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24013ef0:	095b      	lsrs	r3, r3, #5
24013ef2:	f003 0201 	and.w	r2, r3, #1
24013ef6:	687b      	ldr	r3, [r7, #4]
24013ef8:	61da      	str	r2, [r3, #28]

  /* Get the USART1 configuration --------------------------------------------*/
  PeriphClkInit->Usart16ClockSelection      = __HAL_RCC_GET_USART16_SOURCE();
24013efa:	4b5d      	ldr	r3, [pc, #372]	; (24014070 <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
24013efc:	6d5b      	ldr	r3, [r3, #84]	; 0x54
24013efe:	f003 0238 	and.w	r2, r3, #56	; 0x38
24013f02:	687b      	ldr	r3, [r7, #4]
24013f04:	679a      	str	r2, [r3, #120]	; 0x78
  /* Get the USART2/3/4/5/7/8 clock source -----------------------------------*/
  PeriphClkInit->Usart234578ClockSelection  = __HAL_RCC_GET_USART234578_SOURCE();
24013f06:	4b5a      	ldr	r3, [pc, #360]	; (24014070 <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
24013f08:	6d5b      	ldr	r3, [r3, #84]	; 0x54
24013f0a:	f003 0207 	and.w	r2, r3, #7
24013f0e:	687b      	ldr	r3, [r7, #4]
24013f10:	675a      	str	r2, [r3, #116]	; 0x74
  /* Get the LPUART1 clock source --------------------------------------------*/
  PeriphClkInit->Lpuart1ClockSelection      = __HAL_RCC_GET_LPUART1_SOURCE();
24013f12:	4b57      	ldr	r3, [pc, #348]	; (24014070 <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
24013f14:	6d9b      	ldr	r3, [r3, #88]	; 0x58
24013f16:	f003 0207 	and.w	r2, r3, #7
24013f1a:	687b      	ldr	r3, [r7, #4]
24013f1c:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
  /* Get the I2C1/2/3 clock source -------------------------------------------*/
  PeriphClkInit->I2c123ClockSelection       = __HAL_RCC_GET_I2C1_SOURCE();
24013f20:	4b53      	ldr	r3, [pc, #332]	; (24014070 <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
24013f22:	6d5b      	ldr	r3, [r3, #84]	; 0x54
24013f24:	f403 5240 	and.w	r2, r3, #12288	; 0x3000
24013f28:	687b      	ldr	r3, [r7, #4]
24013f2a:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
  /* Get the LPTIM1 clock source ---------------------------------------------*/
  PeriphClkInit->Lptim1ClockSelection       = __HAL_RCC_GET_LPTIM1_SOURCE();
24013f2e:	4b50      	ldr	r3, [pc, #320]	; (24014070 <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
24013f30:	6d5b      	ldr	r3, [r3, #84]	; 0x54
24013f32:	f003 42e0 	and.w	r2, r3, #1879048192	; 0x70000000
24013f36:	687b      	ldr	r3, [r7, #4]
24013f38:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
  /* Get the LPTIM2 clock source ---------------------------------------------*/
  PeriphClkInit->Lptim2ClockSelection       = __HAL_RCC_GET_LPTIM2_SOURCE();
24013f3c:	4b4c      	ldr	r3, [pc, #304]	; (24014070 <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
24013f3e:	6d9b      	ldr	r3, [r3, #88]	; 0x58
24013f40:	f403 52e0 	and.w	r2, r3, #7168	; 0x1c00
24013f44:	687b      	ldr	r3, [r7, #4]
24013f46:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
  /* Get the LPTIM3/4/5 clock source -----------------------------------------*/
  PeriphClkInit->Lptim345ClockSelection     = __HAL_RCC_GET_LPTIM345_SOURCE();
24013f4a:	4b49      	ldr	r3, [pc, #292]	; (24014070 <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
24013f4c:	6d9b      	ldr	r3, [r3, #88]	; 0x58
24013f4e:	f403 4260 	and.w	r2, r3, #57344	; 0xe000
24013f52:	687b      	ldr	r3, [r7, #4]
24013f54:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c
  /* Get the SAI1 clock source -----------------------------------------------*/
  PeriphClkInit->Sai1ClockSelection         = __HAL_RCC_GET_SAI1_SOURCE();
24013f58:	4b45      	ldr	r3, [pc, #276]	; (24014070 <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
24013f5a:	6d1b      	ldr	r3, [r3, #80]	; 0x50
24013f5c:	f003 0207 	and.w	r2, r3, #7
24013f60:	687b      	ldr	r3, [r7, #4]
24013f62:	655a      	str	r2, [r3, #84]	; 0x54
#if defined(SAI3)
  /* Get the SAI2/3 clock source ---------------------------------------------*/
  PeriphClkInit->Sai23ClockSelection        = __HAL_RCC_GET_SAI23_SOURCE();
24013f64:	4b42      	ldr	r3, [pc, #264]	; (24014070 <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
24013f66:	6d1b      	ldr	r3, [r3, #80]	; 0x50
24013f68:	f403 72e0 	and.w	r2, r3, #448	; 0x1c0
24013f6c:	687b      	ldr	r3, [r7, #4]
24013f6e:	659a      	str	r2, [r3, #88]	; 0x58
  /* Get the SAI2B clock source ---------------------------------------------*/
  PeriphClkInit->Sai2BClockSelection        = __HAL_RCC_GET_SAI2B_SOURCE();
#endif  /*SAI2B*/
#if defined(SAI4)
  /* Get the SAI4A clock source ----------------------------------------------*/
  PeriphClkInit->Sai4AClockSelection        = __HAL_RCC_GET_SAI4A_SOURCE();
24013f70:	4b3f      	ldr	r3, [pc, #252]	; (24014070 <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
24013f72:	6d9b      	ldr	r3, [r3, #88]	; 0x58
24013f74:	f403 0260 	and.w	r2, r3, #14680064	; 0xe00000
24013f78:	687b      	ldr	r3, [r7, #4]
24013f7a:	f8c3 20a4 	str.w	r2, [r3, #164]	; 0xa4
  /* Get the SAI4B clock source ----------------------------------------------*/
  PeriphClkInit->Sai4BClockSelection        = __HAL_RCC_GET_SAI4B_SOURCE();
24013f7e:	4b3c      	ldr	r3, [pc, #240]	; (24014070 <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
24013f80:	6d9b      	ldr	r3, [r3, #88]	; 0x58
24013f82:	f003 62e0 	and.w	r2, r3, #117440512	; 0x7000000
24013f86:	687b      	ldr	r3, [r7, #4]
24013f88:	f8c3 20a8 	str.w	r2, [r3, #168]	; 0xa8
#endif  /*SAI4*/
  /* Get the RTC clock source ------------------------------------------------*/
  PeriphClkInit->RTCClockSelection          = __HAL_RCC_GET_RTC_SOURCE();
24013f8c:	4b38      	ldr	r3, [pc, #224]	; (24014070 <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
24013f8e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
24013f90:	f403 7240 	and.w	r2, r3, #768	; 0x300
24013f94:	687b      	ldr	r3, [r7, #4]
24013f96:	f8c3 20b0 	str.w	r2, [r3, #176]	; 0xb0
  /* Get the USB clock source ------------------------------------------------*/
  PeriphClkInit->UsbClockSelection          = __HAL_RCC_GET_USB_SOURCE();
24013f9a:	4b35      	ldr	r3, [pc, #212]	; (24014070 <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
24013f9c:	6d5b      	ldr	r3, [r3, #84]	; 0x54
24013f9e:	f403 1240 	and.w	r2, r3, #3145728	; 0x300000
24013fa2:	687b      	ldr	r3, [r7, #4]
24013fa4:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
  /* Get the SDMMC clock source ----------------------------------------------*/
  PeriphClkInit->SdmmcClockSelection        = __HAL_RCC_GET_SDMMC_SOURCE();
24013fa8:	4b31      	ldr	r3, [pc, #196]	; (24014070 <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
24013faa:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
24013fac:	f403 3280 	and.w	r2, r3, #65536	; 0x10000
24013fb0:	687b      	ldr	r3, [r7, #4]
24013fb2:	64da      	str	r2, [r3, #76]	; 0x4c
  /* Get the RNG clock source ------------------------------------------------*/
  PeriphClkInit->RngClockSelection          = __HAL_RCC_GET_RNG_SOURCE();
24013fb4:	4b2e      	ldr	r3, [pc, #184]	; (24014070 <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
24013fb6:	6d5b      	ldr	r3, [r3, #84]	; 0x54
24013fb8:	f403 7240 	and.w	r2, r3, #768	; 0x300
24013fbc:	687b      	ldr	r3, [r7, #4]
24013fbe:	67da      	str	r2, [r3, #124]	; 0x7c
#if defined(HRTIM1)
  /* Get the HRTIM1 clock source ---------------------------------------------*/
  PeriphClkInit->Hrtim1ClockSelection       = __HAL_RCC_GET_HRTIM1_SOURCE();
24013fc0:	4b2b      	ldr	r3, [pc, #172]	; (24014070 <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
24013fc2:	691b      	ldr	r3, [r3, #16]
24013fc4:	f403 4280 	and.w	r2, r3, #16384	; 0x4000
24013fc8:	687b      	ldr	r3, [r7, #4]
24013fca:	f8c3 20b4 	str.w	r2, [r3, #180]	; 0xb4
#endif /* HRTIM1 */
  /* Get the ADC clock source ------------------------------------------------*/
  PeriphClkInit->AdcClockSelection          = __HAL_RCC_GET_ADC_SOURCE();
24013fce:	4b28      	ldr	r3, [pc, #160]	; (24014070 <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
24013fd0:	6d9b      	ldr	r3, [r3, #88]	; 0x58
24013fd2:	f403 3240 	and.w	r2, r3, #196608	; 0x30000
24013fd6:	687b      	ldr	r3, [r7, #4]
24013fd8:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
  /* Get the SWPMI1 clock source ---------------------------------------------*/
  PeriphClkInit->Swpmi1ClockSelection       = __HAL_RCC_GET_SWPMI1_SOURCE();
24013fdc:	4b24      	ldr	r3, [pc, #144]	; (24014070 <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
24013fde:	6d1b      	ldr	r3, [r3, #80]	; 0x50
24013fe0:	f003 4200 	and.w	r2, r3, #2147483648	; 0x80000000
24013fe4:	687b      	ldr	r3, [r7, #4]
24013fe6:	671a      	str	r2, [r3, #112]	; 0x70
  /* Get the DFSDM1 clock source ---------------------------------------------*/
  PeriphClkInit->Dfsdm1ClockSelection       = __HAL_RCC_GET_DFSDM1_SOURCE();
24013fe8:	4b21      	ldr	r3, [pc, #132]	; (24014070 <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
24013fea:	6d1b      	ldr	r3, [r3, #80]	; 0x50
24013fec:	f003 7280 	and.w	r2, r3, #16777216	; 0x1000000
24013ff0:	687b      	ldr	r3, [r7, #4]
24013ff2:	669a      	str	r2, [r3, #104]	; 0x68
#if defined(DFSDM2_BASE)
  /* Get the DFSDM2 clock source ---------------------------------------------*/
  PeriphClkInit->Dfsdm2ClockSelection       = __HAL_RCC_GET_DFSDM2_SOURCE();
#endif /* DFSDM2 */
  /* Get the SPDIFRX clock source --------------------------------------------*/
  PeriphClkInit->SpdifrxClockSelection      = __HAL_RCC_GET_SPDIFRX_SOURCE();
24013ff4:	4b1e      	ldr	r3, [pc, #120]	; (24014070 <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
24013ff6:	6d1b      	ldr	r3, [r3, #80]	; 0x50
24013ff8:	f403 1240 	and.w	r2, r3, #3145728	; 0x300000
24013ffc:	687b      	ldr	r3, [r7, #4]
24013ffe:	665a      	str	r2, [r3, #100]	; 0x64
  /* Get the SPI1/2/3 clock source -------------------------------------------*/
  PeriphClkInit->Spi123ClockSelection       = __HAL_RCC_GET_SPI123_SOURCE();
24014000:	4b1b      	ldr	r3, [pc, #108]	; (24014070 <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
24014002:	6d1b      	ldr	r3, [r3, #80]	; 0x50
24014004:	f403 42e0 	and.w	r2, r3, #28672	; 0x7000
24014008:	687b      	ldr	r3, [r7, #4]
2401400a:	65da      	str	r2, [r3, #92]	; 0x5c
  /* Get the SPI4/5 clock source ---------------------------------------------*/
  PeriphClkInit->Spi45ClockSelection        = __HAL_RCC_GET_SPI45_SOURCE();
2401400c:	4b18      	ldr	r3, [pc, #96]	; (24014070 <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
2401400e:	6d1b      	ldr	r3, [r3, #80]	; 0x50
24014010:	f403 22e0 	and.w	r2, r3, #458752	; 0x70000
24014014:	687b      	ldr	r3, [r7, #4]
24014016:	661a      	str	r2, [r3, #96]	; 0x60
  /* Get the SPI6 clock source -----------------------------------------------*/
  PeriphClkInit->Spi6ClockSelection         = __HAL_RCC_GET_SPI6_SOURCE();
24014018:	4b15      	ldr	r3, [pc, #84]	; (24014070 <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
2401401a:	6d9b      	ldr	r3, [r3, #88]	; 0x58
2401401c:	f003 42e0 	and.w	r2, r3, #1879048192	; 0x70000000
24014020:	687b      	ldr	r3, [r7, #4]
24014022:	f8c3 20ac 	str.w	r2, [r3, #172]	; 0xac
  /* Get the FDCAN clock source ----------------------------------------------*/
  PeriphClkInit->FdcanClockSelection        = __HAL_RCC_GET_FDCAN_SOURCE();
24014026:	4b12      	ldr	r3, [pc, #72]	; (24014070 <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
24014028:	6d1b      	ldr	r3, [r3, #80]	; 0x50
2401402a:	f003 5240 	and.w	r2, r3, #805306368	; 0x30000000
2401402e:	687b      	ldr	r3, [r7, #4]
24014030:	66da      	str	r2, [r3, #108]	; 0x6c
  /* Get the CEC clock source ------------------------------------------------*/
  PeriphClkInit->CecClockSelection          = __HAL_RCC_GET_CEC_SOURCE();
24014032:	4b0f      	ldr	r3, [pc, #60]	; (24014070 <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
24014034:	6d5b      	ldr	r3, [r3, #84]	; 0x54
24014036:	f403 0240 	and.w	r2, r3, #12582912	; 0xc00000
2401403a:	687b      	ldr	r3, [r7, #4]
2401403c:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
  /* Get the FMC clock source ------------------------------------------------*/
  PeriphClkInit->FmcClockSelection          = __HAL_RCC_GET_FMC_SOURCE();
24014040:	4b0b      	ldr	r3, [pc, #44]	; (24014070 <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
24014042:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
24014044:	f003 0203 	and.w	r2, r3, #3
24014048:	687b      	ldr	r3, [r7, #4]
2401404a:	645a      	str	r2, [r3, #68]	; 0x44
#if defined(QUADSPI)
  /* Get the QSPI clock source -----------------------------------------------*/
  PeriphClkInit->QspiClockSelection         = __HAL_RCC_GET_QSPI_SOURCE();
2401404c:	4b08      	ldr	r3, [pc, #32]	; (24014070 <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
2401404e:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
24014050:	f003 0230 	and.w	r2, r3, #48	; 0x30
24014054:	687b      	ldr	r3, [r7, #4]
24014056:	649a      	str	r2, [r3, #72]	; 0x48
  /* Get the DSI clock source ------------------------------------------------*/
  PeriphClkInit->DsiClockSelection          = __HAL_RCC_GET_DSI_SOURCE();
#endif /*DSI*/

  /* Get the CKPER clock source ----------------------------------------------*/
  PeriphClkInit->CkperClockSelection        = __HAL_RCC_GET_CLKP_SOURCE();
24014058:	4b05      	ldr	r3, [pc, #20]	; (24014070 <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
2401405a:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
2401405c:	f003 5240 	and.w	r2, r3, #805306368	; 0x30000000
24014060:	687b      	ldr	r3, [r7, #4]
24014062:	651a      	str	r2, [r3, #80]	; 0x50

  /* Get the TIM Prescaler configuration -------------------------------------*/
  if ((RCC->CFGR & RCC_CFGR_TIMPRE) == 0U)
24014064:	4b02      	ldr	r3, [pc, #8]	; (24014070 <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
24014066:	691b      	ldr	r3, [r3, #16]
24014068:	e004      	b.n	24014074 <HAL_RCCEx_GetPeriphCLKConfig+0x2a0>
2401406a:	bf00      	nop
2401406c:	c9fff1f7 	.word	0xc9fff1f7
24014070:	58024400 	.word	0x58024400
24014074:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
24014078:	2b00      	cmp	r3, #0
2401407a:	d104      	bne.n	24014086 <HAL_RCCEx_GetPeriphCLKConfig+0x2b2>
  {
    PeriphClkInit->TIMPresSelection = RCC_TIMPRES_DESACTIVATED;
2401407c:	687b      	ldr	r3, [r7, #4]
2401407e:	2200      	movs	r2, #0
24014080:	f8c3 20b8 	str.w	r2, [r3, #184]	; 0xb8
  }
  else
  {
    PeriphClkInit->TIMPresSelection = RCC_TIMPRES_ACTIVATED;
  }
}
24014084:	e004      	b.n	24014090 <HAL_RCCEx_GetPeriphCLKConfig+0x2bc>
    PeriphClkInit->TIMPresSelection = RCC_TIMPRES_ACTIVATED;
24014086:	687b      	ldr	r3, [r7, #4]
24014088:	f44f 4200 	mov.w	r2, #32768	; 0x8000
2401408c:	f8c3 20b8 	str.w	r2, [r3, #184]	; 0xb8
}
24014090:	bf00      	nop
24014092:	370c      	adds	r7, #12
24014094:	46bd      	mov	sp, r7
24014096:	f85d 7b04 	ldr.w	r7, [sp], #4
2401409a:	4770      	bx	lr

2401409c <HAL_RCCEx_GetPeriphCLKFreq>:
  * @retval Frequency in KHz
  *
  *  (*) : Available on some STM32H7 lines only.
  */
uint32_t HAL_RCCEx_GetPeriphCLKFreq(uint32_t PeriphClk)
{
2401409c:	b580      	push	{r7, lr}
2401409e:	b090      	sub	sp, #64	; 0x40
240140a0:	af00      	add	r7, sp, #0
240140a2:	6078      	str	r0, [r7, #4]
  /* This variable is used to store the SAI and CKP clock source */
  uint32_t saiclocksource;
  uint32_t ckpclocksource;
  uint32_t srcclk;

  if (PeriphClk == RCC_PERIPHCLK_SAI1)
240140a4:	687b      	ldr	r3, [r7, #4]
240140a6:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
240140aa:	d150      	bne.n	2401414e <HAL_RCCEx_GetPeriphCLKFreq+0xb2>
    {

      saiclocksource= __HAL_RCC_GET_SAI1_SOURCE();
240140ac:	4ba1      	ldr	r3, [pc, #644]	; (24014334 <HAL_RCCEx_GetPeriphCLKFreq+0x298>)
240140ae:	6d1b      	ldr	r3, [r3, #80]	; 0x50
240140b0:	f003 0307 	and.w	r3, r3, #7
240140b4:	633b      	str	r3, [r7, #48]	; 0x30

      switch (saiclocksource)
240140b6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
240140b8:	2b04      	cmp	r3, #4
240140ba:	d844      	bhi.n	24014146 <HAL_RCCEx_GetPeriphCLKFreq+0xaa>
240140bc:	a201      	add	r2, pc, #4	; (adr r2, 240140c4 <HAL_RCCEx_GetPeriphCLKFreq+0x28>)
240140be:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
240140c2:	bf00      	nop
240140c4:	240140d9 	.word	0x240140d9
240140c8:	240140e9 	.word	0x240140e9
240140cc:	240140f9 	.word	0x240140f9
240140d0:	24014141 	.word	0x24014141
240140d4:	24014109 	.word	0x24014109
      {
      case RCC_SAI1CLKSOURCE_PLL: /* PLL1 is the clock source for SAI1 */
        {
          HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
240140d8:	f107 0324 	add.w	r3, r7, #36	; 0x24
240140dc:	4618      	mov	r0, r3
240140de:	f000 fd19 	bl	24014b14 <HAL_RCCEx_GetPLL1ClockFreq>
          frequency = pll1_clocks.PLL1_Q_Frequency;
240140e2:	6abb      	ldr	r3, [r7, #40]	; 0x28
240140e4:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
240140e6:	e241      	b.n	2401456c <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }
      case RCC_SAI1CLKSOURCE_PLL2: /* PLL2 is the clock source for SAI1 */
        {
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
240140e8:	f107 0318 	add.w	r3, r7, #24
240140ec:	4618      	mov	r0, r3
240140ee:	f000 fa79 	bl	240145e4 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_P_Frequency;
240140f2:	69bb      	ldr	r3, [r7, #24]
240140f4:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
240140f6:	e239      	b.n	2401456c <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }

      case RCC_SAI1CLKSOURCE_PLL3: /* PLL3 is the clock source for SAI1 */
        {
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
240140f8:	f107 030c 	add.w	r3, r7, #12
240140fc:	4618      	mov	r0, r3
240140fe:	f000 fbbd 	bl	2401487c <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_P_Frequency;
24014102:	68fb      	ldr	r3, [r7, #12]
24014104:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
24014106:	e231      	b.n	2401456c <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }

      case RCC_SAI1CLKSOURCE_CLKP: /* CKPER is the clock source for SAI1*/
        {

          ckpclocksource= __HAL_RCC_GET_CLKP_SOURCE();
24014108:	4b8a      	ldr	r3, [pc, #552]	; (24014334 <HAL_RCCEx_GetPeriphCLKFreq+0x298>)
2401410a:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
2401410c:	f003 5340 	and.w	r3, r3, #805306368	; 0x30000000
24014110:	637b      	str	r3, [r7, #52]	; 0x34

          if(ckpclocksource== RCC_CLKPSOURCE_HSI)
24014112:	6b7b      	ldr	r3, [r7, #52]	; 0x34
24014114:	2b00      	cmp	r3, #0
24014116:	d102      	bne.n	2401411e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
          {
            /* In Case the CKPER Source is HSI */
            frequency = HSI_VALUE;
24014118:	4b87      	ldr	r3, [pc, #540]	; (24014338 <HAL_RCCEx_GetPeriphCLKFreq+0x29c>)
2401411a:	63fb      	str	r3, [r7, #60]	; 0x3c
          {
            /* In Case the CKPER is disabled*/
            frequency = 0;
          }

          break;
2401411c:	e226      	b.n	2401456c <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
          else if(ckpclocksource== RCC_CLKPSOURCE_CSI)
2401411e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
24014120:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
24014124:	d102      	bne.n	2401412c <HAL_RCCEx_GetPeriphCLKFreq+0x90>
            frequency = CSI_VALUE;
24014126:	4b85      	ldr	r3, [pc, #532]	; (2401433c <HAL_RCCEx_GetPeriphCLKFreq+0x2a0>)
24014128:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
2401412a:	e21f      	b.n	2401456c <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
          else if (ckpclocksource== RCC_CLKPSOURCE_HSE)
2401412c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
2401412e:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
24014132:	d102      	bne.n	2401413a <HAL_RCCEx_GetPeriphCLKFreq+0x9e>
            frequency = HSE_VALUE;
24014134:	4b82      	ldr	r3, [pc, #520]	; (24014340 <HAL_RCCEx_GetPeriphCLKFreq+0x2a4>)
24014136:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
24014138:	e218      	b.n	2401456c <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
            frequency = 0;
2401413a:	2300      	movs	r3, #0
2401413c:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
2401413e:	e215      	b.n	2401456c <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }

      case (RCC_SAI1CLKSOURCE_PIN): /* External clock is the clock source for SAI1 */
        {
          frequency = EXTERNAL_CLOCK_VALUE;
24014140:	4b80      	ldr	r3, [pc, #512]	; (24014344 <HAL_RCCEx_GetPeriphCLKFreq+0x2a8>)
24014142:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
24014144:	e212      	b.n	2401456c <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }
      default :
        {
          frequency = 0;
24014146:	2300      	movs	r3, #0
24014148:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
2401414a:	bf00      	nop
2401414c:	e20e      	b.n	2401456c <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }
      }
    }

#if defined(SAI3)
  else if (PeriphClk == RCC_PERIPHCLK_SAI23)
2401414e:	687b      	ldr	r3, [r7, #4]
24014150:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
24014154:	d14f      	bne.n	240141f6 <HAL_RCCEx_GetPeriphCLKFreq+0x15a>
    {

      saiclocksource= __HAL_RCC_GET_SAI23_SOURCE();
24014156:	4b77      	ldr	r3, [pc, #476]	; (24014334 <HAL_RCCEx_GetPeriphCLKFreq+0x298>)
24014158:	6d1b      	ldr	r3, [r3, #80]	; 0x50
2401415a:	f403 73e0 	and.w	r3, r3, #448	; 0x1c0
2401415e:	633b      	str	r3, [r7, #48]	; 0x30

      switch (saiclocksource)
24014160:	6b3b      	ldr	r3, [r7, #48]	; 0x30
24014162:	2b80      	cmp	r3, #128	; 0x80
24014164:	d01c      	beq.n	240141a0 <HAL_RCCEx_GetPeriphCLKFreq+0x104>
24014166:	2b80      	cmp	r3, #128	; 0x80
24014168:	d804      	bhi.n	24014174 <HAL_RCCEx_GetPeriphCLKFreq+0xd8>
2401416a:	2b00      	cmp	r3, #0
2401416c:	d008      	beq.n	24014180 <HAL_RCCEx_GetPeriphCLKFreq+0xe4>
2401416e:	2b40      	cmp	r3, #64	; 0x40
24014170:	d00e      	beq.n	24014190 <HAL_RCCEx_GetPeriphCLKFreq+0xf4>
24014172:	e03c      	b.n	240141ee <HAL_RCCEx_GetPeriphCLKFreq+0x152>
24014174:	2bc0      	cmp	r3, #192	; 0xc0
24014176:	d037      	beq.n	240141e8 <HAL_RCCEx_GetPeriphCLKFreq+0x14c>
24014178:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
2401417c:	d018      	beq.n	240141b0 <HAL_RCCEx_GetPeriphCLKFreq+0x114>
2401417e:	e036      	b.n	240141ee <HAL_RCCEx_GetPeriphCLKFreq+0x152>
      {
      case 0: /* PLL1 is the clock source for SAI2/3 */
        {
          HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
24014180:	f107 0324 	add.w	r3, r7, #36	; 0x24
24014184:	4618      	mov	r0, r3
24014186:	f000 fcc5 	bl	24014b14 <HAL_RCCEx_GetPLL1ClockFreq>
          frequency = pll1_clocks.PLL1_Q_Frequency;
2401418a:	6abb      	ldr	r3, [r7, #40]	; 0x28
2401418c:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
2401418e:	e1ed      	b.n	2401456c <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }
      case RCC_SAI23CLKSOURCE_PLL2: /* PLL2 is the clock source for SAI2/3 */
        {
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
24014190:	f107 0318 	add.w	r3, r7, #24
24014194:	4618      	mov	r0, r3
24014196:	f000 fa25 	bl	240145e4 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_P_Frequency;
2401419a:	69bb      	ldr	r3, [r7, #24]
2401419c:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
2401419e:	e1e5      	b.n	2401456c <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }

      case RCC_SAI23CLKSOURCE_PLL3: /* PLL3 is the clock source for SAI2/3 */
        {
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
240141a0:	f107 030c 	add.w	r3, r7, #12
240141a4:	4618      	mov	r0, r3
240141a6:	f000 fb69 	bl	2401487c <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_P_Frequency;
240141aa:	68fb      	ldr	r3, [r7, #12]
240141ac:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
240141ae:	e1dd      	b.n	2401456c <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }

      case RCC_SAI23CLKSOURCE_CLKP: /* CKPER is the clock source for SAI2/3 */
        {

          ckpclocksource= __HAL_RCC_GET_CLKP_SOURCE();
240141b0:	4b60      	ldr	r3, [pc, #384]	; (24014334 <HAL_RCCEx_GetPeriphCLKFreq+0x298>)
240141b2:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
240141b4:	f003 5340 	and.w	r3, r3, #805306368	; 0x30000000
240141b8:	637b      	str	r3, [r7, #52]	; 0x34

          if(ckpclocksource== RCC_CLKPSOURCE_HSI)
240141ba:	6b7b      	ldr	r3, [r7, #52]	; 0x34
240141bc:	2b00      	cmp	r3, #0
240141be:	d102      	bne.n	240141c6 <HAL_RCCEx_GetPeriphCLKFreq+0x12a>
          {
            /* In Case the CKPER Source is HSI */
            frequency = HSI_VALUE;
240141c0:	4b5d      	ldr	r3, [pc, #372]	; (24014338 <HAL_RCCEx_GetPeriphCLKFreq+0x29c>)
240141c2:	63fb      	str	r3, [r7, #60]	; 0x3c
          {
            /* In Case the CKPER is disabled*/
            frequency = 0;
          }

          break;
240141c4:	e1d2      	b.n	2401456c <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
          else if(ckpclocksource== RCC_CLKPSOURCE_CSI)
240141c6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
240141c8:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
240141cc:	d102      	bne.n	240141d4 <HAL_RCCEx_GetPeriphCLKFreq+0x138>
            frequency = CSI_VALUE;
240141ce:	4b5b      	ldr	r3, [pc, #364]	; (2401433c <HAL_RCCEx_GetPeriphCLKFreq+0x2a0>)
240141d0:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
240141d2:	e1cb      	b.n	2401456c <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
          else if (ckpclocksource== RCC_CLKPSOURCE_HSE)
240141d4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
240141d6:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
240141da:	d102      	bne.n	240141e2 <HAL_RCCEx_GetPeriphCLKFreq+0x146>
            frequency = HSE_VALUE;
240141dc:	4b58      	ldr	r3, [pc, #352]	; (24014340 <HAL_RCCEx_GetPeriphCLKFreq+0x2a4>)
240141de:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
240141e0:	e1c4      	b.n	2401456c <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
            frequency = 0;
240141e2:	2300      	movs	r3, #0
240141e4:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
240141e6:	e1c1      	b.n	2401456c <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }

      case (RCC_SAI23CLKSOURCE_PIN): /* External clock is the clock source for SAI2/3 */
        {
          frequency = EXTERNAL_CLOCK_VALUE;
240141e8:	4b56      	ldr	r3, [pc, #344]	; (24014344 <HAL_RCCEx_GetPeriphCLKFreq+0x2a8>)
240141ea:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
240141ec:	e1be      	b.n	2401456c <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }
      default :
        {
          frequency = 0;
240141ee:	2300      	movs	r3, #0
240141f0:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
240141f2:	bf00      	nop
240141f4:	e1ba      	b.n	2401456c <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
      }
    }
#endif

#if defined(SAI4)
  else if (PeriphClk == RCC_PERIPHCLK_SAI4A)
240141f6:	687b      	ldr	r3, [r7, #4]
240141f8:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
240141fc:	d153      	bne.n	240142a6 <HAL_RCCEx_GetPeriphCLKFreq+0x20a>
    {

      saiclocksource= __HAL_RCC_GET_SAI4A_SOURCE();
240141fe:	4b4d      	ldr	r3, [pc, #308]	; (24014334 <HAL_RCCEx_GetPeriphCLKFreq+0x298>)
24014200:	6d9b      	ldr	r3, [r3, #88]	; 0x58
24014202:	f403 0360 	and.w	r3, r3, #14680064	; 0xe00000
24014206:	633b      	str	r3, [r7, #48]	; 0x30

      switch (saiclocksource)
24014208:	6b3b      	ldr	r3, [r7, #48]	; 0x30
2401420a:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
2401420e:	d01f      	beq.n	24014250 <HAL_RCCEx_GetPeriphCLKFreq+0x1b4>
24014210:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
24014214:	d805      	bhi.n	24014222 <HAL_RCCEx_GetPeriphCLKFreq+0x186>
24014216:	2b00      	cmp	r3, #0
24014218:	d00a      	beq.n	24014230 <HAL_RCCEx_GetPeriphCLKFreq+0x194>
2401421a:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
2401421e:	d00f      	beq.n	24014240 <HAL_RCCEx_GetPeriphCLKFreq+0x1a4>
24014220:	e03d      	b.n	2401429e <HAL_RCCEx_GetPeriphCLKFreq+0x202>
24014222:	f5b3 0fc0 	cmp.w	r3, #6291456	; 0x600000
24014226:	d037      	beq.n	24014298 <HAL_RCCEx_GetPeriphCLKFreq+0x1fc>
24014228:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
2401422c:	d018      	beq.n	24014260 <HAL_RCCEx_GetPeriphCLKFreq+0x1c4>
2401422e:	e036      	b.n	2401429e <HAL_RCCEx_GetPeriphCLKFreq+0x202>
      {
      case 0: /* PLL1 is the clock source for SAI4A */
        {
          HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
24014230:	f107 0324 	add.w	r3, r7, #36	; 0x24
24014234:	4618      	mov	r0, r3
24014236:	f000 fc6d 	bl	24014b14 <HAL_RCCEx_GetPLL1ClockFreq>
          frequency = pll1_clocks.PLL1_Q_Frequency;
2401423a:	6abb      	ldr	r3, [r7, #40]	; 0x28
2401423c:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
2401423e:	e195      	b.n	2401456c <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }
      case RCC_D3CCIPR_SAI4ASEL_0: /* PLLI2 is the clock source for SAI4A */
        {
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
24014240:	f107 0318 	add.w	r3, r7, #24
24014244:	4618      	mov	r0, r3
24014246:	f000 f9cd 	bl	240145e4 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_P_Frequency;
2401424a:	69bb      	ldr	r3, [r7, #24]
2401424c:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
2401424e:	e18d      	b.n	2401456c <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }

      case RCC_D3CCIPR_SAI4ASEL_1: /* PLLI3 is the clock source for SAI4A */
        {
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
24014250:	f107 030c 	add.w	r3, r7, #12
24014254:	4618      	mov	r0, r3
24014256:	f000 fb11 	bl	2401487c <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_P_Frequency;
2401425a:	68fb      	ldr	r3, [r7, #12]
2401425c:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
2401425e:	e185      	b.n	2401456c <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }

      case RCC_D3CCIPR_SAI4ASEL_2: /* CKPER is the clock source for SAI4A*/
        {

          ckpclocksource= __HAL_RCC_GET_CLKP_SOURCE();
24014260:	4b34      	ldr	r3, [pc, #208]	; (24014334 <HAL_RCCEx_GetPeriphCLKFreq+0x298>)
24014262:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
24014264:	f003 5340 	and.w	r3, r3, #805306368	; 0x30000000
24014268:	637b      	str	r3, [r7, #52]	; 0x34

          if(ckpclocksource== RCC_CLKPSOURCE_HSI)
2401426a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
2401426c:	2b00      	cmp	r3, #0
2401426e:	d102      	bne.n	24014276 <HAL_RCCEx_GetPeriphCLKFreq+0x1da>
          {
            /* In Case the CKPER Source is HSI */
            frequency = HSI_VALUE;
24014270:	4b31      	ldr	r3, [pc, #196]	; (24014338 <HAL_RCCEx_GetPeriphCLKFreq+0x29c>)
24014272:	63fb      	str	r3, [r7, #60]	; 0x3c
          {
            /* In Case the CKPER is disabled*/
            frequency = 0;
          }

          break;
24014274:	e17a      	b.n	2401456c <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
          else if(ckpclocksource== RCC_CLKPSOURCE_CSI)
24014276:	6b7b      	ldr	r3, [r7, #52]	; 0x34
24014278:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
2401427c:	d102      	bne.n	24014284 <HAL_RCCEx_GetPeriphCLKFreq+0x1e8>
            frequency = CSI_VALUE;
2401427e:	4b2f      	ldr	r3, [pc, #188]	; (2401433c <HAL_RCCEx_GetPeriphCLKFreq+0x2a0>)
24014280:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
24014282:	e173      	b.n	2401456c <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
          else if (ckpclocksource== RCC_CLKPSOURCE_HSE)
24014284:	6b7b      	ldr	r3, [r7, #52]	; 0x34
24014286:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
2401428a:	d102      	bne.n	24014292 <HAL_RCCEx_GetPeriphCLKFreq+0x1f6>
            frequency = HSE_VALUE;
2401428c:	4b2c      	ldr	r3, [pc, #176]	; (24014340 <HAL_RCCEx_GetPeriphCLKFreq+0x2a4>)
2401428e:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
24014290:	e16c      	b.n	2401456c <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
            frequency = 0;
24014292:	2300      	movs	r3, #0
24014294:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
24014296:	e169      	b.n	2401456c <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }

      case (RCC_D3CCIPR_SAI4ASEL_0 | RCC_D3CCIPR_SAI4ASEL_1 ): /* External clock is the clock source for SAI4A */
        {
          frequency = EXTERNAL_CLOCK_VALUE;
24014298:	4b2a      	ldr	r3, [pc, #168]	; (24014344 <HAL_RCCEx_GetPeriphCLKFreq+0x2a8>)
2401429a:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
2401429c:	e166      	b.n	2401456c <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }

      default :
        {
          frequency = 0;
2401429e:	2300      	movs	r3, #0
240142a0:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
240142a2:	bf00      	nop
240142a4:	e162      	b.n	2401456c <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }
      }
    }

  else if (PeriphClk == RCC_PERIPHCLK_SAI4B)
240142a6:	687b      	ldr	r3, [r7, #4]
240142a8:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
240142ac:	d15d      	bne.n	2401436a <HAL_RCCEx_GetPeriphCLKFreq+0x2ce>
    {

      saiclocksource= __HAL_RCC_GET_SAI4B_SOURCE();
240142ae:	4b21      	ldr	r3, [pc, #132]	; (24014334 <HAL_RCCEx_GetPeriphCLKFreq+0x298>)
240142b0:	6d9b      	ldr	r3, [r3, #88]	; 0x58
240142b2:	f003 63e0 	and.w	r3, r3, #117440512	; 0x7000000
240142b6:	633b      	str	r3, [r7, #48]	; 0x30

      switch (saiclocksource)
240142b8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
240142ba:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
240142be:	d01f      	beq.n	24014300 <HAL_RCCEx_GetPeriphCLKFreq+0x264>
240142c0:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
240142c4:	d805      	bhi.n	240142d2 <HAL_RCCEx_GetPeriphCLKFreq+0x236>
240142c6:	2b00      	cmp	r3, #0
240142c8:	d00a      	beq.n	240142e0 <HAL_RCCEx_GetPeriphCLKFreq+0x244>
240142ca:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
240142ce:	d00f      	beq.n	240142f0 <HAL_RCCEx_GetPeriphCLKFreq+0x254>
240142d0:	e047      	b.n	24014362 <HAL_RCCEx_GetPeriphCLKFreq+0x2c6>
240142d2:	f1b3 7f40 	cmp.w	r3, #50331648	; 0x3000000
240142d6:	d041      	beq.n	2401435c <HAL_RCCEx_GetPeriphCLKFreq+0x2c0>
240142d8:	f1b3 6f80 	cmp.w	r3, #67108864	; 0x4000000
240142dc:	d018      	beq.n	24014310 <HAL_RCCEx_GetPeriphCLKFreq+0x274>
240142de:	e040      	b.n	24014362 <HAL_RCCEx_GetPeriphCLKFreq+0x2c6>
      {
      case 0: /* PLL1 is the clock source for SAI4B */
        {
          HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
240142e0:	f107 0324 	add.w	r3, r7, #36	; 0x24
240142e4:	4618      	mov	r0, r3
240142e6:	f000 fc15 	bl	24014b14 <HAL_RCCEx_GetPLL1ClockFreq>
          frequency = pll1_clocks.PLL1_Q_Frequency;
240142ea:	6abb      	ldr	r3, [r7, #40]	; 0x28
240142ec:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
240142ee:	e13d      	b.n	2401456c <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }
      case RCC_D3CCIPR_SAI4BSEL_0: /* PLLI2 is the clock source for SAI4B */
        {
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
240142f0:	f107 0318 	add.w	r3, r7, #24
240142f4:	4618      	mov	r0, r3
240142f6:	f000 f975 	bl	240145e4 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_P_Frequency;
240142fa:	69bb      	ldr	r3, [r7, #24]
240142fc:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
240142fe:	e135      	b.n	2401456c <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }

      case RCC_D3CCIPR_SAI4BSEL_1: /* PLLI3 is the clock source for SAI4B */
        {
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
24014300:	f107 030c 	add.w	r3, r7, #12
24014304:	4618      	mov	r0, r3
24014306:	f000 fab9 	bl	2401487c <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_P_Frequency;
2401430a:	68fb      	ldr	r3, [r7, #12]
2401430c:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
2401430e:	e12d      	b.n	2401456c <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }

      case RCC_D3CCIPR_SAI4BSEL_2: /* CKPER is the clock source for SAI4B*/
        {

          ckpclocksource= __HAL_RCC_GET_CLKP_SOURCE();
24014310:	4b08      	ldr	r3, [pc, #32]	; (24014334 <HAL_RCCEx_GetPeriphCLKFreq+0x298>)
24014312:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
24014314:	f003 5340 	and.w	r3, r3, #805306368	; 0x30000000
24014318:	637b      	str	r3, [r7, #52]	; 0x34

          if(ckpclocksource== RCC_CLKPSOURCE_HSI)
2401431a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
2401431c:	2b00      	cmp	r3, #0
2401431e:	d102      	bne.n	24014326 <HAL_RCCEx_GetPeriphCLKFreq+0x28a>
          {
            /* In Case the CKPER Source is HSI */
            frequency = HSI_VALUE;
24014320:	4b05      	ldr	r3, [pc, #20]	; (24014338 <HAL_RCCEx_GetPeriphCLKFreq+0x29c>)
24014322:	63fb      	str	r3, [r7, #60]	; 0x3c
          {
            /* In Case the CKPER is disabled*/
            frequency = 0;
          }

          break;
24014324:	e122      	b.n	2401456c <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
          else if(ckpclocksource== RCC_CLKPSOURCE_CSI)
24014326:	6b7b      	ldr	r3, [r7, #52]	; 0x34
24014328:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
2401432c:	d10c      	bne.n	24014348 <HAL_RCCEx_GetPeriphCLKFreq+0x2ac>
            frequency = CSI_VALUE;
2401432e:	4b03      	ldr	r3, [pc, #12]	; (2401433c <HAL_RCCEx_GetPeriphCLKFreq+0x2a0>)
24014330:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
24014332:	e11b      	b.n	2401456c <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
24014334:	58024400 	.word	0x58024400
24014338:	03d09000 	.word	0x03d09000
2401433c:	003d0900 	.word	0x003d0900
24014340:	017d7840 	.word	0x017d7840
24014344:	00bb8000 	.word	0x00bb8000
          else if (ckpclocksource== RCC_CLKPSOURCE_HSE)
24014348:	6b7b      	ldr	r3, [r7, #52]	; 0x34
2401434a:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
2401434e:	d102      	bne.n	24014356 <HAL_RCCEx_GetPeriphCLKFreq+0x2ba>
            frequency = HSE_VALUE;
24014350:	4b89      	ldr	r3, [pc, #548]	; (24014578 <HAL_RCCEx_GetPeriphCLKFreq+0x4dc>)
24014352:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
24014354:	e10a      	b.n	2401456c <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
            frequency = 0;
24014356:	2300      	movs	r3, #0
24014358:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
2401435a:	e107      	b.n	2401456c <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }

      case (RCC_D3CCIPR_SAI4BSEL_0 | RCC_D3CCIPR_SAI4BSEL_1 ): /* External clock is the clock source for SAI4B */
        {
          frequency = EXTERNAL_CLOCK_VALUE;
2401435c:	4b87      	ldr	r3, [pc, #540]	; (2401457c <HAL_RCCEx_GetPeriphCLKFreq+0x4e0>)
2401435e:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
24014360:	e104      	b.n	2401456c <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }

      default :
        {
          frequency = 0;
24014362:	2300      	movs	r3, #0
24014364:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
24014366:	bf00      	nop
24014368:	e100      	b.n	2401456c <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }
      }
    }
#endif /*SAI4*/
  else if (PeriphClk == RCC_PERIPHCLK_SPI123)
2401436a:	687b      	ldr	r3, [r7, #4]
2401436c:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
24014370:	d153      	bne.n	2401441a <HAL_RCCEx_GetPeriphCLKFreq+0x37e>
    {
      /* Get SPI1/2/3 clock source */
      srcclk= __HAL_RCC_GET_SPI123_SOURCE();
24014372:	4b83      	ldr	r3, [pc, #524]	; (24014580 <HAL_RCCEx_GetPeriphCLKFreq+0x4e4>)
24014374:	6d1b      	ldr	r3, [r3, #80]	; 0x50
24014376:	f403 43e0 	and.w	r3, r3, #28672	; 0x7000
2401437a:	63bb      	str	r3, [r7, #56]	; 0x38

      switch (srcclk)
2401437c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
2401437e:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
24014382:	d01f      	beq.n	240143c4 <HAL_RCCEx_GetPeriphCLKFreq+0x328>
24014384:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
24014388:	d805      	bhi.n	24014396 <HAL_RCCEx_GetPeriphCLKFreq+0x2fa>
2401438a:	2b00      	cmp	r3, #0
2401438c:	d00a      	beq.n	240143a4 <HAL_RCCEx_GetPeriphCLKFreq+0x308>
2401438e:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
24014392:	d00f      	beq.n	240143b4 <HAL_RCCEx_GetPeriphCLKFreq+0x318>
24014394:	e03d      	b.n	24014412 <HAL_RCCEx_GetPeriphCLKFreq+0x376>
24014396:	f5b3 5f40 	cmp.w	r3, #12288	; 0x3000
2401439a:	d037      	beq.n	2401440c <HAL_RCCEx_GetPeriphCLKFreq+0x370>
2401439c:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
240143a0:	d018      	beq.n	240143d4 <HAL_RCCEx_GetPeriphCLKFreq+0x338>
240143a2:	e036      	b.n	24014412 <HAL_RCCEx_GetPeriphCLKFreq+0x376>
      {
      case RCC_SPI123CLKSOURCE_PLL: /* PLL1 is the clock source for I2S */
        {
          HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
240143a4:	f107 0324 	add.w	r3, r7, #36	; 0x24
240143a8:	4618      	mov	r0, r3
240143aa:	f000 fbb3 	bl	24014b14 <HAL_RCCEx_GetPLL1ClockFreq>
          frequency = pll1_clocks.PLL1_Q_Frequency;
240143ae:	6abb      	ldr	r3, [r7, #40]	; 0x28
240143b0:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
240143b2:	e0db      	b.n	2401456c <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }
      case RCC_SPI123CLKSOURCE_PLL2: /* PLL2 is the clock source for I2S */
        {
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
240143b4:	f107 0318 	add.w	r3, r7, #24
240143b8:	4618      	mov	r0, r3
240143ba:	f000 f913 	bl	240145e4 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_P_Frequency;
240143be:	69bb      	ldr	r3, [r7, #24]
240143c0:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
240143c2:	e0d3      	b.n	2401456c <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }

      case RCC_SPI123CLKSOURCE_PLL3: /* PLL3 is the clock source for I2S */
        {
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
240143c4:	f107 030c 	add.w	r3, r7, #12
240143c8:	4618      	mov	r0, r3
240143ca:	f000 fa57 	bl	2401487c <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_P_Frequency;
240143ce:	68fb      	ldr	r3, [r7, #12]
240143d0:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
240143d2:	e0cb      	b.n	2401456c <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }

      case RCC_SPI123CLKSOURCE_CLKP: /* CKPER is the clock source for I2S */
        {

          ckpclocksource= __HAL_RCC_GET_CLKP_SOURCE();
240143d4:	4b6a      	ldr	r3, [pc, #424]	; (24014580 <HAL_RCCEx_GetPeriphCLKFreq+0x4e4>)
240143d6:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
240143d8:	f003 5340 	and.w	r3, r3, #805306368	; 0x30000000
240143dc:	637b      	str	r3, [r7, #52]	; 0x34

          if(ckpclocksource== RCC_CLKPSOURCE_HSI)
240143de:	6b7b      	ldr	r3, [r7, #52]	; 0x34
240143e0:	2b00      	cmp	r3, #0
240143e2:	d102      	bne.n	240143ea <HAL_RCCEx_GetPeriphCLKFreq+0x34e>
          {
            /* In Case the CKPER Source is HSI */
            frequency = HSI_VALUE;
240143e4:	4b67      	ldr	r3, [pc, #412]	; (24014584 <HAL_RCCEx_GetPeriphCLKFreq+0x4e8>)
240143e6:	63fb      	str	r3, [r7, #60]	; 0x3c
          {
            /* In Case the CKPER is disabled*/
            frequency = 0;
          }

          break;
240143e8:	e0c0      	b.n	2401456c <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
          else if(ckpclocksource== RCC_CLKPSOURCE_CSI)
240143ea:	6b7b      	ldr	r3, [r7, #52]	; 0x34
240143ec:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
240143f0:	d102      	bne.n	240143f8 <HAL_RCCEx_GetPeriphCLKFreq+0x35c>
            frequency = CSI_VALUE;
240143f2:	4b65      	ldr	r3, [pc, #404]	; (24014588 <HAL_RCCEx_GetPeriphCLKFreq+0x4ec>)
240143f4:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
240143f6:	e0b9      	b.n	2401456c <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
          else if (ckpclocksource== RCC_CLKPSOURCE_HSE)
240143f8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
240143fa:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
240143fe:	d102      	bne.n	24014406 <HAL_RCCEx_GetPeriphCLKFreq+0x36a>
            frequency = HSE_VALUE;
24014400:	4b5d      	ldr	r3, [pc, #372]	; (24014578 <HAL_RCCEx_GetPeriphCLKFreq+0x4dc>)
24014402:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
24014404:	e0b2      	b.n	2401456c <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
            frequency = 0;
24014406:	2300      	movs	r3, #0
24014408:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
2401440a:	e0af      	b.n	2401456c <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }

      case (RCC_SPI123CLKSOURCE_PIN): /* External clock is the clock source for I2S */
        {
          frequency = EXTERNAL_CLOCK_VALUE;
2401440c:	4b5b      	ldr	r3, [pc, #364]	; (2401457c <HAL_RCCEx_GetPeriphCLKFreq+0x4e0>)
2401440e:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
24014410:	e0ac      	b.n	2401456c <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }
      default :
        {
          frequency = 0;
24014412:	2300      	movs	r3, #0
24014414:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
24014416:	bf00      	nop
24014418:	e0a8      	b.n	2401456c <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }
      }
    }
  else if (PeriphClk == RCC_PERIPHCLK_ADC)
2401441a:	687b      	ldr	r3, [r7, #4]
2401441c:	f5b3 2f00 	cmp.w	r3, #524288	; 0x80000
24014420:	d13d      	bne.n	2401449e <HAL_RCCEx_GetPeriphCLKFreq+0x402>
    {
      /* Get ADC clock source */
      srcclk= __HAL_RCC_GET_ADC_SOURCE();
24014422:	4b57      	ldr	r3, [pc, #348]	; (24014580 <HAL_RCCEx_GetPeriphCLKFreq+0x4e4>)
24014424:	6d9b      	ldr	r3, [r3, #88]	; 0x58
24014426:	f403 3340 	and.w	r3, r3, #196608	; 0x30000
2401442a:	63bb      	str	r3, [r7, #56]	; 0x38

      switch (srcclk)
2401442c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
2401442e:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
24014432:	d00c      	beq.n	2401444e <HAL_RCCEx_GetPeriphCLKFreq+0x3b2>
24014434:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
24014438:	d011      	beq.n	2401445e <HAL_RCCEx_GetPeriphCLKFreq+0x3c2>
2401443a:	2b00      	cmp	r3, #0
2401443c:	d12b      	bne.n	24014496 <HAL_RCCEx_GetPeriphCLKFreq+0x3fa>
      {
      case RCC_ADCCLKSOURCE_PLL2:
        {
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
2401443e:	f107 0318 	add.w	r3, r7, #24
24014442:	4618      	mov	r0, r3
24014444:	f000 f8ce 	bl	240145e4 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_P_Frequency;
24014448:	69bb      	ldr	r3, [r7, #24]
2401444a:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
2401444c:	e08e      	b.n	2401456c <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }
      case RCC_ADCCLKSOURCE_PLL3:
        {
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
2401444e:	f107 030c 	add.w	r3, r7, #12
24014452:	4618      	mov	r0, r3
24014454:	f000 fa12 	bl	2401487c <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_R_Frequency;
24014458:	697b      	ldr	r3, [r7, #20]
2401445a:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
2401445c:	e086      	b.n	2401456c <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }

      case RCC_ADCCLKSOURCE_CLKP:
        {

          ckpclocksource= __HAL_RCC_GET_CLKP_SOURCE();
2401445e:	4b48      	ldr	r3, [pc, #288]	; (24014580 <HAL_RCCEx_GetPeriphCLKFreq+0x4e4>)
24014460:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
24014462:	f003 5340 	and.w	r3, r3, #805306368	; 0x30000000
24014466:	637b      	str	r3, [r7, #52]	; 0x34

          if(ckpclocksource== RCC_CLKPSOURCE_HSI)
24014468:	6b7b      	ldr	r3, [r7, #52]	; 0x34
2401446a:	2b00      	cmp	r3, #0
2401446c:	d102      	bne.n	24014474 <HAL_RCCEx_GetPeriphCLKFreq+0x3d8>
          {
            /* In Case the CKPER Source is HSI */
            frequency = HSI_VALUE;
2401446e:	4b45      	ldr	r3, [pc, #276]	; (24014584 <HAL_RCCEx_GetPeriphCLKFreq+0x4e8>)
24014470:	63fb      	str	r3, [r7, #60]	; 0x3c
          {
            /* In Case the CKPER is disabled*/
            frequency = 0;
          }

          break;
24014472:	e07b      	b.n	2401456c <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
          else if(ckpclocksource== RCC_CLKPSOURCE_CSI)
24014474:	6b7b      	ldr	r3, [r7, #52]	; 0x34
24014476:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
2401447a:	d102      	bne.n	24014482 <HAL_RCCEx_GetPeriphCLKFreq+0x3e6>
            frequency = CSI_VALUE;
2401447c:	4b42      	ldr	r3, [pc, #264]	; (24014588 <HAL_RCCEx_GetPeriphCLKFreq+0x4ec>)
2401447e:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
24014480:	e074      	b.n	2401456c <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
          else if (ckpclocksource== RCC_CLKPSOURCE_HSE)
24014482:	6b7b      	ldr	r3, [r7, #52]	; 0x34
24014484:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
24014488:	d102      	bne.n	24014490 <HAL_RCCEx_GetPeriphCLKFreq+0x3f4>
            frequency = HSE_VALUE;
2401448a:	4b3b      	ldr	r3, [pc, #236]	; (24014578 <HAL_RCCEx_GetPeriphCLKFreq+0x4dc>)
2401448c:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
2401448e:	e06d      	b.n	2401456c <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
            frequency = 0;
24014490:	2300      	movs	r3, #0
24014492:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
24014494:	e06a      	b.n	2401456c <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }

      default :
        {
          frequency = 0;
24014496:	2300      	movs	r3, #0
24014498:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
2401449a:	bf00      	nop
2401449c:	e066      	b.n	2401456c <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }
      }
    }
  else if (PeriphClk == RCC_PERIPHCLK_SDMMC)
2401449e:	687b      	ldr	r3, [r7, #4]
240144a0:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
240144a4:	d11f      	bne.n	240144e6 <HAL_RCCEx_GetPeriphCLKFreq+0x44a>
    {
      /* Get SDMMC clock source */
      srcclk= __HAL_RCC_GET_SDMMC_SOURCE();
240144a6:	4b36      	ldr	r3, [pc, #216]	; (24014580 <HAL_RCCEx_GetPeriphCLKFreq+0x4e4>)
240144a8:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
240144aa:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
240144ae:	63bb      	str	r3, [r7, #56]	; 0x38

      switch (srcclk)
240144b0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
240144b2:	2b00      	cmp	r3, #0
240144b4:	d003      	beq.n	240144be <HAL_RCCEx_GetPeriphCLKFreq+0x422>
240144b6:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
240144ba:	d008      	beq.n	240144ce <HAL_RCCEx_GetPeriphCLKFreq+0x432>
240144bc:	e00f      	b.n	240144de <HAL_RCCEx_GetPeriphCLKFreq+0x442>
      {
      case RCC_SDMMCCLKSOURCE_PLL: /* PLL1 is the clock source for SDMMC */
        {
          HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
240144be:	f107 0324 	add.w	r3, r7, #36	; 0x24
240144c2:	4618      	mov	r0, r3
240144c4:	f000 fb26 	bl	24014b14 <HAL_RCCEx_GetPLL1ClockFreq>
          frequency = pll1_clocks.PLL1_Q_Frequency;
240144c8:	6abb      	ldr	r3, [r7, #40]	; 0x28
240144ca:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
240144cc:	e04e      	b.n	2401456c <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }
      case RCC_SDMMCCLKSOURCE_PLL2: /* PLL2 is the clock source for SDMMC */
        {
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
240144ce:	f107 0318 	add.w	r3, r7, #24
240144d2:	4618      	mov	r0, r3
240144d4:	f000 f886 	bl	240145e4 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_R_Frequency;
240144d8:	6a3b      	ldr	r3, [r7, #32]
240144da:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
240144dc:	e046      	b.n	2401456c <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }

      default :
        {
          frequency = 0;
240144de:	2300      	movs	r3, #0
240144e0:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
240144e2:	bf00      	nop
240144e4:	e042      	b.n	2401456c <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }
      }
    }
  else if (PeriphClk == RCC_PERIPHCLK_SPI6)
240144e6:	687b      	ldr	r3, [r7, #4]
240144e8:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
240144ec:	d13c      	bne.n	24014568 <HAL_RCCEx_GetPeriphCLKFreq+0x4cc>
    {
      /* Get SPI6 clock source */
      srcclk= __HAL_RCC_GET_SPI6_SOURCE();
240144ee:	4b24      	ldr	r3, [pc, #144]	; (24014580 <HAL_RCCEx_GetPeriphCLKFreq+0x4e4>)
240144f0:	6d9b      	ldr	r3, [r3, #88]	; 0x58
240144f2:	f003 43e0 	and.w	r3, r3, #1879048192	; 0x70000000
240144f6:	63bb      	str	r3, [r7, #56]	; 0x38

      switch (srcclk)
240144f8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
240144fa:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
240144fe:	d01e      	beq.n	2401453e <HAL_RCCEx_GetPeriphCLKFreq+0x4a2>
24014500:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
24014504:	d805      	bhi.n	24014512 <HAL_RCCEx_GetPeriphCLKFreq+0x476>
24014506:	2b00      	cmp	r3, #0
24014508:	d00d      	beq.n	24014526 <HAL_RCCEx_GetPeriphCLKFreq+0x48a>
2401450a:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
2401450e:	d00e      	beq.n	2401452e <HAL_RCCEx_GetPeriphCLKFreq+0x492>
24014510:	e026      	b.n	24014560 <HAL_RCCEx_GetPeriphCLKFreq+0x4c4>
24014512:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
24014516:	d01d      	beq.n	24014554 <HAL_RCCEx_GetPeriphCLKFreq+0x4b8>
24014518:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
2401451c:	d01d      	beq.n	2401455a <HAL_RCCEx_GetPeriphCLKFreq+0x4be>
2401451e:	f1b3 5f40 	cmp.w	r3, #805306368	; 0x30000000
24014522:	d014      	beq.n	2401454e <HAL_RCCEx_GetPeriphCLKFreq+0x4b2>
24014524:	e01c      	b.n	24014560 <HAL_RCCEx_GetPeriphCLKFreq+0x4c4>
      {
      case RCC_SPI6CLKSOURCE_D3PCLK1: /* D3PCLK1 (PCLK4) is the clock source for SPI6 */
        {
          frequency = HAL_RCCEx_GetD3PCLK1Freq();
24014526:	f000 f847 	bl	240145b8 <HAL_RCCEx_GetD3PCLK1Freq>
2401452a:	63f8      	str	r0, [r7, #60]	; 0x3c
          break;
2401452c:	e01e      	b.n	2401456c <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }
      case RCC_SPI6CLKSOURCE_PLL2: /* PLL2 is the clock source for SPI6 */
        {
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
2401452e:	f107 0318 	add.w	r3, r7, #24
24014532:	4618      	mov	r0, r3
24014534:	f000 f856 	bl	240145e4 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_Q_Frequency;
24014538:	69fb      	ldr	r3, [r7, #28]
2401453a:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
2401453c:	e016      	b.n	2401456c <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }
      case RCC_SPI6CLKSOURCE_PLL3: /* PLL3 is the clock source for SPI6 */
        {
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
2401453e:	f107 030c 	add.w	r3, r7, #12
24014542:	4618      	mov	r0, r3
24014544:	f000 f99a 	bl	2401487c <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_Q_Frequency;
24014548:	693b      	ldr	r3, [r7, #16]
2401454a:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
2401454c:	e00e      	b.n	2401456c <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }
      case RCC_SPI6CLKSOURCE_HSI: /* HSI is the clock source for SPI6 */
        {
          frequency = HSI_VALUE;
2401454e:	4b0d      	ldr	r3, [pc, #52]	; (24014584 <HAL_RCCEx_GetPeriphCLKFreq+0x4e8>)
24014550:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
24014552:	e00b      	b.n	2401456c <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }
      case RCC_SPI6CLKSOURCE_CSI: /* CSI is the clock source for SPI6 */
        {
          frequency = CSI_VALUE;
24014554:	4b0c      	ldr	r3, [pc, #48]	; (24014588 <HAL_RCCEx_GetPeriphCLKFreq+0x4ec>)
24014556:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
24014558:	e008      	b.n	2401456c <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }
      case RCC_SPI6CLKSOURCE_HSE: /* HSE is the clock source for SPI6 */
        {
          frequency = HSE_VALUE;
2401455a:	4b07      	ldr	r3, [pc, #28]	; (24014578 <HAL_RCCEx_GetPeriphCLKFreq+0x4dc>)
2401455c:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
2401455e:	e005      	b.n	2401456c <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
          break;
        }
#endif /* RCC_SPI6CLKSOURCE_PIN */
      default :
        {
          frequency = 0;
24014560:	2300      	movs	r3, #0
24014562:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
24014564:	bf00      	nop
24014566:	e001      	b.n	2401456c <HAL_RCCEx_GetPeriphCLKFreq+0x4d0>
        }
      }
    }
  else
    {
      frequency = 0;
24014568:	2300      	movs	r3, #0
2401456a:	63fb      	str	r3, [r7, #60]	; 0x3c
    }

  return frequency;
2401456c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
}
2401456e:	4618      	mov	r0, r3
24014570:	3740      	adds	r7, #64	; 0x40
24014572:	46bd      	mov	sp, r7
24014574:	bd80      	pop	{r7, pc}
24014576:	bf00      	nop
24014578:	017d7840 	.word	0x017d7840
2401457c:	00bb8000 	.word	0x00bb8000
24014580:	58024400 	.word	0x58024400
24014584:	03d09000 	.word	0x03d09000
24014588:	003d0900 	.word	0x003d0900

2401458c <HAL_RCCEx_GetD1PCLK1Freq>:
  * @note   Each time D1PCLK1 changes, this function must be called to update the
  *         right D1PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval D1PCLK1 frequency
  */
uint32_t HAL_RCCEx_GetD1PCLK1Freq(void)
{
2401458c:	b580      	push	{r7, lr}
2401458e:	af00      	add	r7, sp, #0
#if defined(RCC_D1CFGR_D1PPRE)
  /* Get HCLK source and Compute D1PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> (D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1PPRE)>> RCC_D1CFGR_D1PPRE_Pos] & 0x1FU));
24014590:	f7fe fb9a 	bl	24012cc8 <HAL_RCC_GetHCLKFreq>
24014594:	4601      	mov	r1, r0
24014596:	4b06      	ldr	r3, [pc, #24]	; (240145b0 <HAL_RCCEx_GetD1PCLK1Freq+0x24>)
24014598:	699b      	ldr	r3, [r3, #24]
2401459a:	091b      	lsrs	r3, r3, #4
2401459c:	f003 0307 	and.w	r3, r3, #7
240145a0:	4a04      	ldr	r2, [pc, #16]	; (240145b4 <HAL_RCCEx_GetD1PCLK1Freq+0x28>)
240145a2:	5cd3      	ldrb	r3, [r2, r3]
240145a4:	f003 031f 	and.w	r3, r3, #31
240145a8:	fa21 f303 	lsr.w	r3, r1, r3
#else
/* Get HCLK source and Compute D1PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> (D1CorePrescTable[(RCC->CDCFGR1 & RCC_CDCFGR1_CDPPRE)>> RCC_CDCFGR1_CDPPRE_Pos] & 0x1FU));
#endif
}
240145ac:	4618      	mov	r0, r3
240145ae:	bd80      	pop	{r7, pc}
240145b0:	58024400 	.word	0x58024400
240145b4:	24016db8 	.word	0x24016db8

240145b8 <HAL_RCCEx_GetD3PCLK1Freq>:
  * @note   Each time D3PCLK1 changes, this function must be called to update the
  *         right D3PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval D3PCLK1 frequency
  */
uint32_t HAL_RCCEx_GetD3PCLK1Freq(void)
{
240145b8:	b580      	push	{r7, lr}
240145ba:	af00      	add	r7, sp, #0
#if defined(RCC_D3CFGR_D3PPRE)
  /* Get HCLK source and Compute D3PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> (D1CorePrescTable[(RCC->D3CFGR & RCC_D3CFGR_D3PPRE)>> RCC_D3CFGR_D3PPRE_Pos] & 0x1FU));
240145bc:	f7fe fb84 	bl	24012cc8 <HAL_RCC_GetHCLKFreq>
240145c0:	4601      	mov	r1, r0
240145c2:	4b06      	ldr	r3, [pc, #24]	; (240145dc <HAL_RCCEx_GetD3PCLK1Freq+0x24>)
240145c4:	6a1b      	ldr	r3, [r3, #32]
240145c6:	091b      	lsrs	r3, r3, #4
240145c8:	f003 0307 	and.w	r3, r3, #7
240145cc:	4a04      	ldr	r2, [pc, #16]	; (240145e0 <HAL_RCCEx_GetD3PCLK1Freq+0x28>)
240145ce:	5cd3      	ldrb	r3, [r2, r3]
240145d0:	f003 031f 	and.w	r3, r3, #31
240145d4:	fa21 f303 	lsr.w	r3, r1, r3
#else
  /* Get HCLK source and Compute D3PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> (D1CorePrescTable[(RCC->SRDCFGR & RCC_SRDCFGR_SRDPPRE)>> RCC_SRDCFGR_SRDPPRE_Pos] & 0x1FU));
#endif
}
240145d8:	4618      	mov	r0, r3
240145da:	bd80      	pop	{r7, pc}
240145dc:	58024400 	.word	0x58024400
240145e0:	24016db8 	.word	0x24016db8

240145e4 <HAL_RCCEx_GetPLL2ClockFreq>:
  *         right PLL2CLK value. Otherwise, any configuration based on this function will be incorrect.
  * @param  PLL2_Clocks structure.
  * @retval None
  */
void HAL_RCCEx_GetPLL2ClockFreq(PLL2_ClocksTypeDef* PLL2_Clocks)
{
240145e4:	b480      	push	{r7}
240145e6:	b089      	sub	sp, #36	; 0x24
240145e8:	af00      	add	r7, sp, #0
240145ea:	6078      	str	r0, [r7, #4]
  float_t fracn2, pll2vco;

  /* PLL_VCO = (HSE_VALUE or HSI_VALUE or CSI_VALUE/ PLL2M) * PLL2N
     PLL2xCLK = PLL2_VCO / PLL2x
  */
  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
240145ec:	4b9d      	ldr	r3, [pc, #628]	; (24014864 <HAL_RCCEx_GetPLL2ClockFreq+0x280>)
240145ee:	6a9b      	ldr	r3, [r3, #40]	; 0x28
240145f0:	f003 0303 	and.w	r3, r3, #3
240145f4:	61bb      	str	r3, [r7, #24]
  pll2m = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM2)>> 12);
240145f6:	4b9b      	ldr	r3, [pc, #620]	; (24014864 <HAL_RCCEx_GetPLL2ClockFreq+0x280>)
240145f8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
240145fa:	0b1b      	lsrs	r3, r3, #12
240145fc:	f003 033f 	and.w	r3, r3, #63	; 0x3f
24014600:	617b      	str	r3, [r7, #20]
  pll2fracen = (RCC->PLLCFGR & RCC_PLLCFGR_PLL2FRACEN) >> RCC_PLLCFGR_PLL2FRACEN_Pos;
24014602:	4b98      	ldr	r3, [pc, #608]	; (24014864 <HAL_RCCEx_GetPLL2ClockFreq+0x280>)
24014604:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24014606:	091b      	lsrs	r3, r3, #4
24014608:	f003 0301 	and.w	r3, r3, #1
2401460c:	613b      	str	r3, [r7, #16]
  fracn2 =(float_t)(uint32_t)(pll2fracen* ((RCC->PLL2FRACR & RCC_PLL2FRACR_FRACN2)>> 3));
2401460e:	4b95      	ldr	r3, [pc, #596]	; (24014864 <HAL_RCCEx_GetPLL2ClockFreq+0x280>)
24014610:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24014612:	08db      	lsrs	r3, r3, #3
24014614:	f3c3 030c 	ubfx	r3, r3, #0, #13
24014618:	693a      	ldr	r2, [r7, #16]
2401461a:	fb02 f303 	mul.w	r3, r2, r3
2401461e:	ee07 3a90 	vmov	s15, r3
24014622:	eef8 7a67 	vcvt.f32.u32	s15, s15
24014626:	edc7 7a03 	vstr	s15, [r7, #12]

  if (pll2m != 0U)
2401462a:	697b      	ldr	r3, [r7, #20]
2401462c:	2b00      	cmp	r3, #0
2401462e:	f000 810a 	beq.w	24014846 <HAL_RCCEx_GetPLL2ClockFreq+0x262>
  {
    switch (pllsource)
24014632:	69bb      	ldr	r3, [r7, #24]
24014634:	2b01      	cmp	r3, #1
24014636:	d05a      	beq.n	240146ee <HAL_RCCEx_GetPLL2ClockFreq+0x10a>
24014638:	2b01      	cmp	r3, #1
2401463a:	d302      	bcc.n	24014642 <HAL_RCCEx_GetPLL2ClockFreq+0x5e>
2401463c:	2b02      	cmp	r3, #2
2401463e:	d078      	beq.n	24014732 <HAL_RCCEx_GetPLL2ClockFreq+0x14e>
24014640:	e099      	b.n	24014776 <HAL_RCCEx_GetPLL2ClockFreq+0x192>
    {

    case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */

      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
24014642:	4b88      	ldr	r3, [pc, #544]	; (24014864 <HAL_RCCEx_GetPLL2ClockFreq+0x280>)
24014644:	681b      	ldr	r3, [r3, #0]
24014646:	f003 0320 	and.w	r3, r3, #32
2401464a:	2b00      	cmp	r3, #0
2401464c:	d02d      	beq.n	240146aa <HAL_RCCEx_GetPLL2ClockFreq+0xc6>
      {
        hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
2401464e:	4b85      	ldr	r3, [pc, #532]	; (24014864 <HAL_RCCEx_GetPLL2ClockFreq+0x280>)
24014650:	681b      	ldr	r3, [r3, #0]
24014652:	08db      	lsrs	r3, r3, #3
24014654:	f003 0303 	and.w	r3, r3, #3
24014658:	4a83      	ldr	r2, [pc, #524]	; (24014868 <HAL_RCCEx_GetPLL2ClockFreq+0x284>)
2401465a:	fa22 f303 	lsr.w	r3, r2, r3
2401465e:	60bb      	str	r3, [r7, #8]
        pll2vco = ( (float_t)hsivalue / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2/(float_t)0x2000) +(float_t)1 );
24014660:	68bb      	ldr	r3, [r7, #8]
24014662:	ee07 3a90 	vmov	s15, r3
24014666:	eef8 6a67 	vcvt.f32.u32	s13, s15
2401466a:	697b      	ldr	r3, [r7, #20]
2401466c:	ee07 3a90 	vmov	s15, r3
24014670:	eef8 7a67 	vcvt.f32.u32	s15, s15
24014674:	ee86 7aa7 	vdiv.f32	s14, s13, s15
24014678:	4b7a      	ldr	r3, [pc, #488]	; (24014864 <HAL_RCCEx_GetPLL2ClockFreq+0x280>)
2401467a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2401467c:	f3c3 0308 	ubfx	r3, r3, #0, #9
24014680:	ee07 3a90 	vmov	s15, r3
24014684:	eef8 6a67 	vcvt.f32.u32	s13, s15
24014688:	ed97 6a03 	vldr	s12, [r7, #12]
2401468c:	eddf 5a77 	vldr	s11, [pc, #476]	; 2401486c <HAL_RCCEx_GetPLL2ClockFreq+0x288>
24014690:	eec6 7a25 	vdiv.f32	s15, s12, s11
24014694:	ee76 7aa7 	vadd.f32	s15, s13, s15
24014698:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
2401469c:	ee77 7aa6 	vadd.f32	s15, s15, s13
240146a0:	ee67 7a27 	vmul.f32	s15, s14, s15
240146a4:	edc7 7a07 	vstr	s15, [r7, #28]
      }
      else
      {
        pll2vco = ((float_t)HSI_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2/(float_t)0x2000) +(float_t)1 );
      }
      break;
240146a8:	e087      	b.n	240147ba <HAL_RCCEx_GetPLL2ClockFreq+0x1d6>
        pll2vco = ((float_t)HSI_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2/(float_t)0x2000) +(float_t)1 );
240146aa:	697b      	ldr	r3, [r7, #20]
240146ac:	ee07 3a90 	vmov	s15, r3
240146b0:	eef8 7a67 	vcvt.f32.u32	s15, s15
240146b4:	eddf 6a6e 	vldr	s13, [pc, #440]	; 24014870 <HAL_RCCEx_GetPLL2ClockFreq+0x28c>
240146b8:	ee86 7aa7 	vdiv.f32	s14, s13, s15
240146bc:	4b69      	ldr	r3, [pc, #420]	; (24014864 <HAL_RCCEx_GetPLL2ClockFreq+0x280>)
240146be:	6b9b      	ldr	r3, [r3, #56]	; 0x38
240146c0:	f3c3 0308 	ubfx	r3, r3, #0, #9
240146c4:	ee07 3a90 	vmov	s15, r3
240146c8:	eef8 6a67 	vcvt.f32.u32	s13, s15
240146cc:	ed97 6a03 	vldr	s12, [r7, #12]
240146d0:	eddf 5a66 	vldr	s11, [pc, #408]	; 2401486c <HAL_RCCEx_GetPLL2ClockFreq+0x288>
240146d4:	eec6 7a25 	vdiv.f32	s15, s12, s11
240146d8:	ee76 7aa7 	vadd.f32	s15, s13, s15
240146dc:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
240146e0:	ee77 7aa6 	vadd.f32	s15, s15, s13
240146e4:	ee67 7a27 	vmul.f32	s15, s14, s15
240146e8:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
240146ec:	e065      	b.n	240147ba <HAL_RCCEx_GetPLL2ClockFreq+0x1d6>

    case RCC_PLLSOURCE_CSI:  /* CSI used as PLL clock source */
      pll2vco = ((float_t)CSI_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2/(float_t)0x2000) +(float_t)1 );
240146ee:	697b      	ldr	r3, [r7, #20]
240146f0:	ee07 3a90 	vmov	s15, r3
240146f4:	eef8 7a67 	vcvt.f32.u32	s15, s15
240146f8:	eddf 6a5e 	vldr	s13, [pc, #376]	; 24014874 <HAL_RCCEx_GetPLL2ClockFreq+0x290>
240146fc:	ee86 7aa7 	vdiv.f32	s14, s13, s15
24014700:	4b58      	ldr	r3, [pc, #352]	; (24014864 <HAL_RCCEx_GetPLL2ClockFreq+0x280>)
24014702:	6b9b      	ldr	r3, [r3, #56]	; 0x38
24014704:	f3c3 0308 	ubfx	r3, r3, #0, #9
24014708:	ee07 3a90 	vmov	s15, r3
2401470c:	eef8 6a67 	vcvt.f32.u32	s13, s15
24014710:	ed97 6a03 	vldr	s12, [r7, #12]
24014714:	eddf 5a55 	vldr	s11, [pc, #340]	; 2401486c <HAL_RCCEx_GetPLL2ClockFreq+0x288>
24014718:	eec6 7a25 	vdiv.f32	s15, s12, s11
2401471c:	ee76 7aa7 	vadd.f32	s15, s13, s15
24014720:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
24014724:	ee77 7aa6 	vadd.f32	s15, s15, s13
24014728:	ee67 7a27 	vmul.f32	s15, s14, s15
2401472c:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
24014730:	e043      	b.n	240147ba <HAL_RCCEx_GetPLL2ClockFreq+0x1d6>

    case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
      pll2vco = ((float_t)HSE_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2/(float_t)0x2000) +(float_t)1 );
24014732:	697b      	ldr	r3, [r7, #20]
24014734:	ee07 3a90 	vmov	s15, r3
24014738:	eef8 7a67 	vcvt.f32.u32	s15, s15
2401473c:	eddf 6a4e 	vldr	s13, [pc, #312]	; 24014878 <HAL_RCCEx_GetPLL2ClockFreq+0x294>
24014740:	ee86 7aa7 	vdiv.f32	s14, s13, s15
24014744:	4b47      	ldr	r3, [pc, #284]	; (24014864 <HAL_RCCEx_GetPLL2ClockFreq+0x280>)
24014746:	6b9b      	ldr	r3, [r3, #56]	; 0x38
24014748:	f3c3 0308 	ubfx	r3, r3, #0, #9
2401474c:	ee07 3a90 	vmov	s15, r3
24014750:	eef8 6a67 	vcvt.f32.u32	s13, s15
24014754:	ed97 6a03 	vldr	s12, [r7, #12]
24014758:	eddf 5a44 	vldr	s11, [pc, #272]	; 2401486c <HAL_RCCEx_GetPLL2ClockFreq+0x288>
2401475c:	eec6 7a25 	vdiv.f32	s15, s12, s11
24014760:	ee76 7aa7 	vadd.f32	s15, s13, s15
24014764:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
24014768:	ee77 7aa6 	vadd.f32	s15, s15, s13
2401476c:	ee67 7a27 	vmul.f32	s15, s14, s15
24014770:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
24014774:	e021      	b.n	240147ba <HAL_RCCEx_GetPLL2ClockFreq+0x1d6>

    default:
      pll2vco = ((float_t)CSI_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2/(float_t)0x2000) +(float_t)1 );
24014776:	697b      	ldr	r3, [r7, #20]
24014778:	ee07 3a90 	vmov	s15, r3
2401477c:	eef8 7a67 	vcvt.f32.u32	s15, s15
24014780:	eddf 6a3c 	vldr	s13, [pc, #240]	; 24014874 <HAL_RCCEx_GetPLL2ClockFreq+0x290>
24014784:	ee86 7aa7 	vdiv.f32	s14, s13, s15
24014788:	4b36      	ldr	r3, [pc, #216]	; (24014864 <HAL_RCCEx_GetPLL2ClockFreq+0x280>)
2401478a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2401478c:	f3c3 0308 	ubfx	r3, r3, #0, #9
24014790:	ee07 3a90 	vmov	s15, r3
24014794:	eef8 6a67 	vcvt.f32.u32	s13, s15
24014798:	ed97 6a03 	vldr	s12, [r7, #12]
2401479c:	eddf 5a33 	vldr	s11, [pc, #204]	; 2401486c <HAL_RCCEx_GetPLL2ClockFreq+0x288>
240147a0:	eec6 7a25 	vdiv.f32	s15, s12, s11
240147a4:	ee76 7aa7 	vadd.f32	s15, s13, s15
240147a8:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
240147ac:	ee77 7aa6 	vadd.f32	s15, s15, s13
240147b0:	ee67 7a27 	vmul.f32	s15, s14, s15
240147b4:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
240147b8:	bf00      	nop
    }
    PLL2_Clocks->PLL2_P_Frequency = (uint32_t)(float_t)(pll2vco/((float_t)(uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_P2) >>9)  + (float_t)1 )) ;
240147ba:	4b2a      	ldr	r3, [pc, #168]	; (24014864 <HAL_RCCEx_GetPLL2ClockFreq+0x280>)
240147bc:	6b9b      	ldr	r3, [r3, #56]	; 0x38
240147be:	0a5b      	lsrs	r3, r3, #9
240147c0:	f003 037f 	and.w	r3, r3, #127	; 0x7f
240147c4:	ee07 3a90 	vmov	s15, r3
240147c8:	eef8 7a67 	vcvt.f32.u32	s15, s15
240147cc:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
240147d0:	ee37 7a87 	vadd.f32	s14, s15, s14
240147d4:	edd7 6a07 	vldr	s13, [r7, #28]
240147d8:	eec6 7a87 	vdiv.f32	s15, s13, s14
240147dc:	eefc 7ae7 	vcvt.u32.f32	s15, s15
240147e0:	ee17 2a90 	vmov	r2, s15
240147e4:	687b      	ldr	r3, [r7, #4]
240147e6:	601a      	str	r2, [r3, #0]
    PLL2_Clocks->PLL2_Q_Frequency = (uint32_t)(float_t)(pll2vco/((float_t)(uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_Q2) >>16) + (float_t)1 )) ;
240147e8:	4b1e      	ldr	r3, [pc, #120]	; (24014864 <HAL_RCCEx_GetPLL2ClockFreq+0x280>)
240147ea:	6b9b      	ldr	r3, [r3, #56]	; 0x38
240147ec:	0c1b      	lsrs	r3, r3, #16
240147ee:	f003 037f 	and.w	r3, r3, #127	; 0x7f
240147f2:	ee07 3a90 	vmov	s15, r3
240147f6:	eef8 7a67 	vcvt.f32.u32	s15, s15
240147fa:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
240147fe:	ee37 7a87 	vadd.f32	s14, s15, s14
24014802:	edd7 6a07 	vldr	s13, [r7, #28]
24014806:	eec6 7a87 	vdiv.f32	s15, s13, s14
2401480a:	eefc 7ae7 	vcvt.u32.f32	s15, s15
2401480e:	ee17 2a90 	vmov	r2, s15
24014812:	687b      	ldr	r3, [r7, #4]
24014814:	605a      	str	r2, [r3, #4]
    PLL2_Clocks->PLL2_R_Frequency = (uint32_t)(float_t)(pll2vco/((float_t)(uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_R2) >>24) + (float_t)1 )) ;
24014816:	4b13      	ldr	r3, [pc, #76]	; (24014864 <HAL_RCCEx_GetPLL2ClockFreq+0x280>)
24014818:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2401481a:	0e1b      	lsrs	r3, r3, #24
2401481c:	f003 037f 	and.w	r3, r3, #127	; 0x7f
24014820:	ee07 3a90 	vmov	s15, r3
24014824:	eef8 7a67 	vcvt.f32.u32	s15, s15
24014828:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
2401482c:	ee37 7a87 	vadd.f32	s14, s15, s14
24014830:	edd7 6a07 	vldr	s13, [r7, #28]
24014834:	eec6 7a87 	vdiv.f32	s15, s13, s14
24014838:	eefc 7ae7 	vcvt.u32.f32	s15, s15
2401483c:	ee17 2a90 	vmov	r2, s15
24014840:	687b      	ldr	r3, [r7, #4]
24014842:	609a      	str	r2, [r3, #8]
  {
    PLL2_Clocks->PLL2_P_Frequency = 0U;
    PLL2_Clocks->PLL2_Q_Frequency = 0U;
    PLL2_Clocks->PLL2_R_Frequency = 0U;
  }
}
24014844:	e008      	b.n	24014858 <HAL_RCCEx_GetPLL2ClockFreq+0x274>
    PLL2_Clocks->PLL2_P_Frequency = 0U;
24014846:	687b      	ldr	r3, [r7, #4]
24014848:	2200      	movs	r2, #0
2401484a:	601a      	str	r2, [r3, #0]
    PLL2_Clocks->PLL2_Q_Frequency = 0U;
2401484c:	687b      	ldr	r3, [r7, #4]
2401484e:	2200      	movs	r2, #0
24014850:	605a      	str	r2, [r3, #4]
    PLL2_Clocks->PLL2_R_Frequency = 0U;
24014852:	687b      	ldr	r3, [r7, #4]
24014854:	2200      	movs	r2, #0
24014856:	609a      	str	r2, [r3, #8]
}
24014858:	bf00      	nop
2401485a:	3724      	adds	r7, #36	; 0x24
2401485c:	46bd      	mov	sp, r7
2401485e:	f85d 7b04 	ldr.w	r7, [sp], #4
24014862:	4770      	bx	lr
24014864:	58024400 	.word	0x58024400
24014868:	03d09000 	.word	0x03d09000
2401486c:	46000000 	.word	0x46000000
24014870:	4c742400 	.word	0x4c742400
24014874:	4a742400 	.word	0x4a742400
24014878:	4bbebc20 	.word	0x4bbebc20

2401487c <HAL_RCCEx_GetPLL3ClockFreq>:
  *         right PLL3CLK value. Otherwise, any configuration based on this function will be incorrect.
  * @param  PLL3_Clocks structure.
  * @retval None
  */
void HAL_RCCEx_GetPLL3ClockFreq(PLL3_ClocksTypeDef* PLL3_Clocks)
{
2401487c:	b480      	push	{r7}
2401487e:	b089      	sub	sp, #36	; 0x24
24014880:	af00      	add	r7, sp, #0
24014882:	6078      	str	r0, [r7, #4]
  float_t fracn3, pll3vco;

  /* PLL3_VCO = (HSE_VALUE or HSI_VALUE or CSI_VALUE/ PLL3M) * PLL3N
     PLL3xCLK = PLL3_VCO / PLLxR
  */
  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
24014884:	4b9d      	ldr	r3, [pc, #628]	; (24014afc <HAL_RCCEx_GetPLL3ClockFreq+0x280>)
24014886:	6a9b      	ldr	r3, [r3, #40]	; 0x28
24014888:	f003 0303 	and.w	r3, r3, #3
2401488c:	61bb      	str	r3, [r7, #24]
  pll3m = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM3)>> 20)  ;
2401488e:	4b9b      	ldr	r3, [pc, #620]	; (24014afc <HAL_RCCEx_GetPLL3ClockFreq+0x280>)
24014890:	6a9b      	ldr	r3, [r3, #40]	; 0x28
24014892:	0d1b      	lsrs	r3, r3, #20
24014894:	f003 033f 	and.w	r3, r3, #63	; 0x3f
24014898:	617b      	str	r3, [r7, #20]
  pll3fracen = (RCC->PLLCFGR & RCC_PLLCFGR_PLL3FRACEN) >> RCC_PLLCFGR_PLL3FRACEN_Pos;
2401489a:	4b98      	ldr	r3, [pc, #608]	; (24014afc <HAL_RCCEx_GetPLL3ClockFreq+0x280>)
2401489c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2401489e:	0a1b      	lsrs	r3, r3, #8
240148a0:	f003 0301 	and.w	r3, r3, #1
240148a4:	613b      	str	r3, [r7, #16]
  fracn3 = (float_t)(uint32_t)(pll3fracen* ((RCC->PLL3FRACR & RCC_PLL3FRACR_FRACN3)>> 3));
240148a6:	4b95      	ldr	r3, [pc, #596]	; (24014afc <HAL_RCCEx_GetPLL3ClockFreq+0x280>)
240148a8:	6c5b      	ldr	r3, [r3, #68]	; 0x44
240148aa:	08db      	lsrs	r3, r3, #3
240148ac:	f3c3 030c 	ubfx	r3, r3, #0, #13
240148b0:	693a      	ldr	r2, [r7, #16]
240148b2:	fb02 f303 	mul.w	r3, r2, r3
240148b6:	ee07 3a90 	vmov	s15, r3
240148ba:	eef8 7a67 	vcvt.f32.u32	s15, s15
240148be:	edc7 7a03 	vstr	s15, [r7, #12]

  if (pll3m != 0U)
240148c2:	697b      	ldr	r3, [r7, #20]
240148c4:	2b00      	cmp	r3, #0
240148c6:	f000 810a 	beq.w	24014ade <HAL_RCCEx_GetPLL3ClockFreq+0x262>
  {
    switch (pllsource)
240148ca:	69bb      	ldr	r3, [r7, #24]
240148cc:	2b01      	cmp	r3, #1
240148ce:	d05a      	beq.n	24014986 <HAL_RCCEx_GetPLL3ClockFreq+0x10a>
240148d0:	2b01      	cmp	r3, #1
240148d2:	d302      	bcc.n	240148da <HAL_RCCEx_GetPLL3ClockFreq+0x5e>
240148d4:	2b02      	cmp	r3, #2
240148d6:	d078      	beq.n	240149ca <HAL_RCCEx_GetPLL3ClockFreq+0x14e>
240148d8:	e099      	b.n	24014a0e <HAL_RCCEx_GetPLL3ClockFreq+0x192>
    {
    case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */

      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
240148da:	4b88      	ldr	r3, [pc, #544]	; (24014afc <HAL_RCCEx_GetPLL3ClockFreq+0x280>)
240148dc:	681b      	ldr	r3, [r3, #0]
240148de:	f003 0320 	and.w	r3, r3, #32
240148e2:	2b00      	cmp	r3, #0
240148e4:	d02d      	beq.n	24014942 <HAL_RCCEx_GetPLL3ClockFreq+0xc6>
      {
        hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
240148e6:	4b85      	ldr	r3, [pc, #532]	; (24014afc <HAL_RCCEx_GetPLL3ClockFreq+0x280>)
240148e8:	681b      	ldr	r3, [r3, #0]
240148ea:	08db      	lsrs	r3, r3, #3
240148ec:	f003 0303 	and.w	r3, r3, #3
240148f0:	4a83      	ldr	r2, [pc, #524]	; (24014b00 <HAL_RCCEx_GetPLL3ClockFreq+0x284>)
240148f2:	fa22 f303 	lsr.w	r3, r2, r3
240148f6:	60bb      	str	r3, [r7, #8]
        pll3vco = ((float_t)hsivalue / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3/(float_t)0x2000) +(float_t)1 );
240148f8:	68bb      	ldr	r3, [r7, #8]
240148fa:	ee07 3a90 	vmov	s15, r3
240148fe:	eef8 6a67 	vcvt.f32.u32	s13, s15
24014902:	697b      	ldr	r3, [r7, #20]
24014904:	ee07 3a90 	vmov	s15, r3
24014908:	eef8 7a67 	vcvt.f32.u32	s15, s15
2401490c:	ee86 7aa7 	vdiv.f32	s14, s13, s15
24014910:	4b7a      	ldr	r3, [pc, #488]	; (24014afc <HAL_RCCEx_GetPLL3ClockFreq+0x280>)
24014912:	6c1b      	ldr	r3, [r3, #64]	; 0x40
24014914:	f3c3 0308 	ubfx	r3, r3, #0, #9
24014918:	ee07 3a90 	vmov	s15, r3
2401491c:	eef8 6a67 	vcvt.f32.u32	s13, s15
24014920:	ed97 6a03 	vldr	s12, [r7, #12]
24014924:	eddf 5a77 	vldr	s11, [pc, #476]	; 24014b04 <HAL_RCCEx_GetPLL3ClockFreq+0x288>
24014928:	eec6 7a25 	vdiv.f32	s15, s12, s11
2401492c:	ee76 7aa7 	vadd.f32	s15, s13, s15
24014930:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
24014934:	ee77 7aa6 	vadd.f32	s15, s15, s13
24014938:	ee67 7a27 	vmul.f32	s15, s14, s15
2401493c:	edc7 7a07 	vstr	s15, [r7, #28]
      }
      else
      {
        pll3vco = ((float_t)HSI_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3/(float_t)0x2000) +(float_t)1 );
      }
      break;
24014940:	e087      	b.n	24014a52 <HAL_RCCEx_GetPLL3ClockFreq+0x1d6>
        pll3vco = ((float_t)HSI_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3/(float_t)0x2000) +(float_t)1 );
24014942:	697b      	ldr	r3, [r7, #20]
24014944:	ee07 3a90 	vmov	s15, r3
24014948:	eef8 7a67 	vcvt.f32.u32	s15, s15
2401494c:	eddf 6a6e 	vldr	s13, [pc, #440]	; 24014b08 <HAL_RCCEx_GetPLL3ClockFreq+0x28c>
24014950:	ee86 7aa7 	vdiv.f32	s14, s13, s15
24014954:	4b69      	ldr	r3, [pc, #420]	; (24014afc <HAL_RCCEx_GetPLL3ClockFreq+0x280>)
24014956:	6c1b      	ldr	r3, [r3, #64]	; 0x40
24014958:	f3c3 0308 	ubfx	r3, r3, #0, #9
2401495c:	ee07 3a90 	vmov	s15, r3
24014960:	eef8 6a67 	vcvt.f32.u32	s13, s15
24014964:	ed97 6a03 	vldr	s12, [r7, #12]
24014968:	eddf 5a66 	vldr	s11, [pc, #408]	; 24014b04 <HAL_RCCEx_GetPLL3ClockFreq+0x288>
2401496c:	eec6 7a25 	vdiv.f32	s15, s12, s11
24014970:	ee76 7aa7 	vadd.f32	s15, s13, s15
24014974:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
24014978:	ee77 7aa6 	vadd.f32	s15, s15, s13
2401497c:	ee67 7a27 	vmul.f32	s15, s14, s15
24014980:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
24014984:	e065      	b.n	24014a52 <HAL_RCCEx_GetPLL3ClockFreq+0x1d6>
    case RCC_PLLSOURCE_CSI:  /* CSI used as PLL clock source */
      pll3vco = ((float_t)CSI_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3/(float_t)0x2000) +(float_t)1 );
24014986:	697b      	ldr	r3, [r7, #20]
24014988:	ee07 3a90 	vmov	s15, r3
2401498c:	eef8 7a67 	vcvt.f32.u32	s15, s15
24014990:	eddf 6a5e 	vldr	s13, [pc, #376]	; 24014b0c <HAL_RCCEx_GetPLL3ClockFreq+0x290>
24014994:	ee86 7aa7 	vdiv.f32	s14, s13, s15
24014998:	4b58      	ldr	r3, [pc, #352]	; (24014afc <HAL_RCCEx_GetPLL3ClockFreq+0x280>)
2401499a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
2401499c:	f3c3 0308 	ubfx	r3, r3, #0, #9
240149a0:	ee07 3a90 	vmov	s15, r3
240149a4:	eef8 6a67 	vcvt.f32.u32	s13, s15
240149a8:	ed97 6a03 	vldr	s12, [r7, #12]
240149ac:	eddf 5a55 	vldr	s11, [pc, #340]	; 24014b04 <HAL_RCCEx_GetPLL3ClockFreq+0x288>
240149b0:	eec6 7a25 	vdiv.f32	s15, s12, s11
240149b4:	ee76 7aa7 	vadd.f32	s15, s13, s15
240149b8:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
240149bc:	ee77 7aa6 	vadd.f32	s15, s15, s13
240149c0:	ee67 7a27 	vmul.f32	s15, s14, s15
240149c4:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
240149c8:	e043      	b.n	24014a52 <HAL_RCCEx_GetPLL3ClockFreq+0x1d6>

    case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
      pll3vco = ((float_t)HSE_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3/(float_t)0x2000) +(float_t)1 );
240149ca:	697b      	ldr	r3, [r7, #20]
240149cc:	ee07 3a90 	vmov	s15, r3
240149d0:	eef8 7a67 	vcvt.f32.u32	s15, s15
240149d4:	eddf 6a4e 	vldr	s13, [pc, #312]	; 24014b10 <HAL_RCCEx_GetPLL3ClockFreq+0x294>
240149d8:	ee86 7aa7 	vdiv.f32	s14, s13, s15
240149dc:	4b47      	ldr	r3, [pc, #284]	; (24014afc <HAL_RCCEx_GetPLL3ClockFreq+0x280>)
240149de:	6c1b      	ldr	r3, [r3, #64]	; 0x40
240149e0:	f3c3 0308 	ubfx	r3, r3, #0, #9
240149e4:	ee07 3a90 	vmov	s15, r3
240149e8:	eef8 6a67 	vcvt.f32.u32	s13, s15
240149ec:	ed97 6a03 	vldr	s12, [r7, #12]
240149f0:	eddf 5a44 	vldr	s11, [pc, #272]	; 24014b04 <HAL_RCCEx_GetPLL3ClockFreq+0x288>
240149f4:	eec6 7a25 	vdiv.f32	s15, s12, s11
240149f8:	ee76 7aa7 	vadd.f32	s15, s13, s15
240149fc:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
24014a00:	ee77 7aa6 	vadd.f32	s15, s15, s13
24014a04:	ee67 7a27 	vmul.f32	s15, s14, s15
24014a08:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
24014a0c:	e021      	b.n	24014a52 <HAL_RCCEx_GetPLL3ClockFreq+0x1d6>

    default:
      pll3vco = ((float_t)CSI_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3/(float_t)0x2000) +(float_t)1 );
24014a0e:	697b      	ldr	r3, [r7, #20]
24014a10:	ee07 3a90 	vmov	s15, r3
24014a14:	eef8 7a67 	vcvt.f32.u32	s15, s15
24014a18:	eddf 6a3c 	vldr	s13, [pc, #240]	; 24014b0c <HAL_RCCEx_GetPLL3ClockFreq+0x290>
24014a1c:	ee86 7aa7 	vdiv.f32	s14, s13, s15
24014a20:	4b36      	ldr	r3, [pc, #216]	; (24014afc <HAL_RCCEx_GetPLL3ClockFreq+0x280>)
24014a22:	6c1b      	ldr	r3, [r3, #64]	; 0x40
24014a24:	f3c3 0308 	ubfx	r3, r3, #0, #9
24014a28:	ee07 3a90 	vmov	s15, r3
24014a2c:	eef8 6a67 	vcvt.f32.u32	s13, s15
24014a30:	ed97 6a03 	vldr	s12, [r7, #12]
24014a34:	eddf 5a33 	vldr	s11, [pc, #204]	; 24014b04 <HAL_RCCEx_GetPLL3ClockFreq+0x288>
24014a38:	eec6 7a25 	vdiv.f32	s15, s12, s11
24014a3c:	ee76 7aa7 	vadd.f32	s15, s13, s15
24014a40:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
24014a44:	ee77 7aa6 	vadd.f32	s15, s15, s13
24014a48:	ee67 7a27 	vmul.f32	s15, s14, s15
24014a4c:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
24014a50:	bf00      	nop
    }
    PLL3_Clocks->PLL3_P_Frequency = (uint32_t)(float_t)(pll3vco/((float_t)(uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_P3) >>9)  + (float_t)1 )) ;
24014a52:	4b2a      	ldr	r3, [pc, #168]	; (24014afc <HAL_RCCEx_GetPLL3ClockFreq+0x280>)
24014a54:	6c1b      	ldr	r3, [r3, #64]	; 0x40
24014a56:	0a5b      	lsrs	r3, r3, #9
24014a58:	f003 037f 	and.w	r3, r3, #127	; 0x7f
24014a5c:	ee07 3a90 	vmov	s15, r3
24014a60:	eef8 7a67 	vcvt.f32.u32	s15, s15
24014a64:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
24014a68:	ee37 7a87 	vadd.f32	s14, s15, s14
24014a6c:	edd7 6a07 	vldr	s13, [r7, #28]
24014a70:	eec6 7a87 	vdiv.f32	s15, s13, s14
24014a74:	eefc 7ae7 	vcvt.u32.f32	s15, s15
24014a78:	ee17 2a90 	vmov	r2, s15
24014a7c:	687b      	ldr	r3, [r7, #4]
24014a7e:	601a      	str	r2, [r3, #0]
    PLL3_Clocks->PLL3_Q_Frequency = (uint32_t)(float_t)(pll3vco/((float_t)(uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_Q3) >>16) + (float_t)1 )) ;
24014a80:	4b1e      	ldr	r3, [pc, #120]	; (24014afc <HAL_RCCEx_GetPLL3ClockFreq+0x280>)
24014a82:	6c1b      	ldr	r3, [r3, #64]	; 0x40
24014a84:	0c1b      	lsrs	r3, r3, #16
24014a86:	f003 037f 	and.w	r3, r3, #127	; 0x7f
24014a8a:	ee07 3a90 	vmov	s15, r3
24014a8e:	eef8 7a67 	vcvt.f32.u32	s15, s15
24014a92:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
24014a96:	ee37 7a87 	vadd.f32	s14, s15, s14
24014a9a:	edd7 6a07 	vldr	s13, [r7, #28]
24014a9e:	eec6 7a87 	vdiv.f32	s15, s13, s14
24014aa2:	eefc 7ae7 	vcvt.u32.f32	s15, s15
24014aa6:	ee17 2a90 	vmov	r2, s15
24014aaa:	687b      	ldr	r3, [r7, #4]
24014aac:	605a      	str	r2, [r3, #4]
    PLL3_Clocks->PLL3_R_Frequency = (uint32_t)(float_t)(pll3vco/((float_t)(uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_R3) >>24) + (float_t)1 )) ;
24014aae:	4b13      	ldr	r3, [pc, #76]	; (24014afc <HAL_RCCEx_GetPLL3ClockFreq+0x280>)
24014ab0:	6c1b      	ldr	r3, [r3, #64]	; 0x40
24014ab2:	0e1b      	lsrs	r3, r3, #24
24014ab4:	f003 037f 	and.w	r3, r3, #127	; 0x7f
24014ab8:	ee07 3a90 	vmov	s15, r3
24014abc:	eef8 7a67 	vcvt.f32.u32	s15, s15
24014ac0:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
24014ac4:	ee37 7a87 	vadd.f32	s14, s15, s14
24014ac8:	edd7 6a07 	vldr	s13, [r7, #28]
24014acc:	eec6 7a87 	vdiv.f32	s15, s13, s14
24014ad0:	eefc 7ae7 	vcvt.u32.f32	s15, s15
24014ad4:	ee17 2a90 	vmov	r2, s15
24014ad8:	687b      	ldr	r3, [r7, #4]
24014ada:	609a      	str	r2, [r3, #8]
    PLL3_Clocks->PLL3_P_Frequency = 0U;
    PLL3_Clocks->PLL3_Q_Frequency = 0U;
    PLL3_Clocks->PLL3_R_Frequency = 0U;
  }

}
24014adc:	e008      	b.n	24014af0 <HAL_RCCEx_GetPLL3ClockFreq+0x274>
    PLL3_Clocks->PLL3_P_Frequency = 0U;
24014ade:	687b      	ldr	r3, [r7, #4]
24014ae0:	2200      	movs	r2, #0
24014ae2:	601a      	str	r2, [r3, #0]
    PLL3_Clocks->PLL3_Q_Frequency = 0U;
24014ae4:	687b      	ldr	r3, [r7, #4]
24014ae6:	2200      	movs	r2, #0
24014ae8:	605a      	str	r2, [r3, #4]
    PLL3_Clocks->PLL3_R_Frequency = 0U;
24014aea:	687b      	ldr	r3, [r7, #4]
24014aec:	2200      	movs	r2, #0
24014aee:	609a      	str	r2, [r3, #8]
}
24014af0:	bf00      	nop
24014af2:	3724      	adds	r7, #36	; 0x24
24014af4:	46bd      	mov	sp, r7
24014af6:	f85d 7b04 	ldr.w	r7, [sp], #4
24014afa:	4770      	bx	lr
24014afc:	58024400 	.word	0x58024400
24014b00:	03d09000 	.word	0x03d09000
24014b04:	46000000 	.word	0x46000000
24014b08:	4c742400 	.word	0x4c742400
24014b0c:	4a742400 	.word	0x4a742400
24014b10:	4bbebc20 	.word	0x4bbebc20

24014b14 <HAL_RCCEx_GetPLL1ClockFreq>:
  *         right PLL1CLK value. Otherwise, any configuration based on this function will be incorrect.
  * @param  PLL1_Clocks structure.
  * @retval None
  */
void HAL_RCCEx_GetPLL1ClockFreq(PLL1_ClocksTypeDef* PLL1_Clocks)
{
24014b14:	b480      	push	{r7}
24014b16:	b089      	sub	sp, #36	; 0x24
24014b18:	af00      	add	r7, sp, #0
24014b1a:	6078      	str	r0, [r7, #4]
  uint32_t pllsource, pll1m, pll1fracen, hsivalue;
  float_t fracn1, pll1vco;

  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
24014b1c:	4b9d      	ldr	r3, [pc, #628]	; (24014d94 <HAL_RCCEx_GetPLL1ClockFreq+0x280>)
24014b1e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
24014b20:	f003 0303 	and.w	r3, r3, #3
24014b24:	61bb      	str	r3, [r7, #24]
  pll1m = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM1)>> 4);
24014b26:	4b9b      	ldr	r3, [pc, #620]	; (24014d94 <HAL_RCCEx_GetPLL1ClockFreq+0x280>)
24014b28:	6a9b      	ldr	r3, [r3, #40]	; 0x28
24014b2a:	091b      	lsrs	r3, r3, #4
24014b2c:	f003 033f 	and.w	r3, r3, #63	; 0x3f
24014b30:	617b      	str	r3, [r7, #20]
  pll1fracen = RCC->PLLCFGR & RCC_PLLCFGR_PLL1FRACEN;
24014b32:	4b98      	ldr	r3, [pc, #608]	; (24014d94 <HAL_RCCEx_GetPLL1ClockFreq+0x280>)
24014b34:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24014b36:	f003 0301 	and.w	r3, r3, #1
24014b3a:	613b      	str	r3, [r7, #16]
  fracn1 = (float_t)(uint32_t)(pll1fracen * ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));
24014b3c:	4b95      	ldr	r3, [pc, #596]	; (24014d94 <HAL_RCCEx_GetPLL1ClockFreq+0x280>)
24014b3e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
24014b40:	08db      	lsrs	r3, r3, #3
24014b42:	f3c3 030c 	ubfx	r3, r3, #0, #13
24014b46:	693a      	ldr	r2, [r7, #16]
24014b48:	fb02 f303 	mul.w	r3, r2, r3
24014b4c:	ee07 3a90 	vmov	s15, r3
24014b50:	eef8 7a67 	vcvt.f32.u32	s15, s15
24014b54:	edc7 7a03 	vstr	s15, [r7, #12]

  if (pll1m != 0U)
24014b58:	697b      	ldr	r3, [r7, #20]
24014b5a:	2b00      	cmp	r3, #0
24014b5c:	f000 810a 	beq.w	24014d74 <HAL_RCCEx_GetPLL1ClockFreq+0x260>
  {
    switch (pllsource)
24014b60:	69bb      	ldr	r3, [r7, #24]
24014b62:	2b01      	cmp	r3, #1
24014b64:	d05a      	beq.n	24014c1c <HAL_RCCEx_GetPLL1ClockFreq+0x108>
24014b66:	2b01      	cmp	r3, #1
24014b68:	d302      	bcc.n	24014b70 <HAL_RCCEx_GetPLL1ClockFreq+0x5c>
24014b6a:	2b02      	cmp	r3, #2
24014b6c:	d078      	beq.n	24014c60 <HAL_RCCEx_GetPLL1ClockFreq+0x14c>
24014b6e:	e099      	b.n	24014ca4 <HAL_RCCEx_GetPLL1ClockFreq+0x190>
    {

    case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */

      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
24014b70:	4b88      	ldr	r3, [pc, #544]	; (24014d94 <HAL_RCCEx_GetPLL1ClockFreq+0x280>)
24014b72:	681b      	ldr	r3, [r3, #0]
24014b74:	f003 0320 	and.w	r3, r3, #32
24014b78:	2b00      	cmp	r3, #0
24014b7a:	d02d      	beq.n	24014bd8 <HAL_RCCEx_GetPLL1ClockFreq+0xc4>
      {
        hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
24014b7c:	4b85      	ldr	r3, [pc, #532]	; (24014d94 <HAL_RCCEx_GetPLL1ClockFreq+0x280>)
24014b7e:	681b      	ldr	r3, [r3, #0]
24014b80:	08db      	lsrs	r3, r3, #3
24014b82:	f003 0303 	and.w	r3, r3, #3
24014b86:	4a84      	ldr	r2, [pc, #528]	; (24014d98 <HAL_RCCEx_GetPLL1ClockFreq+0x284>)
24014b88:	fa22 f303 	lsr.w	r3, r2, r3
24014b8c:	60bb      	str	r3, [r7, #8]
        pll1vco = ((float_t)hsivalue / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
24014b8e:	68bb      	ldr	r3, [r7, #8]
24014b90:	ee07 3a90 	vmov	s15, r3
24014b94:	eef8 6a67 	vcvt.f32.u32	s13, s15
24014b98:	697b      	ldr	r3, [r7, #20]
24014b9a:	ee07 3a90 	vmov	s15, r3
24014b9e:	eef8 7a67 	vcvt.f32.u32	s15, s15
24014ba2:	ee86 7aa7 	vdiv.f32	s14, s13, s15
24014ba6:	4b7b      	ldr	r3, [pc, #492]	; (24014d94 <HAL_RCCEx_GetPLL1ClockFreq+0x280>)
24014ba8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24014baa:	f3c3 0308 	ubfx	r3, r3, #0, #9
24014bae:	ee07 3a90 	vmov	s15, r3
24014bb2:	eef8 6a67 	vcvt.f32.u32	s13, s15
24014bb6:	ed97 6a03 	vldr	s12, [r7, #12]
24014bba:	eddf 5a78 	vldr	s11, [pc, #480]	; 24014d9c <HAL_RCCEx_GetPLL1ClockFreq+0x288>
24014bbe:	eec6 7a25 	vdiv.f32	s15, s12, s11
24014bc2:	ee76 7aa7 	vadd.f32	s15, s13, s15
24014bc6:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
24014bca:	ee77 7aa6 	vadd.f32	s15, s15, s13
24014bce:	ee67 7a27 	vmul.f32	s15, s14, s15
24014bd2:	edc7 7a07 	vstr	s15, [r7, #28]
      }
      else
      {
        pll1vco = ((float_t)HSI_VALUE / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
      }
      break;
24014bd6:	e087      	b.n	24014ce8 <HAL_RCCEx_GetPLL1ClockFreq+0x1d4>
        pll1vco = ((float_t)HSI_VALUE / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
24014bd8:	697b      	ldr	r3, [r7, #20]
24014bda:	ee07 3a90 	vmov	s15, r3
24014bde:	eef8 7a67 	vcvt.f32.u32	s15, s15
24014be2:	eddf 6a6f 	vldr	s13, [pc, #444]	; 24014da0 <HAL_RCCEx_GetPLL1ClockFreq+0x28c>
24014be6:	ee86 7aa7 	vdiv.f32	s14, s13, s15
24014bea:	4b6a      	ldr	r3, [pc, #424]	; (24014d94 <HAL_RCCEx_GetPLL1ClockFreq+0x280>)
24014bec:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24014bee:	f3c3 0308 	ubfx	r3, r3, #0, #9
24014bf2:	ee07 3a90 	vmov	s15, r3
24014bf6:	eef8 6a67 	vcvt.f32.u32	s13, s15
24014bfa:	ed97 6a03 	vldr	s12, [r7, #12]
24014bfe:	eddf 5a67 	vldr	s11, [pc, #412]	; 24014d9c <HAL_RCCEx_GetPLL1ClockFreq+0x288>
24014c02:	eec6 7a25 	vdiv.f32	s15, s12, s11
24014c06:	ee76 7aa7 	vadd.f32	s15, s13, s15
24014c0a:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
24014c0e:	ee77 7aa6 	vadd.f32	s15, s15, s13
24014c12:	ee67 7a27 	vmul.f32	s15, s14, s15
24014c16:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
24014c1a:	e065      	b.n	24014ce8 <HAL_RCCEx_GetPLL1ClockFreq+0x1d4>
    case RCC_PLLSOURCE_CSI:  /* CSI used as PLL clock source */
      pll1vco = ((float_t)CSI_VALUE / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
24014c1c:	697b      	ldr	r3, [r7, #20]
24014c1e:	ee07 3a90 	vmov	s15, r3
24014c22:	eef8 7a67 	vcvt.f32.u32	s15, s15
24014c26:	eddf 6a5f 	vldr	s13, [pc, #380]	; 24014da4 <HAL_RCCEx_GetPLL1ClockFreq+0x290>
24014c2a:	ee86 7aa7 	vdiv.f32	s14, s13, s15
24014c2e:	4b59      	ldr	r3, [pc, #356]	; (24014d94 <HAL_RCCEx_GetPLL1ClockFreq+0x280>)
24014c30:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24014c32:	f3c3 0308 	ubfx	r3, r3, #0, #9
24014c36:	ee07 3a90 	vmov	s15, r3
24014c3a:	eef8 6a67 	vcvt.f32.u32	s13, s15
24014c3e:	ed97 6a03 	vldr	s12, [r7, #12]
24014c42:	eddf 5a56 	vldr	s11, [pc, #344]	; 24014d9c <HAL_RCCEx_GetPLL1ClockFreq+0x288>
24014c46:	eec6 7a25 	vdiv.f32	s15, s12, s11
24014c4a:	ee76 7aa7 	vadd.f32	s15, s13, s15
24014c4e:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
24014c52:	ee77 7aa6 	vadd.f32	s15, s15, s13
24014c56:	ee67 7a27 	vmul.f32	s15, s14, s15
24014c5a:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
24014c5e:	e043      	b.n	24014ce8 <HAL_RCCEx_GetPLL1ClockFreq+0x1d4>

    case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
      pll1vco = ((float_t)HSE_VALUE / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
24014c60:	697b      	ldr	r3, [r7, #20]
24014c62:	ee07 3a90 	vmov	s15, r3
24014c66:	eef8 7a67 	vcvt.f32.u32	s15, s15
24014c6a:	eddf 6a4f 	vldr	s13, [pc, #316]	; 24014da8 <HAL_RCCEx_GetPLL1ClockFreq+0x294>
24014c6e:	ee86 7aa7 	vdiv.f32	s14, s13, s15
24014c72:	4b48      	ldr	r3, [pc, #288]	; (24014d94 <HAL_RCCEx_GetPLL1ClockFreq+0x280>)
24014c74:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24014c76:	f3c3 0308 	ubfx	r3, r3, #0, #9
24014c7a:	ee07 3a90 	vmov	s15, r3
24014c7e:	eef8 6a67 	vcvt.f32.u32	s13, s15
24014c82:	ed97 6a03 	vldr	s12, [r7, #12]
24014c86:	eddf 5a45 	vldr	s11, [pc, #276]	; 24014d9c <HAL_RCCEx_GetPLL1ClockFreq+0x288>
24014c8a:	eec6 7a25 	vdiv.f32	s15, s12, s11
24014c8e:	ee76 7aa7 	vadd.f32	s15, s13, s15
24014c92:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
24014c96:	ee77 7aa6 	vadd.f32	s15, s15, s13
24014c9a:	ee67 7a27 	vmul.f32	s15, s14, s15
24014c9e:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
24014ca2:	e021      	b.n	24014ce8 <HAL_RCCEx_GetPLL1ClockFreq+0x1d4>

    default:
      pll1vco = ((float_t)CSI_VALUE / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
24014ca4:	697b      	ldr	r3, [r7, #20]
24014ca6:	ee07 3a90 	vmov	s15, r3
24014caa:	eef8 7a67 	vcvt.f32.u32	s15, s15
24014cae:	eddf 6a3d 	vldr	s13, [pc, #244]	; 24014da4 <HAL_RCCEx_GetPLL1ClockFreq+0x290>
24014cb2:	ee86 7aa7 	vdiv.f32	s14, s13, s15
24014cb6:	4b37      	ldr	r3, [pc, #220]	; (24014d94 <HAL_RCCEx_GetPLL1ClockFreq+0x280>)
24014cb8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24014cba:	f3c3 0308 	ubfx	r3, r3, #0, #9
24014cbe:	ee07 3a90 	vmov	s15, r3
24014cc2:	eef8 6a67 	vcvt.f32.u32	s13, s15
24014cc6:	ed97 6a03 	vldr	s12, [r7, #12]
24014cca:	eddf 5a34 	vldr	s11, [pc, #208]	; 24014d9c <HAL_RCCEx_GetPLL1ClockFreq+0x288>
24014cce:	eec6 7a25 	vdiv.f32	s15, s12, s11
24014cd2:	ee76 7aa7 	vadd.f32	s15, s13, s15
24014cd6:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
24014cda:	ee77 7aa6 	vadd.f32	s15, s15, s13
24014cde:	ee67 7a27 	vmul.f32	s15, s14, s15
24014ce2:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
24014ce6:	bf00      	nop
    }

    PLL1_Clocks->PLL1_P_Frequency = (uint32_t)(float_t)(pll1vco/((float_t)(uint32_t)((RCC->PLL1DIVR & RCC_PLL1DIVR_P1) >>9)  + (float_t)1 )) ;
24014ce8:	4b2a      	ldr	r3, [pc, #168]	; (24014d94 <HAL_RCCEx_GetPLL1ClockFreq+0x280>)
24014cea:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24014cec:	0a5b      	lsrs	r3, r3, #9
24014cee:	f003 037f 	and.w	r3, r3, #127	; 0x7f
24014cf2:	ee07 3a90 	vmov	s15, r3
24014cf6:	eef8 7a67 	vcvt.f32.u32	s15, s15
24014cfa:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
24014cfe:	ee37 7a87 	vadd.f32	s14, s15, s14
24014d02:	edd7 6a07 	vldr	s13, [r7, #28]
24014d06:	eec6 7a87 	vdiv.f32	s15, s13, s14
24014d0a:	eefc 7ae7 	vcvt.u32.f32	s15, s15
24014d0e:	ee17 2a90 	vmov	r2, s15
24014d12:	687b      	ldr	r3, [r7, #4]
24014d14:	601a      	str	r2, [r3, #0]
    PLL1_Clocks->PLL1_Q_Frequency = (uint32_t)(float_t)(pll1vco/((float_t)(uint32_t)((RCC->PLL1DIVR & RCC_PLL1DIVR_Q1) >>16) + (float_t)1 )) ;
24014d16:	4b1f      	ldr	r3, [pc, #124]	; (24014d94 <HAL_RCCEx_GetPLL1ClockFreq+0x280>)
24014d18:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24014d1a:	0c1b      	lsrs	r3, r3, #16
24014d1c:	f003 037f 	and.w	r3, r3, #127	; 0x7f
24014d20:	ee07 3a90 	vmov	s15, r3
24014d24:	eef8 7a67 	vcvt.f32.u32	s15, s15
24014d28:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
24014d2c:	ee37 7a87 	vadd.f32	s14, s15, s14
24014d30:	edd7 6a07 	vldr	s13, [r7, #28]
24014d34:	eec6 7a87 	vdiv.f32	s15, s13, s14
24014d38:	eefc 7ae7 	vcvt.u32.f32	s15, s15
24014d3c:	ee17 2a90 	vmov	r2, s15
24014d40:	687b      	ldr	r3, [r7, #4]
24014d42:	605a      	str	r2, [r3, #4]
    PLL1_Clocks->PLL1_R_Frequency = (uint32_t)(float_t)(pll1vco/((float_t)(uint32_t)((RCC->PLL1DIVR & RCC_PLL1DIVR_R1) >>24) + (float_t)1 )) ;
24014d44:	4b13      	ldr	r3, [pc, #76]	; (24014d94 <HAL_RCCEx_GetPLL1ClockFreq+0x280>)
24014d46:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24014d48:	0e1b      	lsrs	r3, r3, #24
24014d4a:	f003 037f 	and.w	r3, r3, #127	; 0x7f
24014d4e:	ee07 3a90 	vmov	s15, r3
24014d52:	eef8 7a67 	vcvt.f32.u32	s15, s15
24014d56:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
24014d5a:	ee37 7a87 	vadd.f32	s14, s15, s14
24014d5e:	edd7 6a07 	vldr	s13, [r7, #28]
24014d62:	eec6 7a87 	vdiv.f32	s15, s13, s14
24014d66:	eefc 7ae7 	vcvt.u32.f32	s15, s15
24014d6a:	ee17 2a90 	vmov	r2, s15
24014d6e:	687b      	ldr	r3, [r7, #4]
24014d70:	609a      	str	r2, [r3, #8]
    PLL1_Clocks->PLL1_P_Frequency = 0U;
    PLL1_Clocks->PLL1_Q_Frequency = 0U;
    PLL1_Clocks->PLL1_R_Frequency = 0U;
  }

}
24014d72:	e008      	b.n	24014d86 <HAL_RCCEx_GetPLL1ClockFreq+0x272>
    PLL1_Clocks->PLL1_P_Frequency = 0U;
24014d74:	687b      	ldr	r3, [r7, #4]
24014d76:	2200      	movs	r2, #0
24014d78:	601a      	str	r2, [r3, #0]
    PLL1_Clocks->PLL1_Q_Frequency = 0U;
24014d7a:	687b      	ldr	r3, [r7, #4]
24014d7c:	2200      	movs	r2, #0
24014d7e:	605a      	str	r2, [r3, #4]
    PLL1_Clocks->PLL1_R_Frequency = 0U;
24014d80:	687b      	ldr	r3, [r7, #4]
24014d82:	2200      	movs	r2, #0
24014d84:	609a      	str	r2, [r3, #8]
}
24014d86:	bf00      	nop
24014d88:	3724      	adds	r7, #36	; 0x24
24014d8a:	46bd      	mov	sp, r7
24014d8c:	f85d 7b04 	ldr.w	r7, [sp], #4
24014d90:	4770      	bx	lr
24014d92:	bf00      	nop
24014d94:	58024400 	.word	0x58024400
24014d98:	03d09000 	.word	0x03d09000
24014d9c:	46000000 	.word	0x46000000
24014da0:	4c742400 	.word	0x4c742400
24014da4:	4a742400 	.word	0x4a742400
24014da8:	4bbebc20 	.word	0x4bbebc20

24014dac <HAL_RCCEx_GetD1SysClockFreq>:
  * @note   The SystemCoreClock CMSIS variable is used to store System current Core Clock Frequency
  *         and updated within this function
  * @retval HCLK frequency
  */
uint32_t HAL_RCCEx_GetD1SysClockFreq(void)
{
24014dac:	b580      	push	{r7, lr}
24014dae:	b082      	sub	sp, #8
24014db0:	af00      	add	r7, sp, #0
uint32_t common_system_clock;

#if defined(RCC_D1CFGR_D1CPRE)
  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos] & 0x1FU);
24014db2:	f7fd fe17 	bl	240129e4 <HAL_RCC_GetSysClockFreq>
24014db6:	4601      	mov	r1, r0
24014db8:	4b10      	ldr	r3, [pc, #64]	; (24014dfc <HAL_RCCEx_GetD1SysClockFreq+0x50>)
24014dba:	699b      	ldr	r3, [r3, #24]
24014dbc:	0a1b      	lsrs	r3, r3, #8
24014dbe:	f003 030f 	and.w	r3, r3, #15
24014dc2:	4a0f      	ldr	r2, [pc, #60]	; (24014e00 <HAL_RCCEx_GetD1SysClockFreq+0x54>)
24014dc4:	5cd3      	ldrb	r3, [r2, r3]
24014dc6:	f003 031f 	and.w	r3, r3, #31
24014dca:	fa21 f303 	lsr.w	r3, r1, r3
24014dce:	607b      	str	r3, [r7, #4]
  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->CDCFGR1 & RCC_CDCFGR1_CDCPRE)>> RCC_CDCFGR1_CDCPRE_Pos] & 0x1FU);
#endif

  /* Update the SystemD2Clock global variable */
#if defined(RCC_D1CFGR_HPRE)
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
24014dd0:	4b0a      	ldr	r3, [pc, #40]	; (24014dfc <HAL_RCCEx_GetD1SysClockFreq+0x50>)
24014dd2:	699b      	ldr	r3, [r3, #24]
24014dd4:	f003 030f 	and.w	r3, r3, #15
24014dd8:	4a09      	ldr	r2, [pc, #36]	; (24014e00 <HAL_RCCEx_GetD1SysClockFreq+0x54>)
24014dda:	5cd3      	ldrb	r3, [r2, r3]
24014ddc:	f003 031f 	and.w	r3, r3, #31
24014de0:	687a      	ldr	r2, [r7, #4]
24014de2:	fa22 f303 	lsr.w	r3, r2, r3
24014de6:	4a07      	ldr	r2, [pc, #28]	; (24014e04 <HAL_RCCEx_GetD1SysClockFreq+0x58>)
24014de8:	6013      	str	r3, [r2, #0]
#endif

#if defined(DUAL_CORE) && defined(CORE_CM4)
  SystemCoreClock = SystemD2Clock;
#else
  SystemCoreClock = common_system_clock;
24014dea:	4a07      	ldr	r2, [pc, #28]	; (24014e08 <HAL_RCCEx_GetD1SysClockFreq+0x5c>)
24014dec:	687b      	ldr	r3, [r7, #4]
24014dee:	6013      	str	r3, [r2, #0]
#endif /* DUAL_CORE && CORE_CM4 */

  return common_system_clock;
24014df0:	687b      	ldr	r3, [r7, #4]
}
24014df2:	4618      	mov	r0, r3
24014df4:	3708      	adds	r7, #8
24014df6:	46bd      	mov	sp, r7
24014df8:	bd80      	pop	{r7, pc}
24014dfa:	bf00      	nop
24014dfc:	58024400 	.word	0x58024400
24014e00:	24016db8 	.word	0x24016db8
24014e04:	240004bc 	.word	0x240004bc
24014e08:	240004b8 	.word	0x240004b8

24014e0c <HAL_RCCEx_EnableLSECSS>:
  *         with HAL_RCC_OscConfig() and the LSE oscillator clock is to be selected as RTC
  *         clock with HAL_RCCEx_PeriphCLKConfig().
  * @retval None
  */
void HAL_RCCEx_EnableLSECSS(void)
{
24014e0c:	b480      	push	{r7}
24014e0e:	af00      	add	r7, sp, #0
  SET_BIT(RCC->BDCR, RCC_BDCR_LSECSSON) ;
24014e10:	4b05      	ldr	r3, [pc, #20]	; (24014e28 <HAL_RCCEx_EnableLSECSS+0x1c>)
24014e12:	6f1b      	ldr	r3, [r3, #112]	; 0x70
24014e14:	4a04      	ldr	r2, [pc, #16]	; (24014e28 <HAL_RCCEx_EnableLSECSS+0x1c>)
24014e16:	f043 0320 	orr.w	r3, r3, #32
24014e1a:	6713      	str	r3, [r2, #112]	; 0x70
}
24014e1c:	bf00      	nop
24014e1e:	46bd      	mov	sp, r7
24014e20:	f85d 7b04 	ldr.w	r7, [sp], #4
24014e24:	4770      	bx	lr
24014e26:	bf00      	nop
24014e28:	58024400 	.word	0x58024400

24014e2c <HAL_RCCEx_DisableLSECSS>:
  * @brief  Disables the LSE Clock Security System.
  * @note   LSE Clock Security System can only be disabled after a LSE failure detection.
  * @retval None
  */
void HAL_RCCEx_DisableLSECSS(void)
{
24014e2c:	b480      	push	{r7}
24014e2e:	af00      	add	r7, sp, #0
  CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSECSSON) ;
24014e30:	4b08      	ldr	r3, [pc, #32]	; (24014e54 <HAL_RCCEx_DisableLSECSS+0x28>)
24014e32:	6f1b      	ldr	r3, [r3, #112]	; 0x70
24014e34:	4a07      	ldr	r2, [pc, #28]	; (24014e54 <HAL_RCCEx_DisableLSECSS+0x28>)
24014e36:	f023 0320 	bic.w	r3, r3, #32
24014e3a:	6713      	str	r3, [r2, #112]	; 0x70
  /* Disable LSE CSS IT if any */
  __HAL_RCC_DISABLE_IT(RCC_IT_LSECSS);
24014e3c:	4b05      	ldr	r3, [pc, #20]	; (24014e54 <HAL_RCCEx_DisableLSECSS+0x28>)
24014e3e:	6e1b      	ldr	r3, [r3, #96]	; 0x60
24014e40:	4a04      	ldr	r2, [pc, #16]	; (24014e54 <HAL_RCCEx_DisableLSECSS+0x28>)
24014e42:	f423 7300 	bic.w	r3, r3, #512	; 0x200
24014e46:	6613      	str	r3, [r2, #96]	; 0x60
}
24014e48:	bf00      	nop
24014e4a:	46bd      	mov	sp, r7
24014e4c:	f85d 7b04 	ldr.w	r7, [sp], #4
24014e50:	4770      	bx	lr
24014e52:	bf00      	nop
24014e54:	58024400 	.word	0x58024400

24014e58 <HAL_RCCEx_EnableLSECSS_IT>:
  * @brief  Enable the LSE Clock Security System Interrupt & corresponding EXTI line.
  * @note   LSE Clock Security System Interrupt is mapped on EXTI line 18
  * @retval None
  */
void HAL_RCCEx_EnableLSECSS_IT(void)
{
24014e58:	b480      	push	{r7}
24014e5a:	af00      	add	r7, sp, #0
  /* Enable LSE CSS */
  SET_BIT(RCC->BDCR, RCC_BDCR_LSECSSON) ;
24014e5c:	4b11      	ldr	r3, [pc, #68]	; (24014ea4 <HAL_RCCEx_EnableLSECSS_IT+0x4c>)
24014e5e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
24014e60:	4a10      	ldr	r2, [pc, #64]	; (24014ea4 <HAL_RCCEx_EnableLSECSS_IT+0x4c>)
24014e62:	f043 0320 	orr.w	r3, r3, #32
24014e66:	6713      	str	r3, [r2, #112]	; 0x70

  /* Enable LSE CSS IT */
  __HAL_RCC_ENABLE_IT(RCC_IT_LSECSS);
24014e68:	4b0e      	ldr	r3, [pc, #56]	; (24014ea4 <HAL_RCCEx_EnableLSECSS_IT+0x4c>)
24014e6a:	6e1b      	ldr	r3, [r3, #96]	; 0x60
24014e6c:	4a0d      	ldr	r2, [pc, #52]	; (24014ea4 <HAL_RCCEx_EnableLSECSS_IT+0x4c>)
24014e6e:	f443 7300 	orr.w	r3, r3, #512	; 0x200
24014e72:	6613      	str	r3, [r2, #96]	; 0x60

  /* Enable IT on EXTI Line 18 */
#if defined(DUAL_CORE) && defined(CORE_CM4)
  __HAL_RCC_C2_LSECSS_EXTI_ENABLE_IT();
#else
  __HAL_RCC_LSECSS_EXTI_ENABLE_IT();
24014e74:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
24014e78:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
24014e7c:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
24014e80:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
24014e84:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
#endif /* DUAL_CORE && CORE_CM4 */
  __HAL_RCC_LSECSS_EXTI_ENABLE_RISING_EDGE();
24014e88:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
24014e8c:	681b      	ldr	r3, [r3, #0]
24014e8e:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
24014e92:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
24014e96:	6013      	str	r3, [r2, #0]
}
24014e98:	bf00      	nop
24014e9a:	46bd      	mov	sp, r7
24014e9c:	f85d 7b04 	ldr.w	r7, [sp], #4
24014ea0:	4770      	bx	lr
24014ea2:	bf00      	nop
24014ea4:	58024400 	.word	0x58024400

24014ea8 <HAL_RCCEx_WakeUpStopCLKConfig>:
  * @note   This function shall not be called after the Clock Security System on HSE has been
  *         enabled.
  * @retval None
  */
void HAL_RCCEx_WakeUpStopCLKConfig(uint32_t WakeUpClk)
{
24014ea8:	b480      	push	{r7}
24014eaa:	b083      	sub	sp, #12
24014eac:	af00      	add	r7, sp, #0
24014eae:	6078      	str	r0, [r7, #4]
  assert_param(IS_RCC_STOP_WAKEUPCLOCK(WakeUpClk));

  __HAL_RCC_WAKEUPSTOP_CLK_CONFIG(WakeUpClk);
24014eb0:	4b06      	ldr	r3, [pc, #24]	; (24014ecc <HAL_RCCEx_WakeUpStopCLKConfig+0x24>)
24014eb2:	691b      	ldr	r3, [r3, #16]
24014eb4:	f023 0240 	bic.w	r2, r3, #64	; 0x40
24014eb8:	4904      	ldr	r1, [pc, #16]	; (24014ecc <HAL_RCCEx_WakeUpStopCLKConfig+0x24>)
24014eba:	687b      	ldr	r3, [r7, #4]
24014ebc:	4313      	orrs	r3, r2
24014ebe:	610b      	str	r3, [r1, #16]
}
24014ec0:	bf00      	nop
24014ec2:	370c      	adds	r7, #12
24014ec4:	46bd      	mov	sp, r7
24014ec6:	f85d 7b04 	ldr.w	r7, [sp], #4
24014eca:	4770      	bx	lr
24014ecc:	58024400 	.word	0x58024400

24014ed0 <HAL_RCCEx_KerWakeUpStopCLKConfig>:
  *            @arg RCC_STOP_KERWAKEUPCLOCK_CSI: CSI oscillator selection
  *            @arg RCC_STOP_KERWAKEUPCLOCK_HSI: HSI oscillator selection
  * @retval None
  */
void HAL_RCCEx_KerWakeUpStopCLKConfig(uint32_t WakeUpClk)
{
24014ed0:	b480      	push	{r7}
24014ed2:	b083      	sub	sp, #12
24014ed4:	af00      	add	r7, sp, #0
24014ed6:	6078      	str	r0, [r7, #4]
  assert_param(IS_RCC_STOP_KERWAKEUPCLOCK(WakeUpClk));

  __HAL_RCC_KERWAKEUPSTOP_CLK_CONFIG(WakeUpClk);
24014ed8:	4b06      	ldr	r3, [pc, #24]	; (24014ef4 <HAL_RCCEx_KerWakeUpStopCLKConfig+0x24>)
24014eda:	691b      	ldr	r3, [r3, #16]
24014edc:	f023 0280 	bic.w	r2, r3, #128	; 0x80
24014ee0:	4904      	ldr	r1, [pc, #16]	; (24014ef4 <HAL_RCCEx_KerWakeUpStopCLKConfig+0x24>)
24014ee2:	687b      	ldr	r3, [r7, #4]
24014ee4:	4313      	orrs	r3, r2
24014ee6:	610b      	str	r3, [r1, #16]
}
24014ee8:	bf00      	nop
24014eea:	370c      	adds	r7, #12
24014eec:	46bd      	mov	sp, r7
24014eee:	f85d 7b04 	ldr.w	r7, [sp], #4
24014ef2:	4770      	bx	lr
24014ef4:	58024400 	.word	0x58024400

24014ef8 <HAL_RCCEx_WWDGxSysResetConfig>:
  * @note   This bit can be set by software but is cleared by hardware during a system reset
  *
  * @retval None
  */
void HAL_RCCEx_WWDGxSysResetConfig(uint32_t RCC_WWDGx)
{
24014ef8:	b480      	push	{r7}
24014efa:	b083      	sub	sp, #12
24014efc:	af00      	add	r7, sp, #0
24014efe:	6078      	str	r0, [r7, #4]
  assert_param(IS_RCC_SCOPE_WWDG(RCC_WWDGx));
  SET_BIT(RCC->GCR, RCC_WWDGx) ;
24014f00:	4b06      	ldr	r3, [pc, #24]	; (24014f1c <HAL_RCCEx_WWDGxSysResetConfig+0x24>)
24014f02:	f8d3 20a0 	ldr.w	r2, [r3, #160]	; 0xa0
24014f06:	4905      	ldr	r1, [pc, #20]	; (24014f1c <HAL_RCCEx_WWDGxSysResetConfig+0x24>)
24014f08:	687b      	ldr	r3, [r7, #4]
24014f0a:	4313      	orrs	r3, r2
24014f0c:	f8c1 30a0 	str.w	r3, [r1, #160]	; 0xa0
}
24014f10:	bf00      	nop
24014f12:	370c      	adds	r7, #12
24014f14:	46bd      	mov	sp, r7
24014f16:	f85d 7b04 	ldr.w	r7, [sp], #4
24014f1a:	4770      	bx	lr
24014f1c:	58024400 	.word	0x58024400

24014f20 <HAL_RCCEx_CRSConfig>:
  * @brief  Start automatic synchronization for polling mode
  * @param  pInit Pointer on RCC_CRSInitTypeDef structure
  * @retval None
  */
void HAL_RCCEx_CRSConfig(RCC_CRSInitTypeDef *pInit)
{
24014f20:	b580      	push	{r7, lr}
24014f22:	b084      	sub	sp, #16
24014f24:	af00      	add	r7, sp, #0
24014f26:	6078      	str	r0, [r7, #4]
  assert_param(IS_RCC_CRS_HSI48CALIBRATION(pInit->HSI48CalibrationValue));

  /* CONFIGURATION */

  /* Before configuration, reset CRS registers to their default values*/
  __HAL_RCC_CRS_FORCE_RESET();
24014f28:	4b26      	ldr	r3, [pc, #152]	; (24014fc4 <HAL_RCCEx_CRSConfig+0xa4>)
24014f2a:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
24014f2e:	4a25      	ldr	r2, [pc, #148]	; (24014fc4 <HAL_RCCEx_CRSConfig+0xa4>)
24014f30:	f043 0302 	orr.w	r3, r3, #2
24014f34:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94
  __HAL_RCC_CRS_RELEASE_RESET();
24014f38:	4b22      	ldr	r3, [pc, #136]	; (24014fc4 <HAL_RCCEx_CRSConfig+0xa4>)
24014f3a:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
24014f3e:	4a21      	ldr	r2, [pc, #132]	; (24014fc4 <HAL_RCCEx_CRSConfig+0xa4>)
24014f40:	f023 0302 	bic.w	r3, r3, #2
24014f44:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94

  /* Set the SYNCDIV[2:0] bits according to Pre-scaler value */
  /* Set the SYNCSRC[1:0] bits according to Source value */
  /* Set the SYNCSPOL bit according to Polarity value */
  if ((HAL_GetREVID() <= REV_ID_Y) && (pInit->Source == RCC_CRS_SYNC_SOURCE_USB2))
24014f48:	f7eb fd1a 	bl	24000980 <HAL_GetREVID>
24014f4c:	4602      	mov	r2, r0
24014f4e:	f241 0303 	movw	r3, #4099	; 0x1003
24014f52:	429a      	cmp	r2, r3
24014f54:	d80b      	bhi.n	24014f6e <HAL_RCCEx_CRSConfig+0x4e>
24014f56:	687b      	ldr	r3, [r7, #4]
24014f58:	685b      	ldr	r3, [r3, #4]
24014f5a:	f1b3 5f40 	cmp.w	r3, #805306368	; 0x30000000
24014f5e:	d106      	bne.n	24014f6e <HAL_RCCEx_CRSConfig+0x4e>
  {
    /* Use Rev.Y value of USB2 */
    value = (pInit->Prescaler | RCC_CRS_SYNC_SOURCE_PIN | pInit->Polarity);
24014f60:	687b      	ldr	r3, [r7, #4]
24014f62:	681a      	ldr	r2, [r3, #0]
24014f64:	687b      	ldr	r3, [r7, #4]
24014f66:	689b      	ldr	r3, [r3, #8]
24014f68:	4313      	orrs	r3, r2
24014f6a:	60fb      	str	r3, [r7, #12]
24014f6c:	e008      	b.n	24014f80 <HAL_RCCEx_CRSConfig+0x60>
  }
  else
  {
    value = (pInit->Prescaler | pInit->Source | pInit->Polarity);
24014f6e:	687b      	ldr	r3, [r7, #4]
24014f70:	681a      	ldr	r2, [r3, #0]
24014f72:	687b      	ldr	r3, [r7, #4]
24014f74:	685b      	ldr	r3, [r3, #4]
24014f76:	431a      	orrs	r2, r3
24014f78:	687b      	ldr	r3, [r7, #4]
24014f7a:	689b      	ldr	r3, [r3, #8]
24014f7c:	4313      	orrs	r3, r2
24014f7e:	60fb      	str	r3, [r7, #12]
  }
  /* Set the RELOAD[15:0] bits according to ReloadValue value */
  value |= pInit->ReloadValue;
24014f80:	687b      	ldr	r3, [r7, #4]
24014f82:	68db      	ldr	r3, [r3, #12]
24014f84:	68fa      	ldr	r2, [r7, #12]
24014f86:	4313      	orrs	r3, r2
24014f88:	60fb      	str	r3, [r7, #12]
  /* Set the FELIM[7:0] bits according to ErrorLimitValue value */
  value |= (pInit->ErrorLimitValue << CRS_CFGR_FELIM_Pos);
24014f8a:	687b      	ldr	r3, [r7, #4]
24014f8c:	691b      	ldr	r3, [r3, #16]
24014f8e:	041b      	lsls	r3, r3, #16
24014f90:	68fa      	ldr	r2, [r7, #12]
24014f92:	4313      	orrs	r3, r2
24014f94:	60fb      	str	r3, [r7, #12]
  WRITE_REG(CRS->CFGR, value);
24014f96:	4a0c      	ldr	r2, [pc, #48]	; (24014fc8 <HAL_RCCEx_CRSConfig+0xa8>)
24014f98:	68fb      	ldr	r3, [r7, #12]
24014f9a:	6053      	str	r3, [r2, #4]

  /* Adjust HSI48 oscillator smooth trimming */
  /* Set the TRIM[5:0] bits according to RCC_CRS_HSI48CalibrationValue value */
  MODIFY_REG(CRS->CR, CRS_CR_TRIM, (pInit->HSI48CalibrationValue << CRS_CR_TRIM_Pos));
24014f9c:	4b0a      	ldr	r3, [pc, #40]	; (24014fc8 <HAL_RCCEx_CRSConfig+0xa8>)
24014f9e:	681b      	ldr	r3, [r3, #0]
24014fa0:	f423 527c 	bic.w	r2, r3, #16128	; 0x3f00
24014fa4:	687b      	ldr	r3, [r7, #4]
24014fa6:	695b      	ldr	r3, [r3, #20]
24014fa8:	021b      	lsls	r3, r3, #8
24014faa:	4907      	ldr	r1, [pc, #28]	; (24014fc8 <HAL_RCCEx_CRSConfig+0xa8>)
24014fac:	4313      	orrs	r3, r2
24014fae:	600b      	str	r3, [r1, #0]

  /* START AUTOMATIC SYNCHRONIZATION*/

  /* Enable Automatic trimming & Frequency error counter */
  SET_BIT(CRS->CR, CRS_CR_AUTOTRIMEN | CRS_CR_CEN);
24014fb0:	4b05      	ldr	r3, [pc, #20]	; (24014fc8 <HAL_RCCEx_CRSConfig+0xa8>)
24014fb2:	681b      	ldr	r3, [r3, #0]
24014fb4:	4a04      	ldr	r2, [pc, #16]	; (24014fc8 <HAL_RCCEx_CRSConfig+0xa8>)
24014fb6:	f043 0360 	orr.w	r3, r3, #96	; 0x60
24014fba:	6013      	str	r3, [r2, #0]
}
24014fbc:	bf00      	nop
24014fbe:	3710      	adds	r7, #16
24014fc0:	46bd      	mov	sp, r7
24014fc2:	bd80      	pop	{r7, pc}
24014fc4:	58024400 	.word	0x58024400
24014fc8:	40008400 	.word	0x40008400

24014fcc <HAL_RCCEx_CRSSoftwareSynchronizationGenerate>:
/**
  * @brief  Generate the software synchronization event
  * @retval None
  */
void HAL_RCCEx_CRSSoftwareSynchronizationGenerate(void)
{
24014fcc:	b480      	push	{r7}
24014fce:	af00      	add	r7, sp, #0
  SET_BIT(CRS->CR, CRS_CR_SWSYNC);
24014fd0:	4b05      	ldr	r3, [pc, #20]	; (24014fe8 <HAL_RCCEx_CRSSoftwareSynchronizationGenerate+0x1c>)
24014fd2:	681b      	ldr	r3, [r3, #0]
24014fd4:	4a04      	ldr	r2, [pc, #16]	; (24014fe8 <HAL_RCCEx_CRSSoftwareSynchronizationGenerate+0x1c>)
24014fd6:	f043 0380 	orr.w	r3, r3, #128	; 0x80
24014fda:	6013      	str	r3, [r2, #0]
}
24014fdc:	bf00      	nop
24014fde:	46bd      	mov	sp, r7
24014fe0:	f85d 7b04 	ldr.w	r7, [sp], #4
24014fe4:	4770      	bx	lr
24014fe6:	bf00      	nop
24014fe8:	40008400 	.word	0x40008400

24014fec <HAL_RCCEx_CRSGetSynchronizationInfo>:
  * @brief  Return synchronization info
  * @param  pSynchroInfo Pointer on RCC_CRSSynchroInfoTypeDef structure
  * @retval None
  */
void HAL_RCCEx_CRSGetSynchronizationInfo(RCC_CRSSynchroInfoTypeDef *pSynchroInfo)
{
24014fec:	b480      	push	{r7}
24014fee:	b083      	sub	sp, #12
24014ff0:	af00      	add	r7, sp, #0
24014ff2:	6078      	str	r0, [r7, #4]
  /* Check the parameter */
  assert_param(pSynchroInfo != (void *)NULL);

  /* Get the reload value */
  pSynchroInfo->ReloadValue = (uint32_t)(READ_BIT(CRS->CFGR, CRS_CFGR_RELOAD));
24014ff4:	4b0e      	ldr	r3, [pc, #56]	; (24015030 <HAL_RCCEx_CRSGetSynchronizationInfo+0x44>)
24014ff6:	685b      	ldr	r3, [r3, #4]
24014ff8:	b29a      	uxth	r2, r3
24014ffa:	687b      	ldr	r3, [r7, #4]
24014ffc:	601a      	str	r2, [r3, #0]

  /* Get HSI48 oscillator smooth trimming */
  pSynchroInfo->HSI48CalibrationValue = (uint32_t)(READ_BIT(CRS->CR, CRS_CR_TRIM) >> CRS_CR_TRIM_Pos);
24014ffe:	4b0c      	ldr	r3, [pc, #48]	; (24015030 <HAL_RCCEx_CRSGetSynchronizationInfo+0x44>)
24015000:	681b      	ldr	r3, [r3, #0]
24015002:	0a1b      	lsrs	r3, r3, #8
24015004:	f003 023f 	and.w	r2, r3, #63	; 0x3f
24015008:	687b      	ldr	r3, [r7, #4]
2401500a:	605a      	str	r2, [r3, #4]

  /* Get Frequency error capture */
  pSynchroInfo->FreqErrorCapture = (uint32_t)(READ_BIT(CRS->ISR, CRS_ISR_FECAP) >> CRS_ISR_FECAP_Pos);
2401500c:	4b08      	ldr	r3, [pc, #32]	; (24015030 <HAL_RCCEx_CRSGetSynchronizationInfo+0x44>)
2401500e:	689b      	ldr	r3, [r3, #8]
24015010:	0c1b      	lsrs	r3, r3, #16
24015012:	b29a      	uxth	r2, r3
24015014:	687b      	ldr	r3, [r7, #4]
24015016:	609a      	str	r2, [r3, #8]

  /* Get Frequency error direction */
  pSynchroInfo->FreqErrorDirection = (uint32_t)(READ_BIT(CRS->ISR, CRS_ISR_FEDIR));
24015018:	4b05      	ldr	r3, [pc, #20]	; (24015030 <HAL_RCCEx_CRSGetSynchronizationInfo+0x44>)
2401501a:	689b      	ldr	r3, [r3, #8]
2401501c:	f403 4200 	and.w	r2, r3, #32768	; 0x8000
24015020:	687b      	ldr	r3, [r7, #4]
24015022:	60da      	str	r2, [r3, #12]
}
24015024:	bf00      	nop
24015026:	370c      	adds	r7, #12
24015028:	46bd      	mov	sp, r7
2401502a:	f85d 7b04 	ldr.w	r7, [sp], #4
2401502e:	4770      	bx	lr
24015030:	40008400 	.word	0x40008400

24015034 <HAL_RCCEx_CRSWaitSynchronization>:
*            @arg @ref RCC_CRS_SYNCERR
*            @arg @ref RCC_CRS_SYNCMISS
*            @arg @ref RCC_CRS_TRIMOVF
*/
uint32_t HAL_RCCEx_CRSWaitSynchronization(uint32_t Timeout)
{
24015034:	b580      	push	{r7, lr}
24015036:	b084      	sub	sp, #16
24015038:	af00      	add	r7, sp, #0
2401503a:	6078      	str	r0, [r7, #4]
  uint32_t crsstatus = RCC_CRS_NONE;
2401503c:	2300      	movs	r3, #0
2401503e:	60fb      	str	r3, [r7, #12]
  uint32_t tickstart;

  /* Get time-out */
  tickstart = HAL_GetTick();
24015040:	f7eb fc06 	bl	24000850 <HAL_GetTick>
24015044:	60b8      	str	r0, [r7, #8]

  /* Wait for CRS flag or time-out detection */
  do
  {
    if(Timeout != HAL_MAX_DELAY)
24015046:	687b      	ldr	r3, [r7, #4]
24015048:	f1b3 3fff 	cmp.w	r3, #4294967295
2401504c:	d00c      	beq.n	24015068 <HAL_RCCEx_CRSWaitSynchronization+0x34>
    {
      if(((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
2401504e:	f7eb fbff 	bl	24000850 <HAL_GetTick>
24015052:	4602      	mov	r2, r0
24015054:	68bb      	ldr	r3, [r7, #8]
24015056:	1ad3      	subs	r3, r2, r3
24015058:	687a      	ldr	r2, [r7, #4]
2401505a:	429a      	cmp	r2, r3
2401505c:	d302      	bcc.n	24015064 <HAL_RCCEx_CRSWaitSynchronization+0x30>
2401505e:	687b      	ldr	r3, [r7, #4]
24015060:	2b00      	cmp	r3, #0
24015062:	d101      	bne.n	24015068 <HAL_RCCEx_CRSWaitSynchronization+0x34>
      {
        crsstatus = RCC_CRS_TIMEOUT;
24015064:	2301      	movs	r3, #1
24015066:	60fb      	str	r3, [r7, #12]
      }
    }
    /* Check CRS SYNCOK flag  */
    if(__HAL_RCC_CRS_GET_FLAG(RCC_CRS_FLAG_SYNCOK))
24015068:	4b2a      	ldr	r3, [pc, #168]	; (24015114 <HAL_RCCEx_CRSWaitSynchronization+0xe0>)
2401506a:	689b      	ldr	r3, [r3, #8]
2401506c:	f003 0301 	and.w	r3, r3, #1
24015070:	2b01      	cmp	r3, #1
24015072:	d106      	bne.n	24015082 <HAL_RCCEx_CRSWaitSynchronization+0x4e>
    {
      /* CRS SYNC event OK */
      crsstatus |= RCC_CRS_SYNCOK;
24015074:	68fb      	ldr	r3, [r7, #12]
24015076:	f043 0302 	orr.w	r3, r3, #2
2401507a:	60fb      	str	r3, [r7, #12]

      /* Clear CRS SYNC event OK bit */
      __HAL_RCC_CRS_CLEAR_FLAG(RCC_CRS_FLAG_SYNCOK);
2401507c:	4b25      	ldr	r3, [pc, #148]	; (24015114 <HAL_RCCEx_CRSWaitSynchronization+0xe0>)
2401507e:	2201      	movs	r2, #1
24015080:	60da      	str	r2, [r3, #12]
    }

    /* Check CRS SYNCWARN flag  */
    if(__HAL_RCC_CRS_GET_FLAG(RCC_CRS_FLAG_SYNCWARN))
24015082:	4b24      	ldr	r3, [pc, #144]	; (24015114 <HAL_RCCEx_CRSWaitSynchronization+0xe0>)
24015084:	689b      	ldr	r3, [r3, #8]
24015086:	f003 0302 	and.w	r3, r3, #2
2401508a:	2b02      	cmp	r3, #2
2401508c:	d106      	bne.n	2401509c <HAL_RCCEx_CRSWaitSynchronization+0x68>
    {
      /* CRS SYNC warning */
      crsstatus |= RCC_CRS_SYNCWARN;
2401508e:	68fb      	ldr	r3, [r7, #12]
24015090:	f043 0304 	orr.w	r3, r3, #4
24015094:	60fb      	str	r3, [r7, #12]

      /* Clear CRS SYNCWARN bit */
      __HAL_RCC_CRS_CLEAR_FLAG(RCC_CRS_FLAG_SYNCWARN);
24015096:	4b1f      	ldr	r3, [pc, #124]	; (24015114 <HAL_RCCEx_CRSWaitSynchronization+0xe0>)
24015098:	2202      	movs	r2, #2
2401509a:	60da      	str	r2, [r3, #12]
    }

    /* Check CRS TRIM overflow flag  */
    if(__HAL_RCC_CRS_GET_FLAG(RCC_CRS_FLAG_TRIMOVF))
2401509c:	4b1d      	ldr	r3, [pc, #116]	; (24015114 <HAL_RCCEx_CRSWaitSynchronization+0xe0>)
2401509e:	689b      	ldr	r3, [r3, #8]
240150a0:	f403 6380 	and.w	r3, r3, #1024	; 0x400
240150a4:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
240150a8:	d106      	bne.n	240150b8 <HAL_RCCEx_CRSWaitSynchronization+0x84>
    {
      /* CRS SYNC Error */
      crsstatus |= RCC_CRS_TRIMOVF;
240150aa:	68fb      	ldr	r3, [r7, #12]
240150ac:	f043 0320 	orr.w	r3, r3, #32
240150b0:	60fb      	str	r3, [r7, #12]

      /* Clear CRS Error bit */
      __HAL_RCC_CRS_CLEAR_FLAG(RCC_CRS_FLAG_TRIMOVF);
240150b2:	4b18      	ldr	r3, [pc, #96]	; (24015114 <HAL_RCCEx_CRSWaitSynchronization+0xe0>)
240150b4:	2204      	movs	r2, #4
240150b6:	60da      	str	r2, [r3, #12]
    }

    /* Check CRS Error flag  */
    if(__HAL_RCC_CRS_GET_FLAG(RCC_CRS_FLAG_SYNCERR))
240150b8:	4b16      	ldr	r3, [pc, #88]	; (24015114 <HAL_RCCEx_CRSWaitSynchronization+0xe0>)
240150ba:	689b      	ldr	r3, [r3, #8]
240150bc:	f403 7380 	and.w	r3, r3, #256	; 0x100
240150c0:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
240150c4:	d106      	bne.n	240150d4 <HAL_RCCEx_CRSWaitSynchronization+0xa0>
    {
      /* CRS SYNC Error */
      crsstatus |= RCC_CRS_SYNCERR;
240150c6:	68fb      	ldr	r3, [r7, #12]
240150c8:	f043 0308 	orr.w	r3, r3, #8
240150cc:	60fb      	str	r3, [r7, #12]

      /* Clear CRS Error bit */
      __HAL_RCC_CRS_CLEAR_FLAG(RCC_CRS_FLAG_SYNCERR);
240150ce:	4b11      	ldr	r3, [pc, #68]	; (24015114 <HAL_RCCEx_CRSWaitSynchronization+0xe0>)
240150d0:	2204      	movs	r2, #4
240150d2:	60da      	str	r2, [r3, #12]
    }

    /* Check CRS SYNC Missed flag  */
    if(__HAL_RCC_CRS_GET_FLAG(RCC_CRS_FLAG_SYNCMISS))
240150d4:	4b0f      	ldr	r3, [pc, #60]	; (24015114 <HAL_RCCEx_CRSWaitSynchronization+0xe0>)
240150d6:	689b      	ldr	r3, [r3, #8]
240150d8:	f403 7300 	and.w	r3, r3, #512	; 0x200
240150dc:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
240150e0:	d106      	bne.n	240150f0 <HAL_RCCEx_CRSWaitSynchronization+0xbc>
    {
      /* CRS SYNC Missed */
      crsstatus |= RCC_CRS_SYNCMISS;
240150e2:	68fb      	ldr	r3, [r7, #12]
240150e4:	f043 0310 	orr.w	r3, r3, #16
240150e8:	60fb      	str	r3, [r7, #12]

      /* Clear CRS SYNC Missed bit */
      __HAL_RCC_CRS_CLEAR_FLAG(RCC_CRS_FLAG_SYNCMISS);
240150ea:	4b0a      	ldr	r3, [pc, #40]	; (24015114 <HAL_RCCEx_CRSWaitSynchronization+0xe0>)
240150ec:	2204      	movs	r2, #4
240150ee:	60da      	str	r2, [r3, #12]
    }

    /* Check CRS Expected SYNC flag  */
    if(__HAL_RCC_CRS_GET_FLAG(RCC_CRS_FLAG_ESYNC))
240150f0:	4b08      	ldr	r3, [pc, #32]	; (24015114 <HAL_RCCEx_CRSWaitSynchronization+0xe0>)
240150f2:	689b      	ldr	r3, [r3, #8]
240150f4:	f003 0308 	and.w	r3, r3, #8
240150f8:	2b08      	cmp	r3, #8
240150fa:	d102      	bne.n	24015102 <HAL_RCCEx_CRSWaitSynchronization+0xce>
    {
      /* frequency error counter reached a zero value */
      __HAL_RCC_CRS_CLEAR_FLAG(RCC_CRS_FLAG_ESYNC);
240150fc:	4b05      	ldr	r3, [pc, #20]	; (24015114 <HAL_RCCEx_CRSWaitSynchronization+0xe0>)
240150fe:	2208      	movs	r2, #8
24015100:	60da      	str	r2, [r3, #12]
    }
  } while(RCC_CRS_NONE == crsstatus);
24015102:	68fb      	ldr	r3, [r7, #12]
24015104:	2b00      	cmp	r3, #0
24015106:	d09e      	beq.n	24015046 <HAL_RCCEx_CRSWaitSynchronization+0x12>

  return crsstatus;
24015108:	68fb      	ldr	r3, [r7, #12]
}
2401510a:	4618      	mov	r0, r3
2401510c:	3710      	adds	r7, #16
2401510e:	46bd      	mov	sp, r7
24015110:	bd80      	pop	{r7, pc}
24015112:	bf00      	nop
24015114:	40008400 	.word	0x40008400

24015118 <HAL_RCCEx_CRS_IRQHandler>:
/**
  * @brief Handle the Clock Recovery System interrupt request.
  * @retval None
  */
void HAL_RCCEx_CRS_IRQHandler(void)
{
24015118:	b580      	push	{r7, lr}
2401511a:	b084      	sub	sp, #16
2401511c:	af00      	add	r7, sp, #0
  uint32_t crserror = RCC_CRS_NONE;
2401511e:	2300      	movs	r3, #0
24015120:	60fb      	str	r3, [r7, #12]
  /* Get current IT flags and IT sources values */
  uint32_t itflags = READ_REG(CRS->ISR);
24015122:	4b33      	ldr	r3, [pc, #204]	; (240151f0 <HAL_RCCEx_CRS_IRQHandler+0xd8>)
24015124:	689b      	ldr	r3, [r3, #8]
24015126:	60bb      	str	r3, [r7, #8]
  uint32_t itsources = READ_REG(CRS->CR);
24015128:	4b31      	ldr	r3, [pc, #196]	; (240151f0 <HAL_RCCEx_CRS_IRQHandler+0xd8>)
2401512a:	681b      	ldr	r3, [r3, #0]
2401512c:	607b      	str	r3, [r7, #4]

  /* Check CRS SYNCOK flag  */
  if(((itflags & RCC_CRS_FLAG_SYNCOK) != 0U) && ((itsources & RCC_CRS_IT_SYNCOK) != 0U))
2401512e:	68bb      	ldr	r3, [r7, #8]
24015130:	f003 0301 	and.w	r3, r3, #1
24015134:	2b00      	cmp	r3, #0
24015136:	d00a      	beq.n	2401514e <HAL_RCCEx_CRS_IRQHandler+0x36>
24015138:	687b      	ldr	r3, [r7, #4]
2401513a:	f003 0301 	and.w	r3, r3, #1
2401513e:	2b00      	cmp	r3, #0
24015140:	d005      	beq.n	2401514e <HAL_RCCEx_CRS_IRQHandler+0x36>
  {
    /* Clear CRS SYNC event OK flag */
    WRITE_REG(CRS->ICR, CRS_ICR_SYNCOKC);
24015142:	4b2b      	ldr	r3, [pc, #172]	; (240151f0 <HAL_RCCEx_CRS_IRQHandler+0xd8>)
24015144:	2201      	movs	r2, #1
24015146:	60da      	str	r2, [r3, #12]

    /* user callback */
    HAL_RCCEx_CRS_SyncOkCallback();
24015148:	f000 f854 	bl	240151f4 <HAL_RCCEx_CRS_SyncOkCallback>
2401514c:	e04b      	b.n	240151e6 <HAL_RCCEx_CRS_IRQHandler+0xce>
  }
  /* Check CRS SYNCWARN flag  */
  else if(((itflags & RCC_CRS_FLAG_SYNCWARN) != 0U) && ((itsources & RCC_CRS_IT_SYNCWARN) != 0U))
2401514e:	68bb      	ldr	r3, [r7, #8]
24015150:	f003 0302 	and.w	r3, r3, #2
24015154:	2b00      	cmp	r3, #0
24015156:	d00a      	beq.n	2401516e <HAL_RCCEx_CRS_IRQHandler+0x56>
24015158:	687b      	ldr	r3, [r7, #4]
2401515a:	f003 0302 	and.w	r3, r3, #2
2401515e:	2b00      	cmp	r3, #0
24015160:	d005      	beq.n	2401516e <HAL_RCCEx_CRS_IRQHandler+0x56>
  {
    /* Clear CRS SYNCWARN flag */
    WRITE_REG(CRS->ICR, CRS_ICR_SYNCWARNC);
24015162:	4b23      	ldr	r3, [pc, #140]	; (240151f0 <HAL_RCCEx_CRS_IRQHandler+0xd8>)
24015164:	2202      	movs	r2, #2
24015166:	60da      	str	r2, [r3, #12]

    /* user callback */
    HAL_RCCEx_CRS_SyncWarnCallback();
24015168:	f000 f84b 	bl	24015202 <HAL_RCCEx_CRS_SyncWarnCallback>
2401516c:	e03b      	b.n	240151e6 <HAL_RCCEx_CRS_IRQHandler+0xce>
  }
  /* Check CRS Expected SYNC flag  */
  else if(((itflags & RCC_CRS_FLAG_ESYNC) != 0U) && ((itsources & RCC_CRS_IT_ESYNC) != 0U))
2401516e:	68bb      	ldr	r3, [r7, #8]
24015170:	f003 0308 	and.w	r3, r3, #8
24015174:	2b00      	cmp	r3, #0
24015176:	d00a      	beq.n	2401518e <HAL_RCCEx_CRS_IRQHandler+0x76>
24015178:	687b      	ldr	r3, [r7, #4]
2401517a:	f003 0308 	and.w	r3, r3, #8
2401517e:	2b00      	cmp	r3, #0
24015180:	d005      	beq.n	2401518e <HAL_RCCEx_CRS_IRQHandler+0x76>
  {
    /* frequency error counter reached a zero value */
    WRITE_REG(CRS->ICR, CRS_ICR_ESYNCC);
24015182:	4b1b      	ldr	r3, [pc, #108]	; (240151f0 <HAL_RCCEx_CRS_IRQHandler+0xd8>)
24015184:	2208      	movs	r2, #8
24015186:	60da      	str	r2, [r3, #12]

    /* user callback */
    HAL_RCCEx_CRS_ExpectedSyncCallback();
24015188:	f000 f842 	bl	24015210 <HAL_RCCEx_CRS_ExpectedSyncCallback>
2401518c:	e02b      	b.n	240151e6 <HAL_RCCEx_CRS_IRQHandler+0xce>
  }
  /* Check CRS Error flags  */
  else
  {
    if(((itflags & RCC_CRS_FLAG_ERR) != 0U) && ((itsources & RCC_CRS_IT_ERR) != 0U))
2401518e:	68bb      	ldr	r3, [r7, #8]
24015190:	f003 0304 	and.w	r3, r3, #4
24015194:	2b00      	cmp	r3, #0
24015196:	d026      	beq.n	240151e6 <HAL_RCCEx_CRS_IRQHandler+0xce>
24015198:	687b      	ldr	r3, [r7, #4]
2401519a:	f003 0304 	and.w	r3, r3, #4
2401519e:	2b00      	cmp	r3, #0
240151a0:	d021      	beq.n	240151e6 <HAL_RCCEx_CRS_IRQHandler+0xce>
    {
      if((itflags & RCC_CRS_FLAG_SYNCERR) != 0U)
240151a2:	68bb      	ldr	r3, [r7, #8]
240151a4:	f403 7380 	and.w	r3, r3, #256	; 0x100
240151a8:	2b00      	cmp	r3, #0
240151aa:	d003      	beq.n	240151b4 <HAL_RCCEx_CRS_IRQHandler+0x9c>
      {
        crserror |= RCC_CRS_SYNCERR;
240151ac:	68fb      	ldr	r3, [r7, #12]
240151ae:	f043 0308 	orr.w	r3, r3, #8
240151b2:	60fb      	str	r3, [r7, #12]
      }
      if((itflags & RCC_CRS_FLAG_SYNCMISS) != 0U)
240151b4:	68bb      	ldr	r3, [r7, #8]
240151b6:	f403 7300 	and.w	r3, r3, #512	; 0x200
240151ba:	2b00      	cmp	r3, #0
240151bc:	d003      	beq.n	240151c6 <HAL_RCCEx_CRS_IRQHandler+0xae>
      {
        crserror |= RCC_CRS_SYNCMISS;
240151be:	68fb      	ldr	r3, [r7, #12]
240151c0:	f043 0310 	orr.w	r3, r3, #16
240151c4:	60fb      	str	r3, [r7, #12]
      }
      if((itflags & RCC_CRS_FLAG_TRIMOVF) != 0U)
240151c6:	68bb      	ldr	r3, [r7, #8]
240151c8:	f403 6380 	and.w	r3, r3, #1024	; 0x400
240151cc:	2b00      	cmp	r3, #0
240151ce:	d003      	beq.n	240151d8 <HAL_RCCEx_CRS_IRQHandler+0xc0>
      {
        crserror |= RCC_CRS_TRIMOVF;
240151d0:	68fb      	ldr	r3, [r7, #12]
240151d2:	f043 0320 	orr.w	r3, r3, #32
240151d6:	60fb      	str	r3, [r7, #12]
      }

      /* Clear CRS Error flags */
      WRITE_REG(CRS->ICR, CRS_ICR_ERRC);
240151d8:	4b05      	ldr	r3, [pc, #20]	; (240151f0 <HAL_RCCEx_CRS_IRQHandler+0xd8>)
240151da:	2204      	movs	r2, #4
240151dc:	60da      	str	r2, [r3, #12]

      /* user error callback */
      HAL_RCCEx_CRS_ErrorCallback(crserror);
240151de:	68f8      	ldr	r0, [r7, #12]
240151e0:	f000 f81d 	bl	2401521e <HAL_RCCEx_CRS_ErrorCallback>
    }
  }
}
240151e4:	e7ff      	b.n	240151e6 <HAL_RCCEx_CRS_IRQHandler+0xce>
240151e6:	bf00      	nop
240151e8:	3710      	adds	r7, #16
240151ea:	46bd      	mov	sp, r7
240151ec:	bd80      	pop	{r7, pc}
240151ee:	bf00      	nop
240151f0:	40008400 	.word	0x40008400

240151f4 <HAL_RCCEx_CRS_SyncOkCallback>:
/**
  * @brief  RCCEx Clock Recovery System SYNCOK interrupt callback.
  * @retval none
  */
__weak void HAL_RCCEx_CRS_SyncOkCallback(void)
{
240151f4:	b480      	push	{r7}
240151f6:	af00      	add	r7, sp, #0
  /* NOTE : This function should not be modified, when the callback is needed,
            the @ref HAL_RCCEx_CRS_SyncOkCallback should be implemented in the user file
   */
}
240151f8:	bf00      	nop
240151fa:	46bd      	mov	sp, r7
240151fc:	f85d 7b04 	ldr.w	r7, [sp], #4
24015200:	4770      	bx	lr

24015202 <HAL_RCCEx_CRS_SyncWarnCallback>:
/**
  * @brief  RCCEx Clock Recovery System SYNCWARN interrupt callback.
  * @retval none
  */
__weak void HAL_RCCEx_CRS_SyncWarnCallback(void)
{
24015202:	b480      	push	{r7}
24015204:	af00      	add	r7, sp, #0
  /* NOTE : This function should not be modified, when the callback is needed,
            the @ref HAL_RCCEx_CRS_SyncWarnCallback should be implemented in the user file
   */
}
24015206:	bf00      	nop
24015208:	46bd      	mov	sp, r7
2401520a:	f85d 7b04 	ldr.w	r7, [sp], #4
2401520e:	4770      	bx	lr

24015210 <HAL_RCCEx_CRS_ExpectedSyncCallback>:
/**
  * @brief  RCCEx Clock Recovery System Expected SYNC interrupt callback.
  * @retval none
  */
__weak void HAL_RCCEx_CRS_ExpectedSyncCallback(void)
{
24015210:	b480      	push	{r7}
24015212:	af00      	add	r7, sp, #0
  /* NOTE : This function should not be modified, when the callback is needed,
            the @ref HAL_RCCEx_CRS_ExpectedSyncCallback should be implemented in the user file
   */
}
24015214:	bf00      	nop
24015216:	46bd      	mov	sp, r7
24015218:	f85d 7b04 	ldr.w	r7, [sp], #4
2401521c:	4770      	bx	lr

2401521e <HAL_RCCEx_CRS_ErrorCallback>:
  *           @arg @ref RCC_CRS_SYNCMISS
  *           @arg @ref RCC_CRS_TRIMOVF
  * @retval none
  */
__weak void HAL_RCCEx_CRS_ErrorCallback(uint32_t Error)
{
2401521e:	b480      	push	{r7}
24015220:	b083      	sub	sp, #12
24015222:	af00      	add	r7, sp, #0
24015224:	6078      	str	r0, [r7, #4]
  UNUSED(Error);

  /* NOTE : This function should not be modified, when the callback is needed,
            the @ref HAL_RCCEx_CRS_ErrorCallback should be implemented in the user file
   */
}
24015226:	bf00      	nop
24015228:	370c      	adds	r7, #12
2401522a:	46bd      	mov	sp, r7
2401522c:	f85d 7b04 	ldr.w	r7, [sp], #4
24015230:	4770      	bx	lr
	...

24015234 <RCCEx_PLL2_Config>:
  * @note   PLL2 is temporary disabled to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLL2_Config(RCC_PLL2InitTypeDef *pll2, uint32_t Divider)
{
24015234:	b580      	push	{r7, lr}
24015236:	b084      	sub	sp, #16
24015238:	af00      	add	r7, sp, #0
2401523a:	6078      	str	r0, [r7, #4]
2401523c:	6039      	str	r1, [r7, #0]

  uint32_t tickstart;
  HAL_StatusTypeDef status = HAL_OK;
2401523e:	2300      	movs	r3, #0
24015240:	73fb      	strb	r3, [r7, #15]
  assert_param(IS_RCC_PLL2RGE_VALUE(pll2->PLL2RGE));
  assert_param(IS_RCC_PLL2VCO_VALUE(pll2->PLL2VCOSEL));
  assert_param(IS_RCC_PLLFRACN_VALUE(pll2->PLL2FRACN));

  /* Check that PLL2 OSC clock source is already set */
  if(__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_NONE)
24015242:	4b53      	ldr	r3, [pc, #332]	; (24015390 <RCCEx_PLL2_Config+0x15c>)
24015244:	6a9b      	ldr	r3, [r3, #40]	; 0x28
24015246:	f003 0303 	and.w	r3, r3, #3
2401524a:	2b03      	cmp	r3, #3
2401524c:	d101      	bne.n	24015252 <RCCEx_PLL2_Config+0x1e>
  {
    return HAL_ERROR;
2401524e:	2301      	movs	r3, #1
24015250:	e099      	b.n	24015386 <RCCEx_PLL2_Config+0x152>


  else
  {
    /* Disable  PLL2. */
    __HAL_RCC_PLL2_DISABLE();
24015252:	4b4f      	ldr	r3, [pc, #316]	; (24015390 <RCCEx_PLL2_Config+0x15c>)
24015254:	681b      	ldr	r3, [r3, #0]
24015256:	4a4e      	ldr	r2, [pc, #312]	; (24015390 <RCCEx_PLL2_Config+0x15c>)
24015258:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
2401525c:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
2401525e:	f7eb faf7 	bl	24000850 <HAL_GetTick>
24015262:	60b8      	str	r0, [r7, #8]

    /* Wait till PLL is disabled */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) != 0U)
24015264:	e008      	b.n	24015278 <RCCEx_PLL2_Config+0x44>
    {
      if( (HAL_GetTick() - tickstart ) > PLL2_TIMEOUT_VALUE)
24015266:	f7eb faf3 	bl	24000850 <HAL_GetTick>
2401526a:	4602      	mov	r2, r0
2401526c:	68bb      	ldr	r3, [r7, #8]
2401526e:	1ad3      	subs	r3, r2, r3
24015270:	2b02      	cmp	r3, #2
24015272:	d901      	bls.n	24015278 <RCCEx_PLL2_Config+0x44>
      {
        return HAL_TIMEOUT;
24015274:	2303      	movs	r3, #3
24015276:	e086      	b.n	24015386 <RCCEx_PLL2_Config+0x152>
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) != 0U)
24015278:	4b45      	ldr	r3, [pc, #276]	; (24015390 <RCCEx_PLL2_Config+0x15c>)
2401527a:	681b      	ldr	r3, [r3, #0]
2401527c:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
24015280:	2b00      	cmp	r3, #0
24015282:	d1f0      	bne.n	24015266 <RCCEx_PLL2_Config+0x32>
      }
    }

    /* Configure PLL2 multiplication and division factors. */
    __HAL_RCC_PLL2_CONFIG(pll2->PLL2M,
24015284:	4b42      	ldr	r3, [pc, #264]	; (24015390 <RCCEx_PLL2_Config+0x15c>)
24015286:	6a9b      	ldr	r3, [r3, #40]	; 0x28
24015288:	f423 327c 	bic.w	r2, r3, #258048	; 0x3f000
2401528c:	687b      	ldr	r3, [r7, #4]
2401528e:	681b      	ldr	r3, [r3, #0]
24015290:	031b      	lsls	r3, r3, #12
24015292:	493f      	ldr	r1, [pc, #252]	; (24015390 <RCCEx_PLL2_Config+0x15c>)
24015294:	4313      	orrs	r3, r2
24015296:	628b      	str	r3, [r1, #40]	; 0x28
24015298:	687b      	ldr	r3, [r7, #4]
2401529a:	685b      	ldr	r3, [r3, #4]
2401529c:	3b01      	subs	r3, #1
2401529e:	f3c3 0208 	ubfx	r2, r3, #0, #9
240152a2:	687b      	ldr	r3, [r7, #4]
240152a4:	689b      	ldr	r3, [r3, #8]
240152a6:	3b01      	subs	r3, #1
240152a8:	025b      	lsls	r3, r3, #9
240152aa:	b29b      	uxth	r3, r3
240152ac:	431a      	orrs	r2, r3
240152ae:	687b      	ldr	r3, [r7, #4]
240152b0:	68db      	ldr	r3, [r3, #12]
240152b2:	3b01      	subs	r3, #1
240152b4:	041b      	lsls	r3, r3, #16
240152b6:	f403 03fe 	and.w	r3, r3, #8323072	; 0x7f0000
240152ba:	431a      	orrs	r2, r3
240152bc:	687b      	ldr	r3, [r7, #4]
240152be:	691b      	ldr	r3, [r3, #16]
240152c0:	3b01      	subs	r3, #1
240152c2:	061b      	lsls	r3, r3, #24
240152c4:	f003 43fe 	and.w	r3, r3, #2130706432	; 0x7f000000
240152c8:	4931      	ldr	r1, [pc, #196]	; (24015390 <RCCEx_PLL2_Config+0x15c>)
240152ca:	4313      	orrs	r3, r2
240152cc:	638b      	str	r3, [r1, #56]	; 0x38
                          pll2->PLL2P,
                          pll2->PLL2Q,
                          pll2->PLL2R);

    /* Select PLL2 input reference frequency range: VCI */
    __HAL_RCC_PLL2_VCIRANGE(pll2->PLL2RGE) ;
240152ce:	4b30      	ldr	r3, [pc, #192]	; (24015390 <RCCEx_PLL2_Config+0x15c>)
240152d0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
240152d2:	f023 02c0 	bic.w	r2, r3, #192	; 0xc0
240152d6:	687b      	ldr	r3, [r7, #4]
240152d8:	695b      	ldr	r3, [r3, #20]
240152da:	492d      	ldr	r1, [pc, #180]	; (24015390 <RCCEx_PLL2_Config+0x15c>)
240152dc:	4313      	orrs	r3, r2
240152de:	62cb      	str	r3, [r1, #44]	; 0x2c

    /* Select PLL2 output frequency range : VCO */
    __HAL_RCC_PLL2_VCORANGE(pll2->PLL2VCOSEL) ;
240152e0:	4b2b      	ldr	r3, [pc, #172]	; (24015390 <RCCEx_PLL2_Config+0x15c>)
240152e2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
240152e4:	f023 0220 	bic.w	r2, r3, #32
240152e8:	687b      	ldr	r3, [r7, #4]
240152ea:	699b      	ldr	r3, [r3, #24]
240152ec:	4928      	ldr	r1, [pc, #160]	; (24015390 <RCCEx_PLL2_Config+0x15c>)
240152ee:	4313      	orrs	r3, r2
240152f0:	62cb      	str	r3, [r1, #44]	; 0x2c

    /* Disable PLL2FRACN . */
    __HAL_RCC_PLL2FRACN_DISABLE();
240152f2:	4b27      	ldr	r3, [pc, #156]	; (24015390 <RCCEx_PLL2_Config+0x15c>)
240152f4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
240152f6:	4a26      	ldr	r2, [pc, #152]	; (24015390 <RCCEx_PLL2_Config+0x15c>)
240152f8:	f023 0310 	bic.w	r3, r3, #16
240152fc:	62d3      	str	r3, [r2, #44]	; 0x2c

    /* Configures PLL2 clock Fractional Part Of The Multiplication Factor */
    __HAL_RCC_PLL2FRACN_CONFIG(pll2->PLL2FRACN);
240152fe:	4b24      	ldr	r3, [pc, #144]	; (24015390 <RCCEx_PLL2_Config+0x15c>)
24015300:	6bda      	ldr	r2, [r3, #60]	; 0x3c
24015302:	4b24      	ldr	r3, [pc, #144]	; (24015394 <RCCEx_PLL2_Config+0x160>)
24015304:	4013      	ands	r3, r2
24015306:	687a      	ldr	r2, [r7, #4]
24015308:	69d2      	ldr	r2, [r2, #28]
2401530a:	00d2      	lsls	r2, r2, #3
2401530c:	4920      	ldr	r1, [pc, #128]	; (24015390 <RCCEx_PLL2_Config+0x15c>)
2401530e:	4313      	orrs	r3, r2
24015310:	63cb      	str	r3, [r1, #60]	; 0x3c

    /* Enable PLL2FRACN . */
    __HAL_RCC_PLL2FRACN_ENABLE();
24015312:	4b1f      	ldr	r3, [pc, #124]	; (24015390 <RCCEx_PLL2_Config+0x15c>)
24015314:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24015316:	4a1e      	ldr	r2, [pc, #120]	; (24015390 <RCCEx_PLL2_Config+0x15c>)
24015318:	f043 0310 	orr.w	r3, r3, #16
2401531c:	62d3      	str	r3, [r2, #44]	; 0x2c

    /* Enable the PLL2 clock output */
    if(Divider == DIVIDER_P_UPDATE)
2401531e:	683b      	ldr	r3, [r7, #0]
24015320:	2b00      	cmp	r3, #0
24015322:	d106      	bne.n	24015332 <RCCEx_PLL2_Config+0xfe>
    {
      __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL2_DIVP);
24015324:	4b1a      	ldr	r3, [pc, #104]	; (24015390 <RCCEx_PLL2_Config+0x15c>)
24015326:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24015328:	4a19      	ldr	r2, [pc, #100]	; (24015390 <RCCEx_PLL2_Config+0x15c>)
2401532a:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
2401532e:	62d3      	str	r3, [r2, #44]	; 0x2c
24015330:	e00f      	b.n	24015352 <RCCEx_PLL2_Config+0x11e>
    }
    else if(Divider == DIVIDER_Q_UPDATE)
24015332:	683b      	ldr	r3, [r7, #0]
24015334:	2b01      	cmp	r3, #1
24015336:	d106      	bne.n	24015346 <RCCEx_PLL2_Config+0x112>
    {
      __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL2_DIVQ);
24015338:	4b15      	ldr	r3, [pc, #84]	; (24015390 <RCCEx_PLL2_Config+0x15c>)
2401533a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2401533c:	4a14      	ldr	r2, [pc, #80]	; (24015390 <RCCEx_PLL2_Config+0x15c>)
2401533e:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
24015342:	62d3      	str	r3, [r2, #44]	; 0x2c
24015344:	e005      	b.n	24015352 <RCCEx_PLL2_Config+0x11e>
    }
    else
    {
      __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL2_DIVR);
24015346:	4b12      	ldr	r3, [pc, #72]	; (24015390 <RCCEx_PLL2_Config+0x15c>)
24015348:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2401534a:	4a11      	ldr	r2, [pc, #68]	; (24015390 <RCCEx_PLL2_Config+0x15c>)
2401534c:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
24015350:	62d3      	str	r3, [r2, #44]	; 0x2c
    }

    /* Enable  PLL2. */
    __HAL_RCC_PLL2_ENABLE();
24015352:	4b0f      	ldr	r3, [pc, #60]	; (24015390 <RCCEx_PLL2_Config+0x15c>)
24015354:	681b      	ldr	r3, [r3, #0]
24015356:	4a0e      	ldr	r2, [pc, #56]	; (24015390 <RCCEx_PLL2_Config+0x15c>)
24015358:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
2401535c:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
2401535e:	f7eb fa77 	bl	24000850 <HAL_GetTick>
24015362:	60b8      	str	r0, [r7, #8]

    /* Wait till PLL2 is ready */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) == 0U)
24015364:	e008      	b.n	24015378 <RCCEx_PLL2_Config+0x144>
    {
      if( (HAL_GetTick() - tickstart ) > PLL2_TIMEOUT_VALUE)
24015366:	f7eb fa73 	bl	24000850 <HAL_GetTick>
2401536a:	4602      	mov	r2, r0
2401536c:	68bb      	ldr	r3, [r7, #8]
2401536e:	1ad3      	subs	r3, r2, r3
24015370:	2b02      	cmp	r3, #2
24015372:	d901      	bls.n	24015378 <RCCEx_PLL2_Config+0x144>
      {
        return HAL_TIMEOUT;
24015374:	2303      	movs	r3, #3
24015376:	e006      	b.n	24015386 <RCCEx_PLL2_Config+0x152>
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) == 0U)
24015378:	4b05      	ldr	r3, [pc, #20]	; (24015390 <RCCEx_PLL2_Config+0x15c>)
2401537a:	681b      	ldr	r3, [r3, #0]
2401537c:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
24015380:	2b00      	cmp	r3, #0
24015382:	d0f0      	beq.n	24015366 <RCCEx_PLL2_Config+0x132>
    }

  }


  return status;
24015384:	7bfb      	ldrb	r3, [r7, #15]
}
24015386:	4618      	mov	r0, r3
24015388:	3710      	adds	r7, #16
2401538a:	46bd      	mov	sp, r7
2401538c:	bd80      	pop	{r7, pc}
2401538e:	bf00      	nop
24015390:	58024400 	.word	0x58024400
24015394:	ffff0007 	.word	0xffff0007

24015398 <RCCEx_PLL3_Config>:
  * @note   PLL3 is temporary disabled to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLL3_Config(RCC_PLL3InitTypeDef *pll3, uint32_t Divider)
{
24015398:	b580      	push	{r7, lr}
2401539a:	b084      	sub	sp, #16
2401539c:	af00      	add	r7, sp, #0
2401539e:	6078      	str	r0, [r7, #4]
240153a0:	6039      	str	r1, [r7, #0]
  uint32_t tickstart;
  HAL_StatusTypeDef status = HAL_OK;
240153a2:	2300      	movs	r3, #0
240153a4:	73fb      	strb	r3, [r7, #15]
  assert_param(IS_RCC_PLL3RGE_VALUE(pll3->PLL3RGE));
  assert_param(IS_RCC_PLL3VCO_VALUE(pll3->PLL3VCOSEL));
  assert_param(IS_RCC_PLLFRACN_VALUE(pll3->PLL3FRACN));

  /* Check that PLL3 OSC clock source is already set */
  if(__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_NONE)
240153a6:	4b53      	ldr	r3, [pc, #332]	; (240154f4 <RCCEx_PLL3_Config+0x15c>)
240153a8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
240153aa:	f003 0303 	and.w	r3, r3, #3
240153ae:	2b03      	cmp	r3, #3
240153b0:	d101      	bne.n	240153b6 <RCCEx_PLL3_Config+0x1e>
  {
    return HAL_ERROR;
240153b2:	2301      	movs	r3, #1
240153b4:	e099      	b.n	240154ea <RCCEx_PLL3_Config+0x152>


  else
  {
    /* Disable  PLL3. */
    __HAL_RCC_PLL3_DISABLE();
240153b6:	4b4f      	ldr	r3, [pc, #316]	; (240154f4 <RCCEx_PLL3_Config+0x15c>)
240153b8:	681b      	ldr	r3, [r3, #0]
240153ba:	4a4e      	ldr	r2, [pc, #312]	; (240154f4 <RCCEx_PLL3_Config+0x15c>)
240153bc:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
240153c0:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
240153c2:	f7eb fa45 	bl	24000850 <HAL_GetTick>
240153c6:	60b8      	str	r0, [r7, #8]
    /* Wait till PLL3 is ready */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) != 0U)
240153c8:	e008      	b.n	240153dc <RCCEx_PLL3_Config+0x44>
    {
      if( (HAL_GetTick() - tickstart ) > PLL3_TIMEOUT_VALUE)
240153ca:	f7eb fa41 	bl	24000850 <HAL_GetTick>
240153ce:	4602      	mov	r2, r0
240153d0:	68bb      	ldr	r3, [r7, #8]
240153d2:	1ad3      	subs	r3, r2, r3
240153d4:	2b02      	cmp	r3, #2
240153d6:	d901      	bls.n	240153dc <RCCEx_PLL3_Config+0x44>
      {
        return HAL_TIMEOUT;
240153d8:	2303      	movs	r3, #3
240153da:	e086      	b.n	240154ea <RCCEx_PLL3_Config+0x152>
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) != 0U)
240153dc:	4b45      	ldr	r3, [pc, #276]	; (240154f4 <RCCEx_PLL3_Config+0x15c>)
240153de:	681b      	ldr	r3, [r3, #0]
240153e0:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
240153e4:	2b00      	cmp	r3, #0
240153e6:	d1f0      	bne.n	240153ca <RCCEx_PLL3_Config+0x32>
      }
    }

    /* Configure the PLL3  multiplication and division factors. */
    __HAL_RCC_PLL3_CONFIG(pll3->PLL3M,
240153e8:	4b42      	ldr	r3, [pc, #264]	; (240154f4 <RCCEx_PLL3_Config+0x15c>)
240153ea:	6a9b      	ldr	r3, [r3, #40]	; 0x28
240153ec:	f023 727c 	bic.w	r2, r3, #66060288	; 0x3f00000
240153f0:	687b      	ldr	r3, [r7, #4]
240153f2:	681b      	ldr	r3, [r3, #0]
240153f4:	051b      	lsls	r3, r3, #20
240153f6:	493f      	ldr	r1, [pc, #252]	; (240154f4 <RCCEx_PLL3_Config+0x15c>)
240153f8:	4313      	orrs	r3, r2
240153fa:	628b      	str	r3, [r1, #40]	; 0x28
240153fc:	687b      	ldr	r3, [r7, #4]
240153fe:	685b      	ldr	r3, [r3, #4]
24015400:	3b01      	subs	r3, #1
24015402:	f3c3 0208 	ubfx	r2, r3, #0, #9
24015406:	687b      	ldr	r3, [r7, #4]
24015408:	689b      	ldr	r3, [r3, #8]
2401540a:	3b01      	subs	r3, #1
2401540c:	025b      	lsls	r3, r3, #9
2401540e:	b29b      	uxth	r3, r3
24015410:	431a      	orrs	r2, r3
24015412:	687b      	ldr	r3, [r7, #4]
24015414:	68db      	ldr	r3, [r3, #12]
24015416:	3b01      	subs	r3, #1
24015418:	041b      	lsls	r3, r3, #16
2401541a:	f403 03fe 	and.w	r3, r3, #8323072	; 0x7f0000
2401541e:	431a      	orrs	r2, r3
24015420:	687b      	ldr	r3, [r7, #4]
24015422:	691b      	ldr	r3, [r3, #16]
24015424:	3b01      	subs	r3, #1
24015426:	061b      	lsls	r3, r3, #24
24015428:	f003 43fe 	and.w	r3, r3, #2130706432	; 0x7f000000
2401542c:	4931      	ldr	r1, [pc, #196]	; (240154f4 <RCCEx_PLL3_Config+0x15c>)
2401542e:	4313      	orrs	r3, r2
24015430:	640b      	str	r3, [r1, #64]	; 0x40
                          pll3->PLL3P,
                          pll3->PLL3Q,
                          pll3->PLL3R);

    /* Select PLL3 input reference frequency range: VCI */
    __HAL_RCC_PLL3_VCIRANGE(pll3->PLL3RGE) ;
24015432:	4b30      	ldr	r3, [pc, #192]	; (240154f4 <RCCEx_PLL3_Config+0x15c>)
24015434:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24015436:	f423 6240 	bic.w	r2, r3, #3072	; 0xc00
2401543a:	687b      	ldr	r3, [r7, #4]
2401543c:	695b      	ldr	r3, [r3, #20]
2401543e:	492d      	ldr	r1, [pc, #180]	; (240154f4 <RCCEx_PLL3_Config+0x15c>)
24015440:	4313      	orrs	r3, r2
24015442:	62cb      	str	r3, [r1, #44]	; 0x2c

    /* Select PLL3 output frequency range : VCO */
    __HAL_RCC_PLL3_VCORANGE(pll3->PLL3VCOSEL) ;
24015444:	4b2b      	ldr	r3, [pc, #172]	; (240154f4 <RCCEx_PLL3_Config+0x15c>)
24015446:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24015448:	f423 7200 	bic.w	r2, r3, #512	; 0x200
2401544c:	687b      	ldr	r3, [r7, #4]
2401544e:	699b      	ldr	r3, [r3, #24]
24015450:	4928      	ldr	r1, [pc, #160]	; (240154f4 <RCCEx_PLL3_Config+0x15c>)
24015452:	4313      	orrs	r3, r2
24015454:	62cb      	str	r3, [r1, #44]	; 0x2c

    /* Disable PLL3FRACN . */
    __HAL_RCC_PLL3FRACN_DISABLE();
24015456:	4b27      	ldr	r3, [pc, #156]	; (240154f4 <RCCEx_PLL3_Config+0x15c>)
24015458:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2401545a:	4a26      	ldr	r2, [pc, #152]	; (240154f4 <RCCEx_PLL3_Config+0x15c>)
2401545c:	f423 7380 	bic.w	r3, r3, #256	; 0x100
24015460:	62d3      	str	r3, [r2, #44]	; 0x2c

    /* Configures PLL3 clock Fractional Part Of The Multiplication Factor */
    __HAL_RCC_PLL3FRACN_CONFIG(pll3->PLL3FRACN);
24015462:	4b24      	ldr	r3, [pc, #144]	; (240154f4 <RCCEx_PLL3_Config+0x15c>)
24015464:	6c5a      	ldr	r2, [r3, #68]	; 0x44
24015466:	4b24      	ldr	r3, [pc, #144]	; (240154f8 <RCCEx_PLL3_Config+0x160>)
24015468:	4013      	ands	r3, r2
2401546a:	687a      	ldr	r2, [r7, #4]
2401546c:	69d2      	ldr	r2, [r2, #28]
2401546e:	00d2      	lsls	r2, r2, #3
24015470:	4920      	ldr	r1, [pc, #128]	; (240154f4 <RCCEx_PLL3_Config+0x15c>)
24015472:	4313      	orrs	r3, r2
24015474:	644b      	str	r3, [r1, #68]	; 0x44

    /* Enable PLL3FRACN . */
    __HAL_RCC_PLL3FRACN_ENABLE();
24015476:	4b1f      	ldr	r3, [pc, #124]	; (240154f4 <RCCEx_PLL3_Config+0x15c>)
24015478:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2401547a:	4a1e      	ldr	r2, [pc, #120]	; (240154f4 <RCCEx_PLL3_Config+0x15c>)
2401547c:	f443 7380 	orr.w	r3, r3, #256	; 0x100
24015480:	62d3      	str	r3, [r2, #44]	; 0x2c

    /* Enable the PLL3 clock output */
    if(Divider == DIVIDER_P_UPDATE)
24015482:	683b      	ldr	r3, [r7, #0]
24015484:	2b00      	cmp	r3, #0
24015486:	d106      	bne.n	24015496 <RCCEx_PLL3_Config+0xfe>
    {
      __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVP);
24015488:	4b1a      	ldr	r3, [pc, #104]	; (240154f4 <RCCEx_PLL3_Config+0x15c>)
2401548a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2401548c:	4a19      	ldr	r2, [pc, #100]	; (240154f4 <RCCEx_PLL3_Config+0x15c>)
2401548e:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
24015492:	62d3      	str	r3, [r2, #44]	; 0x2c
24015494:	e00f      	b.n	240154b6 <RCCEx_PLL3_Config+0x11e>
    }
    else if(Divider == DIVIDER_Q_UPDATE)
24015496:	683b      	ldr	r3, [r7, #0]
24015498:	2b01      	cmp	r3, #1
2401549a:	d106      	bne.n	240154aa <RCCEx_PLL3_Config+0x112>
    {
      __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVQ);
2401549c:	4b15      	ldr	r3, [pc, #84]	; (240154f4 <RCCEx_PLL3_Config+0x15c>)
2401549e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
240154a0:	4a14      	ldr	r2, [pc, #80]	; (240154f4 <RCCEx_PLL3_Config+0x15c>)
240154a2:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
240154a6:	62d3      	str	r3, [r2, #44]	; 0x2c
240154a8:	e005      	b.n	240154b6 <RCCEx_PLL3_Config+0x11e>
    }
    else
    {
      __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVR);
240154aa:	4b12      	ldr	r3, [pc, #72]	; (240154f4 <RCCEx_PLL3_Config+0x15c>)
240154ac:	6adb      	ldr	r3, [r3, #44]	; 0x2c
240154ae:	4a11      	ldr	r2, [pc, #68]	; (240154f4 <RCCEx_PLL3_Config+0x15c>)
240154b0:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
240154b4:	62d3      	str	r3, [r2, #44]	; 0x2c
    }

    /* Enable  PLL3. */
    __HAL_RCC_PLL3_ENABLE();
240154b6:	4b0f      	ldr	r3, [pc, #60]	; (240154f4 <RCCEx_PLL3_Config+0x15c>)
240154b8:	681b      	ldr	r3, [r3, #0]
240154ba:	4a0e      	ldr	r2, [pc, #56]	; (240154f4 <RCCEx_PLL3_Config+0x15c>)
240154bc:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
240154c0:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
240154c2:	f7eb f9c5 	bl	24000850 <HAL_GetTick>
240154c6:	60b8      	str	r0, [r7, #8]

    /* Wait till PLL3 is ready */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) == 0U)
240154c8:	e008      	b.n	240154dc <RCCEx_PLL3_Config+0x144>
    {
      if( (HAL_GetTick() - tickstart ) > PLL3_TIMEOUT_VALUE)
240154ca:	f7eb f9c1 	bl	24000850 <HAL_GetTick>
240154ce:	4602      	mov	r2, r0
240154d0:	68bb      	ldr	r3, [r7, #8]
240154d2:	1ad3      	subs	r3, r2, r3
240154d4:	2b02      	cmp	r3, #2
240154d6:	d901      	bls.n	240154dc <RCCEx_PLL3_Config+0x144>
      {
        return HAL_TIMEOUT;
240154d8:	2303      	movs	r3, #3
240154da:	e006      	b.n	240154ea <RCCEx_PLL3_Config+0x152>
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) == 0U)
240154dc:	4b05      	ldr	r3, [pc, #20]	; (240154f4 <RCCEx_PLL3_Config+0x15c>)
240154de:	681b      	ldr	r3, [r3, #0]
240154e0:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
240154e4:	2b00      	cmp	r3, #0
240154e6:	d0f0      	beq.n	240154ca <RCCEx_PLL3_Config+0x132>
    }

  }


  return status;
240154e8:	7bfb      	ldrb	r3, [r7, #15]
}
240154ea:	4618      	mov	r0, r3
240154ec:	3710      	adds	r7, #16
240154ee:	46bd      	mov	sp, r7
240154f0:	bd80      	pop	{r7, pc}
240154f2:	bf00      	nop
240154f4:	58024400 	.word	0x58024400
240154f8:	ffff0007 	.word	0xffff0007

240154fc <HAL_RCCEx_LSECSS_IRQHandler>:
/**
  * @brief Handle the RCC LSE Clock Security System interrupt request.
  * @retval None
  */
void HAL_RCCEx_LSECSS_IRQHandler(void)
{
240154fc:	b580      	push	{r7, lr}
240154fe:	af00      	add	r7, sp, #0
  /* Check RCC LSE CSSF flag  */
  if(__HAL_RCC_GET_IT(RCC_IT_LSECSS))
24015500:	4b07      	ldr	r3, [pc, #28]	; (24015520 <HAL_RCCEx_LSECSS_IRQHandler+0x24>)
24015502:	6e5b      	ldr	r3, [r3, #100]	; 0x64
24015504:	f403 7300 	and.w	r3, r3, #512	; 0x200
24015508:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
2401550c:	d105      	bne.n	2401551a <HAL_RCCEx_LSECSS_IRQHandler+0x1e>
  {

    /* Clear RCC LSE CSS pending bit */
    __HAL_RCC_CLEAR_IT(RCC_IT_LSECSS);
2401550e:	4b04      	ldr	r3, [pc, #16]	; (24015520 <HAL_RCCEx_LSECSS_IRQHandler+0x24>)
24015510:	f44f 7200 	mov.w	r2, #512	; 0x200
24015514:	669a      	str	r2, [r3, #104]	; 0x68

    /* RCC LSE Clock Security System interrupt user callback */
    HAL_RCCEx_LSECSS_Callback();
24015516:	f000 f805 	bl	24015524 <HAL_RCCEx_LSECSS_Callback>

  }
}
2401551a:	bf00      	nop
2401551c:	bd80      	pop	{r7, pc}
2401551e:	bf00      	nop
24015520:	58024400 	.word	0x58024400

24015524 <HAL_RCCEx_LSECSS_Callback>:
/**
  * @brief  RCCEx LSE Clock Security System interrupt callback.
  * @retval none
  */
__weak void HAL_RCCEx_LSECSS_Callback(void)
{
24015524:	b480      	push	{r7}
24015526:	af00      	add	r7, sp, #0
  /* NOTE : This function should not be modified, when the callback is needed,
            the @ref HAL_RCCEx_LSECSS_Callback should be implemented in the user file
   */
}
24015528:	bf00      	nop
2401552a:	46bd      	mov	sp, r7
2401552c:	f85d 7b04 	ldr.w	r7, [sp], #4
24015530:	4770      	bx	lr
	...

24015534 <Init>:
 * @param  None
 * @retval  LOADER_OK = 1   : Operation succeeded
 * @retval  LOADER_FAIL = 0 : Operation failed
 */
int Init(uint8_t configureMemoryMappedMode)
{
24015534:	b580      	push	{r7, lr}
24015536:	b086      	sub	sp, #24
24015538:	af00      	add	r7, sp, #0
2401553a:	4603      	mov	r3, r0
2401553c:	71fb      	strb	r3, [r7, #7]

    *(uint32_t*)0xE000EDF0 = 0xA05F0000; //enable interrupts in debug
2401553e:	4b21      	ldr	r3, [pc, #132]	; (240155c4 <Init+0x90>)
24015540:	4a21      	ldr	r2, [pc, #132]	; (240155c8 <Init+0x94>)
24015542:	601a      	str	r2, [r3, #0]


    SystemInit();
24015544:	f001 f98e 	bl	24016864 <SystemInit>
     * change VTOR setting for other devices
     * SCB->VTOR = 0x20000000 | 0x200;
     *
     * */

    SCB->VTOR = 0x24000000 | 0x200;
24015548:	4b20      	ldr	r3, [pc, #128]	; (240155cc <Init+0x98>)
2401554a:	4a21      	ldr	r2, [pc, #132]	; (240155d0 <Init+0x9c>)
2401554c:	609a      	str	r2, [r3, #8]
2401554e:	2300      	movs	r3, #0
24015550:	617b      	str	r3, [r7, #20]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
24015552:	697b      	ldr	r3, [r7, #20]
24015554:	f383 8810 	msr	PRIMASK, r3

    __set_PRIMASK(0); //enable interrupts

    HAL_Init();
24015558:	f7eb f88e 	bl	24000678 <HAL_Init>

    SystemClock_Config();
2401555c:	f000 fa66 	bl	24015a2c <SystemClock_Config>

    __HAL_RCC_QSPI_FORCE_RESET();  //completely reset peripheral
24015560:	4b1c      	ldr	r3, [pc, #112]	; (240155d4 <Init+0xa0>)
24015562:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
24015564:	4a1b      	ldr	r2, [pc, #108]	; (240155d4 <Init+0xa0>)
24015566:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
2401556a:	67d3      	str	r3, [r2, #124]	; 0x7c
    __HAL_RCC_QSPI_RELEASE_RESET();
2401556c:	4b19      	ldr	r3, [pc, #100]	; (240155d4 <Init+0xa0>)
2401556e:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
24015570:	4a18      	ldr	r2, [pc, #96]	; (240155d4 <Init+0xa0>)
24015572:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
24015576:	67d3      	str	r3, [r2, #124]	; 0x7c

    if (CSP_QUADSPI_Init() != HAL_OK)
24015578:	f000 fd0a 	bl	24015f90 <CSP_QUADSPI_Init>
2401557c:	4603      	mov	r3, r0
2401557e:	2b00      	cmp	r3, #0
24015580:	d006      	beq.n	24015590 <Init+0x5c>
24015582:	2301      	movs	r3, #1
24015584:	613b      	str	r3, [r7, #16]
24015586:	693b      	ldr	r3, [r7, #16]
24015588:	f383 8810 	msr	PRIMASK, r3
    {
        __set_PRIMASK(1); //disable interrupts
        return LOADER_FAIL;
2401558c:	2300      	movs	r3, #0
2401558e:	e014      	b.n	240155ba <Init+0x86>
    }
//
    if(!configureMemoryMappedMode)
24015590:	79fb      	ldrb	r3, [r7, #7]
24015592:	2b00      	cmp	r3, #0
24015594:	d10b      	bne.n	240155ae <Init+0x7a>
    if (CSP_QSPI_EnableMemoryMappedMode() != HAL_OK)
24015596:	f000 fee7 	bl	24016368 <CSP_QSPI_EnableMemoryMappedMode>
2401559a:	4603      	mov	r3, r0
2401559c:	2b00      	cmp	r3, #0
2401559e:	d006      	beq.n	240155ae <Init+0x7a>
240155a0:	2301      	movs	r3, #1
240155a2:	60fb      	str	r3, [r7, #12]
240155a4:	68fb      	ldr	r3, [r7, #12]
240155a6:	f383 8810 	msr	PRIMASK, r3
    {
        __set_PRIMASK(1); //disable interrupts
        return LOADER_FAIL;
240155aa:	2300      	movs	r3, #0
240155ac:	e005      	b.n	240155ba <Init+0x86>
240155ae:	2301      	movs	r3, #1
240155b0:	60bb      	str	r3, [r7, #8]
240155b2:	68bb      	ldr	r3, [r7, #8]
240155b4:	f383 8810 	msr	PRIMASK, r3
    }

    __set_PRIMASK(1); //disable interrupts
    return LOADER_OK;
240155b8:	2301      	movs	r3, #1
}
240155ba:	4618      	mov	r0, r3
240155bc:	3718      	adds	r7, #24
240155be:	46bd      	mov	sp, r7
240155c0:	bd80      	pop	{r7, pc}
240155c2:	bf00      	nop
240155c4:	e000edf0 	.word	0xe000edf0
240155c8:	a05f0000 	.word	0xa05f0000
240155cc:	e000ed00 	.word	0xe000ed00
240155d0:	24000200 	.word	0x24000200
240155d4:	58024400 	.word	0x58024400

240155d8 <Write>:
 * @param   buffer : pointer to data buffer
 * @retval  LOADER_OK = 1       : Operation succeeded
 * @retval  LOADER_FAIL = 0 : Operation failed
 */
int Write(uint32_t Address, uint32_t Size, uint8_t* buffer)
{
240155d8:	b580      	push	{r7, lr}
240155da:	b088      	sub	sp, #32
240155dc:	af00      	add	r7, sp, #0
240155de:	60f8      	str	r0, [r7, #12]
240155e0:	60b9      	str	r1, [r7, #8]
240155e2:	607a      	str	r2, [r7, #4]
240155e4:	2300      	movs	r3, #0
240155e6:	61fb      	str	r3, [r7, #28]
240155e8:	69fb      	ldr	r3, [r7, #28]
240155ea:	f383 8810 	msr	PRIMASK, r3
    __set_PRIMASK(0); //enable interrupts

    if(HAL_QSPI_Abort(&hqspi) != HAL_OK)
240155ee:	4814      	ldr	r0, [pc, #80]	; (24015640 <Write+0x68>)
240155f0:	f7fb ff21 	bl	24011436 <HAL_QSPI_Abort>
240155f4:	4603      	mov	r3, r0
240155f6:	2b00      	cmp	r3, #0
240155f8:	d006      	beq.n	24015608 <Write+0x30>
240155fa:	2301      	movs	r3, #1
240155fc:	61bb      	str	r3, [r7, #24]
240155fe:	69bb      	ldr	r3, [r7, #24]
24015600:	f383 8810 	msr	PRIMASK, r3
    {
        __set_PRIMASK(1); //disable interrupts
        return LOADER_FAIL;
24015604:	2300      	movs	r3, #0
24015606:	e017      	b.n	24015638 <Write+0x60>
    }


    if(CSP_QSPI_WriteMemory((uint8_t*) buffer, (Address & (0x00ffffff)), Size) != HAL_OK)
24015608:	68fb      	ldr	r3, [r7, #12]
2401560a:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
2401560e:	68ba      	ldr	r2, [r7, #8]
24015610:	4619      	mov	r1, r3
24015612:	6878      	ldr	r0, [r7, #4]
24015614:	f000 fe1a 	bl	2401624c <CSP_QSPI_WriteMemory>
24015618:	4603      	mov	r3, r0
2401561a:	2b00      	cmp	r3, #0
2401561c:	d006      	beq.n	2401562c <Write+0x54>
2401561e:	2301      	movs	r3, #1
24015620:	617b      	str	r3, [r7, #20]
24015622:	697b      	ldr	r3, [r7, #20]
24015624:	f383 8810 	msr	PRIMASK, r3
    {
        __set_PRIMASK(1); //disable interrupts
        return LOADER_FAIL;
24015628:	2300      	movs	r3, #0
2401562a:	e005      	b.n	24015638 <Write+0x60>
2401562c:	2301      	movs	r3, #1
2401562e:	613b      	str	r3, [r7, #16]
24015630:	693b      	ldr	r3, [r7, #16]
24015632:	f383 8810 	msr	PRIMASK, r3
    }
    __set_PRIMASK(1); //disable interrupts
    return LOADER_OK;
24015636:	2301      	movs	r3, #1
}
24015638:	4618      	mov	r0, r3
2401563a:	3720      	adds	r7, #32
2401563c:	46bd      	mov	sp, r7
2401563e:	bd80      	pop	{r7, pc}
24015640:	24000564 	.word	0x24000564

24015644 <SectorErase>:
 * @param   EraseEndAddress   :  erase end address
 * @retval  LOADER_OK = 1       : Operation succeeded
 * @retval  LOADER_FAIL = 0 : Operation failed
 */
int SectorErase(uint32_t EraseStartAddress, uint32_t EraseEndAddress)
{
24015644:	b580      	push	{r7, lr}
24015646:	b086      	sub	sp, #24
24015648:	af00      	add	r7, sp, #0
2401564a:	6078      	str	r0, [r7, #4]
2401564c:	6039      	str	r1, [r7, #0]
2401564e:	2300      	movs	r3, #0
24015650:	617b      	str	r3, [r7, #20]
24015652:	697b      	ldr	r3, [r7, #20]
24015654:	f383 8810 	msr	PRIMASK, r3

    __set_PRIMASK(0); //enable interrupts
    if (HAL_QSPI_Abort(&hqspi) != HAL_OK)
24015658:	4812      	ldr	r0, [pc, #72]	; (240156a4 <SectorErase+0x60>)
2401565a:	f7fb feec 	bl	24011436 <HAL_QSPI_Abort>
2401565e:	4603      	mov	r3, r0
24015660:	2b00      	cmp	r3, #0
24015662:	d006      	beq.n	24015672 <SectorErase+0x2e>
24015664:	2301      	movs	r3, #1
24015666:	613b      	str	r3, [r7, #16]
24015668:	693b      	ldr	r3, [r7, #16]
2401566a:	f383 8810 	msr	PRIMASK, r3
    {
        __set_PRIMASK(1); //disable interrupts
        return LOADER_FAIL;
2401566e:	2300      	movs	r3, #0
24015670:	e013      	b.n	2401569a <SectorErase+0x56>
    }


    if (CSP_QSPI_EraseSector(EraseStartAddress, EraseEndAddress) != HAL_OK)
24015672:	6839      	ldr	r1, [r7, #0]
24015674:	6878      	ldr	r0, [r7, #4]
24015676:	f000 fd95 	bl	240161a4 <CSP_QSPI_EraseSector>
2401567a:	4603      	mov	r3, r0
2401567c:	2b00      	cmp	r3, #0
2401567e:	d006      	beq.n	2401568e <SectorErase+0x4a>
24015680:	2301      	movs	r3, #1
24015682:	60fb      	str	r3, [r7, #12]
24015684:	68fb      	ldr	r3, [r7, #12]
24015686:	f383 8810 	msr	PRIMASK, r3
    {
        __set_PRIMASK(1); //disable interrupts
        return LOADER_FAIL;
2401568a:	2300      	movs	r3, #0
2401568c:	e005      	b.n	2401569a <SectorErase+0x56>
2401568e:	2301      	movs	r3, #1
24015690:	60bb      	str	r3, [r7, #8]
24015692:	68bb      	ldr	r3, [r7, #8]
24015694:	f383 8810 	msr	PRIMASK, r3
    }

    __set_PRIMASK(1); //disable interrupts
    return LOADER_OK;
24015698:	2301      	movs	r3, #1
}
2401569a:	4618      	mov	r0, r3
2401569c:	3718      	adds	r7, #24
2401569e:	46bd      	mov	sp, r7
240156a0:	bd80      	pop	{r7, pc}
240156a2:	bf00      	nop
240156a4:	24000564 	.word	0x24000564

240156a8 <MassErase>:
 * outputs   :
 *     none
 * Note: Optional for all types of device
 */
int MassErase(void)
{
240156a8:	b580      	push	{r7, lr}
240156aa:	b084      	sub	sp, #16
240156ac:	af00      	add	r7, sp, #0
240156ae:	2300      	movs	r3, #0
240156b0:	60fb      	str	r3, [r7, #12]
240156b2:	68fb      	ldr	r3, [r7, #12]
240156b4:	f383 8810 	msr	PRIMASK, r3

    __set_PRIMASK(0); //enable interrupts

    if (HAL_QSPI_Abort(&hqspi) != HAL_OK)
240156b8:	4811      	ldr	r0, [pc, #68]	; (24015700 <MassErase+0x58>)
240156ba:	f7fb febc 	bl	24011436 <HAL_QSPI_Abort>
240156be:	4603      	mov	r3, r0
240156c0:	2b00      	cmp	r3, #0
240156c2:	d006      	beq.n	240156d2 <MassErase+0x2a>
240156c4:	2301      	movs	r3, #1
240156c6:	60bb      	str	r3, [r7, #8]
240156c8:	68bb      	ldr	r3, [r7, #8]
240156ca:	f383 8810 	msr	PRIMASK, r3
    {
        __set_PRIMASK(1); //disable interrupts
        return LOADER_FAIL;
240156ce:	2300      	movs	r3, #0
240156d0:	e011      	b.n	240156f6 <MassErase+0x4e>
    }


    if (CSP_QSPI_Erase_Chip() != HAL_OK)
240156d2:	f000 fc81 	bl	24015fd8 <CSP_QSPI_Erase_Chip>
240156d6:	4603      	mov	r3, r0
240156d8:	2b00      	cmp	r3, #0
240156da:	d006      	beq.n	240156ea <MassErase+0x42>
240156dc:	2301      	movs	r3, #1
240156de:	607b      	str	r3, [r7, #4]
240156e0:	687b      	ldr	r3, [r7, #4]
240156e2:	f383 8810 	msr	PRIMASK, r3
    {
        __set_PRIMASK(1); //disable interrupts
        return LOADER_FAIL;
240156e6:	2300      	movs	r3, #0
240156e8:	e005      	b.n	240156f6 <MassErase+0x4e>
240156ea:	2301      	movs	r3, #1
240156ec:	603b      	str	r3, [r7, #0]
240156ee:	683b      	ldr	r3, [r7, #0]
240156f0:	f383 8810 	msr	PRIMASK, r3
    }

    __set_PRIMASK(1); //disable interrupts
    return LOADER_OK;
240156f4:	2301      	movs	r3, #1
}
240156f6:	4618      	mov	r0, r3
240156f8:	3710      	adds	r7, #16
240156fa:	46bd      	mov	sp, r7
240156fc:	bd80      	pop	{r7, pc}
240156fe:	bf00      	nop
24015700:	24000564 	.word	0x24000564

24015704 <CheckSum>:
 * outputs   :
 *     R0             : Checksum value
 * Note: Optional for all types of device
 */
uint32_t CheckSum(uint32_t StartAddress, uint32_t Size, uint32_t InitVal)
{
24015704:	b480      	push	{r7}
24015706:	b089      	sub	sp, #36	; 0x24
24015708:	af00      	add	r7, sp, #0
2401570a:	60f8      	str	r0, [r7, #12]
2401570c:	60b9      	str	r1, [r7, #8]
2401570e:	607a      	str	r2, [r7, #4]
    uint8_t missalignementAddress = StartAddress % 4;
24015710:	68fb      	ldr	r3, [r7, #12]
24015712:	b2db      	uxtb	r3, r3
24015714:	f003 0303 	and.w	r3, r3, #3
24015718:	77fb      	strb	r3, [r7, #31]
    uint8_t missalignementSize = Size;
2401571a:	68bb      	ldr	r3, [r7, #8]
2401571c:	77bb      	strb	r3, [r7, #30]
    int cnt;
    uint32_t Val;

    StartAddress -= StartAddress % 4;
2401571e:	68fb      	ldr	r3, [r7, #12]
24015720:	f023 0303 	bic.w	r3, r3, #3
24015724:	60fb      	str	r3, [r7, #12]
    Size += (Size % 4 == 0) ? 0 : 4 - (Size % 4);
24015726:	68bb      	ldr	r3, [r7, #8]
24015728:	f003 0303 	and.w	r3, r3, #3
2401572c:	2b00      	cmp	r3, #0
2401572e:	d005      	beq.n	2401573c <CheckSum+0x38>
24015730:	68bb      	ldr	r3, [r7, #8]
24015732:	f003 0303 	and.w	r3, r3, #3
24015736:	f1c3 0304 	rsb	r3, r3, #4
2401573a:	e000      	b.n	2401573e <CheckSum+0x3a>
2401573c:	2300      	movs	r3, #0
2401573e:	68ba      	ldr	r2, [r7, #8]
24015740:	4413      	add	r3, r2
24015742:	60bb      	str	r3, [r7, #8]

    for (cnt = 0; cnt < Size; cnt += 4)
24015744:	2300      	movs	r3, #0
24015746:	61bb      	str	r3, [r7, #24]
24015748:	e0af      	b.n	240158aa <CheckSum+0x1a6>
    {
        Val = *(uint32_t*) StartAddress;
2401574a:	68fb      	ldr	r3, [r7, #12]
2401574c:	681b      	ldr	r3, [r3, #0]
2401574e:	617b      	str	r3, [r7, #20]
        if (missalignementAddress)
24015750:	7ffb      	ldrb	r3, [r7, #31]
24015752:	2b00      	cmp	r3, #0
24015754:	d03e      	beq.n	240157d4 <CheckSum+0xd0>
        {
            switch (missalignementAddress)
24015756:	7ffb      	ldrb	r3, [r7, #31]
24015758:	2b02      	cmp	r3, #2
2401575a:	d01d      	beq.n	24015798 <CheckSum+0x94>
2401575c:	2b03      	cmp	r3, #3
2401575e:	d02d      	beq.n	240157bc <CheckSum+0xb8>
24015760:	2b01      	cmp	r3, #1
24015762:	f040 809c 	bne.w	2401589e <CheckSum+0x19a>
            {
                case 1:
                    InitVal += (uint8_t) (Val >> 8 & 0xff);
24015766:	697b      	ldr	r3, [r7, #20]
24015768:	0a1b      	lsrs	r3, r3, #8
2401576a:	b2db      	uxtb	r3, r3
2401576c:	461a      	mov	r2, r3
2401576e:	687b      	ldr	r3, [r7, #4]
24015770:	4413      	add	r3, r2
24015772:	607b      	str	r3, [r7, #4]
                    InitVal += (uint8_t) (Val >> 16 & 0xff);
24015774:	697b      	ldr	r3, [r7, #20]
24015776:	0c1b      	lsrs	r3, r3, #16
24015778:	b2db      	uxtb	r3, r3
2401577a:	461a      	mov	r2, r3
2401577c:	687b      	ldr	r3, [r7, #4]
2401577e:	4413      	add	r3, r2
24015780:	607b      	str	r3, [r7, #4]
                    InitVal += (uint8_t) (Val >> 24 & 0xff);
24015782:	697b      	ldr	r3, [r7, #20]
24015784:	0e1b      	lsrs	r3, r3, #24
24015786:	b2db      	uxtb	r3, r3
24015788:	461a      	mov	r2, r3
2401578a:	687b      	ldr	r3, [r7, #4]
2401578c:	4413      	add	r3, r2
2401578e:	607b      	str	r3, [r7, #4]
                    missalignementAddress -= 1;
24015790:	7ffb      	ldrb	r3, [r7, #31]
24015792:	3b01      	subs	r3, #1
24015794:	77fb      	strb	r3, [r7, #31]
                    break;
24015796:	e082      	b.n	2401589e <CheckSum+0x19a>
                case 2:
                    InitVal += (uint8_t) (Val >> 16 & 0xff);
24015798:	697b      	ldr	r3, [r7, #20]
2401579a:	0c1b      	lsrs	r3, r3, #16
2401579c:	b2db      	uxtb	r3, r3
2401579e:	461a      	mov	r2, r3
240157a0:	687b      	ldr	r3, [r7, #4]
240157a2:	4413      	add	r3, r2
240157a4:	607b      	str	r3, [r7, #4]
                    InitVal += (uint8_t) (Val >> 24 & 0xff);
240157a6:	697b      	ldr	r3, [r7, #20]
240157a8:	0e1b      	lsrs	r3, r3, #24
240157aa:	b2db      	uxtb	r3, r3
240157ac:	461a      	mov	r2, r3
240157ae:	687b      	ldr	r3, [r7, #4]
240157b0:	4413      	add	r3, r2
240157b2:	607b      	str	r3, [r7, #4]
                    missalignementAddress -= 2;
240157b4:	7ffb      	ldrb	r3, [r7, #31]
240157b6:	3b02      	subs	r3, #2
240157b8:	77fb      	strb	r3, [r7, #31]
                    break;
240157ba:	e070      	b.n	2401589e <CheckSum+0x19a>
                case 3:
                    InitVal += (uint8_t) (Val >> 24 & 0xff);
240157bc:	697b      	ldr	r3, [r7, #20]
240157be:	0e1b      	lsrs	r3, r3, #24
240157c0:	b2db      	uxtb	r3, r3
240157c2:	461a      	mov	r2, r3
240157c4:	687b      	ldr	r3, [r7, #4]
240157c6:	4413      	add	r3, r2
240157c8:	607b      	str	r3, [r7, #4]
                    missalignementAddress -= 3;
240157ca:	7ffb      	ldrb	r3, [r7, #31]
240157cc:	3b03      	subs	r3, #3
240157ce:	77fb      	strb	r3, [r7, #31]
                    break;
240157d0:	bf00      	nop
240157d2:	e064      	b.n	2401589e <CheckSum+0x19a>
            }
        }else if ((Size - missalignementSize) % 4 && (Size - cnt) <= 4)
240157d4:	7fbb      	ldrb	r3, [r7, #30]
240157d6:	68ba      	ldr	r2, [r7, #8]
240157d8:	1ad3      	subs	r3, r2, r3
240157da:	f003 0303 	and.w	r3, r3, #3
240157de:	2b00      	cmp	r3, #0
240157e0:	d042      	beq.n	24015868 <CheckSum+0x164>
240157e2:	69bb      	ldr	r3, [r7, #24]
240157e4:	68ba      	ldr	r2, [r7, #8]
240157e6:	1ad3      	subs	r3, r2, r3
240157e8:	2b04      	cmp	r3, #4
240157ea:	d83d      	bhi.n	24015868 <CheckSum+0x164>
        {
            switch (Size - missalignementSize)
240157ec:	7fbb      	ldrb	r3, [r7, #30]
240157ee:	68ba      	ldr	r2, [r7, #8]
240157f0:	1ad3      	subs	r3, r2, r3
240157f2:	2b02      	cmp	r3, #2
240157f4:	d01c      	beq.n	24015830 <CheckSum+0x12c>
240157f6:	2b03      	cmp	r3, #3
240157f8:	d02b      	beq.n	24015852 <CheckSum+0x14e>
240157fa:	2b01      	cmp	r3, #1
240157fc:	d000      	beq.n	24015800 <CheckSum+0xfc>
                case 3:
                    InitVal += (uint8_t) Val;
                    missalignementSize -= 3;
                    break;
            }
        }else
240157fe:	e04e      	b.n	2401589e <CheckSum+0x19a>
                    InitVal += (uint8_t) Val;
24015800:	697b      	ldr	r3, [r7, #20]
24015802:	b2db      	uxtb	r3, r3
24015804:	461a      	mov	r2, r3
24015806:	687b      	ldr	r3, [r7, #4]
24015808:	4413      	add	r3, r2
2401580a:	607b      	str	r3, [r7, #4]
                    InitVal += (uint8_t) (Val >> 8 & 0xff);
2401580c:	697b      	ldr	r3, [r7, #20]
2401580e:	0a1b      	lsrs	r3, r3, #8
24015810:	b2db      	uxtb	r3, r3
24015812:	461a      	mov	r2, r3
24015814:	687b      	ldr	r3, [r7, #4]
24015816:	4413      	add	r3, r2
24015818:	607b      	str	r3, [r7, #4]
                    InitVal += (uint8_t) (Val >> 16 & 0xff);
2401581a:	697b      	ldr	r3, [r7, #20]
2401581c:	0c1b      	lsrs	r3, r3, #16
2401581e:	b2db      	uxtb	r3, r3
24015820:	461a      	mov	r2, r3
24015822:	687b      	ldr	r3, [r7, #4]
24015824:	4413      	add	r3, r2
24015826:	607b      	str	r3, [r7, #4]
                    missalignementSize -= 1;
24015828:	7fbb      	ldrb	r3, [r7, #30]
2401582a:	3b01      	subs	r3, #1
2401582c:	77bb      	strb	r3, [r7, #30]
                    break;
2401582e:	e01a      	b.n	24015866 <CheckSum+0x162>
                    InitVal += (uint8_t) Val;
24015830:	697b      	ldr	r3, [r7, #20]
24015832:	b2db      	uxtb	r3, r3
24015834:	461a      	mov	r2, r3
24015836:	687b      	ldr	r3, [r7, #4]
24015838:	4413      	add	r3, r2
2401583a:	607b      	str	r3, [r7, #4]
                    InitVal += (uint8_t) (Val >> 8 & 0xff);
2401583c:	697b      	ldr	r3, [r7, #20]
2401583e:	0a1b      	lsrs	r3, r3, #8
24015840:	b2db      	uxtb	r3, r3
24015842:	461a      	mov	r2, r3
24015844:	687b      	ldr	r3, [r7, #4]
24015846:	4413      	add	r3, r2
24015848:	607b      	str	r3, [r7, #4]
                    missalignementSize -= 2;
2401584a:	7fbb      	ldrb	r3, [r7, #30]
2401584c:	3b02      	subs	r3, #2
2401584e:	77bb      	strb	r3, [r7, #30]
                    break;
24015850:	e009      	b.n	24015866 <CheckSum+0x162>
                    InitVal += (uint8_t) Val;
24015852:	697b      	ldr	r3, [r7, #20]
24015854:	b2db      	uxtb	r3, r3
24015856:	461a      	mov	r2, r3
24015858:	687b      	ldr	r3, [r7, #4]
2401585a:	4413      	add	r3, r2
2401585c:	607b      	str	r3, [r7, #4]
                    missalignementSize -= 3;
2401585e:	7fbb      	ldrb	r3, [r7, #30]
24015860:	3b03      	subs	r3, #3
24015862:	77bb      	strb	r3, [r7, #30]
                    break;
24015864:	bf00      	nop
        }else
24015866:	e01a      	b.n	2401589e <CheckSum+0x19a>
        {
            InitVal += (uint8_t) Val;
24015868:	697b      	ldr	r3, [r7, #20]
2401586a:	b2db      	uxtb	r3, r3
2401586c:	461a      	mov	r2, r3
2401586e:	687b      	ldr	r3, [r7, #4]
24015870:	4413      	add	r3, r2
24015872:	607b      	str	r3, [r7, #4]
            InitVal += (uint8_t) (Val >> 8 & 0xff);
24015874:	697b      	ldr	r3, [r7, #20]
24015876:	0a1b      	lsrs	r3, r3, #8
24015878:	b2db      	uxtb	r3, r3
2401587a:	461a      	mov	r2, r3
2401587c:	687b      	ldr	r3, [r7, #4]
2401587e:	4413      	add	r3, r2
24015880:	607b      	str	r3, [r7, #4]
            InitVal += (uint8_t) (Val >> 16 & 0xff);
24015882:	697b      	ldr	r3, [r7, #20]
24015884:	0c1b      	lsrs	r3, r3, #16
24015886:	b2db      	uxtb	r3, r3
24015888:	461a      	mov	r2, r3
2401588a:	687b      	ldr	r3, [r7, #4]
2401588c:	4413      	add	r3, r2
2401588e:	607b      	str	r3, [r7, #4]
            InitVal += (uint8_t) (Val >> 24 & 0xff);
24015890:	697b      	ldr	r3, [r7, #20]
24015892:	0e1b      	lsrs	r3, r3, #24
24015894:	b2db      	uxtb	r3, r3
24015896:	461a      	mov	r2, r3
24015898:	687b      	ldr	r3, [r7, #4]
2401589a:	4413      	add	r3, r2
2401589c:	607b      	str	r3, [r7, #4]
        }
        StartAddress += 4;
2401589e:	68fb      	ldr	r3, [r7, #12]
240158a0:	3304      	adds	r3, #4
240158a2:	60fb      	str	r3, [r7, #12]
    for (cnt = 0; cnt < Size; cnt += 4)
240158a4:	69bb      	ldr	r3, [r7, #24]
240158a6:	3304      	adds	r3, #4
240158a8:	61bb      	str	r3, [r7, #24]
240158aa:	69bb      	ldr	r3, [r7, #24]
240158ac:	68ba      	ldr	r2, [r7, #8]
240158ae:	429a      	cmp	r2, r3
240158b0:	f63f af4b 	bhi.w	2401574a <CheckSum+0x46>
    }

    return (InitVal);
240158b4:	687b      	ldr	r3, [r7, #4]
}
240158b6:	4618      	mov	r0, r3
240158b8:	3724      	adds	r7, #36	; 0x24
240158ba:	46bd      	mov	sp, r7
240158bc:	f85d 7b04 	ldr.w	r7, [sp], #4
240158c0:	4770      	bx	lr

240158c2 <Verify>:
 *     R0             : Operation failed (address of failure)
 *     R1             : Checksum value
 * Note: Optional for all types of device
 */
uint64_t Verify(uint32_t MemoryAddr, uint32_t RAMBufferAddr, uint32_t Size, uint32_t missalignement)
{
240158c2:	e92d 4890 	stmdb	sp!, {r4, r7, fp, lr}
240158c6:	b08c      	sub	sp, #48	; 0x30
240158c8:	af00      	add	r7, sp, #0
240158ca:	60f8      	str	r0, [r7, #12]
240158cc:	60b9      	str	r1, [r7, #8]
240158ce:	607a      	str	r2, [r7, #4]
240158d0:	603b      	str	r3, [r7, #0]
240158d2:	2300      	movs	r3, #0
240158d4:	61fb      	str	r3, [r7, #28]
240158d6:	69fb      	ldr	r3, [r7, #28]
240158d8:	f383 8810 	msr	PRIMASK, r3

    __set_PRIMASK(0); //enable interrupts
    uint32_t VerifiedData = 0, InitVal = 0;
240158dc:	2300      	movs	r3, #0
240158de:	62fb      	str	r3, [r7, #44]	; 0x2c
240158e0:	2300      	movs	r3, #0
240158e2:	62bb      	str	r3, [r7, #40]	; 0x28
    uint64_t checksum;
    Size *= 4;
240158e4:	687b      	ldr	r3, [r7, #4]
240158e6:	009b      	lsls	r3, r3, #2
240158e8:	607b      	str	r3, [r7, #4]

    if (CSP_QSPI_EnableMemoryMappedMode() != HAL_OK)
240158ea:	f000 fd3d 	bl	24016368 <CSP_QSPI_EnableMemoryMappedMode>
240158ee:	4603      	mov	r3, r0
240158f0:	2b00      	cmp	r3, #0
240158f2:	d009      	beq.n	24015908 <Verify+0x46>
240158f4:	2301      	movs	r3, #1
240158f6:	61bb      	str	r3, [r7, #24]
240158f8:	69bb      	ldr	r3, [r7, #24]
240158fa:	f383 8810 	msr	PRIMASK, r3
    {
        __set_PRIMASK(1); //disable interrupts
        return LOADER_FAIL;
240158fe:	f04f 0b00 	mov.w	fp, #0
24015902:	f04f 0c00 	mov.w	ip, #0
24015906:	e04b      	b.n	240159a0 <Verify+0xde>
    }

    checksum = CheckSum((uint32_t) MemoryAddr + (missalignement & 0xf), Size - ((missalignement >> 16) & 0xF), InitVal);
24015908:	683b      	ldr	r3, [r7, #0]
2401590a:	f003 020f 	and.w	r2, r3, #15
2401590e:	68fb      	ldr	r3, [r7, #12]
24015910:	18d0      	adds	r0, r2, r3
24015912:	683b      	ldr	r3, [r7, #0]
24015914:	0c1b      	lsrs	r3, r3, #16
24015916:	f003 030f 	and.w	r3, r3, #15
2401591a:	687a      	ldr	r2, [r7, #4]
2401591c:	1ad3      	subs	r3, r2, r3
2401591e:	6aba      	ldr	r2, [r7, #40]	; 0x28
24015920:	4619      	mov	r1, r3
24015922:	f7ff feef 	bl	24015704 <CheckSum>
24015926:	4603      	mov	r3, r0
24015928:	f04f 0400 	mov.w	r4, #0
2401592c:	e9c7 3408 	strd	r3, r4, [r7, #32]
    while(Size > VerifiedData)
24015930:	e024      	b.n	2401597c <Verify+0xba>
    {
        if(*(uint8_t*) MemoryAddr++ != *((uint8_t*) RAMBufferAddr + VerifiedData))
24015932:	68fb      	ldr	r3, [r7, #12]
24015934:	1c5a      	adds	r2, r3, #1
24015936:	60fa      	str	r2, [r7, #12]
24015938:	781a      	ldrb	r2, [r3, #0]
2401593a:	6af9      	ldr	r1, [r7, #44]	; 0x2c
2401593c:	68bb      	ldr	r3, [r7, #8]
2401593e:	440b      	add	r3, r1
24015940:	781b      	ldrb	r3, [r3, #0]
24015942:	429a      	cmp	r2, r3
24015944:	d017      	beq.n	24015976 <Verify+0xb4>
24015946:	2301      	movs	r3, #1
24015948:	617b      	str	r3, [r7, #20]
2401594a:	697b      	ldr	r3, [r7, #20]
2401594c:	f383 8810 	msr	PRIMASK, r3
        {
            __set_PRIMASK(1); //disable interrupts
            return ((checksum << 32) + (MemoryAddr + VerifiedData));
24015950:	e9d7 1208 	ldrd	r1, r2, [r7, #32]
24015954:	f04f 0300 	mov.w	r3, #0
24015958:	f04f 0400 	mov.w	r4, #0
2401595c:	000c      	movs	r4, r1
2401595e:	2300      	movs	r3, #0
24015960:	68f9      	ldr	r1, [r7, #12]
24015962:	6afa      	ldr	r2, [r7, #44]	; 0x2c
24015964:	440a      	add	r2, r1
24015966:	4611      	mov	r1, r2
24015968:	f04f 0200 	mov.w	r2, #0
2401596c:	eb13 0b01 	adds.w	fp, r3, r1
24015970:	eb44 0c02 	adc.w	ip, r4, r2
24015974:	e014      	b.n	240159a0 <Verify+0xde>
        }
        VerifiedData++;
24015976:	6afb      	ldr	r3, [r7, #44]	; 0x2c
24015978:	3301      	adds	r3, #1
2401597a:	62fb      	str	r3, [r7, #44]	; 0x2c
    while(Size > VerifiedData)
2401597c:	687a      	ldr	r2, [r7, #4]
2401597e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
24015980:	429a      	cmp	r2, r3
24015982:	d8d6      	bhi.n	24015932 <Verify+0x70>
24015984:	2301      	movs	r3, #1
24015986:	613b      	str	r3, [r7, #16]
24015988:	693b      	ldr	r3, [r7, #16]
2401598a:	f383 8810 	msr	PRIMASK, r3
    }

    __set_PRIMASK(1); //disable interrupts
    return (checksum << 32);
2401598e:	e9d7 1208 	ldrd	r1, r2, [r7, #32]
24015992:	f04f 0b00 	mov.w	fp, #0
24015996:	f04f 0c00 	mov.w	ip, #0
2401599a:	468c      	mov	ip, r1
2401599c:	f04f 0b00 	mov.w	fp, #0
240159a0:	465b      	mov	r3, fp
240159a2:	4664      	mov	r4, ip
}
240159a4:	4618      	mov	r0, r3
240159a6:	4621      	mov	r1, r4
240159a8:	3730      	adds	r7, #48	; 0x30
240159aa:	46bd      	mov	sp, r7
240159ac:	e8bd 8890 	ldmia.w	sp!, {r4, r7, fp, pc}

240159b0 <ITM_SendChar>:
           \li Is blocking when a debugger is connected, but the previous character sent has not been transmitted.
  \param [in]     ch  Character to transmit.
  \returns            Character to transmit.
 */
__STATIC_INLINE uint32_t ITM_SendChar (uint32_t ch)
{
240159b0:	b480      	push	{r7}
240159b2:	b083      	sub	sp, #12
240159b4:	af00      	add	r7, sp, #0
240159b6:	6078      	str	r0, [r7, #4]
  if (((ITM->TCR & ITM_TCR_ITMENA_Msk) != 0UL) &&      /* ITM enabled */
240159b8:	f04f 4360 	mov.w	r3, #3758096384	; 0xe0000000
240159bc:	f8d3 3e80 	ldr.w	r3, [r3, #3712]	; 0xe80
240159c0:	f003 0301 	and.w	r3, r3, #1
240159c4:	2b00      	cmp	r3, #0
240159c6:	d013      	beq.n	240159f0 <ITM_SendChar+0x40>
      ((ITM->TER & 1UL               ) != 0UL)   )     /* ITM Port #0 enabled */
240159c8:	f04f 4360 	mov.w	r3, #3758096384	; 0xe0000000
240159cc:	f8d3 3e00 	ldr.w	r3, [r3, #3584]	; 0xe00
240159d0:	f003 0301 	and.w	r3, r3, #1
  if (((ITM->TCR & ITM_TCR_ITMENA_Msk) != 0UL) &&      /* ITM enabled */
240159d4:	2b00      	cmp	r3, #0
240159d6:	d00b      	beq.n	240159f0 <ITM_SendChar+0x40>
  {
    while (ITM->PORT[0U].u32 == 0UL)
240159d8:	e000      	b.n	240159dc <ITM_SendChar+0x2c>
    {
      __NOP();
240159da:	bf00      	nop
    while (ITM->PORT[0U].u32 == 0UL)
240159dc:	f04f 4360 	mov.w	r3, #3758096384	; 0xe0000000
240159e0:	681b      	ldr	r3, [r3, #0]
240159e2:	2b00      	cmp	r3, #0
240159e4:	d0f9      	beq.n	240159da <ITM_SendChar+0x2a>
    }
    ITM->PORT[0U].u8 = (uint8_t)ch;
240159e6:	f04f 4360 	mov.w	r3, #3758096384	; 0xe0000000
240159ea:	687a      	ldr	r2, [r7, #4]
240159ec:	b2d2      	uxtb	r2, r2
240159ee:	701a      	strb	r2, [r3, #0]
  }
  return (ch);
240159f0:	687b      	ldr	r3, [r7, #4]
}
240159f2:	4618      	mov	r0, r3
240159f4:	370c      	adds	r7, #12
240159f6:	46bd      	mov	sp, r7
240159f8:	f85d 7b04 	ldr.w	r7, [sp], #4
240159fc:	4770      	bx	lr

240159fe <__io_putchar>:
void SystemClock_Config(void);



int __io_putchar(int ch)
{
240159fe:	b580      	push	{r7, lr}
24015a00:	b082      	sub	sp, #8
24015a02:	af00      	add	r7, sp, #0
24015a04:	6078      	str	r0, [r7, #4]
	ITM_SendChar(ch);
24015a06:	687b      	ldr	r3, [r7, #4]
24015a08:	4618      	mov	r0, r3
24015a0a:	f7ff ffd1 	bl	240159b0 <ITM_SendChar>

	return ch;
24015a0e:	687b      	ldr	r3, [r7, #4]
}
24015a10:	4618      	mov	r0, r3
24015a12:	3708      	adds	r7, #8
24015a14:	46bd      	mov	sp, r7
24015a16:	bd80      	pop	{r7, pc}

24015a18 <main>:
/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
24015a18:	b580      	push	{r7, lr}
24015a1a:	af00      	add	r7, sp, #0


	/* Reset of all peripherals, Initializes the Flash interface and the Systick. */
	HAL_Init();
24015a1c:	f7ea fe2c 	bl	24000678 <HAL_Init>

	/* Configure the system clock */
	SystemClock_Config();
24015a20:	f000 f804 	bl	24015a2c <SystemClock_Config>


	return 1;
24015a24:	2301      	movs	r3, #1
	while (1)
	{

	}

}
24015a26:	4618      	mov	r0, r3
24015a28:	bd80      	pop	{r7, pc}
	...

24015a2c <SystemClock_Config>:
/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
24015a2c:	b580      	push	{r7, lr}
24015a2e:	b0cc      	sub	sp, #304	; 0x130
24015a30:	af00      	add	r7, sp, #0
	RCC_OscInitTypeDef RCC_OscInitStruct = {0};
24015a32:	f107 03e4 	add.w	r3, r7, #228	; 0xe4
24015a36:	224c      	movs	r2, #76	; 0x4c
24015a38:	2100      	movs	r1, #0
24015a3a:	4618      	mov	r0, r3
24015a3c:	f001 f93e 	bl	24016cbc <memset>
	RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
24015a40:	f107 03c4 	add.w	r3, r7, #196	; 0xc4
24015a44:	2220      	movs	r2, #32
24015a46:	2100      	movs	r1, #0
24015a48:	4618      	mov	r0, r3
24015a4a:	f001 f937 	bl	24016cbc <memset>
	RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
24015a4e:	f107 0308 	add.w	r3, r7, #8
24015a52:	4618      	mov	r0, r3
24015a54:	23bc      	movs	r3, #188	; 0xbc
24015a56:	461a      	mov	r2, r3
24015a58:	2100      	movs	r1, #0
24015a5a:	f001 f92f 	bl	24016cbc <memset>

	/** Supply configuration update enable
	*/
	HAL_PWREx_ConfigSupply(PWR_LDO_SUPPLY);
24015a5e:	2002      	movs	r0, #2
24015a60:	f7f9 ff06 	bl	2400f870 <HAL_PWREx_ConfigSupply>
	/** Configure the main internal regulator output voltage
	*/
	__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE0);
24015a64:	1d3b      	adds	r3, r7, #4
24015a66:	2200      	movs	r2, #0
24015a68:	601a      	str	r2, [r3, #0]
24015a6a:	4b86      	ldr	r3, [pc, #536]	; (24015c84 <SystemClock_Config+0x258>)
24015a6c:	699b      	ldr	r3, [r3, #24]
24015a6e:	4a85      	ldr	r2, [pc, #532]	; (24015c84 <SystemClock_Config+0x258>)
24015a70:	f443 4340 	orr.w	r3, r3, #49152	; 0xc000
24015a74:	6193      	str	r3, [r2, #24]
24015a76:	4b83      	ldr	r3, [pc, #524]	; (24015c84 <SystemClock_Config+0x258>)
24015a78:	699b      	ldr	r3, [r3, #24]
24015a7a:	f403 4240 	and.w	r2, r3, #49152	; 0xc000
24015a7e:	1d3b      	adds	r3, r7, #4
24015a80:	601a      	str	r2, [r3, #0]
24015a82:	4b81      	ldr	r3, [pc, #516]	; (24015c88 <SystemClock_Config+0x25c>)
24015a84:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24015a86:	4a80      	ldr	r2, [pc, #512]	; (24015c88 <SystemClock_Config+0x25c>)
24015a88:	f043 0301 	orr.w	r3, r3, #1
24015a8c:	62d3      	str	r3, [r2, #44]	; 0x2c
24015a8e:	4b7e      	ldr	r3, [pc, #504]	; (24015c88 <SystemClock_Config+0x25c>)
24015a90:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24015a92:	f003 0201 	and.w	r2, r3, #1
24015a96:	1d3b      	adds	r3, r7, #4
24015a98:	601a      	str	r2, [r3, #0]
24015a9a:	1d3b      	adds	r3, r7, #4
24015a9c:	681b      	ldr	r3, [r3, #0]

	while(!__HAL_PWR_GET_FLAG(PWR_FLAG_VOSRDY)) {}
24015a9e:	bf00      	nop
24015aa0:	4b78      	ldr	r3, [pc, #480]	; (24015c84 <SystemClock_Config+0x258>)
24015aa2:	699b      	ldr	r3, [r3, #24]
24015aa4:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
24015aa8:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
24015aac:	d1f8      	bne.n	24015aa0 <SystemClock_Config+0x74>
	/** Configure LSE Drive Capability
	*/
	HAL_PWR_EnableBkUpAccess();
24015aae:	f7f9 fd23 	bl	2400f4f8 <HAL_PWR_EnableBkUpAccess>
	__HAL_RCC_LSEDRIVE_CONFIG(RCC_LSEDRIVE_LOW);
24015ab2:	f7ea ff65 	bl	24000980 <HAL_GetREVID>
24015ab6:	4b75      	ldr	r3, [pc, #468]	; (24015c8c <SystemClock_Config+0x260>)
24015ab8:	6f1b      	ldr	r3, [r3, #112]	; 0x70
24015aba:	4a74      	ldr	r2, [pc, #464]	; (24015c8c <SystemClock_Config+0x260>)
24015abc:	f023 0318 	bic.w	r3, r3, #24
24015ac0:	6713      	str	r3, [r2, #112]	; 0x70
	/** Macro to configure the PLL clock source
	*/
	__HAL_RCC_PLL_PLLSOURCE_CONFIG(RCC_PLLSOURCE_HSE);
24015ac2:	4b72      	ldr	r3, [pc, #456]	; (24015c8c <SystemClock_Config+0x260>)
24015ac4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
24015ac6:	f023 0303 	bic.w	r3, r3, #3
24015aca:	4a70      	ldr	r2, [pc, #448]	; (24015c8c <SystemClock_Config+0x260>)
24015acc:	f043 0302 	orr.w	r3, r3, #2
24015ad0:	6293      	str	r3, [r2, #40]	; 0x28
	/** Initializes the CPU, AHB and APB busses clocks
	*/
	RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI48|RCC_OSCILLATORTYPE_HSE
24015ad2:	2325      	movs	r3, #37	; 0x25
24015ad4:	f8c7 30e4 	str.w	r3, [r7, #228]	; 0xe4
							  |RCC_OSCILLATORTYPE_LSE;
	RCC_OscInitStruct.HSEState = RCC_HSE_ON;
24015ad8:	f44f 3380 	mov.w	r3, #65536	; 0x10000
24015adc:	f8c7 30e8 	str.w	r3, [r7, #232]	; 0xe8
	RCC_OscInitStruct.LSEState = RCC_LSE_ON;
24015ae0:	2301      	movs	r3, #1
24015ae2:	f8c7 30ec 	str.w	r3, [r7, #236]	; 0xec
	RCC_OscInitStruct.HSI48State = RCC_HSI48_ON;
24015ae6:	2301      	movs	r3, #1
24015ae8:	f8c7 30fc 	str.w	r3, [r7, #252]	; 0xfc
	RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
24015aec:	2302      	movs	r3, #2
24015aee:	f8c7 3108 	str.w	r3, [r7, #264]	; 0x108
	RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
24015af2:	2302      	movs	r3, #2
24015af4:	f8c7 310c 	str.w	r3, [r7, #268]	; 0x10c
	RCC_OscInitStruct.PLL.PLLM = 5;
24015af8:	2305      	movs	r3, #5
24015afa:	f8c7 3110 	str.w	r3, [r7, #272]	; 0x110
	RCC_OscInitStruct.PLL.PLLN = 160;
24015afe:	23a0      	movs	r3, #160	; 0xa0
24015b00:	f8c7 3114 	str.w	r3, [r7, #276]	; 0x114
	RCC_OscInitStruct.PLL.PLLP = 2;
24015b04:	2302      	movs	r3, #2
24015b06:	f8c7 3118 	str.w	r3, [r7, #280]	; 0x118
	RCC_OscInitStruct.PLL.PLLQ = 2;
24015b0a:	2302      	movs	r3, #2
24015b0c:	f8c7 311c 	str.w	r3, [r7, #284]	; 0x11c
	RCC_OscInitStruct.PLL.PLLR = 2;
24015b10:	2302      	movs	r3, #2
24015b12:	f8c7 3120 	str.w	r3, [r7, #288]	; 0x120
	RCC_OscInitStruct.PLL.PLLRGE = RCC_PLL1VCIRANGE_2;
24015b16:	2308      	movs	r3, #8
24015b18:	f8c7 3124 	str.w	r3, [r7, #292]	; 0x124
	RCC_OscInitStruct.PLL.PLLVCOSEL = RCC_PLL1VCOWIDE;
24015b1c:	2300      	movs	r3, #0
24015b1e:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
	RCC_OscInitStruct.PLL.PLLFRACN = 0;
24015b22:	2300      	movs	r3, #0
24015b24:	f8c7 312c 	str.w	r3, [r7, #300]	; 0x12c
	if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
24015b28:	f107 03e4 	add.w	r3, r7, #228	; 0xe4
24015b2c:	4618      	mov	r0, r3
24015b2e:	f7fc f941 	bl	24011db4 <HAL_RCC_OscConfig>
24015b32:	4603      	mov	r3, r0
24015b34:	2b00      	cmp	r3, #0
24015b36:	d001      	beq.n	24015b3c <SystemClock_Config+0x110>
	{
		Error_Handler();
24015b38:	f000 f956 	bl	24015de8 <Error_Handler>
	}
	/** Initializes the CPU, AHB and APB busses clocks
	*/
	RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
24015b3c:	233f      	movs	r3, #63	; 0x3f
24015b3e:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4
							  |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2
							  |RCC_CLOCKTYPE_D3PCLK1|RCC_CLOCKTYPE_D1PCLK1;
	RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
24015b42:	2303      	movs	r3, #3
24015b44:	f8c7 30c8 	str.w	r3, [r7, #200]	; 0xc8
	RCC_ClkInitStruct.SYSCLKDivider = RCC_SYSCLK_DIV1;
24015b48:	2300      	movs	r3, #0
24015b4a:	f8c7 30cc 	str.w	r3, [r7, #204]	; 0xcc
	RCC_ClkInitStruct.AHBCLKDivider = RCC_HCLK_DIV2;
24015b4e:	2308      	movs	r3, #8
24015b50:	f8c7 30d0 	str.w	r3, [r7, #208]	; 0xd0
	RCC_ClkInitStruct.APB3CLKDivider = RCC_APB3_DIV2;
24015b54:	2340      	movs	r3, #64	; 0x40
24015b56:	f8c7 30d4 	str.w	r3, [r7, #212]	; 0xd4
	RCC_ClkInitStruct.APB1CLKDivider = RCC_APB1_DIV2;
24015b5a:	2340      	movs	r3, #64	; 0x40
24015b5c:	f8c7 30d8 	str.w	r3, [r7, #216]	; 0xd8
	RCC_ClkInitStruct.APB2CLKDivider = RCC_APB2_DIV2;
24015b60:	f44f 6380 	mov.w	r3, #1024	; 0x400
24015b64:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
	RCC_ClkInitStruct.APB4CLKDivider = RCC_APB4_DIV2;
24015b68:	2340      	movs	r3, #64	; 0x40
24015b6a:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0

	if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK)
24015b6e:	f107 03c4 	add.w	r3, r7, #196	; 0xc4
24015b72:	2104      	movs	r1, #4
24015b74:	4618      	mov	r0, r3
24015b76:	f7fc fcf5 	bl	24012564 <HAL_RCC_ClockConfig>
24015b7a:	4603      	mov	r3, r0
24015b7c:	2b00      	cmp	r3, #0
24015b7e:	d001      	beq.n	24015b84 <SystemClock_Config+0x158>
	{
		Error_Handler();
24015b80:	f000 f932 	bl	24015de8 <Error_Handler>
	}
	PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_LTDC|RCC_PERIPHCLK_UART5
24015b84:	f107 0308 	add.w	r3, r7, #8
24015b88:	4a41      	ldr	r2, [pc, #260]	; (24015c90 <SystemClock_Config+0x264>)
24015b8a:	601a      	str	r2, [r3, #0]
							  |RCC_PERIPHCLK_SPI2|RCC_PERIPHCLK_SDMMC
							  |RCC_PERIPHCLK_ADC|RCC_PERIPHCLK_I2C1
							  |RCC_PERIPHCLK_CEC|RCC_PERIPHCLK_USB
							  |RCC_PERIPHCLK_QSPI|RCC_PERIPHCLK_FMC;
	PeriphClkInitStruct.PLL2.PLL2M = 2;
24015b8c:	f107 0308 	add.w	r3, r7, #8
24015b90:	2202      	movs	r2, #2
24015b92:	605a      	str	r2, [r3, #4]
	PeriphClkInitStruct.PLL2.PLL2N = 12;
24015b94:	f107 0308 	add.w	r3, r7, #8
24015b98:	220c      	movs	r2, #12
24015b9a:	609a      	str	r2, [r3, #8]
	PeriphClkInitStruct.PLL2.PLL2P = 1;
24015b9c:	f107 0308 	add.w	r3, r7, #8
24015ba0:	2201      	movs	r2, #1
24015ba2:	60da      	str	r2, [r3, #12]
	PeriphClkInitStruct.PLL2.PLL2Q = 2;
24015ba4:	f107 0308 	add.w	r3, r7, #8
24015ba8:	2202      	movs	r2, #2
24015baa:	611a      	str	r2, [r3, #16]
	PeriphClkInitStruct.PLL2.PLL2R = 1;
24015bac:	f107 0308 	add.w	r3, r7, #8
24015bb0:	2201      	movs	r2, #1
24015bb2:	615a      	str	r2, [r3, #20]
	PeriphClkInitStruct.PLL2.PLL2RGE = RCC_PLL2VCIRANGE_3;
24015bb4:	f107 0308 	add.w	r3, r7, #8
24015bb8:	22c0      	movs	r2, #192	; 0xc0
24015bba:	619a      	str	r2, [r3, #24]
	PeriphClkInitStruct.PLL2.PLL2VCOSEL = RCC_PLL2VCOMEDIUM;
24015bbc:	f107 0308 	add.w	r3, r7, #8
24015bc0:	2220      	movs	r2, #32
24015bc2:	61da      	str	r2, [r3, #28]
	PeriphClkInitStruct.PLL2.PLL2FRACN = 0;
24015bc4:	f107 0308 	add.w	r3, r7, #8
24015bc8:	2200      	movs	r2, #0
24015bca:	621a      	str	r2, [r3, #32]
	PeriphClkInitStruct.PLL3.PLL3M = 2;
24015bcc:	f107 0308 	add.w	r3, r7, #8
24015bd0:	2202      	movs	r2, #2
24015bd2:	625a      	str	r2, [r3, #36]	; 0x24
	PeriphClkInitStruct.PLL3.PLL3N = 12;
24015bd4:	f107 0308 	add.w	r3, r7, #8
24015bd8:	220c      	movs	r2, #12
24015bda:	629a      	str	r2, [r3, #40]	; 0x28
	PeriphClkInitStruct.PLL3.PLL3P = 10;
24015bdc:	f107 0308 	add.w	r3, r7, #8
24015be0:	220a      	movs	r2, #10
24015be2:	62da      	str	r2, [r3, #44]	; 0x2c
	PeriphClkInitStruct.PLL3.PLL3Q = 25;
24015be4:	f107 0308 	add.w	r3, r7, #8
24015be8:	2219      	movs	r2, #25
24015bea:	631a      	str	r2, [r3, #48]	; 0x30
	PeriphClkInitStruct.PLL3.PLL3R = 5;
24015bec:	f107 0308 	add.w	r3, r7, #8
24015bf0:	2205      	movs	r2, #5
24015bf2:	635a      	str	r2, [r3, #52]	; 0x34
	PeriphClkInitStruct.PLL3.PLL3RGE = RCC_PLL3VCIRANGE_3;
24015bf4:	f107 0308 	add.w	r3, r7, #8
24015bf8:	f44f 6240 	mov.w	r2, #3072	; 0xc00
24015bfc:	639a      	str	r2, [r3, #56]	; 0x38
	PeriphClkInitStruct.PLL3.PLL3VCOSEL = RCC_PLL3VCOMEDIUM;
24015bfe:	f107 0308 	add.w	r3, r7, #8
24015c02:	f44f 7200 	mov.w	r2, #512	; 0x200
24015c06:	63da      	str	r2, [r3, #60]	; 0x3c
	PeriphClkInitStruct.PLL3.PLL3FRACN = 0;
24015c08:	f107 0308 	add.w	r3, r7, #8
24015c0c:	2200      	movs	r2, #0
24015c0e:	641a      	str	r2, [r3, #64]	; 0x40
	PeriphClkInitStruct.FmcClockSelection = RCC_FMCCLKSOURCE_D1HCLK;
24015c10:	f107 0308 	add.w	r3, r7, #8
24015c14:	2200      	movs	r2, #0
24015c16:	645a      	str	r2, [r3, #68]	; 0x44
	PeriphClkInitStruct.QspiClockSelection = RCC_QSPICLKSOURCE_D1HCLK;
24015c18:	f107 0308 	add.w	r3, r7, #8
24015c1c:	2200      	movs	r2, #0
24015c1e:	649a      	str	r2, [r3, #72]	; 0x48
	PeriphClkInitStruct.SdmmcClockSelection = RCC_SDMMCCLKSOURCE_PLL;
24015c20:	f107 0308 	add.w	r3, r7, #8
24015c24:	2200      	movs	r2, #0
24015c26:	64da      	str	r2, [r3, #76]	; 0x4c
	PeriphClkInitStruct.Spi123ClockSelection = RCC_SPI123CLKSOURCE_PLL;
24015c28:	f107 0308 	add.w	r3, r7, #8
24015c2c:	2200      	movs	r2, #0
24015c2e:	65da      	str	r2, [r3, #92]	; 0x5c
	PeriphClkInitStruct.Usart234578ClockSelection = RCC_USART234578CLKSOURCE_D2PCLK1;
24015c30:	f107 0308 	add.w	r3, r7, #8
24015c34:	2200      	movs	r2, #0
24015c36:	675a      	str	r2, [r3, #116]	; 0x74
	PeriphClkInitStruct.I2c123ClockSelection = RCC_I2C123CLKSOURCE_D2PCLK1;
24015c38:	f107 0308 	add.w	r3, r7, #8
24015c3c:	2200      	movs	r2, #0
24015c3e:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
	PeriphClkInitStruct.UsbClockSelection = RCC_USBCLKSOURCE_HSI48;
24015c42:	f107 0308 	add.w	r3, r7, #8
24015c46:	f44f 1240 	mov.w	r2, #3145728	; 0x300000
24015c4a:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
	PeriphClkInitStruct.CecClockSelection = RCC_CECCLKSOURCE_LSE;
24015c4e:	f107 0308 	add.w	r3, r7, #8
24015c52:	2200      	movs	r2, #0
24015c54:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
	PeriphClkInitStruct.AdcClockSelection = RCC_ADCCLKSOURCE_PLL2;
24015c58:	f107 0308 	add.w	r3, r7, #8
24015c5c:	2200      	movs	r2, #0
24015c5e:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
	if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
24015c62:	f107 0308 	add.w	r3, r7, #8
24015c66:	4618      	mov	r0, r3
24015c68:	f7fd f9d6 	bl	24013018 <HAL_RCCEx_PeriphCLKConfig>
24015c6c:	4603      	mov	r3, r0
24015c6e:	2b00      	cmp	r3, #0
24015c70:	d001      	beq.n	24015c76 <SystemClock_Config+0x24a>
	{
		Error_Handler();
24015c72:	f000 f8b9 	bl	24015de8 <Error_Handler>
	}
	/** Enable USB Voltage detector
	*/
	HAL_PWREx_EnableUSBVoltageDetector();
24015c76:	f7fa f987 	bl	2400ff88 <HAL_PWREx_EnableUSBVoltageDetector>
}
24015c7a:	bf00      	nop
24015c7c:	f507 7798 	add.w	r7, r7, #304	; 0x130
24015c80:	46bd      	mov	sp, r7
24015c82:	bd80      	pop	{r7, pc}
24015c84:	58024800 	.word	0x58024800
24015c88:	58000400 	.word	0x58000400
24015c8c:	58024400 	.word	0x58024400
24015c90:	238d100a 	.word	0x238d100a

24015c94 <MX_GPIO_Init>:
  * @brief GPIO Initialization Function
  * @param None
  * @retval None
  */
static void MX_GPIO_Init(void)
{
24015c94:	b580      	push	{r7, lr}
24015c96:	b08e      	sub	sp, #56	; 0x38
24015c98:	af00      	add	r7, sp, #0
	GPIO_InitTypeDef GPIO_InitStruct = {0};
24015c9a:	f107 0324 	add.w	r3, r7, #36	; 0x24
24015c9e:	2200      	movs	r2, #0
24015ca0:	601a      	str	r2, [r3, #0]
24015ca2:	605a      	str	r2, [r3, #4]
24015ca4:	609a      	str	r2, [r3, #8]
24015ca6:	60da      	str	r2, [r3, #12]
24015ca8:	611a      	str	r2, [r3, #16]

	/* GPIO Ports Clock Enable */
	__HAL_RCC_GPIOE_CLK_ENABLE();
24015caa:	4b4d      	ldr	r3, [pc, #308]	; (24015de0 <MX_GPIO_Init+0x14c>)
24015cac:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
24015cb0:	4a4b      	ldr	r2, [pc, #300]	; (24015de0 <MX_GPIO_Init+0x14c>)
24015cb2:	f043 0310 	orr.w	r3, r3, #16
24015cb6:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
24015cba:	4b49      	ldr	r3, [pc, #292]	; (24015de0 <MX_GPIO_Init+0x14c>)
24015cbc:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
24015cc0:	f003 0310 	and.w	r3, r3, #16
24015cc4:	623b      	str	r3, [r7, #32]
24015cc6:	6a3b      	ldr	r3, [r7, #32]
	__HAL_RCC_GPIOC_CLK_ENABLE();
24015cc8:	4b45      	ldr	r3, [pc, #276]	; (24015de0 <MX_GPIO_Init+0x14c>)
24015cca:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
24015cce:	4a44      	ldr	r2, [pc, #272]	; (24015de0 <MX_GPIO_Init+0x14c>)
24015cd0:	f043 0304 	orr.w	r3, r3, #4
24015cd4:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
24015cd8:	4b41      	ldr	r3, [pc, #260]	; (24015de0 <MX_GPIO_Init+0x14c>)
24015cda:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
24015cde:	f003 0304 	and.w	r3, r3, #4
24015ce2:	61fb      	str	r3, [r7, #28]
24015ce4:	69fb      	ldr	r3, [r7, #28]
	__HAL_RCC_GPIOI_CLK_ENABLE();
24015ce6:	4b3e      	ldr	r3, [pc, #248]	; (24015de0 <MX_GPIO_Init+0x14c>)
24015ce8:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
24015cec:	4a3c      	ldr	r2, [pc, #240]	; (24015de0 <MX_GPIO_Init+0x14c>)
24015cee:	f443 7380 	orr.w	r3, r3, #256	; 0x100
24015cf2:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
24015cf6:	4b3a      	ldr	r3, [pc, #232]	; (24015de0 <MX_GPIO_Init+0x14c>)
24015cf8:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
24015cfc:	f403 7380 	and.w	r3, r3, #256	; 0x100
24015d00:	61bb      	str	r3, [r7, #24]
24015d02:	69bb      	ldr	r3, [r7, #24]
	__HAL_RCC_GPIOF_CLK_ENABLE();
24015d04:	4b36      	ldr	r3, [pc, #216]	; (24015de0 <MX_GPIO_Init+0x14c>)
24015d06:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
24015d0a:	4a35      	ldr	r2, [pc, #212]	; (24015de0 <MX_GPIO_Init+0x14c>)
24015d0c:	f043 0320 	orr.w	r3, r3, #32
24015d10:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
24015d14:	4b32      	ldr	r3, [pc, #200]	; (24015de0 <MX_GPIO_Init+0x14c>)
24015d16:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
24015d1a:	f003 0320 	and.w	r3, r3, #32
24015d1e:	617b      	str	r3, [r7, #20]
24015d20:	697b      	ldr	r3, [r7, #20]
	__HAL_RCC_GPIOH_CLK_ENABLE();
24015d22:	4b2f      	ldr	r3, [pc, #188]	; (24015de0 <MX_GPIO_Init+0x14c>)
24015d24:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
24015d28:	4a2d      	ldr	r2, [pc, #180]	; (24015de0 <MX_GPIO_Init+0x14c>)
24015d2a:	f043 0380 	orr.w	r3, r3, #128	; 0x80
24015d2e:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
24015d32:	4b2b      	ldr	r3, [pc, #172]	; (24015de0 <MX_GPIO_Init+0x14c>)
24015d34:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
24015d38:	f003 0380 	and.w	r3, r3, #128	; 0x80
24015d3c:	613b      	str	r3, [r7, #16]
24015d3e:	693b      	ldr	r3, [r7, #16]
	__HAL_RCC_GPIOA_CLK_ENABLE();
24015d40:	4b27      	ldr	r3, [pc, #156]	; (24015de0 <MX_GPIO_Init+0x14c>)
24015d42:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
24015d46:	4a26      	ldr	r2, [pc, #152]	; (24015de0 <MX_GPIO_Init+0x14c>)
24015d48:	f043 0301 	orr.w	r3, r3, #1
24015d4c:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
24015d50:	4b23      	ldr	r3, [pc, #140]	; (24015de0 <MX_GPIO_Init+0x14c>)
24015d52:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
24015d56:	f003 0301 	and.w	r3, r3, #1
24015d5a:	60fb      	str	r3, [r7, #12]
24015d5c:	68fb      	ldr	r3, [r7, #12]
	__HAL_RCC_GPIOB_CLK_ENABLE();
24015d5e:	4b20      	ldr	r3, [pc, #128]	; (24015de0 <MX_GPIO_Init+0x14c>)
24015d60:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
24015d64:	4a1e      	ldr	r2, [pc, #120]	; (24015de0 <MX_GPIO_Init+0x14c>)
24015d66:	f043 0302 	orr.w	r3, r3, #2
24015d6a:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
24015d6e:	4b1c      	ldr	r3, [pc, #112]	; (24015de0 <MX_GPIO_Init+0x14c>)
24015d70:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
24015d74:	f003 0302 	and.w	r3, r3, #2
24015d78:	60bb      	str	r3, [r7, #8]
24015d7a:	68bb      	ldr	r3, [r7, #8]
	__HAL_RCC_GPIOG_CLK_ENABLE();
24015d7c:	4b18      	ldr	r3, [pc, #96]	; (24015de0 <MX_GPIO_Init+0x14c>)
24015d7e:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
24015d82:	4a17      	ldr	r2, [pc, #92]	; (24015de0 <MX_GPIO_Init+0x14c>)
24015d84:	f043 0340 	orr.w	r3, r3, #64	; 0x40
24015d88:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
24015d8c:	4b14      	ldr	r3, [pc, #80]	; (24015de0 <MX_GPIO_Init+0x14c>)
24015d8e:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
24015d92:	f003 0340 	and.w	r3, r3, #64	; 0x40
24015d96:	607b      	str	r3, [r7, #4]
24015d98:	687b      	ldr	r3, [r7, #4]
	__HAL_RCC_GPIOD_CLK_ENABLE();
24015d9a:	4b11      	ldr	r3, [pc, #68]	; (24015de0 <MX_GPIO_Init+0x14c>)
24015d9c:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
24015da0:	4a0f      	ldr	r2, [pc, #60]	; (24015de0 <MX_GPIO_Init+0x14c>)
24015da2:	f043 0308 	orr.w	r3, r3, #8
24015da6:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
24015daa:	4b0d      	ldr	r3, [pc, #52]	; (24015de0 <MX_GPIO_Init+0x14c>)
24015dac:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
24015db0:	f003 0308 	and.w	r3, r3, #8
24015db4:	603b      	str	r3, [r7, #0]
24015db6:	683b      	ldr	r3, [r7, #0]


;

	/*Configure GPIO pins : LED_STATUS_Pin USB_EN_Pin */
	GPIO_InitStruct.Pin = LED_STATUS_Pin;
24015db8:	f44f 5300 	mov.w	r3, #8192	; 0x2000
24015dbc:	627b      	str	r3, [r7, #36]	; 0x24
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
24015dbe:	2301      	movs	r3, #1
24015dc0:	62bb      	str	r3, [r7, #40]	; 0x28
	GPIO_InitStruct.Pull = GPIO_NOPULL;
24015dc2:	2300      	movs	r3, #0
24015dc4:	62fb      	str	r3, [r7, #44]	; 0x2c
	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
24015dc6:	2300      	movs	r3, #0
24015dc8:	633b      	str	r3, [r7, #48]	; 0x30
	HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
24015dca:	f107 0324 	add.w	r3, r7, #36	; 0x24
24015dce:	4619      	mov	r1, r3
24015dd0:	4804      	ldr	r0, [pc, #16]	; (24015de4 <MX_GPIO_Init+0x150>)
24015dd2:	f7f2 fbd9 	bl	24008588 <HAL_GPIO_Init>

}
24015dd6:	bf00      	nop
24015dd8:	3738      	adds	r7, #56	; 0x38
24015dda:	46bd      	mov	sp, r7
24015ddc:	bd80      	pop	{r7, pc}
24015dde:	bf00      	nop
24015de0:	58024400 	.word	0x58024400
24015de4:	58020c00 	.word	0x58020c00

24015de8 <Error_Handler>:
/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
24015de8:	b580      	push	{r7, lr}
24015dea:	af00      	add	r7, sp, #0
	while(1)
	{
		HAL_GPIO_TogglePin(LED_STATUS_GPIO_Port, LED_STATUS_Pin);
24015dec:	f44f 5100 	mov.w	r1, #8192	; 0x2000
24015df0:	4803      	ldr	r0, [pc, #12]	; (24015e00 <Error_Handler+0x18>)
24015df2:	f7f2 feb4 	bl	24008b5e <HAL_GPIO_TogglePin>
		HAL_Delay(500);
24015df6:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
24015dfa:	f7ea fd75 	bl	240008e8 <HAL_Delay>
		HAL_GPIO_TogglePin(LED_STATUS_GPIO_Port, LED_STATUS_Pin);
24015dfe:	e7f5      	b.n	24015dec <Error_Handler+0x4>
24015e00:	58020c00 	.word	0x58020c00

24015e04 <QSPI_ReadStatus>:
static uint8_t QSPI_WriteStatus(uint8_t command, uint8_t* value, uint32_t length);

extern void Error_Handler(void);

static uint8_t QSPI_ReadStatus(uint8_t command, uint8_t* value)
{
24015e04:	b580      	push	{r7, lr}
24015e06:	b092      	sub	sp, #72	; 0x48
24015e08:	af00      	add	r7, sp, #0
24015e0a:	4603      	mov	r3, r0
24015e0c:	6039      	str	r1, [r7, #0]
24015e0e:	71fb      	strb	r3, [r7, #7]
	QSPI_CommandTypeDef sCommand;
	uint8_t reg;

	sCommand.InstructionMode = QSPI_INSTRUCTION_1_LINE;
24015e10:	f44f 7380 	mov.w	r3, #256	; 0x100
24015e14:	62bb      	str	r3, [r7, #40]	; 0x28
	sCommand.Instruction = (uint32_t)command;
24015e16:	79fb      	ldrb	r3, [r7, #7]
24015e18:	613b      	str	r3, [r7, #16]
	sCommand.AddressMode       = QSPI_ADDRESS_NONE;
24015e1a:	2300      	movs	r3, #0
24015e1c:	62fb      	str	r3, [r7, #44]	; 0x2c
	sCommand.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
24015e1e:	2300      	movs	r3, #0
24015e20:	633b      	str	r3, [r7, #48]	; 0x30
	sCommand.DataMode          = QSPI_DATA_1_LINE;
24015e22:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
24015e26:	637b      	str	r3, [r7, #52]	; 0x34
	sCommand.DummyCycles       = 0;
24015e28:	2300      	movs	r3, #0
24015e2a:	627b      	str	r3, [r7, #36]	; 0x24
	sCommand.NbData            = 1;
24015e2c:	2301      	movs	r3, #1
24015e2e:	63bb      	str	r3, [r7, #56]	; 0x38
	sCommand.DdrMode           = QSPI_DDR_MODE_DISABLE;
24015e30:	2300      	movs	r3, #0
24015e32:	63fb      	str	r3, [r7, #60]	; 0x3c
	sCommand.DdrHoldHalfCycle  = QSPI_DDR_HHC_ANALOG_DELAY;
24015e34:	2300      	movs	r3, #0
24015e36:	643b      	str	r3, [r7, #64]	; 0x40
	sCommand.SIOOMode          = QSPI_SIOO_INST_EVERY_CMD;
24015e38:	2300      	movs	r3, #0
24015e3a:	647b      	str	r3, [r7, #68]	; 0x44

	/* Configure the command */
	if(HAL_QSPI_Command(&hqspi, &sCommand, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
24015e3c:	f107 0310 	add.w	r3, r7, #16
24015e40:	f241 3288 	movw	r2, #5000	; 0x1388
24015e44:	4619      	mov	r1, r3
24015e46:	480e      	ldr	r0, [pc, #56]	; (24015e80 <QSPI_ReadStatus+0x7c>)
24015e48:	f7fa fc8c 	bl	24010764 <HAL_QSPI_Command>
24015e4c:	4603      	mov	r3, r0
24015e4e:	2b00      	cmp	r3, #0
24015e50:	d001      	beq.n	24015e56 <QSPI_ReadStatus+0x52>
	{
		return HAL_ERROR;
24015e52:	2301      	movs	r3, #1
24015e54:	e010      	b.n	24015e78 <QSPI_ReadStatus+0x74>
	}

	/* Reception of the data */
	if(HAL_QSPI_Receive(&hqspi, &reg, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
24015e56:	f107 030f 	add.w	r3, r7, #15
24015e5a:	f241 3288 	movw	r2, #5000	; 0x1388
24015e5e:	4619      	mov	r1, r3
24015e60:	4807      	ldr	r0, [pc, #28]	; (24015e80 <QSPI_ReadStatus+0x7c>)
24015e62:	f7fa fdd5 	bl	24010a10 <HAL_QSPI_Receive>
24015e66:	4603      	mov	r3, r0
24015e68:	2b00      	cmp	r3, #0
24015e6a:	d001      	beq.n	24015e70 <QSPI_ReadStatus+0x6c>
	{
		return HAL_ERROR;
24015e6c:	2301      	movs	r3, #1
24015e6e:	e003      	b.n	24015e78 <QSPI_ReadStatus+0x74>
	}

	*value = reg;
24015e70:	7bfa      	ldrb	r2, [r7, #15]
24015e72:	683b      	ldr	r3, [r7, #0]
24015e74:	701a      	strb	r2, [r3, #0]

	return HAL_OK;
24015e76:	2300      	movs	r3, #0
}
24015e78:	4618      	mov	r0, r3
24015e7a:	3748      	adds	r7, #72	; 0x48
24015e7c:	46bd      	mov	sp, r7
24015e7e:	bd80      	pop	{r7, pc}
24015e80:	24000564 	.word	0x24000564

24015e84 <QSPI_WriteStatus>:
static uint8_t QSPI_WriteStatus(uint8_t command, uint8_t* value, uint32_t length)
{
24015e84:	b580      	push	{r7, lr}
24015e86:	b092      	sub	sp, #72	; 0x48
24015e88:	af00      	add	r7, sp, #0
24015e8a:	4603      	mov	r3, r0
24015e8c:	60b9      	str	r1, [r7, #8]
24015e8e:	607a      	str	r2, [r7, #4]
24015e90:	73fb      	strb	r3, [r7, #15]
	QSPI_CommandTypeDef sCommand;

	/* Initialize the program command */
	sCommand.InstructionMode   = QSPI_INSTRUCTION_1_LINE;
24015e92:	f44f 7380 	mov.w	r3, #256	; 0x100
24015e96:	62bb      	str	r3, [r7, #40]	; 0x28
	sCommand.Instruction       = command;
24015e98:	7bfb      	ldrb	r3, [r7, #15]
24015e9a:	613b      	str	r3, [r7, #16]
	sCommand.AddressMode       = QSPI_ADDRESS_NONE;
24015e9c:	2300      	movs	r3, #0
24015e9e:	62fb      	str	r3, [r7, #44]	; 0x2c
	sCommand.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
24015ea0:	2300      	movs	r3, #0
24015ea2:	633b      	str	r3, [r7, #48]	; 0x30
	sCommand.DataMode          = QSPI_DATA_1_LINE;
24015ea4:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
24015ea8:	637b      	str	r3, [r7, #52]	; 0x34
	sCommand.DummyCycles       = 0;
24015eaa:	2300      	movs	r3, #0
24015eac:	627b      	str	r3, [r7, #36]	; 0x24
	sCommand.NbData            = length;
24015eae:	687b      	ldr	r3, [r7, #4]
24015eb0:	63bb      	str	r3, [r7, #56]	; 0x38
	sCommand.DdrMode           = QSPI_DDR_MODE_DISABLE;
24015eb2:	2300      	movs	r3, #0
24015eb4:	63fb      	str	r3, [r7, #60]	; 0x3c
	sCommand.DdrHoldHalfCycle  = QSPI_DDR_HHC_ANALOG_DELAY;
24015eb6:	2300      	movs	r3, #0
24015eb8:	643b      	str	r3, [r7, #64]	; 0x40
	sCommand.SIOOMode          = QSPI_SIOO_INST_EVERY_CMD;
24015eba:	2300      	movs	r3, #0
24015ebc:	647b      	str	r3, [r7, #68]	; 0x44

	/* Enable write operations */
	if(QSPI_WriteEnable() != HAL_OK)
24015ebe:	f000 f901 	bl	240160c4 <QSPI_WriteEnable>
24015ec2:	4603      	mov	r3, r0
24015ec4:	2b00      	cmp	r3, #0
24015ec6:	d001      	beq.n	24015ecc <QSPI_WriteStatus+0x48>
	{
		return HAL_ERROR;
24015ec8:	2301      	movs	r3, #1
24015eca:	e021      	b.n	24015f10 <QSPI_WriteStatus+0x8c>
	}

	/* Configure the command */
	if(HAL_QSPI_Command(&hqspi, &sCommand, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
24015ecc:	f107 0310 	add.w	r3, r7, #16
24015ed0:	f241 3288 	movw	r2, #5000	; 0x1388
24015ed4:	4619      	mov	r1, r3
24015ed6:	4810      	ldr	r0, [pc, #64]	; (24015f18 <QSPI_WriteStatus+0x94>)
24015ed8:	f7fa fc44 	bl	24010764 <HAL_QSPI_Command>
24015edc:	4603      	mov	r3, r0
24015ede:	2b00      	cmp	r3, #0
24015ee0:	d001      	beq.n	24015ee6 <QSPI_WriteStatus+0x62>
	{
		return HAL_ERROR;
24015ee2:	2301      	movs	r3, #1
24015ee4:	e014      	b.n	24015f10 <QSPI_WriteStatus+0x8c>
	}

	/* Transmission of the data */
	if(HAL_QSPI_Transmit(&hqspi, value, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
24015ee6:	f241 3288 	movw	r2, #5000	; 0x1388
24015eea:	68b9      	ldr	r1, [r7, #8]
24015eec:	480a      	ldr	r0, [pc, #40]	; (24015f18 <QSPI_WriteStatus+0x94>)
24015eee:	f7fa fcfd 	bl	240108ec <HAL_QSPI_Transmit>
24015ef2:	4603      	mov	r3, r0
24015ef4:	2b00      	cmp	r3, #0
24015ef6:	d001      	beq.n	24015efc <QSPI_WriteStatus+0x78>
	{
		return HAL_ERROR;
24015ef8:	2301      	movs	r3, #1
24015efa:	e009      	b.n	24015f10 <QSPI_WriteStatus+0x8c>
	}

	/* Configure automatic polling mode to wait for end of program */
	if(QSPI_AutoPollingMemReady(HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
24015efc:	f241 3088 	movw	r0, #5000	; 0x1388
24015f00:	f000 f8a6 	bl	24016050 <QSPI_AutoPollingMemReady>
24015f04:	4603      	mov	r3, r0
24015f06:	2b00      	cmp	r3, #0
24015f08:	d001      	beq.n	24015f0e <QSPI_WriteStatus+0x8a>
	{
		return HAL_ERROR;
24015f0a:	2301      	movs	r3, #1
24015f0c:	e000      	b.n	24015f10 <QSPI_WriteStatus+0x8c>
	}

	return HAL_OK;
24015f0e:	2300      	movs	r3, #0

}
24015f10:	4618      	mov	r0, r3
24015f12:	3748      	adds	r7, #72	; 0x48
24015f14:	46bd      	mov	sp, r7
24015f16:	bd80      	pop	{r7, pc}
24015f18:	24000564 	.word	0x24000564

24015f1c <MX_QUADSPI_Init>:
void MX_QUADSPI_Init(void)
{
24015f1c:	b580      	push	{r7, lr}
24015f1e:	b082      	sub	sp, #8
24015f20:	af00      	add	r7, sp, #0
    hqspi.Instance = QUADSPI;
24015f22:	4b19      	ldr	r3, [pc, #100]	; (24015f88 <MX_QUADSPI_Init+0x6c>)
24015f24:	4a19      	ldr	r2, [pc, #100]	; (24015f8c <MX_QUADSPI_Init+0x70>)
24015f26:	601a      	str	r2, [r3, #0]
    hqspi.Init.ClockPrescaler = 1;
24015f28:	4b17      	ldr	r3, [pc, #92]	; (24015f88 <MX_QUADSPI_Init+0x6c>)
24015f2a:	2201      	movs	r2, #1
24015f2c:	605a      	str	r2, [r3, #4]
    hqspi.Init.FifoThreshold = 4;
24015f2e:	4b16      	ldr	r3, [pc, #88]	; (24015f88 <MX_QUADSPI_Init+0x6c>)
24015f30:	2204      	movs	r2, #4
24015f32:	609a      	str	r2, [r3, #8]
    hqspi.Init.SampleShifting = QSPI_SAMPLE_SHIFTING_NONE;
24015f34:	4b14      	ldr	r3, [pc, #80]	; (24015f88 <MX_QUADSPI_Init+0x6c>)
24015f36:	2200      	movs	r2, #0
24015f38:	60da      	str	r2, [r3, #12]
24015f3a:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
24015f3e:	607b      	str	r3, [r7, #4]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
24015f40:	687b      	ldr	r3, [r7, #4]
24015f42:	fa93 f3a3 	rbit	r3, r3
24015f46:	603b      	str	r3, [r7, #0]
  return result;
24015f48:	683b      	ldr	r3, [r7, #0]
    hqspi.Init.FlashSize = POSITION_VAL(MEMORY_FLASH_SIZE) - 1;
24015f4a:	fab3 f383 	clz	r3, r3
24015f4e:	b2db      	uxtb	r3, r3
24015f50:	3b01      	subs	r3, #1
24015f52:	461a      	mov	r2, r3
24015f54:	4b0c      	ldr	r3, [pc, #48]	; (24015f88 <MX_QUADSPI_Init+0x6c>)
24015f56:	611a      	str	r2, [r3, #16]
    hqspi.Init.ChipSelectHighTime = QSPI_CS_HIGH_TIME_1_CYCLE;
24015f58:	4b0b      	ldr	r3, [pc, #44]	; (24015f88 <MX_QUADSPI_Init+0x6c>)
24015f5a:	2200      	movs	r2, #0
24015f5c:	615a      	str	r2, [r3, #20]
    hqspi.Init.ClockMode = QSPI_CLOCK_MODE_0;
24015f5e:	4b0a      	ldr	r3, [pc, #40]	; (24015f88 <MX_QUADSPI_Init+0x6c>)
24015f60:	2200      	movs	r2, #0
24015f62:	619a      	str	r2, [r3, #24]
    hqspi.Init.FlashID = QSPI_FLASH_ID_1;
24015f64:	4b08      	ldr	r3, [pc, #32]	; (24015f88 <MX_QUADSPI_Init+0x6c>)
24015f66:	2200      	movs	r2, #0
24015f68:	61da      	str	r2, [r3, #28]
    hqspi.Init.DualFlash = QSPI_DUALFLASH_DISABLE;
24015f6a:	4b07      	ldr	r3, [pc, #28]	; (24015f88 <MX_QUADSPI_Init+0x6c>)
24015f6c:	2200      	movs	r2, #0
24015f6e:	621a      	str	r2, [r3, #32]
    if(HAL_QSPI_Init(&hqspi) != HAL_OK)
24015f70:	4805      	ldr	r0, [pc, #20]	; (24015f88 <MX_QUADSPI_Init+0x6c>)
24015f72:	f7fa f995 	bl	240102a0 <HAL_QSPI_Init>
24015f76:	4603      	mov	r3, r0
24015f78:	2b00      	cmp	r3, #0
24015f7a:	d001      	beq.n	24015f80 <MX_QUADSPI_Init+0x64>
    {
        Error_Handler();
24015f7c:	f7ff ff34 	bl	24015de8 <Error_Handler>
    }
}
24015f80:	bf00      	nop
24015f82:	3708      	adds	r7, #8
24015f84:	46bd      	mov	sp, r7
24015f86:	bd80      	pop	{r7, pc}
24015f88:	24000564 	.word	0x24000564
24015f8c:	52005000 	.word	0x52005000

24015f90 <CSP_QUADSPI_Init>:


uint8_t CSP_QUADSPI_Init(void)
{
24015f90:	b580      	push	{r7, lr}
24015f92:	af00      	add	r7, sp, #0
    //prepare QSPI peripheral for ST-Link Utility operations
	hqspi.Instance = QUADSPI;
24015f94:	4b0e      	ldr	r3, [pc, #56]	; (24015fd0 <CSP_QUADSPI_Init+0x40>)
24015f96:	4a0f      	ldr	r2, [pc, #60]	; (24015fd4 <CSP_QUADSPI_Init+0x44>)
24015f98:	601a      	str	r2, [r3, #0]
    if (HAL_QSPI_DeInit(&hqspi) != HAL_OK)
24015f9a:	480d      	ldr	r0, [pc, #52]	; (24015fd0 <CSP_QUADSPI_Init+0x40>)
24015f9c:	f7fa f9f4 	bl	24010388 <HAL_QSPI_DeInit>
24015fa0:	4603      	mov	r3, r0
24015fa2:	2b00      	cmp	r3, #0
24015fa4:	d001      	beq.n	24015faa <CSP_QUADSPI_Init+0x1a>
    {
        return HAL_ERROR;
24015fa6:	2301      	movs	r3, #1
24015fa8:	e010      	b.n	24015fcc <CSP_QUADSPI_Init+0x3c>
    }

    MX_QUADSPI_Init();
24015faa:	f7ff ffb7 	bl	24015f1c <MX_QUADSPI_Init>

    if (QSPI_ResetChip() != HAL_OK)
24015fae:	f000 fa11 	bl	240163d4 <QSPI_ResetChip>
24015fb2:	4603      	mov	r3, r0
24015fb4:	2b00      	cmp	r3, #0
24015fb6:	d001      	beq.n	24015fbc <CSP_QUADSPI_Init+0x2c>
    {
        return HAL_ERROR;
24015fb8:	2301      	movs	r3, #1
24015fba:	e007      	b.n	24015fcc <CSP_QUADSPI_Init+0x3c>
    }

    if (QSPI_Configuration() != HAL_OK)
24015fbc:	f000 f8cc 	bl	24016158 <QSPI_Configuration>
24015fc0:	4603      	mov	r3, r0
24015fc2:	2b00      	cmp	r3, #0
24015fc4:	d001      	beq.n	24015fca <CSP_QUADSPI_Init+0x3a>
    {
        return HAL_ERROR;
24015fc6:	2301      	movs	r3, #1
24015fc8:	e000      	b.n	24015fcc <CSP_QUADSPI_Init+0x3c>
    }

    return HAL_OK;
24015fca:	2300      	movs	r3, #0
}
24015fcc:	4618      	mov	r0, r3
24015fce:	bd80      	pop	{r7, pc}
24015fd0:	24000564 	.word	0x24000564
24015fd4:	52005000 	.word	0x52005000

24015fd8 <CSP_QSPI_Erase_Chip>:


uint8_t CSP_QSPI_Erase_Chip(void)
{
24015fd8:	b580      	push	{r7, lr}
24015fda:	b08e      	sub	sp, #56	; 0x38
24015fdc:	af00      	add	r7, sp, #0
    QSPI_CommandTypeDef sCommand;

    /* Erasing Sequence --------------------------------- */
    sCommand.Instruction = CHIP_ERASE_CMD;
24015fde:	23c7      	movs	r3, #199	; 0xc7
24015fe0:	603b      	str	r3, [r7, #0]
    sCommand.InstructionMode = QSPI_INSTRUCTION_1_LINE;
24015fe2:	f44f 7380 	mov.w	r3, #256	; 0x100
24015fe6:	61bb      	str	r3, [r7, #24]
    sCommand.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
24015fe8:	2300      	movs	r3, #0
24015fea:	623b      	str	r3, [r7, #32]
    sCommand.DdrMode = QSPI_DDR_MODE_DISABLE;
24015fec:	2300      	movs	r3, #0
24015fee:	62fb      	str	r3, [r7, #44]	; 0x2c
    sCommand.DdrHoldHalfCycle = QSPI_DDR_HHC_ANALOG_DELAY;
24015ff0:	2300      	movs	r3, #0
24015ff2:	633b      	str	r3, [r7, #48]	; 0x30
    sCommand.SIOOMode = QSPI_SIOO_INST_EVERY_CMD;
24015ff4:	2300      	movs	r3, #0
24015ff6:	637b      	str	r3, [r7, #52]	; 0x34
    sCommand.AddressMode = QSPI_ADDRESS_NONE;
24015ff8:	2300      	movs	r3, #0
24015ffa:	61fb      	str	r3, [r7, #28]
    sCommand.Address = 0;
24015ffc:	2300      	movs	r3, #0
24015ffe:	607b      	str	r3, [r7, #4]
    sCommand.DataMode = QSPI_DATA_NONE;
24016000:	2300      	movs	r3, #0
24016002:	627b      	str	r3, [r7, #36]	; 0x24
    sCommand.DummyCycles = 0;
24016004:	2300      	movs	r3, #0
24016006:	617b      	str	r3, [r7, #20]

    if(QSPI_WriteEnable() != HAL_OK)
24016008:	f000 f85c 	bl	240160c4 <QSPI_WriteEnable>
2401600c:	4603      	mov	r3, r0
2401600e:	2b00      	cmp	r3, #0
24016010:	d001      	beq.n	24016016 <CSP_QSPI_Erase_Chip+0x3e>
  	{
      	return HAL_ERROR;
24016012:	2301      	movs	r3, #1
24016014:	e014      	b.n	24016040 <CSP_QSPI_Erase_Chip+0x68>
  	}

    if(HAL_QSPI_Command(&hqspi, &sCommand, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
24016016:	463b      	mov	r3, r7
24016018:	f241 3288 	movw	r2, #5000	; 0x1388
2401601c:	4619      	mov	r1, r3
2401601e:	480a      	ldr	r0, [pc, #40]	; (24016048 <CSP_QSPI_Erase_Chip+0x70>)
24016020:	f7fa fba0 	bl	24010764 <HAL_QSPI_Command>
24016024:	4603      	mov	r3, r0
24016026:	2b00      	cmp	r3, #0
24016028:	d001      	beq.n	2401602e <CSP_QSPI_Erase_Chip+0x56>
    {
        return HAL_ERROR;
2401602a:	2301      	movs	r3, #1
2401602c:	e008      	b.n	24016040 <CSP_QSPI_Erase_Chip+0x68>
    }

    if(QSPI_AutoPollingMemReady(BULK_ERASE_MAX_TIME) != HAL_OK)
2401602e:	4807      	ldr	r0, [pc, #28]	; (2401604c <CSP_QSPI_Erase_Chip+0x74>)
24016030:	f000 f80e 	bl	24016050 <QSPI_AutoPollingMemReady>
24016034:	4603      	mov	r3, r0
24016036:	2b00      	cmp	r3, #0
24016038:	d001      	beq.n	2401603e <CSP_QSPI_Erase_Chip+0x66>
    {
        return HAL_ERROR;
2401603a:	2301      	movs	r3, #1
2401603c:	e000      	b.n	24016040 <CSP_QSPI_Erase_Chip+0x68>
    }

    return HAL_OK;
2401603e:	2300      	movs	r3, #0
}
24016040:	4618      	mov	r0, r3
24016042:	3738      	adds	r7, #56	; 0x38
24016044:	46bd      	mov	sp, r7
24016046:	bd80      	pop	{r7, pc}
24016048:	24000564 	.word	0x24000564
2401604c:	0003d090 	.word	0x0003d090

24016050 <QSPI_AutoPollingMemReady>:

uint8_t QSPI_AutoPollingMemReady(uint32_t time)
{
24016050:	b580      	push	{r7, lr}
24016052:	b096      	sub	sp, #88	; 0x58
24016054:	af00      	add	r7, sp, #0
24016056:	6078      	str	r0, [r7, #4]

    QSPI_CommandTypeDef sCommand;
    QSPI_AutoPollingTypeDef sConfig;

    /* Configure automatic polling mode to wait for memory ready ------ */
    sCommand.InstructionMode = QSPI_INSTRUCTION_1_LINE;
24016058:	f44f 7380 	mov.w	r3, #256	; 0x100
2401605c:	63bb      	str	r3, [r7, #56]	; 0x38
    sCommand.Instruction = READ_STATUS_REG_CMD;
2401605e:	2305      	movs	r3, #5
24016060:	623b      	str	r3, [r7, #32]
    sCommand.AddressMode = QSPI_ADDRESS_NONE;
24016062:	2300      	movs	r3, #0
24016064:	63fb      	str	r3, [r7, #60]	; 0x3c
    sCommand.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
24016066:	2300      	movs	r3, #0
24016068:	643b      	str	r3, [r7, #64]	; 0x40
    sCommand.DataMode = QSPI_DATA_1_LINE;
2401606a:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2401606e:	647b      	str	r3, [r7, #68]	; 0x44
    sCommand.DummyCycles = 0;
24016070:	2300      	movs	r3, #0
24016072:	637b      	str	r3, [r7, #52]	; 0x34
    sCommand.DdrMode = QSPI_DDR_MODE_DISABLE;
24016074:	2300      	movs	r3, #0
24016076:	64fb      	str	r3, [r7, #76]	; 0x4c
    sCommand.DdrHoldHalfCycle = QSPI_DDR_HHC_ANALOG_DELAY;
24016078:	2300      	movs	r3, #0
2401607a:	653b      	str	r3, [r7, #80]	; 0x50
    sCommand.SIOOMode = QSPI_SIOO_INST_EVERY_CMD;
2401607c:	2300      	movs	r3, #0
2401607e:	657b      	str	r3, [r7, #84]	; 0x54

    sConfig.Match = 0x00;
24016080:	2300      	movs	r3, #0
24016082:	60bb      	str	r3, [r7, #8]
    sConfig.Mask = 0x01;
24016084:	2301      	movs	r3, #1
24016086:	60fb      	str	r3, [r7, #12]
    sConfig.MatchMode = QSPI_MATCH_MODE_AND;
24016088:	2300      	movs	r3, #0
2401608a:	61bb      	str	r3, [r7, #24]
    sConfig.StatusBytesSize = 1;
2401608c:	2301      	movs	r3, #1
2401608e:	617b      	str	r3, [r7, #20]
    sConfig.Interval = 0x10;
24016090:	2310      	movs	r3, #16
24016092:	613b      	str	r3, [r7, #16]
    sConfig.AutomaticStop = QSPI_AUTOMATIC_STOP_ENABLE;
24016094:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
24016098:	61fb      	str	r3, [r7, #28]

    if (HAL_QSPI_AutoPolling(&hqspi, &sCommand, &sConfig, time) != HAL_OK)
2401609a:	f107 0208 	add.w	r2, r7, #8
2401609e:	f107 0120 	add.w	r1, r7, #32
240160a2:	687b      	ldr	r3, [r7, #4]
240160a4:	4806      	ldr	r0, [pc, #24]	; (240160c0 <QSPI_AutoPollingMemReady+0x70>)
240160a6:	f7fb f80b 	bl	240110c0 <HAL_QSPI_AutoPolling>
240160aa:	4603      	mov	r3, r0
240160ac:	2b00      	cmp	r3, #0
240160ae:	d001      	beq.n	240160b4 <QSPI_AutoPollingMemReady+0x64>
    {
        return HAL_ERROR;
240160b0:	2301      	movs	r3, #1
240160b2:	e000      	b.n	240160b6 <QSPI_AutoPollingMemReady+0x66>
    }

    return HAL_OK;
240160b4:	2300      	movs	r3, #0
}
240160b6:	4618      	mov	r0, r3
240160b8:	3758      	adds	r7, #88	; 0x58
240160ba:	46bd      	mov	sp, r7
240160bc:	bd80      	pop	{r7, pc}
240160be:	bf00      	nop
240160c0:	24000564 	.word	0x24000564

240160c4 <QSPI_WriteEnable>:

static uint8_t QSPI_WriteEnable(void)
{
240160c4:	b580      	push	{r7, lr}
240160c6:	b094      	sub	sp, #80	; 0x50
240160c8:	af00      	add	r7, sp, #0
    QSPI_CommandTypeDef sCommand;
    QSPI_AutoPollingTypeDef sConfig;

    /* Enable write operations ------------------------------------------ */
    sCommand.InstructionMode = QSPI_INSTRUCTION_1_LINE;
240160ca:	f44f 7380 	mov.w	r3, #256	; 0x100
240160ce:	633b      	str	r3, [r7, #48]	; 0x30
    sCommand.Instruction = WRITE_ENABLE_CMD;
240160d0:	2306      	movs	r3, #6
240160d2:	61bb      	str	r3, [r7, #24]
    sCommand.AddressMode = QSPI_ADDRESS_NONE;
240160d4:	2300      	movs	r3, #0
240160d6:	637b      	str	r3, [r7, #52]	; 0x34
    sCommand.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
240160d8:	2300      	movs	r3, #0
240160da:	63bb      	str	r3, [r7, #56]	; 0x38
    sCommand.DataMode = QSPI_DATA_NONE;
240160dc:	2300      	movs	r3, #0
240160de:	63fb      	str	r3, [r7, #60]	; 0x3c
    sCommand.DummyCycles = 0;
240160e0:	2300      	movs	r3, #0
240160e2:	62fb      	str	r3, [r7, #44]	; 0x2c
    sCommand.DdrMode = QSPI_DDR_MODE_DISABLE;
240160e4:	2300      	movs	r3, #0
240160e6:	647b      	str	r3, [r7, #68]	; 0x44
    sCommand.DdrHoldHalfCycle = QSPI_DDR_HHC_ANALOG_DELAY;
240160e8:	2300      	movs	r3, #0
240160ea:	64bb      	str	r3, [r7, #72]	; 0x48
    sCommand.SIOOMode = QSPI_SIOO_INST_EVERY_CMD;
240160ec:	2300      	movs	r3, #0
240160ee:	64fb      	str	r3, [r7, #76]	; 0x4c

    if(HAL_QSPI_Command(&hqspi, &sCommand, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
240160f0:	f107 0318 	add.w	r3, r7, #24
240160f4:	f241 3288 	movw	r2, #5000	; 0x1388
240160f8:	4619      	mov	r1, r3
240160fa:	4816      	ldr	r0, [pc, #88]	; (24016154 <QSPI_WriteEnable+0x90>)
240160fc:	f7fa fb32 	bl	24010764 <HAL_QSPI_Command>
24016100:	4603      	mov	r3, r0
24016102:	2b00      	cmp	r3, #0
24016104:	d001      	beq.n	2401610a <QSPI_WriteEnable+0x46>
    {
        return HAL_ERROR;
24016106:	2301      	movs	r3, #1
24016108:	e01f      	b.n	2401614a <QSPI_WriteEnable+0x86>
    }

    /* Configure automatic polling mode to wait for write enabling ---- */
    sConfig.Match = 0x02;
2401610a:	2302      	movs	r3, #2
2401610c:	603b      	str	r3, [r7, #0]
    sConfig.Mask = 0x02;
2401610e:	2302      	movs	r3, #2
24016110:	607b      	str	r3, [r7, #4]
    sConfig.MatchMode = QSPI_MATCH_MODE_AND;
24016112:	2300      	movs	r3, #0
24016114:	613b      	str	r3, [r7, #16]
    sConfig.StatusBytesSize = 1;
24016116:	2301      	movs	r3, #1
24016118:	60fb      	str	r3, [r7, #12]
    sConfig.Interval = 0x10;
2401611a:	2310      	movs	r3, #16
2401611c:	60bb      	str	r3, [r7, #8]
    sConfig.AutomaticStop = QSPI_AUTOMATIC_STOP_ENABLE;
2401611e:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
24016122:	617b      	str	r3, [r7, #20]

    sCommand.Instruction = READ_STATUS_REG_CMD;
24016124:	2305      	movs	r3, #5
24016126:	61bb      	str	r3, [r7, #24]
    sCommand.DataMode = QSPI_DATA_1_LINE;
24016128:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2401612c:	63fb      	str	r3, [r7, #60]	; 0x3c
    if(HAL_QSPI_AutoPolling(&hqspi, &sCommand, &sConfig, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
2401612e:	463a      	mov	r2, r7
24016130:	f107 0118 	add.w	r1, r7, #24
24016134:	f241 3388 	movw	r3, #5000	; 0x1388
24016138:	4806      	ldr	r0, [pc, #24]	; (24016154 <QSPI_WriteEnable+0x90>)
2401613a:	f7fa ffc1 	bl	240110c0 <HAL_QSPI_AutoPolling>
2401613e:	4603      	mov	r3, r0
24016140:	2b00      	cmp	r3, #0
24016142:	d001      	beq.n	24016148 <QSPI_WriteEnable+0x84>
    {
        return HAL_ERROR;
24016144:	2301      	movs	r3, #1
24016146:	e000      	b.n	2401614a <QSPI_WriteEnable+0x86>
    }

    return HAL_OK;
24016148:	2300      	movs	r3, #0
}
2401614a:	4618      	mov	r0, r3
2401614c:	3750      	adds	r7, #80	; 0x50
2401614e:	46bd      	mov	sp, r7
24016150:	bd80      	pop	{r7, pc}
24016152:	bf00      	nop
24016154:	24000564 	.word	0x24000564

24016158 <QSPI_Configuration>:
/*Enable quad mode and set dummy cycles count*/
uint8_t QSPI_Configuration(void)
{
24016158:	b580      	push	{r7, lr}
2401615a:	b082      	sub	sp, #8
2401615c:	af00      	add	r7, sp, #0
	uint8_t reg = 0;
2401615e:	2300      	movs	r3, #0
24016160:	71fb      	strb	r3, [r7, #7]
	uint8_t regs[2] = {2, 0};
24016162:	2302      	movs	r3, #2
24016164:	713b      	strb	r3, [r7, #4]
24016166:	2300      	movs	r3, #0
24016168:	717b      	strb	r3, [r7, #5]


	if(QSPI_ReadStatus(READ_STATUS_REGISTER_2, &reg) != HAL_OK)
2401616a:	1dfb      	adds	r3, r7, #7
2401616c:	4619      	mov	r1, r3
2401616e:	2035      	movs	r0, #53	; 0x35
24016170:	f7ff fe48 	bl	24015e04 <QSPI_ReadStatus>
24016174:	4603      	mov	r3, r0
24016176:	2b00      	cmp	r3, #0
24016178:	d001      	beq.n	2401617e <QSPI_Configuration+0x26>
	{
		return HAL_ERROR;
2401617a:	2301      	movs	r3, #1
2401617c:	e00d      	b.n	2401619a <QSPI_Configuration+0x42>
	}

	reg = 2;
2401617e:	2302      	movs	r3, #2
24016180:	71fb      	strb	r3, [r7, #7]
	if(QSPI_WriteStatus(WRITE_STATUS_REGISTER_1, regs, 2) != HAL_OK)
24016182:	1d3b      	adds	r3, r7, #4
24016184:	2202      	movs	r2, #2
24016186:	4619      	mov	r1, r3
24016188:	2001      	movs	r0, #1
2401618a:	f7ff fe7b 	bl	24015e84 <QSPI_WriteStatus>
2401618e:	4603      	mov	r3, r0
24016190:	2b00      	cmp	r3, #0
24016192:	d001      	beq.n	24016198 <QSPI_Configuration+0x40>
	{
		return HAL_ERROR;
24016194:	2301      	movs	r3, #1
24016196:	e000      	b.n	2401619a <QSPI_Configuration+0x42>
	}

	return HAL_OK;
24016198:	2300      	movs	r3, #0

}
2401619a:	4618      	mov	r0, r3
2401619c:	3708      	adds	r7, #8
2401619e:	46bd      	mov	sp, r7
240161a0:	bd80      	pop	{r7, pc}
	...

240161a4 <CSP_QSPI_EraseSector>:
uint8_t CSP_QSPI_EraseSector(uint32_t EraseStartAddress, uint32_t EraseEndAddress)
{
240161a4:	b580      	push	{r7, lr}
240161a6:	b090      	sub	sp, #64	; 0x40
240161a8:	af00      	add	r7, sp, #0
240161aa:	6078      	str	r0, [r7, #4]
240161ac:	6039      	str	r1, [r7, #0]

    QSPI_CommandTypeDef sCommand;

    EraseStartAddress = EraseStartAddress
240161ae:	687a      	ldr	r2, [r7, #4]
240161b0:	4b24      	ldr	r3, [pc, #144]	; (24016244 <CSP_QSPI_EraseSector+0xa0>)
240161b2:	4013      	ands	r3, r2
240161b4:	607b      	str	r3, [r7, #4]
                        - EraseStartAddress % MEMORY_SECTOR_SIZE;

    /* Erasing Sequence -------------------------------------------------- */
    sCommand.InstructionMode = QSPI_INSTRUCTION_1_LINE;
240161b6:	f44f 7380 	mov.w	r3, #256	; 0x100
240161ba:	623b      	str	r3, [r7, #32]
    sCommand.AddressSize = QSPI_ADDRESS_24_BITS;
240161bc:	f44f 5300 	mov.w	r3, #8192	; 0x2000
240161c0:	617b      	str	r3, [r7, #20]
    sCommand.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
240161c2:	2300      	movs	r3, #0
240161c4:	62bb      	str	r3, [r7, #40]	; 0x28
    sCommand.DdrMode = QSPI_DDR_MODE_DISABLE;
240161c6:	2300      	movs	r3, #0
240161c8:	637b      	str	r3, [r7, #52]	; 0x34
    sCommand.DdrHoldHalfCycle = QSPI_DDR_HHC_ANALOG_DELAY;
240161ca:	2300      	movs	r3, #0
240161cc:	63bb      	str	r3, [r7, #56]	; 0x38
    sCommand.SIOOMode = QSPI_SIOO_INST_EVERY_CMD;
240161ce:	2300      	movs	r3, #0
240161d0:	63fb      	str	r3, [r7, #60]	; 0x3c
    sCommand.Instruction = SECTOR_ERASE_CMD;
240161d2:	23d8      	movs	r3, #216	; 0xd8
240161d4:	60bb      	str	r3, [r7, #8]
    sCommand.AddressMode = QSPI_ADDRESS_1_LINE;
240161d6:	f44f 6380 	mov.w	r3, #1024	; 0x400
240161da:	627b      	str	r3, [r7, #36]	; 0x24

    sCommand.DataMode = QSPI_DATA_NONE;
240161dc:	2300      	movs	r3, #0
240161de:	62fb      	str	r3, [r7, #44]	; 0x2c
    sCommand.DummyCycles = 0;
240161e0:	2300      	movs	r3, #0
240161e2:	61fb      	str	r3, [r7, #28]

    while(EraseEndAddress >= EraseStartAddress)
240161e4:	e024      	b.n	24016230 <CSP_QSPI_EraseSector+0x8c>
    {

    	sCommand.Address = (EraseStartAddress & 0x0fFFFFFF);
240161e6:	687b      	ldr	r3, [r7, #4]
240161e8:	f023 4370 	bic.w	r3, r3, #4026531840	; 0xf0000000
240161ec:	60fb      	str	r3, [r7, #12]

        if(QSPI_WriteEnable() != HAL_OK)
240161ee:	f7ff ff69 	bl	240160c4 <QSPI_WriteEnable>
240161f2:	4603      	mov	r3, r0
240161f4:	2b00      	cmp	r3, #0
240161f6:	d001      	beq.n	240161fc <CSP_QSPI_EraseSector+0x58>
        {
            return HAL_ERROR;
240161f8:	2301      	movs	r3, #1
240161fa:	e01e      	b.n	2401623a <CSP_QSPI_EraseSector+0x96>
        }

        if(HAL_QSPI_Command(&hqspi, &sCommand, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
240161fc:	f107 0308 	add.w	r3, r7, #8
24016200:	f241 3288 	movw	r2, #5000	; 0x1388
24016204:	4619      	mov	r1, r3
24016206:	4810      	ldr	r0, [pc, #64]	; (24016248 <CSP_QSPI_EraseSector+0xa4>)
24016208:	f7fa faac 	bl	24010764 <HAL_QSPI_Command>
2401620c:	4603      	mov	r3, r0
2401620e:	2b00      	cmp	r3, #0
24016210:	d001      	beq.n	24016216 <CSP_QSPI_EraseSector+0x72>
        {
            return HAL_ERROR;
24016212:	2301      	movs	r3, #1
24016214:	e011      	b.n	2401623a <CSP_QSPI_EraseSector+0x96>
        }
        EraseStartAddress += MEMORY_SECTOR_SIZE;
24016216:	687b      	ldr	r3, [r7, #4]
24016218:	f503 3380 	add.w	r3, r3, #65536	; 0x10000
2401621c:	607b      	str	r3, [r7, #4]

        if (QSPI_AutoPollingMemReady(SECTOR_ERASE_MAX_TIME) != HAL_OK)
2401621e:	f640 30b8 	movw	r0, #3000	; 0xbb8
24016222:	f7ff ff15 	bl	24016050 <QSPI_AutoPollingMemReady>
24016226:	4603      	mov	r3, r0
24016228:	2b00      	cmp	r3, #0
2401622a:	d001      	beq.n	24016230 <CSP_QSPI_EraseSector+0x8c>
        {
            return HAL_ERROR;
2401622c:	2301      	movs	r3, #1
2401622e:	e004      	b.n	2401623a <CSP_QSPI_EraseSector+0x96>
    while(EraseEndAddress >= EraseStartAddress)
24016230:	683a      	ldr	r2, [r7, #0]
24016232:	687b      	ldr	r3, [r7, #4]
24016234:	429a      	cmp	r2, r3
24016236:	d2d6      	bcs.n	240161e6 <CSP_QSPI_EraseSector+0x42>
        }
    }

    return HAL_OK;
24016238:	2300      	movs	r3, #0
}
2401623a:	4618      	mov	r0, r3
2401623c:	3740      	adds	r7, #64	; 0x40
2401623e:	46bd      	mov	sp, r7
24016240:	bd80      	pop	{r7, pc}
24016242:	bf00      	nop
24016244:	ffff0000 	.word	0xffff0000
24016248:	24000564 	.word	0x24000564

2401624c <CSP_QSPI_WriteMemory>:

uint8_t CSP_QSPI_WriteMemory(uint8_t* buffer, uint32_t address, uint32_t buffer_size)
{
2401624c:	b580      	push	{r7, lr}
2401624e:	b096      	sub	sp, #88	; 0x58
24016250:	af00      	add	r7, sp, #0
24016252:	60f8      	str	r0, [r7, #12]
24016254:	60b9      	str	r1, [r7, #8]
24016256:	607a      	str	r2, [r7, #4]

    QSPI_CommandTypeDef sCommand;
    uint32_t end_addr, current_size, current_addr;

    /* Calculation of the size between the write address and the end of the page */
    current_addr = 0;
24016258:	2300      	movs	r3, #0
2401625a:	653b      	str	r3, [r7, #80]	; 0x50


    //
    while (current_addr <= address)
2401625c:	e003      	b.n	24016266 <CSP_QSPI_WriteMemory+0x1a>
    {
        current_addr += MEMORY_PAGE_SIZE;
2401625e:	6d3b      	ldr	r3, [r7, #80]	; 0x50
24016260:	f503 7380 	add.w	r3, r3, #256	; 0x100
24016264:	653b      	str	r3, [r7, #80]	; 0x50
    while (current_addr <= address)
24016266:	6d3a      	ldr	r2, [r7, #80]	; 0x50
24016268:	68bb      	ldr	r3, [r7, #8]
2401626a:	429a      	cmp	r2, r3
2401626c:	d9f7      	bls.n	2401625e <CSP_QSPI_WriteMemory+0x12>
    }
    current_size = current_addr - address;
2401626e:	6d3a      	ldr	r2, [r7, #80]	; 0x50
24016270:	68bb      	ldr	r3, [r7, #8]
24016272:	1ad3      	subs	r3, r2, r3
24016274:	657b      	str	r3, [r7, #84]	; 0x54

    /* Check if the size of the data is less than the remaining place in the page */
    if (current_size > buffer_size)
24016276:	6d7a      	ldr	r2, [r7, #84]	; 0x54
24016278:	687b      	ldr	r3, [r7, #4]
2401627a:	429a      	cmp	r2, r3
2401627c:	d901      	bls.n	24016282 <CSP_QSPI_WriteMemory+0x36>
    {
        current_size = buffer_size;
2401627e:	687b      	ldr	r3, [r7, #4]
24016280:	657b      	str	r3, [r7, #84]	; 0x54
    }

    /* Initialize the adress variables */
    current_addr = address;
24016282:	68bb      	ldr	r3, [r7, #8]
24016284:	653b      	str	r3, [r7, #80]	; 0x50
    end_addr = address + buffer_size;
24016286:	68ba      	ldr	r2, [r7, #8]
24016288:	687b      	ldr	r3, [r7, #4]
2401628a:	4413      	add	r3, r2
2401628c:	64fb      	str	r3, [r7, #76]	; 0x4c

    sCommand.InstructionMode = QSPI_INSTRUCTION_1_LINE;
2401628e:	f44f 7380 	mov.w	r3, #256	; 0x100
24016292:	62fb      	str	r3, [r7, #44]	; 0x2c
    sCommand.AddressSize = QSPI_ADDRESS_24_BITS;
24016294:	f44f 5300 	mov.w	r3, #8192	; 0x2000
24016298:	623b      	str	r3, [r7, #32]
    sCommand.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
2401629a:	2300      	movs	r3, #0
2401629c:	637b      	str	r3, [r7, #52]	; 0x34
    sCommand.DdrMode = QSPI_DDR_MODE_DISABLE;
2401629e:	2300      	movs	r3, #0
240162a0:	643b      	str	r3, [r7, #64]	; 0x40
    sCommand.DdrHoldHalfCycle = QSPI_DDR_HHC_ANALOG_DELAY;
240162a2:	2300      	movs	r3, #0
240162a4:	647b      	str	r3, [r7, #68]	; 0x44
    sCommand.SIOOMode = QSPI_SIOO_INST_EVERY_CMD;
240162a6:	2300      	movs	r3, #0
240162a8:	64bb      	str	r3, [r7, #72]	; 0x48
    sCommand.Instruction = QUAD_IN_FAST_PROG_CMD;
240162aa:	2332      	movs	r3, #50	; 0x32
240162ac:	617b      	str	r3, [r7, #20]
    sCommand.AddressMode = QSPI_ADDRESS_1_LINE;
240162ae:	f44f 6380 	mov.w	r3, #1024	; 0x400
240162b2:	633b      	str	r3, [r7, #48]	; 0x30
    sCommand.DataMode = QSPI_DATA_4_LINES;
240162b4:	f04f 7340 	mov.w	r3, #50331648	; 0x3000000
240162b8:	63bb      	str	r3, [r7, #56]	; 0x38
    sCommand.NbData = buffer_size;
240162ba:	687b      	ldr	r3, [r7, #4]
240162bc:	63fb      	str	r3, [r7, #60]	; 0x3c
    sCommand.Address = address;
240162be:	68bb      	ldr	r3, [r7, #8]
240162c0:	61bb      	str	r3, [r7, #24]
    sCommand.DummyCycles = 0;
240162c2:	2300      	movs	r3, #0
240162c4:	62bb      	str	r3, [r7, #40]	; 0x28

    /* Perform the write page by page */
    do
    {
        sCommand.Address = current_addr;
240162c6:	6d3b      	ldr	r3, [r7, #80]	; 0x50
240162c8:	61bb      	str	r3, [r7, #24]
        sCommand.NbData = current_size;
240162ca:	6d7b      	ldr	r3, [r7, #84]	; 0x54
240162cc:	63fb      	str	r3, [r7, #60]	; 0x3c

        if (current_size == 0)
240162ce:	6d7b      	ldr	r3, [r7, #84]	; 0x54
240162d0:	2b00      	cmp	r3, #0
240162d2:	d101      	bne.n	240162d8 <CSP_QSPI_WriteMemory+0x8c>
        {
            return HAL_OK;
240162d4:	2300      	movs	r3, #0
240162d6:	e041      	b.n	2401635c <CSP_QSPI_WriteMemory+0x110>
        }

        /* Enable write operations */
        if (QSPI_WriteEnable() != HAL_OK)
240162d8:	f7ff fef4 	bl	240160c4 <QSPI_WriteEnable>
240162dc:	4603      	mov	r3, r0
240162de:	2b00      	cmp	r3, #0
240162e0:	d001      	beq.n	240162e6 <CSP_QSPI_WriteMemory+0x9a>
        {
            return HAL_ERROR;
240162e2:	2301      	movs	r3, #1
240162e4:	e03a      	b.n	2401635c <CSP_QSPI_WriteMemory+0x110>
        }

        /* Configure the command */
        if (HAL_QSPI_Command(&hqspi, &sCommand, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
240162e6:	f107 0314 	add.w	r3, r7, #20
240162ea:	f241 3288 	movw	r2, #5000	; 0x1388
240162ee:	4619      	mov	r1, r3
240162f0:	481c      	ldr	r0, [pc, #112]	; (24016364 <CSP_QSPI_WriteMemory+0x118>)
240162f2:	f7fa fa37 	bl	24010764 <HAL_QSPI_Command>
240162f6:	4603      	mov	r3, r0
240162f8:	2b00      	cmp	r3, #0
240162fa:	d001      	beq.n	24016300 <CSP_QSPI_WriteMemory+0xb4>
        {

            return HAL_ERROR;
240162fc:	2301      	movs	r3, #1
240162fe:	e02d      	b.n	2401635c <CSP_QSPI_WriteMemory+0x110>
        }

        /* Transmission of the data */
        if (HAL_QSPI_Transmit(&hqspi, buffer, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
24016300:	f241 3288 	movw	r2, #5000	; 0x1388
24016304:	68f9      	ldr	r1, [r7, #12]
24016306:	4817      	ldr	r0, [pc, #92]	; (24016364 <CSP_QSPI_WriteMemory+0x118>)
24016308:	f7fa faf0 	bl	240108ec <HAL_QSPI_Transmit>
2401630c:	4603      	mov	r3, r0
2401630e:	2b00      	cmp	r3, #0
24016310:	d001      	beq.n	24016316 <CSP_QSPI_WriteMemory+0xca>
        {

            return HAL_ERROR;
24016312:	2301      	movs	r3, #1
24016314:	e022      	b.n	2401635c <CSP_QSPI_WriteMemory+0x110>
        }

        /* Configure automatic polling mode to wait for end of program */
        if (QSPI_AutoPollingMemReady(HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
24016316:	f241 3088 	movw	r0, #5000	; 0x1388
2401631a:	f7ff fe99 	bl	24016050 <QSPI_AutoPollingMemReady>
2401631e:	4603      	mov	r3, r0
24016320:	2b00      	cmp	r3, #0
24016322:	d001      	beq.n	24016328 <CSP_QSPI_WriteMemory+0xdc>
        {
            return HAL_ERROR;
24016324:	2301      	movs	r3, #1
24016326:	e019      	b.n	2401635c <CSP_QSPI_WriteMemory+0x110>
        }

        /* Update the address and size variables for next page programming */
        current_addr += current_size;
24016328:	6d3a      	ldr	r2, [r7, #80]	; 0x50
2401632a:	6d7b      	ldr	r3, [r7, #84]	; 0x54
2401632c:	4413      	add	r3, r2
2401632e:	653b      	str	r3, [r7, #80]	; 0x50
        buffer += current_size;
24016330:	68fa      	ldr	r2, [r7, #12]
24016332:	6d7b      	ldr	r3, [r7, #84]	; 0x54
24016334:	4413      	add	r3, r2
24016336:	60fb      	str	r3, [r7, #12]
        current_size =
            ((current_addr + MEMORY_PAGE_SIZE) > end_addr) ?
24016338:	6d3b      	ldr	r3, [r7, #80]	; 0x50
2401633a:	f503 7380 	add.w	r3, r3, #256	; 0x100
            (end_addr - current_addr) : MEMORY_PAGE_SIZE;
2401633e:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
24016340:	429a      	cmp	r2, r3
24016342:	d203      	bcs.n	2401634c <CSP_QSPI_WriteMemory+0x100>
24016344:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
24016346:	6d3b      	ldr	r3, [r7, #80]	; 0x50
24016348:	1ad3      	subs	r3, r2, r3
2401634a:	e001      	b.n	24016350 <CSP_QSPI_WriteMemory+0x104>
2401634c:	f44f 7380 	mov.w	r3, #256	; 0x100
        current_size =
24016350:	657b      	str	r3, [r7, #84]	; 0x54
    } while (current_addr <= end_addr);
24016352:	6d3a      	ldr	r2, [r7, #80]	; 0x50
24016354:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
24016356:	429a      	cmp	r2, r3
24016358:	d9b5      	bls.n	240162c6 <CSP_QSPI_WriteMemory+0x7a>

    return HAL_OK;
2401635a:	2300      	movs	r3, #0
}
2401635c:	4618      	mov	r0, r3
2401635e:	3758      	adds	r7, #88	; 0x58
24016360:	46bd      	mov	sp, r7
24016362:	bd80      	pop	{r7, pc}
24016364:	24000564 	.word	0x24000564

24016368 <CSP_QSPI_EnableMemoryMappedMode>:


uint8_t CSP_QSPI_EnableMemoryMappedMode(void)
{
24016368:	b580      	push	{r7, lr}
2401636a:	b090      	sub	sp, #64	; 0x40
2401636c:	af00      	add	r7, sp, #0
    QSPI_MemoryMappedTypeDef sMemMappedCfg;

    /* Enable Memory-Mapped mode-------------------------------------------------- */

    /* Configure the command for the read instruction */
    sCommand.InstructionMode   = QSPI_INSTRUCTION_1_LINE;
2401636e:	f44f 7380 	mov.w	r3, #256	; 0x100
24016372:	623b      	str	r3, [r7, #32]
    sCommand.Instruction       = QUAD_OUT_FAST_READ_CMD;
24016374:	23eb      	movs	r3, #235	; 0xeb
24016376:	60bb      	str	r3, [r7, #8]
    sCommand.AddressMode       = QSPI_ADDRESS_4_LINES;
24016378:	f44f 6340 	mov.w	r3, #3072	; 0xc00
2401637c:	627b      	str	r3, [r7, #36]	; 0x24
    sCommand.AddressSize       = QSPI_ADDRESS_24_BITS;
2401637e:	f44f 5300 	mov.w	r3, #8192	; 0x2000
24016382:	617b      	str	r3, [r7, #20]

    sCommand.AlternateByteMode = QSPI_ALTERNATE_BYTES_4_LINES;
24016384:	f44f 4340 	mov.w	r3, #49152	; 0xc000
24016388:	62bb      	str	r3, [r7, #40]	; 0x28
    sCommand.AlternateBytesSize= QSPI_ALTERNATE_BYTES_8_BITS;
2401638a:	2300      	movs	r3, #0
2401638c:	61bb      	str	r3, [r7, #24]
    sCommand.AlternateBytes    = 0;
2401638e:	2300      	movs	r3, #0
24016390:	613b      	str	r3, [r7, #16]

    sCommand.DataMode          = QSPI_DATA_4_LINES;
24016392:	f04f 7340 	mov.w	r3, #50331648	; 0x3000000
24016396:	62fb      	str	r3, [r7, #44]	; 0x2c
    sCommand.DummyCycles       = 4;
24016398:	2304      	movs	r3, #4
2401639a:	61fb      	str	r3, [r7, #28]
    sCommand.DdrMode           = QSPI_DDR_MODE_DISABLE;
2401639c:	2300      	movs	r3, #0
2401639e:	637b      	str	r3, [r7, #52]	; 0x34
    sCommand.DdrHoldHalfCycle  = QSPI_DDR_HHC_ANALOG_DELAY;
240163a0:	2300      	movs	r3, #0
240163a2:	63bb      	str	r3, [r7, #56]	; 0x38
    sCommand.SIOOMode          = QSPI_SIOO_INST_EVERY_CMD;
240163a4:	2300      	movs	r3, #0
240163a6:	63fb      	str	r3, [r7, #60]	; 0x3c

    /* Configure the memory mapped mode */
    sMemMappedCfg.TimeOutActivation = QSPI_TIMEOUT_COUNTER_DISABLE;
240163a8:	2300      	movs	r3, #0
240163aa:	607b      	str	r3, [r7, #4]
    if (HAL_QSPI_MemoryMapped(&hqspi, &sCommand, &sMemMappedCfg) != HAL_OK)
240163ac:	463a      	mov	r2, r7
240163ae:	f107 0308 	add.w	r3, r7, #8
240163b2:	4619      	mov	r1, r3
240163b4:	4806      	ldr	r0, [pc, #24]	; (240163d0 <CSP_QSPI_EnableMemoryMappedMode+0x68>)
240163b6:	f7fa ff72 	bl	2401129e <HAL_QSPI_MemoryMapped>
240163ba:	4603      	mov	r3, r0
240163bc:	2b00      	cmp	r3, #0
240163be:	d001      	beq.n	240163c4 <CSP_QSPI_EnableMemoryMappedMode+0x5c>
    {
        return HAL_ERROR;
240163c0:	2301      	movs	r3, #1
240163c2:	e000      	b.n	240163c6 <CSP_QSPI_EnableMemoryMappedMode+0x5e>
    }
    return HAL_OK;
240163c4:	2300      	movs	r3, #0
}
240163c6:	4618      	mov	r0, r3
240163c8:	3740      	adds	r7, #64	; 0x40
240163ca:	46bd      	mov	sp, r7
240163cc:	bd80      	pop	{r7, pc}
240163ce:	bf00      	nop
240163d0:	24000564 	.word	0x24000564

240163d4 <QSPI_ResetChip>:

uint8_t QSPI_ResetChip()
{
240163d4:	b580      	push	{r7, lr}
240163d6:	b090      	sub	sp, #64	; 0x40
240163d8:	af00      	add	r7, sp, #0
    QSPI_CommandTypeDef sCommand;
    uint32_t temp = 0;
240163da:	2300      	movs	r3, #0
240163dc:	63fb      	str	r3, [r7, #60]	; 0x3c
    /* Erasing Sequence -------------------------------------------------- */
    sCommand.InstructionMode = QSPI_INSTRUCTION_1_LINE;
240163de:	f44f 7380 	mov.w	r3, #256	; 0x100
240163e2:	61fb      	str	r3, [r7, #28]
    sCommand.AddressSize = QSPI_ADDRESS_24_BITS;
240163e4:	f44f 5300 	mov.w	r3, #8192	; 0x2000
240163e8:	613b      	str	r3, [r7, #16]
    sCommand.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
240163ea:	2300      	movs	r3, #0
240163ec:	627b      	str	r3, [r7, #36]	; 0x24
    sCommand.DdrMode = QSPI_DDR_MODE_DISABLE;
240163ee:	2300      	movs	r3, #0
240163f0:	633b      	str	r3, [r7, #48]	; 0x30
    sCommand.DdrHoldHalfCycle = QSPI_DDR_HHC_ANALOG_DELAY;
240163f2:	2300      	movs	r3, #0
240163f4:	637b      	str	r3, [r7, #52]	; 0x34
    sCommand.SIOOMode = QSPI_SIOO_INST_EVERY_CMD;
240163f6:	2300      	movs	r3, #0
240163f8:	63bb      	str	r3, [r7, #56]	; 0x38
    sCommand.Instruction = RESET_ENABLE_CMD;
240163fa:	2366      	movs	r3, #102	; 0x66
240163fc:	607b      	str	r3, [r7, #4]
    sCommand.AddressMode = QSPI_ADDRESS_NONE;
240163fe:	2300      	movs	r3, #0
24016400:	623b      	str	r3, [r7, #32]
    sCommand.Address = 0;
24016402:	2300      	movs	r3, #0
24016404:	60bb      	str	r3, [r7, #8]
    sCommand.DataMode = QSPI_DATA_NONE;
24016406:	2300      	movs	r3, #0
24016408:	62bb      	str	r3, [r7, #40]	; 0x28
    sCommand.DummyCycles = 0;
2401640a:	2300      	movs	r3, #0
2401640c:	61bb      	str	r3, [r7, #24]

    if (HAL_QSPI_Command(&hqspi, &sCommand, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
2401640e:	1d3b      	adds	r3, r7, #4
24016410:	f241 3288 	movw	r2, #5000	; 0x1388
24016414:	4619      	mov	r1, r3
24016416:	4817      	ldr	r0, [pc, #92]	; (24016474 <QSPI_ResetChip+0xa0>)
24016418:	f7fa f9a4 	bl	24010764 <HAL_QSPI_Command>
2401641c:	4603      	mov	r3, r0
2401641e:	2b00      	cmp	r3, #0
24016420:	d001      	beq.n	24016426 <QSPI_ResetChip+0x52>
    {
        return HAL_ERROR;
24016422:	2301      	movs	r3, #1
24016424:	e021      	b.n	2401646a <QSPI_ResetChip+0x96>
    }
    for (temp = 0; temp < 200; temp++)
24016426:	2300      	movs	r3, #0
24016428:	63fb      	str	r3, [r7, #60]	; 0x3c
2401642a:	e003      	b.n	24016434 <QSPI_ResetChip+0x60>
    {
        __NOP();
2401642c:	bf00      	nop
    for (temp = 0; temp < 200; temp++)
2401642e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
24016430:	3301      	adds	r3, #1
24016432:	63fb      	str	r3, [r7, #60]	; 0x3c
24016434:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
24016436:	2bc7      	cmp	r3, #199	; 0xc7
24016438:	d9f8      	bls.n	2401642c <QSPI_ResetChip+0x58>
    }

    sCommand.Instruction = RESET_EXECUTE_CMD;
2401643a:	2399      	movs	r3, #153	; 0x99
2401643c:	607b      	str	r3, [r7, #4]

    if (HAL_QSPI_Command(&hqspi, &sCommand, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
2401643e:	1d3b      	adds	r3, r7, #4
24016440:	f241 3288 	movw	r2, #5000	; 0x1388
24016444:	4619      	mov	r1, r3
24016446:	480b      	ldr	r0, [pc, #44]	; (24016474 <QSPI_ResetChip+0xa0>)
24016448:	f7fa f98c 	bl	24010764 <HAL_QSPI_Command>
2401644c:	4603      	mov	r3, r0
2401644e:	2b00      	cmp	r3, #0
24016450:	d001      	beq.n	24016456 <QSPI_ResetChip+0x82>
    {
        return HAL_ERROR;
24016452:	2301      	movs	r3, #1
24016454:	e009      	b.n	2401646a <QSPI_ResetChip+0x96>
    }

    if(QSPI_AutoPollingMemReady(HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
24016456:	f241 3088 	movw	r0, #5000	; 0x1388
2401645a:	f7ff fdf9 	bl	24016050 <QSPI_AutoPollingMemReady>
2401645e:	4603      	mov	r3, r0
24016460:	2b00      	cmp	r3, #0
24016462:	d001      	beq.n	24016468 <QSPI_ResetChip+0x94>
	{
    	return HAL_ERROR;
24016464:	2301      	movs	r3, #1
24016466:	e000      	b.n	2401646a <QSPI_ResetChip+0x96>
	}

    return HAL_OK;
24016468:	2300      	movs	r3, #0
}
2401646a:	4618      	mov	r0, r3
2401646c:	3740      	adds	r7, #64	; 0x40
2401646e:	46bd      	mov	sp, r7
24016470:	bd80      	pop	{r7, pc}
24016472:	bf00      	nop
24016474:	24000564 	.word	0x24000564

24016478 <HAL_QSPI_MspInit>:
* This function configures the hardware resources used in this example
* @param hqspi: QSPI handle pointer
* @retval None
*/
void HAL_QSPI_MspInit(QSPI_HandleTypeDef* hqspi)
{
24016478:	b580      	push	{r7, lr}
2401647a:	b08a      	sub	sp, #40	; 0x28
2401647c:	af00      	add	r7, sp, #0
2401647e:	6078      	str	r0, [r7, #4]
	GPIO_InitTypeDef GPIO_InitStruct = {0};
24016480:	f107 0314 	add.w	r3, r7, #20
24016484:	2200      	movs	r2, #0
24016486:	601a      	str	r2, [r3, #0]
24016488:	605a      	str	r2, [r3, #4]
2401648a:	609a      	str	r2, [r3, #8]
2401648c:	60da      	str	r2, [r3, #12]
2401648e:	611a      	str	r2, [r3, #16]
	if(hqspi->Instance==QUADSPI)
24016490:	687b      	ldr	r3, [r7, #4]
24016492:	681b      	ldr	r3, [r3, #0]
24016494:	4a32      	ldr	r2, [pc, #200]	; (24016560 <HAL_QSPI_MspInit+0xe8>)
24016496:	4293      	cmp	r3, r2
24016498:	d15e      	bne.n	24016558 <HAL_QSPI_MspInit+0xe0>
	{
		 /* Peripheral clock enable */
		__HAL_RCC_QSPI_CLK_ENABLE();
2401649a:	4b32      	ldr	r3, [pc, #200]	; (24016564 <HAL_QSPI_MspInit+0xec>)
2401649c:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
240164a0:	4a30      	ldr	r2, [pc, #192]	; (24016564 <HAL_QSPI_MspInit+0xec>)
240164a2:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
240164a6:	f8c2 30d4 	str.w	r3, [r2, #212]	; 0xd4
240164aa:	4b2e      	ldr	r3, [pc, #184]	; (24016564 <HAL_QSPI_MspInit+0xec>)
240164ac:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
240164b0:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
240164b4:	613b      	str	r3, [r7, #16]
240164b6:	693b      	ldr	r3, [r7, #16]

		__HAL_RCC_GPIOF_CLK_ENABLE();
240164b8:	4b2a      	ldr	r3, [pc, #168]	; (24016564 <HAL_QSPI_MspInit+0xec>)
240164ba:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
240164be:	4a29      	ldr	r2, [pc, #164]	; (24016564 <HAL_QSPI_MspInit+0xec>)
240164c0:	f043 0320 	orr.w	r3, r3, #32
240164c4:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
240164c8:	4b26      	ldr	r3, [pc, #152]	; (24016564 <HAL_QSPI_MspInit+0xec>)
240164ca:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
240164ce:	f003 0320 	and.w	r3, r3, #32
240164d2:	60fb      	str	r3, [r7, #12]
240164d4:	68fb      	ldr	r3, [r7, #12]
		__HAL_RCC_GPIOB_CLK_ENABLE();
240164d6:	4b23      	ldr	r3, [pc, #140]	; (24016564 <HAL_QSPI_MspInit+0xec>)
240164d8:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
240164dc:	4a21      	ldr	r2, [pc, #132]	; (24016564 <HAL_QSPI_MspInit+0xec>)
240164de:	f043 0302 	orr.w	r3, r3, #2
240164e2:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
240164e6:	4b1f      	ldr	r3, [pc, #124]	; (24016564 <HAL_QSPI_MspInit+0xec>)
240164e8:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
240164ec:	f003 0302 	and.w	r3, r3, #2
240164f0:	60bb      	str	r3, [r7, #8]
240164f2:	68bb      	ldr	r3, [r7, #8]
		PF8     ------> QUADSPI_BK1_IO0
		PF9     ------> QUADSPI_BK1_IO1
		PB2     ------> QUADSPI_CLK
		PB10     ------> QUADSPI_BK1_NCS
		*/
		GPIO_InitStruct.Pin = GPIO_PIN_6|GPIO_PIN_7;
240164f4:	23c0      	movs	r3, #192	; 0xc0
240164f6:	617b      	str	r3, [r7, #20]
		GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
240164f8:	2302      	movs	r3, #2
240164fa:	61bb      	str	r3, [r7, #24]
		GPIO_InitStruct.Pull = GPIO_PULLUP;
240164fc:	2301      	movs	r3, #1
240164fe:	61fb      	str	r3, [r7, #28]
		GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
24016500:	2303      	movs	r3, #3
24016502:	623b      	str	r3, [r7, #32]
		GPIO_InitStruct.Alternate = GPIO_AF9_QUADSPI;
24016504:	2309      	movs	r3, #9
24016506:	627b      	str	r3, [r7, #36]	; 0x24
		HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
24016508:	f107 0314 	add.w	r3, r7, #20
2401650c:	4619      	mov	r1, r3
2401650e:	4816      	ldr	r0, [pc, #88]	; (24016568 <HAL_QSPI_MspInit+0xf0>)
24016510:	f7f2 f83a 	bl	24008588 <HAL_GPIO_Init>

		GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_9;
24016514:	f44f 7340 	mov.w	r3, #768	; 0x300
24016518:	617b      	str	r3, [r7, #20]
		GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
2401651a:	2302      	movs	r3, #2
2401651c:	61bb      	str	r3, [r7, #24]
		GPIO_InitStruct.Pull = GPIO_NOPULL;
2401651e:	2300      	movs	r3, #0
24016520:	61fb      	str	r3, [r7, #28]
		GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
24016522:	2303      	movs	r3, #3
24016524:	623b      	str	r3, [r7, #32]
		GPIO_InitStruct.Alternate = GPIO_AF10_QUADSPI;
24016526:	230a      	movs	r3, #10
24016528:	627b      	str	r3, [r7, #36]	; 0x24
		HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
2401652a:	f107 0314 	add.w	r3, r7, #20
2401652e:	4619      	mov	r1, r3
24016530:	480d      	ldr	r0, [pc, #52]	; (24016568 <HAL_QSPI_MspInit+0xf0>)
24016532:	f7f2 f829 	bl	24008588 <HAL_GPIO_Init>

		GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_10;
24016536:	f240 4304 	movw	r3, #1028	; 0x404
2401653a:	617b      	str	r3, [r7, #20]
		GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
2401653c:	2302      	movs	r3, #2
2401653e:	61bb      	str	r3, [r7, #24]
		GPIO_InitStruct.Pull = GPIO_NOPULL;
24016540:	2300      	movs	r3, #0
24016542:	61fb      	str	r3, [r7, #28]
		GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
24016544:	2303      	movs	r3, #3
24016546:	623b      	str	r3, [r7, #32]
		GPIO_InitStruct.Alternate = GPIO_AF9_QUADSPI;
24016548:	2309      	movs	r3, #9
2401654a:	627b      	str	r3, [r7, #36]	; 0x24
		HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
2401654c:	f107 0314 	add.w	r3, r7, #20
24016550:	4619      	mov	r1, r3
24016552:	4806      	ldr	r0, [pc, #24]	; (2401656c <HAL_QSPI_MspInit+0xf4>)
24016554:	f7f2 f818 	bl	24008588 <HAL_GPIO_Init>
	}

}
24016558:	bf00      	nop
2401655a:	3728      	adds	r7, #40	; 0x28
2401655c:	46bd      	mov	sp, r7
2401655e:	bd80      	pop	{r7, pc}
24016560:	52005000 	.word	0x52005000
24016564:	58024400 	.word	0x58024400
24016568:	58021400 	.word	0x58021400
2401656c:	58020400 	.word	0x58020400

24016570 <HAL_QSPI_MspDeInit>:
* This function freeze the hardware resources used in this example
* @param hqspi: QSPI handle pointer
* @retval None
*/
void HAL_QSPI_MspDeInit(QSPI_HandleTypeDef* hqspi)
{
24016570:	b580      	push	{r7, lr}
24016572:	b082      	sub	sp, #8
24016574:	af00      	add	r7, sp, #0
24016576:	6078      	str	r0, [r7, #4]
	if(hqspi->Instance==QUADSPI)
24016578:	687b      	ldr	r3, [r7, #4]
2401657a:	681b      	ldr	r3, [r3, #0]
2401657c:	4a0c      	ldr	r2, [pc, #48]	; (240165b0 <HAL_QSPI_MspDeInit+0x40>)
2401657e:	4293      	cmp	r3, r2
24016580:	d111      	bne.n	240165a6 <HAL_QSPI_MspDeInit+0x36>
	{
		/* Peripheral clock disable */
		__HAL_RCC_QSPI_CLK_DISABLE();
24016582:	4b0c      	ldr	r3, [pc, #48]	; (240165b4 <HAL_QSPI_MspDeInit+0x44>)
24016584:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
24016588:	4a0a      	ldr	r2, [pc, #40]	; (240165b4 <HAL_QSPI_MspDeInit+0x44>)
2401658a:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
2401658e:	f8c2 30d4 	str.w	r3, [r2, #212]	; 0xd4
		PF8     ------> QUADSPI_BK1_IO0
		PF9     ------> QUADSPI_BK1_IO1
		PB2     ------> QUADSPI_CLK
		PB10     ------> QUADSPI_BK1_NCS
		*/
		HAL_GPIO_DeInit(GPIOF, GPIO_PIN_6|GPIO_PIN_7|GPIO_PIN_8|GPIO_PIN_9);
24016592:	f44f 7170 	mov.w	r1, #960	; 0x3c0
24016596:	4808      	ldr	r0, [pc, #32]	; (240165b8 <HAL_QSPI_MspDeInit+0x48>)
24016598:	f7f2 f9a6 	bl	240088e8 <HAL_GPIO_DeInit>

		HAL_GPIO_DeInit(GPIOB, GPIO_PIN_2|GPIO_PIN_10);
2401659c:	f240 4104 	movw	r1, #1028	; 0x404
240165a0:	4806      	ldr	r0, [pc, #24]	; (240165bc <HAL_QSPI_MspDeInit+0x4c>)
240165a2:	f7f2 f9a1 	bl	240088e8 <HAL_GPIO_DeInit>
	}

}
240165a6:	bf00      	nop
240165a8:	3708      	adds	r7, #8
240165aa:	46bd      	mov	sp, r7
240165ac:	bd80      	pop	{r7, pc}
240165ae:	bf00      	nop
240165b0:	52005000 	.word	0x52005000
240165b4:	58024400 	.word	0x58024400
240165b8:	58021400 	.word	0x58021400
240165bc:	58020400 	.word	0x58020400

240165c0 <HAL_MspInit>:

/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
240165c0:	b480      	push	{r7}
240165c2:	b083      	sub	sp, #12
240165c4:	af00      	add	r7, sp, #0
	__HAL_RCC_SYSCFG_CLK_ENABLE();
240165c6:	4b0a      	ldr	r3, [pc, #40]	; (240165f0 <HAL_MspInit+0x30>)
240165c8:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
240165cc:	4a08      	ldr	r2, [pc, #32]	; (240165f0 <HAL_MspInit+0x30>)
240165ce:	f043 0302 	orr.w	r3, r3, #2
240165d2:	f8c2 30f4 	str.w	r3, [r2, #244]	; 0xf4
240165d6:	4b06      	ldr	r3, [pc, #24]	; (240165f0 <HAL_MspInit+0x30>)
240165d8:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
240165dc:	f003 0302 	and.w	r3, r3, #2
240165e0:	607b      	str	r3, [r7, #4]
240165e2:	687b      	ldr	r3, [r7, #4]

	/* System interrupt init*/
}
240165e4:	bf00      	nop
240165e6:	370c      	adds	r7, #12
240165e8:	46bd      	mov	sp, r7
240165ea:	f85d 7b04 	ldr.w	r7, [sp], #4
240165ee:	4770      	bx	lr
240165f0:	58024400 	.word	0x58024400

240165f4 <NMI_Handler>:
/******************************************************************************/
/**
  * @brief This function handles Non maskable interrupt.
  */
void NMI_Handler(void)
{
240165f4:	b480      	push	{r7}
240165f6:	af00      	add	r7, sp, #0

}
240165f8:	bf00      	nop
240165fa:	46bd      	mov	sp, r7
240165fc:	f85d 7b04 	ldr.w	r7, [sp], #4
24016600:	4770      	bx	lr

24016602 <HardFault_Handler>:

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
24016602:	b480      	push	{r7}
24016604:	af00      	add	r7, sp, #0

	while (1)
24016606:	e7fe      	b.n	24016606 <HardFault_Handler+0x4>

24016608 <MemManage_Handler>:

/**
  * @brief This function handles Memory management fault.
  */
void MemManage_Handler(void)
{
24016608:	b480      	push	{r7}
2401660a:	af00      	add	r7, sp, #0
	while (1)
2401660c:	e7fe      	b.n	2401660c <MemManage_Handler+0x4>

2401660e <BusFault_Handler>:

/**
  * @brief This function handles Pre-fetch fault, memory access fault.
  */
void BusFault_Handler(void)
{
2401660e:	b480      	push	{r7}
24016610:	af00      	add	r7, sp, #0
   while (1)
24016612:	e7fe      	b.n	24016612 <BusFault_Handler+0x4>

24016614 <UsageFault_Handler>:

/**
  * @brief This function handles Undefined instruction or illegal state.
  */
void UsageFault_Handler(void)
{
24016614:	b480      	push	{r7}
24016616:	af00      	add	r7, sp, #0
	while (1)
24016618:	e7fe      	b.n	24016618 <UsageFault_Handler+0x4>

2401661a <SVC_Handler>:

/**
  * @brief This function handles System service call via SWI instruction.
  */
void SVC_Handler(void)
{
2401661a:	b480      	push	{r7}
2401661c:	af00      	add	r7, sp, #0

}
2401661e:	bf00      	nop
24016620:	46bd      	mov	sp, r7
24016622:	f85d 7b04 	ldr.w	r7, [sp], #4
24016626:	4770      	bx	lr

24016628 <DebugMon_Handler>:

/**
  * @brief This function handles Debug monitor.
  */
void DebugMon_Handler(void)
{
24016628:	b480      	push	{r7}
2401662a:	af00      	add	r7, sp, #0

}
2401662c:	bf00      	nop
2401662e:	46bd      	mov	sp, r7
24016630:	f85d 7b04 	ldr.w	r7, [sp], #4
24016634:	4770      	bx	lr

24016636 <PendSV_Handler>:

/**
  * @brief This function handles Pendable request for system service.
  */
void PendSV_Handler(void)
{
24016636:	b480      	push	{r7}
24016638:	af00      	add	r7, sp, #0

}
2401663a:	bf00      	nop
2401663c:	46bd      	mov	sp, r7
2401663e:	f85d 7b04 	ldr.w	r7, [sp], #4
24016642:	4770      	bx	lr

24016644 <SysTick_Handler>:

/**
  * @brief This function handles System tick timer.
  */
void SysTick_Handler(void)
{
24016644:	b580      	push	{r7, lr}
24016646:	af00      	add	r7, sp, #0
	HAL_IncTick();
24016648:	f7ea f8ee 	bl	24000828 <HAL_IncTick>
}
2401664c:	bf00      	nop
2401664e:	bd80      	pop	{r7, pc}

24016650 <initialise_monitor_handles>:
char** environ = __env;


/* Functions */
void
initialise_monitor_handles() {
24016650:	b480      	push	{r7}
24016652:	af00      	add	r7, sp, #0
}
24016654:	bf00      	nop
24016656:	46bd      	mov	sp, r7
24016658:	f85d 7b04 	ldr.w	r7, [sp], #4
2401665c:	4770      	bx	lr

2401665e <_getpid>:

int
_getpid(void) {
2401665e:	b480      	push	{r7}
24016660:	af00      	add	r7, sp, #0
    return 1;
24016662:	2301      	movs	r3, #1
}
24016664:	4618      	mov	r0, r3
24016666:	46bd      	mov	sp, r7
24016668:	f85d 7b04 	ldr.w	r7, [sp], #4
2401666c:	4770      	bx	lr

2401666e <_kill>:

int
_kill(int pid, int sig) {
2401666e:	b580      	push	{r7, lr}
24016670:	b082      	sub	sp, #8
24016672:	af00      	add	r7, sp, #0
24016674:	6078      	str	r0, [r7, #4]
24016676:	6039      	str	r1, [r7, #0]
    errno = EINVAL;
24016678:	f000 fae2 	bl	24016c40 <__errno>
2401667c:	4602      	mov	r2, r0
2401667e:	2316      	movs	r3, #22
24016680:	6013      	str	r3, [r2, #0]
    return -1;
24016682:	f04f 33ff 	mov.w	r3, #4294967295
}
24016686:	4618      	mov	r0, r3
24016688:	3708      	adds	r7, #8
2401668a:	46bd      	mov	sp, r7
2401668c:	bd80      	pop	{r7, pc}

2401668e <_exit>:

void
_exit (int status) {
2401668e:	b580      	push	{r7, lr}
24016690:	b082      	sub	sp, #8
24016692:	af00      	add	r7, sp, #0
24016694:	6078      	str	r0, [r7, #4]
    _kill(status, -1);
24016696:	f04f 31ff 	mov.w	r1, #4294967295
2401669a:	6878      	ldr	r0, [r7, #4]
2401669c:	f7ff ffe7 	bl	2401666e <_kill>
    while (1) {}        /* Make sure we hang here */
240166a0:	e7fe      	b.n	240166a0 <_exit+0x12>

240166a2 <_read>:
}

__attribute__((weak)) int _read(int file, char* ptr, int len) {
240166a2:	b580      	push	{r7, lr}
240166a4:	b086      	sub	sp, #24
240166a6:	af00      	add	r7, sp, #0
240166a8:	60f8      	str	r0, [r7, #12]
240166aa:	60b9      	str	r1, [r7, #8]
240166ac:	607a      	str	r2, [r7, #4]
    int DataIdx;

    for (DataIdx = 0; DataIdx < len; DataIdx++) {
240166ae:	2300      	movs	r3, #0
240166b0:	617b      	str	r3, [r7, #20]
240166b2:	e00a      	b.n	240166ca <_read+0x28>
        *ptr++ = __io_getchar();
240166b4:	f3af 8000 	nop.w
240166b8:	4601      	mov	r1, r0
240166ba:	68bb      	ldr	r3, [r7, #8]
240166bc:	1c5a      	adds	r2, r3, #1
240166be:	60ba      	str	r2, [r7, #8]
240166c0:	b2ca      	uxtb	r2, r1
240166c2:	701a      	strb	r2, [r3, #0]
    for (DataIdx = 0; DataIdx < len; DataIdx++) {
240166c4:	697b      	ldr	r3, [r7, #20]
240166c6:	3301      	adds	r3, #1
240166c8:	617b      	str	r3, [r7, #20]
240166ca:	697a      	ldr	r2, [r7, #20]
240166cc:	687b      	ldr	r3, [r7, #4]
240166ce:	429a      	cmp	r2, r3
240166d0:	dbf0      	blt.n	240166b4 <_read+0x12>
    }

    return len;
240166d2:	687b      	ldr	r3, [r7, #4]
}
240166d4:	4618      	mov	r0, r3
240166d6:	3718      	adds	r7, #24
240166d8:	46bd      	mov	sp, r7
240166da:	bd80      	pop	{r7, pc}

240166dc <_write>:

__attribute__((weak)) int _write(int file, char* ptr, int len) {
240166dc:	b580      	push	{r7, lr}
240166de:	b086      	sub	sp, #24
240166e0:	af00      	add	r7, sp, #0
240166e2:	60f8      	str	r0, [r7, #12]
240166e4:	60b9      	str	r1, [r7, #8]
240166e6:	607a      	str	r2, [r7, #4]
    int DataIdx;

    for (DataIdx = 0; DataIdx < len; DataIdx++) {
240166e8:	2300      	movs	r3, #0
240166ea:	617b      	str	r3, [r7, #20]
240166ec:	e009      	b.n	24016702 <_write+0x26>
        __io_putchar(*ptr++);
240166ee:	68bb      	ldr	r3, [r7, #8]
240166f0:	1c5a      	adds	r2, r3, #1
240166f2:	60ba      	str	r2, [r7, #8]
240166f4:	781b      	ldrb	r3, [r3, #0]
240166f6:	4618      	mov	r0, r3
240166f8:	f7ff f981 	bl	240159fe <__io_putchar>
    for (DataIdx = 0; DataIdx < len; DataIdx++) {
240166fc:	697b      	ldr	r3, [r7, #20]
240166fe:	3301      	adds	r3, #1
24016700:	617b      	str	r3, [r7, #20]
24016702:	697a      	ldr	r2, [r7, #20]
24016704:	687b      	ldr	r3, [r7, #4]
24016706:	429a      	cmp	r2, r3
24016708:	dbf1      	blt.n	240166ee <_write+0x12>
    }
    return len;
2401670a:	687b      	ldr	r3, [r7, #4]
}
2401670c:	4618      	mov	r0, r3
2401670e:	3718      	adds	r7, #24
24016710:	46bd      	mov	sp, r7
24016712:	bd80      	pop	{r7, pc}

24016714 <_close>:

int
_close(int file) {
24016714:	b480      	push	{r7}
24016716:	b083      	sub	sp, #12
24016718:	af00      	add	r7, sp, #0
2401671a:	6078      	str	r0, [r7, #4]
    return -1;
2401671c:	f04f 33ff 	mov.w	r3, #4294967295
}
24016720:	4618      	mov	r0, r3
24016722:	370c      	adds	r7, #12
24016724:	46bd      	mov	sp, r7
24016726:	f85d 7b04 	ldr.w	r7, [sp], #4
2401672a:	4770      	bx	lr

2401672c <_fstat>:


int
_fstat(int file, struct stat* st) {
2401672c:	b480      	push	{r7}
2401672e:	b083      	sub	sp, #12
24016730:	af00      	add	r7, sp, #0
24016732:	6078      	str	r0, [r7, #4]
24016734:	6039      	str	r1, [r7, #0]
    st->st_mode = S_IFCHR;
24016736:	683b      	ldr	r3, [r7, #0]
24016738:	f44f 5200 	mov.w	r2, #8192	; 0x2000
2401673c:	605a      	str	r2, [r3, #4]
    return 0;
2401673e:	2300      	movs	r3, #0
}
24016740:	4618      	mov	r0, r3
24016742:	370c      	adds	r7, #12
24016744:	46bd      	mov	sp, r7
24016746:	f85d 7b04 	ldr.w	r7, [sp], #4
2401674a:	4770      	bx	lr

2401674c <_isatty>:

int
_isatty(int file) {
2401674c:	b480      	push	{r7}
2401674e:	b083      	sub	sp, #12
24016750:	af00      	add	r7, sp, #0
24016752:	6078      	str	r0, [r7, #4]
    return 1;
24016754:	2301      	movs	r3, #1
}
24016756:	4618      	mov	r0, r3
24016758:	370c      	adds	r7, #12
2401675a:	46bd      	mov	sp, r7
2401675c:	f85d 7b04 	ldr.w	r7, [sp], #4
24016760:	4770      	bx	lr

24016762 <_lseek>:

int
_lseek(int file, int ptr, int dir) {
24016762:	b480      	push	{r7}
24016764:	b085      	sub	sp, #20
24016766:	af00      	add	r7, sp, #0
24016768:	60f8      	str	r0, [r7, #12]
2401676a:	60b9      	str	r1, [r7, #8]
2401676c:	607a      	str	r2, [r7, #4]
    return 0;
2401676e:	2300      	movs	r3, #0
}
24016770:	4618      	mov	r0, r3
24016772:	3714      	adds	r7, #20
24016774:	46bd      	mov	sp, r7
24016776:	f85d 7b04 	ldr.w	r7, [sp], #4
2401677a:	4770      	bx	lr

2401677c <_open>:

int
_open(char* path, int flags, ...) {
2401677c:	b40e      	push	{r1, r2, r3}
2401677e:	b480      	push	{r7}
24016780:	b082      	sub	sp, #8
24016782:	af00      	add	r7, sp, #0
24016784:	6078      	str	r0, [r7, #4]
    /* Pretend like we always fail */
    return -1;
24016786:	f04f 33ff 	mov.w	r3, #4294967295
}
2401678a:	4618      	mov	r0, r3
2401678c:	3708      	adds	r7, #8
2401678e:	46bd      	mov	sp, r7
24016790:	f85d 7b04 	ldr.w	r7, [sp], #4
24016794:	b003      	add	sp, #12
24016796:	4770      	bx	lr

24016798 <_wait>:

int
_wait(int* status) {
24016798:	b580      	push	{r7, lr}
2401679a:	b082      	sub	sp, #8
2401679c:	af00      	add	r7, sp, #0
2401679e:	6078      	str	r0, [r7, #4]
    errno = ECHILD;
240167a0:	f000 fa4e 	bl	24016c40 <__errno>
240167a4:	4602      	mov	r2, r0
240167a6:	230a      	movs	r3, #10
240167a8:	6013      	str	r3, [r2, #0]
    return -1;
240167aa:	f04f 33ff 	mov.w	r3, #4294967295
}
240167ae:	4618      	mov	r0, r3
240167b0:	3708      	adds	r7, #8
240167b2:	46bd      	mov	sp, r7
240167b4:	bd80      	pop	{r7, pc}

240167b6 <_unlink>:

int
_unlink(char* name) {
240167b6:	b580      	push	{r7, lr}
240167b8:	b082      	sub	sp, #8
240167ba:	af00      	add	r7, sp, #0
240167bc:	6078      	str	r0, [r7, #4]
    errno = ENOENT;
240167be:	f000 fa3f 	bl	24016c40 <__errno>
240167c2:	4602      	mov	r2, r0
240167c4:	2302      	movs	r3, #2
240167c6:	6013      	str	r3, [r2, #0]
    return -1;
240167c8:	f04f 33ff 	mov.w	r3, #4294967295
}
240167cc:	4618      	mov	r0, r3
240167ce:	3708      	adds	r7, #8
240167d0:	46bd      	mov	sp, r7
240167d2:	bd80      	pop	{r7, pc}

240167d4 <_times>:

int
_times(struct tms* buf) {
240167d4:	b480      	push	{r7}
240167d6:	b083      	sub	sp, #12
240167d8:	af00      	add	r7, sp, #0
240167da:	6078      	str	r0, [r7, #4]
    return -1;
240167dc:	f04f 33ff 	mov.w	r3, #4294967295
}
240167e0:	4618      	mov	r0, r3
240167e2:	370c      	adds	r7, #12
240167e4:	46bd      	mov	sp, r7
240167e6:	f85d 7b04 	ldr.w	r7, [sp], #4
240167ea:	4770      	bx	lr

240167ec <_stat>:

int
_stat(char* file, struct stat* st) {
240167ec:	b480      	push	{r7}
240167ee:	b083      	sub	sp, #12
240167f0:	af00      	add	r7, sp, #0
240167f2:	6078      	str	r0, [r7, #4]
240167f4:	6039      	str	r1, [r7, #0]
    st->st_mode = S_IFCHR;
240167f6:	683b      	ldr	r3, [r7, #0]
240167f8:	f44f 5200 	mov.w	r2, #8192	; 0x2000
240167fc:	605a      	str	r2, [r3, #4]
    return 0;
240167fe:	2300      	movs	r3, #0
}
24016800:	4618      	mov	r0, r3
24016802:	370c      	adds	r7, #12
24016804:	46bd      	mov	sp, r7
24016806:	f85d 7b04 	ldr.w	r7, [sp], #4
2401680a:	4770      	bx	lr

2401680c <_link>:

int
_link(char* old, char* new) {
2401680c:	b580      	push	{r7, lr}
2401680e:	b082      	sub	sp, #8
24016810:	af00      	add	r7, sp, #0
24016812:	6078      	str	r0, [r7, #4]
24016814:	6039      	str	r1, [r7, #0]
    errno = EMLINK;
24016816:	f000 fa13 	bl	24016c40 <__errno>
2401681a:	4602      	mov	r2, r0
2401681c:	231f      	movs	r3, #31
2401681e:	6013      	str	r3, [r2, #0]
    return -1;
24016820:	f04f 33ff 	mov.w	r3, #4294967295
}
24016824:	4618      	mov	r0, r3
24016826:	3708      	adds	r7, #8
24016828:	46bd      	mov	sp, r7
2401682a:	bd80      	pop	{r7, pc}

2401682c <_fork>:

int
_fork(void) {
2401682c:	b580      	push	{r7, lr}
2401682e:	af00      	add	r7, sp, #0
    errno = EAGAIN;
24016830:	f000 fa06 	bl	24016c40 <__errno>
24016834:	4602      	mov	r2, r0
24016836:	230b      	movs	r3, #11
24016838:	6013      	str	r3, [r2, #0]
    return -1;
2401683a:	f04f 33ff 	mov.w	r3, #4294967295
}
2401683e:	4618      	mov	r0, r3
24016840:	bd80      	pop	{r7, pc}

24016842 <_execve>:

int
_execve(char* name, char** argv, char** env) {
24016842:	b580      	push	{r7, lr}
24016844:	b084      	sub	sp, #16
24016846:	af00      	add	r7, sp, #0
24016848:	60f8      	str	r0, [r7, #12]
2401684a:	60b9      	str	r1, [r7, #8]
2401684c:	607a      	str	r2, [r7, #4]
    errno = ENOMEM;
2401684e:	f000 f9f7 	bl	24016c40 <__errno>
24016852:	4602      	mov	r2, r0
24016854:	230c      	movs	r3, #12
24016856:	6013      	str	r3, [r2, #0]
    return -1;
24016858:	f04f 33ff 	mov.w	r3, #4294967295
}
2401685c:	4618      	mov	r0, r3
2401685e:	3710      	adds	r7, #16
24016860:	46bd      	mov	sp, r7
24016862:	bd80      	pop	{r7, pc}

24016864 <SystemInit>:
  *         configuration.
  * @param  None
  * @retval None
  */
void SystemInit (void)
{
24016864:	b480      	push	{r7}
24016866:	af00      	add	r7, sp, #0
 __IO uint32_t tmpreg;
#endif /* DATA_IN_D2_SRAM */

  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << (10*2))|(3UL << (11*2)));  /* set CP10 and CP11 Full Access */
24016868:	4b29      	ldr	r3, [pc, #164]	; (24016910 <SystemInit+0xac>)
2401686a:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
2401686e:	4a28      	ldr	r2, [pc, #160]	; (24016910 <SystemInit+0xac>)
24016870:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
24016874:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
  #endif
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set HSION bit */
  RCC->CR |= RCC_CR_HSION;
24016878:	4b26      	ldr	r3, [pc, #152]	; (24016914 <SystemInit+0xb0>)
2401687a:	681b      	ldr	r3, [r3, #0]
2401687c:	4a25      	ldr	r2, [pc, #148]	; (24016914 <SystemInit+0xb0>)
2401687e:	f043 0301 	orr.w	r3, r3, #1
24016882:	6013      	str	r3, [r2, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
24016884:	4b23      	ldr	r3, [pc, #140]	; (24016914 <SystemInit+0xb0>)
24016886:	2200      	movs	r2, #0
24016888:	611a      	str	r2, [r3, #16]

  /* Reset HSEON, CSSON , CSION,RC48ON, CSIKERON PLL1ON, PLL2ON and PLL3ON bits */
  RCC->CR &= 0xEAF6ED7FU;
2401688a:	4b22      	ldr	r3, [pc, #136]	; (24016914 <SystemInit+0xb0>)
2401688c:	681a      	ldr	r2, [r3, #0]
2401688e:	4921      	ldr	r1, [pc, #132]	; (24016914 <SystemInit+0xb0>)
24016890:	4b21      	ldr	r3, [pc, #132]	; (24016918 <SystemInit+0xb4>)
24016892:	4013      	ands	r3, r2
24016894:	600b      	str	r3, [r1, #0]

#if defined(D3_SRAM_BASE)
  /* Reset D1CFGR register */
  RCC->D1CFGR = 0x00000000;
24016896:	4b1f      	ldr	r3, [pc, #124]	; (24016914 <SystemInit+0xb0>)
24016898:	2200      	movs	r2, #0
2401689a:	619a      	str	r2, [r3, #24]

  /* Reset D2CFGR register */
  RCC->D2CFGR = 0x00000000;
2401689c:	4b1d      	ldr	r3, [pc, #116]	; (24016914 <SystemInit+0xb0>)
2401689e:	2200      	movs	r2, #0
240168a0:	61da      	str	r2, [r3, #28]

  /* Reset D3CFGR register */
  RCC->D3CFGR = 0x00000000;
240168a2:	4b1c      	ldr	r3, [pc, #112]	; (24016914 <SystemInit+0xb0>)
240168a4:	2200      	movs	r2, #0
240168a6:	621a      	str	r2, [r3, #32]

  /* Reset SRDCFGR register */
  RCC->SRDCFGR = 0x00000000;
#endif
  /* Reset PLLCKSELR register */
  RCC->PLLCKSELR = 0x00000000;
240168a8:	4b1a      	ldr	r3, [pc, #104]	; (24016914 <SystemInit+0xb0>)
240168aa:	2200      	movs	r2, #0
240168ac:	629a      	str	r2, [r3, #40]	; 0x28

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x00000000;
240168ae:	4b19      	ldr	r3, [pc, #100]	; (24016914 <SystemInit+0xb0>)
240168b0:	2200      	movs	r2, #0
240168b2:	62da      	str	r2, [r3, #44]	; 0x2c
  /* Reset PLL1DIVR register */
  RCC->PLL1DIVR = 0x00000000;
240168b4:	4b17      	ldr	r3, [pc, #92]	; (24016914 <SystemInit+0xb0>)
240168b6:	2200      	movs	r2, #0
240168b8:	631a      	str	r2, [r3, #48]	; 0x30
  /* Reset PLL1FRACR register */
  RCC->PLL1FRACR = 0x00000000;
240168ba:	4b16      	ldr	r3, [pc, #88]	; (24016914 <SystemInit+0xb0>)
240168bc:	2200      	movs	r2, #0
240168be:	635a      	str	r2, [r3, #52]	; 0x34

  /* Reset PLL2DIVR register */
  RCC->PLL2DIVR = 0x00000000;
240168c0:	4b14      	ldr	r3, [pc, #80]	; (24016914 <SystemInit+0xb0>)
240168c2:	2200      	movs	r2, #0
240168c4:	639a      	str	r2, [r3, #56]	; 0x38

  /* Reset PLL2FRACR register */

  RCC->PLL2FRACR = 0x00000000;
240168c6:	4b13      	ldr	r3, [pc, #76]	; (24016914 <SystemInit+0xb0>)
240168c8:	2200      	movs	r2, #0
240168ca:	63da      	str	r2, [r3, #60]	; 0x3c
  /* Reset PLL3DIVR register */
  RCC->PLL3DIVR = 0x00000000;
240168cc:	4b11      	ldr	r3, [pc, #68]	; (24016914 <SystemInit+0xb0>)
240168ce:	2200      	movs	r2, #0
240168d0:	641a      	str	r2, [r3, #64]	; 0x40

  /* Reset PLL3FRACR register */
  RCC->PLL3FRACR = 0x00000000;
240168d2:	4b10      	ldr	r3, [pc, #64]	; (24016914 <SystemInit+0xb0>)
240168d4:	2200      	movs	r2, #0
240168d6:	645a      	str	r2, [r3, #68]	; 0x44

  /* Reset HSEBYP bit */
  RCC->CR &= 0xFFFBFFFFU;
240168d8:	4b0e      	ldr	r3, [pc, #56]	; (24016914 <SystemInit+0xb0>)
240168da:	681b      	ldr	r3, [r3, #0]
240168dc:	4a0d      	ldr	r2, [pc, #52]	; (24016914 <SystemInit+0xb0>)
240168de:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
240168e2:	6013      	str	r3, [r2, #0]

  /* Disable all interrupts */
  RCC->CIER = 0x00000000;
240168e4:	4b0b      	ldr	r3, [pc, #44]	; (24016914 <SystemInit+0xb0>)
240168e6:	2200      	movs	r2, #0
240168e8:	661a      	str	r2, [r3, #96]	; 0x60

#if (STM32H7_DEV_ID == 0x450UL)
  /* dual core CM7 or single core line */
  if((DBGMCU->IDCODE & 0xFFFF0000U) < 0x20000000U)
240168ea:	4b0c      	ldr	r3, [pc, #48]	; (2401691c <SystemInit+0xb8>)
240168ec:	681a      	ldr	r2, [r3, #0]
240168ee:	4b0c      	ldr	r3, [pc, #48]	; (24016920 <SystemInit+0xbc>)
240168f0:	4013      	ands	r3, r2
240168f2:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
240168f6:	d202      	bcs.n	240168fe <SystemInit+0x9a>
  {
    /* if stm32h7 revY*/
    /* Change  the switch matrix read issuing capability to 1 for the AXI SRAM target (Target 7) */
    *((__IO uint32_t*)0x51008108) = 0x000000001U;
240168f8:	4b0a      	ldr	r3, [pc, #40]	; (24016924 <SystemInit+0xc0>)
240168fa:	2201      	movs	r2, #1
240168fc:	601a      	str	r2, [r3, #0]

  /* Configure the Vector Table location add offset address for cortex-M7 ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = D1_AXISRAM_BASE  | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal AXI-RAM */
#else
  SCB->VTOR = FLASH_BANK1_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
240168fe:	4b04      	ldr	r3, [pc, #16]	; (24016910 <SystemInit+0xac>)
24016900:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
24016904:	609a      	str	r2, [r3, #8]
#endif

#endif /*DUAL_CORE && CORE_CM4*/

}
24016906:	bf00      	nop
24016908:	46bd      	mov	sp, r7
2401690a:	f85d 7b04 	ldr.w	r7, [sp], #4
2401690e:	4770      	bx	lr
24016910:	e000ed00 	.word	0xe000ed00
24016914:	58024400 	.word	0x58024400
24016918:	eaf6ed7f 	.word	0xeaf6ed7f
2401691c:	5c001000 	.word	0x5c001000
24016920:	ffff0000 	.word	0xffff0000
24016924:	51008108 	.word	0x51008108

24016928 <SystemCoreClockUpdate>:
  *           value for HSE crystal.
  * @param  None
  * @retval None
  */
void SystemCoreClockUpdate (void)
{
24016928:	b480      	push	{r7}
2401692a:	b08b      	sub	sp, #44	; 0x2c
2401692c:	af00      	add	r7, sp, #0
  float_t fracn1, pllvco;


  /* Get SYSCLK source -------------------------------------------------------*/

  switch (RCC->CFGR & RCC_CFGR_SWS)
2401692e:	4ba5      	ldr	r3, [pc, #660]	; (24016bc4 <SystemCoreClockUpdate+0x29c>)
24016930:	691b      	ldr	r3, [r3, #16]
24016932:	f003 0338 	and.w	r3, r3, #56	; 0x38
24016936:	2b18      	cmp	r3, #24
24016938:	f200 811d 	bhi.w	24016b76 <SystemCoreClockUpdate+0x24e>
2401693c:	a201      	add	r2, pc, #4	; (adr r2, 24016944 <SystemCoreClockUpdate+0x1c>)
2401693e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
24016942:	bf00      	nop
24016944:	240169a9 	.word	0x240169a9
24016948:	24016b77 	.word	0x24016b77
2401694c:	24016b77 	.word	0x24016b77
24016950:	24016b77 	.word	0x24016b77
24016954:	24016b77 	.word	0x24016b77
24016958:	24016b77 	.word	0x24016b77
2401695c:	24016b77 	.word	0x24016b77
24016960:	24016b77 	.word	0x24016b77
24016964:	240169bd 	.word	0x240169bd
24016968:	24016b77 	.word	0x24016b77
2401696c:	24016b77 	.word	0x24016b77
24016970:	24016b77 	.word	0x24016b77
24016974:	24016b77 	.word	0x24016b77
24016978:	24016b77 	.word	0x24016b77
2401697c:	24016b77 	.word	0x24016b77
24016980:	24016b77 	.word	0x24016b77
24016984:	240169c3 	.word	0x240169c3
24016988:	24016b77 	.word	0x24016b77
2401698c:	24016b77 	.word	0x24016b77
24016990:	24016b77 	.word	0x24016b77
24016994:	24016b77 	.word	0x24016b77
24016998:	24016b77 	.word	0x24016b77
2401699c:	24016b77 	.word	0x24016b77
240169a0:	24016b77 	.word	0x24016b77
240169a4:	240169c9 	.word	0x240169c9
  {
  case RCC_CFGR_SWS_HSI:  /* HSI used as system clock source */
    common_system_clock = (uint32_t) (HSI_VALUE >> ((RCC->CR & RCC_CR_HSIDIV)>> 3));
240169a8:	4b86      	ldr	r3, [pc, #536]	; (24016bc4 <SystemCoreClockUpdate+0x29c>)
240169aa:	681b      	ldr	r3, [r3, #0]
240169ac:	08db      	lsrs	r3, r3, #3
240169ae:	f003 0303 	and.w	r3, r3, #3
240169b2:	4a85      	ldr	r2, [pc, #532]	; (24016bc8 <SystemCoreClockUpdate+0x2a0>)
240169b4:	fa22 f303 	lsr.w	r3, r2, r3
240169b8:	627b      	str	r3, [r7, #36]	; 0x24
    break;
240169ba:	e0df      	b.n	24016b7c <SystemCoreClockUpdate+0x254>

  case RCC_CFGR_SWS_CSI:  /* CSI used as system clock  source */
    common_system_clock = CSI_VALUE;
240169bc:	4b83      	ldr	r3, [pc, #524]	; (24016bcc <SystemCoreClockUpdate+0x2a4>)
240169be:	627b      	str	r3, [r7, #36]	; 0x24
    break;
240169c0:	e0dc      	b.n	24016b7c <SystemCoreClockUpdate+0x254>

  case RCC_CFGR_SWS_HSE:  /* HSE used as system clock  source */
    common_system_clock = HSE_VALUE;
240169c2:	4b83      	ldr	r3, [pc, #524]	; (24016bd0 <SystemCoreClockUpdate+0x2a8>)
240169c4:	627b      	str	r3, [r7, #36]	; 0x24
    break;
240169c6:	e0d9      	b.n	24016b7c <SystemCoreClockUpdate+0x254>
  case RCC_CFGR_SWS_PLL1:  /* PLL1 used as system clock  source */

    /* PLL_VCO = (HSE_VALUE or HSI_VALUE or CSI_VALUE/ PLLM) * PLLN
    SYSCLK = PLL_VCO / PLLR
    */
    pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
240169c8:	4b7e      	ldr	r3, [pc, #504]	; (24016bc4 <SystemCoreClockUpdate+0x29c>)
240169ca:	6a9b      	ldr	r3, [r3, #40]	; 0x28
240169cc:	f003 0303 	and.w	r3, r3, #3
240169d0:	61fb      	str	r3, [r7, #28]
    pllm = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM1)>> 4)  ;
240169d2:	4b7c      	ldr	r3, [pc, #496]	; (24016bc4 <SystemCoreClockUpdate+0x29c>)
240169d4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
240169d6:	091b      	lsrs	r3, r3, #4
240169d8:	f003 033f 	and.w	r3, r3, #63	; 0x3f
240169dc:	61bb      	str	r3, [r7, #24]
    pllfracen = ((RCC->PLLCFGR & RCC_PLLCFGR_PLL1FRACEN)>>RCC_PLLCFGR_PLL1FRACEN_Pos);
240169de:	4b79      	ldr	r3, [pc, #484]	; (24016bc4 <SystemCoreClockUpdate+0x29c>)
240169e0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
240169e2:	f003 0301 	and.w	r3, r3, #1
240169e6:	617b      	str	r3, [r7, #20]
    fracn1 = (float_t)(uint32_t)(pllfracen* ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));
240169e8:	4b76      	ldr	r3, [pc, #472]	; (24016bc4 <SystemCoreClockUpdate+0x29c>)
240169ea:	6b5b      	ldr	r3, [r3, #52]	; 0x34
240169ec:	08db      	lsrs	r3, r3, #3
240169ee:	f3c3 030c 	ubfx	r3, r3, #0, #13
240169f2:	697a      	ldr	r2, [r7, #20]
240169f4:	fb02 f303 	mul.w	r3, r2, r3
240169f8:	ee07 3a90 	vmov	s15, r3
240169fc:	eef8 7a67 	vcvt.f32.u32	s15, s15
24016a00:	edc7 7a04 	vstr	s15, [r7, #16]

    if (pllm != 0U)
24016a04:	69bb      	ldr	r3, [r7, #24]
24016a06:	2b00      	cmp	r3, #0
24016a08:	f000 80b2 	beq.w	24016b70 <SystemCoreClockUpdate+0x248>
    {
      switch (pllsource)
24016a0c:	69fb      	ldr	r3, [r7, #28]
24016a0e:	2b01      	cmp	r3, #1
24016a10:	d032      	beq.n	24016a78 <SystemCoreClockUpdate+0x150>
24016a12:	2b01      	cmp	r3, #1
24016a14:	d302      	bcc.n	24016a1c <SystemCoreClockUpdate+0xf4>
24016a16:	2b02      	cmp	r3, #2
24016a18:	d050      	beq.n	24016abc <SystemCoreClockUpdate+0x194>
24016a1a:	e071      	b.n	24016b00 <SystemCoreClockUpdate+0x1d8>
      {
        case RCC_PLLCKSELR_PLLSRC_HSI:  /* HSI used as PLL clock source */

        hsivalue = (HSI_VALUE >> ((RCC->CR & RCC_CR_HSIDIV)>> 3)) ;
24016a1c:	4b69      	ldr	r3, [pc, #420]	; (24016bc4 <SystemCoreClockUpdate+0x29c>)
24016a1e:	681b      	ldr	r3, [r3, #0]
24016a20:	08db      	lsrs	r3, r3, #3
24016a22:	f003 0303 	and.w	r3, r3, #3
24016a26:	4a68      	ldr	r2, [pc, #416]	; (24016bc8 <SystemCoreClockUpdate+0x2a0>)
24016a28:	fa22 f303 	lsr.w	r3, r2, r3
24016a2c:	60fb      	str	r3, [r7, #12]
        pllvco = ( (float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
24016a2e:	68fb      	ldr	r3, [r7, #12]
24016a30:	ee07 3a90 	vmov	s15, r3
24016a34:	eef8 6a67 	vcvt.f32.u32	s13, s15
24016a38:	69bb      	ldr	r3, [r7, #24]
24016a3a:	ee07 3a90 	vmov	s15, r3
24016a3e:	eef8 7a67 	vcvt.f32.u32	s15, s15
24016a42:	ee86 7aa7 	vdiv.f32	s14, s13, s15
24016a46:	4b5f      	ldr	r3, [pc, #380]	; (24016bc4 <SystemCoreClockUpdate+0x29c>)
24016a48:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24016a4a:	f3c3 0308 	ubfx	r3, r3, #0, #9
24016a4e:	ee07 3a90 	vmov	s15, r3
24016a52:	eef8 6a67 	vcvt.f32.u32	s13, s15
24016a56:	ed97 6a04 	vldr	s12, [r7, #16]
24016a5a:	eddf 5a5e 	vldr	s11, [pc, #376]	; 24016bd4 <SystemCoreClockUpdate+0x2ac>
24016a5e:	eec6 7a25 	vdiv.f32	s15, s12, s11
24016a62:	ee76 7aa7 	vadd.f32	s15, s13, s15
24016a66:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
24016a6a:	ee77 7aa6 	vadd.f32	s15, s15, s13
24016a6e:	ee67 7a27 	vmul.f32	s15, s14, s15
24016a72:	edc7 7a08 	vstr	s15, [r7, #32]

        break;
24016a76:	e065      	b.n	24016b44 <SystemCoreClockUpdate+0x21c>

        case RCC_PLLCKSELR_PLLSRC_CSI:  /* CSI used as PLL clock source */
          pllvco = ((float_t)CSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
24016a78:	69bb      	ldr	r3, [r7, #24]
24016a7a:	ee07 3a90 	vmov	s15, r3
24016a7e:	eef8 7a67 	vcvt.f32.u32	s15, s15
24016a82:	eddf 6a55 	vldr	s13, [pc, #340]	; 24016bd8 <SystemCoreClockUpdate+0x2b0>
24016a86:	ee86 7aa7 	vdiv.f32	s14, s13, s15
24016a8a:	4b4e      	ldr	r3, [pc, #312]	; (24016bc4 <SystemCoreClockUpdate+0x29c>)
24016a8c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24016a8e:	f3c3 0308 	ubfx	r3, r3, #0, #9
24016a92:	ee07 3a90 	vmov	s15, r3
24016a96:	eef8 6a67 	vcvt.f32.u32	s13, s15
24016a9a:	ed97 6a04 	vldr	s12, [r7, #16]
24016a9e:	eddf 5a4d 	vldr	s11, [pc, #308]	; 24016bd4 <SystemCoreClockUpdate+0x2ac>
24016aa2:	eec6 7a25 	vdiv.f32	s15, s12, s11
24016aa6:	ee76 7aa7 	vadd.f32	s15, s13, s15
24016aaa:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
24016aae:	ee77 7aa6 	vadd.f32	s15, s15, s13
24016ab2:	ee67 7a27 	vmul.f32	s15, s14, s15
24016ab6:	edc7 7a08 	vstr	s15, [r7, #32]
        break;
24016aba:	e043      	b.n	24016b44 <SystemCoreClockUpdate+0x21c>

        case RCC_PLLCKSELR_PLLSRC_HSE:  /* HSE used as PLL clock source */
          pllvco = ((float_t)HSE_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
24016abc:	69bb      	ldr	r3, [r7, #24]
24016abe:	ee07 3a90 	vmov	s15, r3
24016ac2:	eef8 7a67 	vcvt.f32.u32	s15, s15
24016ac6:	eddf 6a45 	vldr	s13, [pc, #276]	; 24016bdc <SystemCoreClockUpdate+0x2b4>
24016aca:	ee86 7aa7 	vdiv.f32	s14, s13, s15
24016ace:	4b3d      	ldr	r3, [pc, #244]	; (24016bc4 <SystemCoreClockUpdate+0x29c>)
24016ad0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24016ad2:	f3c3 0308 	ubfx	r3, r3, #0, #9
24016ad6:	ee07 3a90 	vmov	s15, r3
24016ada:	eef8 6a67 	vcvt.f32.u32	s13, s15
24016ade:	ed97 6a04 	vldr	s12, [r7, #16]
24016ae2:	eddf 5a3c 	vldr	s11, [pc, #240]	; 24016bd4 <SystemCoreClockUpdate+0x2ac>
24016ae6:	eec6 7a25 	vdiv.f32	s15, s12, s11
24016aea:	ee76 7aa7 	vadd.f32	s15, s13, s15
24016aee:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
24016af2:	ee77 7aa6 	vadd.f32	s15, s15, s13
24016af6:	ee67 7a27 	vmul.f32	s15, s14, s15
24016afa:	edc7 7a08 	vstr	s15, [r7, #32]
        break;
24016afe:	e021      	b.n	24016b44 <SystemCoreClockUpdate+0x21c>

      default:
          pllvco = ((float_t)CSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
24016b00:	69bb      	ldr	r3, [r7, #24]
24016b02:	ee07 3a90 	vmov	s15, r3
24016b06:	eef8 7a67 	vcvt.f32.u32	s15, s15
24016b0a:	eddf 6a33 	vldr	s13, [pc, #204]	; 24016bd8 <SystemCoreClockUpdate+0x2b0>
24016b0e:	ee86 7aa7 	vdiv.f32	s14, s13, s15
24016b12:	4b2c      	ldr	r3, [pc, #176]	; (24016bc4 <SystemCoreClockUpdate+0x29c>)
24016b14:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24016b16:	f3c3 0308 	ubfx	r3, r3, #0, #9
24016b1a:	ee07 3a90 	vmov	s15, r3
24016b1e:	eef8 6a67 	vcvt.f32.u32	s13, s15
24016b22:	ed97 6a04 	vldr	s12, [r7, #16]
24016b26:	eddf 5a2b 	vldr	s11, [pc, #172]	; 24016bd4 <SystemCoreClockUpdate+0x2ac>
24016b2a:	eec6 7a25 	vdiv.f32	s15, s12, s11
24016b2e:	ee76 7aa7 	vadd.f32	s15, s13, s15
24016b32:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
24016b36:	ee77 7aa6 	vadd.f32	s15, s15, s13
24016b3a:	ee67 7a27 	vmul.f32	s15, s14, s15
24016b3e:	edc7 7a08 	vstr	s15, [r7, #32]
        break;
24016b42:	bf00      	nop
      }
      pllp = (((RCC->PLL1DIVR & RCC_PLL1DIVR_P1) >>9) + 1U ) ;
24016b44:	4b1f      	ldr	r3, [pc, #124]	; (24016bc4 <SystemCoreClockUpdate+0x29c>)
24016b46:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24016b48:	0a5b      	lsrs	r3, r3, #9
24016b4a:	f003 037f 	and.w	r3, r3, #127	; 0x7f
24016b4e:	3301      	adds	r3, #1
24016b50:	60bb      	str	r3, [r7, #8]
      common_system_clock =  (uint32_t)(float_t)(pllvco/(float_t)pllp);
24016b52:	68bb      	ldr	r3, [r7, #8]
24016b54:	ee07 3a90 	vmov	s15, r3
24016b58:	eeb8 7a67 	vcvt.f32.u32	s14, s15
24016b5c:	edd7 6a08 	vldr	s13, [r7, #32]
24016b60:	eec6 7a87 	vdiv.f32	s15, s13, s14
24016b64:	eefc 7ae7 	vcvt.u32.f32	s15, s15
24016b68:	ee17 3a90 	vmov	r3, s15
24016b6c:	627b      	str	r3, [r7, #36]	; 0x24
    }
    else
    {
      common_system_clock = 0U;
    }
    break;
24016b6e:	e005      	b.n	24016b7c <SystemCoreClockUpdate+0x254>
      common_system_clock = 0U;
24016b70:	2300      	movs	r3, #0
24016b72:	627b      	str	r3, [r7, #36]	; 0x24
    break;
24016b74:	e002      	b.n	24016b7c <SystemCoreClockUpdate+0x254>

  default:
    common_system_clock = CSI_VALUE;
24016b76:	4b15      	ldr	r3, [pc, #84]	; (24016bcc <SystemCoreClockUpdate+0x2a4>)
24016b78:	627b      	str	r3, [r7, #36]	; 0x24
    break;
24016b7a:	bf00      	nop
  }

  /* Compute SystemClock frequency --------------------------------------------------*/
#if defined (RCC_D1CFGR_D1CPRE)
  tmp = D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos];
24016b7c:	4b11      	ldr	r3, [pc, #68]	; (24016bc4 <SystemCoreClockUpdate+0x29c>)
24016b7e:	699b      	ldr	r3, [r3, #24]
24016b80:	0a1b      	lsrs	r3, r3, #8
24016b82:	f003 030f 	and.w	r3, r3, #15
24016b86:	4a16      	ldr	r2, [pc, #88]	; (24016be0 <SystemCoreClockUpdate+0x2b8>)
24016b88:	5cd3      	ldrb	r3, [r2, r3]
24016b8a:	607b      	str	r3, [r7, #4]

  /* common_system_clock frequency : CM7 CPU frequency  */
  common_system_clock >>= tmp;
24016b8c:	6a7a      	ldr	r2, [r7, #36]	; 0x24
24016b8e:	687b      	ldr	r3, [r7, #4]
24016b90:	fa22 f303 	lsr.w	r3, r2, r3
24016b94:	627b      	str	r3, [r7, #36]	; 0x24

  /* SystemD2Clock frequency : CM4 CPU, AXI and AHBs Clock frequency  */
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
24016b96:	4b0b      	ldr	r3, [pc, #44]	; (24016bc4 <SystemCoreClockUpdate+0x29c>)
24016b98:	699b      	ldr	r3, [r3, #24]
24016b9a:	f003 030f 	and.w	r3, r3, #15
24016b9e:	4a10      	ldr	r2, [pc, #64]	; (24016be0 <SystemCoreClockUpdate+0x2b8>)
24016ba0:	5cd3      	ldrb	r3, [r2, r3]
24016ba2:	f003 031f 	and.w	r3, r3, #31
24016ba6:	6a7a      	ldr	r2, [r7, #36]	; 0x24
24016ba8:	fa22 f303 	lsr.w	r3, r2, r3
24016bac:	4a0d      	ldr	r2, [pc, #52]	; (24016be4 <SystemCoreClockUpdate+0x2bc>)
24016bae:	6013      	str	r3, [r2, #0]
#endif

#if defined(DUAL_CORE) && defined(CORE_CM4)
  SystemCoreClock = SystemD2Clock;
#else
  SystemCoreClock = common_system_clock;
24016bb0:	4a0d      	ldr	r2, [pc, #52]	; (24016be8 <SystemCoreClockUpdate+0x2c0>)
24016bb2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
24016bb4:	6013      	str	r3, [r2, #0]
#endif /* DUAL_CORE && CORE_CM4 */
}
24016bb6:	bf00      	nop
24016bb8:	372c      	adds	r7, #44	; 0x2c
24016bba:	46bd      	mov	sp, r7
24016bbc:	f85d 7b04 	ldr.w	r7, [sp], #4
24016bc0:	4770      	bx	lr
24016bc2:	bf00      	nop
24016bc4:	58024400 	.word	0x58024400
24016bc8:	03d09000 	.word	0x03d09000
24016bcc:	003d0900 	.word	0x003d0900
24016bd0:	017d7840 	.word	0x017d7840
24016bd4:	46000000 	.word	0x46000000
24016bd8:	4a742400 	.word	0x4a742400
24016bdc:	4bbebc20 	.word	0x4bbebc20
24016be0:	24016db8 	.word	0x24016db8
24016be4:	240004bc 	.word	0x240004bc
24016be8:	240004b8 	.word	0x240004b8

24016bec <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  
  ldr   sp, =_estack      /* set stack pointer */
24016bec:	f8df d034 	ldr.w	sp, [pc, #52]	; 24016c24 <LoopFillZerobss+0x14>

/* Copy the data segment initializers from flash to SRAM */  
  movs  r1, #0
24016bf0:	2100      	movs	r1, #0
  b  LoopCopyDataInit
24016bf2:	e003      	b.n	24016bfc <LoopCopyDataInit>

24016bf4 <CopyDataInit>:

CopyDataInit:
  ldr  r3, =_sidata
24016bf4:	4b0c      	ldr	r3, [pc, #48]	; (24016c28 <LoopFillZerobss+0x18>)
  ldr  r3, [r3, r1]
24016bf6:	585b      	ldr	r3, [r3, r1]
  str  r3, [r0, r1]
24016bf8:	5043      	str	r3, [r0, r1]
  adds  r1, r1, #4
24016bfa:	3104      	adds	r1, #4

24016bfc <LoopCopyDataInit>:
    
LoopCopyDataInit:
  ldr  r0, =_sdata
24016bfc:	480b      	ldr	r0, [pc, #44]	; (24016c2c <LoopFillZerobss+0x1c>)
  ldr  r3, =_edata
24016bfe:	4b0c      	ldr	r3, [pc, #48]	; (24016c30 <LoopFillZerobss+0x20>)
  adds  r2, r0, r1
24016c00:	1842      	adds	r2, r0, r1
  cmp  r2, r3
24016c02:	429a      	cmp	r2, r3
  bcc  CopyDataInit
24016c04:	d3f6      	bcc.n	24016bf4 <CopyDataInit>
  ldr  r2, =_sbss
24016c06:	4a0b      	ldr	r2, [pc, #44]	; (24016c34 <LoopFillZerobss+0x24>)
  b  LoopFillZerobss
24016c08:	e002      	b.n	24016c10 <LoopFillZerobss>

24016c0a <FillZerobss>:
/* Zero fill the bss segment. */  
FillZerobss:
  movs  r3, #0
24016c0a:	2300      	movs	r3, #0
  str  r3, [r2], #4
24016c0c:	f842 3b04 	str.w	r3, [r2], #4

24016c10 <LoopFillZerobss>:
    
LoopFillZerobss:
  ldr  r3, = _ebss
24016c10:	4b09      	ldr	r3, [pc, #36]	; (24016c38 <LoopFillZerobss+0x28>)
  cmp  r2, r3
24016c12:	429a      	cmp	r2, r3
  bcc  FillZerobss
24016c14:	d3f9      	bcc.n	24016c0a <FillZerobss>

/* Call the clock system intitialization function.*/
  bl  SystemInit   
24016c16:	f7ff fe25 	bl	24016864 <SystemInit>
/* Call static constructors */
    bl __libc_init_array
24016c1a:	f000 f82b 	bl	24016c74 <__libc_init_array>
/* Call the application's entry point.*/
  bl  Init
24016c1e:	f7fe fc89 	bl	24015534 <Init>
  bx  lr    
24016c22:	4770      	bx	lr
  ldr   sp, =_estack      /* set stack pointer */
24016c24:	24080004 	.word	0x24080004
  ldr  r3, =_sidata
24016c28:	240004a8 	.word	0x240004a8
  ldr  r0, =_sdata
24016c2c:	240004a8 	.word	0x240004a8
  ldr  r3, =_edata
24016c30:	24000524 	.word	0x24000524
  ldr  r2, =_sbss
24016c34:	24000524 	.word	0x24000524
  ldr  r3, = _ebss
24016c38:	240005b0 	.word	0x240005b0

24016c3c <ADC3_IRQHandler>:
 * @retval None       
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
24016c3c:	e7fe      	b.n	24016c3c <ADC3_IRQHandler>
	...

24016c40 <__errno>:
24016c40:	4b01      	ldr	r3, [pc, #4]	; (24016c48 <__errno+0x8>)
24016c42:	6818      	ldr	r0, [r3, #0]
24016c44:	4770      	bx	lr
24016c46:	bf00      	nop
24016c48:	240004c0 	.word	0x240004c0

24016c4c <exit>:
24016c4c:	b508      	push	{r3, lr}
24016c4e:	4b07      	ldr	r3, [pc, #28]	; (24016c6c <exit+0x20>)
24016c50:	4604      	mov	r4, r0
24016c52:	b113      	cbz	r3, 24016c5a <exit+0xe>
24016c54:	2100      	movs	r1, #0
24016c56:	f3af 8000 	nop.w
24016c5a:	4b05      	ldr	r3, [pc, #20]	; (24016c70 <exit+0x24>)
24016c5c:	6818      	ldr	r0, [r3, #0]
24016c5e:	6a83      	ldr	r3, [r0, #40]	; 0x28
24016c60:	b103      	cbz	r3, 24016c64 <exit+0x18>
24016c62:	4798      	blx	r3
24016c64:	4620      	mov	r0, r4
24016c66:	f7ff fd12 	bl	2401668e <_exit>
24016c6a:	bf00      	nop
24016c6c:	00000000 	.word	0x00000000
24016c70:	24016dc8 	.word	0x24016dc8

24016c74 <__libc_init_array>:
24016c74:	b570      	push	{r4, r5, r6, lr}
24016c76:	4e0d      	ldr	r6, [pc, #52]	; (24016cac <__libc_init_array+0x38>)
24016c78:	4c0d      	ldr	r4, [pc, #52]	; (24016cb0 <__libc_init_array+0x3c>)
24016c7a:	1ba4      	subs	r4, r4, r6
24016c7c:	10a4      	asrs	r4, r4, #2
24016c7e:	2500      	movs	r5, #0
24016c80:	42a5      	cmp	r5, r4
24016c82:	d109      	bne.n	24016c98 <__libc_init_array+0x24>
24016c84:	4e0b      	ldr	r6, [pc, #44]	; (24016cb4 <__libc_init_array+0x40>)
24016c86:	4c0c      	ldr	r4, [pc, #48]	; (24016cb8 <__libc_init_array+0x44>)
24016c88:	f000 f822 	bl	24016cd0 <_init>
24016c8c:	1ba4      	subs	r4, r4, r6
24016c8e:	10a4      	asrs	r4, r4, #2
24016c90:	2500      	movs	r5, #0
24016c92:	42a5      	cmp	r5, r4
24016c94:	d105      	bne.n	24016ca2 <__libc_init_array+0x2e>
24016c96:	bd70      	pop	{r4, r5, r6, pc}
24016c98:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
24016c9c:	4798      	blx	r3
24016c9e:	3501      	adds	r5, #1
24016ca0:	e7ee      	b.n	24016c80 <__libc_init_array+0xc>
24016ca2:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
24016ca6:	4798      	blx	r3
24016ca8:	3501      	adds	r5, #1
24016caa:	e7f2      	b.n	24016c92 <__libc_init_array+0x1e>
24016cac:	240004a0 	.word	0x240004a0
24016cb0:	240004a0 	.word	0x240004a0
24016cb4:	240004a0 	.word	0x240004a0
24016cb8:	240004a4 	.word	0x240004a4

24016cbc <memset>:
24016cbc:	4402      	add	r2, r0
24016cbe:	4603      	mov	r3, r0
24016cc0:	4293      	cmp	r3, r2
24016cc2:	d100      	bne.n	24016cc6 <memset+0xa>
24016cc4:	4770      	bx	lr
24016cc6:	f803 1b01 	strb.w	r1, [r3], #1
24016cca:	e7f9      	b.n	24016cc0 <memset+0x4>

24016ccc <__EH_FRAME_BEGIN__>:
24016ccc:	0000 0000                                   ....

24016cd0 <_init>:
24016cd0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
24016cd2:	bf00      	nop
24016cd4:	bcf8      	pop	{r3, r4, r5, r6, r7}
24016cd6:	bc08      	pop	{r3}
24016cd8:	469e      	mov	lr, r3
24016cda:	4770      	bx	lr

24016cdc <_fini>:
24016cdc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
24016cde:	bf00      	nop
24016ce0:	bcf8      	pop	{r3, r4, r5, r6, r7}
24016ce2:	bc08      	pop	{r3}
24016ce4:	469e      	mov	lr, r3
24016ce6:	4770      	bx	lr
