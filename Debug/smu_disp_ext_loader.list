
smu_disp_ext_loader.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000494  24000004  24000004  00001004  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .ARM          00000008  24000498  24000498  00001498  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .data         000000d8  240004a0  240004a0  000014a0  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  3 .bss          00000294  24000578  24000578  00001578  2**2
                  ALLOC
  4 .text         00013898  24000810  24000810  00001810  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  5 .Dev_info     000000c8  240140a8  240140a8  000160a8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  6 .rodata       0000026c  24014170  24014170  00015170  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 ._user_heap_stack 00000a00  240143dc  240143dc  000153dc  2**0
                  ALLOC
  8 .ARM.attributes 00000030  00000000  00000000  00016170  2**0
                  CONTENTS, READONLY
  9 .debug_info   0002857f  00000000  00000000  000161a0  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 10 .debug_abbrev 000053e3  00000000  00000000  0003e71f  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 11 .debug_loclists 0000ff5b  00000000  00000000  00043b02  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 12 .debug_aranges 00000400  00000000  00000000  00053a60  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_macro  0003a3a3  00000000  00000000  00053e60  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_line   0002d96d  00000000  00000000  0008e203  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_str    00169cc5  00000000  00000000  000bbb70  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .comment      00000043  00000000  00000000  00225835  2**0
                  CONTENTS, READONLY
 17 .debug_frame  00004e0c  00000000  00000000  00225878  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_rnglists 0000044b  00000000  00000000  0022a684  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_line_str 00000071  00000000  00000000  0022aacf  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

24000810 <HAL_MspDeInit-0x2>:
__weak void HAL_MspInit(void)
{
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_MspInit could be implemented in the user file
   */
}
24000810:	4770      	bx	lr

24000812 <HAL_MspDeInit>:

/**
  * @brief  DeInitializes the MSP.
  * @retval None
  */
__weak void HAL_MspDeInit(void)
24000812:	4770      	bx	lr

24000814 <HAL_DeInit>:
  __HAL_RCC_AHB3_FORCE_RESET();
24000814:	4b16      	ldr	r3, [pc, #88]	@ (24000870 <HAL_DeInit+0x5c>)
24000816:	f06f 4200 	mvn.w	r2, #2147483648	@ 0x80000000
{
2400081a:	b510      	push	{r4, lr}
  __HAL_RCC_AHB3_FORCE_RESET();
2400081c:	67da      	str	r2, [r3, #124]	@ 0x7c
  __HAL_RCC_AHB3_RELEASE_RESET();
2400081e:	2400      	movs	r4, #0
  __HAL_RCC_AHB1_FORCE_RESET();
24000820:	f04f 32ff 	mov.w	r2, #4294967295
  __HAL_RCC_AHB3_RELEASE_RESET();
24000824:	67dc      	str	r4, [r3, #124]	@ 0x7c
  __HAL_RCC_AHB1_FORCE_RESET();
24000826:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
  __HAL_RCC_AHB1_RELEASE_RESET();
2400082a:	f8c3 4080 	str.w	r4, [r3, #128]	@ 0x80
  __HAL_RCC_AHB2_FORCE_RESET();
2400082e:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84
  __HAL_RCC_AHB2_RELEASE_RESET();
24000832:	f8c3 4084 	str.w	r4, [r3, #132]	@ 0x84
  __HAL_RCC_AHB4_FORCE_RESET();
24000836:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88
 __HAL_RCC_AHB4_RELEASE_RESET();
2400083a:	f8c3 4088 	str.w	r4, [r3, #136]	@ 0x88
  __HAL_RCC_APB3_FORCE_RESET();
2400083e:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
  __HAL_RCC_APB3_RELEASE_RESET();
24000842:	f8c3 408c 	str.w	r4, [r3, #140]	@ 0x8c
  __HAL_RCC_APB1L_FORCE_RESET();
24000846:	f8c3 2090 	str.w	r2, [r3, #144]	@ 0x90
  __HAL_RCC_APB1L_RELEASE_RESET();
2400084a:	f8c3 4090 	str.w	r4, [r3, #144]	@ 0x90
  __HAL_RCC_APB1H_FORCE_RESET();
2400084e:	f8c3 2094 	str.w	r2, [r3, #148]	@ 0x94
  __HAL_RCC_APB1H_RELEASE_RESET();
24000852:	f8c3 4094 	str.w	r4, [r3, #148]	@ 0x94
   __HAL_RCC_APB2_FORCE_RESET();
24000856:	f8c3 2098 	str.w	r2, [r3, #152]	@ 0x98
   __HAL_RCC_APB2_RELEASE_RESET();
2400085a:	f8c3 4098 	str.w	r4, [r3, #152]	@ 0x98
  __HAL_RCC_APB4_FORCE_RESET();
2400085e:	f8c3 209c 	str.w	r2, [r3, #156]	@ 0x9c
  __HAL_RCC_APB4_RELEASE_RESET();
24000862:	f8c3 409c 	str.w	r4, [r3, #156]	@ 0x9c
  HAL_MspDeInit();
24000866:	f7ff ffd4 	bl	24000812 <HAL_MspDeInit>
}
2400086a:	4620      	mov	r0, r4
2400086c:	bd10      	pop	{r4, pc}
2400086e:	bf00      	nop
24000870:	58024400 	.word	0x58024400
  *       implementation  in user file.
  * @param TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
24000874:	b570      	push	{r4, r5, r6, lr}
  /* Check uwTickFreq for MisraC 2012 (even if uwTickFreq is a enum type that don't take the value zero)*/
  if((uint32_t)uwTickFreq == 0UL)
24000876:	4e0f      	ldr	r6, [pc, #60]	@ (240008b4 <HAL_DeInit+0xa0>)
{
24000878:	4605      	mov	r5, r0
  if((uint32_t)uwTickFreq == 0UL)
2400087a:	7832      	ldrb	r2, [r6, #0]
2400087c:	b90a      	cbnz	r2, 24000882 <HAL_DeInit+0x6e>
  {
    return HAL_ERROR;
2400087e:	2001      	movs	r0, #1
    return HAL_ERROR;
  }

  /* Return function status */
  return HAL_OK;
}
24000880:	bd70      	pop	{r4, r5, r6, pc}
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000UL / (uint32_t)uwTickFreq)) > 0U)
24000882:	f44f 737a 	mov.w	r3, #1000	@ 0x3e8
24000886:	fbb3 f3f2 	udiv	r3, r3, r2
2400088a:	4a0b      	ldr	r2, [pc, #44]	@ (240008b8 <HAL_DeInit+0xa4>)
2400088c:	6810      	ldr	r0, [r2, #0]
2400088e:	fbb0 f0f3 	udiv	r0, r0, r3
24000892:	f000 fab9 	bl	24000e08 <HAL_SYSTICK_Config>
24000896:	4604      	mov	r4, r0
24000898:	2800      	cmp	r0, #0
2400089a:	d1f0      	bne.n	2400087e <HAL_DeInit+0x6a>
  if (TickPriority < (1UL << __NVIC_PRIO_BITS))
2400089c:	2d0f      	cmp	r5, #15
2400089e:	d8ee      	bhi.n	2400087e <HAL_DeInit+0x6a>
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
240008a0:	4602      	mov	r2, r0
240008a2:	4629      	mov	r1, r5
240008a4:	f04f 30ff 	mov.w	r0, #4294967295
240008a8:	f000 fa4a 	bl	24000d40 <HAL_NVIC_SetPriority>
    uwTickPrio = TickPriority;
240008ac:	4620      	mov	r0, r4
240008ae:	6075      	str	r5, [r6, #4]
  return HAL_OK;
240008b0:	e7e6      	b.n	24000880 <HAL_DeInit+0x6c>
240008b2:	bf00      	nop
240008b4:	240004a0 	.word	0x240004a0
240008b8:	24000518 	.word	0x24000518

240008bc <HAL_Init>:
{
240008bc:	b510      	push	{r4, lr}
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
240008be:	2003      	movs	r0, #3
240008c0:	f000 fa2c 	bl	24000d1c <HAL_NVIC_SetPriorityGrouping>
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
240008c4:	f009 f93a 	bl	24009b3c <HAL_RCC_GetSysClockFreq>
240008c8:	490f      	ldr	r1, [pc, #60]	@ (24000908 <HAL_Init+0x4c>)
240008ca:	4a10      	ldr	r2, [pc, #64]	@ (2400090c <HAL_Init+0x50>)
240008cc:	698b      	ldr	r3, [r1, #24]
240008ce:	f3c3 2303 	ubfx	r3, r3, #8, #4
240008d2:	5cd3      	ldrb	r3, [r2, r3]
240008d4:	f003 031f 	and.w	r3, r3, #31
240008d8:	40d8      	lsrs	r0, r3
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
240008da:	698b      	ldr	r3, [r1, #24]
240008dc:	f003 030f 	and.w	r3, r3, #15
240008e0:	5cd3      	ldrb	r3, [r2, r3]
240008e2:	4a0b      	ldr	r2, [pc, #44]	@ (24000910 <HAL_Init+0x54>)
240008e4:	f003 031f 	and.w	r3, r3, #31
240008e8:	fa20 f303 	lsr.w	r3, r0, r3
240008ec:	6013      	str	r3, [r2, #0]
  SystemCoreClock = common_system_clock;
240008ee:	4b09      	ldr	r3, [pc, #36]	@ (24000914 <HAL_Init+0x58>)
240008f0:	6018      	str	r0, [r3, #0]
  if(HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
240008f2:	2000      	movs	r0, #0
240008f4:	f011 fa86 	bl	24011e04 <HAL_InitTick>
240008f8:	4604      	mov	r4, r0
240008fa:	b918      	cbnz	r0, 24000904 <HAL_Init+0x48>
  HAL_MspInit();
240008fc:	f011 feaa 	bl	24012654 <HAL_MspInit>
}
24000900:	4620      	mov	r0, r4
24000902:	bd10      	pop	{r4, pc}
    return HAL_ERROR;
24000904:	2401      	movs	r4, #1
24000906:	e7fb      	b.n	24000900 <HAL_Init+0x44>
24000908:	58024400 	.word	0x58024400
2400090c:	240141fa 	.word	0x240141fa
24000910:	24000514 	.word	0x24000514
24000914:	24000518 	.word	0x24000518

24000918 <HAL_IncTick>:
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick += (uint32_t)uwTickFreq;
24000918:	4a03      	ldr	r2, [pc, #12]	@ (24000928 <HAL_IncTick+0x10>)
2400091a:	4b04      	ldr	r3, [pc, #16]	@ (2400092c <HAL_IncTick+0x14>)
2400091c:	6811      	ldr	r1, [r2, #0]
2400091e:	781b      	ldrb	r3, [r3, #0]
24000920:	440b      	add	r3, r1
24000922:	6013      	str	r3, [r2, #0]
}
24000924:	4770      	bx	lr
24000926:	bf00      	nop
24000928:	24000578 	.word	0x24000578
2400092c:	240004a0 	.word	0x240004a0
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
24000930:	4b01      	ldr	r3, [pc, #4]	@ (24000938 <HAL_IncTick+0x20>)
24000932:	6818      	ldr	r0, [r3, #0]
}
24000934:	4770      	bx	lr
24000936:	bf00      	nop
24000938:	24000578 	.word	0x24000578

2400093c <HAL_GetTickPrio>:
  * @retval tick priority
  */
uint32_t HAL_GetTickPrio(void)
{
  return uwTickPrio;
}
2400093c:	4b01      	ldr	r3, [pc, #4]	@ (24000944 <HAL_GetTickPrio+0x8>)
2400093e:	6858      	ldr	r0, [r3, #4]
24000940:	4770      	bx	lr
24000942:	bf00      	nop
24000944:	240004a0 	.word	0x240004a0

24000948 <HAL_SetTickFreq>:
/**
  * @brief Set new tick Freq.
  * @retval Status
  */
HAL_StatusTypeDef HAL_SetTickFreq(HAL_TickFreqTypeDef Freq)
{
24000948:	b538      	push	{r3, r4, r5, lr}
  HAL_StatusTypeDef status  = HAL_OK;
  HAL_TickFreqTypeDef prevTickFreq;

  assert_param(IS_TICKFREQ(Freq));

  if (uwTickFreq != Freq)
2400094a:	4c06      	ldr	r4, [pc, #24]	@ (24000964 <HAL_SetTickFreq+0x1c>)
2400094c:	7825      	ldrb	r5, [r4, #0]
2400094e:	4285      	cmp	r5, r0
24000950:	d004      	beq.n	2400095c <HAL_SetTickFreq+0x14>

    /* Back up uwTickFreq frequency */
    prevTickFreq = uwTickFreq;

    /* Update uwTickFreq global variable used by HAL_InitTick() */
    uwTickFreq = Freq;
24000952:	7020      	strb	r0, [r4, #0]

    /* Apply the new tick Freq  */
    status = HAL_InitTick(uwTickPrio);
24000954:	6860      	ldr	r0, [r4, #4]
24000956:	f011 fa55 	bl	24011e04 <HAL_InitTick>
    if (status != HAL_OK)
2400095a:	b908      	cbnz	r0, 24000960 <HAL_SetTickFreq+0x18>
  HAL_StatusTypeDef status  = HAL_OK;
2400095c:	2000      	movs	r0, #0
      uwTickFreq = prevTickFreq;
    }
  }

  return status;
}
2400095e:	bd38      	pop	{r3, r4, r5, pc}
      uwTickFreq = prevTickFreq;
24000960:	7025      	strb	r5, [r4, #0]
24000962:	e7fc      	b.n	2400095e <HAL_SetTickFreq+0x16>
24000964:	240004a0 	.word	0x240004a0

24000968 <HAL_GetTickFreq>:
  * @retval tick period in Hz
  */
HAL_TickFreqTypeDef HAL_GetTickFreq(void)
{
  return uwTickFreq;
}
24000968:	4b01      	ldr	r3, [pc, #4]	@ (24000970 <HAL_GetTickFreq+0x8>)
2400096a:	7818      	ldrb	r0, [r3, #0]
2400096c:	4770      	bx	lr
2400096e:	bf00      	nop
24000970:	240004a0 	.word	0x240004a0
  *       implementations in user file.
  * @param Delay  specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
24000974:	b538      	push	{r3, r4, r5, lr}
24000976:	4604      	mov	r4, r0
  uint32_t tickstart = HAL_GetTick();
24000978:	f011 fa46 	bl	24011e08 <HAL_GetTick>
2400097c:	4605      	mov	r5, r0
  uint32_t wait = Delay;

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
2400097e:	1c63      	adds	r3, r4, #1
  {
    wait += (uint32_t)(uwTickFreq);
24000980:	bf1e      	ittt	ne
24000982:	4b04      	ldrne	r3, [pc, #16]	@ (24000994 <HAL_GetTickFreq+0x2c>)
24000984:	781b      	ldrbne	r3, [r3, #0]
24000986:	18e4      	addne	r4, r4, r3
  }

  while ((HAL_GetTick() - tickstart) < wait)
24000988:	f011 fa3e 	bl	24011e08 <HAL_GetTick>
2400098c:	1b43      	subs	r3, r0, r5
2400098e:	42a3      	cmp	r3, r4
24000990:	d3fa      	bcc.n	24000988 <HAL_GetTickFreq+0x20>
  {
  }
}
24000992:	bd38      	pop	{r3, r4, r5, pc}
24000994:	240004a0 	.word	0x240004a0

24000998 <HAL_SuspendTick>:
  * @retval None
  */
__weak void HAL_SuspendTick(void)
{
  /* Disable SysTick Interrupt */
  SysTick->CTRL &= ~SysTick_CTRL_TICKINT_Msk;
24000998:	f04f 22e0 	mov.w	r2, #3758153728	@ 0xe000e000
2400099c:	6913      	ldr	r3, [r2, #16]
2400099e:	f023 0302 	bic.w	r3, r3, #2
240009a2:	6113      	str	r3, [r2, #16]
}
240009a4:	4770      	bx	lr

240009a6 <HAL_ResumeTick>:
  * @retval None
  */
__weak void HAL_ResumeTick(void)
{
  /* Enable SysTick Interrupt */
  SysTick->CTRL  |= SysTick_CTRL_TICKINT_Msk;
240009a6:	f04f 22e0 	mov.w	r2, #3758153728	@ 0xe000e000
240009aa:	6913      	ldr	r3, [r2, #16]
240009ac:	f043 0302 	orr.w	r3, r3, #2
240009b0:	6113      	str	r3, [r2, #16]
}
240009b2:	4770      	bx	lr

240009b4 <HAL_GetHalVersion>:
  * @retval version : 0xXYZR (8bits for each decimal, R for RC)
  */
uint32_t HAL_GetHalVersion(void)
{
 return __STM32H7xx_HAL_VERSION;
}
240009b4:	f04f 7084 	mov.w	r0, #17301504	@ 0x1080000
240009b8:	4770      	bx	lr

240009ba <HAL_GetREVID>:
  * @brief  Returns the device revision identifier.
  * @retval Device revision identifier
  */
uint32_t HAL_GetREVID(void)
{
   return((DBGMCU->IDCODE) >> 16);
240009ba:	4b02      	ldr	r3, [pc, #8]	@ (240009c4 <HAL_GetREVID+0xa>)
240009bc:	6818      	ldr	r0, [r3, #0]
}
240009be:	0c00      	lsrs	r0, r0, #16
240009c0:	4770      	bx	lr
240009c2:	bf00      	nop
240009c4:	5c001000 	.word	0x5c001000

240009c8 <HAL_GetDEVID>:
  * @brief  Returns the device identifier.
  * @retval Device identifier
  */
uint32_t HAL_GetDEVID(void)
{
   return((DBGMCU->IDCODE) & IDCODE_DEVID_MASK);
240009c8:	4b02      	ldr	r3, [pc, #8]	@ (240009d4 <HAL_GetDEVID+0xc>)
240009ca:	6818      	ldr	r0, [r3, #0]
}
240009cc:	f3c0 000b 	ubfx	r0, r0, #0, #12
240009d0:	4770      	bx	lr
240009d2:	bf00      	nop
240009d4:	5c001000 	.word	0x5c001000

240009d8 <HAL_GetUIDw0>:
  * @retval Device identifier
  */
uint32_t HAL_GetUIDw0(void)
{
  return(READ_REG(*((uint32_t *)UID_BASE)));
}
240009d8:	4b01      	ldr	r3, [pc, #4]	@ (240009e0 <HAL_GetUIDw0+0x8>)
240009da:	f8d3 0800 	ldr.w	r0, [r3, #2048]	@ 0x800
240009de:	4770      	bx	lr
240009e0:	1ff1e000 	.word	0x1ff1e000

240009e4 <HAL_GetUIDw1>:
  * @retval Device identifier
  */
uint32_t HAL_GetUIDw1(void)
{
  return(READ_REG(*((uint32_t *)(UID_BASE + 4U))));
}
240009e4:	4b01      	ldr	r3, [pc, #4]	@ (240009ec <HAL_GetUIDw1+0x8>)
240009e6:	f8d3 0804 	ldr.w	r0, [r3, #2052]	@ 0x804
240009ea:	4770      	bx	lr
240009ec:	1ff1e000 	.word	0x1ff1e000

240009f0 <HAL_GetUIDw2>:
  * @retval Device identifier
  */
uint32_t HAL_GetUIDw2(void)
{
  return(READ_REG(*((uint32_t *)(UID_BASE + 8U))));
}
240009f0:	4b01      	ldr	r3, [pc, #4]	@ (240009f8 <HAL_GetUIDw2+0x8>)
240009f2:	f8d3 0808 	ldr.w	r0, [r3, #2056]	@ 0x808
240009f6:	4770      	bx	lr
240009f8:	1ff1e000 	.word	0x1ff1e000

240009fc <HAL_SYSCFG_VREFBUF_VoltageScalingConfig>:
void HAL_SYSCFG_VREFBUF_VoltageScalingConfig(uint32_t VoltageScaling)
{
  /* Check the parameters */
  assert_param(IS_SYSCFG_VREFBUF_VOLTAGE_SCALE(VoltageScaling));

  MODIFY_REG(VREFBUF->CSR, VREFBUF_CSR_VRS, VoltageScaling);
240009fc:	4a03      	ldr	r2, [pc, #12]	@ (24000a0c <HAL_SYSCFG_VREFBUF_VoltageScalingConfig+0x10>)
240009fe:	6813      	ldr	r3, [r2, #0]
24000a00:	f023 0370 	bic.w	r3, r3, #112	@ 0x70
24000a04:	4303      	orrs	r3, r0
24000a06:	6013      	str	r3, [r2, #0]
}
24000a08:	4770      	bx	lr
24000a0a:	bf00      	nop
24000a0c:	58003c00 	.word	0x58003c00

24000a10 <HAL_SYSCFG_VREFBUF_HighImpedanceConfig>:
void HAL_SYSCFG_VREFBUF_HighImpedanceConfig(uint32_t Mode)
{
  /* Check the parameters */
  assert_param(IS_SYSCFG_VREFBUF_HIGH_IMPEDANCE(Mode));

  MODIFY_REG(VREFBUF->CSR, VREFBUF_CSR_HIZ, Mode);
24000a10:	4a03      	ldr	r2, [pc, #12]	@ (24000a20 <HAL_SYSCFG_VREFBUF_HighImpedanceConfig+0x10>)
24000a12:	6813      	ldr	r3, [r2, #0]
24000a14:	f023 0302 	bic.w	r3, r3, #2
24000a18:	4303      	orrs	r3, r0
24000a1a:	6013      	str	r3, [r2, #0]
}
24000a1c:	4770      	bx	lr
24000a1e:	bf00      	nop
24000a20:	58003c00 	.word	0x58003c00

24000a24 <HAL_SYSCFG_VREFBUF_TrimmingConfig>:
void HAL_SYSCFG_VREFBUF_TrimmingConfig(uint32_t TrimmingValue)
{
  /* Check the parameters */
  assert_param(IS_SYSCFG_VREFBUF_TRIMMING(TrimmingValue));

  MODIFY_REG(VREFBUF->CCR, VREFBUF_CCR_TRIM, TrimmingValue);
24000a24:	4a03      	ldr	r2, [pc, #12]	@ (24000a34 <HAL_SYSCFG_VREFBUF_TrimmingConfig+0x10>)
24000a26:	6853      	ldr	r3, [r2, #4]
24000a28:	f023 033f 	bic.w	r3, r3, #63	@ 0x3f
24000a2c:	4303      	orrs	r3, r0
24000a2e:	6053      	str	r3, [r2, #4]
}
24000a30:	4770      	bx	lr
24000a32:	bf00      	nop
24000a34:	58003c00 	.word	0x58003c00

24000a38 <HAL_SYSCFG_EnableVREFBUF>:
/**
  * @brief  Enable the Internal Voltage Reference buffer (VREFBUF).
  * @retval HAL_OK/HAL_TIMEOUT
  */
HAL_StatusTypeDef HAL_SYSCFG_EnableVREFBUF(void)
{
24000a38:	b538      	push	{r3, r4, r5, lr}
  uint32_t  tickstart;

  SET_BIT(VREFBUF->CSR, VREFBUF_CSR_ENVR);
24000a3a:	4c0a      	ldr	r4, [pc, #40]	@ (24000a64 <HAL_SYSCFG_EnableVREFBUF+0x2c>)
24000a3c:	6823      	ldr	r3, [r4, #0]
24000a3e:	f043 0301 	orr.w	r3, r3, #1
24000a42:	6023      	str	r3, [r4, #0]

  /* Get Start Tick*/
  tickstart = HAL_GetTick();
24000a44:	f011 f9e0 	bl	24011e08 <HAL_GetTick>
24000a48:	4605      	mov	r5, r0

  /* Wait for VRR bit  */
  while(READ_BIT(VREFBUF->CSR, VREFBUF_CSR_VRR) == 0UL)
24000a4a:	6823      	ldr	r3, [r4, #0]
24000a4c:	071b      	lsls	r3, r3, #28
24000a4e:	d501      	bpl.n	24000a54 <HAL_SYSCFG_EnableVREFBUF+0x1c>
    {
      return HAL_TIMEOUT;
    }
  }

  return HAL_OK;
24000a50:	2000      	movs	r0, #0
}
24000a52:	bd38      	pop	{r3, r4, r5, pc}
    if((HAL_GetTick() - tickstart) > VREFBUF_TIMEOUT_VALUE)
24000a54:	f011 f9d8 	bl	24011e08 <HAL_GetTick>
24000a58:	1b40      	subs	r0, r0, r5
24000a5a:	280a      	cmp	r0, #10
24000a5c:	d9f5      	bls.n	24000a4a <HAL_SYSCFG_EnableVREFBUF+0x12>
      return HAL_TIMEOUT;
24000a5e:	2003      	movs	r0, #3
24000a60:	e7f7      	b.n	24000a52 <HAL_SYSCFG_EnableVREFBUF+0x1a>
24000a62:	bf00      	nop
24000a64:	58003c00 	.word	0x58003c00

24000a68 <HAL_SYSCFG_DisableVREFBUF>:
  *
  * @retval None
  */
void HAL_SYSCFG_DisableVREFBUF(void)
{
  CLEAR_BIT(VREFBUF->CSR, VREFBUF_CSR_ENVR);
24000a68:	4a02      	ldr	r2, [pc, #8]	@ (24000a74 <HAL_SYSCFG_DisableVREFBUF+0xc>)
24000a6a:	6813      	ldr	r3, [r2, #0]
24000a6c:	f023 0301 	bic.w	r3, r3, #1
24000a70:	6013      	str	r3, [r2, #0]
}
24000a72:	4770      	bx	lr
24000a74:	58003c00 	.word	0x58003c00

24000a78 <HAL_SYSCFG_ETHInterfaceSelect>:
void HAL_SYSCFG_ETHInterfaceSelect(uint32_t SYSCFG_ETHInterface)
{
  /* Check the parameter */
  assert_param(IS_SYSCFG_ETHERNET_CONFIG(SYSCFG_ETHInterface));

  MODIFY_REG(SYSCFG->PMCR, SYSCFG_PMCR_EPIS_SEL, (uint32_t)(SYSCFG_ETHInterface));
24000a78:	4a03      	ldr	r2, [pc, #12]	@ (24000a88 <HAL_SYSCFG_ETHInterfaceSelect+0x10>)
24000a7a:	6853      	ldr	r3, [r2, #4]
24000a7c:	f423 0360 	bic.w	r3, r3, #14680064	@ 0xe00000
24000a80:	4303      	orrs	r3, r0
24000a82:	6053      	str	r3, [r2, #4]
}
24000a84:	4770      	bx	lr
24000a86:	bf00      	nop
24000a88:	58000400 	.word	0x58000400

24000a8c <HAL_SYSCFG_AnalogSwitchConfig>:
{
  /* Check the parameter */
  assert_param(IS_SYSCFG_ANALOG_SWITCH(SYSCFG_AnalogSwitch));
  assert_param(IS_SYSCFG_SWITCH_STATE(SYSCFG_SwitchState));

  MODIFY_REG(SYSCFG->PMCR, (uint32_t) SYSCFG_AnalogSwitch, (uint32_t)(SYSCFG_SwitchState));
24000a8c:	4a03      	ldr	r2, [pc, #12]	@ (24000a9c <HAL_SYSCFG_AnalogSwitchConfig+0x10>)
24000a8e:	6853      	ldr	r3, [r2, #4]
24000a90:	ea23 0300 	bic.w	r3, r3, r0
24000a94:	430b      	orrs	r3, r1
24000a96:	6053      	str	r3, [r2, #4]
}
24000a98:	4770      	bx	lr
24000a9a:	bf00      	nop
24000a9c:	58000400 	.word	0x58000400

24000aa0 <HAL_SYSCFG_EnableBOOST>:
  *         performance is the same on the full voltage range
  * @retval None
  */
void HAL_SYSCFG_EnableBOOST(void)
{
 SET_BIT(SYSCFG->PMCR, SYSCFG_PMCR_BOOSTEN) ;
24000aa0:	4a02      	ldr	r2, [pc, #8]	@ (24000aac <HAL_SYSCFG_EnableBOOST+0xc>)
24000aa2:	6853      	ldr	r3, [r2, #4]
24000aa4:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
24000aa8:	6053      	str	r3, [r2, #4]
}
24000aaa:	4770      	bx	lr
24000aac:	58000400 	.word	0x58000400

24000ab0 <HAL_SYSCFG_DisableBOOST>:
  *         performance is the same on the full voltage range
  * @retval None
  */
void HAL_SYSCFG_DisableBOOST(void)
{
 CLEAR_BIT(SYSCFG->PMCR, SYSCFG_PMCR_BOOSTEN) ;
24000ab0:	4a02      	ldr	r2, [pc, #8]	@ (24000abc <HAL_SYSCFG_DisableBOOST+0xc>)
24000ab2:	6853      	ldr	r3, [r2, #4]
24000ab4:	f423 7380 	bic.w	r3, r3, #256	@ 0x100
24000ab8:	6053      	str	r3, [r2, #4]
}
24000aba:	4770      	bx	lr
24000abc:	58000400 	.word	0x58000400

24000ac0 <HAL_SYSCFG_CM7BootAddConfig>:
  {
    /* Configure CM7 BOOT ADD0 */
#if defined(DUAL_CORE)
    MODIFY_REG(SYSCFG->UR2, SYSCFG_UR2_BCM7_ADD0, ((BootAddress >> 16) << SYSCFG_UR2_BCM7_ADD0_Pos));
#else
    MODIFY_REG(SYSCFG->UR2, SYSCFG_UR2_BOOT_ADD0, ((BootAddress >> 16) << SYSCFG_UR2_BOOT_ADD0_Pos));
24000ac0:	0c09      	lsrs	r1, r1, #16
24000ac2:	4a09      	ldr	r2, [pc, #36]	@ (24000ae8 <HAL_SYSCFG_CM7BootAddConfig+0x28>)
  if ( BootRegister == SYSCFG_BOOT_ADDR0 )
24000ac4:	b938      	cbnz	r0, 24000ad6 <HAL_SYSCFG_CM7BootAddConfig+0x16>
    MODIFY_REG(SYSCFG->UR2, SYSCFG_UR2_BOOT_ADD0, ((BootAddress >> 16) << SYSCFG_UR2_BOOT_ADD0_Pos));
24000ac6:	f8d2 3308 	ldr.w	r3, [r2, #776]	@ 0x308
24000aca:	b29b      	uxth	r3, r3
24000acc:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
24000ad0:	f8c2 3308 	str.w	r3, [r2, #776]	@ 0x308
24000ad4:	4770      	bx	lr
  {
    /* Configure CM7 BOOT ADD1 */
#if defined(DUAL_CORE)
    MODIFY_REG(SYSCFG->UR3, SYSCFG_UR3_BCM7_ADD1, (BootAddress >> 16));
#else
    MODIFY_REG(SYSCFG->UR3, SYSCFG_UR3_BOOT_ADD1, (BootAddress >> 16));
24000ad6:	f8d2 330c 	ldr.w	r3, [r2, #780]	@ 0x30c
24000ada:	0c1b      	lsrs	r3, r3, #16
24000adc:	041b      	lsls	r3, r3, #16
24000ade:	430b      	orrs	r3, r1
24000ae0:	f8c2 330c 	str.w	r3, [r2, #780]	@ 0x30c
#endif /*DUAL_CORE*/
  }
}
24000ae4:	4770      	bx	lr
24000ae6:	bf00      	nop
24000ae8:	58000400 	.word	0x58000400

24000aec <HAL_EnableCompensationCell>:
  *         voltage ranges from 2.4 to 3.6 V.
  * @retval None
  */
void HAL_EnableCompensationCell(void)
{
  SET_BIT(SYSCFG->CCCSR, SYSCFG_CCCSR_EN) ;
24000aec:	4a02      	ldr	r2, [pc, #8]	@ (24000af8 <HAL_EnableCompensationCell+0xc>)
24000aee:	6a13      	ldr	r3, [r2, #32]
24000af0:	f043 0301 	orr.w	r3, r3, #1
24000af4:	6213      	str	r3, [r2, #32]
}
24000af6:	4770      	bx	lr
24000af8:	58000400 	.word	0x58000400

24000afc <HAL_DisableCompensationCell>:
  *         voltage ranges from 2.4 to 3.6 V.
  * @retval None
  */
void HAL_DisableCompensationCell(void)
{
  CLEAR_BIT(SYSCFG->CCCSR, SYSCFG_CCCSR_EN);
24000afc:	4a02      	ldr	r2, [pc, #8]	@ (24000b08 <HAL_DisableCompensationCell+0xc>)
24000afe:	6a13      	ldr	r3, [r2, #32]
24000b00:	f023 0301 	bic.w	r3, r3, #1
24000b04:	6213      	str	r3, [r2, #32]
}
24000b06:	4770      	bx	lr
24000b08:	58000400 	.word	0x58000400

24000b0c <HAL_SYSCFG_EnableIOSpeedOptimize>:
  * @retval None
  */
void HAL_SYSCFG_EnableIOSpeedOptimize(void)
{
#if defined(SYSCFG_CCCSR_HSLV)
  SET_BIT(SYSCFG->CCCSR, SYSCFG_CCCSR_HSLV);
24000b0c:	4a02      	ldr	r2, [pc, #8]	@ (24000b18 <HAL_SYSCFG_EnableIOSpeedOptimize+0xc>)
24000b0e:	6a13      	ldr	r3, [r2, #32]
24000b10:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
24000b14:	6213      	str	r3, [r2, #32]
#else
  SET_BIT(SYSCFG->CCCSR, (SYSCFG_CCCSR_HSLV0| SYSCFG_CCCSR_HSLV1 | SYSCFG_CCCSR_HSLV2  | SYSCFG_CCCSR_HSLV3));
#endif   /* SYSCFG_CCCSR_HSLV */
}
24000b16:	4770      	bx	lr
24000b18:	58000400 	.word	0x58000400

24000b1c <HAL_SYSCFG_DisableIOSpeedOptimize>:
  * @retval None
  */
void HAL_SYSCFG_DisableIOSpeedOptimize(void)
{
#if defined(SYSCFG_CCCSR_HSLV)
  CLEAR_BIT(SYSCFG->CCCSR, SYSCFG_CCCSR_HSLV);
24000b1c:	4a02      	ldr	r2, [pc, #8]	@ (24000b28 <HAL_SYSCFG_DisableIOSpeedOptimize+0xc>)
24000b1e:	6a13      	ldr	r3, [r2, #32]
24000b20:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
24000b24:	6213      	str	r3, [r2, #32]
#else
  CLEAR_BIT(SYSCFG->CCCSR, (SYSCFG_CCCSR_HSLV0| SYSCFG_CCCSR_HSLV1 | SYSCFG_CCCSR_HSLV2  | SYSCFG_CCCSR_HSLV3));
#endif   /* SYSCFG_CCCSR_HSLV */
}
24000b26:	4770      	bx	lr
24000b28:	58000400 	.word	0x58000400

24000b2c <HAL_SYSCFG_CompensationCodeSelect>:
  */
void HAL_SYSCFG_CompensationCodeSelect(uint32_t SYSCFG_CompCode)
{
  /* Check the parameter */
  assert_param(IS_SYSCFG_CODE_SELECT(SYSCFG_CompCode));
  MODIFY_REG(SYSCFG->CCCSR, SYSCFG_CCCSR_CS, (uint32_t)(SYSCFG_CompCode));
24000b2c:	4a03      	ldr	r2, [pc, #12]	@ (24000b3c <HAL_SYSCFG_CompensationCodeSelect+0x10>)
24000b2e:	6a13      	ldr	r3, [r2, #32]
24000b30:	f023 0302 	bic.w	r3, r3, #2
24000b34:	4303      	orrs	r3, r0
24000b36:	6213      	str	r3, [r2, #32]
}
24000b38:	4770      	bx	lr
24000b3a:	bf00      	nop
24000b3c:	58000400 	.word	0x58000400

24000b40 <HAL_SYSCFG_CompensationCodeConfig>:
void HAL_SYSCFG_CompensationCodeConfig(uint32_t SYSCFG_PMOSCode, uint32_t SYSCFG_NMOSCode )
{
  /* Check the parameter */
  assert_param(IS_SYSCFG_CODE_CONFIG(SYSCFG_PMOSCode));
  assert_param(IS_SYSCFG_CODE_CONFIG(SYSCFG_NMOSCode));
  MODIFY_REG(SYSCFG->CCCR, SYSCFG_CCCR_NCC|SYSCFG_CCCR_PCC, (((uint32_t)(SYSCFG_PMOSCode)<< 4)|(uint32_t)(SYSCFG_NMOSCode)) );
24000b40:	4a04      	ldr	r2, [pc, #16]	@ (24000b54 <HAL_SYSCFG_CompensationCodeConfig+0x14>)
24000b42:	6a93      	ldr	r3, [r2, #40]	@ 0x28
24000b44:	f023 03ff 	bic.w	r3, r3, #255	@ 0xff
24000b48:	430b      	orrs	r3, r1
24000b4a:	ea43 1300 	orr.w	r3, r3, r0, lsl #4
24000b4e:	6293      	str	r3, [r2, #40]	@ 0x28
}
24000b50:	4770      	bx	lr
24000b52:	bf00      	nop
24000b54:	58000400 	.word	0x58000400

24000b58 <HAL_DBGMCU_EnableDBGSleepMode>:
  * @brief  Enable the Debug Module during Domain1/CDomain SLEEP mode
  * @retval None
  */
void HAL_EnableDBGSleepMode(void)
{
  SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_SLEEPD1);
24000b58:	4a02      	ldr	r2, [pc, #8]	@ (24000b64 <HAL_DBGMCU_EnableDBGSleepMode+0xc>)
24000b5a:	6853      	ldr	r3, [r2, #4]
24000b5c:	f043 0301 	orr.w	r3, r3, #1
24000b60:	6053      	str	r3, [r2, #4]
}
24000b62:	4770      	bx	lr
24000b64:	5c001000 	.word	0x5c001000

24000b68 <HAL_DBGMCU_DisableDBGSleepMode>:
  * @brief  Disable the Debug Module during Domain1/CDomain SLEEP mode
  * @retval None
  */
void HAL_DisableDBGSleepMode(void)
{
  CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_SLEEPD1);
24000b68:	4a02      	ldr	r2, [pc, #8]	@ (24000b74 <HAL_DBGMCU_DisableDBGSleepMode+0xc>)
24000b6a:	6853      	ldr	r3, [r2, #4]
24000b6c:	f023 0301 	bic.w	r3, r3, #1
24000b70:	6053      	str	r3, [r2, #4]
}
24000b72:	4770      	bx	lr
24000b74:	5c001000 	.word	0x5c001000

24000b78 <HAL_DBGMCU_EnableDBGStopMode>:
  * @brief  Enable the Debug Module during Domain1/CDomain STOP mode
  * @retval None
  */
void HAL_EnableDBGStopMode(void)
{
  SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STOPD1);
24000b78:	4a02      	ldr	r2, [pc, #8]	@ (24000b84 <HAL_DBGMCU_EnableDBGStopMode+0xc>)
24000b7a:	6853      	ldr	r3, [r2, #4]
24000b7c:	f043 0302 	orr.w	r3, r3, #2
24000b80:	6053      	str	r3, [r2, #4]
}
24000b82:	4770      	bx	lr
24000b84:	5c001000 	.word	0x5c001000

24000b88 <HAL_DBGMCU_DisableDBGStopMode>:
  * @brief  Disable the Debug Module during Domain1/CDomain STOP mode
  * @retval None
  */
void HAL_DisableDBGStopMode(void)
{
  CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STOPD1);
24000b88:	4a02      	ldr	r2, [pc, #8]	@ (24000b94 <HAL_DBGMCU_DisableDBGStopMode+0xc>)
24000b8a:	6853      	ldr	r3, [r2, #4]
24000b8c:	f023 0302 	bic.w	r3, r3, #2
24000b90:	6053      	str	r3, [r2, #4]
}
24000b92:	4770      	bx	lr
24000b94:	5c001000 	.word	0x5c001000

24000b98 <HAL_DBGMCU_EnableDBGStandbyMode>:
  * @brief  Enable the Debug Module during Domain1/CDomain STANDBY mode
  * @retval None
  */
void HAL_EnableDBGStandbyMode(void)
{
  SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STANDBYD1);
24000b98:	4a02      	ldr	r2, [pc, #8]	@ (24000ba4 <HAL_DBGMCU_EnableDBGStandbyMode+0xc>)
24000b9a:	6853      	ldr	r3, [r2, #4]
24000b9c:	f043 0304 	orr.w	r3, r3, #4
24000ba0:	6053      	str	r3, [r2, #4]
}
24000ba2:	4770      	bx	lr
24000ba4:	5c001000 	.word	0x5c001000

24000ba8 <HAL_DBGMCU_DisableDBGStandbyMode>:
  * @brief  Disable the Debug Module during Domain1/CDomain STANDBY mode
  * @retval None
  */
void HAL_DisableDBGStandbyMode(void)
{
  CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STANDBYD1);
24000ba8:	4a02      	ldr	r2, [pc, #8]	@ (24000bb4 <HAL_DBGMCU_DisableDBGStandbyMode+0xc>)
24000baa:	6853      	ldr	r3, [r2, #4]
24000bac:	f023 0304 	bic.w	r3, r3, #4
24000bb0:	6053      	str	r3, [r2, #4]
}
24000bb2:	4770      	bx	lr
24000bb4:	5c001000 	.word	0x5c001000

24000bb8 <HAL_EnableDomain3DBGStopMode>:
  * @brief  Enable the Debug Module during Domain3/SRDomain STOP mode
  * @retval None
  */
void HAL_EnableDomain3DBGStopMode(void)
{
  SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STOPD3);
24000bb8:	4a02      	ldr	r2, [pc, #8]	@ (24000bc4 <HAL_EnableDomain3DBGStopMode+0xc>)
24000bba:	6853      	ldr	r3, [r2, #4]
24000bbc:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
24000bc0:	6053      	str	r3, [r2, #4]
}
24000bc2:	4770      	bx	lr
24000bc4:	5c001000 	.word	0x5c001000

24000bc8 <HAL_DisableDomain3DBGStopMode>:
  * @brief  Disable the Debug Module during Domain3/SRDomain STOP mode
  * @retval None
  */
void HAL_DisableDomain3DBGStopMode(void)
{
  CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STOPD3);
24000bc8:	4a02      	ldr	r2, [pc, #8]	@ (24000bd4 <HAL_DisableDomain3DBGStopMode+0xc>)
24000bca:	6853      	ldr	r3, [r2, #4]
24000bcc:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
24000bd0:	6053      	str	r3, [r2, #4]
}
24000bd2:	4770      	bx	lr
24000bd4:	5c001000 	.word	0x5c001000

24000bd8 <HAL_EnableDomain3DBGStandbyMode>:
  * @brief  Enable the Debug Module during Domain3/SRDomain STANDBY mode
  * @retval None
  */
void HAL_EnableDomain3DBGStandbyMode(void)
{
  SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STANDBYD3);
24000bd8:	4a02      	ldr	r2, [pc, #8]	@ (24000be4 <HAL_EnableDomain3DBGStandbyMode+0xc>)
24000bda:	6853      	ldr	r3, [r2, #4]
24000bdc:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
24000be0:	6053      	str	r3, [r2, #4]
}
24000be2:	4770      	bx	lr
24000be4:	5c001000 	.word	0x5c001000

24000be8 <HAL_DisableDomain3DBGStandbyMode>:
  * @brief  Disable the Debug Module during Domain3/SRDomain STANDBY mode
  * @retval None
  */
void HAL_DisableDomain3DBGStandbyMode(void)
{
  CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STANDBYD3);
24000be8:	4a02      	ldr	r2, [pc, #8]	@ (24000bf4 <HAL_DisableDomain3DBGStandbyMode+0xc>)
24000bea:	6853      	ldr	r3, [r2, #4]
24000bec:	f423 7380 	bic.w	r3, r3, #256	@ 0x100
24000bf0:	6053      	str	r3, [r2, #4]
}
24000bf2:	4770      	bx	lr
24000bf4:	5c001000 	.word	0x5c001000

24000bf8 <HAL_SetFMCMemorySwappingConfig>:
  */
void HAL_SetFMCMemorySwappingConfig(uint32_t BankMapConfig)
{
  /* Check the parameter */
  assert_param(IS_FMC_SWAPBMAP_MODE(BankMapConfig));
  MODIFY_REG(FMC_Bank1_R->BTCR[0], FMC_BCR1_BMAP, BankMapConfig);
24000bf8:	4a03      	ldr	r2, [pc, #12]	@ (24000c08 <HAL_SetFMCMemorySwappingConfig+0x10>)
24000bfa:	6813      	ldr	r3, [r2, #0]
24000bfc:	f023 7340 	bic.w	r3, r3, #50331648	@ 0x3000000
24000c00:	4303      	orrs	r3, r0
24000c02:	6013      	str	r3, [r2, #0]
}
24000c04:	4770      	bx	lr
24000c06:	bf00      	nop
24000c08:	52004000 	.word	0x52004000

24000c0c <HAL_GetFMCMemorySwappingConfig>:
  * @retval The FMC Bank mapping mode. This parameter can be
            FMC_SWAPBMAP_DISABLE, FMC_SWAPBMAP_SDRAM_SRAM, FMC_SWAPBMAP_SDRAMB2
*/
uint32_t HAL_GetFMCMemorySwappingConfig(void)
{
  return READ_BIT(FMC_Bank1_R->BTCR[0], FMC_BCR1_BMAP);
24000c0c:	4b02      	ldr	r3, [pc, #8]	@ (24000c18 <HAL_GetFMCMemorySwappingConfig+0xc>)
24000c0e:	6818      	ldr	r0, [r3, #0]
}
24000c10:	f000 7040 	and.w	r0, r0, #50331648	@ 0x3000000
24000c14:	4770      	bx	lr
24000c16:	bf00      	nop
24000c18:	52004000 	.word	0x52004000

24000c1c <HAL_EXTI_EdgeConfig>:
  /* Check the parameter */
  assert_param(IS_HAL_EXTI_CONFIG_LINE(EXTI_Line));
  assert_param(IS_EXTI_EDGE_LINE(EXTI_Edge));

  /* Clear Rising Falling edge configuration */
  CLEAR_BIT(*(__IO uint32_t *) (((uint32_t) &(EXTI->FTSR1)) + ((EXTI_Line >> 5 ) * 0x20UL)), (uint32_t)(1UL << (EXTI_Line & 0x1FUL)));
24000c1c:	f020 031f 	bic.w	r3, r0, #31
24000c20:	2201      	movs	r2, #1
24000c22:	f000 001f 	and.w	r0, r0, #31
24000c26:	f103 43b0 	add.w	r3, r3, #1476395008	@ 0x58000000
24000c2a:	4082      	lsls	r2, r0
{
24000c2c:	b510      	push	{r4, lr}
  CLEAR_BIT(*(__IO uint32_t *) (((uint32_t) &(EXTI->FTSR1)) + ((EXTI_Line >> 5 ) * 0x20UL)), (uint32_t)(1UL << (EXTI_Line & 0x1FUL)));
24000c2e:	685c      	ldr	r4, [r3, #4]
24000c30:	ea24 0402 	bic.w	r4, r4, r2
24000c34:	605c      	str	r4, [r3, #4]
  CLEAR_BIT( *(__IO uint32_t *) (((uint32_t) &(EXTI->RTSR1)) + ((EXTI_Line >> 5 ) * 0x20UL)), (uint32_t)(1UL << (EXTI_Line & 0x1FUL)));
24000c36:	6818      	ldr	r0, [r3, #0]
24000c38:	ea20 0002 	bic.w	r0, r0, r2
24000c3c:	6018      	str	r0, [r3, #0]

  if( (EXTI_Edge & EXTI_RISING_EDGE) == EXTI_RISING_EDGE)
24000c3e:	02c8      	lsls	r0, r1, #11
24000c40:	d502      	bpl.n	24000c48 <HAL_EXTI_EdgeConfig+0x2c>
  {
   SET_BIT( *(__IO uint32_t *) (((uint32_t) &(EXTI->RTSR1)) + ((EXTI_Line >> 5 ) * 0x20UL)), (uint32_t)(1UL << (EXTI_Line & 0x1FUL)));
24000c42:	6818      	ldr	r0, [r3, #0]
24000c44:	4310      	orrs	r0, r2
24000c46:	6018      	str	r0, [r3, #0]
  }
  if( (EXTI_Edge & EXTI_FALLING_EDGE) == EXTI_FALLING_EDGE)
24000c48:	0289      	lsls	r1, r1, #10
24000c4a:	d502      	bpl.n	24000c52 <HAL_EXTI_EdgeConfig+0x36>
  {
   SET_BIT(*(__IO uint32_t *) (((uint32_t) &(EXTI->FTSR1)) + ((EXTI_Line >> 5 ) * 0x20UL)), (uint32_t)(1UL << (EXTI_Line & 0x1FUL)));
24000c4c:	6859      	ldr	r1, [r3, #4]
24000c4e:	430a      	orrs	r2, r1
24000c50:	605a      	str	r2, [r3, #4]
  }
}
24000c52:	bd10      	pop	{r4, pc}

24000c54 <HAL_EXTI_GenerateSWInterrupt>:
void HAL_EXTI_GenerateSWInterrupt(uint32_t EXTI_Line)
{
  /* Check the parameters */
  assert_param(IS_HAL_EXTI_CONFIG_LINE(EXTI_Line));

  SET_BIT(*(__IO uint32_t *) (((uint32_t) &(EXTI->SWIER1)) + ((EXTI_Line >> 5 ) * 0x20UL)), (uint32_t)(1UL << (EXTI_Line & 0x1FUL)));
24000c54:	f020 021f 	bic.w	r2, r0, #31
24000c58:	2301      	movs	r3, #1
24000c5a:	f000 001f 	and.w	r0, r0, #31
24000c5e:	f102 42b0 	add.w	r2, r2, #1476395008	@ 0x58000000
24000c62:	4083      	lsls	r3, r0
24000c64:	6891      	ldr	r1, [r2, #8]
24000c66:	430b      	orrs	r3, r1
24000c68:	6093      	str	r3, [r2, #8]
}
24000c6a:	4770      	bx	lr

24000c6c <HAL_EXTI_D1_ClearFlag>:
  */
void HAL_EXTI_D1_ClearFlag(uint32_t EXTI_Line)
{
  /* Check the parameters */
 assert_param(IS_EXTI_D1_LINE(EXTI_Line));
 WRITE_REG(*(__IO uint32_t *) (((uint32_t) &(EXTI_D1->PR1)) + ((EXTI_Line >> 5 ) * 0x10UL)), (uint32_t)(1UL << (EXTI_Line & 0x1FUL)));
24000c6c:	0943      	lsrs	r3, r0, #5
24000c6e:	2201      	movs	r2, #1
24000c70:	f000 001f 	and.w	r0, r0, #31
24000c74:	011b      	lsls	r3, r3, #4
24000c76:	4082      	lsls	r2, r0
24000c78:	f103 43b0 	add.w	r3, r3, #1476395008	@ 0x58000000
24000c7c:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88

}
24000c80:	4770      	bx	lr

24000c82 <HAL_EXTI_D1_EventInputConfig>:
  * @param   EXTI_LineCmd controls (Enable/Disable) the EXTI line.

  * @retval None
  */
void HAL_EXTI_D1_EventInputConfig(uint32_t EXTI_Line , uint32_t EXTI_Mode,  uint32_t EXTI_LineCmd )
{
24000c82:	b530      	push	{r4, r5, lr}
  /* Check the parameter */
  assert_param(IS_EXTI_D1_LINE(EXTI_Line));
  assert_param(IS_EXTI_MODE_LINE(EXTI_Mode));

  if( (EXTI_Mode & EXTI_MODE_IT) == EXTI_MODE_IT)
24000c84:	03cc      	lsls	r4, r1, #15
24000c86:	d50d      	bpl.n	24000ca4 <HAL_EXTI_D1_EventInputConfig+0x22>
  {
     if( EXTI_LineCmd == 0UL)
     {
       /* Clear EXTI line configuration */
        CLEAR_BIT(*(__IO uint32_t *) (((uint32_t) &(EXTI_D1->IMR1)) + ((EXTI_Line >> 5 ) * 0x10UL)),(uint32_t)(1UL << (EXTI_Line & 0x1FUL)) );
24000c88:	0943      	lsrs	r3, r0, #5
24000c8a:	f000 051f 	and.w	r5, r0, #31
24000c8e:	2401      	movs	r4, #1
24000c90:	f103 63b0 	add.w	r3, r3, #92274688	@ 0x5800000
24000c94:	40ac      	lsls	r4, r5
24000c96:	3308      	adds	r3, #8
24000c98:	011b      	lsls	r3, r3, #4
24000c9a:	681d      	ldr	r5, [r3, #0]
     if( EXTI_LineCmd == 0UL)
24000c9c:	b9a2      	cbnz	r2, 24000cc8 <HAL_EXTI_D1_EventInputConfig+0x46>
        CLEAR_BIT(*(__IO uint32_t *) (((uint32_t) &(EXTI_D1->IMR1)) + ((EXTI_Line >> 5 ) * 0x10UL)),(uint32_t)(1UL << (EXTI_Line & 0x1FUL)) );
24000c9e:	ea25 0404 	bic.w	r4, r5, r4
     }
     else
     {
        SET_BIT(*(__IO uint32_t *) (((uint32_t) &(EXTI_D1->IMR1)) + ((EXTI_Line >> 5 ) * 0x10UL)), (uint32_t)(1UL << (EXTI_Line & 0x1FUL)));
24000ca2:	601c      	str	r4, [r3, #0]
     }
  }

  if( (EXTI_Mode & EXTI_MODE_EVT) == EXTI_MODE_EVT)
24000ca4:	038b      	lsls	r3, r1, #14
24000ca6:	d50e      	bpl.n	24000cc6 <HAL_EXTI_D1_EventInputConfig+0x44>
        CLEAR_BIT(*(__IO uint32_t *) (((uint32_t) &(EXTI_D1->IMR1)) + ((EXTI_Line >> 5 ) * 0x10UL)),(uint32_t)(1UL << (EXTI_Line & 0x1FUL)) );
24000ca8:	f000 011f 	and.w	r1, r0, #31
24000cac:	0940      	lsrs	r0, r0, #5
  {
    if( EXTI_LineCmd == 0UL)
    {
      /* Clear EXTI line configuration */
      CLEAR_BIT(  *(__IO uint32_t *) (((uint32_t) &(EXTI_D1->EMR1)) + ((EXTI_Line >> 5 ) * 0x10UL)), (uint32_t)(1UL << (EXTI_Line & 0x1FUL)));
24000cae:	2301      	movs	r3, #1
24000cb0:	0100      	lsls	r0, r0, #4
24000cb2:	408b      	lsls	r3, r1
24000cb4:	f100 40b0 	add.w	r0, r0, #1476395008	@ 0x58000000
    if( EXTI_LineCmd == 0UL)
24000cb8:	b942      	cbnz	r2, 24000ccc <HAL_EXTI_D1_EventInputConfig+0x4a>
      CLEAR_BIT(  *(__IO uint32_t *) (((uint32_t) &(EXTI_D1->EMR1)) + ((EXTI_Line >> 5 ) * 0x10UL)), (uint32_t)(1UL << (EXTI_Line & 0x1FUL)));
24000cba:	f8d0 2084 	ldr.w	r2, [r0, #132]	@ 0x84
24000cbe:	ea22 0303 	bic.w	r3, r2, r3
    }
    else
    {
      SET_BIT(  *(__IO uint32_t *) (((uint32_t) &(EXTI_D1->EMR1)) + ((EXTI_Line >> 5 ) * 0x10UL)), (uint32_t)(1UL << (EXTI_Line & 0x1FUL)));
24000cc2:	f8c0 3084 	str.w	r3, [r0, #132]	@ 0x84
    }
  }
}
24000cc6:	bd30      	pop	{r4, r5, pc}
        SET_BIT(*(__IO uint32_t *) (((uint32_t) &(EXTI_D1->IMR1)) + ((EXTI_Line >> 5 ) * 0x10UL)), (uint32_t)(1UL << (EXTI_Line & 0x1FUL)));
24000cc8:	432c      	orrs	r4, r5
24000cca:	e7ea      	b.n	24000ca2 <HAL_EXTI_D1_EventInputConfig+0x20>
      SET_BIT(  *(__IO uint32_t *) (((uint32_t) &(EXTI_D1->EMR1)) + ((EXTI_Line >> 5 ) * 0x10UL)), (uint32_t)(1UL << (EXTI_Line & 0x1FUL)));
24000ccc:	f8d0 2084 	ldr.w	r2, [r0, #132]	@ 0x84
24000cd0:	4313      	orrs	r3, r2
24000cd2:	e7f6      	b.n	24000cc2 <HAL_EXTI_D1_EventInputConfig+0x40>

24000cd4 <HAL_EXTI_D3_EventInputConfig>:
  *   @arg LPTIM4_OUT_CLEAR : LPTIM4 out selected as D3 domain pendclear source
  *   @arg LPTIM5_OUT_CLEAR : LPTIM5 out selected as D3 domain pendclear source
  * @retval None
  */
void HAL_EXTI_D3_EventInputConfig(uint32_t EXTI_Line, uint32_t EXTI_LineCmd , uint32_t EXTI_ClearSrc  )
{
24000cd4:	b530      	push	{r4, r5, lr}
  assert_param(IS_EXTI_D3_CLEAR(EXTI_ClearSrc));

  if( EXTI_LineCmd == 0UL)
  {
    /* Clear EXTI line configuration */
    CLEAR_BIT(*(__IO uint32_t *) (((uint32_t) &(EXTI->D3PMR1)) + ((EXTI_Line >> 5 ) * 0x20UL)),(uint32_t)(1UL << (EXTI_Line & 0x1FUL)) );
24000cd6:	f020 031f 	bic.w	r3, r0, #31
24000cda:	f000 051f 	and.w	r5, r0, #31
24000cde:	2401      	movs	r4, #1
24000ce0:	f103 43b0 	add.w	r3, r3, #1476395008	@ 0x58000000
24000ce4:	40ac      	lsls	r4, r5
  if( EXTI_LineCmd == 0UL)
24000ce6:	b9a9      	cbnz	r1, 24000d14 <HAL_EXTI_D3_EventInputConfig+0x40>
    CLEAR_BIT(*(__IO uint32_t *) (((uint32_t) &(EXTI->D3PMR1)) + ((EXTI_Line >> 5 ) * 0x20UL)),(uint32_t)(1UL << (EXTI_Line & 0x1FUL)) );
24000ce8:	68d9      	ldr	r1, [r3, #12]
24000cea:	ea21 0104 	bic.w	r1, r1, r4
  }
  else
  {
    SET_BIT(*(__IO uint32_t *) (((uint32_t) &(EXTI->D3PMR1)) +((EXTI_Line >> 5 ) * 0x20UL)), (uint32_t)(1UL << (EXTI_Line & 0x1FUL)));
24000cee:	60d9      	str	r1, [r3, #12]
  }

  if(((EXTI_Line>>4)%2UL) == 0UL)
24000cf0:	06c1      	lsls	r1, r0, #27
  }
  else
  {
    pRegv = (__IO uint32_t *) (((uint32_t) &(EXTI->D3PCR1H)) + ((EXTI_Line >> 5 ) * 0x20UL));
  }
  MODIFY_REG(*pRegv, (uint32_t)(3UL << ((EXTI_Line*2UL) & 0x1FUL)), (uint32_t)(EXTI_ClearSrc << ((EXTI_Line*2UL) & 0x1FUL)));
24000cf2:	ea4f 0040 	mov.w	r0, r0, lsl #1
24000cf6:	f04f 0403 	mov.w	r4, #3
    pRegv = (__IO uint32_t *) (((uint32_t) &(EXTI->D3PCR1L)) + ((EXTI_Line >> 5 ) * 0x20UL));
24000cfa:	bf54      	ite	pl
24000cfc:	3310      	addpl	r3, #16
    pRegv = (__IO uint32_t *) (((uint32_t) &(EXTI->D3PCR1H)) + ((EXTI_Line >> 5 ) * 0x20UL));
24000cfe:	3314      	addmi	r3, #20
  MODIFY_REG(*pRegv, (uint32_t)(3UL << ((EXTI_Line*2UL) & 0x1FUL)), (uint32_t)(EXTI_ClearSrc << ((EXTI_Line*2UL) & 0x1FUL)));
24000d00:	f000 001e 	and.w	r0, r0, #30
24000d04:	6819      	ldr	r1, [r3, #0]
24000d06:	4084      	lsls	r4, r0
24000d08:	4082      	lsls	r2, r0
24000d0a:	ea21 0104 	bic.w	r1, r1, r4
24000d0e:	430a      	orrs	r2, r1
24000d10:	601a      	str	r2, [r3, #0]

}
24000d12:	bd30      	pop	{r4, r5, pc}
    SET_BIT(*(__IO uint32_t *) (((uint32_t) &(EXTI->D3PMR1)) +((EXTI_Line >> 5 ) * 0x20UL)), (uint32_t)(1UL << (EXTI_Line & 0x1FUL)));
24000d14:	68d9      	ldr	r1, [r3, #12]
24000d16:	4321      	orrs	r1, r4
24000d18:	e7e9      	b.n	24000cee <HAL_EXTI_D3_EventInputConfig+0x1a>
24000d1a:	bf00      	nop

24000d1c <HAL_NVIC_SetPriorityGrouping>:
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
24000d1c:	4907      	ldr	r1, [pc, #28]	@ (24000d3c <HAL_NVIC_SetPriorityGrouping+0x20>)
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
24000d1e:	0203      	lsls	r3, r0, #8
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
24000d20:	68ca      	ldr	r2, [r1, #12]
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
24000d22:	f403 63e0 	and.w	r3, r3, #1792	@ 0x700
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
24000d26:	f422 62e0 	bic.w	r2, r2, #1792	@ 0x700
24000d2a:	0412      	lsls	r2, r2, #16
24000d2c:	0c12      	lsrs	r2, r2, #16
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
24000d2e:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
24000d30:	f043 63bf 	orr.w	r3, r3, #100139008	@ 0x5f80000
24000d34:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
  SCB->AIRCR =  reg_value;
24000d38:	60cb      	str	r3, [r1, #12]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));

  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
}
24000d3a:	4770      	bx	lr
24000d3c:	e000ed00 	.word	0xe000ed00

24000d40 <HAL_NVIC_SetPriority>:
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
24000d40:	4b16      	ldr	r3, [pc, #88]	@ (24000d9c <HAL_NVIC_SetPriority+0x5c>)
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
24000d42:	b530      	push	{r4, r5, lr}
24000d44:	68dc      	ldr	r4, [r3, #12]
24000d46:	f3c4 2402 	ubfx	r4, r4, #8, #3
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
24000d4a:	f1c4 0307 	rsb	r3, r4, #7
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
24000d4e:	1d25      	adds	r5, r4, #4
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
24000d50:	2b04      	cmp	r3, #4
24000d52:	bf28      	it	cs
24000d54:	2304      	movcs	r3, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
24000d56:	2d06      	cmp	r5, #6

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
24000d58:	f04f 35ff 	mov.w	r5, #4294967295
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
24000d5c:	bf8c      	ite	hi
24000d5e:	3c03      	subhi	r4, #3
24000d60:	2400      	movls	r4, #0
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
24000d62:	fa05 f303 	lsl.w	r3, r5, r3
  if ((int32_t)(IRQn) >= 0)
24000d66:	2800      	cmp	r0, #0
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
24000d68:	fa05 f504 	lsl.w	r5, r5, r4
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
24000d6c:	ea21 0303 	bic.w	r3, r1, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
24000d70:	ea22 0205 	bic.w	r2, r2, r5
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
24000d74:	fa03 f304 	lsl.w	r3, r3, r4
24000d78:	ea43 0302 	orr.w	r3, r3, r2
    NVIC->IP[((uint32_t)IRQn)]                = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
24000d7c:	ea4f 1303 	mov.w	r3, r3, lsl #4
24000d80:	b2db      	uxtb	r3, r3
  if ((int32_t)(IRQn) >= 0)
24000d82:	db06      	blt.n	24000d92 <HAL_NVIC_SetPriority+0x52>
    NVIC->IP[((uint32_t)IRQn)]                = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
24000d84:	f100 4060 	add.w	r0, r0, #3758096384	@ 0xe0000000
24000d88:	f500 4061 	add.w	r0, r0, #57600	@ 0xe100
24000d8c:	f880 3300 	strb.w	r3, [r0, #768]	@ 0x300
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));

  prioritygroup = NVIC_GetPriorityGrouping();

  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
}
24000d90:	bd30      	pop	{r4, r5, pc}
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
24000d92:	f000 000f 	and.w	r0, r0, #15
24000d96:	4a02      	ldr	r2, [pc, #8]	@ (24000da0 <HAL_NVIC_SetPriority+0x60>)
24000d98:	5413      	strb	r3, [r2, r0]
24000d9a:	e7f9      	b.n	24000d90 <HAL_NVIC_SetPriority+0x50>
24000d9c:	e000ed00 	.word	0xe000ed00
24000da0:	e000ed14 	.word	0xe000ed14

24000da4 <HAL_NVIC_EnableIRQ>:
  if ((int32_t)(IRQn) >= 0)
24000da4:	2800      	cmp	r0, #0
24000da6:	db07      	blt.n	24000db8 <HAL_NVIC_EnableIRQ+0x14>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
24000da8:	0941      	lsrs	r1, r0, #5
24000daa:	2301      	movs	r3, #1
24000dac:	f000 001f 	and.w	r0, r0, #31
24000db0:	4a02      	ldr	r2, [pc, #8]	@ (24000dbc <HAL_NVIC_EnableIRQ+0x18>)
24000db2:	4083      	lsls	r3, r0
24000db4:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
}
24000db8:	4770      	bx	lr
24000dba:	bf00      	nop
24000dbc:	e000e100 	.word	0xe000e100

24000dc0 <HAL_NVIC_DisableIRQ>:
  if ((int32_t)(IRQn) >= 0)
24000dc0:	2800      	cmp	r0, #0
24000dc2:	db0c      	blt.n	24000dde <HAL_NVIC_DisableIRQ+0x1e>
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
24000dc4:	0943      	lsrs	r3, r0, #5
24000dc6:	2201      	movs	r2, #1
24000dc8:	f000 001f 	and.w	r0, r0, #31
24000dcc:	4904      	ldr	r1, [pc, #16]	@ (24000de0 <HAL_NVIC_DisableIRQ+0x20>)
24000dce:	3320      	adds	r3, #32
24000dd0:	4082      	lsls	r2, r0
24000dd2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
24000dd6:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
24000dda:	f3bf 8f6f 	isb	sy
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Disable interrupt */
  NVIC_DisableIRQ(IRQn);
}
24000dde:	4770      	bx	lr
24000de0:	e000e100 	.word	0xe000e100

24000de4 <HAL_NVIC_SystemReset>:
  __ASM volatile ("dsb 0xF":::"memory");
24000de4:	f3bf 8f4f 	dsb	sy
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
24000de8:	4905      	ldr	r1, [pc, #20]	@ (24000e00 <HAL_NVIC_SystemReset+0x1c>)
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
24000dea:	4b06      	ldr	r3, [pc, #24]	@ (24000e04 <HAL_NVIC_SystemReset+0x20>)
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
24000dec:	68ca      	ldr	r2, [r1, #12]
24000dee:	f402 62e0 	and.w	r2, r2, #1792	@ 0x700
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
24000df2:	4313      	orrs	r3, r2
24000df4:	60cb      	str	r3, [r1, #12]
24000df6:	f3bf 8f4f 	dsb	sy
                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
  __DSB();                                                          /* Ensure completion of memory access */

  for(;;)                                                           /* wait until reset */
  {
    __NOP();
24000dfa:	bf00      	nop
  for(;;)                                                           /* wait until reset */
24000dfc:	e7fd      	b.n	24000dfa <HAL_NVIC_SystemReset+0x16>
24000dfe:	bf00      	nop
24000e00:	e000ed00 	.word	0xe000ed00
24000e04:	05fa0004 	.word	0x05fa0004

24000e08 <HAL_SYSTICK_Config>:
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
24000e08:	3801      	subs	r0, #1
24000e0a:	f1b0 7f80 	cmp.w	r0, #16777216	@ 0x1000000
24000e0e:	d20b      	bcs.n	24000e28 <HAL_SYSTICK_Config+0x20>
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
24000e10:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
24000e14:	4a05      	ldr	r2, [pc, #20]	@ (24000e2c <HAL_SYSTICK_Config+0x24>)
24000e16:	21f0      	movs	r1, #240	@ 0xf0
  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
24000e18:	6158      	str	r0, [r3, #20]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
24000e1a:	2000      	movs	r0, #0
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
24000e1c:	f882 1023 	strb.w	r1, [r2, #35]	@ 0x23
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
24000e20:	2207      	movs	r2, #7
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
24000e22:	6198      	str	r0, [r3, #24]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
24000e24:	611a      	str	r2, [r3, #16]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
24000e26:	4770      	bx	lr
    return (1UL);                                                   /* Reload value impossible */
24000e28:	2001      	movs	r0, #1
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
   return SysTick_Config(TicksNumb);
}
24000e2a:	4770      	bx	lr
24000e2c:	e000ed00 	.word	0xe000ed00

24000e30 <HAL_MPU_Disable>:
  \details Ensures the apparent order of the explicit memory operations before
           and after the instruction, without ensuring their completion.
 */
__STATIC_FORCEINLINE void __DMB(void)
{
  __ASM volatile ("dmb 0xF":::"memory");
24000e30:	f3bf 8f5f 	dmb	sy
{
  /* Make sure outstanding transfers are done */
  __DMB();

  /* Disable fault exceptions */
  SCB->SHCSR &= ~SCB_SHCSR_MEMFAULTENA_Msk;
24000e34:	4b04      	ldr	r3, [pc, #16]	@ (24000e48 <HAL_MPU_Disable+0x18>)
24000e36:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
24000e38:	f422 3280 	bic.w	r2, r2, #65536	@ 0x10000
24000e3c:	625a      	str	r2, [r3, #36]	@ 0x24

  /* Disable the MPU and clear the control register*/
  MPU->CTRL = 0;
24000e3e:	2200      	movs	r2, #0
24000e40:	f8c3 2094 	str.w	r2, [r3, #148]	@ 0x94
}
24000e44:	4770      	bx	lr
24000e46:	bf00      	nop
24000e48:	e000ed00 	.word	0xe000ed00

24000e4c <HAL_MPU_Enable>:
  * @retval None
  */
void HAL_MPU_Enable(uint32_t MPU_Control)
{
  /* Enable the MPU */
  MPU->CTRL = MPU_Control | MPU_CTRL_ENABLE_Msk;
24000e4c:	4b06      	ldr	r3, [pc, #24]	@ (24000e68 <HAL_MPU_Enable+0x1c>)
24000e4e:	f040 0001 	orr.w	r0, r0, #1
24000e52:	f8c3 0094 	str.w	r0, [r3, #148]	@ 0x94

  /* Enable fault exceptions */
  SCB->SHCSR |= SCB_SHCSR_MEMFAULTENA_Msk;
24000e56:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
24000e58:	f442 3280 	orr.w	r2, r2, #65536	@ 0x10000
24000e5c:	625a      	str	r2, [r3, #36]	@ 0x24
  __ASM volatile ("dsb 0xF":::"memory");
24000e5e:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
24000e62:	f3bf 8f6f 	isb	sy

  /* Ensure MPU setting take effects */
  __DSB();
  __ISB();
}
24000e66:	4770      	bx	lr
24000e68:	e000ed00 	.word	0xe000ed00

24000e6c <HAL_MPU_ConfigRegion>:
  /* Check the parameters */
  assert_param(IS_MPU_REGION_NUMBER(MPU_Init->Number));
  assert_param(IS_MPU_REGION_ENABLE(MPU_Init->Enable));

  /* Set the Region number */
  MPU->RNR = MPU_Init->Number;
24000e6c:	7843      	ldrb	r3, [r0, #1]
24000e6e:	4a14      	ldr	r2, [pc, #80]	@ (24000ec0 <HAL_MPU_ConfigRegion+0x54>)
{
24000e70:	b510      	push	{r4, lr}
  MPU->RNR = MPU_Init->Number;
24000e72:	f8c2 3098 	str.w	r3, [r2, #152]	@ 0x98

  if ((MPU_Init->Enable) != 0UL)
24000e76:	7801      	ldrb	r1, [r0, #0]
24000e78:	b1e9      	cbz	r1, 24000eb6 <HAL_MPU_ConfigRegion+0x4a>
    assert_param(IS_MPU_ACCESS_CACHEABLE(MPU_Init->IsCacheable));
    assert_param(IS_MPU_ACCESS_BUFFERABLE(MPU_Init->IsBufferable));
    assert_param(IS_MPU_SUB_REGION_DISABLE(MPU_Init->SubRegionDisable));
    assert_param(IS_MPU_REGION_SIZE(MPU_Init->Size));

    MPU->RBAR = MPU_Init->BaseAddress;
24000e7a:	6843      	ldr	r3, [r0, #4]
24000e7c:	f8c2 309c 	str.w	r3, [r2, #156]	@ 0x9c
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
                ((uint32_t)MPU_Init->AccessPermission        << MPU_RASR_AP_Pos)   |
24000e80:	7ac3      	ldrb	r3, [r0, #11]
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
24000e82:	7b04      	ldrb	r4, [r0, #12]
                ((uint32_t)MPU_Init->AccessPermission        << MPU_RASR_AP_Pos)   |
24000e84:	061b      	lsls	r3, r3, #24
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
24000e86:	ea43 7304 	orr.w	r3, r3, r4, lsl #28
                ((uint32_t)MPU_Init->TypeExtField            << MPU_RASR_TEX_Pos)  |
                ((uint32_t)MPU_Init->IsShareable             << MPU_RASR_S_Pos)    |
                ((uint32_t)MPU_Init->IsCacheable             << MPU_RASR_C_Pos)    |
                ((uint32_t)MPU_Init->IsBufferable            << MPU_RASR_B_Pos)    |
                ((uint32_t)MPU_Init->SubRegionDisable        << MPU_RASR_SRD_Pos)  |
                ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
24000e8a:	430b      	orrs	r3, r1
                ((uint32_t)MPU_Init->TypeExtField            << MPU_RASR_TEX_Pos)  |
24000e8c:	7a81      	ldrb	r1, [r0, #10]
                ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
24000e8e:	ea43 43c1 	orr.w	r3, r3, r1, lsl #19
                ((uint32_t)MPU_Init->IsShareable             << MPU_RASR_S_Pos)    |
24000e92:	7b41      	ldrb	r1, [r0, #13]
                ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
24000e94:	ea43 4381 	orr.w	r3, r3, r1, lsl #18
                ((uint32_t)MPU_Init->IsCacheable             << MPU_RASR_C_Pos)    |
24000e98:	7b81      	ldrb	r1, [r0, #14]
                ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
24000e9a:	ea43 4341 	orr.w	r3, r3, r1, lsl #17
                ((uint32_t)MPU_Init->IsBufferable            << MPU_RASR_B_Pos)    |
24000e9e:	7bc1      	ldrb	r1, [r0, #15]
                ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
24000ea0:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
                ((uint32_t)MPU_Init->SubRegionDisable        << MPU_RASR_SRD_Pos)  |
24000ea4:	7a41      	ldrb	r1, [r0, #9]
                ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
24000ea6:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
24000eaa:	7a01      	ldrb	r1, [r0, #8]
24000eac:	ea43 0341 	orr.w	r3, r3, r1, lsl #1
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
24000eb0:	f8c2 30a0 	str.w	r3, [r2, #160]	@ 0xa0
  else
  {
    MPU->RBAR = 0x00;
    MPU->RASR = 0x00;
  }
}
24000eb4:	bd10      	pop	{r4, pc}
    MPU->RBAR = 0x00;
24000eb6:	f8c2 109c 	str.w	r1, [r2, #156]	@ 0x9c
    MPU->RASR = 0x00;
24000eba:	f8c2 10a0 	str.w	r1, [r2, #160]	@ 0xa0
}
24000ebe:	e7f9      	b.n	24000eb4 <HAL_MPU_ConfigRegion+0x48>
24000ec0:	e000ed00 	.word	0xe000ed00

24000ec4 <HAL_NVIC_GetPriorityGrouping>:
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
24000ec4:	4b02      	ldr	r3, [pc, #8]	@ (24000ed0 <HAL_NVIC_GetPriorityGrouping+0xc>)
24000ec6:	68d8      	ldr	r0, [r3, #12]
  */
uint32_t HAL_NVIC_GetPriorityGrouping(void)
{
  /* Get the PRIGROUP[10:8] field value */
  return NVIC_GetPriorityGrouping();
}
24000ec8:	f3c0 2002 	ubfx	r0, r0, #8, #3
24000ecc:	4770      	bx	lr
24000ece:	bf00      	nop
24000ed0:	e000ed00 	.word	0xe000ed00

24000ed4 <HAL_NVIC_GetPriority>:
  if ((int32_t)(IRQn) >= 0)
24000ed4:	2800      	cmp	r0, #0
  * @param  pPreemptPriority Pointer on the Preemptive priority value (starting from 0).
  * @param  pSubPriority Pointer on the Subpriority value (starting from 0).
  * @retval None
  */
void HAL_NVIC_GetPriority(IRQn_Type IRQn, uint32_t PriorityGroup, uint32_t *pPreemptPriority, uint32_t *pSubPriority)
{
24000ed6:	b570      	push	{r4, r5, r6, lr}
24000ed8:	db20      	blt.n	24000f1c <HAL_NVIC_GetPriority+0x48>
    return(((uint32_t)NVIC->IP[((uint32_t)IRQn)]                >> (8U - __NVIC_PRIO_BITS)));
24000eda:	f100 4060 	add.w	r0, r0, #3758096384	@ 0xe0000000
24000ede:	f500 4061 	add.w	r0, r0, #57600	@ 0xe100
24000ee2:	f890 0300 	ldrb.w	r0, [r0, #768]	@ 0x300
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
24000ee6:	f001 0107 	and.w	r1, r1, #7
    return(((uint32_t)SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] >> (8U - __NVIC_PRIO_BITS)));
24000eea:	0900      	lsrs	r0, r0, #4
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
24000eec:	f1c1 0407 	rsb	r4, r1, #7
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
24000ef0:	1d0d      	adds	r5, r1, #4
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
24000ef2:	2c04      	cmp	r4, #4
24000ef4:	bf28      	it	cs
24000ef6:	2404      	movcs	r4, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
24000ef8:	2d06      	cmp	r5, #6
  *pPreemptPriority = (Priority >> SubPriorityBits) & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL);
24000efa:	f04f 35ff 	mov.w	r5, #4294967295
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
24000efe:	bf8c      	ite	hi
24000f00:	3903      	subhi	r1, #3
24000f02:	2100      	movls	r1, #0
  *pPreemptPriority = (Priority >> SubPriorityBits) & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL);
24000f04:	fa05 f404 	lsl.w	r4, r5, r4
24000f08:	fa20 f601 	lsr.w	r6, r0, r1
  *pSubPriority     = (Priority                   ) & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL);
24000f0c:	408d      	lsls	r5, r1
  *pPreemptPriority = (Priority >> SubPriorityBits) & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL);
24000f0e:	ea26 0404 	bic.w	r4, r6, r4
  *pSubPriority     = (Priority                   ) & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL);
24000f12:	ea20 0005 	bic.w	r0, r0, r5
  *pPreemptPriority = (Priority >> SubPriorityBits) & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL);
24000f16:	6014      	str	r4, [r2, #0]
  *pSubPriority     = (Priority                   ) & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL);
24000f18:	6018      	str	r0, [r3, #0]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
 /* Get priority for Cortex-M system or device specific interrupts */
  NVIC_DecodePriority(NVIC_GetPriority(IRQn), PriorityGroup, pPreemptPriority, pSubPriority);
}
24000f1a:	bd70      	pop	{r4, r5, r6, pc}
    return(((uint32_t)SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] >> (8U - __NVIC_PRIO_BITS)));
24000f1c:	f000 000f 	and.w	r0, r0, #15
24000f20:	4c01      	ldr	r4, [pc, #4]	@ (24000f28 <HAL_NVIC_GetPriority+0x54>)
24000f22:	5c20      	ldrb	r0, [r4, r0]
24000f24:	e7df      	b.n	24000ee6 <HAL_NVIC_GetPriority+0x12>
24000f26:	bf00      	nop
24000f28:	e000ed14 	.word	0xe000ed14

24000f2c <HAL_NVIC_SetPendingIRQ>:
  if ((int32_t)(IRQn) >= 0)
24000f2c:	2800      	cmp	r0, #0
24000f2e:	db08      	blt.n	24000f42 <HAL_NVIC_SetPendingIRQ+0x16>
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
24000f30:	0943      	lsrs	r3, r0, #5
24000f32:	2201      	movs	r2, #1
24000f34:	f000 001f 	and.w	r0, r0, #31
24000f38:	4902      	ldr	r1, [pc, #8]	@ (24000f44 <HAL_NVIC_SetPendingIRQ+0x18>)
24000f3a:	3340      	adds	r3, #64	@ 0x40
24000f3c:	4082      	lsls	r2, r0
24000f3e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Set interrupt pending */
  NVIC_SetPendingIRQ(IRQn);
}
24000f42:	4770      	bx	lr
24000f44:	e000e100 	.word	0xe000e100

24000f48 <HAL_NVIC_GetPendingIRQ>:
  if ((int32_t)(IRQn) >= 0)
24000f48:	2800      	cmp	r0, #0
24000f4a:	db0b      	blt.n	24000f64 <HAL_NVIC_GetPendingIRQ+0x1c>
    return((uint32_t)(((NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
24000f4c:	0943      	lsrs	r3, r0, #5
24000f4e:	4a06      	ldr	r2, [pc, #24]	@ (24000f68 <HAL_NVIC_GetPendingIRQ+0x20>)
24000f50:	f000 001f 	and.w	r0, r0, #31
24000f54:	3340      	adds	r3, #64	@ 0x40
24000f56:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
24000f5a:	fa23 f000 	lsr.w	r0, r3, r0
24000f5e:	f000 0001 	and.w	r0, r0, #1
24000f62:	4770      	bx	lr
    return(0U);
24000f64:	2000      	movs	r0, #0
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Return 1 if pending else 0 */
  return NVIC_GetPendingIRQ(IRQn);
}
24000f66:	4770      	bx	lr
24000f68:	e000e100 	.word	0xe000e100

24000f6c <HAL_NVIC_ClearPendingIRQ>:
  if ((int32_t)(IRQn) >= 0)
24000f6c:	2800      	cmp	r0, #0
24000f6e:	db08      	blt.n	24000f82 <HAL_NVIC_ClearPendingIRQ+0x16>
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
24000f70:	0943      	lsrs	r3, r0, #5
24000f72:	2201      	movs	r2, #1
24000f74:	f000 001f 	and.w	r0, r0, #31
24000f78:	4902      	ldr	r1, [pc, #8]	@ (24000f84 <HAL_NVIC_ClearPendingIRQ+0x18>)
24000f7a:	3360      	adds	r3, #96	@ 0x60
24000f7c:	4082      	lsls	r2, r0
24000f7e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Clear pending interrupt */
  NVIC_ClearPendingIRQ(IRQn);
}
24000f82:	4770      	bx	lr
24000f84:	e000e100 	.word	0xe000e100

24000f88 <HAL_NVIC_GetActive>:
  if ((int32_t)(IRQn) >= 0)
24000f88:	2800      	cmp	r0, #0
24000f8a:	db0b      	blt.n	24000fa4 <HAL_NVIC_GetActive+0x1c>
    return((uint32_t)(((NVIC->IABR[(((uint32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
24000f8c:	0943      	lsrs	r3, r0, #5
24000f8e:	4a06      	ldr	r2, [pc, #24]	@ (24000fa8 <HAL_NVIC_GetActive+0x20>)
24000f90:	f000 001f 	and.w	r0, r0, #31
24000f94:	3380      	adds	r3, #128	@ 0x80
24000f96:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
24000f9a:	fa23 f000 	lsr.w	r0, r3, r0
24000f9e:	f000 0001 	and.w	r0, r0, #1
24000fa2:	4770      	bx	lr
    return(0U);
24000fa4:	2000      	movs	r0, #0
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Return 1 if active else 0 */
  return NVIC_GetActive(IRQn);
}
24000fa6:	4770      	bx	lr
24000fa8:	e000e100 	.word	0xe000e100

24000fac <HAL_SYSTICK_CLKSourceConfig>:
  */
void HAL_SYSTICK_CLKSourceConfig(uint32_t CLKSource)
{
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(CLKSource));
  if (CLKSource == SYSTICK_CLKSOURCE_HCLK)
24000fac:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
24000fb0:	2804      	cmp	r0, #4
  {
    SysTick->CTRL |= SYSTICK_CLKSOURCE_HCLK;
24000fb2:	691a      	ldr	r2, [r3, #16]
24000fb4:	bf0c      	ite	eq
24000fb6:	f042 0204 	orreq.w	r2, r2, #4
  }
  else
  {
    SysTick->CTRL &= ~SYSTICK_CLKSOURCE_HCLK;
24000fba:	f022 0204 	bicne.w	r2, r2, #4
24000fbe:	611a      	str	r2, [r3, #16]
  }
}
24000fc0:	4770      	bx	lr

24000fc2 <HAL_SYSTICK_Callback>:
__weak void HAL_SYSTICK_Callback(void)
{
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_SYSTICK_Callback could be implemented in the user file
   */
}
24000fc2:	4770      	bx	lr

24000fc4 <HAL_SYSTICK_IRQHandler>:
{
24000fc4:	b508      	push	{r3, lr}
  HAL_SYSTICK_Callback();
24000fc6:	f7ff fffc 	bl	24000fc2 <HAL_SYSTICK_Callback>
}
24000fca:	bd08      	pop	{r3, pc}

24000fcc <HAL_GetCurrentCPUID>:
* @retval CPU identifier
*/
uint32_t HAL_GetCurrentCPUID(void)
{
  return  CM7_CPUID;
}
24000fcc:	2003      	movs	r0, #3
24000fce:	4770      	bx	lr

24000fd0 <DMA_SetConfig>:
  * @param  DstAddress: The destination memory Buffer address
  * @param  DataLength: The length of data to be transferred from source to destination
  * @retval None
  */
static void DMA_SetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{
24000fd0:	b5f0      	push	{r4, r5, r6, r7, lr}
  /* calculate DMA base and stream number */
  DMA_Base_Registers  *regs_dma  = (DMA_Base_Registers *)hdma->StreamBaseAddress;
  BDMA_Base_Registers *regs_bdma = (BDMA_Base_Registers *)hdma->StreamBaseAddress;

  if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
24000fd2:	f8df c17c 	ldr.w	ip, [pc, #380]	@ 24001150 <DMA_SetConfig+0x180>
24000fd6:	6804      	ldr	r4, [r0, #0]
  DMA_Base_Registers  *regs_dma  = (DMA_Base_Registers *)hdma->StreamBaseAddress;
24000fd8:	6d87      	ldr	r7, [r0, #88]	@ 0x58
  if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
24000fda:	4564      	cmp	r4, ip
24000fdc:	d045      	beq.n	2400106a <DMA_SetConfig+0x9a>
24000fde:	4d59      	ldr	r5, [pc, #356]	@ (24001144 <DMA_SetConfig+0x174>)
24000fe0:	42ac      	cmp	r4, r5
24000fe2:	d042      	beq.n	2400106a <DMA_SetConfig+0x9a>
24000fe4:	3518      	adds	r5, #24
24000fe6:	42ac      	cmp	r4, r5
24000fe8:	d03f      	beq.n	2400106a <DMA_SetConfig+0x9a>
24000fea:	3518      	adds	r5, #24
24000fec:	42ac      	cmp	r4, r5
24000fee:	d03c      	beq.n	2400106a <DMA_SetConfig+0x9a>
24000ff0:	3518      	adds	r5, #24
24000ff2:	42ac      	cmp	r4, r5
24000ff4:	d039      	beq.n	2400106a <DMA_SetConfig+0x9a>
24000ff6:	3518      	adds	r5, #24
24000ff8:	42ac      	cmp	r4, r5
24000ffa:	d036      	beq.n	2400106a <DMA_SetConfig+0x9a>
24000ffc:	3518      	adds	r5, #24
24000ffe:	42ac      	cmp	r4, r5
24001000:	d033      	beq.n	2400106a <DMA_SetConfig+0x9a>
24001002:	3518      	adds	r5, #24
24001004:	42ac      	cmp	r4, r5
24001006:	d030      	beq.n	2400106a <DMA_SetConfig+0x9a>
24001008:	f505 7556 	add.w	r5, r5, #856	@ 0x358
2400100c:	42ac      	cmp	r4, r5
2400100e:	d02c      	beq.n	2400106a <DMA_SetConfig+0x9a>
24001010:	3518      	adds	r5, #24
24001012:	42ac      	cmp	r4, r5
24001014:	d029      	beq.n	2400106a <DMA_SetConfig+0x9a>
24001016:	3518      	adds	r5, #24
24001018:	42ac      	cmp	r4, r5
2400101a:	d026      	beq.n	2400106a <DMA_SetConfig+0x9a>
2400101c:	3518      	adds	r5, #24
2400101e:	42ac      	cmp	r4, r5
24001020:	d023      	beq.n	2400106a <DMA_SetConfig+0x9a>
24001022:	3518      	adds	r5, #24
24001024:	42ac      	cmp	r4, r5
24001026:	d020      	beq.n	2400106a <DMA_SetConfig+0x9a>
24001028:	3518      	adds	r5, #24
2400102a:	42ac      	cmp	r4, r5
2400102c:	d01d      	beq.n	2400106a <DMA_SetConfig+0x9a>
2400102e:	3518      	adds	r5, #24
24001030:	42ac      	cmp	r4, r5
24001032:	d01a      	beq.n	2400106a <DMA_SetConfig+0x9a>
24001034:	3518      	adds	r5, #24
24001036:	42ac      	cmp	r4, r5
24001038:	d017      	beq.n	2400106a <DMA_SetConfig+0x9a>
2400103a:	4d43      	ldr	r5, [pc, #268]	@ (24001148 <DMA_SetConfig+0x178>)
2400103c:	42ac      	cmp	r4, r5
2400103e:	d014      	beq.n	2400106a <DMA_SetConfig+0x9a>
24001040:	3514      	adds	r5, #20
24001042:	42ac      	cmp	r4, r5
24001044:	d011      	beq.n	2400106a <DMA_SetConfig+0x9a>
24001046:	3514      	adds	r5, #20
24001048:	42ac      	cmp	r4, r5
2400104a:	d00e      	beq.n	2400106a <DMA_SetConfig+0x9a>
2400104c:	3514      	adds	r5, #20
2400104e:	42ac      	cmp	r4, r5
24001050:	d00b      	beq.n	2400106a <DMA_SetConfig+0x9a>
24001052:	3514      	adds	r5, #20
24001054:	42ac      	cmp	r4, r5
24001056:	d008      	beq.n	2400106a <DMA_SetConfig+0x9a>
24001058:	3514      	adds	r5, #20
2400105a:	42ac      	cmp	r4, r5
2400105c:	d005      	beq.n	2400106a <DMA_SetConfig+0x9a>
2400105e:	3514      	adds	r5, #20
24001060:	42ac      	cmp	r4, r5
24001062:	d002      	beq.n	2400106a <DMA_SetConfig+0x9a>
24001064:	3514      	adds	r5, #20
24001066:	42ac      	cmp	r4, r5
24001068:	d167      	bne.n	2400113a <DMA_SetConfig+0x16a>
  {
    /* Clear the DMAMUX synchro overrun flag */
    hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
2400106a:	e9d0 5619 	ldrd	r5, r6, [r0, #100]	@ 0x64
2400106e:	606e      	str	r6, [r5, #4]

    if(hdma->DMAmuxRequestGen != 0U)
24001070:	6ec5      	ldr	r5, [r0, #108]	@ 0x6c
24001072:	b115      	cbz	r5, 2400107a <DMA_SetConfig+0xaa>
    {
      /* Clear the DMAMUX request generator overrun flag */
      hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
24001074:	e9d0 561c 	ldrd	r5, r6, [r0, #112]	@ 0x70
24001078:	606e      	str	r6, [r5, #4]
    }
  }

  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
2400107a:	4564      	cmp	r4, ip
2400107c:	d037      	beq.n	240010ee <DMA_SetConfig+0x11e>
2400107e:	4d31      	ldr	r5, [pc, #196]	@ (24001144 <DMA_SetConfig+0x174>)
24001080:	42ac      	cmp	r4, r5
24001082:	d034      	beq.n	240010ee <DMA_SetConfig+0x11e>
24001084:	3518      	adds	r5, #24
24001086:	42ac      	cmp	r4, r5
24001088:	d031      	beq.n	240010ee <DMA_SetConfig+0x11e>
2400108a:	3518      	adds	r5, #24
2400108c:	42ac      	cmp	r4, r5
2400108e:	d02e      	beq.n	240010ee <DMA_SetConfig+0x11e>
24001090:	3518      	adds	r5, #24
24001092:	42ac      	cmp	r4, r5
24001094:	d02b      	beq.n	240010ee <DMA_SetConfig+0x11e>
24001096:	3518      	adds	r5, #24
24001098:	42ac      	cmp	r4, r5
2400109a:	d028      	beq.n	240010ee <DMA_SetConfig+0x11e>
2400109c:	3518      	adds	r5, #24
2400109e:	42ac      	cmp	r4, r5
240010a0:	d025      	beq.n	240010ee <DMA_SetConfig+0x11e>
240010a2:	3518      	adds	r5, #24
240010a4:	42ac      	cmp	r4, r5
240010a6:	d022      	beq.n	240010ee <DMA_SetConfig+0x11e>
240010a8:	f505 7556 	add.w	r5, r5, #856	@ 0x358
240010ac:	42ac      	cmp	r4, r5
240010ae:	d01e      	beq.n	240010ee <DMA_SetConfig+0x11e>
240010b0:	3518      	adds	r5, #24
240010b2:	42ac      	cmp	r4, r5
240010b4:	d01b      	beq.n	240010ee <DMA_SetConfig+0x11e>
240010b6:	3518      	adds	r5, #24
240010b8:	42ac      	cmp	r4, r5
240010ba:	d018      	beq.n	240010ee <DMA_SetConfig+0x11e>
240010bc:	3518      	adds	r5, #24
240010be:	42ac      	cmp	r4, r5
240010c0:	d015      	beq.n	240010ee <DMA_SetConfig+0x11e>
240010c2:	3518      	adds	r5, #24
240010c4:	42ac      	cmp	r4, r5
240010c6:	d012      	beq.n	240010ee <DMA_SetConfig+0x11e>
240010c8:	3518      	adds	r5, #24
240010ca:	42ac      	cmp	r4, r5
240010cc:	d00f      	beq.n	240010ee <DMA_SetConfig+0x11e>
240010ce:	3518      	adds	r5, #24
240010d0:	42ac      	cmp	r4, r5
240010d2:	d00c      	beq.n	240010ee <DMA_SetConfig+0x11e>
240010d4:	3518      	adds	r5, #24
240010d6:	42ac      	cmp	r4, r5
240010d8:	d009      	beq.n	240010ee <DMA_SetConfig+0x11e>

      /* Configure DMA Stream destination address */
      ((DMA_Stream_TypeDef *)hdma->Instance)->M0AR = DstAddress;
    }
  }
  else if(IS_BDMA_CHANNEL_INSTANCE(hdma->Instance) != 0U) /* BDMA instance(s) */
240010da:	4d1b      	ldr	r5, [pc, #108]	@ (24001148 <DMA_SetConfig+0x178>)
240010dc:	42ac      	cmp	r4, r5
240010de:	d117      	bne.n	24001110 <DMA_SetConfig+0x140>
  {
    /* Clear all flags */
    regs_bdma->IFCR = (BDMA_ISR_GIF0) << (hdma->StreamIndex & 0x1FU);
240010e0:	6dc5      	ldr	r5, [r0, #92]	@ 0x5c
240010e2:	f005 061f 	and.w	r6, r5, #31
240010e6:	2501      	movs	r5, #1
240010e8:	40b5      	lsls	r5, r6
240010ea:	607d      	str	r5, [r7, #4]
240010ec:	e009      	b.n	24001102 <DMA_SetConfig+0x132>
    regs_dma->IFCR = 0x3FUL << (hdma->StreamIndex & 0x1FU);
240010ee:	6dc5      	ldr	r5, [r0, #92]	@ 0x5c
240010f0:	f005 061f 	and.w	r6, r5, #31
240010f4:	253f      	movs	r5, #63	@ 0x3f
240010f6:	40b5      	lsls	r5, r6
240010f8:	60bd      	str	r5, [r7, #8]
    ((DMA_Stream_TypeDef *)hdma->Instance)->CR &= (uint32_t)(~DMA_SxCR_DBM);
240010fa:	6825      	ldr	r5, [r4, #0]
240010fc:	f425 2580 	bic.w	r5, r5, #262144	@ 0x40000
24001100:	6025      	str	r5, [r4, #0]

    /* Configure DMA Channel data length */
    ((BDMA_Channel_TypeDef *)hdma->Instance)->CNDTR = DataLength;
24001102:	6063      	str	r3, [r4, #4]

    /* Peripheral to Memory */
    if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
24001104:	6883      	ldr	r3, [r0, #8]
24001106:	2b40      	cmp	r3, #64	@ 0x40
24001108:	d118      	bne.n	2400113c <DMA_SetConfig+0x16c>
    {
      /* Configure DMA Channel destination address */
      ((BDMA_Channel_TypeDef *)hdma->Instance)->CPAR = DstAddress;
2400110a:	60a2      	str	r2, [r4, #8]

      /* Configure DMA Channel source address */
      ((BDMA_Channel_TypeDef *)hdma->Instance)->CM0AR = SrcAddress;
2400110c:	60e1      	str	r1, [r4, #12]
2400110e:	e014      	b.n	2400113a <DMA_SetConfig+0x16a>
  else if(IS_BDMA_CHANNEL_INSTANCE(hdma->Instance) != 0U) /* BDMA instance(s) */
24001110:	4d0e      	ldr	r5, [pc, #56]	@ (2400114c <DMA_SetConfig+0x17c>)
24001112:	42ac      	cmp	r4, r5
24001114:	d0e4      	beq.n	240010e0 <DMA_SetConfig+0x110>
24001116:	3514      	adds	r5, #20
24001118:	42ac      	cmp	r4, r5
2400111a:	d0e1      	beq.n	240010e0 <DMA_SetConfig+0x110>
2400111c:	3514      	adds	r5, #20
2400111e:	42ac      	cmp	r4, r5
24001120:	d0de      	beq.n	240010e0 <DMA_SetConfig+0x110>
24001122:	3514      	adds	r5, #20
24001124:	42ac      	cmp	r4, r5
24001126:	d0db      	beq.n	240010e0 <DMA_SetConfig+0x110>
24001128:	3514      	adds	r5, #20
2400112a:	42ac      	cmp	r4, r5
2400112c:	d0d8      	beq.n	240010e0 <DMA_SetConfig+0x110>
2400112e:	3514      	adds	r5, #20
24001130:	42ac      	cmp	r4, r5
24001132:	d0d5      	beq.n	240010e0 <DMA_SetConfig+0x110>
24001134:	3514      	adds	r5, #20
24001136:	42ac      	cmp	r4, r5
24001138:	d0d2      	beq.n	240010e0 <DMA_SetConfig+0x110>
  }
  else
  {
    /* Nothing To Do */
  }
}
2400113a:	bdf0      	pop	{r4, r5, r6, r7, pc}
      ((BDMA_Channel_TypeDef *)hdma->Instance)->CPAR = SrcAddress;
2400113c:	60a1      	str	r1, [r4, #8]
      ((BDMA_Channel_TypeDef *)hdma->Instance)->CM0AR = DstAddress;
2400113e:	60e2      	str	r2, [r4, #12]
}
24001140:	e7fb      	b.n	2400113a <DMA_SetConfig+0x16a>
24001142:	bf00      	nop
24001144:	40020028 	.word	0x40020028
24001148:	58025408 	.word	0x58025408
2400114c:	5802541c 	.word	0x5802541c
24001150:	40020010 	.word	0x40020010

24001154 <DMA_CalcBaseAndBitshift>:
  *                     the configuration information for the specified DMA Stream.
  * @retval Stream base address
  */
static uint32_t DMA_CalcBaseAndBitshift(DMA_HandleTypeDef *hdma)
{
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
24001154:	6803      	ldr	r3, [r0, #0]
{
24001156:	4602      	mov	r2, r0
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
24001158:	4923      	ldr	r1, [pc, #140]	@ (240011e8 <DMA_CalcBaseAndBitshift+0x94>)
2400115a:	428b      	cmp	r3, r1
{
2400115c:	b510      	push	{r4, lr}
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
2400115e:	d031      	beq.n	240011c4 <DMA_CalcBaseAndBitshift+0x70>
24001160:	3118      	adds	r1, #24
24001162:	428b      	cmp	r3, r1
24001164:	d02e      	beq.n	240011c4 <DMA_CalcBaseAndBitshift+0x70>
24001166:	3118      	adds	r1, #24
24001168:	428b      	cmp	r3, r1
2400116a:	d02b      	beq.n	240011c4 <DMA_CalcBaseAndBitshift+0x70>
2400116c:	3118      	adds	r1, #24
2400116e:	428b      	cmp	r3, r1
24001170:	d028      	beq.n	240011c4 <DMA_CalcBaseAndBitshift+0x70>
24001172:	3118      	adds	r1, #24
24001174:	428b      	cmp	r3, r1
24001176:	d025      	beq.n	240011c4 <DMA_CalcBaseAndBitshift+0x70>
24001178:	3118      	adds	r1, #24
2400117a:	428b      	cmp	r3, r1
2400117c:	d022      	beq.n	240011c4 <DMA_CalcBaseAndBitshift+0x70>
2400117e:	3118      	adds	r1, #24
24001180:	428b      	cmp	r3, r1
24001182:	d01f      	beq.n	240011c4 <DMA_CalcBaseAndBitshift+0x70>
24001184:	3118      	adds	r1, #24
24001186:	428b      	cmp	r3, r1
24001188:	d01c      	beq.n	240011c4 <DMA_CalcBaseAndBitshift+0x70>
2400118a:	f501 7156 	add.w	r1, r1, #856	@ 0x358
2400118e:	428b      	cmp	r3, r1
24001190:	d018      	beq.n	240011c4 <DMA_CalcBaseAndBitshift+0x70>
24001192:	3118      	adds	r1, #24
24001194:	428b      	cmp	r3, r1
24001196:	d015      	beq.n	240011c4 <DMA_CalcBaseAndBitshift+0x70>
24001198:	3118      	adds	r1, #24
2400119a:	428b      	cmp	r3, r1
2400119c:	d012      	beq.n	240011c4 <DMA_CalcBaseAndBitshift+0x70>
2400119e:	3118      	adds	r1, #24
240011a0:	428b      	cmp	r3, r1
240011a2:	d00f      	beq.n	240011c4 <DMA_CalcBaseAndBitshift+0x70>
240011a4:	3118      	adds	r1, #24
240011a6:	428b      	cmp	r3, r1
240011a8:	d00c      	beq.n	240011c4 <DMA_CalcBaseAndBitshift+0x70>
240011aa:	3118      	adds	r1, #24
240011ac:	428b      	cmp	r3, r1
240011ae:	d009      	beq.n	240011c4 <DMA_CalcBaseAndBitshift+0x70>
240011b0:	3118      	adds	r1, #24
240011b2:	428b      	cmp	r3, r1
240011b4:	d006      	beq.n	240011c4 <DMA_CalcBaseAndBitshift+0x70>
240011b6:	3118      	adds	r1, #24
240011b8:	428b      	cmp	r3, r1
240011ba:	d003      	beq.n	240011c4 <DMA_CalcBaseAndBitshift+0x70>
    }
  }
  else /* BDMA instance(s) */
  {
    /* return pointer to ISR and IFCR */
    hdma->StreamBaseAddress = ((uint32_t)((uint32_t*)hdma->Instance) & (uint32_t)(~0xFFU));
240011bc:	f023 00ff 	bic.w	r0, r3, #255	@ 0xff
      hdma->StreamBaseAddress = ((uint32_t)((uint32_t*)hdma->Instance) & (uint32_t)(~0x3FFU));
240011c0:	6590      	str	r0, [r2, #88]	@ 0x58
  }

  return hdma->StreamBaseAddress;
}
240011c2:	bd10      	pop	{r4, pc}
    uint32_t stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 16U) / 24U;
240011c4:	b2dc      	uxtb	r4, r3
240011c6:	2118      	movs	r1, #24
    hdma->StreamIndex = flagBitshiftOffset[stream_number & 0x7U];
240011c8:	4808      	ldr	r0, [pc, #32]	@ (240011ec <DMA_CalcBaseAndBitshift+0x98>)
    uint32_t stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 16U) / 24U;
240011ca:	3c10      	subs	r4, #16
240011cc:	fbb4 f1f1 	udiv	r1, r4, r1
    hdma->StreamIndex = flagBitshiftOffset[stream_number & 0x7U];
240011d0:	f001 0107 	and.w	r1, r1, #7
    if (stream_number > 3U)
240011d4:	2c5f      	cmp	r4, #95	@ 0x5f
    hdma->StreamIndex = flagBitshiftOffset[stream_number & 0x7U];
240011d6:	5c41      	ldrb	r1, [r0, r1]
      hdma->StreamBaseAddress = (((uint32_t)((uint32_t*)hdma->Instance) & (uint32_t)(~0x3FFU)) + 4U);
240011d8:	f423 707f 	bic.w	r0, r3, #1020	@ 0x3fc
240011dc:	f020 0003 	bic.w	r0, r0, #3
    hdma->StreamIndex = flagBitshiftOffset[stream_number & 0x7U];
240011e0:	65d1      	str	r1, [r2, #92]	@ 0x5c
      hdma->StreamBaseAddress = (((uint32_t)((uint32_t*)hdma->Instance) & (uint32_t)(~0x3FFU)) + 4U);
240011e2:	bf88      	it	hi
240011e4:	3004      	addhi	r0, #4
240011e6:	e7eb      	b.n	240011c0 <DMA_CalcBaseAndBitshift+0x6c>
240011e8:	40020010 	.word	0x40020010
240011ec:	24014170 	.word	0x24014170

240011f0 <DMA_CalcDMAMUXChannelBaseAndMask>:
  * @retval HAL status
  */
static void DMA_CalcDMAMUXChannelBaseAndMask(DMA_HandleTypeDef *hdma)
{
  uint32_t stream_number;
  uint32_t stream_baseaddress = (uint32_t)((uint32_t*)hdma->Instance);
240011f0:	6802      	ldr	r2, [r0, #0]

  if(IS_BDMA_CHANNEL_DMAMUX_INSTANCE(hdma->Instance) != 0U)
240011f2:	4921      	ldr	r1, [pc, #132]	@ (24001278 <DMA_CalcDMAMUXChannelBaseAndMask+0x88>)
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
  }
  else
  {
    /* DMA1/DMA2 Streams are connected to DMAMUX1 channels */
    stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 16U) / 24U;
240011f4:	b2d3      	uxtb	r3, r2
  if(IS_BDMA_CHANNEL_DMAMUX_INSTANCE(hdma->Instance) != 0U)
240011f6:	428a      	cmp	r2, r1
240011f8:	d028      	beq.n	2400124c <DMA_CalcDMAMUXChannelBaseAndMask+0x5c>
240011fa:	3114      	adds	r1, #20
240011fc:	428a      	cmp	r2, r1
240011fe:	d025      	beq.n	2400124c <DMA_CalcDMAMUXChannelBaseAndMask+0x5c>
24001200:	3114      	adds	r1, #20
24001202:	428a      	cmp	r2, r1
24001204:	d022      	beq.n	2400124c <DMA_CalcDMAMUXChannelBaseAndMask+0x5c>
24001206:	3114      	adds	r1, #20
24001208:	428a      	cmp	r2, r1
2400120a:	d01f      	beq.n	2400124c <DMA_CalcDMAMUXChannelBaseAndMask+0x5c>
2400120c:	3114      	adds	r1, #20
2400120e:	428a      	cmp	r2, r1
24001210:	d01c      	beq.n	2400124c <DMA_CalcDMAMUXChannelBaseAndMask+0x5c>
24001212:	3114      	adds	r1, #20
24001214:	428a      	cmp	r2, r1
24001216:	d019      	beq.n	2400124c <DMA_CalcDMAMUXChannelBaseAndMask+0x5c>
24001218:	3114      	adds	r1, #20
2400121a:	428a      	cmp	r2, r1
2400121c:	d016      	beq.n	2400124c <DMA_CalcDMAMUXChannelBaseAndMask+0x5c>
2400121e:	3114      	adds	r1, #20
24001220:	428a      	cmp	r2, r1
24001222:	d013      	beq.n	2400124c <DMA_CalcDMAMUXChannelBaseAndMask+0x5c>
    stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 16U) / 24U;
24001224:	2118      	movs	r1, #24
24001226:	3b10      	subs	r3, #16
24001228:	fbb3 f3f1 	udiv	r3, r3, r1

    if((stream_baseaddress <= ((uint32_t)DMA2_Stream7) ) && \
2400122c:	4913      	ldr	r1, [pc, #76]	@ (2400127c <DMA_CalcDMAMUXChannelBaseAndMask+0x8c>)
2400122e:	4411      	add	r1, r2
24001230:	29a8      	cmp	r1, #168	@ 0xa8
24001232:	d91e      	bls.n	24001272 <DMA_CalcDMAMUXChannelBaseAndMask+0x82>
       (stream_baseaddress >= ((uint32_t)DMA2_Stream0)))
    {
      stream_number += 8U;
    }
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_Channel0) + (stream_number * 4U)));
24001234:	f103 5280 	add.w	r2, r3, #268435456	@ 0x10000000
    hdma->DMAmuxChannelStatus = DMAMUX1_ChannelStatus;
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
24001238:	2101      	movs	r1, #1
2400123a:	f003 031f 	and.w	r3, r3, #31
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_Channel0) + (stream_number * 4U)));
2400123e:	f502 4202 	add.w	r2, r2, #33280	@ 0x8200
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
24001242:	fa01 f303 	lsl.w	r3, r1, r3
24001246:	490e      	ldr	r1, [pc, #56]	@ (24001280 <DMA_CalcDMAMUXChannelBaseAndMask+0x90>)
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_Channel0) + (stream_number * 4U)));
24001248:	0092      	lsls	r2, r2, #2
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
2400124a:	e00e      	b.n	2400126a <DMA_CalcDMAMUXChannelBaseAndMask+0x7a>
    stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 8U) / 20U;
2400124c:	2214      	movs	r2, #20
2400124e:	3b08      	subs	r3, #8
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
24001250:	2101      	movs	r1, #1
    stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 8U) / 20U;
24001252:	fbb3 f3f2 	udiv	r3, r3, r2
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX2_Channel0) + (stream_number * 4U)));
24001256:	f103 52b0 	add.w	r2, r3, #369098752	@ 0x16000000
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
2400125a:	f003 031f 	and.w	r3, r3, #31
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX2_Channel0) + (stream_number * 4U)));
2400125e:	f502 4216 	add.w	r2, r2, #38400	@ 0x9600
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
24001262:	fa01 f303 	lsl.w	r3, r1, r3
24001266:	4907      	ldr	r1, [pc, #28]	@ (24001284 <DMA_CalcDMAMUXChannelBaseAndMask+0x94>)
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX2_Channel0) + (stream_number * 4U)));
24001268:	0092      	lsls	r2, r2, #2
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
2400126a:	6683      	str	r3, [r0, #104]	@ 0x68
    hdma->DMAmuxChannelStatus = DMAMUX2_ChannelStatus;
2400126c:	e9c0 2118 	strd	r2, r1, [r0, #96]	@ 0x60
  }
}
24001270:	4770      	bx	lr
      stream_number += 8U;
24001272:	3308      	adds	r3, #8
24001274:	e7de      	b.n	24001234 <DMA_CalcDMAMUXChannelBaseAndMask+0x44>
24001276:	bf00      	nop
24001278:	58025408 	.word	0x58025408
2400127c:	bffdfbf0 	.word	0xbffdfbf0
24001280:	40020880 	.word	0x40020880
24001284:	58025880 	.word	0x58025880

24001288 <DMA_CalcDMAMUXRequestGenBaseAndMask>:
  *                     the configuration information for the specified DMA Stream.
  * @retval HAL status
  */
static void DMA_CalcDMAMUXRequestGenBaseAndMask(DMA_HandleTypeDef *hdma)
{
  uint32_t request =  hdma->Init.Request & DMAMUX_CxCR_DMAREQ_ID;
24001288:	7902      	ldrb	r2, [r0, #4]

  if((request >= DMA_REQUEST_GENERATOR0) && (request <= DMA_REQUEST_GENERATOR7))
2400128a:	1e51      	subs	r1, r2, #1
2400128c:	2907      	cmp	r1, #7
{
2400128e:	b510      	push	{r4, lr}
  if((request >= DMA_REQUEST_GENERATOR0) && (request <= DMA_REQUEST_GENERATOR7))
24001290:	d821      	bhi.n	240012d6 <DMA_CalcDMAMUXRequestGenBaseAndMask+0x4e>
  {
    if(IS_BDMA_CHANNEL_DMAMUX_INSTANCE(hdma->Instance) != 0U)
24001292:	6803      	ldr	r3, [r0, #0]
24001294:	4c13      	ldr	r4, [pc, #76]	@ (240012e4 <DMA_CalcDMAMUXRequestGenBaseAndMask+0x5c>)
24001296:	42a3      	cmp	r3, r4
24001298:	d01e      	beq.n	240012d8 <DMA_CalcDMAMUXRequestGenBaseAndMask+0x50>
2400129a:	3414      	adds	r4, #20
2400129c:	42a3      	cmp	r3, r4
2400129e:	d01b      	beq.n	240012d8 <DMA_CalcDMAMUXRequestGenBaseAndMask+0x50>
240012a0:	3414      	adds	r4, #20
240012a2:	42a3      	cmp	r3, r4
240012a4:	d018      	beq.n	240012d8 <DMA_CalcDMAMUXRequestGenBaseAndMask+0x50>
240012a6:	3414      	adds	r4, #20
240012a8:	42a3      	cmp	r3, r4
240012aa:	d015      	beq.n	240012d8 <DMA_CalcDMAMUXRequestGenBaseAndMask+0x50>
240012ac:	3414      	adds	r4, #20
240012ae:	42a3      	cmp	r3, r4
240012b0:	d012      	beq.n	240012d8 <DMA_CalcDMAMUXRequestGenBaseAndMask+0x50>
240012b2:	3414      	adds	r4, #20
240012b4:	42a3      	cmp	r3, r4
240012b6:	d00f      	beq.n	240012d8 <DMA_CalcDMAMUXRequestGenBaseAndMask+0x50>
240012b8:	3414      	adds	r4, #20
240012ba:	42a3      	cmp	r3, r4
240012bc:	d00c      	beq.n	240012d8 <DMA_CalcDMAMUXRequestGenBaseAndMask+0x50>
240012be:	3414      	adds	r4, #20
240012c0:	42a3      	cmp	r3, r4
240012c2:	d009      	beq.n	240012d8 <DMA_CalcDMAMUXRequestGenBaseAndMask+0x50>
      hdma->DMAmuxRequestGenStatus = DMAMUX2_RequestGenStatus;
    }
    else
    {
      /* DMA1 and DMA2 Streams use DMAMUX1 request generator blocks */
      hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_RequestGenerator0) + ((request - 1U) * 4U)));
240012c4:	4b08      	ldr	r3, [pc, #32]	@ (240012e8 <DMA_CalcDMAMUXRequestGenBaseAndMask+0x60>)
240012c6:	4413      	add	r3, r2
240012c8:	4a08      	ldr	r2, [pc, #32]	@ (240012ec <DMA_CalcDMAMUXRequestGenBaseAndMask+0x64>)
240012ca:	009b      	lsls	r3, r3, #2
      hdma->DMAmuxRequestGenStatus = DMAMUX2_RequestGenStatus;
240012cc:	e9c0 321b 	strd	r3, r2, [r0, #108]	@ 0x6c

      hdma->DMAmuxRequestGenStatus = DMAMUX1_RequestGenStatus;
    }

    hdma->DMAmuxRequestGenStatusMask = 1UL << (request - 1U);
240012d0:	2301      	movs	r3, #1
240012d2:	408b      	lsls	r3, r1
240012d4:	6743      	str	r3, [r0, #116]	@ 0x74
  }
}
240012d6:	bd10      	pop	{r4, pc}
      hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX2_RequestGenerator0) + ((request - 1U) * 4U)));
240012d8:	4b05      	ldr	r3, [pc, #20]	@ (240012f0 <DMA_CalcDMAMUXRequestGenBaseAndMask+0x68>)
240012da:	4413      	add	r3, r2
240012dc:	4a05      	ldr	r2, [pc, #20]	@ (240012f4 <DMA_CalcDMAMUXRequestGenBaseAndMask+0x6c>)
240012de:	009b      	lsls	r3, r3, #2
      hdma->DMAmuxRequestGenStatus = DMAMUX2_RequestGenStatus;
240012e0:	e7f4      	b.n	240012cc <DMA_CalcDMAMUXRequestGenBaseAndMask+0x44>
240012e2:	bf00      	nop
240012e4:	58025408 	.word	0x58025408
240012e8:	1000823f 	.word	0x1000823f
240012ec:	40020940 	.word	0x40020940
240012f0:	1600963f 	.word	0x1600963f
240012f4:	58025940 	.word	0x58025940

240012f8 <HAL_DMA_Init>:
{
240012f8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
240012fa:	4604      	mov	r4, r0
  uint32_t tickstart = HAL_GetTick();
240012fc:	f010 fd84 	bl	24011e08 <HAL_GetTick>
24001300:	4606      	mov	r6, r0
  if(hdma == NULL)
24001302:	2c00      	cmp	r4, #0
24001304:	f000 80ee 	beq.w	240014e4 <HAL_DMA_Init+0x1ec>
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
24001308:	6823      	ldr	r3, [r4, #0]
2400130a:	4d83      	ldr	r5, [pc, #524]	@ (24001518 <HAL_DMA_Init+0x220>)
2400130c:	42ab      	cmp	r3, r5
2400130e:	d06a      	beq.n	240013e6 <HAL_DMA_Init+0xee>
24001310:	4a82      	ldr	r2, [pc, #520]	@ (2400151c <HAL_DMA_Init+0x224>)
24001312:	4293      	cmp	r3, r2
24001314:	d067      	beq.n	240013e6 <HAL_DMA_Init+0xee>
24001316:	3218      	adds	r2, #24
24001318:	4293      	cmp	r3, r2
2400131a:	d064      	beq.n	240013e6 <HAL_DMA_Init+0xee>
2400131c:	3218      	adds	r2, #24
2400131e:	4293      	cmp	r3, r2
24001320:	d061      	beq.n	240013e6 <HAL_DMA_Init+0xee>
24001322:	3218      	adds	r2, #24
24001324:	4293      	cmp	r3, r2
24001326:	d05e      	beq.n	240013e6 <HAL_DMA_Init+0xee>
24001328:	3218      	adds	r2, #24
2400132a:	4293      	cmp	r3, r2
2400132c:	d05b      	beq.n	240013e6 <HAL_DMA_Init+0xee>
2400132e:	3218      	adds	r2, #24
24001330:	4293      	cmp	r3, r2
24001332:	d058      	beq.n	240013e6 <HAL_DMA_Init+0xee>
24001334:	3218      	adds	r2, #24
24001336:	4293      	cmp	r3, r2
24001338:	d055      	beq.n	240013e6 <HAL_DMA_Init+0xee>
2400133a:	f502 7256 	add.w	r2, r2, #856	@ 0x358
2400133e:	4293      	cmp	r3, r2
24001340:	d051      	beq.n	240013e6 <HAL_DMA_Init+0xee>
24001342:	3218      	adds	r2, #24
24001344:	4293      	cmp	r3, r2
24001346:	d04e      	beq.n	240013e6 <HAL_DMA_Init+0xee>
24001348:	3218      	adds	r2, #24
2400134a:	4293      	cmp	r3, r2
2400134c:	d04b      	beq.n	240013e6 <HAL_DMA_Init+0xee>
2400134e:	3218      	adds	r2, #24
24001350:	4293      	cmp	r3, r2
24001352:	d048      	beq.n	240013e6 <HAL_DMA_Init+0xee>
24001354:	3218      	adds	r2, #24
24001356:	4293      	cmp	r3, r2
24001358:	d045      	beq.n	240013e6 <HAL_DMA_Init+0xee>
2400135a:	3218      	adds	r2, #24
2400135c:	4293      	cmp	r3, r2
2400135e:	d042      	beq.n	240013e6 <HAL_DMA_Init+0xee>
24001360:	3218      	adds	r2, #24
24001362:	4293      	cmp	r3, r2
24001364:	d03f      	beq.n	240013e6 <HAL_DMA_Init+0xee>
24001366:	3218      	adds	r2, #24
24001368:	4293      	cmp	r3, r2
2400136a:	d03c      	beq.n	240013e6 <HAL_DMA_Init+0xee>
  else if(IS_BDMA_CHANNEL_INSTANCE(hdma->Instance) != 0U) /* BDMA instance(s) */
2400136c:	4a6c      	ldr	r2, [pc, #432]	@ (24001520 <HAL_DMA_Init+0x228>)
2400136e:	4293      	cmp	r3, r2
24001370:	f040 8157 	bne.w	24001622 <HAL_DMA_Init+0x32a>
    __HAL_UNLOCK(hdma);
24001374:	2200      	movs	r2, #0
    registerValue |=  DMA_TO_BDMA_DIRECTION(hdma->Init.Direction)            |
24001376:	68a1      	ldr	r1, [r4, #8]
    __HAL_UNLOCK(hdma);
24001378:	f884 2034 	strb.w	r2, [r4, #52]	@ 0x34
    hdma->State = HAL_DMA_STATE_BUSY;
2400137c:	2202      	movs	r2, #2
    registerValue |=  DMA_TO_BDMA_DIRECTION(hdma->Init.Direction)            |
2400137e:	2940      	cmp	r1, #64	@ 0x40
    hdma->State = HAL_DMA_STATE_BUSY;
24001380:	f884 2035 	strb.w	r2, [r4, #53]	@ 0x35
    registerValue = ((BDMA_Channel_TypeDef *)hdma->Instance)->CCR;
24001384:	6818      	ldr	r0, [r3, #0]
    registerValue &= ((uint32_t)~(BDMA_CCR_PL    | BDMA_CCR_MSIZE   | BDMA_CCR_PSIZE  | \
24001386:	f420 30ff 	bic.w	r0, r0, #130560	@ 0x1fe00
2400138a:	f420 70f8 	bic.w	r0, r0, #496	@ 0x1f0
    registerValue |=  DMA_TO_BDMA_DIRECTION(hdma->Init.Direction)            |
2400138e:	f000 8166 	beq.w	2400165e <HAL_DMA_Init+0x366>
24001392:	f1a1 0280 	sub.w	r2, r1, #128	@ 0x80
24001396:	4251      	negs	r1, r2
24001398:	4151      	adcs	r1, r2
2400139a:	0389      	lsls	r1, r1, #14
                      DMA_TO_BDMA_MEMORY_INC(hdma->Init.MemInc)              |
2400139c:	e9d4 6203 	ldrd	r6, r2, [r4, #12]
240013a0:	08d2      	lsrs	r2, r2, #3
240013a2:	ea42 02d6 	orr.w	r2, r2, r6, lsr #3
                      DMA_TO_BDMA_PDATA_SIZE(hdma->Init.PeriphDataAlignment) |
240013a6:	6966      	ldr	r6, [r4, #20]
240013a8:	ea42 02d6 	orr.w	r2, r2, r6, lsr #3
                      DMA_TO_BDMA_MDATA_SIZE(hdma->Init.MemDataAlignment)    |
240013ac:	69a6      	ldr	r6, [r4, #24]
240013ae:	ea42 02d6 	orr.w	r2, r2, r6, lsr #3
                      DMA_TO_BDMA_MODE(hdma->Init.Mode)                      |
240013b2:	69e6      	ldr	r6, [r4, #28]
240013b4:	ea42 02d6 	orr.w	r2, r2, r6, lsr #3
                      DMA_TO_BDMA_PRIORITY(hdma->Init.Priority);
240013b8:	6a26      	ldr	r6, [r4, #32]
240013ba:	ea42 1216 	orr.w	r2, r2, r6, lsr #4
240013be:	4302      	orrs	r2, r0
    regs_bdma = (BDMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
240013c0:	4620      	mov	r0, r4
    registerValue |=  DMA_TO_BDMA_DIRECTION(hdma->Init.Direction)            |
240013c2:	4311      	orrs	r1, r2
    hdma->StreamIndex = (((uint32_t)((uint32_t*)hdma->Instance) - (uint32_t)BDMA_Channel0) / ((uint32_t)BDMA_Channel1 - (uint32_t)BDMA_Channel0)) << 2U;
240013c4:	4a57      	ldr	r2, [pc, #348]	@ (24001524 <HAL_DMA_Init+0x22c>)
    ((BDMA_Channel_TypeDef *)hdma->Instance)->CCR = registerValue;
240013c6:	6019      	str	r1, [r3, #0]
    hdma->StreamIndex = (((uint32_t)((uint32_t*)hdma->Instance) - (uint32_t)BDMA_Channel0) / ((uint32_t)BDMA_Channel1 - (uint32_t)BDMA_Channel0)) << 2U;
240013c8:	441a      	add	r2, r3
240013ca:	2314      	movs	r3, #20
240013cc:	fbb2 f2f3 	udiv	r2, r2, r3
240013d0:	0092      	lsls	r2, r2, #2
240013d2:	65e2      	str	r2, [r4, #92]	@ 0x5c
    regs_bdma = (BDMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
240013d4:	f7ff febe 	bl	24001154 <DMA_CalcBaseAndBitshift>
    regs_bdma->IFCR = ((BDMA_IFCR_CGIF0) << (hdma->StreamIndex & 0x1FU));
240013d8:	6de3      	ldr	r3, [r4, #92]	@ 0x5c
240013da:	f003 021f 	and.w	r2, r3, #31
240013de:	2301      	movs	r3, #1
240013e0:	4093      	lsls	r3, r2
240013e2:	6043      	str	r3, [r0, #4]
240013e4:	e0b4      	b.n	24001550 <HAL_DMA_Init+0x258>
    __HAL_UNLOCK(hdma);
240013e6:	2200      	movs	r2, #0
    __HAL_DMA_DISABLE(hdma);
240013e8:	42ab      	cmp	r3, r5
    __HAL_UNLOCK(hdma);
240013ea:	f884 2034 	strb.w	r2, [r4, #52]	@ 0x34
    hdma->State = HAL_DMA_STATE_BUSY;
240013ee:	f04f 0202 	mov.w	r2, #2
240013f2:	f884 2035 	strb.w	r2, [r4, #53]	@ 0x35
    __HAL_DMA_DISABLE(hdma);
240013f6:	d01e      	beq.n	24001436 <HAL_DMA_Init+0x13e>
240013f8:	4a48      	ldr	r2, [pc, #288]	@ (2400151c <HAL_DMA_Init+0x224>)
240013fa:	4293      	cmp	r3, r2
240013fc:	d01b      	beq.n	24001436 <HAL_DMA_Init+0x13e>
240013fe:	3218      	adds	r2, #24
24001400:	4293      	cmp	r3, r2
24001402:	d018      	beq.n	24001436 <HAL_DMA_Init+0x13e>
24001404:	3218      	adds	r2, #24
24001406:	4293      	cmp	r3, r2
24001408:	d015      	beq.n	24001436 <HAL_DMA_Init+0x13e>
2400140a:	3218      	adds	r2, #24
2400140c:	4293      	cmp	r3, r2
2400140e:	d012      	beq.n	24001436 <HAL_DMA_Init+0x13e>
24001410:	3218      	adds	r2, #24
24001412:	4293      	cmp	r3, r2
24001414:	d00f      	beq.n	24001436 <HAL_DMA_Init+0x13e>
24001416:	3218      	adds	r2, #24
24001418:	4293      	cmp	r3, r2
2400141a:	d00c      	beq.n	24001436 <HAL_DMA_Init+0x13e>
2400141c:	3218      	adds	r2, #24
2400141e:	4293      	cmp	r3, r2
24001420:	d009      	beq.n	24001436 <HAL_DMA_Init+0x13e>
24001422:	f502 7256 	add.w	r2, r2, #856	@ 0x358
24001426:	4293      	cmp	r3, r2
24001428:	d005      	beq.n	24001436 <HAL_DMA_Init+0x13e>
2400142a:	3218      	adds	r2, #24
2400142c:	4293      	cmp	r3, r2
2400142e:	d002      	beq.n	24001436 <HAL_DMA_Init+0x13e>
24001430:	3218      	adds	r2, #24
24001432:	4293      	cmp	r3, r2
24001434:	d0ff      	beq.n	24001436 <HAL_DMA_Init+0x13e>
24001436:	681a      	ldr	r2, [r3, #0]
24001438:	f022 0201 	bic.w	r2, r2, #1
2400143c:	601a      	str	r2, [r3, #0]
    while((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_EN) != 0U)
2400143e:	6822      	ldr	r2, [r4, #0]
24001440:	6813      	ldr	r3, [r2, #0]
24001442:	07df      	lsls	r7, r3, #31
24001444:	d444      	bmi.n	240014d0 <HAL_DMA_Init+0x1d8>
    registerValue = ((DMA_Stream_TypeDef   *)hdma->Instance)->CR;
24001446:	6813      	ldr	r3, [r2, #0]
    registerValue &= ((uint32_t)~(DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
24001448:	4837      	ldr	r0, [pc, #220]	@ (24001528 <HAL_DMA_Init+0x230>)
            hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
2400144a:	69a1      	ldr	r1, [r4, #24]
    registerValue &= ((uint32_t)~(DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
2400144c:	4018      	ands	r0, r3
    registerValue |=  hdma->Init.Direction           |
2400144e:	e9d4 3602 	ldrd	r3, r6, [r4, #8]
24001452:	4333      	orrs	r3, r6
            hdma->Init.PeriphInc           | hdma->Init.MemInc           |
24001454:	6926      	ldr	r6, [r4, #16]
24001456:	4333      	orrs	r3, r6
24001458:	6966      	ldr	r6, [r4, #20]
2400145a:	4333      	orrs	r3, r6
            hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
2400145c:	69e6      	ldr	r6, [r4, #28]
2400145e:	430b      	orrs	r3, r1
24001460:	4333      	orrs	r3, r6
            hdma->Init.Mode                | hdma->Init.Priority;
24001462:	6a26      	ldr	r6, [r4, #32]
24001464:	4333      	orrs	r3, r6
    if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
24001466:	6a66      	ldr	r6, [r4, #36]	@ 0x24
24001468:	2e04      	cmp	r6, #4
    registerValue |=  hdma->Init.Direction           |
2400146a:	ea43 0300 	orr.w	r3, r3, r0
      registerValue |=  hdma->Init.MemBurst | hdma->Init.PeriphBurst;
2400146e:	bf02      	ittt	eq
24001470:	e9d4 070b 	ldrdeq	r0, r7, [r4, #44]	@ 0x2c
24001474:	4338      	orreq	r0, r7
24001476:	4303      	orreq	r3, r0
    if((DBGMCU->IDCODE & 0xFFFF0000U) >= 0x20000000U)
24001478:	482c      	ldr	r0, [pc, #176]	@ (2400152c <HAL_DMA_Init+0x234>)
2400147a:	6800      	ldr	r0, [r0, #0]
2400147c:	0c00      	lsrs	r0, r0, #16
2400147e:	0400      	lsls	r0, r0, #16
24001480:	f1b0 5f00 	cmp.w	r0, #536870912	@ 0x20000000
24001484:	d30e      	bcc.n	240014a4 <HAL_DMA_Init+0x1ac>
      if(IS_DMA_UART_USART_REQUEST(hdma->Init.Request) != 0U)
24001486:	6860      	ldr	r0, [r4, #4]
24001488:	f1a0 0729 	sub.w	r7, r0, #41	@ 0x29
2400148c:	2f05      	cmp	r7, #5
2400148e:	d907      	bls.n	240014a0 <HAL_DMA_Init+0x1a8>
24001490:	383f      	subs	r0, #63	@ 0x3f
24001492:	2813      	cmp	r0, #19
24001494:	d806      	bhi.n	240014a4 <HAL_DMA_Init+0x1ac>
24001496:	4f26      	ldr	r7, [pc, #152]	@ (24001530 <HAL_DMA_Init+0x238>)
24001498:	fa27 f000 	lsr.w	r0, r7, r0
2400149c:	07c0      	lsls	r0, r0, #31
2400149e:	d501      	bpl.n	240014a4 <HAL_DMA_Init+0x1ac>
        registerValue |= DMA_SxCR_TRBUFF;
240014a0:	f443 1380 	orr.w	r3, r3, #1048576	@ 0x100000
    ((DMA_Stream_TypeDef   *)hdma->Instance)->CR = registerValue;
240014a4:	6013      	str	r3, [r2, #0]
    if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
240014a6:	2e04      	cmp	r6, #4
    registerValue = ((DMA_Stream_TypeDef   *)hdma->Instance)->FCR;
240014a8:	6953      	ldr	r3, [r2, #20]
    registerValue &= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);
240014aa:	f023 0307 	bic.w	r3, r3, #7
    registerValue |= hdma->Init.FIFOMode;
240014ae:	ea43 0306 	orr.w	r3, r3, r6
    if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
240014b2:	d143      	bne.n	2400153c <HAL_DMA_Init+0x244>
      registerValue |= hdma->Init.FIFOThreshold;
240014b4:	6aa0      	ldr	r0, [r4, #40]	@ 0x28
      if(hdma->Init.MemBurst != DMA_MBURST_SINGLE)
240014b6:	6ae6      	ldr	r6, [r4, #44]	@ 0x2c
      registerValue |= hdma->Init.FIFOThreshold;
240014b8:	4303      	orrs	r3, r0
      if(hdma->Init.MemBurst != DMA_MBURST_SINGLE)
240014ba:	2e00      	cmp	r6, #0
240014bc:	d03e      	beq.n	2400153c <HAL_DMA_Init+0x244>
  if (hdma->Init.MemDataAlignment == DMA_MDATAALIGN_BYTE)
240014be:	b999      	cbnz	r1, 240014e8 <HAL_DMA_Init+0x1f0>
    switch (hdma->Init.FIFOThreshold)
240014c0:	2801      	cmp	r0, #1
240014c2:	d021      	beq.n	24001508 <HAL_DMA_Init+0x210>
240014c4:	f030 0102 	bics.w	r1, r0, #2
240014c8:	d138      	bne.n	2400153c <HAL_DMA_Init+0x244>
        if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
240014ca:	01f1      	lsls	r1, r6, #7
240014cc:	d536      	bpl.n	2400153c <HAL_DMA_Init+0x244>
240014ce:	e01e      	b.n	2400150e <HAL_DMA_Init+0x216>
      if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA_ABORT)
240014d0:	f010 fc9a 	bl	24011e08 <HAL_GetTick>
240014d4:	1b80      	subs	r0, r0, r6
240014d6:	2805      	cmp	r0, #5
240014d8:	d9b1      	bls.n	2400143e <HAL_DMA_Init+0x146>
        hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
240014da:	2320      	movs	r3, #32
240014dc:	6563      	str	r3, [r4, #84]	@ 0x54
        hdma->State = HAL_DMA_STATE_ERROR;
240014de:	2303      	movs	r3, #3
240014e0:	f884 3035 	strb.w	r3, [r4, #53]	@ 0x35
    return HAL_ERROR;
240014e4:	2001      	movs	r0, #1
}
240014e6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  else if (hdma->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)
240014e8:	f5b1 5f00 	cmp.w	r1, #8192	@ 0x2000
240014ec:	d122      	bne.n	24001534 <HAL_DMA_Init+0x23c>
    switch (hdma->Init.FIFOThreshold)
240014ee:	2803      	cmp	r0, #3
240014f0:	d824      	bhi.n	2400153c <HAL_DMA_Init+0x244>
240014f2:	a101      	add	r1, pc, #4	@ (adr r1, 240014f8 <HAL_DMA_Init+0x200>)
240014f4:	f851 f020 	ldr.w	pc, [r1, r0, lsl #2]
240014f8:	2400150f 	.word	0x2400150f
240014fc:	240014cb 	.word	0x240014cb
24001500:	2400150f 	.word	0x2400150f
24001504:	24001509 	.word	0x24001509
        if (hdma->Init.MemBurst == DMA_MBURST_INC16)
24001508:	f1b6 7fc0 	cmp.w	r6, #25165824	@ 0x1800000
2400150c:	d116      	bne.n	2400153c <HAL_DMA_Init+0x244>
          hdma->ErrorCode = HAL_DMA_ERROR_PARAM;
2400150e:	2340      	movs	r3, #64	@ 0x40
24001510:	6563      	str	r3, [r4, #84]	@ 0x54
          hdma->State = HAL_DMA_STATE_READY;
24001512:	2301      	movs	r3, #1
24001514:	e7e4      	b.n	240014e0 <HAL_DMA_Init+0x1e8>
24001516:	bf00      	nop
24001518:	40020010 	.word	0x40020010
2400151c:	40020028 	.word	0x40020028
24001520:	58025408 	.word	0x58025408
24001524:	a7fdabf8 	.word	0xa7fdabf8
24001528:	fe10803f 	.word	0xfe10803f
2400152c:	5c001000 	.word	0x5c001000
24001530:	000f030f 	.word	0x000f030f
    switch (hdma->Init.FIFOThreshold)
24001534:	2802      	cmp	r0, #2
24001536:	d9ea      	bls.n	2400150e <HAL_DMA_Init+0x216>
24001538:	2803      	cmp	r0, #3
2400153a:	d0c6      	beq.n	240014ca <HAL_DMA_Init+0x1d2>
    ((DMA_Stream_TypeDef   *)hdma->Instance)->FCR = registerValue;
2400153c:	6153      	str	r3, [r2, #20]
    regs_dma = (DMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
2400153e:	4620      	mov	r0, r4
24001540:	f7ff fe08 	bl	24001154 <DMA_CalcBaseAndBitshift>
    regs_dma->IFCR = 0x3FUL << (hdma->StreamIndex & 0x1FU);
24001544:	6de3      	ldr	r3, [r4, #92]	@ 0x5c
24001546:	f003 021f 	and.w	r2, r3, #31
2400154a:	233f      	movs	r3, #63	@ 0x3f
2400154c:	4093      	lsls	r3, r2
2400154e:	6083      	str	r3, [r0, #8]
  if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
24001550:	6823      	ldr	r3, [r4, #0]
24001552:	42ab      	cmp	r3, r5
24001554:	d045      	beq.n	240015e2 <HAL_DMA_Init+0x2ea>
24001556:	4a45      	ldr	r2, [pc, #276]	@ (2400166c <HAL_DMA_Init+0x374>)
24001558:	4293      	cmp	r3, r2
2400155a:	d042      	beq.n	240015e2 <HAL_DMA_Init+0x2ea>
2400155c:	3218      	adds	r2, #24
2400155e:	4293      	cmp	r3, r2
24001560:	d03f      	beq.n	240015e2 <HAL_DMA_Init+0x2ea>
24001562:	3218      	adds	r2, #24
24001564:	4293      	cmp	r3, r2
24001566:	d03c      	beq.n	240015e2 <HAL_DMA_Init+0x2ea>
24001568:	3218      	adds	r2, #24
2400156a:	4293      	cmp	r3, r2
2400156c:	d039      	beq.n	240015e2 <HAL_DMA_Init+0x2ea>
2400156e:	3218      	adds	r2, #24
24001570:	4293      	cmp	r3, r2
24001572:	d036      	beq.n	240015e2 <HAL_DMA_Init+0x2ea>
24001574:	3218      	adds	r2, #24
24001576:	4293      	cmp	r3, r2
24001578:	d033      	beq.n	240015e2 <HAL_DMA_Init+0x2ea>
2400157a:	3218      	adds	r2, #24
2400157c:	4293      	cmp	r3, r2
2400157e:	d030      	beq.n	240015e2 <HAL_DMA_Init+0x2ea>
24001580:	f502 7256 	add.w	r2, r2, #856	@ 0x358
24001584:	4293      	cmp	r3, r2
24001586:	d02c      	beq.n	240015e2 <HAL_DMA_Init+0x2ea>
24001588:	3218      	adds	r2, #24
2400158a:	4293      	cmp	r3, r2
2400158c:	d029      	beq.n	240015e2 <HAL_DMA_Init+0x2ea>
2400158e:	3218      	adds	r2, #24
24001590:	4293      	cmp	r3, r2
24001592:	d026      	beq.n	240015e2 <HAL_DMA_Init+0x2ea>
24001594:	3218      	adds	r2, #24
24001596:	4293      	cmp	r3, r2
24001598:	d023      	beq.n	240015e2 <HAL_DMA_Init+0x2ea>
2400159a:	3218      	adds	r2, #24
2400159c:	4293      	cmp	r3, r2
2400159e:	d020      	beq.n	240015e2 <HAL_DMA_Init+0x2ea>
240015a0:	3218      	adds	r2, #24
240015a2:	4293      	cmp	r3, r2
240015a4:	d01d      	beq.n	240015e2 <HAL_DMA_Init+0x2ea>
240015a6:	3218      	adds	r2, #24
240015a8:	4293      	cmp	r3, r2
240015aa:	d01a      	beq.n	240015e2 <HAL_DMA_Init+0x2ea>
240015ac:	3218      	adds	r2, #24
240015ae:	4293      	cmp	r3, r2
240015b0:	d017      	beq.n	240015e2 <HAL_DMA_Init+0x2ea>
240015b2:	4a2f      	ldr	r2, [pc, #188]	@ (24001670 <HAL_DMA_Init+0x378>)
240015b4:	4293      	cmp	r3, r2
240015b6:	d014      	beq.n	240015e2 <HAL_DMA_Init+0x2ea>
240015b8:	3214      	adds	r2, #20
240015ba:	4293      	cmp	r3, r2
240015bc:	d011      	beq.n	240015e2 <HAL_DMA_Init+0x2ea>
240015be:	3214      	adds	r2, #20
240015c0:	4293      	cmp	r3, r2
240015c2:	d00e      	beq.n	240015e2 <HAL_DMA_Init+0x2ea>
240015c4:	3214      	adds	r2, #20
240015c6:	4293      	cmp	r3, r2
240015c8:	d00b      	beq.n	240015e2 <HAL_DMA_Init+0x2ea>
240015ca:	3214      	adds	r2, #20
240015cc:	4293      	cmp	r3, r2
240015ce:	d008      	beq.n	240015e2 <HAL_DMA_Init+0x2ea>
240015d0:	3214      	adds	r2, #20
240015d2:	4293      	cmp	r3, r2
240015d4:	d005      	beq.n	240015e2 <HAL_DMA_Init+0x2ea>
240015d6:	3214      	adds	r2, #20
240015d8:	4293      	cmp	r3, r2
240015da:	d002      	beq.n	240015e2 <HAL_DMA_Init+0x2ea>
240015dc:	3214      	adds	r2, #20
240015de:	4293      	cmp	r3, r2
240015e0:	d119      	bne.n	24001616 <HAL_DMA_Init+0x31e>
    DMA_CalcDMAMUXChannelBaseAndMask(hdma);
240015e2:	4620      	mov	r0, r4
240015e4:	2500      	movs	r5, #0
240015e6:	f7ff fe03 	bl	240011f0 <DMA_CalcDMAMUXChannelBaseAndMask>
    if(hdma->Init.Direction == DMA_MEMORY_TO_MEMORY)
240015ea:	68a3      	ldr	r3, [r4, #8]
    hdma->DMAmuxChannel->CCR = (hdma->Init.Request & DMAMUX_CxCR_DMAREQ_ID);
240015ec:	6e22      	ldr	r2, [r4, #96]	@ 0x60
    if(hdma->Init.Direction == DMA_MEMORY_TO_MEMORY)
240015ee:	2b80      	cmp	r3, #128	@ 0x80
      hdma->Init.Request = DMA_REQUEST_MEM2MEM;
240015f0:	bf04      	itt	eq
240015f2:	2300      	moveq	r3, #0
240015f4:	6063      	streq	r3, [r4, #4]
    hdma->DMAmuxChannel->CCR = (hdma->Init.Request & DMAMUX_CxCR_DMAREQ_ID);
240015f6:	6863      	ldr	r3, [r4, #4]
240015f8:	b2d9      	uxtb	r1, r3
    if((hdma->Init.Request >= DMA_REQUEST_GENERATOR0) && (hdma->Init.Request <= DMA_REQUEST_GENERATOR7))
240015fa:	3b01      	subs	r3, #1
    hdma->DMAmuxChannel->CCR = (hdma->Init.Request & DMAMUX_CxCR_DMAREQ_ID);
240015fc:	6011      	str	r1, [r2, #0]
    if((hdma->Init.Request >= DMA_REQUEST_GENERATOR0) && (hdma->Init.Request <= DMA_REQUEST_GENERATOR7))
240015fe:	2b07      	cmp	r3, #7
    hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
24001600:	e9d4 2119 	ldrd	r2, r1, [r4, #100]	@ 0x64
24001604:	6051      	str	r1, [r2, #4]
    if((hdma->Init.Request >= DMA_REQUEST_GENERATOR0) && (hdma->Init.Request <= DMA_REQUEST_GENERATOR7))
24001606:	d82c      	bhi.n	24001662 <HAL_DMA_Init+0x36a>
      DMA_CalcDMAMUXRequestGenBaseAndMask(hdma);
24001608:	f7ff fe3e 	bl	24001288 <DMA_CalcDMAMUXRequestGenBaseAndMask>
      hdma->DMAmuxRequestGen->RGCR = 0U;
2400160c:	6ee3      	ldr	r3, [r4, #108]	@ 0x6c
2400160e:	601d      	str	r5, [r3, #0]
      hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
24001610:	e9d4 321c 	ldrd	r3, r2, [r4, #112]	@ 0x70
24001614:	605a      	str	r2, [r3, #4]
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
24001616:	2000      	movs	r0, #0
  hdma->State = HAL_DMA_STATE_READY;
24001618:	2301      	movs	r3, #1
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
2400161a:	6560      	str	r0, [r4, #84]	@ 0x54
  hdma->State = HAL_DMA_STATE_READY;
2400161c:	f884 3035 	strb.w	r3, [r4, #53]	@ 0x35
  return HAL_OK;
24001620:	e761      	b.n	240014e6 <HAL_DMA_Init+0x1ee>
  else if(IS_BDMA_CHANNEL_INSTANCE(hdma->Instance) != 0U) /* BDMA instance(s) */
24001622:	4a14      	ldr	r2, [pc, #80]	@ (24001674 <HAL_DMA_Init+0x37c>)
24001624:	4293      	cmp	r3, r2
24001626:	f43f aea5 	beq.w	24001374 <HAL_DMA_Init+0x7c>
2400162a:	3214      	adds	r2, #20
2400162c:	4293      	cmp	r3, r2
2400162e:	f43f aea1 	beq.w	24001374 <HAL_DMA_Init+0x7c>
24001632:	3214      	adds	r2, #20
24001634:	4293      	cmp	r3, r2
24001636:	f43f ae9d 	beq.w	24001374 <HAL_DMA_Init+0x7c>
2400163a:	3214      	adds	r2, #20
2400163c:	4293      	cmp	r3, r2
2400163e:	f43f ae99 	beq.w	24001374 <HAL_DMA_Init+0x7c>
24001642:	3214      	adds	r2, #20
24001644:	4293      	cmp	r3, r2
24001646:	f43f ae95 	beq.w	24001374 <HAL_DMA_Init+0x7c>
2400164a:	3214      	adds	r2, #20
2400164c:	4293      	cmp	r3, r2
2400164e:	f43f ae91 	beq.w	24001374 <HAL_DMA_Init+0x7c>
24001652:	3214      	adds	r2, #20
24001654:	4293      	cmp	r3, r2
24001656:	f43f ae8d 	beq.w	24001374 <HAL_DMA_Init+0x7c>
    hdma->ErrorCode = HAL_DMA_ERROR_PARAM;
2400165a:	2340      	movs	r3, #64	@ 0x40
2400165c:	e73e      	b.n	240014dc <HAL_DMA_Init+0x1e4>
    registerValue |=  DMA_TO_BDMA_DIRECTION(hdma->Init.Direction)            |
2400165e:	2110      	movs	r1, #16
24001660:	e69c      	b.n	2400139c <HAL_DMA_Init+0xa4>
      hdma->DMAmuxRequestGenStatus = 0U;
24001662:	e9c4 551b 	strd	r5, r5, [r4, #108]	@ 0x6c
      hdma->DMAmuxRequestGenStatusMask = 0U;
24001666:	6765      	str	r5, [r4, #116]	@ 0x74
24001668:	e7d5      	b.n	24001616 <HAL_DMA_Init+0x31e>
2400166a:	bf00      	nop
2400166c:	40020028 	.word	0x40020028
24001670:	58025408 	.word	0x58025408
24001674:	5802541c 	.word	0x5802541c

24001678 <HAL_DMA_DeInit>:
{
24001678:	b570      	push	{r4, r5, r6, lr}
  if(hdma == NULL)
2400167a:	4605      	mov	r5, r0
2400167c:	b908      	cbnz	r0, 24001682 <HAL_DMA_DeInit+0xa>
    return HAL_ERROR;
2400167e:	2001      	movs	r0, #1
}
24001680:	bd70      	pop	{r4, r5, r6, pc}
  __HAL_DMA_DISABLE(hdma);
24001682:	6804      	ldr	r4, [r0, #0]
24001684:	4e99      	ldr	r6, [pc, #612]	@ (240018ec <HAL_DMA_DeInit+0x274>)
24001686:	42b4      	cmp	r4, r6
24001688:	d02d      	beq.n	240016e6 <HAL_DMA_DeInit+0x6e>
2400168a:	4b99      	ldr	r3, [pc, #612]	@ (240018f0 <HAL_DMA_DeInit+0x278>)
2400168c:	429c      	cmp	r4, r3
2400168e:	d02a      	beq.n	240016e6 <HAL_DMA_DeInit+0x6e>
24001690:	3318      	adds	r3, #24
24001692:	429c      	cmp	r4, r3
24001694:	d027      	beq.n	240016e6 <HAL_DMA_DeInit+0x6e>
24001696:	3318      	adds	r3, #24
24001698:	429c      	cmp	r4, r3
2400169a:	d024      	beq.n	240016e6 <HAL_DMA_DeInit+0x6e>
2400169c:	3318      	adds	r3, #24
2400169e:	429c      	cmp	r4, r3
240016a0:	d021      	beq.n	240016e6 <HAL_DMA_DeInit+0x6e>
240016a2:	3318      	adds	r3, #24
240016a4:	429c      	cmp	r4, r3
240016a6:	d01e      	beq.n	240016e6 <HAL_DMA_DeInit+0x6e>
240016a8:	3318      	adds	r3, #24
240016aa:	429c      	cmp	r4, r3
240016ac:	d01b      	beq.n	240016e6 <HAL_DMA_DeInit+0x6e>
240016ae:	3318      	adds	r3, #24
240016b0:	429c      	cmp	r4, r3
240016b2:	d018      	beq.n	240016e6 <HAL_DMA_DeInit+0x6e>
240016b4:	f503 7356 	add.w	r3, r3, #856	@ 0x358
240016b8:	429c      	cmp	r4, r3
240016ba:	d014      	beq.n	240016e6 <HAL_DMA_DeInit+0x6e>
240016bc:	3318      	adds	r3, #24
240016be:	429c      	cmp	r4, r3
240016c0:	d011      	beq.n	240016e6 <HAL_DMA_DeInit+0x6e>
240016c2:	3318      	adds	r3, #24
240016c4:	429c      	cmp	r4, r3
240016c6:	d00e      	beq.n	240016e6 <HAL_DMA_DeInit+0x6e>
240016c8:	3318      	adds	r3, #24
240016ca:	429c      	cmp	r4, r3
240016cc:	d00b      	beq.n	240016e6 <HAL_DMA_DeInit+0x6e>
240016ce:	3318      	adds	r3, #24
240016d0:	429c      	cmp	r4, r3
240016d2:	d008      	beq.n	240016e6 <HAL_DMA_DeInit+0x6e>
240016d4:	3318      	adds	r3, #24
240016d6:	429c      	cmp	r4, r3
240016d8:	d005      	beq.n	240016e6 <HAL_DMA_DeInit+0x6e>
240016da:	3318      	adds	r3, #24
240016dc:	429c      	cmp	r4, r3
240016de:	d002      	beq.n	240016e6 <HAL_DMA_DeInit+0x6e>
240016e0:	3318      	adds	r3, #24
240016e2:	429c      	cmp	r4, r3
240016e4:	d134      	bne.n	24001750 <HAL_DMA_DeInit+0xd8>
240016e6:	6823      	ldr	r3, [r4, #0]
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
240016e8:	42b4      	cmp	r4, r6
  __HAL_DMA_DISABLE(hdma);
240016ea:	f023 0301 	bic.w	r3, r3, #1
240016ee:	6023      	str	r3, [r4, #0]
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
240016f0:	d169      	bne.n	240017c6 <HAL_DMA_DeInit+0x14e>
    ((DMA_Stream_TypeDef   *)hdma->Instance)->CR   = 0U;
240016f2:	2300      	movs	r3, #0
    regs_dma = (DMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
240016f4:	4628      	mov	r0, r5
    ((DMA_Stream_TypeDef   *)hdma->Instance)->CR   = 0U;
240016f6:	6023      	str	r3, [r4, #0]
    ((DMA_Stream_TypeDef   *)hdma->Instance)->NDTR = 0U;
240016f8:	6063      	str	r3, [r4, #4]
    ((DMA_Stream_TypeDef   *)hdma->Instance)->PAR  = 0U;
240016fa:	60a3      	str	r3, [r4, #8]
    ((DMA_Stream_TypeDef   *)hdma->Instance)->M0AR = 0U;
240016fc:	60e3      	str	r3, [r4, #12]
    ((DMA_Stream_TypeDef   *)hdma->Instance)->M1AR = 0U;
240016fe:	6123      	str	r3, [r4, #16]
    ((DMA_Stream_TypeDef   *)hdma->Instance)->FCR  = (uint32_t)0x00000021U;
24001700:	2321      	movs	r3, #33	@ 0x21
24001702:	6163      	str	r3, [r4, #20]
    regs_dma = (DMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
24001704:	f7ff fd26 	bl	24001154 <DMA_CalcBaseAndBitshift>
    regs_dma->IFCR = 0x3FUL << (hdma->StreamIndex & 0x1FU);
24001708:	6deb      	ldr	r3, [r5, #92]	@ 0x5c
  if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
2400170a:	42b4      	cmp	r4, r6
    regs_dma->IFCR = 0x3FUL << (hdma->StreamIndex & 0x1FU);
2400170c:	f003 021f 	and.w	r2, r3, #31
24001710:	f04f 033f 	mov.w	r3, #63	@ 0x3f
24001714:	fa03 f302 	lsl.w	r3, r3, r2
24001718:	6083      	str	r3, [r0, #8]
  if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
2400171a:	f040 80a2 	bne.w	24001862 <HAL_DMA_DeInit+0x1ea>
    DMA_CalcDMAMUXChannelBaseAndMask(hdma);
2400171e:	4628      	mov	r0, r5
24001720:	f7ff fd66 	bl	240011f0 <DMA_CalcDMAMUXChannelBaseAndMask>
    if(hdma->DMAmuxChannel != 0U)
24001724:	6e2b      	ldr	r3, [r5, #96]	@ 0x60
24001726:	2b00      	cmp	r3, #0
24001728:	f040 80d9 	bne.w	240018de <HAL_DMA_DeInit+0x266>
    if((hdma->Init.Request >= DMA_REQUEST_GENERATOR0) && (hdma->Init.Request <= DMA_REQUEST_GENERATOR7))
2400172c:	686b      	ldr	r3, [r5, #4]
2400172e:	3b01      	subs	r3, #1
24001730:	2b07      	cmp	r3, #7
24001732:	d808      	bhi.n	24001746 <HAL_DMA_DeInit+0xce>
      DMA_CalcDMAMUXRequestGenBaseAndMask(hdma);
24001734:	4628      	mov	r0, r5
24001736:	f7ff fda7 	bl	24001288 <DMA_CalcDMAMUXRequestGenBaseAndMask>
      hdma->DMAmuxRequestGen->RGCR = 0U;
2400173a:	6eeb      	ldr	r3, [r5, #108]	@ 0x6c
2400173c:	2200      	movs	r2, #0
2400173e:	601a      	str	r2, [r3, #0]
      hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
24001740:	e9d5 321c 	ldrd	r3, r2, [r5, #112]	@ 0x70
24001744:	605a      	str	r2, [r3, #4]
    hdma->DMAmuxRequestGen = 0U;
24001746:	2300      	movs	r3, #0
    hdma->DMAmuxRequestGenStatus = 0U;
24001748:	e9c5 331b 	strd	r3, r3, [r5, #108]	@ 0x6c
    hdma->DMAmuxRequestGenStatusMask = 0U;
2400174c:	676b      	str	r3, [r5, #116]	@ 0x74
2400174e:	e02d      	b.n	240017ac <HAL_DMA_DeInit+0x134>
  __HAL_DMA_DISABLE(hdma);
24001750:	6823      	ldr	r3, [r4, #0]
24001752:	f023 0301 	bic.w	r3, r3, #1
24001756:	6023      	str	r3, [r4, #0]
  else if(IS_BDMA_CHANNEL_INSTANCE(hdma->Instance) != 0U) /* BDMA instance(s) */
24001758:	4b66      	ldr	r3, [pc, #408]	@ (240018f4 <HAL_DMA_DeInit+0x27c>)
2400175a:	429c      	cmp	r4, r3
2400175c:	d16a      	bne.n	24001834 <HAL_DMA_DeInit+0x1bc>
    ((BDMA_Channel_TypeDef *)hdma->Instance)->CCR  = 0U;
2400175e:	2300      	movs	r3, #0
    regs_bdma = (BDMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
24001760:	4628      	mov	r0, r5
    ((BDMA_Channel_TypeDef *)hdma->Instance)->CCR  = 0U;
24001762:	6023      	str	r3, [r4, #0]
    ((BDMA_Channel_TypeDef *)hdma->Instance)->CNDTR = 0U;
24001764:	6063      	str	r3, [r4, #4]
    ((BDMA_Channel_TypeDef *)hdma->Instance)->CPAR  = 0U;
24001766:	60a3      	str	r3, [r4, #8]
    ((BDMA_Channel_TypeDef *)hdma->Instance)->CM0AR = 0U;
24001768:	60e3      	str	r3, [r4, #12]
    ((BDMA_Channel_TypeDef *)hdma->Instance)->CM1AR = 0U;
2400176a:	6123      	str	r3, [r4, #16]
    regs_bdma = (BDMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
2400176c:	f7ff fcf2 	bl	24001154 <DMA_CalcBaseAndBitshift>
    regs_bdma->IFCR = ((BDMA_IFCR_CGIF0) << (hdma->StreamIndex & 0x1FU));
24001770:	6deb      	ldr	r3, [r5, #92]	@ 0x5c
24001772:	f003 021f 	and.w	r2, r3, #31
24001776:	2301      	movs	r3, #1
24001778:	4093      	lsls	r3, r2
2400177a:	6043      	str	r3, [r0, #4]
  if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
2400177c:	4b5d      	ldr	r3, [pc, #372]	@ (240018f4 <HAL_DMA_DeInit+0x27c>)
2400177e:	429c      	cmp	r4, r3
24001780:	d0cd      	beq.n	2400171e <HAL_DMA_DeInit+0xa6>
24001782:	3314      	adds	r3, #20
24001784:	429c      	cmp	r4, r3
24001786:	d0ca      	beq.n	2400171e <HAL_DMA_DeInit+0xa6>
24001788:	3314      	adds	r3, #20
2400178a:	429c      	cmp	r4, r3
2400178c:	d0c7      	beq.n	2400171e <HAL_DMA_DeInit+0xa6>
2400178e:	3314      	adds	r3, #20
24001790:	429c      	cmp	r4, r3
24001792:	d0c4      	beq.n	2400171e <HAL_DMA_DeInit+0xa6>
24001794:	3314      	adds	r3, #20
24001796:	429c      	cmp	r4, r3
24001798:	d0c1      	beq.n	2400171e <HAL_DMA_DeInit+0xa6>
2400179a:	3314      	adds	r3, #20
2400179c:	429c      	cmp	r4, r3
2400179e:	d0be      	beq.n	2400171e <HAL_DMA_DeInit+0xa6>
240017a0:	3314      	adds	r3, #20
240017a2:	429c      	cmp	r4, r3
240017a4:	d0bb      	beq.n	2400171e <HAL_DMA_DeInit+0xa6>
240017a6:	3314      	adds	r3, #20
240017a8:	429c      	cmp	r4, r3
240017aa:	d0b8      	beq.n	2400171e <HAL_DMA_DeInit+0xa6>
  hdma->XferCpltCallback       = NULL;
240017ac:	2000      	movs	r0, #0
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
240017ae:	6568      	str	r0, [r5, #84]	@ 0x54
  __HAL_UNLOCK(hdma);
240017b0:	f885 0034 	strb.w	r0, [r5, #52]	@ 0x34
  hdma->State = HAL_DMA_STATE_RESET;
240017b4:	f885 0035 	strb.w	r0, [r5, #53]	@ 0x35
  hdma->XferHalfCpltCallback   = NULL;
240017b8:	e9c5 000f 	strd	r0, r0, [r5, #60]	@ 0x3c
  hdma->XferM1HalfCpltCallback = NULL;
240017bc:	e9c5 0011 	strd	r0, r0, [r5, #68]	@ 0x44
  hdma->XferAbortCallback      = NULL;
240017c0:	e9c5 0013 	strd	r0, r0, [r5, #76]	@ 0x4c
  return HAL_OK;
240017c4:	e75c      	b.n	24001680 <HAL_DMA_DeInit+0x8>
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
240017c6:	4b4a      	ldr	r3, [pc, #296]	@ (240018f0 <HAL_DMA_DeInit+0x278>)
240017c8:	429c      	cmp	r4, r3
240017ca:	d092      	beq.n	240016f2 <HAL_DMA_DeInit+0x7a>
240017cc:	3318      	adds	r3, #24
240017ce:	429c      	cmp	r4, r3
240017d0:	d08f      	beq.n	240016f2 <HAL_DMA_DeInit+0x7a>
240017d2:	3318      	adds	r3, #24
240017d4:	429c      	cmp	r4, r3
240017d6:	d08c      	beq.n	240016f2 <HAL_DMA_DeInit+0x7a>
240017d8:	3318      	adds	r3, #24
240017da:	429c      	cmp	r4, r3
240017dc:	d089      	beq.n	240016f2 <HAL_DMA_DeInit+0x7a>
240017de:	3318      	adds	r3, #24
240017e0:	429c      	cmp	r4, r3
240017e2:	d086      	beq.n	240016f2 <HAL_DMA_DeInit+0x7a>
240017e4:	3318      	adds	r3, #24
240017e6:	429c      	cmp	r4, r3
240017e8:	d083      	beq.n	240016f2 <HAL_DMA_DeInit+0x7a>
240017ea:	3318      	adds	r3, #24
240017ec:	429c      	cmp	r4, r3
240017ee:	d080      	beq.n	240016f2 <HAL_DMA_DeInit+0x7a>
240017f0:	f503 7356 	add.w	r3, r3, #856	@ 0x358
240017f4:	429c      	cmp	r4, r3
240017f6:	f43f af7c 	beq.w	240016f2 <HAL_DMA_DeInit+0x7a>
240017fa:	3318      	adds	r3, #24
240017fc:	429c      	cmp	r4, r3
240017fe:	f43f af78 	beq.w	240016f2 <HAL_DMA_DeInit+0x7a>
24001802:	3318      	adds	r3, #24
24001804:	429c      	cmp	r4, r3
24001806:	f43f af74 	beq.w	240016f2 <HAL_DMA_DeInit+0x7a>
2400180a:	3318      	adds	r3, #24
2400180c:	429c      	cmp	r4, r3
2400180e:	f43f af70 	beq.w	240016f2 <HAL_DMA_DeInit+0x7a>
24001812:	3318      	adds	r3, #24
24001814:	429c      	cmp	r4, r3
24001816:	f43f af6c 	beq.w	240016f2 <HAL_DMA_DeInit+0x7a>
2400181a:	3318      	adds	r3, #24
2400181c:	429c      	cmp	r4, r3
2400181e:	f43f af68 	beq.w	240016f2 <HAL_DMA_DeInit+0x7a>
24001822:	3318      	adds	r3, #24
24001824:	429c      	cmp	r4, r3
24001826:	f43f af64 	beq.w	240016f2 <HAL_DMA_DeInit+0x7a>
2400182a:	3318      	adds	r3, #24
2400182c:	429c      	cmp	r4, r3
2400182e:	f43f af60 	beq.w	240016f2 <HAL_DMA_DeInit+0x7a>
24001832:	e791      	b.n	24001758 <HAL_DMA_DeInit+0xe0>
  else if(IS_BDMA_CHANNEL_INSTANCE(hdma->Instance) != 0U) /* BDMA instance(s) */
24001834:	4b30      	ldr	r3, [pc, #192]	@ (240018f8 <HAL_DMA_DeInit+0x280>)
24001836:	429c      	cmp	r4, r3
24001838:	d091      	beq.n	2400175e <HAL_DMA_DeInit+0xe6>
2400183a:	3314      	adds	r3, #20
2400183c:	429c      	cmp	r4, r3
2400183e:	d08e      	beq.n	2400175e <HAL_DMA_DeInit+0xe6>
24001840:	3314      	adds	r3, #20
24001842:	429c      	cmp	r4, r3
24001844:	d08b      	beq.n	2400175e <HAL_DMA_DeInit+0xe6>
24001846:	3314      	adds	r3, #20
24001848:	429c      	cmp	r4, r3
2400184a:	d088      	beq.n	2400175e <HAL_DMA_DeInit+0xe6>
2400184c:	3314      	adds	r3, #20
2400184e:	429c      	cmp	r4, r3
24001850:	d085      	beq.n	2400175e <HAL_DMA_DeInit+0xe6>
24001852:	3314      	adds	r3, #20
24001854:	429c      	cmp	r4, r3
24001856:	d082      	beq.n	2400175e <HAL_DMA_DeInit+0xe6>
24001858:	3314      	adds	r3, #20
2400185a:	429c      	cmp	r4, r3
2400185c:	f47f af0f 	bne.w	2400167e <HAL_DMA_DeInit+0x6>
24001860:	e77d      	b.n	2400175e <HAL_DMA_DeInit+0xe6>
  if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
24001862:	4b23      	ldr	r3, [pc, #140]	@ (240018f0 <HAL_DMA_DeInit+0x278>)
24001864:	429c      	cmp	r4, r3
24001866:	f43f af5a 	beq.w	2400171e <HAL_DMA_DeInit+0xa6>
2400186a:	3318      	adds	r3, #24
2400186c:	429c      	cmp	r4, r3
2400186e:	f43f af56 	beq.w	2400171e <HAL_DMA_DeInit+0xa6>
24001872:	3318      	adds	r3, #24
24001874:	429c      	cmp	r4, r3
24001876:	f43f af52 	beq.w	2400171e <HAL_DMA_DeInit+0xa6>
2400187a:	3318      	adds	r3, #24
2400187c:	429c      	cmp	r4, r3
2400187e:	f43f af4e 	beq.w	2400171e <HAL_DMA_DeInit+0xa6>
24001882:	3318      	adds	r3, #24
24001884:	429c      	cmp	r4, r3
24001886:	f43f af4a 	beq.w	2400171e <HAL_DMA_DeInit+0xa6>
2400188a:	3318      	adds	r3, #24
2400188c:	429c      	cmp	r4, r3
2400188e:	f43f af46 	beq.w	2400171e <HAL_DMA_DeInit+0xa6>
24001892:	3318      	adds	r3, #24
24001894:	429c      	cmp	r4, r3
24001896:	f43f af42 	beq.w	2400171e <HAL_DMA_DeInit+0xa6>
2400189a:	f503 7356 	add.w	r3, r3, #856	@ 0x358
2400189e:	429c      	cmp	r4, r3
240018a0:	f43f af3d 	beq.w	2400171e <HAL_DMA_DeInit+0xa6>
240018a4:	3318      	adds	r3, #24
240018a6:	429c      	cmp	r4, r3
240018a8:	f43f af39 	beq.w	2400171e <HAL_DMA_DeInit+0xa6>
240018ac:	3318      	adds	r3, #24
240018ae:	429c      	cmp	r4, r3
240018b0:	f43f af35 	beq.w	2400171e <HAL_DMA_DeInit+0xa6>
240018b4:	3318      	adds	r3, #24
240018b6:	429c      	cmp	r4, r3
240018b8:	f43f af31 	beq.w	2400171e <HAL_DMA_DeInit+0xa6>
240018bc:	3318      	adds	r3, #24
240018be:	429c      	cmp	r4, r3
240018c0:	f43f af2d 	beq.w	2400171e <HAL_DMA_DeInit+0xa6>
240018c4:	3318      	adds	r3, #24
240018c6:	429c      	cmp	r4, r3
240018c8:	f43f af29 	beq.w	2400171e <HAL_DMA_DeInit+0xa6>
240018cc:	3318      	adds	r3, #24
240018ce:	429c      	cmp	r4, r3
240018d0:	f43f af25 	beq.w	2400171e <HAL_DMA_DeInit+0xa6>
240018d4:	3318      	adds	r3, #24
240018d6:	429c      	cmp	r4, r3
240018d8:	f43f af21 	beq.w	2400171e <HAL_DMA_DeInit+0xa6>
240018dc:	e74e      	b.n	2400177c <HAL_DMA_DeInit+0x104>
      hdma->DMAmuxChannel->CCR = 0U;
240018de:	2200      	movs	r2, #0
240018e0:	601a      	str	r2, [r3, #0]
      hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
240018e2:	e9d5 3219 	ldrd	r3, r2, [r5, #100]	@ 0x64
240018e6:	605a      	str	r2, [r3, #4]
240018e8:	e720      	b.n	2400172c <HAL_DMA_DeInit+0xb4>
240018ea:	bf00      	nop
240018ec:	40020010 	.word	0x40020010
240018f0:	40020028 	.word	0x40020028
240018f4:	58025408 	.word	0x58025408
240018f8:	5802541c 	.word	0x5802541c

240018fc <HAL_DMA_Start>:
{
240018fc:	b570      	push	{r4, r5, r6, lr}
  if(hdma == NULL)
240018fe:	2800      	cmp	r0, #0
24001900:	d065      	beq.n	240019ce <HAL_DMA_Start+0xd2>
  __HAL_LOCK(hdma);
24001902:	f890 4034 	ldrb.w	r4, [r0, #52]	@ 0x34
24001906:	2c01      	cmp	r4, #1
24001908:	d063      	beq.n	240019d2 <HAL_DMA_Start+0xd6>
2400190a:	2401      	movs	r4, #1
2400190c:	f880 4034 	strb.w	r4, [r0, #52]	@ 0x34
  if(HAL_DMA_STATE_READY == hdma->State)
24001910:	f890 4035 	ldrb.w	r4, [r0, #53]	@ 0x35
24001914:	2c01      	cmp	r4, #1
24001916:	f04f 0400 	mov.w	r4, #0
2400191a:	d153      	bne.n	240019c4 <HAL_DMA_Start+0xc8>
    hdma->State = HAL_DMA_STATE_BUSY;
2400191c:	2502      	movs	r5, #2
    __HAL_DMA_DISABLE(hdma);
2400191e:	4e2e      	ldr	r6, [pc, #184]	@ (240019d8 <HAL_DMA_Start+0xdc>)
    hdma->State = HAL_DMA_STATE_BUSY;
24001920:	f880 5035 	strb.w	r5, [r0, #53]	@ 0x35
    hdma->ErrorCode = HAL_DMA_ERROR_NONE;
24001924:	6544      	str	r4, [r0, #84]	@ 0x54
    __HAL_DMA_DISABLE(hdma);
24001926:	6804      	ldr	r4, [r0, #0]
24001928:	42b4      	cmp	r4, r6
2400192a:	d01e      	beq.n	2400196a <HAL_DMA_Start+0x6e>
2400192c:	4d2b      	ldr	r5, [pc, #172]	@ (240019dc <HAL_DMA_Start+0xe0>)
2400192e:	42ac      	cmp	r4, r5
24001930:	d01b      	beq.n	2400196a <HAL_DMA_Start+0x6e>
24001932:	3518      	adds	r5, #24
24001934:	42ac      	cmp	r4, r5
24001936:	d018      	beq.n	2400196a <HAL_DMA_Start+0x6e>
24001938:	3518      	adds	r5, #24
2400193a:	42ac      	cmp	r4, r5
2400193c:	d015      	beq.n	2400196a <HAL_DMA_Start+0x6e>
2400193e:	3518      	adds	r5, #24
24001940:	42ac      	cmp	r4, r5
24001942:	d012      	beq.n	2400196a <HAL_DMA_Start+0x6e>
24001944:	3518      	adds	r5, #24
24001946:	42ac      	cmp	r4, r5
24001948:	d00f      	beq.n	2400196a <HAL_DMA_Start+0x6e>
2400194a:	3518      	adds	r5, #24
2400194c:	42ac      	cmp	r4, r5
2400194e:	d00c      	beq.n	2400196a <HAL_DMA_Start+0x6e>
24001950:	3518      	adds	r5, #24
24001952:	42ac      	cmp	r4, r5
24001954:	d009      	beq.n	2400196a <HAL_DMA_Start+0x6e>
24001956:	f505 7556 	add.w	r5, r5, #856	@ 0x358
2400195a:	42ac      	cmp	r4, r5
2400195c:	d005      	beq.n	2400196a <HAL_DMA_Start+0x6e>
2400195e:	3518      	adds	r5, #24
24001960:	42ac      	cmp	r4, r5
24001962:	d002      	beq.n	2400196a <HAL_DMA_Start+0x6e>
24001964:	3518      	adds	r5, #24
24001966:	42ac      	cmp	r4, r5
24001968:	d0ff      	beq.n	2400196a <HAL_DMA_Start+0x6e>
2400196a:	6825      	ldr	r5, [r4, #0]
2400196c:	f025 0501 	bic.w	r5, r5, #1
24001970:	6025      	str	r5, [r4, #0]
    DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength);
24001972:	f7ff fb2d 	bl	24000fd0 <DMA_SetConfig>
    __HAL_DMA_ENABLE(hdma);
24001976:	42b4      	cmp	r4, r6
24001978:	d01e      	beq.n	240019b8 <HAL_DMA_Start+0xbc>
2400197a:	4b18      	ldr	r3, [pc, #96]	@ (240019dc <HAL_DMA_Start+0xe0>)
2400197c:	429c      	cmp	r4, r3
2400197e:	d01b      	beq.n	240019b8 <HAL_DMA_Start+0xbc>
24001980:	3318      	adds	r3, #24
24001982:	429c      	cmp	r4, r3
24001984:	d018      	beq.n	240019b8 <HAL_DMA_Start+0xbc>
24001986:	3318      	adds	r3, #24
24001988:	429c      	cmp	r4, r3
2400198a:	d015      	beq.n	240019b8 <HAL_DMA_Start+0xbc>
2400198c:	3318      	adds	r3, #24
2400198e:	429c      	cmp	r4, r3
24001990:	d012      	beq.n	240019b8 <HAL_DMA_Start+0xbc>
24001992:	3318      	adds	r3, #24
24001994:	429c      	cmp	r4, r3
24001996:	d00f      	beq.n	240019b8 <HAL_DMA_Start+0xbc>
24001998:	3318      	adds	r3, #24
2400199a:	429c      	cmp	r4, r3
2400199c:	d00c      	beq.n	240019b8 <HAL_DMA_Start+0xbc>
2400199e:	3318      	adds	r3, #24
240019a0:	429c      	cmp	r4, r3
240019a2:	d009      	beq.n	240019b8 <HAL_DMA_Start+0xbc>
240019a4:	f503 7356 	add.w	r3, r3, #856	@ 0x358
240019a8:	429c      	cmp	r4, r3
240019aa:	d005      	beq.n	240019b8 <HAL_DMA_Start+0xbc>
240019ac:	3318      	adds	r3, #24
240019ae:	429c      	cmp	r4, r3
240019b0:	d002      	beq.n	240019b8 <HAL_DMA_Start+0xbc>
240019b2:	3318      	adds	r3, #24
240019b4:	429c      	cmp	r4, r3
240019b6:	d0ff      	beq.n	240019b8 <HAL_DMA_Start+0xbc>
240019b8:	6823      	ldr	r3, [r4, #0]
  HAL_StatusTypeDef status = HAL_OK;
240019ba:	2000      	movs	r0, #0
    __HAL_DMA_ENABLE(hdma);
240019bc:	f043 0301 	orr.w	r3, r3, #1
240019c0:	6023      	str	r3, [r4, #0]
}
240019c2:	bd70      	pop	{r4, r5, r6, pc}
    hdma->ErrorCode = HAL_DMA_ERROR_BUSY;
240019c4:	f44f 6300 	mov.w	r3, #2048	@ 0x800
    __HAL_UNLOCK(hdma);
240019c8:	f880 4034 	strb.w	r4, [r0, #52]	@ 0x34
    hdma->ErrorCode = HAL_DMA_ERROR_BUSY;
240019cc:	6543      	str	r3, [r0, #84]	@ 0x54
    return HAL_ERROR;
240019ce:	2001      	movs	r0, #1
240019d0:	e7f7      	b.n	240019c2 <HAL_DMA_Start+0xc6>
  __HAL_LOCK(hdma);
240019d2:	2002      	movs	r0, #2
240019d4:	e7f5      	b.n	240019c2 <HAL_DMA_Start+0xc6>
240019d6:	bf00      	nop
240019d8:	40020010 	.word	0x40020010
240019dc:	40020028 	.word	0x40020028

240019e0 <HAL_DMA_Start_IT>:
{
240019e0:	b570      	push	{r4, r5, r6, lr}
  if(hdma == NULL)
240019e2:	2800      	cmp	r0, #0
240019e4:	f000 810a 	beq.w	24001bfc <HAL_DMA_Start_IT+0x21c>
  __HAL_LOCK(hdma);
240019e8:	f890 4034 	ldrb.w	r4, [r0, #52]	@ 0x34
240019ec:	2c01      	cmp	r4, #1
240019ee:	f000 8107 	beq.w	24001c00 <HAL_DMA_Start_IT+0x220>
240019f2:	2401      	movs	r4, #1
240019f4:	f880 4034 	strb.w	r4, [r0, #52]	@ 0x34
  if(HAL_DMA_STATE_READY == hdma->State)
240019f8:	f890 4035 	ldrb.w	r4, [r0, #53]	@ 0x35
240019fc:	2c01      	cmp	r4, #1
240019fe:	f04f 0400 	mov.w	r4, #0
24001a02:	f040 80f6 	bne.w	24001bf2 <HAL_DMA_Start_IT+0x212>
    hdma->State = HAL_DMA_STATE_BUSY;
24001a06:	2502      	movs	r5, #2
24001a08:	f880 5035 	strb.w	r5, [r0, #53]	@ 0x35
    __HAL_DMA_DISABLE(hdma);
24001a0c:	4d7d      	ldr	r5, [pc, #500]	@ (24001c04 <HAL_DMA_Start_IT+0x224>)
    hdma->ErrorCode = HAL_DMA_ERROR_NONE;
24001a0e:	6544      	str	r4, [r0, #84]	@ 0x54
    __HAL_DMA_DISABLE(hdma);
24001a10:	6804      	ldr	r4, [r0, #0]
24001a12:	42ac      	cmp	r4, r5
24001a14:	d01e      	beq.n	24001a54 <HAL_DMA_Start_IT+0x74>
24001a16:	4e7c      	ldr	r6, [pc, #496]	@ (24001c08 <HAL_DMA_Start_IT+0x228>)
24001a18:	42b4      	cmp	r4, r6
24001a1a:	d01b      	beq.n	24001a54 <HAL_DMA_Start_IT+0x74>
24001a1c:	3618      	adds	r6, #24
24001a1e:	42b4      	cmp	r4, r6
24001a20:	d018      	beq.n	24001a54 <HAL_DMA_Start_IT+0x74>
24001a22:	3618      	adds	r6, #24
24001a24:	42b4      	cmp	r4, r6
24001a26:	d015      	beq.n	24001a54 <HAL_DMA_Start_IT+0x74>
24001a28:	3618      	adds	r6, #24
24001a2a:	42b4      	cmp	r4, r6
24001a2c:	d012      	beq.n	24001a54 <HAL_DMA_Start_IT+0x74>
24001a2e:	3618      	adds	r6, #24
24001a30:	42b4      	cmp	r4, r6
24001a32:	d00f      	beq.n	24001a54 <HAL_DMA_Start_IT+0x74>
24001a34:	3618      	adds	r6, #24
24001a36:	42b4      	cmp	r4, r6
24001a38:	d00c      	beq.n	24001a54 <HAL_DMA_Start_IT+0x74>
24001a3a:	3618      	adds	r6, #24
24001a3c:	42b4      	cmp	r4, r6
24001a3e:	d009      	beq.n	24001a54 <HAL_DMA_Start_IT+0x74>
24001a40:	f506 7656 	add.w	r6, r6, #856	@ 0x358
24001a44:	42b4      	cmp	r4, r6
24001a46:	d005      	beq.n	24001a54 <HAL_DMA_Start_IT+0x74>
24001a48:	3618      	adds	r6, #24
24001a4a:	42b4      	cmp	r4, r6
24001a4c:	d002      	beq.n	24001a54 <HAL_DMA_Start_IT+0x74>
24001a4e:	3618      	adds	r6, #24
24001a50:	42b4      	cmp	r4, r6
24001a52:	d0ff      	beq.n	24001a54 <HAL_DMA_Start_IT+0x74>
24001a54:	6826      	ldr	r6, [r4, #0]
24001a56:	f026 0601 	bic.w	r6, r6, #1
24001a5a:	6026      	str	r6, [r4, #0]
    DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength);
24001a5c:	f7ff fab8 	bl	24000fd0 <DMA_SetConfig>
    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
24001a60:	42ac      	cmp	r4, r5
24001a62:	6c02      	ldr	r2, [r0, #64]	@ 0x40
24001a64:	d053      	beq.n	24001b0e <HAL_DMA_Start_IT+0x12e>
24001a66:	4b68      	ldr	r3, [pc, #416]	@ (24001c08 <HAL_DMA_Start_IT+0x228>)
24001a68:	429c      	cmp	r4, r3
24001a6a:	d050      	beq.n	24001b0e <HAL_DMA_Start_IT+0x12e>
24001a6c:	3318      	adds	r3, #24
24001a6e:	429c      	cmp	r4, r3
24001a70:	d04d      	beq.n	24001b0e <HAL_DMA_Start_IT+0x12e>
24001a72:	3318      	adds	r3, #24
24001a74:	429c      	cmp	r4, r3
24001a76:	d04a      	beq.n	24001b0e <HAL_DMA_Start_IT+0x12e>
24001a78:	3318      	adds	r3, #24
24001a7a:	429c      	cmp	r4, r3
24001a7c:	d047      	beq.n	24001b0e <HAL_DMA_Start_IT+0x12e>
24001a7e:	3318      	adds	r3, #24
24001a80:	429c      	cmp	r4, r3
24001a82:	d044      	beq.n	24001b0e <HAL_DMA_Start_IT+0x12e>
24001a84:	3318      	adds	r3, #24
24001a86:	429c      	cmp	r4, r3
24001a88:	d041      	beq.n	24001b0e <HAL_DMA_Start_IT+0x12e>
24001a8a:	3318      	adds	r3, #24
24001a8c:	429c      	cmp	r4, r3
24001a8e:	d03e      	beq.n	24001b0e <HAL_DMA_Start_IT+0x12e>
24001a90:	f503 7356 	add.w	r3, r3, #856	@ 0x358
24001a94:	429c      	cmp	r4, r3
24001a96:	d03a      	beq.n	24001b0e <HAL_DMA_Start_IT+0x12e>
24001a98:	3318      	adds	r3, #24
24001a9a:	429c      	cmp	r4, r3
24001a9c:	d037      	beq.n	24001b0e <HAL_DMA_Start_IT+0x12e>
24001a9e:	3318      	adds	r3, #24
24001aa0:	429c      	cmp	r4, r3
24001aa2:	d034      	beq.n	24001b0e <HAL_DMA_Start_IT+0x12e>
24001aa4:	3318      	adds	r3, #24
24001aa6:	429c      	cmp	r4, r3
24001aa8:	d031      	beq.n	24001b0e <HAL_DMA_Start_IT+0x12e>
24001aaa:	3318      	adds	r3, #24
24001aac:	429c      	cmp	r4, r3
24001aae:	d02e      	beq.n	24001b0e <HAL_DMA_Start_IT+0x12e>
24001ab0:	3318      	adds	r3, #24
24001ab2:	429c      	cmp	r4, r3
24001ab4:	d02b      	beq.n	24001b0e <HAL_DMA_Start_IT+0x12e>
24001ab6:	3318      	adds	r3, #24
24001ab8:	429c      	cmp	r4, r3
24001aba:	d028      	beq.n	24001b0e <HAL_DMA_Start_IT+0x12e>
24001abc:	3318      	adds	r3, #24
24001abe:	429c      	cmp	r4, r3
24001ac0:	d025      	beq.n	24001b0e <HAL_DMA_Start_IT+0x12e>
      MODIFY_REG(((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR, (BDMA_CCR_TCIE | BDMA_CCR_HTIE | BDMA_CCR_TEIE), (BDMA_CCR_TCIE | BDMA_CCR_TEIE));
24001ac2:	6823      	ldr	r3, [r4, #0]
24001ac4:	f023 030e 	bic.w	r3, r3, #14
24001ac8:	f043 030a 	orr.w	r3, r3, #10
24001acc:	6023      	str	r3, [r4, #0]
      if(hdma->XferHalfCpltCallback != NULL)
24001ace:	2a00      	cmp	r2, #0
24001ad0:	d156      	bne.n	24001b80 <HAL_DMA_Start_IT+0x1a0>
    if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
24001ad2:	4b4e      	ldr	r3, [pc, #312]	@ (24001c0c <HAL_DMA_Start_IT+0x22c>)
24001ad4:	429c      	cmp	r4, r3
24001ad6:	d027      	beq.n	24001b28 <HAL_DMA_Start_IT+0x148>
24001ad8:	4b4d      	ldr	r3, [pc, #308]	@ (24001c10 <HAL_DMA_Start_IT+0x230>)
24001ada:	429c      	cmp	r4, r3
24001adc:	d024      	beq.n	24001b28 <HAL_DMA_Start_IT+0x148>
24001ade:	3314      	adds	r3, #20
24001ae0:	429c      	cmp	r4, r3
24001ae2:	d021      	beq.n	24001b28 <HAL_DMA_Start_IT+0x148>
24001ae4:	3314      	adds	r3, #20
24001ae6:	429c      	cmp	r4, r3
24001ae8:	d01e      	beq.n	24001b28 <HAL_DMA_Start_IT+0x148>
24001aea:	3314      	adds	r3, #20
24001aec:	429c      	cmp	r4, r3
24001aee:	d01b      	beq.n	24001b28 <HAL_DMA_Start_IT+0x148>
24001af0:	3314      	adds	r3, #20
24001af2:	429c      	cmp	r4, r3
24001af4:	d018      	beq.n	24001b28 <HAL_DMA_Start_IT+0x148>
24001af6:	3314      	adds	r3, #20
24001af8:	429c      	cmp	r4, r3
24001afa:	d015      	beq.n	24001b28 <HAL_DMA_Start_IT+0x148>
24001afc:	3314      	adds	r3, #20
24001afe:	429c      	cmp	r4, r3
24001b00:	d012      	beq.n	24001b28 <HAL_DMA_Start_IT+0x148>
    __HAL_DMA_ENABLE(hdma);
24001b02:	6823      	ldr	r3, [r4, #0]
  HAL_StatusTypeDef status = HAL_OK;
24001b04:	2000      	movs	r0, #0
    __HAL_DMA_ENABLE(hdma);
24001b06:	f043 0301 	orr.w	r3, r3, #1
24001b0a:	6023      	str	r3, [r4, #0]
}
24001b0c:	bd70      	pop	{r4, r5, r6, pc}
      MODIFY_REG(((DMA_Stream_TypeDef   *)hdma->Instance)->CR, (DMA_IT_TC | DMA_IT_TE | DMA_IT_DME | DMA_IT_HT), (DMA_IT_TC | DMA_IT_TE | DMA_IT_DME));
24001b0e:	6823      	ldr	r3, [r4, #0]
24001b10:	f023 031e 	bic.w	r3, r3, #30
24001b14:	f043 0316 	orr.w	r3, r3, #22
24001b18:	6023      	str	r3, [r4, #0]
      if(hdma->XferHalfCpltCallback != NULL)
24001b1a:	b11a      	cbz	r2, 24001b24 <HAL_DMA_Start_IT+0x144>
        ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  |= DMA_IT_HT;
24001b1c:	6823      	ldr	r3, [r4, #0]
24001b1e:	f043 0308 	orr.w	r3, r3, #8
24001b22:	6023      	str	r3, [r4, #0]
    if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
24001b24:	42ac      	cmp	r4, r5
24001b26:	d130      	bne.n	24001b8a <HAL_DMA_Start_IT+0x1aa>
      if((hdma->DMAmuxChannel->CCR & DMAMUX_CxCR_SE) != 0U)
24001b28:	6e03      	ldr	r3, [r0, #96]	@ 0x60
24001b2a:	681a      	ldr	r2, [r3, #0]
24001b2c:	03d2      	lsls	r2, r2, #15
24001b2e:	d45b      	bmi.n	24001be8 <HAL_DMA_Start_IT+0x208>
      if(hdma->DMAmuxRequestGen != 0U)
24001b30:	6ec3      	ldr	r3, [r0, #108]	@ 0x6c
24001b32:	b11b      	cbz	r3, 24001b3c <HAL_DMA_Start_IT+0x15c>
        hdma->DMAmuxRequestGen->RGCR |= DMAMUX_RGxCR_OIE;
24001b34:	681a      	ldr	r2, [r3, #0]
24001b36:	f442 7280 	orr.w	r2, r2, #256	@ 0x100
24001b3a:	601a      	str	r2, [r3, #0]
    __HAL_DMA_ENABLE(hdma);
24001b3c:	42ac      	cmp	r4, r5
24001b3e:	d0e0      	beq.n	24001b02 <HAL_DMA_Start_IT+0x122>
24001b40:	4b31      	ldr	r3, [pc, #196]	@ (24001c08 <HAL_DMA_Start_IT+0x228>)
24001b42:	429c      	cmp	r4, r3
24001b44:	d0dd      	beq.n	24001b02 <HAL_DMA_Start_IT+0x122>
24001b46:	3318      	adds	r3, #24
24001b48:	429c      	cmp	r4, r3
24001b4a:	d0da      	beq.n	24001b02 <HAL_DMA_Start_IT+0x122>
24001b4c:	3318      	adds	r3, #24
24001b4e:	429c      	cmp	r4, r3
24001b50:	d0d7      	beq.n	24001b02 <HAL_DMA_Start_IT+0x122>
24001b52:	3318      	adds	r3, #24
24001b54:	429c      	cmp	r4, r3
24001b56:	d0d4      	beq.n	24001b02 <HAL_DMA_Start_IT+0x122>
24001b58:	3318      	adds	r3, #24
24001b5a:	429c      	cmp	r4, r3
24001b5c:	d0d1      	beq.n	24001b02 <HAL_DMA_Start_IT+0x122>
24001b5e:	3318      	adds	r3, #24
24001b60:	429c      	cmp	r4, r3
24001b62:	d0ce      	beq.n	24001b02 <HAL_DMA_Start_IT+0x122>
24001b64:	3318      	adds	r3, #24
24001b66:	429c      	cmp	r4, r3
24001b68:	d0cb      	beq.n	24001b02 <HAL_DMA_Start_IT+0x122>
24001b6a:	f503 7356 	add.w	r3, r3, #856	@ 0x358
24001b6e:	429c      	cmp	r4, r3
24001b70:	d0c7      	beq.n	24001b02 <HAL_DMA_Start_IT+0x122>
24001b72:	3318      	adds	r3, #24
24001b74:	429c      	cmp	r4, r3
24001b76:	d0c4      	beq.n	24001b02 <HAL_DMA_Start_IT+0x122>
24001b78:	3318      	adds	r3, #24
24001b7a:	429c      	cmp	r4, r3
24001b7c:	d0c1      	beq.n	24001b02 <HAL_DMA_Start_IT+0x122>
24001b7e:	e7c0      	b.n	24001b02 <HAL_DMA_Start_IT+0x122>
        ((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR  |= BDMA_CCR_HTIE;
24001b80:	6823      	ldr	r3, [r4, #0]
24001b82:	f043 0304 	orr.w	r3, r3, #4
24001b86:	6023      	str	r3, [r4, #0]
24001b88:	e7a3      	b.n	24001ad2 <HAL_DMA_Start_IT+0xf2>
    if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
24001b8a:	4b1f      	ldr	r3, [pc, #124]	@ (24001c08 <HAL_DMA_Start_IT+0x228>)
24001b8c:	429c      	cmp	r4, r3
24001b8e:	d0cb      	beq.n	24001b28 <HAL_DMA_Start_IT+0x148>
24001b90:	3318      	adds	r3, #24
24001b92:	429c      	cmp	r4, r3
24001b94:	d0c8      	beq.n	24001b28 <HAL_DMA_Start_IT+0x148>
24001b96:	3318      	adds	r3, #24
24001b98:	429c      	cmp	r4, r3
24001b9a:	d0c5      	beq.n	24001b28 <HAL_DMA_Start_IT+0x148>
24001b9c:	3318      	adds	r3, #24
24001b9e:	429c      	cmp	r4, r3
24001ba0:	d0c2      	beq.n	24001b28 <HAL_DMA_Start_IT+0x148>
24001ba2:	3318      	adds	r3, #24
24001ba4:	429c      	cmp	r4, r3
24001ba6:	d0bf      	beq.n	24001b28 <HAL_DMA_Start_IT+0x148>
24001ba8:	3318      	adds	r3, #24
24001baa:	429c      	cmp	r4, r3
24001bac:	d0bc      	beq.n	24001b28 <HAL_DMA_Start_IT+0x148>
24001bae:	3318      	adds	r3, #24
24001bb0:	429c      	cmp	r4, r3
24001bb2:	d0b9      	beq.n	24001b28 <HAL_DMA_Start_IT+0x148>
24001bb4:	f503 7356 	add.w	r3, r3, #856	@ 0x358
24001bb8:	429c      	cmp	r4, r3
24001bba:	d0b5      	beq.n	24001b28 <HAL_DMA_Start_IT+0x148>
24001bbc:	3318      	adds	r3, #24
24001bbe:	429c      	cmp	r4, r3
24001bc0:	d0b2      	beq.n	24001b28 <HAL_DMA_Start_IT+0x148>
24001bc2:	3318      	adds	r3, #24
24001bc4:	429c      	cmp	r4, r3
24001bc6:	d0af      	beq.n	24001b28 <HAL_DMA_Start_IT+0x148>
24001bc8:	3318      	adds	r3, #24
24001bca:	429c      	cmp	r4, r3
24001bcc:	d0ac      	beq.n	24001b28 <HAL_DMA_Start_IT+0x148>
24001bce:	3318      	adds	r3, #24
24001bd0:	429c      	cmp	r4, r3
24001bd2:	d0a9      	beq.n	24001b28 <HAL_DMA_Start_IT+0x148>
24001bd4:	3318      	adds	r3, #24
24001bd6:	429c      	cmp	r4, r3
24001bd8:	d0a6      	beq.n	24001b28 <HAL_DMA_Start_IT+0x148>
24001bda:	3318      	adds	r3, #24
24001bdc:	429c      	cmp	r4, r3
24001bde:	d0a3      	beq.n	24001b28 <HAL_DMA_Start_IT+0x148>
24001be0:	3318      	adds	r3, #24
24001be2:	429c      	cmp	r4, r3
24001be4:	d0a0      	beq.n	24001b28 <HAL_DMA_Start_IT+0x148>
24001be6:	e774      	b.n	24001ad2 <HAL_DMA_Start_IT+0xf2>
        hdma->DMAmuxChannel->CCR |= DMAMUX_CxCR_SOIE;
24001be8:	681a      	ldr	r2, [r3, #0]
24001bea:	f442 7280 	orr.w	r2, r2, #256	@ 0x100
24001bee:	601a      	str	r2, [r3, #0]
24001bf0:	e79e      	b.n	24001b30 <HAL_DMA_Start_IT+0x150>
    hdma->ErrorCode = HAL_DMA_ERROR_BUSY;
24001bf2:	f44f 6300 	mov.w	r3, #2048	@ 0x800
    __HAL_UNLOCK(hdma);
24001bf6:	f880 4034 	strb.w	r4, [r0, #52]	@ 0x34
    hdma->ErrorCode = HAL_DMA_ERROR_BUSY;
24001bfa:	6543      	str	r3, [r0, #84]	@ 0x54
    return HAL_ERROR;
24001bfc:	2001      	movs	r0, #1
24001bfe:	e785      	b.n	24001b0c <HAL_DMA_Start_IT+0x12c>
  __HAL_LOCK(hdma);
24001c00:	2002      	movs	r0, #2
24001c02:	e783      	b.n	24001b0c <HAL_DMA_Start_IT+0x12c>
24001c04:	40020010 	.word	0x40020010
24001c08:	40020028 	.word	0x40020028
24001c0c:	58025408 	.word	0x58025408
24001c10:	5802541c 	.word	0x5802541c

24001c14 <HAL_DMA_Abort>:
{
24001c14:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
24001c16:	4605      	mov	r5, r0
  uint32_t tickstart = HAL_GetTick();
24001c18:	f010 f8f6 	bl	24011e08 <HAL_GetTick>
24001c1c:	4607      	mov	r7, r0
  if(hdma == NULL)
24001c1e:	b145      	cbz	r5, 24001c32 <HAL_DMA_Abort+0x1e>
  if(hdma->State != HAL_DMA_STATE_BUSY)
24001c20:	f895 3035 	ldrb.w	r3, [r5, #53]	@ 0x35
24001c24:	2b02      	cmp	r3, #2
24001c26:	d006      	beq.n	24001c36 <HAL_DMA_Abort+0x22>
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
24001c28:	2380      	movs	r3, #128	@ 0x80
24001c2a:	656b      	str	r3, [r5, #84]	@ 0x54
    __HAL_UNLOCK(hdma);
24001c2c:	2300      	movs	r3, #0
24001c2e:	f885 3034 	strb.w	r3, [r5, #52]	@ 0x34
    return HAL_ERROR;
24001c32:	2001      	movs	r0, #1
}
24001c34:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
24001c36:	682c      	ldr	r4, [r5, #0]
24001c38:	4eac      	ldr	r6, [pc, #688]	@ (24001eec <HAL_DMA_Abort+0x2d8>)
24001c3a:	42b4      	cmp	r4, r6
24001c3c:	d04a      	beq.n	24001cd4 <HAL_DMA_Abort+0xc0>
24001c3e:	4bac      	ldr	r3, [pc, #688]	@ (24001ef0 <HAL_DMA_Abort+0x2dc>)
24001c40:	429c      	cmp	r4, r3
24001c42:	d047      	beq.n	24001cd4 <HAL_DMA_Abort+0xc0>
24001c44:	3318      	adds	r3, #24
24001c46:	429c      	cmp	r4, r3
24001c48:	d044      	beq.n	24001cd4 <HAL_DMA_Abort+0xc0>
24001c4a:	3318      	adds	r3, #24
24001c4c:	429c      	cmp	r4, r3
24001c4e:	d041      	beq.n	24001cd4 <HAL_DMA_Abort+0xc0>
24001c50:	3318      	adds	r3, #24
24001c52:	429c      	cmp	r4, r3
24001c54:	d03e      	beq.n	24001cd4 <HAL_DMA_Abort+0xc0>
24001c56:	3318      	adds	r3, #24
24001c58:	429c      	cmp	r4, r3
24001c5a:	d03b      	beq.n	24001cd4 <HAL_DMA_Abort+0xc0>
24001c5c:	3318      	adds	r3, #24
24001c5e:	429c      	cmp	r4, r3
24001c60:	d038      	beq.n	24001cd4 <HAL_DMA_Abort+0xc0>
24001c62:	3318      	adds	r3, #24
24001c64:	429c      	cmp	r4, r3
24001c66:	d035      	beq.n	24001cd4 <HAL_DMA_Abort+0xc0>
24001c68:	f503 7356 	add.w	r3, r3, #856	@ 0x358
24001c6c:	429c      	cmp	r4, r3
24001c6e:	d031      	beq.n	24001cd4 <HAL_DMA_Abort+0xc0>
24001c70:	3318      	adds	r3, #24
24001c72:	429c      	cmp	r4, r3
24001c74:	d02e      	beq.n	24001cd4 <HAL_DMA_Abort+0xc0>
24001c76:	3318      	adds	r3, #24
24001c78:	429c      	cmp	r4, r3
24001c7a:	d02b      	beq.n	24001cd4 <HAL_DMA_Abort+0xc0>
24001c7c:	3318      	adds	r3, #24
24001c7e:	429c      	cmp	r4, r3
24001c80:	d028      	beq.n	24001cd4 <HAL_DMA_Abort+0xc0>
24001c82:	3318      	adds	r3, #24
24001c84:	429c      	cmp	r4, r3
24001c86:	d025      	beq.n	24001cd4 <HAL_DMA_Abort+0xc0>
24001c88:	3318      	adds	r3, #24
24001c8a:	429c      	cmp	r4, r3
24001c8c:	d022      	beq.n	24001cd4 <HAL_DMA_Abort+0xc0>
24001c8e:	3318      	adds	r3, #24
24001c90:	429c      	cmp	r4, r3
24001c92:	d01f      	beq.n	24001cd4 <HAL_DMA_Abort+0xc0>
24001c94:	3318      	adds	r3, #24
24001c96:	429c      	cmp	r4, r3
24001c98:	d01c      	beq.n	24001cd4 <HAL_DMA_Abort+0xc0>
      ((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR  &= ~(BDMA_CCR_TCIE | BDMA_CCR_HTIE | BDMA_CCR_TEIE);
24001c9a:	6823      	ldr	r3, [r4, #0]
24001c9c:	f023 030e 	bic.w	r3, r3, #14
24001ca0:	6023      	str	r3, [r4, #0]
    if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
24001ca2:	4b94      	ldr	r3, [pc, #592]	@ (24001ef4 <HAL_DMA_Abort+0x2e0>)
24001ca4:	429c      	cmp	r4, r3
24001ca6:	d01f      	beq.n	24001ce8 <HAL_DMA_Abort+0xd4>
24001ca8:	3314      	adds	r3, #20
24001caa:	429c      	cmp	r4, r3
24001cac:	d01c      	beq.n	24001ce8 <HAL_DMA_Abort+0xd4>
24001cae:	3314      	adds	r3, #20
24001cb0:	429c      	cmp	r4, r3
24001cb2:	d019      	beq.n	24001ce8 <HAL_DMA_Abort+0xd4>
24001cb4:	3314      	adds	r3, #20
24001cb6:	429c      	cmp	r4, r3
24001cb8:	d016      	beq.n	24001ce8 <HAL_DMA_Abort+0xd4>
24001cba:	3314      	adds	r3, #20
24001cbc:	429c      	cmp	r4, r3
24001cbe:	d013      	beq.n	24001ce8 <HAL_DMA_Abort+0xd4>
24001cc0:	3314      	adds	r3, #20
24001cc2:	429c      	cmp	r4, r3
24001cc4:	d010      	beq.n	24001ce8 <HAL_DMA_Abort+0xd4>
24001cc6:	3314      	adds	r3, #20
24001cc8:	429c      	cmp	r4, r3
24001cca:	d00d      	beq.n	24001ce8 <HAL_DMA_Abort+0xd4>
24001ccc:	3314      	adds	r3, #20
24001cce:	429c      	cmp	r4, r3
24001cd0:	d112      	bne.n	24001cf8 <HAL_DMA_Abort+0xe4>
24001cd2:	e009      	b.n	24001ce8 <HAL_DMA_Abort+0xd4>
      ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME | DMA_IT_HT);
24001cd4:	6823      	ldr	r3, [r4, #0]
    if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
24001cd6:	42b4      	cmp	r4, r6
      ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME | DMA_IT_HT);
24001cd8:	f023 031e 	bic.w	r3, r3, #30
24001cdc:	6023      	str	r3, [r4, #0]
      ((DMA_Stream_TypeDef   *)hdma->Instance)->FCR &= ~(DMA_IT_FE);
24001cde:	6963      	ldr	r3, [r4, #20]
24001ce0:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
24001ce4:	6163      	str	r3, [r4, #20]
    if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
24001ce6:	d178      	bne.n	24001dda <HAL_DMA_Abort+0x1c6>
      hdma->DMAmuxChannel->CCR &= ~DMAMUX_CxCR_SOIE;
24001ce8:	6e2a      	ldr	r2, [r5, #96]	@ 0x60
    __HAL_DMA_DISABLE(hdma);
24001cea:	42b4      	cmp	r4, r6
      hdma->DMAmuxChannel->CCR &= ~DMAMUX_CxCR_SOIE;
24001cec:	6813      	ldr	r3, [r2, #0]
24001cee:	f423 7380 	bic.w	r3, r3, #256	@ 0x100
24001cf2:	6013      	str	r3, [r2, #0]
    __HAL_DMA_DISABLE(hdma);
24001cf4:	f040 80ad 	bne.w	24001e52 <HAL_DMA_Abort+0x23e>
24001cf8:	6823      	ldr	r3, [r4, #0]
24001cfa:	f023 0301 	bic.w	r3, r3, #1
24001cfe:	6023      	str	r3, [r4, #0]
    while(((*enableRegister) & DMA_SxCR_EN) != 0U)
24001d00:	6823      	ldr	r3, [r4, #0]
24001d02:	07db      	lsls	r3, r3, #31
24001d04:	f100 80cf 	bmi.w	24001ea6 <HAL_DMA_Abort+0x292>
    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
24001d08:	682b      	ldr	r3, [r5, #0]
      regs_bdma->IFCR = ((BDMA_IFCR_CGIF0) << (hdma->StreamIndex & 0x1FU));
24001d0a:	6dea      	ldr	r2, [r5, #92]	@ 0x5c
    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
24001d0c:	42b3      	cmp	r3, r6
      regs_bdma = (BDMA_Base_Registers *)hdma->StreamBaseAddress;
24001d0e:	6da8      	ldr	r0, [r5, #88]	@ 0x58
      regs_bdma->IFCR = ((BDMA_IFCR_CGIF0) << (hdma->StreamIndex & 0x1FU));
24001d10:	f002 021f 	and.w	r2, r2, #31
    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
24001d14:	f000 80d6 	beq.w	24001ec4 <HAL_DMA_Abort+0x2b0>
24001d18:	4975      	ldr	r1, [pc, #468]	@ (24001ef0 <HAL_DMA_Abort+0x2dc>)
24001d1a:	428b      	cmp	r3, r1
24001d1c:	f000 80d2 	beq.w	24001ec4 <HAL_DMA_Abort+0x2b0>
24001d20:	3118      	adds	r1, #24
24001d22:	428b      	cmp	r3, r1
24001d24:	f000 80ce 	beq.w	24001ec4 <HAL_DMA_Abort+0x2b0>
24001d28:	3118      	adds	r1, #24
24001d2a:	428b      	cmp	r3, r1
24001d2c:	f000 80ca 	beq.w	24001ec4 <HAL_DMA_Abort+0x2b0>
24001d30:	3118      	adds	r1, #24
24001d32:	428b      	cmp	r3, r1
24001d34:	f000 80c6 	beq.w	24001ec4 <HAL_DMA_Abort+0x2b0>
24001d38:	3118      	adds	r1, #24
24001d3a:	428b      	cmp	r3, r1
24001d3c:	f000 80c2 	beq.w	24001ec4 <HAL_DMA_Abort+0x2b0>
24001d40:	3118      	adds	r1, #24
24001d42:	428b      	cmp	r3, r1
24001d44:	f000 80be 	beq.w	24001ec4 <HAL_DMA_Abort+0x2b0>
24001d48:	3118      	adds	r1, #24
24001d4a:	428b      	cmp	r3, r1
24001d4c:	f000 80ba 	beq.w	24001ec4 <HAL_DMA_Abort+0x2b0>
24001d50:	f501 7156 	add.w	r1, r1, #856	@ 0x358
24001d54:	428b      	cmp	r3, r1
24001d56:	f000 80b5 	beq.w	24001ec4 <HAL_DMA_Abort+0x2b0>
24001d5a:	3118      	adds	r1, #24
24001d5c:	428b      	cmp	r3, r1
24001d5e:	f000 80b1 	beq.w	24001ec4 <HAL_DMA_Abort+0x2b0>
24001d62:	3118      	adds	r1, #24
24001d64:	428b      	cmp	r3, r1
24001d66:	f000 80ad 	beq.w	24001ec4 <HAL_DMA_Abort+0x2b0>
24001d6a:	3118      	adds	r1, #24
24001d6c:	428b      	cmp	r3, r1
24001d6e:	f000 80a9 	beq.w	24001ec4 <HAL_DMA_Abort+0x2b0>
24001d72:	3118      	adds	r1, #24
24001d74:	428b      	cmp	r3, r1
24001d76:	f000 80a5 	beq.w	24001ec4 <HAL_DMA_Abort+0x2b0>
24001d7a:	3118      	adds	r1, #24
24001d7c:	428b      	cmp	r3, r1
24001d7e:	f000 80a1 	beq.w	24001ec4 <HAL_DMA_Abort+0x2b0>
24001d82:	3118      	adds	r1, #24
24001d84:	428b      	cmp	r3, r1
24001d86:	f000 809d 	beq.w	24001ec4 <HAL_DMA_Abort+0x2b0>
24001d8a:	3118      	adds	r1, #24
24001d8c:	428b      	cmp	r3, r1
24001d8e:	f000 8099 	beq.w	24001ec4 <HAL_DMA_Abort+0x2b0>
      regs_bdma->IFCR = ((BDMA_IFCR_CGIF0) << (hdma->StreamIndex & 0x1FU));
24001d92:	2101      	movs	r1, #1
24001d94:	fa01 f202 	lsl.w	r2, r1, r2
24001d98:	6042      	str	r2, [r0, #4]
    if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
24001d9a:	4a56      	ldr	r2, [pc, #344]	@ (24001ef4 <HAL_DMA_Abort+0x2e0>)
24001d9c:	4293      	cmp	r3, r2
24001d9e:	f000 8097 	beq.w	24001ed0 <HAL_DMA_Abort+0x2bc>
24001da2:	3214      	adds	r2, #20
24001da4:	4293      	cmp	r3, r2
24001da6:	f000 8093 	beq.w	24001ed0 <HAL_DMA_Abort+0x2bc>
24001daa:	3214      	adds	r2, #20
24001dac:	4293      	cmp	r3, r2
24001dae:	f000 808f 	beq.w	24001ed0 <HAL_DMA_Abort+0x2bc>
24001db2:	3214      	adds	r2, #20
24001db4:	4293      	cmp	r3, r2
24001db6:	f000 808b 	beq.w	24001ed0 <HAL_DMA_Abort+0x2bc>
24001dba:	3214      	adds	r2, #20
24001dbc:	4293      	cmp	r3, r2
24001dbe:	f000 8087 	beq.w	24001ed0 <HAL_DMA_Abort+0x2bc>
24001dc2:	3214      	adds	r2, #20
24001dc4:	4293      	cmp	r3, r2
24001dc6:	f000 8083 	beq.w	24001ed0 <HAL_DMA_Abort+0x2bc>
24001dca:	3214      	adds	r2, #20
24001dcc:	4293      	cmp	r3, r2
24001dce:	d07f      	beq.n	24001ed0 <HAL_DMA_Abort+0x2bc>
24001dd0:	3214      	adds	r2, #20
24001dd2:	4293      	cmp	r3, r2
24001dd4:	f040 8082 	bne.w	24001edc <HAL_DMA_Abort+0x2c8>
24001dd8:	e07a      	b.n	24001ed0 <HAL_DMA_Abort+0x2bc>
    if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
24001dda:	4b45      	ldr	r3, [pc, #276]	@ (24001ef0 <HAL_DMA_Abort+0x2dc>)
24001ddc:	429c      	cmp	r4, r3
24001dde:	d083      	beq.n	24001ce8 <HAL_DMA_Abort+0xd4>
24001de0:	3318      	adds	r3, #24
24001de2:	429c      	cmp	r4, r3
24001de4:	d080      	beq.n	24001ce8 <HAL_DMA_Abort+0xd4>
24001de6:	3318      	adds	r3, #24
24001de8:	429c      	cmp	r4, r3
24001dea:	f43f af7d 	beq.w	24001ce8 <HAL_DMA_Abort+0xd4>
24001dee:	3318      	adds	r3, #24
24001df0:	429c      	cmp	r4, r3
24001df2:	f43f af79 	beq.w	24001ce8 <HAL_DMA_Abort+0xd4>
24001df6:	3318      	adds	r3, #24
24001df8:	429c      	cmp	r4, r3
24001dfa:	f43f af75 	beq.w	24001ce8 <HAL_DMA_Abort+0xd4>
24001dfe:	3318      	adds	r3, #24
24001e00:	429c      	cmp	r4, r3
24001e02:	f43f af71 	beq.w	24001ce8 <HAL_DMA_Abort+0xd4>
24001e06:	3318      	adds	r3, #24
24001e08:	429c      	cmp	r4, r3
24001e0a:	f43f af6d 	beq.w	24001ce8 <HAL_DMA_Abort+0xd4>
24001e0e:	f503 7356 	add.w	r3, r3, #856	@ 0x358
24001e12:	429c      	cmp	r4, r3
24001e14:	f43f af68 	beq.w	24001ce8 <HAL_DMA_Abort+0xd4>
24001e18:	3318      	adds	r3, #24
24001e1a:	429c      	cmp	r4, r3
24001e1c:	f43f af64 	beq.w	24001ce8 <HAL_DMA_Abort+0xd4>
24001e20:	3318      	adds	r3, #24
24001e22:	429c      	cmp	r4, r3
24001e24:	f43f af60 	beq.w	24001ce8 <HAL_DMA_Abort+0xd4>
24001e28:	3318      	adds	r3, #24
24001e2a:	429c      	cmp	r4, r3
24001e2c:	f43f af5c 	beq.w	24001ce8 <HAL_DMA_Abort+0xd4>
24001e30:	3318      	adds	r3, #24
24001e32:	429c      	cmp	r4, r3
24001e34:	f43f af58 	beq.w	24001ce8 <HAL_DMA_Abort+0xd4>
24001e38:	3318      	adds	r3, #24
24001e3a:	429c      	cmp	r4, r3
24001e3c:	f43f af54 	beq.w	24001ce8 <HAL_DMA_Abort+0xd4>
24001e40:	3318      	adds	r3, #24
24001e42:	429c      	cmp	r4, r3
24001e44:	f43f af50 	beq.w	24001ce8 <HAL_DMA_Abort+0xd4>
24001e48:	3318      	adds	r3, #24
24001e4a:	429c      	cmp	r4, r3
24001e4c:	f43f af4c 	beq.w	24001ce8 <HAL_DMA_Abort+0xd4>
24001e50:	e727      	b.n	24001ca2 <HAL_DMA_Abort+0x8e>
    __HAL_DMA_DISABLE(hdma);
24001e52:	4b27      	ldr	r3, [pc, #156]	@ (24001ef0 <HAL_DMA_Abort+0x2dc>)
24001e54:	429c      	cmp	r4, r3
24001e56:	f43f af4f 	beq.w	24001cf8 <HAL_DMA_Abort+0xe4>
24001e5a:	3318      	adds	r3, #24
24001e5c:	429c      	cmp	r4, r3
24001e5e:	f43f af4b 	beq.w	24001cf8 <HAL_DMA_Abort+0xe4>
24001e62:	3318      	adds	r3, #24
24001e64:	429c      	cmp	r4, r3
24001e66:	f43f af47 	beq.w	24001cf8 <HAL_DMA_Abort+0xe4>
24001e6a:	3318      	adds	r3, #24
24001e6c:	429c      	cmp	r4, r3
24001e6e:	f43f af43 	beq.w	24001cf8 <HAL_DMA_Abort+0xe4>
24001e72:	3318      	adds	r3, #24
24001e74:	429c      	cmp	r4, r3
24001e76:	f43f af3f 	beq.w	24001cf8 <HAL_DMA_Abort+0xe4>
24001e7a:	3318      	adds	r3, #24
24001e7c:	429c      	cmp	r4, r3
24001e7e:	f43f af3b 	beq.w	24001cf8 <HAL_DMA_Abort+0xe4>
24001e82:	3318      	adds	r3, #24
24001e84:	429c      	cmp	r4, r3
24001e86:	f43f af37 	beq.w	24001cf8 <HAL_DMA_Abort+0xe4>
24001e8a:	f503 7356 	add.w	r3, r3, #856	@ 0x358
24001e8e:	429c      	cmp	r4, r3
24001e90:	f43f af32 	beq.w	24001cf8 <HAL_DMA_Abort+0xe4>
24001e94:	3318      	adds	r3, #24
24001e96:	429c      	cmp	r4, r3
24001e98:	f43f af2e 	beq.w	24001cf8 <HAL_DMA_Abort+0xe4>
24001e9c:	3318      	adds	r3, #24
24001e9e:	429c      	cmp	r4, r3
24001ea0:	f43f af2a 	beq.w	24001cf8 <HAL_DMA_Abort+0xe4>
24001ea4:	e728      	b.n	24001cf8 <HAL_DMA_Abort+0xe4>
      if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA_ABORT)
24001ea6:	f00f ffaf 	bl	24011e08 <HAL_GetTick>
24001eaa:	1bc0      	subs	r0, r0, r7
24001eac:	2805      	cmp	r0, #5
24001eae:	f67f af27 	bls.w	24001d00 <HAL_DMA_Abort+0xec>
        hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
24001eb2:	2320      	movs	r3, #32
24001eb4:	656b      	str	r3, [r5, #84]	@ 0x54
        __HAL_UNLOCK(hdma);
24001eb6:	2300      	movs	r3, #0
24001eb8:	f885 3034 	strb.w	r3, [r5, #52]	@ 0x34
        hdma->State = HAL_DMA_STATE_ERROR;
24001ebc:	2303      	movs	r3, #3
24001ebe:	f885 3035 	strb.w	r3, [r5, #53]	@ 0x35
        return HAL_ERROR;
24001ec2:	e6b6      	b.n	24001c32 <HAL_DMA_Abort+0x1e>
      regs_dma->IFCR = 0x3FUL << (hdma->StreamIndex & 0x1FU);
24001ec4:	213f      	movs	r1, #63	@ 0x3f
    if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
24001ec6:	42b3      	cmp	r3, r6
      regs_dma->IFCR = 0x3FUL << (hdma->StreamIndex & 0x1FU);
24001ec8:	fa01 f202 	lsl.w	r2, r1, r2
24001ecc:	6082      	str	r2, [r0, #8]
    if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
24001ece:	d113      	bne.n	24001ef8 <HAL_DMA_Abort+0x2e4>
      hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
24001ed0:	e9d5 3219 	ldrd	r3, r2, [r5, #100]	@ 0x64
24001ed4:	605a      	str	r2, [r3, #4]
      if(hdma->DMAmuxRequestGen != 0U)
24001ed6:	6eeb      	ldr	r3, [r5, #108]	@ 0x6c
24001ed8:	2b00      	cmp	r3, #0
24001eda:	d13c      	bne.n	24001f56 <HAL_DMA_Abort+0x342>
    __HAL_UNLOCK(hdma);
24001edc:	2000      	movs	r0, #0
    hdma->State = HAL_DMA_STATE_READY;
24001ede:	2301      	movs	r3, #1
    __HAL_UNLOCK(hdma);
24001ee0:	f885 0034 	strb.w	r0, [r5, #52]	@ 0x34
    hdma->State = HAL_DMA_STATE_READY;
24001ee4:	f885 3035 	strb.w	r3, [r5, #53]	@ 0x35
  return HAL_OK;
24001ee8:	e6a4      	b.n	24001c34 <HAL_DMA_Abort+0x20>
24001eea:	bf00      	nop
24001eec:	40020010 	.word	0x40020010
24001ef0:	40020028 	.word	0x40020028
24001ef4:	58025408 	.word	0x58025408
    if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
24001ef8:	4a1b      	ldr	r2, [pc, #108]	@ (24001f68 <HAL_DMA_Abort+0x354>)
24001efa:	4293      	cmp	r3, r2
24001efc:	d0e8      	beq.n	24001ed0 <HAL_DMA_Abort+0x2bc>
24001efe:	3218      	adds	r2, #24
24001f00:	4293      	cmp	r3, r2
24001f02:	d0e5      	beq.n	24001ed0 <HAL_DMA_Abort+0x2bc>
24001f04:	3218      	adds	r2, #24
24001f06:	4293      	cmp	r3, r2
24001f08:	d0e2      	beq.n	24001ed0 <HAL_DMA_Abort+0x2bc>
24001f0a:	3218      	adds	r2, #24
24001f0c:	4293      	cmp	r3, r2
24001f0e:	d0df      	beq.n	24001ed0 <HAL_DMA_Abort+0x2bc>
24001f10:	3218      	adds	r2, #24
24001f12:	4293      	cmp	r3, r2
24001f14:	d0dc      	beq.n	24001ed0 <HAL_DMA_Abort+0x2bc>
24001f16:	3218      	adds	r2, #24
24001f18:	4293      	cmp	r3, r2
24001f1a:	d0d9      	beq.n	24001ed0 <HAL_DMA_Abort+0x2bc>
24001f1c:	3218      	adds	r2, #24
24001f1e:	4293      	cmp	r3, r2
24001f20:	d0d6      	beq.n	24001ed0 <HAL_DMA_Abort+0x2bc>
24001f22:	f502 7256 	add.w	r2, r2, #856	@ 0x358
24001f26:	4293      	cmp	r3, r2
24001f28:	d0d2      	beq.n	24001ed0 <HAL_DMA_Abort+0x2bc>
24001f2a:	3218      	adds	r2, #24
24001f2c:	4293      	cmp	r3, r2
24001f2e:	d0cf      	beq.n	24001ed0 <HAL_DMA_Abort+0x2bc>
24001f30:	3218      	adds	r2, #24
24001f32:	4293      	cmp	r3, r2
24001f34:	d0cc      	beq.n	24001ed0 <HAL_DMA_Abort+0x2bc>
24001f36:	3218      	adds	r2, #24
24001f38:	4293      	cmp	r3, r2
24001f3a:	d0c9      	beq.n	24001ed0 <HAL_DMA_Abort+0x2bc>
24001f3c:	3218      	adds	r2, #24
24001f3e:	4293      	cmp	r3, r2
24001f40:	d0c6      	beq.n	24001ed0 <HAL_DMA_Abort+0x2bc>
24001f42:	3218      	adds	r2, #24
24001f44:	4293      	cmp	r3, r2
24001f46:	d0c3      	beq.n	24001ed0 <HAL_DMA_Abort+0x2bc>
24001f48:	3218      	adds	r2, #24
24001f4a:	4293      	cmp	r3, r2
24001f4c:	d0c0      	beq.n	24001ed0 <HAL_DMA_Abort+0x2bc>
24001f4e:	3218      	adds	r2, #24
24001f50:	4293      	cmp	r3, r2
24001f52:	d0bd      	beq.n	24001ed0 <HAL_DMA_Abort+0x2bc>
24001f54:	e721      	b.n	24001d9a <HAL_DMA_Abort+0x186>
        hdma->DMAmuxRequestGen->RGCR &= ~DMAMUX_RGxCR_OIE;
24001f56:	681a      	ldr	r2, [r3, #0]
24001f58:	f422 7280 	bic.w	r2, r2, #256	@ 0x100
24001f5c:	601a      	str	r2, [r3, #0]
        hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
24001f5e:	e9d5 321c 	ldrd	r3, r2, [r5, #112]	@ 0x70
24001f62:	605a      	str	r2, [r3, #4]
24001f64:	e7ba      	b.n	24001edc <HAL_DMA_Abort+0x2c8>
24001f66:	bf00      	nop
24001f68:	40020028 	.word	0x40020028

24001f6c <HAL_DMA_Abort_IT>:
{
24001f6c:	b508      	push	{r3, lr}
  if(hdma == NULL)
24001f6e:	b128      	cbz	r0, 24001f7c <HAL_DMA_Abort_IT+0x10>
  if(hdma->State != HAL_DMA_STATE_BUSY)
24001f70:	f890 3035 	ldrb.w	r3, [r0, #53]	@ 0x35
24001f74:	2b02      	cmp	r3, #2
24001f76:	d003      	beq.n	24001f80 <HAL_DMA_Abort_IT+0x14>
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
24001f78:	2380      	movs	r3, #128	@ 0x80
24001f7a:	6543      	str	r3, [r0, #84]	@ 0x54
    return HAL_ERROR;
24001f7c:	2001      	movs	r0, #1
24001f7e:	e05d      	b.n	2400203c <HAL_DMA_Abort_IT+0xd0>
    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
24001f80:	6803      	ldr	r3, [r0, #0]
24001f82:	4a3f      	ldr	r2, [pc, #252]	@ (24002080 <HAL_DMA_Abort_IT+0x114>)
24001f84:	4293      	cmp	r3, r2
24001f86:	d051      	beq.n	2400202c <HAL_DMA_Abort_IT+0xc0>
24001f88:	3218      	adds	r2, #24
24001f8a:	4293      	cmp	r3, r2
24001f8c:	d04e      	beq.n	2400202c <HAL_DMA_Abort_IT+0xc0>
24001f8e:	3218      	adds	r2, #24
24001f90:	4293      	cmp	r3, r2
24001f92:	d04b      	beq.n	2400202c <HAL_DMA_Abort_IT+0xc0>
24001f94:	3218      	adds	r2, #24
24001f96:	4293      	cmp	r3, r2
24001f98:	d048      	beq.n	2400202c <HAL_DMA_Abort_IT+0xc0>
24001f9a:	3218      	adds	r2, #24
24001f9c:	4293      	cmp	r3, r2
24001f9e:	d045      	beq.n	2400202c <HAL_DMA_Abort_IT+0xc0>
24001fa0:	3218      	adds	r2, #24
24001fa2:	4293      	cmp	r3, r2
24001fa4:	d042      	beq.n	2400202c <HAL_DMA_Abort_IT+0xc0>
24001fa6:	3218      	adds	r2, #24
24001fa8:	4293      	cmp	r3, r2
24001faa:	d03f      	beq.n	2400202c <HAL_DMA_Abort_IT+0xc0>
24001fac:	3218      	adds	r2, #24
24001fae:	4293      	cmp	r3, r2
24001fb0:	d03c      	beq.n	2400202c <HAL_DMA_Abort_IT+0xc0>
24001fb2:	f502 7256 	add.w	r2, r2, #856	@ 0x358
24001fb6:	4293      	cmp	r3, r2
24001fb8:	d038      	beq.n	2400202c <HAL_DMA_Abort_IT+0xc0>
24001fba:	3218      	adds	r2, #24
24001fbc:	4293      	cmp	r3, r2
24001fbe:	d035      	beq.n	2400202c <HAL_DMA_Abort_IT+0xc0>
24001fc0:	3218      	adds	r2, #24
24001fc2:	4293      	cmp	r3, r2
24001fc4:	d032      	beq.n	2400202c <HAL_DMA_Abort_IT+0xc0>
24001fc6:	3218      	adds	r2, #24
24001fc8:	4293      	cmp	r3, r2
24001fca:	d02f      	beq.n	2400202c <HAL_DMA_Abort_IT+0xc0>
24001fcc:	3218      	adds	r2, #24
24001fce:	4293      	cmp	r3, r2
24001fd0:	d02c      	beq.n	2400202c <HAL_DMA_Abort_IT+0xc0>
24001fd2:	3218      	adds	r2, #24
24001fd4:	4293      	cmp	r3, r2
24001fd6:	d029      	beq.n	2400202c <HAL_DMA_Abort_IT+0xc0>
24001fd8:	3218      	adds	r2, #24
24001fda:	4293      	cmp	r3, r2
24001fdc:	d026      	beq.n	2400202c <HAL_DMA_Abort_IT+0xc0>
24001fde:	3218      	adds	r2, #24
24001fe0:	4293      	cmp	r3, r2
24001fe2:	d023      	beq.n	2400202c <HAL_DMA_Abort_IT+0xc0>
      ((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR  &= ~(BDMA_CCR_TCIE | BDMA_CCR_HTIE | BDMA_CCR_TEIE);
24001fe4:	681a      	ldr	r2, [r3, #0]
24001fe6:	f022 020e 	bic.w	r2, r2, #14
24001fea:	601a      	str	r2, [r3, #0]
      __HAL_DMA_DISABLE(hdma);
24001fec:	681a      	ldr	r2, [r3, #0]
24001fee:	f022 0201 	bic.w	r2, r2, #1
24001ff2:	601a      	str	r2, [r3, #0]
      if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
24001ff4:	4a23      	ldr	r2, [pc, #140]	@ (24002084 <HAL_DMA_Abort_IT+0x118>)
24001ff6:	4293      	cmp	r3, r2
24001ff8:	d121      	bne.n	2400203e <HAL_DMA_Abort_IT+0xd2>
        hdma->DMAmuxChannel->CCR &= ~DMAMUX_CxCR_SOIE;
24001ffa:	6e02      	ldr	r2, [r0, #96]	@ 0x60
24001ffc:	6813      	ldr	r3, [r2, #0]
24001ffe:	f423 7380 	bic.w	r3, r3, #256	@ 0x100
24002002:	6013      	str	r3, [r2, #0]
        regs_bdma->IFCR = ((BDMA_IFCR_CGIF0) << (hdma->StreamIndex & 0x1FU));
24002004:	e9d0 1316 	ldrd	r1, r3, [r0, #88]	@ 0x58
24002008:	f003 021f 	and.w	r2, r3, #31
2400200c:	2301      	movs	r3, #1
2400200e:	4093      	lsls	r3, r2
24002010:	604b      	str	r3, [r1, #4]
        hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
24002012:	e9d0 3219 	ldrd	r3, r2, [r0, #100]	@ 0x64
24002016:	605a      	str	r2, [r3, #4]
        if(hdma->DMAmuxRequestGen != 0U)
24002018:	6ec3      	ldr	r3, [r0, #108]	@ 0x6c
2400201a:	b32b      	cbz	r3, 24002068 <HAL_DMA_Abort_IT+0xfc>
          hdma->DMAmuxRequestGen->RGCR &= ~DMAMUX_RGxCR_OIE;
2400201c:	681a      	ldr	r2, [r3, #0]
2400201e:	f422 7280 	bic.w	r2, r2, #256	@ 0x100
24002022:	601a      	str	r2, [r3, #0]
          hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
24002024:	e9d0 321c 	ldrd	r3, r2, [r0, #112]	@ 0x70
24002028:	605a      	str	r2, [r3, #4]
2400202a:	e01d      	b.n	24002068 <HAL_DMA_Abort_IT+0xfc>
      hdma->State = HAL_DMA_STATE_ABORT;
2400202c:	2204      	movs	r2, #4
2400202e:	f880 2035 	strb.w	r2, [r0, #53]	@ 0x35
      __HAL_DMA_DISABLE(hdma);
24002032:	681a      	ldr	r2, [r3, #0]
24002034:	f022 0201 	bic.w	r2, r2, #1
24002038:	601a      	str	r2, [r3, #0]
  return HAL_OK;
2400203a:	2000      	movs	r0, #0
}
2400203c:	bd08      	pop	{r3, pc}
      if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
2400203e:	4a12      	ldr	r2, [pc, #72]	@ (24002088 <HAL_DMA_Abort_IT+0x11c>)
24002040:	4293      	cmp	r3, r2
24002042:	d0da      	beq.n	24001ffa <HAL_DMA_Abort_IT+0x8e>
24002044:	3214      	adds	r2, #20
24002046:	4293      	cmp	r3, r2
24002048:	d0d7      	beq.n	24001ffa <HAL_DMA_Abort_IT+0x8e>
2400204a:	3214      	adds	r2, #20
2400204c:	4293      	cmp	r3, r2
2400204e:	d0d4      	beq.n	24001ffa <HAL_DMA_Abort_IT+0x8e>
24002050:	3214      	adds	r2, #20
24002052:	4293      	cmp	r3, r2
24002054:	d0d1      	beq.n	24001ffa <HAL_DMA_Abort_IT+0x8e>
24002056:	3214      	adds	r2, #20
24002058:	4293      	cmp	r3, r2
2400205a:	d0ce      	beq.n	24001ffa <HAL_DMA_Abort_IT+0x8e>
2400205c:	3214      	adds	r2, #20
2400205e:	4293      	cmp	r3, r2
24002060:	d0cb      	beq.n	24001ffa <HAL_DMA_Abort_IT+0x8e>
24002062:	3214      	adds	r2, #20
24002064:	4293      	cmp	r3, r2
24002066:	d0c8      	beq.n	24001ffa <HAL_DMA_Abort_IT+0x8e>
      __HAL_UNLOCK(hdma);
24002068:	2300      	movs	r3, #0
2400206a:	f880 3034 	strb.w	r3, [r0, #52]	@ 0x34
      hdma->State = HAL_DMA_STATE_READY;
2400206e:	2301      	movs	r3, #1
24002070:	f880 3035 	strb.w	r3, [r0, #53]	@ 0x35
      if(hdma->XferAbortCallback != NULL)
24002074:	6d03      	ldr	r3, [r0, #80]	@ 0x50
24002076:	2b00      	cmp	r3, #0
24002078:	d0df      	beq.n	2400203a <HAL_DMA_Abort_IT+0xce>
        hdma->XferAbortCallback(hdma);
2400207a:	4798      	blx	r3
2400207c:	e7dd      	b.n	2400203a <HAL_DMA_Abort_IT+0xce>
2400207e:	bf00      	nop
24002080:	40020010 	.word	0x40020010
24002084:	58025408 	.word	0x58025408
24002088:	5802541c 	.word	0x5802541c

2400208c <HAL_DMA_PollForTransfer>:
{
2400208c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
24002090:	4604      	mov	r4, r0
24002092:	4689      	mov	r9, r1
24002094:	4692      	mov	sl, r2
  uint32_t tickstart = HAL_GetTick();
24002096:	f00f feb7 	bl	24011e08 <HAL_GetTick>
2400209a:	4683      	mov	fp, r0
  if(hdma == NULL)
2400209c:	2c00      	cmp	r4, #0
2400209e:	d042      	beq.n	24002126 <HAL_DMA_PollForTransfer+0x9a>
  if(HAL_DMA_STATE_BUSY != hdma->State)
240020a0:	f894 3035 	ldrb.w	r3, [r4, #53]	@ 0x35
240020a4:	2b02      	cmp	r3, #2
240020a6:	d005      	beq.n	240020b4 <HAL_DMA_PollForTransfer+0x28>
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
240020a8:	2380      	movs	r3, #128	@ 0x80
240020aa:	6563      	str	r3, [r4, #84]	@ 0x54
        __HAL_UNLOCK(hdma);
240020ac:	2300      	movs	r3, #0
240020ae:	f884 3034 	strb.w	r3, [r4, #52]	@ 0x34
        return HAL_ERROR;
240020b2:	e038      	b.n	24002126 <HAL_DMA_PollForTransfer+0x9a>
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
240020b4:	6823      	ldr	r3, [r4, #0]
240020b6:	f8df 81f0 	ldr.w	r8, [pc, #496]	@ 240022a8 <HAL_DMA_PollForTransfer+0x21c>
240020ba:	4543      	cmp	r3, r8
240020bc:	d035      	beq.n	2400212a <HAL_DMA_PollForTransfer+0x9e>
240020be:	4a77      	ldr	r2, [pc, #476]	@ (2400229c <HAL_DMA_PollForTransfer+0x210>)
240020c0:	4293      	cmp	r3, r2
240020c2:	d032      	beq.n	2400212a <HAL_DMA_PollForTransfer+0x9e>
240020c4:	3218      	adds	r2, #24
240020c6:	4293      	cmp	r3, r2
240020c8:	d02f      	beq.n	2400212a <HAL_DMA_PollForTransfer+0x9e>
240020ca:	3218      	adds	r2, #24
240020cc:	4293      	cmp	r3, r2
240020ce:	d02c      	beq.n	2400212a <HAL_DMA_PollForTransfer+0x9e>
240020d0:	3218      	adds	r2, #24
240020d2:	4293      	cmp	r3, r2
240020d4:	d029      	beq.n	2400212a <HAL_DMA_PollForTransfer+0x9e>
240020d6:	3218      	adds	r2, #24
240020d8:	4293      	cmp	r3, r2
240020da:	d026      	beq.n	2400212a <HAL_DMA_PollForTransfer+0x9e>
240020dc:	3218      	adds	r2, #24
240020de:	4293      	cmp	r3, r2
240020e0:	d023      	beq.n	2400212a <HAL_DMA_PollForTransfer+0x9e>
240020e2:	3218      	adds	r2, #24
240020e4:	4293      	cmp	r3, r2
240020e6:	d020      	beq.n	2400212a <HAL_DMA_PollForTransfer+0x9e>
240020e8:	f502 7256 	add.w	r2, r2, #856	@ 0x358
240020ec:	4293      	cmp	r3, r2
240020ee:	d01c      	beq.n	2400212a <HAL_DMA_PollForTransfer+0x9e>
240020f0:	3218      	adds	r2, #24
240020f2:	4293      	cmp	r3, r2
240020f4:	d019      	beq.n	2400212a <HAL_DMA_PollForTransfer+0x9e>
240020f6:	3218      	adds	r2, #24
240020f8:	4293      	cmp	r3, r2
240020fa:	d016      	beq.n	2400212a <HAL_DMA_PollForTransfer+0x9e>
240020fc:	3218      	adds	r2, #24
240020fe:	4293      	cmp	r3, r2
24002100:	d013      	beq.n	2400212a <HAL_DMA_PollForTransfer+0x9e>
24002102:	3218      	adds	r2, #24
24002104:	4293      	cmp	r3, r2
24002106:	d010      	beq.n	2400212a <HAL_DMA_PollForTransfer+0x9e>
24002108:	3218      	adds	r2, #24
2400210a:	4293      	cmp	r3, r2
2400210c:	d00d      	beq.n	2400212a <HAL_DMA_PollForTransfer+0x9e>
2400210e:	3218      	adds	r2, #24
24002110:	4293      	cmp	r3, r2
24002112:	d00a      	beq.n	2400212a <HAL_DMA_PollForTransfer+0x9e>
24002114:	3218      	adds	r2, #24
24002116:	4293      	cmp	r3, r2
24002118:	d007      	beq.n	2400212a <HAL_DMA_PollForTransfer+0x9e>
    if ((((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR & BDMA_CCR_CIRC) != 0U)
2400211a:	681b      	ldr	r3, [r3, #0]
2400211c:	069a      	lsls	r2, r3, #26
2400211e:	d519      	bpl.n	24002154 <HAL_DMA_PollForTransfer+0xc8>
      hdma->ErrorCode = HAL_DMA_ERROR_NOT_SUPPORTED;
24002120:	f44f 7380 	mov.w	r3, #256	@ 0x100
24002124:	6563      	str	r3, [r4, #84]	@ 0x54
    return HAL_ERROR;
24002126:	2001      	movs	r0, #1
24002128:	e181      	b.n	2400242e <HAL_DMA_PollForTransfer+0x3a2>
    if ((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_CIRC) != 0U)
2400212a:	681b      	ldr	r3, [r3, #0]
2400212c:	05db      	lsls	r3, r3, #23
2400212e:	d4f7      	bmi.n	24002120 <HAL_DMA_PollForTransfer+0x94>
      cpltlevel_mask = DMA_FLAG_TCIF0_4 << (hdma->StreamIndex & 0x1FU);
24002130:	6de5      	ldr	r5, [r4, #92]	@ 0x5c
24002132:	f005 051f 	and.w	r5, r5, #31
    if(CompleteLevel == HAL_DMA_FULL_TRANSFER)
24002136:	f1b9 0f00 	cmp.w	r9, #0
2400213a:	d109      	bne.n	24002150 <HAL_DMA_PollForTransfer+0xc4>
      cpltlevel_mask = DMA_FLAG_TCIF0_4 << (hdma->StreamIndex & 0x1FU);
2400213c:	2320      	movs	r3, #32
    isr_reg  = &(((DMA_Base_Registers *)hdma->StreamBaseAddress)->ISR);
2400213e:	6da6      	ldr	r6, [r4, #88]	@ 0x58
      cpltlevel_mask = DMA_FLAG_HTIF0_4 << (hdma->StreamIndex & 0x1FU);
24002140:	fa03 f505 	lsl.w	r5, r3, r5
    ifcr_reg = &(((DMA_Base_Registers *)hdma->StreamBaseAddress)->IFCR);
24002144:	f106 0708 	add.w	r7, r6, #8
    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
24002148:	4b54      	ldr	r3, [pc, #336]	@ (2400229c <HAL_DMA_PollForTransfer+0x210>)
2400214a:	4a55      	ldr	r2, [pc, #340]	@ (240022a0 <HAL_DMA_PollForTransfer+0x214>)
2400214c:	4955      	ldr	r1, [pc, #340]	@ (240022a4 <HAL_DMA_PollForTransfer+0x218>)
2400214e:	e126      	b.n	2400239e <HAL_DMA_PollForTransfer+0x312>
      cpltlevel_mask = DMA_FLAG_HTIF0_4 << (hdma->StreamIndex & 0x1FU);
24002150:	2310      	movs	r3, #16
24002152:	e7f4      	b.n	2400213e <HAL_DMA_PollForTransfer+0xb2>
      cpltlevel_mask = BDMA_FLAG_TC0 << (hdma->StreamIndex & 0x1FU);
24002154:	6de5      	ldr	r5, [r4, #92]	@ 0x5c
24002156:	f005 051f 	and.w	r5, r5, #31
    if(CompleteLevel == HAL_DMA_FULL_TRANSFER)
2400215a:	f1b9 0f00 	cmp.w	r9, #0
2400215e:	d105      	bne.n	2400216c <HAL_DMA_PollForTransfer+0xe0>
      cpltlevel_mask = BDMA_FLAG_TC0 << (hdma->StreamIndex & 0x1FU);
24002160:	2302      	movs	r3, #2
    isr_reg  = &(((BDMA_Base_Registers *)hdma->StreamBaseAddress)->ISR);
24002162:	6da6      	ldr	r6, [r4, #88]	@ 0x58
      cpltlevel_mask = BDMA_FLAG_HT0 << (hdma->StreamIndex & 0x1FU);
24002164:	fa03 f505 	lsl.w	r5, r3, r5
    ifcr_reg = &(((BDMA_Base_Registers *)hdma->StreamBaseAddress)->IFCR);
24002168:	1d37      	adds	r7, r6, #4
2400216a:	e7ed      	b.n	24002148 <HAL_DMA_PollForTransfer+0xbc>
      cpltlevel_mask = BDMA_FLAG_HT0 << (hdma->StreamIndex & 0x1FU);
2400216c:	2304      	movs	r3, #4
2400216e:	e7f8      	b.n	24002162 <HAL_DMA_PollForTransfer+0xd6>
    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
24002170:	45c4      	cmp	ip, r8
24002172:	d044      	beq.n	240021fe <HAL_DMA_PollForTransfer+0x172>
24002174:	459c      	cmp	ip, r3
24002176:	d042      	beq.n	240021fe <HAL_DMA_PollForTransfer+0x172>
24002178:	4594      	cmp	ip, r2
2400217a:	d040      	beq.n	240021fe <HAL_DMA_PollForTransfer+0x172>
2400217c:	458c      	cmp	ip, r1
2400217e:	d03e      	beq.n	240021fe <HAL_DMA_PollForTransfer+0x172>
24002180:	f8df e128 	ldr.w	lr, [pc, #296]	@ 240022ac <HAL_DMA_PollForTransfer+0x220>
24002184:	45f4      	cmp	ip, lr
24002186:	d03a      	beq.n	240021fe <HAL_DMA_PollForTransfer+0x172>
24002188:	f10e 0e18 	add.w	lr, lr, #24
2400218c:	45f4      	cmp	ip, lr
2400218e:	d036      	beq.n	240021fe <HAL_DMA_PollForTransfer+0x172>
24002190:	f10e 0e18 	add.w	lr, lr, #24
24002194:	45f4      	cmp	ip, lr
24002196:	d032      	beq.n	240021fe <HAL_DMA_PollForTransfer+0x172>
24002198:	f10e 0e18 	add.w	lr, lr, #24
2400219c:	45f4      	cmp	ip, lr
2400219e:	d02e      	beq.n	240021fe <HAL_DMA_PollForTransfer+0x172>
240021a0:	f50e 7e56 	add.w	lr, lr, #856	@ 0x358
240021a4:	45f4      	cmp	ip, lr
240021a6:	d02a      	beq.n	240021fe <HAL_DMA_PollForTransfer+0x172>
240021a8:	f10e 0e18 	add.w	lr, lr, #24
240021ac:	45f4      	cmp	ip, lr
240021ae:	d026      	beq.n	240021fe <HAL_DMA_PollForTransfer+0x172>
240021b0:	f10e 0e18 	add.w	lr, lr, #24
240021b4:	45f4      	cmp	ip, lr
240021b6:	d022      	beq.n	240021fe <HAL_DMA_PollForTransfer+0x172>
240021b8:	f10e 0e18 	add.w	lr, lr, #24
240021bc:	45f4      	cmp	ip, lr
240021be:	d01e      	beq.n	240021fe <HAL_DMA_PollForTransfer+0x172>
240021c0:	f10e 0e18 	add.w	lr, lr, #24
240021c4:	45f4      	cmp	ip, lr
240021c6:	d01a      	beq.n	240021fe <HAL_DMA_PollForTransfer+0x172>
240021c8:	f10e 0e18 	add.w	lr, lr, #24
240021cc:	45f4      	cmp	ip, lr
240021ce:	d016      	beq.n	240021fe <HAL_DMA_PollForTransfer+0x172>
240021d0:	f10e 0e18 	add.w	lr, lr, #24
240021d4:	45f4      	cmp	ip, lr
240021d6:	d012      	beq.n	240021fe <HAL_DMA_PollForTransfer+0x172>
240021d8:	f10e 0e18 	add.w	lr, lr, #24
240021dc:	45f4      	cmp	ip, lr
240021de:	d00e      	beq.n	240021fe <HAL_DMA_PollForTransfer+0x172>
      if(((*isr_reg) & (BDMA_FLAG_TE0 << (hdma->StreamIndex & 0x1FU))) != 0U)
240021e0:	f04f 0c08 	mov.w	ip, #8
240021e4:	f8d6 e000 	ldr.w	lr, [r6]
240021e8:	fa0c fc00 	lsl.w	ip, ip, r0
240021ec:	ea1c 0f0e 	tst.w	ip, lr
240021f0:	d03f      	beq.n	24002272 <HAL_DMA_PollForTransfer+0x1e6>
        (*isr_reg) = ((BDMA_ISR_GIF0) << (hdma->StreamIndex & 0x1FU));
240021f2:	2301      	movs	r3, #1
240021f4:	fa03 f000 	lsl.w	r0, r3, r0
240021f8:	6030      	str	r0, [r6, #0]
        hdma->ErrorCode = HAL_DMA_ERROR_TE;
240021fa:	6563      	str	r3, [r4, #84]	@ 0x54
240021fc:	e036      	b.n	2400226c <HAL_DMA_PollForTransfer+0x1e0>
      if(((*isr_reg) & (DMA_FLAG_FEIF0_4 << (hdma->StreamIndex & 0x1FU))) != 0U)
240021fe:	f8d6 c000 	ldr.w	ip, [r6]
24002202:	fa2c fc00 	lsr.w	ip, ip, r0
24002206:	f01c 0f01 	tst.w	ip, #1
2400220a:	d00a      	beq.n	24002222 <HAL_DMA_PollForTransfer+0x196>
        hdma->ErrorCode |= HAL_DMA_ERROR_FE;
2400220c:	f8d4 c054 	ldr.w	ip, [r4, #84]	@ 0x54
24002210:	f04c 0c02 	orr.w	ip, ip, #2
24002214:	f8c4 c054 	str.w	ip, [r4, #84]	@ 0x54
        (*ifcr_reg) = DMA_FLAG_FEIF0_4 << (hdma->StreamIndex & 0x1FU);
24002218:	f04f 0c01 	mov.w	ip, #1
2400221c:	fa0c f000 	lsl.w	r0, ip, r0
24002220:	6038      	str	r0, [r7, #0]
      if(((*isr_reg) & (DMA_FLAG_DMEIF0_4 << (hdma->StreamIndex & 0x1FU))) != 0U)
24002222:	6de0      	ldr	r0, [r4, #92]	@ 0x5c
24002224:	f04f 0e04 	mov.w	lr, #4
24002228:	f8d6 c000 	ldr.w	ip, [r6]
2400222c:	f000 001f 	and.w	r0, r0, #31
24002230:	fa0e f000 	lsl.w	r0, lr, r0
24002234:	ea1c 0f00 	tst.w	ip, r0
24002238:	d006      	beq.n	24002248 <HAL_DMA_PollForTransfer+0x1bc>
        hdma->ErrorCode |= HAL_DMA_ERROR_DME;
2400223a:	f8d4 c054 	ldr.w	ip, [r4, #84]	@ 0x54
2400223e:	ea4c 0c0e 	orr.w	ip, ip, lr
24002242:	f8c4 c054 	str.w	ip, [r4, #84]	@ 0x54
        (*ifcr_reg) = DMA_FLAG_DMEIF0_4 << (hdma->StreamIndex & 0x1FU);
24002246:	6038      	str	r0, [r7, #0]
      if(((*isr_reg) & (DMA_FLAG_TEIF0_4 << (hdma->StreamIndex & 0x1FU))) != 0U)
24002248:	6de0      	ldr	r0, [r4, #92]	@ 0x5c
2400224a:	f04f 0e08 	mov.w	lr, #8
2400224e:	f8d6 c000 	ldr.w	ip, [r6]
24002252:	f000 001f 	and.w	r0, r0, #31
24002256:	fa0e f000 	lsl.w	r0, lr, r0
2400225a:	ea1c 0f00 	tst.w	ip, r0
2400225e:	d008      	beq.n	24002272 <HAL_DMA_PollForTransfer+0x1e6>
        hdma->ErrorCode |= HAL_DMA_ERROR_TE;
24002260:	6d63      	ldr	r3, [r4, #84]	@ 0x54
24002262:	f043 0301 	orr.w	r3, r3, #1
24002266:	6563      	str	r3, [r4, #84]	@ 0x54
        hdma->State = HAL_DMA_STATE_READY;
24002268:	2301      	movs	r3, #1
        (*ifcr_reg) = DMA_FLAG_TEIF0_4 << (hdma->StreamIndex & 0x1FU);
2400226a:	6038      	str	r0, [r7, #0]
        hdma->State = HAL_DMA_STATE_READY;
2400226c:	f884 3035 	strb.w	r3, [r4, #53]	@ 0x35
24002270:	e71c      	b.n	240020ac <HAL_DMA_PollForTransfer+0x20>
    if(Timeout != HAL_MAX_DELAY)
24002272:	f1ba 3fff 	cmp.w	sl, #4294967295
24002276:	d01b      	beq.n	240022b0 <HAL_DMA_PollForTransfer+0x224>
      if(((HAL_GetTick() - tickstart ) > Timeout)||(Timeout == 0U))
24002278:	f00f fdc6 	bl	24011e08 <HAL_GetTick>
2400227c:	eba0 000b 	sub.w	r0, r0, fp
24002280:	4550      	cmp	r0, sl
24002282:	d805      	bhi.n	24002290 <HAL_DMA_PollForTransfer+0x204>
24002284:	4b05      	ldr	r3, [pc, #20]	@ (2400229c <HAL_DMA_PollForTransfer+0x210>)
24002286:	4a06      	ldr	r2, [pc, #24]	@ (240022a0 <HAL_DMA_PollForTransfer+0x214>)
24002288:	4906      	ldr	r1, [pc, #24]	@ (240022a4 <HAL_DMA_PollForTransfer+0x218>)
2400228a:	f1ba 0f00 	cmp.w	sl, #0
2400228e:	d10f      	bne.n	240022b0 <HAL_DMA_PollForTransfer+0x224>
        hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
24002290:	2320      	movs	r3, #32
        (void) HAL_DMA_Abort(hdma);
24002292:	4620      	mov	r0, r4
        hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
24002294:	6563      	str	r3, [r4, #84]	@ 0x54
        (void) HAL_DMA_Abort(hdma);
24002296:	f7ff fcbd 	bl	24001c14 <HAL_DMA_Abort>
        return HAL_ERROR;
2400229a:	e744      	b.n	24002126 <HAL_DMA_PollForTransfer+0x9a>
2400229c:	40020028 	.word	0x40020028
240022a0:	40020040 	.word	0x40020040
240022a4:	40020058 	.word	0x40020058
240022a8:	40020010 	.word	0x40020010
240022ac:	40020070 	.word	0x40020070
    if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
240022b0:	6820      	ldr	r0, [r4, #0]
240022b2:	4540      	cmp	r0, r8
240022b4:	d055      	beq.n	24002362 <HAL_DMA_PollForTransfer+0x2d6>
240022b6:	4298      	cmp	r0, r3
240022b8:	d053      	beq.n	24002362 <HAL_DMA_PollForTransfer+0x2d6>
240022ba:	4290      	cmp	r0, r2
240022bc:	d051      	beq.n	24002362 <HAL_DMA_PollForTransfer+0x2d6>
240022be:	4288      	cmp	r0, r1
240022c0:	d04f      	beq.n	24002362 <HAL_DMA_PollForTransfer+0x2d6>
240022c2:	f8df c1e4 	ldr.w	ip, [pc, #484]	@ 240024a8 <HAL_DMA_PollForTransfer+0x41c>
240022c6:	4560      	cmp	r0, ip
240022c8:	d04b      	beq.n	24002362 <HAL_DMA_PollForTransfer+0x2d6>
240022ca:	f10c 0c18 	add.w	ip, ip, #24
240022ce:	4560      	cmp	r0, ip
240022d0:	d047      	beq.n	24002362 <HAL_DMA_PollForTransfer+0x2d6>
240022d2:	f10c 0c18 	add.w	ip, ip, #24
240022d6:	4560      	cmp	r0, ip
240022d8:	d043      	beq.n	24002362 <HAL_DMA_PollForTransfer+0x2d6>
240022da:	f10c 0c18 	add.w	ip, ip, #24
240022de:	4560      	cmp	r0, ip
240022e0:	d03f      	beq.n	24002362 <HAL_DMA_PollForTransfer+0x2d6>
240022e2:	f50c 7c56 	add.w	ip, ip, #856	@ 0x358
240022e6:	4560      	cmp	r0, ip
240022e8:	d03b      	beq.n	24002362 <HAL_DMA_PollForTransfer+0x2d6>
240022ea:	f10c 0c18 	add.w	ip, ip, #24
240022ee:	4560      	cmp	r0, ip
240022f0:	d037      	beq.n	24002362 <HAL_DMA_PollForTransfer+0x2d6>
240022f2:	f10c 0c18 	add.w	ip, ip, #24
240022f6:	4560      	cmp	r0, ip
240022f8:	d033      	beq.n	24002362 <HAL_DMA_PollForTransfer+0x2d6>
240022fa:	f10c 0c18 	add.w	ip, ip, #24
240022fe:	4560      	cmp	r0, ip
24002300:	d02f      	beq.n	24002362 <HAL_DMA_PollForTransfer+0x2d6>
24002302:	f10c 0c18 	add.w	ip, ip, #24
24002306:	4560      	cmp	r0, ip
24002308:	d02b      	beq.n	24002362 <HAL_DMA_PollForTransfer+0x2d6>
2400230a:	f10c 0c18 	add.w	ip, ip, #24
2400230e:	4560      	cmp	r0, ip
24002310:	d027      	beq.n	24002362 <HAL_DMA_PollForTransfer+0x2d6>
24002312:	f10c 0c18 	add.w	ip, ip, #24
24002316:	4560      	cmp	r0, ip
24002318:	d023      	beq.n	24002362 <HAL_DMA_PollForTransfer+0x2d6>
2400231a:	f10c 0c18 	add.w	ip, ip, #24
2400231e:	4560      	cmp	r0, ip
24002320:	d01f      	beq.n	24002362 <HAL_DMA_PollForTransfer+0x2d6>
24002322:	f8df c188 	ldr.w	ip, [pc, #392]	@ 240024ac <HAL_DMA_PollForTransfer+0x420>
24002326:	4560      	cmp	r0, ip
24002328:	d01b      	beq.n	24002362 <HAL_DMA_PollForTransfer+0x2d6>
2400232a:	f10c 0c14 	add.w	ip, ip, #20
2400232e:	4560      	cmp	r0, ip
24002330:	d017      	beq.n	24002362 <HAL_DMA_PollForTransfer+0x2d6>
24002332:	f10c 0c14 	add.w	ip, ip, #20
24002336:	4560      	cmp	r0, ip
24002338:	d013      	beq.n	24002362 <HAL_DMA_PollForTransfer+0x2d6>
2400233a:	f10c 0c14 	add.w	ip, ip, #20
2400233e:	4560      	cmp	r0, ip
24002340:	d00f      	beq.n	24002362 <HAL_DMA_PollForTransfer+0x2d6>
24002342:	f10c 0c14 	add.w	ip, ip, #20
24002346:	4560      	cmp	r0, ip
24002348:	d00b      	beq.n	24002362 <HAL_DMA_PollForTransfer+0x2d6>
2400234a:	f10c 0c14 	add.w	ip, ip, #20
2400234e:	4560      	cmp	r0, ip
24002350:	d007      	beq.n	24002362 <HAL_DMA_PollForTransfer+0x2d6>
24002352:	f10c 0c14 	add.w	ip, ip, #20
24002356:	4560      	cmp	r0, ip
24002358:	d003      	beq.n	24002362 <HAL_DMA_PollForTransfer+0x2d6>
2400235a:	f10c 0c14 	add.w	ip, ip, #20
2400235e:	4560      	cmp	r0, ip
24002360:	d11d      	bne.n	2400239e <HAL_DMA_PollForTransfer+0x312>
      if(hdma->DMAmuxRequestGen != 0U)
24002362:	6ee0      	ldr	r0, [r4, #108]	@ 0x6c
24002364:	b168      	cbz	r0, 24002382 <HAL_DMA_PollForTransfer+0x2f6>
        if((hdma->DMAmuxRequestGenStatus->RGSR & hdma->DMAmuxRequestGenStatusMask) != 0U)
24002366:	6f20      	ldr	r0, [r4, #112]	@ 0x70
24002368:	f8d4 c074 	ldr.w	ip, [r4, #116]	@ 0x74
2400236c:	f8d0 e000 	ldr.w	lr, [r0]
24002370:	ea1e 0f0c 	tst.w	lr, ip
24002374:	d005      	beq.n	24002382 <HAL_DMA_PollForTransfer+0x2f6>
          hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
24002376:	f8c0 c004 	str.w	ip, [r0, #4]
          hdma->ErrorCode |= HAL_DMA_ERROR_REQGEN;
2400237a:	6d60      	ldr	r0, [r4, #84]	@ 0x54
2400237c:	f440 6080 	orr.w	r0, r0, #1024	@ 0x400
24002380:	6560      	str	r0, [r4, #84]	@ 0x54
      if((hdma->DMAmuxChannelStatus->CSR & hdma->DMAmuxChannelStatusMask) != 0U)
24002382:	6e60      	ldr	r0, [r4, #100]	@ 0x64
24002384:	f8d4 c068 	ldr.w	ip, [r4, #104]	@ 0x68
24002388:	f8d0 e000 	ldr.w	lr, [r0]
2400238c:	ea1e 0f0c 	tst.w	lr, ip
24002390:	d005      	beq.n	2400239e <HAL_DMA_PollForTransfer+0x312>
        hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
24002392:	f8c0 c004 	str.w	ip, [r0, #4]
        hdma->ErrorCode |= HAL_DMA_ERROR_SYNC;
24002396:	6d60      	ldr	r0, [r4, #84]	@ 0x54
24002398:	f440 7000 	orr.w	r0, r0, #512	@ 0x200
2400239c:	6560      	str	r0, [r4, #84]	@ 0x54
  while(((*isr_reg) & cpltlevel_mask) == 0U)
2400239e:	f8d6 e000 	ldr.w	lr, [r6]
      if(((*isr_reg) & (BDMA_FLAG_TE0 << (hdma->StreamIndex & 0x1FU))) != 0U)
240023a2:	6de0      	ldr	r0, [r4, #92]	@ 0x5c
  while(((*isr_reg) & cpltlevel_mask) == 0U)
240023a4:	ea1e 0f05 	tst.w	lr, r5
    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
240023a8:	f8d4 c000 	ldr.w	ip, [r4]
      if(((*isr_reg) & (BDMA_FLAG_TE0 << (hdma->StreamIndex & 0x1FU))) != 0U)
240023ac:	f000 001f 	and.w	r0, r0, #31
  while(((*isr_reg) & cpltlevel_mask) == 0U)
240023b0:	f43f aede 	beq.w	24002170 <HAL_DMA_PollForTransfer+0xe4>
  if(CompleteLevel == HAL_DMA_FULL_TRANSFER)
240023b4:	f1b9 0f00 	cmp.w	r9, #0
240023b8:	d13d      	bne.n	24002436 <HAL_DMA_PollForTransfer+0x3aa>
    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
240023ba:	45c4      	cmp	ip, r8
240023bc:	d039      	beq.n	24002432 <HAL_DMA_PollForTransfer+0x3a6>
240023be:	4b39      	ldr	r3, [pc, #228]	@ (240024a4 <HAL_DMA_PollForTransfer+0x418>)
240023c0:	459c      	cmp	ip, r3
240023c2:	d036      	beq.n	24002432 <HAL_DMA_PollForTransfer+0x3a6>
240023c4:	3318      	adds	r3, #24
240023c6:	459c      	cmp	ip, r3
240023c8:	d033      	beq.n	24002432 <HAL_DMA_PollForTransfer+0x3a6>
240023ca:	3318      	adds	r3, #24
240023cc:	459c      	cmp	ip, r3
240023ce:	d030      	beq.n	24002432 <HAL_DMA_PollForTransfer+0x3a6>
240023d0:	3318      	adds	r3, #24
240023d2:	459c      	cmp	ip, r3
240023d4:	d02d      	beq.n	24002432 <HAL_DMA_PollForTransfer+0x3a6>
240023d6:	3318      	adds	r3, #24
240023d8:	459c      	cmp	ip, r3
240023da:	d02a      	beq.n	24002432 <HAL_DMA_PollForTransfer+0x3a6>
240023dc:	3318      	adds	r3, #24
240023de:	459c      	cmp	ip, r3
240023e0:	d027      	beq.n	24002432 <HAL_DMA_PollForTransfer+0x3a6>
240023e2:	3318      	adds	r3, #24
240023e4:	459c      	cmp	ip, r3
240023e6:	d024      	beq.n	24002432 <HAL_DMA_PollForTransfer+0x3a6>
240023e8:	f503 7356 	add.w	r3, r3, #856	@ 0x358
240023ec:	459c      	cmp	ip, r3
240023ee:	d020      	beq.n	24002432 <HAL_DMA_PollForTransfer+0x3a6>
240023f0:	3318      	adds	r3, #24
240023f2:	459c      	cmp	ip, r3
240023f4:	d01d      	beq.n	24002432 <HAL_DMA_PollForTransfer+0x3a6>
240023f6:	3318      	adds	r3, #24
240023f8:	459c      	cmp	ip, r3
240023fa:	d01a      	beq.n	24002432 <HAL_DMA_PollForTransfer+0x3a6>
240023fc:	3318      	adds	r3, #24
240023fe:	459c      	cmp	ip, r3
24002400:	d017      	beq.n	24002432 <HAL_DMA_PollForTransfer+0x3a6>
24002402:	3318      	adds	r3, #24
24002404:	459c      	cmp	ip, r3
24002406:	d014      	beq.n	24002432 <HAL_DMA_PollForTransfer+0x3a6>
24002408:	3318      	adds	r3, #24
2400240a:	459c      	cmp	ip, r3
2400240c:	d011      	beq.n	24002432 <HAL_DMA_PollForTransfer+0x3a6>
2400240e:	3318      	adds	r3, #24
24002410:	459c      	cmp	ip, r3
24002412:	d00e      	beq.n	24002432 <HAL_DMA_PollForTransfer+0x3a6>
24002414:	3318      	adds	r3, #24
24002416:	459c      	cmp	ip, r3
24002418:	d00b      	beq.n	24002432 <HAL_DMA_PollForTransfer+0x3a6>
      (*ifcr_reg) = (BDMA_FLAG_TC0 << (hdma->StreamIndex & 0x1FU));
2400241a:	2302      	movs	r3, #2
      (*ifcr_reg) = (DMA_FLAG_HTIF0_4 | DMA_FLAG_TCIF0_4) << (hdma->StreamIndex & 0x1FU);
2400241c:	4083      	lsls	r3, r0
2400241e:	603b      	str	r3, [r7, #0]
    __HAL_UNLOCK(hdma);
24002420:	2300      	movs	r3, #0
24002422:	f884 3034 	strb.w	r3, [r4, #52]	@ 0x34
    hdma->State = HAL_DMA_STATE_READY;
24002426:	2301      	movs	r3, #1
24002428:	f884 3035 	strb.w	r3, [r4, #53]	@ 0x35
  return status;
2400242c:	2000      	movs	r0, #0
}
2400242e:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
      (*ifcr_reg) = (DMA_FLAG_HTIF0_4 | DMA_FLAG_TCIF0_4) << (hdma->StreamIndex & 0x1FU);
24002432:	2330      	movs	r3, #48	@ 0x30
24002434:	e7f2      	b.n	2400241c <HAL_DMA_PollForTransfer+0x390>
    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
24002436:	45c4      	cmp	ip, r8
24002438:	d031      	beq.n	2400249e <HAL_DMA_PollForTransfer+0x412>
2400243a:	4b1a      	ldr	r3, [pc, #104]	@ (240024a4 <HAL_DMA_PollForTransfer+0x418>)
2400243c:	459c      	cmp	ip, r3
2400243e:	d02e      	beq.n	2400249e <HAL_DMA_PollForTransfer+0x412>
24002440:	3318      	adds	r3, #24
24002442:	459c      	cmp	ip, r3
24002444:	d02b      	beq.n	2400249e <HAL_DMA_PollForTransfer+0x412>
24002446:	3318      	adds	r3, #24
24002448:	459c      	cmp	ip, r3
2400244a:	d028      	beq.n	2400249e <HAL_DMA_PollForTransfer+0x412>
2400244c:	3318      	adds	r3, #24
2400244e:	459c      	cmp	ip, r3
24002450:	d025      	beq.n	2400249e <HAL_DMA_PollForTransfer+0x412>
24002452:	3318      	adds	r3, #24
24002454:	459c      	cmp	ip, r3
24002456:	d022      	beq.n	2400249e <HAL_DMA_PollForTransfer+0x412>
24002458:	3318      	adds	r3, #24
2400245a:	459c      	cmp	ip, r3
2400245c:	d01f      	beq.n	2400249e <HAL_DMA_PollForTransfer+0x412>
2400245e:	3318      	adds	r3, #24
24002460:	459c      	cmp	ip, r3
24002462:	d01c      	beq.n	2400249e <HAL_DMA_PollForTransfer+0x412>
24002464:	f503 7356 	add.w	r3, r3, #856	@ 0x358
24002468:	459c      	cmp	ip, r3
2400246a:	d018      	beq.n	2400249e <HAL_DMA_PollForTransfer+0x412>
2400246c:	3318      	adds	r3, #24
2400246e:	459c      	cmp	ip, r3
24002470:	d015      	beq.n	2400249e <HAL_DMA_PollForTransfer+0x412>
24002472:	3318      	adds	r3, #24
24002474:	459c      	cmp	ip, r3
24002476:	d012      	beq.n	2400249e <HAL_DMA_PollForTransfer+0x412>
24002478:	3318      	adds	r3, #24
2400247a:	459c      	cmp	ip, r3
2400247c:	d00f      	beq.n	2400249e <HAL_DMA_PollForTransfer+0x412>
2400247e:	3318      	adds	r3, #24
24002480:	459c      	cmp	ip, r3
24002482:	d00c      	beq.n	2400249e <HAL_DMA_PollForTransfer+0x412>
24002484:	3318      	adds	r3, #24
24002486:	459c      	cmp	ip, r3
24002488:	d009      	beq.n	2400249e <HAL_DMA_PollForTransfer+0x412>
2400248a:	3318      	adds	r3, #24
2400248c:	459c      	cmp	ip, r3
2400248e:	d006      	beq.n	2400249e <HAL_DMA_PollForTransfer+0x412>
24002490:	3318      	adds	r3, #24
24002492:	459c      	cmp	ip, r3
24002494:	d003      	beq.n	2400249e <HAL_DMA_PollForTransfer+0x412>
      (*ifcr_reg) = (BDMA_FLAG_HT0 << (hdma->StreamIndex & 0x1FU));
24002496:	2304      	movs	r3, #4
      (*ifcr_reg) = (DMA_FLAG_HTIF0_4) << (hdma->StreamIndex & 0x1FU);
24002498:	4083      	lsls	r3, r0
2400249a:	603b      	str	r3, [r7, #0]
2400249c:	e7c6      	b.n	2400242c <HAL_DMA_PollForTransfer+0x3a0>
2400249e:	2310      	movs	r3, #16
240024a0:	e7fa      	b.n	24002498 <HAL_DMA_PollForTransfer+0x40c>
240024a2:	bf00      	nop
240024a4:	40020028 	.word	0x40020028
240024a8:	40020070 	.word	0x40020070
240024ac:	58025408 	.word	0x58025408

240024b0 <HAL_DMA_IRQHandler>:
  __IO uint32_t count = 0U;
240024b0:	2300      	movs	r3, #0
{
240024b2:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
  __IO uint32_t count = 0U;
240024b6:	9301      	str	r3, [sp, #4]
{
240024b8:	4604      	mov	r4, r0
  uint32_t timeout = SystemCoreClock / 9600U;
240024ba:	4b29      	ldr	r3, [pc, #164]	@ (24002560 <HAL_DMA_IRQHandler+0xb0>)
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U)  /* DMA1 or DMA2 instance */
240024bc:	4e29      	ldr	r6, [pc, #164]	@ (24002564 <HAL_DMA_IRQHandler+0xb4>)
  uint32_t timeout = SystemCoreClock / 9600U;
240024be:	681f      	ldr	r7, [r3, #0]
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U)  /* DMA1 or DMA2 instance */
240024c0:	6803      	ldr	r3, [r0, #0]
  DMA_Base_Registers  *regs_dma  = (DMA_Base_Registers *)hdma->StreamBaseAddress;
240024c2:	6d85      	ldr	r5, [r0, #88]	@ 0x58
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U)  /* DMA1 or DMA2 instance */
240024c4:	42b3      	cmp	r3, r6
  tmpisr_dma  = regs_dma->ISR;
240024c6:	f8d5 8000 	ldr.w	r8, [r5]
  tmpisr_bdma = regs_bdma->ISR;
240024ca:	f8d5 c000 	ldr.w	ip, [r5]
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U)  /* DMA1 or DMA2 instance */
240024ce:	d04f      	beq.n	24002570 <HAL_DMA_IRQHandler+0xc0>
240024d0:	4a25      	ldr	r2, [pc, #148]	@ (24002568 <HAL_DMA_IRQHandler+0xb8>)
240024d2:	4293      	cmp	r3, r2
240024d4:	d04c      	beq.n	24002570 <HAL_DMA_IRQHandler+0xc0>
240024d6:	3218      	adds	r2, #24
240024d8:	4293      	cmp	r3, r2
240024da:	d049      	beq.n	24002570 <HAL_DMA_IRQHandler+0xc0>
240024dc:	3218      	adds	r2, #24
240024de:	4293      	cmp	r3, r2
240024e0:	d046      	beq.n	24002570 <HAL_DMA_IRQHandler+0xc0>
240024e2:	3218      	adds	r2, #24
240024e4:	4293      	cmp	r3, r2
240024e6:	d043      	beq.n	24002570 <HAL_DMA_IRQHandler+0xc0>
240024e8:	3218      	adds	r2, #24
240024ea:	4293      	cmp	r3, r2
240024ec:	d040      	beq.n	24002570 <HAL_DMA_IRQHandler+0xc0>
240024ee:	3218      	adds	r2, #24
240024f0:	4293      	cmp	r3, r2
240024f2:	d03d      	beq.n	24002570 <HAL_DMA_IRQHandler+0xc0>
240024f4:	3218      	adds	r2, #24
240024f6:	4293      	cmp	r3, r2
240024f8:	d03a      	beq.n	24002570 <HAL_DMA_IRQHandler+0xc0>
240024fa:	f502 7256 	add.w	r2, r2, #856	@ 0x358
240024fe:	4293      	cmp	r3, r2
24002500:	d036      	beq.n	24002570 <HAL_DMA_IRQHandler+0xc0>
24002502:	3218      	adds	r2, #24
24002504:	4293      	cmp	r3, r2
24002506:	d033      	beq.n	24002570 <HAL_DMA_IRQHandler+0xc0>
24002508:	3218      	adds	r2, #24
2400250a:	4293      	cmp	r3, r2
2400250c:	d030      	beq.n	24002570 <HAL_DMA_IRQHandler+0xc0>
2400250e:	3218      	adds	r2, #24
24002510:	4293      	cmp	r3, r2
24002512:	d02d      	beq.n	24002570 <HAL_DMA_IRQHandler+0xc0>
24002514:	3218      	adds	r2, #24
24002516:	4293      	cmp	r3, r2
24002518:	d02a      	beq.n	24002570 <HAL_DMA_IRQHandler+0xc0>
2400251a:	3218      	adds	r2, #24
2400251c:	4293      	cmp	r3, r2
2400251e:	d027      	beq.n	24002570 <HAL_DMA_IRQHandler+0xc0>
24002520:	3218      	adds	r2, #24
24002522:	4293      	cmp	r3, r2
24002524:	d024      	beq.n	24002570 <HAL_DMA_IRQHandler+0xc0>
24002526:	3218      	adds	r2, #24
24002528:	4293      	cmp	r3, r2
2400252a:	d021      	beq.n	24002570 <HAL_DMA_IRQHandler+0xc0>
  else if(IS_BDMA_CHANNEL_INSTANCE(hdma->Instance) != 0U)  /* BDMA instance(s) */
2400252c:	4a0f      	ldr	r2, [pc, #60]	@ (2400256c <HAL_DMA_IRQHandler+0xbc>)
2400252e:	4293      	cmp	r3, r2
24002530:	f040 8209 	bne.w	24002946 <HAL_DMA_IRQHandler+0x496>
    if (((tmpisr_bdma & (BDMA_FLAG_HT0 << (hdma->StreamIndex & 0x1FU))) != 0U) && ((ccr_reg & BDMA_CCR_HTIE) != 0U))
24002534:	6de1      	ldr	r1, [r4, #92]	@ 0x5c
24002536:	2004      	movs	r0, #4
    ccr_reg = (((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR);
24002538:	681a      	ldr	r2, [r3, #0]
    if (((tmpisr_bdma & (BDMA_FLAG_HT0 << (hdma->StreamIndex & 0x1FU))) != 0U) && ((ccr_reg & BDMA_CCR_HTIE) != 0U))
2400253a:	f001 011f 	and.w	r1, r1, #31
2400253e:	4088      	lsls	r0, r1
24002540:	ea10 0f0c 	tst.w	r0, ip
24002544:	f000 8226 	beq.w	24002994 <HAL_DMA_IRQHandler+0x4e4>
24002548:	0756      	lsls	r6, r2, #29
2400254a:	f140 8223 	bpl.w	24002994 <HAL_DMA_IRQHandler+0x4e4>
      if((ccr_reg & BDMA_CCR_DBM) != 0U)
2400254e:	0411      	lsls	r1, r2, #16
      regs_bdma->IFCR = (BDMA_ISR_HTIF0 << (hdma->StreamIndex & 0x1FU));
24002550:	6068      	str	r0, [r5, #4]
      if((ccr_reg & BDMA_CCR_DBM) != 0U)
24002552:	f140 8217 	bpl.w	24002984 <HAL_DMA_IRQHandler+0x4d4>
        if((ccr_reg & BDMA_CCR_CT) == 0U)
24002556:	03d3      	lsls	r3, r2, #15
24002558:	f100 821a 	bmi.w	24002990 <HAL_DMA_IRQHandler+0x4e0>
          if(hdma->XferM1HalfCpltCallback != NULL)
2400255c:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
2400255e:	e17e      	b.n	2400285e <HAL_DMA_IRQHandler+0x3ae>
24002560:	24000518 	.word	0x24000518
24002564:	40020010 	.word	0x40020010
24002568:	40020028 	.word	0x40020028
2400256c:	58025408 	.word	0x58025408
    if ((tmpisr_dma & (DMA_FLAG_TEIF0_4 << (hdma->StreamIndex & 0x1FU))) != 0U)
24002570:	6de2      	ldr	r2, [r4, #92]	@ 0x5c
24002572:	2008      	movs	r0, #8
24002574:	f002 021f 	and.w	r2, r2, #31
24002578:	4090      	lsls	r0, r2
2400257a:	ea10 0f08 	tst.w	r0, r8
2400257e:	d03d      	beq.n	240025fc <HAL_DMA_IRQHandler+0x14c>
      if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TE) != 0U)
24002580:	42b3      	cmp	r3, r6
24002582:	d02e      	beq.n	240025e2 <HAL_DMA_IRQHandler+0x132>
24002584:	4984      	ldr	r1, [pc, #528]	@ (24002798 <HAL_DMA_IRQHandler+0x2e8>)
24002586:	428b      	cmp	r3, r1
24002588:	d02b      	beq.n	240025e2 <HAL_DMA_IRQHandler+0x132>
2400258a:	3118      	adds	r1, #24
2400258c:	428b      	cmp	r3, r1
2400258e:	d028      	beq.n	240025e2 <HAL_DMA_IRQHandler+0x132>
24002590:	3118      	adds	r1, #24
24002592:	428b      	cmp	r3, r1
24002594:	d025      	beq.n	240025e2 <HAL_DMA_IRQHandler+0x132>
24002596:	3118      	adds	r1, #24
24002598:	428b      	cmp	r3, r1
2400259a:	d022      	beq.n	240025e2 <HAL_DMA_IRQHandler+0x132>
2400259c:	3118      	adds	r1, #24
2400259e:	428b      	cmp	r3, r1
240025a0:	d01f      	beq.n	240025e2 <HAL_DMA_IRQHandler+0x132>
240025a2:	3118      	adds	r1, #24
240025a4:	428b      	cmp	r3, r1
240025a6:	d01c      	beq.n	240025e2 <HAL_DMA_IRQHandler+0x132>
240025a8:	3118      	adds	r1, #24
240025aa:	428b      	cmp	r3, r1
240025ac:	d019      	beq.n	240025e2 <HAL_DMA_IRQHandler+0x132>
240025ae:	f501 7156 	add.w	r1, r1, #856	@ 0x358
240025b2:	428b      	cmp	r3, r1
240025b4:	d015      	beq.n	240025e2 <HAL_DMA_IRQHandler+0x132>
240025b6:	3118      	adds	r1, #24
240025b8:	428b      	cmp	r3, r1
240025ba:	d012      	beq.n	240025e2 <HAL_DMA_IRQHandler+0x132>
240025bc:	3118      	adds	r1, #24
240025be:	428b      	cmp	r3, r1
240025c0:	d00f      	beq.n	240025e2 <HAL_DMA_IRQHandler+0x132>
240025c2:	3118      	adds	r1, #24
240025c4:	428b      	cmp	r3, r1
240025c6:	d00c      	beq.n	240025e2 <HAL_DMA_IRQHandler+0x132>
240025c8:	3118      	adds	r1, #24
240025ca:	428b      	cmp	r3, r1
240025cc:	d009      	beq.n	240025e2 <HAL_DMA_IRQHandler+0x132>
240025ce:	3118      	adds	r1, #24
240025d0:	428b      	cmp	r3, r1
240025d2:	d006      	beq.n	240025e2 <HAL_DMA_IRQHandler+0x132>
240025d4:	3118      	adds	r1, #24
240025d6:	428b      	cmp	r3, r1
240025d8:	d003      	beq.n	240025e2 <HAL_DMA_IRQHandler+0x132>
240025da:	3118      	adds	r1, #24
240025dc:	428b      	cmp	r3, r1
240025de:	f040 80c1 	bne.w	24002764 <HAL_DMA_IRQHandler+0x2b4>
240025e2:	6819      	ldr	r1, [r3, #0]
240025e4:	f3c1 0180 	ubfx	r1, r1, #2, #1
240025e8:	b141      	cbz	r1, 240025fc <HAL_DMA_IRQHandler+0x14c>
        ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  &= ~(DMA_IT_TE);
240025ea:	6819      	ldr	r1, [r3, #0]
240025ec:	f021 0104 	bic.w	r1, r1, #4
240025f0:	6019      	str	r1, [r3, #0]
        regs_dma->IFCR = DMA_FLAG_TEIF0_4 << (hdma->StreamIndex & 0x1FU);
240025f2:	60a8      	str	r0, [r5, #8]
        hdma->ErrorCode |= HAL_DMA_ERROR_TE;
240025f4:	6d61      	ldr	r1, [r4, #84]	@ 0x54
240025f6:	f041 0101 	orr.w	r1, r1, #1
240025fa:	6561      	str	r1, [r4, #84]	@ 0x54
    if ((tmpisr_dma & (DMA_FLAG_FEIF0_4 << (hdma->StreamIndex & 0x1FU))) != 0U)
240025fc:	fa28 f102 	lsr.w	r1, r8, r2
24002600:	07c8      	lsls	r0, r1, #31
24002602:	d534      	bpl.n	2400266e <HAL_DMA_IRQHandler+0x1be>
      if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_FE) != 0U)
24002604:	42b3      	cmp	r3, r6
24002606:	d02e      	beq.n	24002666 <HAL_DMA_IRQHandler+0x1b6>
24002608:	4963      	ldr	r1, [pc, #396]	@ (24002798 <HAL_DMA_IRQHandler+0x2e8>)
2400260a:	428b      	cmp	r3, r1
2400260c:	d02b      	beq.n	24002666 <HAL_DMA_IRQHandler+0x1b6>
2400260e:	3118      	adds	r1, #24
24002610:	428b      	cmp	r3, r1
24002612:	d028      	beq.n	24002666 <HAL_DMA_IRQHandler+0x1b6>
24002614:	3118      	adds	r1, #24
24002616:	428b      	cmp	r3, r1
24002618:	d025      	beq.n	24002666 <HAL_DMA_IRQHandler+0x1b6>
2400261a:	3118      	adds	r1, #24
2400261c:	428b      	cmp	r3, r1
2400261e:	d022      	beq.n	24002666 <HAL_DMA_IRQHandler+0x1b6>
24002620:	3118      	adds	r1, #24
24002622:	428b      	cmp	r3, r1
24002624:	d01f      	beq.n	24002666 <HAL_DMA_IRQHandler+0x1b6>
24002626:	3118      	adds	r1, #24
24002628:	428b      	cmp	r3, r1
2400262a:	d01c      	beq.n	24002666 <HAL_DMA_IRQHandler+0x1b6>
2400262c:	3118      	adds	r1, #24
2400262e:	428b      	cmp	r3, r1
24002630:	d019      	beq.n	24002666 <HAL_DMA_IRQHandler+0x1b6>
24002632:	f501 7156 	add.w	r1, r1, #856	@ 0x358
24002636:	428b      	cmp	r3, r1
24002638:	d015      	beq.n	24002666 <HAL_DMA_IRQHandler+0x1b6>
2400263a:	3118      	adds	r1, #24
2400263c:	428b      	cmp	r3, r1
2400263e:	d012      	beq.n	24002666 <HAL_DMA_IRQHandler+0x1b6>
24002640:	3118      	adds	r1, #24
24002642:	428b      	cmp	r3, r1
24002644:	d00f      	beq.n	24002666 <HAL_DMA_IRQHandler+0x1b6>
24002646:	3118      	adds	r1, #24
24002648:	428b      	cmp	r3, r1
2400264a:	d00c      	beq.n	24002666 <HAL_DMA_IRQHandler+0x1b6>
2400264c:	3118      	adds	r1, #24
2400264e:	428b      	cmp	r3, r1
24002650:	d009      	beq.n	24002666 <HAL_DMA_IRQHandler+0x1b6>
24002652:	3118      	adds	r1, #24
24002654:	428b      	cmp	r3, r1
24002656:	d006      	beq.n	24002666 <HAL_DMA_IRQHandler+0x1b6>
24002658:	3118      	adds	r1, #24
2400265a:	428b      	cmp	r3, r1
2400265c:	d003      	beq.n	24002666 <HAL_DMA_IRQHandler+0x1b6>
2400265e:	3118      	adds	r1, #24
24002660:	428b      	cmp	r3, r1
24002662:	f040 8083 	bne.w	2400276c <HAL_DMA_IRQHandler+0x2bc>
24002666:	6959      	ldr	r1, [r3, #20]
24002668:	0609      	lsls	r1, r1, #24
2400266a:	f100 8081 	bmi.w	24002770 <HAL_DMA_IRQHandler+0x2c0>
    if ((tmpisr_dma & (DMA_FLAG_DMEIF0_4 << (hdma->StreamIndex & 0x1FU))) != 0U)
2400266e:	2104      	movs	r1, #4
24002670:	4091      	lsls	r1, r2
24002672:	ea11 0f08 	tst.w	r1, r8
24002676:	d032      	beq.n	240026de <HAL_DMA_IRQHandler+0x22e>
      if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_DME) != 0U)
24002678:	42b3      	cmp	r3, r6
2400267a:	d02d      	beq.n	240026d8 <HAL_DMA_IRQHandler+0x228>
2400267c:	4846      	ldr	r0, [pc, #280]	@ (24002798 <HAL_DMA_IRQHandler+0x2e8>)
2400267e:	4283      	cmp	r3, r0
24002680:	d02a      	beq.n	240026d8 <HAL_DMA_IRQHandler+0x228>
24002682:	3018      	adds	r0, #24
24002684:	4283      	cmp	r3, r0
24002686:	d027      	beq.n	240026d8 <HAL_DMA_IRQHandler+0x228>
24002688:	3018      	adds	r0, #24
2400268a:	4283      	cmp	r3, r0
2400268c:	d024      	beq.n	240026d8 <HAL_DMA_IRQHandler+0x228>
2400268e:	3018      	adds	r0, #24
24002690:	4283      	cmp	r3, r0
24002692:	d021      	beq.n	240026d8 <HAL_DMA_IRQHandler+0x228>
24002694:	3018      	adds	r0, #24
24002696:	4283      	cmp	r3, r0
24002698:	d01e      	beq.n	240026d8 <HAL_DMA_IRQHandler+0x228>
2400269a:	3018      	adds	r0, #24
2400269c:	4283      	cmp	r3, r0
2400269e:	d01b      	beq.n	240026d8 <HAL_DMA_IRQHandler+0x228>
240026a0:	3018      	adds	r0, #24
240026a2:	4283      	cmp	r3, r0
240026a4:	d018      	beq.n	240026d8 <HAL_DMA_IRQHandler+0x228>
240026a6:	f500 7056 	add.w	r0, r0, #856	@ 0x358
240026aa:	4283      	cmp	r3, r0
240026ac:	d014      	beq.n	240026d8 <HAL_DMA_IRQHandler+0x228>
240026ae:	3018      	adds	r0, #24
240026b0:	4283      	cmp	r3, r0
240026b2:	d011      	beq.n	240026d8 <HAL_DMA_IRQHandler+0x228>
240026b4:	3018      	adds	r0, #24
240026b6:	4283      	cmp	r3, r0
240026b8:	d00e      	beq.n	240026d8 <HAL_DMA_IRQHandler+0x228>
240026ba:	3018      	adds	r0, #24
240026bc:	4283      	cmp	r3, r0
240026be:	d00b      	beq.n	240026d8 <HAL_DMA_IRQHandler+0x228>
240026c0:	3018      	adds	r0, #24
240026c2:	4283      	cmp	r3, r0
240026c4:	d008      	beq.n	240026d8 <HAL_DMA_IRQHandler+0x228>
240026c6:	3018      	adds	r0, #24
240026c8:	4283      	cmp	r3, r0
240026ca:	d005      	beq.n	240026d8 <HAL_DMA_IRQHandler+0x228>
240026cc:	3018      	adds	r0, #24
240026ce:	4283      	cmp	r3, r0
240026d0:	d002      	beq.n	240026d8 <HAL_DMA_IRQHandler+0x228>
240026d2:	3018      	adds	r0, #24
240026d4:	4283      	cmp	r3, r0
240026d6:	d153      	bne.n	24002780 <HAL_DMA_IRQHandler+0x2d0>
240026d8:	6818      	ldr	r0, [r3, #0]
240026da:	0780      	lsls	r0, r0, #30
240026dc:	d452      	bmi.n	24002784 <HAL_DMA_IRQHandler+0x2d4>
    if ((tmpisr_dma & (DMA_FLAG_HTIF0_4 << (hdma->StreamIndex & 0x1FU))) != 0U)
240026de:	2110      	movs	r1, #16
240026e0:	4091      	lsls	r1, r2
240026e2:	ea11 0f08 	tst.w	r1, r8
240026e6:	d05d      	beq.n	240027a4 <HAL_DMA_IRQHandler+0x2f4>
      if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_HT) != 0U)
240026e8:	42b3      	cmp	r3, r6
240026ea:	d02d      	beq.n	24002748 <HAL_DMA_IRQHandler+0x298>
240026ec:	4a2a      	ldr	r2, [pc, #168]	@ (24002798 <HAL_DMA_IRQHandler+0x2e8>)
240026ee:	4293      	cmp	r3, r2
240026f0:	d02a      	beq.n	24002748 <HAL_DMA_IRQHandler+0x298>
240026f2:	3218      	adds	r2, #24
240026f4:	4293      	cmp	r3, r2
240026f6:	d027      	beq.n	24002748 <HAL_DMA_IRQHandler+0x298>
240026f8:	3218      	adds	r2, #24
240026fa:	4293      	cmp	r3, r2
240026fc:	d024      	beq.n	24002748 <HAL_DMA_IRQHandler+0x298>
240026fe:	3218      	adds	r2, #24
24002700:	4293      	cmp	r3, r2
24002702:	d021      	beq.n	24002748 <HAL_DMA_IRQHandler+0x298>
24002704:	3218      	adds	r2, #24
24002706:	4293      	cmp	r3, r2
24002708:	d01e      	beq.n	24002748 <HAL_DMA_IRQHandler+0x298>
2400270a:	3218      	adds	r2, #24
2400270c:	4293      	cmp	r3, r2
2400270e:	d01b      	beq.n	24002748 <HAL_DMA_IRQHandler+0x298>
24002710:	3218      	adds	r2, #24
24002712:	4293      	cmp	r3, r2
24002714:	d018      	beq.n	24002748 <HAL_DMA_IRQHandler+0x298>
24002716:	f502 7256 	add.w	r2, r2, #856	@ 0x358
2400271a:	4293      	cmp	r3, r2
2400271c:	d014      	beq.n	24002748 <HAL_DMA_IRQHandler+0x298>
2400271e:	3218      	adds	r2, #24
24002720:	4293      	cmp	r3, r2
24002722:	d011      	beq.n	24002748 <HAL_DMA_IRQHandler+0x298>
24002724:	3218      	adds	r2, #24
24002726:	4293      	cmp	r3, r2
24002728:	d00e      	beq.n	24002748 <HAL_DMA_IRQHandler+0x298>
2400272a:	3218      	adds	r2, #24
2400272c:	4293      	cmp	r3, r2
2400272e:	d00b      	beq.n	24002748 <HAL_DMA_IRQHandler+0x298>
24002730:	3218      	adds	r2, #24
24002732:	4293      	cmp	r3, r2
24002734:	d008      	beq.n	24002748 <HAL_DMA_IRQHandler+0x298>
24002736:	3218      	adds	r2, #24
24002738:	4293      	cmp	r3, r2
2400273a:	d005      	beq.n	24002748 <HAL_DMA_IRQHandler+0x298>
2400273c:	3218      	adds	r2, #24
2400273e:	4293      	cmp	r3, r2
24002740:	d002      	beq.n	24002748 <HAL_DMA_IRQHandler+0x298>
24002742:	3218      	adds	r2, #24
24002744:	4293      	cmp	r3, r2
24002746:	d123      	bne.n	24002790 <HAL_DMA_IRQHandler+0x2e0>
24002748:	681a      	ldr	r2, [r3, #0]
2400274a:	f3c2 02c0 	ubfx	r2, r2, #3, #1
2400274e:	b34a      	cbz	r2, 240027a4 <HAL_DMA_IRQHandler+0x2f4>
        regs_dma->IFCR = DMA_FLAG_HTIF0_4 << (hdma->StreamIndex & 0x1FU);
24002750:	60a9      	str	r1, [r5, #8]
        if(((((DMA_Stream_TypeDef   *)hdma->Instance)->CR) & (uint32_t)(DMA_SxCR_DBM)) != 0U)
24002752:	681a      	ldr	r2, [r3, #0]
24002754:	0350      	lsls	r0, r2, #13
24002756:	f140 808a 	bpl.w	2400286e <HAL_DMA_IRQHandler+0x3be>
          if((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_CT) == 0U)
2400275a:	681b      	ldr	r3, [r3, #0]
2400275c:	0319      	lsls	r1, r3, #12
2400275e:	d41d      	bmi.n	2400279c <HAL_DMA_IRQHandler+0x2ec>
          if(hdma->XferHalfCpltCallback != NULL)
24002760:	6c23      	ldr	r3, [r4, #64]	@ 0x40
24002762:	e01c      	b.n	2400279e <HAL_DMA_IRQHandler+0x2ee>
      if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TE) != 0U)
24002764:	6819      	ldr	r1, [r3, #0]
24002766:	f3c1 01c0 	ubfx	r1, r1, #3, #1
2400276a:	e73d      	b.n	240025e8 <HAL_DMA_IRQHandler+0x138>
      if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_FE) != 0U)
2400276c:	6819      	ldr	r1, [r3, #0]
2400276e:	e77e      	b.n	2400266e <HAL_DMA_IRQHandler+0x1be>
        regs_dma->IFCR = DMA_FLAG_FEIF0_4 << (hdma->StreamIndex & 0x1FU);
24002770:	2101      	movs	r1, #1
24002772:	4091      	lsls	r1, r2
24002774:	60a9      	str	r1, [r5, #8]
        hdma->ErrorCode |= HAL_DMA_ERROR_FE;
24002776:	6d61      	ldr	r1, [r4, #84]	@ 0x54
24002778:	f041 0102 	orr.w	r1, r1, #2
2400277c:	6561      	str	r1, [r4, #84]	@ 0x54
2400277e:	e776      	b.n	2400266e <HAL_DMA_IRQHandler+0x1be>
      if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_DME) != 0U)
24002780:	6819      	ldr	r1, [r3, #0]
24002782:	e7ac      	b.n	240026de <HAL_DMA_IRQHandler+0x22e>
        regs_dma->IFCR = DMA_FLAG_DMEIF0_4 << (hdma->StreamIndex & 0x1FU);
24002784:	60a9      	str	r1, [r5, #8]
        hdma->ErrorCode |= HAL_DMA_ERROR_DME;
24002786:	6d61      	ldr	r1, [r4, #84]	@ 0x54
24002788:	f041 0104 	orr.w	r1, r1, #4
2400278c:	6561      	str	r1, [r4, #84]	@ 0x54
2400278e:	e7a6      	b.n	240026de <HAL_DMA_IRQHandler+0x22e>
      if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_HT) != 0U)
24002790:	681a      	ldr	r2, [r3, #0]
24002792:	f3c2 0280 	ubfx	r2, r2, #2, #1
24002796:	e7da      	b.n	2400274e <HAL_DMA_IRQHandler+0x29e>
24002798:	40020028 	.word	0x40020028
            if(hdma->XferM1HalfCpltCallback != NULL)
2400279c:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
          if(hdma->XferHalfCpltCallback != NULL)
2400279e:	b10b      	cbz	r3, 240027a4 <HAL_DMA_IRQHandler+0x2f4>
            hdma->XferHalfCpltCallback(hdma);
240027a0:	4620      	mov	r0, r4
240027a2:	4798      	blx	r3
    if ((tmpisr_dma & (DMA_FLAG_TCIF0_4 << (hdma->StreamIndex & 0x1FU))) != 0U)
240027a4:	6de1      	ldr	r1, [r4, #92]	@ 0x5c
240027a6:	2020      	movs	r0, #32
240027a8:	f001 011f 	and.w	r1, r1, #31
240027ac:	4088      	lsls	r0, r1
240027ae:	ea10 0f08 	tst.w	r0, r8
240027b2:	d072      	beq.n	2400289a <HAL_DMA_IRQHandler+0x3ea>
      if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TC) != 0U)
240027b4:	6823      	ldr	r3, [r4, #0]
240027b6:	42b3      	cmp	r3, r6
240027b8:	d02d      	beq.n	24002816 <HAL_DMA_IRQHandler+0x366>
240027ba:	4a8e      	ldr	r2, [pc, #568]	@ (240029f4 <HAL_DMA_IRQHandler+0x544>)
240027bc:	4293      	cmp	r3, r2
240027be:	d02a      	beq.n	24002816 <HAL_DMA_IRQHandler+0x366>
240027c0:	3218      	adds	r2, #24
240027c2:	4293      	cmp	r3, r2
240027c4:	d027      	beq.n	24002816 <HAL_DMA_IRQHandler+0x366>
240027c6:	3218      	adds	r2, #24
240027c8:	4293      	cmp	r3, r2
240027ca:	d024      	beq.n	24002816 <HAL_DMA_IRQHandler+0x366>
240027cc:	3218      	adds	r2, #24
240027ce:	4293      	cmp	r3, r2
240027d0:	d021      	beq.n	24002816 <HAL_DMA_IRQHandler+0x366>
240027d2:	3218      	adds	r2, #24
240027d4:	4293      	cmp	r3, r2
240027d6:	d01e      	beq.n	24002816 <HAL_DMA_IRQHandler+0x366>
240027d8:	3218      	adds	r2, #24
240027da:	4293      	cmp	r3, r2
240027dc:	d01b      	beq.n	24002816 <HAL_DMA_IRQHandler+0x366>
240027de:	3218      	adds	r2, #24
240027e0:	4293      	cmp	r3, r2
240027e2:	d018      	beq.n	24002816 <HAL_DMA_IRQHandler+0x366>
240027e4:	f502 7256 	add.w	r2, r2, #856	@ 0x358
240027e8:	4293      	cmp	r3, r2
240027ea:	d014      	beq.n	24002816 <HAL_DMA_IRQHandler+0x366>
240027ec:	3218      	adds	r2, #24
240027ee:	4293      	cmp	r3, r2
240027f0:	d011      	beq.n	24002816 <HAL_DMA_IRQHandler+0x366>
240027f2:	3218      	adds	r2, #24
240027f4:	4293      	cmp	r3, r2
240027f6:	d00e      	beq.n	24002816 <HAL_DMA_IRQHandler+0x366>
240027f8:	3218      	adds	r2, #24
240027fa:	4293      	cmp	r3, r2
240027fc:	d00b      	beq.n	24002816 <HAL_DMA_IRQHandler+0x366>
240027fe:	3218      	adds	r2, #24
24002800:	4293      	cmp	r3, r2
24002802:	d008      	beq.n	24002816 <HAL_DMA_IRQHandler+0x366>
24002804:	3218      	adds	r2, #24
24002806:	4293      	cmp	r3, r2
24002808:	d005      	beq.n	24002816 <HAL_DMA_IRQHandler+0x366>
2400280a:	3218      	adds	r2, #24
2400280c:	4293      	cmp	r3, r2
2400280e:	d002      	beq.n	24002816 <HAL_DMA_IRQHandler+0x366>
24002810:	3218      	adds	r2, #24
24002812:	4293      	cmp	r3, r2
24002814:	d134      	bne.n	24002880 <HAL_DMA_IRQHandler+0x3d0>
24002816:	681a      	ldr	r2, [r3, #0]
24002818:	f3c2 1200 	ubfx	r2, r2, #4, #1
2400281c:	2a00      	cmp	r2, #0
2400281e:	d03c      	beq.n	2400289a <HAL_DMA_IRQHandler+0x3ea>
        regs_dma->IFCR = DMA_FLAG_TCIF0_4 << (hdma->StreamIndex & 0x1FU);
24002820:	60a8      	str	r0, [r5, #8]
        if(HAL_DMA_STATE_ABORT == hdma->State)
24002822:	f894 2035 	ldrb.w	r2, [r4, #53]	@ 0x35
24002826:	2a04      	cmp	r2, #4
          ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME);
24002828:	681a      	ldr	r2, [r3, #0]
        if(HAL_DMA_STATE_ABORT == hdma->State)
2400282a:	d12d      	bne.n	24002888 <HAL_DMA_IRQHandler+0x3d8>
          ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME);
2400282c:	f022 0216 	bic.w	r2, r2, #22
24002830:	601a      	str	r2, [r3, #0]
          ((DMA_Stream_TypeDef   *)hdma->Instance)->FCR &= ~(DMA_IT_FE);
24002832:	695a      	ldr	r2, [r3, #20]
24002834:	f022 0280 	bic.w	r2, r2, #128	@ 0x80
24002838:	615a      	str	r2, [r3, #20]
          if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
2400283a:	6c22      	ldr	r2, [r4, #64]	@ 0x40
2400283c:	b90a      	cbnz	r2, 24002842 <HAL_DMA_IRQHandler+0x392>
2400283e:	6ca2      	ldr	r2, [r4, #72]	@ 0x48
24002840:	b11a      	cbz	r2, 2400284a <HAL_DMA_IRQHandler+0x39a>
            ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  &= ~(DMA_IT_HT);
24002842:	681a      	ldr	r2, [r3, #0]
24002844:	f022 0208 	bic.w	r2, r2, #8
24002848:	601a      	str	r2, [r3, #0]
          regs_dma->IFCR = 0x3FUL << (hdma->StreamIndex & 0x1FU);
2400284a:	233f      	movs	r3, #63	@ 0x3f
2400284c:	408b      	lsls	r3, r1
2400284e:	60ab      	str	r3, [r5, #8]
          __HAL_UNLOCK(hdma);
24002850:	2300      	movs	r3, #0
24002852:	f884 3034 	strb.w	r3, [r4, #52]	@ 0x34
          hdma->State = HAL_DMA_STATE_READY;
24002856:	2301      	movs	r3, #1
24002858:	f884 3035 	strb.w	r3, [r4, #53]	@ 0x35
          if(hdma->XferAbortCallback != NULL)
2400285c:	6d23      	ldr	r3, [r4, #80]	@ 0x50
      if (hdma->XferErrorCallback != NULL)
2400285e:	2b00      	cmp	r3, #0
24002860:	f000 808d 	beq.w	2400297e <HAL_DMA_IRQHandler+0x4ce>
        hdma->XferErrorCallback(hdma);
24002864:	4620      	mov	r0, r4
}
24002866:	b002      	add	sp, #8
24002868:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
        hdma->XferErrorCallback(hdma);
2400286c:	4718      	bx	r3
          if((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_CIRC) == 0U)
2400286e:	681a      	ldr	r2, [r3, #0]
24002870:	05d2      	lsls	r2, r2, #23
24002872:	f53f af75 	bmi.w	24002760 <HAL_DMA_IRQHandler+0x2b0>
            ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  &= ~(DMA_IT_HT);
24002876:	681a      	ldr	r2, [r3, #0]
24002878:	f022 0208 	bic.w	r2, r2, #8
2400287c:	601a      	str	r2, [r3, #0]
2400287e:	e76f      	b.n	24002760 <HAL_DMA_IRQHandler+0x2b0>
      if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TC) != 0U)
24002880:	681a      	ldr	r2, [r3, #0]
24002882:	f3c2 0240 	ubfx	r2, r2, #1, #1
24002886:	e7c9      	b.n	2400281c <HAL_DMA_IRQHandler+0x36c>
        if(((((DMA_Stream_TypeDef   *)hdma->Instance)->CR) & (uint32_t)(DMA_SxCR_DBM)) != 0U)
24002888:	0355      	lsls	r5, r2, #13
2400288a:	d54d      	bpl.n	24002928 <HAL_DMA_IRQHandler+0x478>
          if((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_CT) == 0U)
2400288c:	681b      	ldr	r3, [r3, #0]
2400288e:	0318      	lsls	r0, r3, #12
24002890:	d457      	bmi.n	24002942 <HAL_DMA_IRQHandler+0x492>
            if(hdma->XferM1CpltCallback != NULL)
24002892:	6c63      	ldr	r3, [r4, #68]	@ 0x44
          if(hdma->XferCpltCallback != NULL)
24002894:	b10b      	cbz	r3, 2400289a <HAL_DMA_IRQHandler+0x3ea>
            hdma->XferCpltCallback(hdma);
24002896:	4620      	mov	r0, r4
24002898:	4798      	blx	r3
    if(hdma->ErrorCode != HAL_DMA_ERROR_NONE)
2400289a:	6d63      	ldr	r3, [r4, #84]	@ 0x54
2400289c:	2b00      	cmp	r3, #0
2400289e:	d06e      	beq.n	2400297e <HAL_DMA_IRQHandler+0x4ce>
      if((hdma->ErrorCode & HAL_DMA_ERROR_TE) != 0U)
240028a0:	6d63      	ldr	r3, [r4, #84]	@ 0x54
240028a2:	07d9      	lsls	r1, r3, #31
240028a4:	d53e      	bpl.n	24002924 <HAL_DMA_IRQHandler+0x474>
        hdma->State = HAL_DMA_STATE_ABORT;
240028a6:	2304      	movs	r3, #4
240028a8:	f884 3035 	strb.w	r3, [r4, #53]	@ 0x35
        __HAL_DMA_DISABLE(hdma);
240028ac:	6823      	ldr	r3, [r4, #0]
240028ae:	42b3      	cmp	r3, r6
240028b0:	d01e      	beq.n	240028f0 <HAL_DMA_IRQHandler+0x440>
240028b2:	4a50      	ldr	r2, [pc, #320]	@ (240029f4 <HAL_DMA_IRQHandler+0x544>)
240028b4:	4293      	cmp	r3, r2
240028b6:	d01b      	beq.n	240028f0 <HAL_DMA_IRQHandler+0x440>
240028b8:	3218      	adds	r2, #24
240028ba:	4293      	cmp	r3, r2
240028bc:	d018      	beq.n	240028f0 <HAL_DMA_IRQHandler+0x440>
240028be:	3218      	adds	r2, #24
240028c0:	4293      	cmp	r3, r2
240028c2:	d015      	beq.n	240028f0 <HAL_DMA_IRQHandler+0x440>
240028c4:	3218      	adds	r2, #24
240028c6:	4293      	cmp	r3, r2
240028c8:	d012      	beq.n	240028f0 <HAL_DMA_IRQHandler+0x440>
240028ca:	3218      	adds	r2, #24
240028cc:	4293      	cmp	r3, r2
240028ce:	d00f      	beq.n	240028f0 <HAL_DMA_IRQHandler+0x440>
240028d0:	3218      	adds	r2, #24
240028d2:	4293      	cmp	r3, r2
240028d4:	d00c      	beq.n	240028f0 <HAL_DMA_IRQHandler+0x440>
240028d6:	3218      	adds	r2, #24
240028d8:	4293      	cmp	r3, r2
240028da:	d009      	beq.n	240028f0 <HAL_DMA_IRQHandler+0x440>
240028dc:	f502 7256 	add.w	r2, r2, #856	@ 0x358
240028e0:	4293      	cmp	r3, r2
240028e2:	d005      	beq.n	240028f0 <HAL_DMA_IRQHandler+0x440>
240028e4:	3218      	adds	r2, #24
240028e6:	4293      	cmp	r3, r2
240028e8:	d002      	beq.n	240028f0 <HAL_DMA_IRQHandler+0x440>
240028ea:	3218      	adds	r2, #24
240028ec:	4293      	cmp	r3, r2
240028ee:	d0ff      	beq.n	240028f0 <HAL_DMA_IRQHandler+0x440>
  uint32_t timeout = SystemCoreClock / 9600U;
240028f0:	f44f 5116 	mov.w	r1, #9600	@ 0x2580
        __HAL_DMA_DISABLE(hdma);
240028f4:	681a      	ldr	r2, [r3, #0]
  uint32_t timeout = SystemCoreClock / 9600U;
240028f6:	fbb7 f1f1 	udiv	r1, r7, r1
        __HAL_DMA_DISABLE(hdma);
240028fa:	f022 0201 	bic.w	r2, r2, #1
240028fe:	601a      	str	r2, [r3, #0]
          if (++count > timeout)
24002900:	9a01      	ldr	r2, [sp, #4]
24002902:	3201      	adds	r2, #1
24002904:	428a      	cmp	r2, r1
24002906:	9201      	str	r2, [sp, #4]
24002908:	d802      	bhi.n	24002910 <HAL_DMA_IRQHandler+0x460>
        while((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_EN) != 0U);
2400290a:	681a      	ldr	r2, [r3, #0]
2400290c:	07d2      	lsls	r2, r2, #31
2400290e:	d4f7      	bmi.n	24002900 <HAL_DMA_IRQHandler+0x450>
        __HAL_UNLOCK(hdma);
24002910:	2200      	movs	r2, #0
24002912:	f884 2034 	strb.w	r2, [r4, #52]	@ 0x34
        if((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_EN) != 0U)
24002916:	681b      	ldr	r3, [r3, #0]
24002918:	07df      	lsls	r7, r3, #31
          hdma->State = HAL_DMA_STATE_ERROR;
2400291a:	bf4c      	ite	mi
2400291c:	2303      	movmi	r3, #3
          hdma->State = HAL_DMA_STATE_READY;
2400291e:	2301      	movpl	r3, #1
      hdma->State = HAL_DMA_STATE_READY;
24002920:	f884 3035 	strb.w	r3, [r4, #53]	@ 0x35
      if (hdma->XferErrorCallback != NULL)
24002924:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
24002926:	e79a      	b.n	2400285e <HAL_DMA_IRQHandler+0x3ae>
          if((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_CIRC) == 0U)
24002928:	681a      	ldr	r2, [r3, #0]
2400292a:	f412 7280 	ands.w	r2, r2, #256	@ 0x100
2400292e:	d108      	bne.n	24002942 <HAL_DMA_IRQHandler+0x492>
            ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  &= ~(DMA_IT_TC);
24002930:	6819      	ldr	r1, [r3, #0]
24002932:	f021 0110 	bic.w	r1, r1, #16
24002936:	6019      	str	r1, [r3, #0]
            hdma->State = HAL_DMA_STATE_READY;
24002938:	2301      	movs	r3, #1
            __HAL_UNLOCK(hdma);
2400293a:	f884 2034 	strb.w	r2, [r4, #52]	@ 0x34
            hdma->State = HAL_DMA_STATE_READY;
2400293e:	f884 3035 	strb.w	r3, [r4, #53]	@ 0x35
          if(hdma->XferCpltCallback != NULL)
24002942:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
24002944:	e7a6      	b.n	24002894 <HAL_DMA_IRQHandler+0x3e4>
  else if(IS_BDMA_CHANNEL_INSTANCE(hdma->Instance) != 0U)  /* BDMA instance(s) */
24002946:	4a2c      	ldr	r2, [pc, #176]	@ (240029f8 <HAL_DMA_IRQHandler+0x548>)
24002948:	4293      	cmp	r3, r2
2400294a:	f43f adf3 	beq.w	24002534 <HAL_DMA_IRQHandler+0x84>
2400294e:	3214      	adds	r2, #20
24002950:	4293      	cmp	r3, r2
24002952:	f43f adef 	beq.w	24002534 <HAL_DMA_IRQHandler+0x84>
24002956:	3214      	adds	r2, #20
24002958:	4293      	cmp	r3, r2
2400295a:	f43f adeb 	beq.w	24002534 <HAL_DMA_IRQHandler+0x84>
2400295e:	3214      	adds	r2, #20
24002960:	4293      	cmp	r3, r2
24002962:	f43f ade7 	beq.w	24002534 <HAL_DMA_IRQHandler+0x84>
24002966:	3214      	adds	r2, #20
24002968:	4293      	cmp	r3, r2
2400296a:	f43f ade3 	beq.w	24002534 <HAL_DMA_IRQHandler+0x84>
2400296e:	3214      	adds	r2, #20
24002970:	4293      	cmp	r3, r2
24002972:	f43f addf 	beq.w	24002534 <HAL_DMA_IRQHandler+0x84>
24002976:	3214      	adds	r2, #20
24002978:	4293      	cmp	r3, r2
2400297a:	f43f addb 	beq.w	24002534 <HAL_DMA_IRQHandler+0x84>
}
2400297e:	b002      	add	sp, #8
24002980:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        if((ccr_reg & BDMA_CCR_CIRC) == 0U)
24002984:	0697      	lsls	r7, r2, #26
24002986:	d403      	bmi.n	24002990 <HAL_DMA_IRQHandler+0x4e0>
          __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
24002988:	681a      	ldr	r2, [r3, #0]
2400298a:	f022 0204 	bic.w	r2, r2, #4
2400298e:	601a      	str	r2, [r3, #0]
       if(hdma->XferHalfCpltCallback != NULL)
24002990:	6c23      	ldr	r3, [r4, #64]	@ 0x40
24002992:	e764      	b.n	2400285e <HAL_DMA_IRQHandler+0x3ae>
    else if (((tmpisr_bdma & (BDMA_FLAG_TC0 << (hdma->StreamIndex & 0x1FU))) != 0U) && ((ccr_reg & BDMA_CCR_TCIE) != 0U))
24002994:	2002      	movs	r0, #2
24002996:	4088      	lsls	r0, r1
24002998:	ea10 0f0c 	tst.w	r0, ip
2400299c:	d016      	beq.n	240029cc <HAL_DMA_IRQHandler+0x51c>
2400299e:	0796      	lsls	r6, r2, #30
240029a0:	d514      	bpl.n	240029cc <HAL_DMA_IRQHandler+0x51c>
      regs_bdma->IFCR = (BDMA_ISR_TCIF0) << (hdma->StreamIndex & 0x1FU);
240029a2:	6068      	str	r0, [r5, #4]
      if((ccr_reg & BDMA_CCR_DBM) != 0U)
240029a4:	0410      	lsls	r0, r2, #16
240029a6:	d503      	bpl.n	240029b0 <HAL_DMA_IRQHandler+0x500>
        if((ccr_reg & BDMA_CCR_CT) == 0U)
240029a8:	03d1      	lsls	r1, r2, #15
240029aa:	d40d      	bmi.n	240029c8 <HAL_DMA_IRQHandler+0x518>
          if(hdma->XferM1CpltCallback != NULL)
240029ac:	6c63      	ldr	r3, [r4, #68]	@ 0x44
240029ae:	e756      	b.n	2400285e <HAL_DMA_IRQHandler+0x3ae>
        if((ccr_reg & BDMA_CCR_CIRC) == 0U)
240029b0:	f012 0220 	ands.w	r2, r2, #32
240029b4:	d108      	bne.n	240029c8 <HAL_DMA_IRQHandler+0x518>
          __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TE | DMA_IT_TC);
240029b6:	6819      	ldr	r1, [r3, #0]
240029b8:	f021 010a 	bic.w	r1, r1, #10
240029bc:	6019      	str	r1, [r3, #0]
          hdma->State = HAL_DMA_STATE_READY;
240029be:	2301      	movs	r3, #1
          __HAL_UNLOCK(hdma);
240029c0:	f884 2034 	strb.w	r2, [r4, #52]	@ 0x34
          hdma->State = HAL_DMA_STATE_READY;
240029c4:	f884 3035 	strb.w	r3, [r4, #53]	@ 0x35
        if(hdma->XferCpltCallback != NULL)
240029c8:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
240029ca:	e748      	b.n	2400285e <HAL_DMA_IRQHandler+0x3ae>
    else if (((tmpisr_bdma & (BDMA_FLAG_TE0 << (hdma->StreamIndex & 0x1FU))) != 0U) && ((ccr_reg & BDMA_CCR_TEIE) != 0U))
240029cc:	2008      	movs	r0, #8
240029ce:	4088      	lsls	r0, r1
240029d0:	ea10 0f0c 	tst.w	r0, ip
240029d4:	d0d3      	beq.n	2400297e <HAL_DMA_IRQHandler+0x4ce>
240029d6:	0712      	lsls	r2, r2, #28
240029d8:	d5d1      	bpl.n	2400297e <HAL_DMA_IRQHandler+0x4ce>
      __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
240029da:	681a      	ldr	r2, [r3, #0]
240029dc:	f022 020e 	bic.w	r2, r2, #14
240029e0:	601a      	str	r2, [r3, #0]
      regs_bdma->IFCR = (BDMA_ISR_GIF0) << (hdma->StreamIndex & 0x1FU);
240029e2:	2301      	movs	r3, #1
      __HAL_UNLOCK(hdma);
240029e4:	2200      	movs	r2, #0
      regs_bdma->IFCR = (BDMA_ISR_GIF0) << (hdma->StreamIndex & 0x1FU);
240029e6:	fa03 f101 	lsl.w	r1, r3, r1
240029ea:	6069      	str	r1, [r5, #4]
      hdma->ErrorCode = HAL_DMA_ERROR_TE;
240029ec:	6563      	str	r3, [r4, #84]	@ 0x54
      __HAL_UNLOCK(hdma);
240029ee:	f884 2034 	strb.w	r2, [r4, #52]	@ 0x34
240029f2:	e795      	b.n	24002920 <HAL_DMA_IRQHandler+0x470>
240029f4:	40020028 	.word	0x40020028
240029f8:	5802541c 	.word	0x5802541c

240029fc <HAL_DMA_RegisterCallback>:
  if(hdma == NULL)
240029fc:	4603      	mov	r3, r0
240029fe:	b300      	cbz	r0, 24002a42 <HAL_DMA_RegisterCallback+0x46>
  __HAL_LOCK(hdma);
24002a00:	f890 0034 	ldrb.w	r0, [r0, #52]	@ 0x34
24002a04:	2801      	cmp	r0, #1
24002a06:	d01e      	beq.n	24002a46 <HAL_DMA_RegisterCallback+0x4a>
  if(HAL_DMA_STATE_READY == hdma->State)
24002a08:	f893 0035 	ldrb.w	r0, [r3, #53]	@ 0x35
24002a0c:	2801      	cmp	r0, #1
24002a0e:	d116      	bne.n	24002a3e <HAL_DMA_RegisterCallback+0x42>
    switch (CallbackID)
24002a10:	2905      	cmp	r1, #5
24002a12:	d805      	bhi.n	24002a20 <HAL_DMA_RegisterCallback+0x24>
24002a14:	e8df f001 	tbb	[pc, r1]
24002a18:	0d0b0903 	.word	0x0d0b0903
24002a1c:	110f      	.short	0x110f
      hdma->XferCpltCallback = pCallback;
24002a1e:	63da      	str	r2, [r3, #60]	@ 0x3c
  HAL_StatusTypeDef status = HAL_OK;
24002a20:	2000      	movs	r0, #0
  __HAL_UNLOCK(hdma);
24002a22:	2200      	movs	r2, #0
24002a24:	f883 2034 	strb.w	r2, [r3, #52]	@ 0x34
  return status;
24002a28:	4770      	bx	lr
      hdma->XferHalfCpltCallback = pCallback;
24002a2a:	641a      	str	r2, [r3, #64]	@ 0x40
      break;
24002a2c:	e7f8      	b.n	24002a20 <HAL_DMA_RegisterCallback+0x24>
      hdma->XferM1CpltCallback = pCallback;
24002a2e:	645a      	str	r2, [r3, #68]	@ 0x44
      break;
24002a30:	e7f6      	b.n	24002a20 <HAL_DMA_RegisterCallback+0x24>
      hdma->XferM1HalfCpltCallback = pCallback;
24002a32:	649a      	str	r2, [r3, #72]	@ 0x48
      break;
24002a34:	e7f4      	b.n	24002a20 <HAL_DMA_RegisterCallback+0x24>
      hdma->XferErrorCallback = pCallback;
24002a36:	64da      	str	r2, [r3, #76]	@ 0x4c
      break;
24002a38:	e7f2      	b.n	24002a20 <HAL_DMA_RegisterCallback+0x24>
      hdma->XferAbortCallback = pCallback;
24002a3a:	651a      	str	r2, [r3, #80]	@ 0x50
      break;
24002a3c:	e7f0      	b.n	24002a20 <HAL_DMA_RegisterCallback+0x24>
    status =  HAL_ERROR;
24002a3e:	2001      	movs	r0, #1
24002a40:	e7ef      	b.n	24002a22 <HAL_DMA_RegisterCallback+0x26>
    return HAL_ERROR;
24002a42:	2001      	movs	r0, #1
24002a44:	4770      	bx	lr
  __HAL_LOCK(hdma);
24002a46:	2002      	movs	r0, #2
}
24002a48:	4770      	bx	lr

24002a4a <HAL_DMA_UnRegisterCallback>:
  if(hdma == NULL)
24002a4a:	4603      	mov	r3, r0
{
24002a4c:	b510      	push	{r4, lr}
  if(hdma == NULL)
24002a4e:	b358      	cbz	r0, 24002aa8 <HAL_DMA_UnRegisterCallback+0x5e>
  __HAL_LOCK(hdma);
24002a50:	f890 2034 	ldrb.w	r2, [r0, #52]	@ 0x34
24002a54:	2a01      	cmp	r2, #1
24002a56:	d029      	beq.n	24002aac <HAL_DMA_UnRegisterCallback+0x62>
24002a58:	2201      	movs	r2, #1
  if(HAL_DMA_STATE_READY == hdma->State)
24002a5a:	f890 4035 	ldrb.w	r4, [r0, #53]	@ 0x35
24002a5e:	4294      	cmp	r4, r2
  __HAL_LOCK(hdma);
24002a60:	f880 2034 	strb.w	r2, [r0, #52]	@ 0x34
  if(HAL_DMA_STATE_READY == hdma->State)
24002a64:	b2e0      	uxtb	r0, r4
24002a66:	d11d      	bne.n	24002aa4 <HAL_DMA_UnRegisterCallback+0x5a>
    switch (CallbackID)
24002a68:	2200      	movs	r2, #0
24002a6a:	2906      	cmp	r1, #6
24002a6c:	d807      	bhi.n	24002a7e <HAL_DMA_UnRegisterCallback+0x34>
24002a6e:	e8df f001 	tbb	[pc, r1]
24002a72:	0a04      	.short	0x0a04
24002a74:	17100e0c 	.word	0x17100e0c
24002a78:	12          	.byte	0x12
24002a79:	00          	.byte	0x00
      hdma->XferCpltCallback = NULL;
24002a7a:	63da      	str	r2, [r3, #60]	@ 0x3c
  HAL_StatusTypeDef status = HAL_OK;
24002a7c:	2000      	movs	r0, #0
  __HAL_UNLOCK(hdma);
24002a7e:	2200      	movs	r2, #0
24002a80:	f883 2034 	strb.w	r2, [r3, #52]	@ 0x34
}
24002a84:	bd10      	pop	{r4, pc}
      hdma->XferHalfCpltCallback = NULL;
24002a86:	641a      	str	r2, [r3, #64]	@ 0x40
      break;
24002a88:	e7f8      	b.n	24002a7c <HAL_DMA_UnRegisterCallback+0x32>
      hdma->XferM1CpltCallback = NULL;
24002a8a:	645a      	str	r2, [r3, #68]	@ 0x44
      break;
24002a8c:	e7f6      	b.n	24002a7c <HAL_DMA_UnRegisterCallback+0x32>
      hdma->XferM1HalfCpltCallback = NULL;
24002a8e:	649a      	str	r2, [r3, #72]	@ 0x48
      break;
24002a90:	e7f4      	b.n	24002a7c <HAL_DMA_UnRegisterCallback+0x32>
      hdma->XferErrorCallback = NULL;
24002a92:	64da      	str	r2, [r3, #76]	@ 0x4c
      break;
24002a94:	e7f2      	b.n	24002a7c <HAL_DMA_UnRegisterCallback+0x32>
      hdma->XferHalfCpltCallback = NULL;
24002a96:	e9c3 220f 	strd	r2, r2, [r3, #60]	@ 0x3c
      hdma->XferM1HalfCpltCallback = NULL;
24002a9a:	e9c3 2211 	strd	r2, r2, [r3, #68]	@ 0x44
      hdma->XferErrorCallback = NULL;
24002a9e:	64da      	str	r2, [r3, #76]	@ 0x4c
      hdma->XferAbortCallback = NULL;
24002aa0:	651a      	str	r2, [r3, #80]	@ 0x50
      break;
24002aa2:	e7eb      	b.n	24002a7c <HAL_DMA_UnRegisterCallback+0x32>
24002aa4:	4610      	mov	r0, r2
24002aa6:	e7ea      	b.n	24002a7e <HAL_DMA_UnRegisterCallback+0x34>
    return HAL_ERROR;
24002aa8:	2001      	movs	r0, #1
24002aaa:	e7eb      	b.n	24002a84 <HAL_DMA_UnRegisterCallback+0x3a>
  __HAL_LOCK(hdma);
24002aac:	2002      	movs	r0, #2
24002aae:	e7e9      	b.n	24002a84 <HAL_DMA_UnRegisterCallback+0x3a>

24002ab0 <HAL_DMA_GetState>:
  return hdma->State;
24002ab0:	f890 0035 	ldrb.w	r0, [r0, #53]	@ 0x35
}
24002ab4:	4770      	bx	lr

24002ab6 <HAL_DMA_GetError>:
  return hdma->ErrorCode;
24002ab6:	6d40      	ldr	r0, [r0, #84]	@ 0x54
}
24002ab8:	4770      	bx	lr
24002aba:	bf00      	nop

24002abc <DMA_MultiBufferSetConfig>:
  * @param  DstAddress: The destination memory Buffer address
  * @param  DataLength: The length of data to be transferred from source to destination
  * @retval HAL status
  */
static void DMA_MultiBufferSetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{
24002abc:	b530      	push	{r4, r5, lr}
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
24002abe:	6804      	ldr	r4, [r0, #0]
24002ac0:	4d15      	ldr	r5, [pc, #84]	@ (24002b18 <DMA_MultiBufferSetConfig+0x5c>)
  {
    /* Configure DMA Stream data length */
    ((BDMA_Channel_TypeDef   *)hdma->Instance)->CNDTR = DataLength;

    /* Peripheral to Memory */
    if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
24002ac2:	6880      	ldr	r0, [r0, #8]
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
24002ac4:	42ac      	cmp	r4, r5
24002ac6:	d01e      	beq.n	24002b06 <DMA_MultiBufferSetConfig+0x4a>
24002ac8:	3518      	adds	r5, #24
24002aca:	42ac      	cmp	r4, r5
24002acc:	d01b      	beq.n	24002b06 <DMA_MultiBufferSetConfig+0x4a>
24002ace:	3518      	adds	r5, #24
24002ad0:	42ac      	cmp	r4, r5
24002ad2:	d018      	beq.n	24002b06 <DMA_MultiBufferSetConfig+0x4a>
24002ad4:	3518      	adds	r5, #24
24002ad6:	42ac      	cmp	r4, r5
24002ad8:	d015      	beq.n	24002b06 <DMA_MultiBufferSetConfig+0x4a>
24002ada:	3518      	adds	r5, #24
24002adc:	42ac      	cmp	r4, r5
24002ade:	d012      	beq.n	24002b06 <DMA_MultiBufferSetConfig+0x4a>
24002ae0:	3518      	adds	r5, #24
24002ae2:	42ac      	cmp	r4, r5
24002ae4:	d00f      	beq.n	24002b06 <DMA_MultiBufferSetConfig+0x4a>
24002ae6:	3518      	adds	r5, #24
24002ae8:	42ac      	cmp	r4, r5
24002aea:	d00c      	beq.n	24002b06 <DMA_MultiBufferSetConfig+0x4a>
24002aec:	3518      	adds	r5, #24
24002aee:	42ac      	cmp	r4, r5
24002af0:	d009      	beq.n	24002b06 <DMA_MultiBufferSetConfig+0x4a>
24002af2:	f505 7556 	add.w	r5, r5, #856	@ 0x358
24002af6:	42ac      	cmp	r4, r5
24002af8:	d005      	beq.n	24002b06 <DMA_MultiBufferSetConfig+0x4a>
24002afa:	3518      	adds	r5, #24
24002afc:	42ac      	cmp	r4, r5
24002afe:	d002      	beq.n	24002b06 <DMA_MultiBufferSetConfig+0x4a>
24002b00:	3518      	adds	r5, #24
24002b02:	42ac      	cmp	r4, r5
24002b04:	d0ff      	beq.n	24002b06 <DMA_MultiBufferSetConfig+0x4a>
    if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
24002b06:	2840      	cmp	r0, #64	@ 0x40
    ((DMA_Stream_TypeDef   *)hdma->Instance)->NDTR = DataLength;
24002b08:	6063      	str	r3, [r4, #4]
    if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
24002b0a:	d102      	bne.n	24002b12 <DMA_MultiBufferSetConfig+0x56>
    {
      /* Configure DMA Stream destination address */
      ((BDMA_Channel_TypeDef   *)hdma->Instance)->CPAR = DstAddress;
24002b0c:	60a2      	str	r2, [r4, #8]

      /* Configure DMA Stream source address */
      ((BDMA_Channel_TypeDef   *)hdma->Instance)->CM0AR = SrcAddress;
24002b0e:	60e1      	str	r1, [r4, #12]

      /* Configure DMA Stream destination address */
      ((BDMA_Channel_TypeDef   *)hdma->Instance)->CM0AR = DstAddress;
    }
  }
}
24002b10:	bd30      	pop	{r4, r5, pc}
      ((BDMA_Channel_TypeDef   *)hdma->Instance)->CPAR = SrcAddress;
24002b12:	60a1      	str	r1, [r4, #8]
      ((BDMA_Channel_TypeDef   *)hdma->Instance)->CM0AR = DstAddress;
24002b14:	60e2      	str	r2, [r4, #12]
}
24002b16:	e7fb      	b.n	24002b10 <DMA_MultiBufferSetConfig+0x54>
24002b18:	40020010 	.word	0x40020010

24002b1c <HAL_DMAEx_MultiBufferStart>:
{
24002b1c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
24002b1e:	4605      	mov	r5, r0
  if (hdma->Init.Direction == DMA_MEMORY_TO_MEMORY)
24002b20:	6880      	ldr	r0, [r0, #8]
24002b22:	2880      	cmp	r0, #128	@ 0x80
24002b24:	d104      	bne.n	24002b30 <HAL_DMAEx_MultiBufferStart+0x14>
    hdma->ErrorCode = HAL_DMA_ERROR_NOT_SUPPORTED;
24002b26:	f44f 7380 	mov.w	r3, #256	@ 0x100
    status = HAL_ERROR;
24002b2a:	2001      	movs	r0, #1
      hdma->ErrorCode = HAL_DMA_ERROR_BUSY;
24002b2c:	656b      	str	r3, [r5, #84]	@ 0x54
      status = HAL_ERROR;
24002b2e:	e06f      	b.n	24002c10 <HAL_DMAEx_MultiBufferStart+0xf4>
    __HAL_LOCK(hdma);
24002b30:	f895 0034 	ldrb.w	r0, [r5, #52]	@ 0x34
24002b34:	2801      	cmp	r0, #1
24002b36:	f000 80db 	beq.w	24002cf0 <HAL_DMAEx_MultiBufferStart+0x1d4>
24002b3a:	2001      	movs	r0, #1
24002b3c:	f885 0034 	strb.w	r0, [r5, #52]	@ 0x34
    if(HAL_DMA_STATE_READY == hdma->State)
24002b40:	f895 0035 	ldrb.w	r0, [r5, #53]	@ 0x35
24002b44:	2801      	cmp	r0, #1
24002b46:	f040 80d0 	bne.w	24002cea <HAL_DMAEx_MultiBufferStart+0x1ce>
      hdma->State = HAL_DMA_STATE_BUSY;
24002b4a:	2002      	movs	r0, #2
      if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
24002b4c:	682c      	ldr	r4, [r5, #0]
24002b4e:	4f69      	ldr	r7, [pc, #420]	@ (24002cf4 <HAL_DMAEx_MultiBufferStart+0x1d8>)
      hdma->State = HAL_DMA_STATE_BUSY;
24002b50:	f885 0035 	strb.w	r0, [r5, #53]	@ 0x35
      hdma->ErrorCode = HAL_DMA_ERROR_NONE;
24002b54:	2000      	movs	r0, #0
      if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
24002b56:	42bc      	cmp	r4, r7
      hdma->ErrorCode = HAL_DMA_ERROR_NONE;
24002b58:	6568      	str	r0, [r5, #84]	@ 0x54
        *ifcRegister_Base = (BDMA_ISR_GIF0) << (hdma->StreamIndex & 0x1FU);
24002b5a:	e9d5 c616 	ldrd	ip, r6, [r5, #88]	@ 0x58
24002b5e:	f006 061f 	and.w	r6, r6, #31
      if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
24002b62:	d056      	beq.n	24002c12 <HAL_DMAEx_MultiBufferStart+0xf6>
24002b64:	4864      	ldr	r0, [pc, #400]	@ (24002cf8 <HAL_DMAEx_MultiBufferStart+0x1dc>)
24002b66:	4284      	cmp	r4, r0
24002b68:	d053      	beq.n	24002c12 <HAL_DMAEx_MultiBufferStart+0xf6>
24002b6a:	3018      	adds	r0, #24
24002b6c:	4284      	cmp	r4, r0
24002b6e:	d050      	beq.n	24002c12 <HAL_DMAEx_MultiBufferStart+0xf6>
24002b70:	3018      	adds	r0, #24
24002b72:	4284      	cmp	r4, r0
24002b74:	d04d      	beq.n	24002c12 <HAL_DMAEx_MultiBufferStart+0xf6>
24002b76:	3018      	adds	r0, #24
24002b78:	4284      	cmp	r4, r0
24002b7a:	d04a      	beq.n	24002c12 <HAL_DMAEx_MultiBufferStart+0xf6>
24002b7c:	3018      	adds	r0, #24
24002b7e:	4284      	cmp	r4, r0
24002b80:	d047      	beq.n	24002c12 <HAL_DMAEx_MultiBufferStart+0xf6>
24002b82:	3018      	adds	r0, #24
24002b84:	4284      	cmp	r4, r0
24002b86:	d044      	beq.n	24002c12 <HAL_DMAEx_MultiBufferStart+0xf6>
24002b88:	3018      	adds	r0, #24
24002b8a:	4284      	cmp	r4, r0
24002b8c:	d041      	beq.n	24002c12 <HAL_DMAEx_MultiBufferStart+0xf6>
24002b8e:	f500 7056 	add.w	r0, r0, #856	@ 0x358
24002b92:	4284      	cmp	r4, r0
24002b94:	d03d      	beq.n	24002c12 <HAL_DMAEx_MultiBufferStart+0xf6>
24002b96:	3018      	adds	r0, #24
24002b98:	4284      	cmp	r4, r0
24002b9a:	d03a      	beq.n	24002c12 <HAL_DMAEx_MultiBufferStart+0xf6>
24002b9c:	3018      	adds	r0, #24
24002b9e:	4284      	cmp	r4, r0
24002ba0:	d037      	beq.n	24002c12 <HAL_DMAEx_MultiBufferStart+0xf6>
24002ba2:	3018      	adds	r0, #24
24002ba4:	4284      	cmp	r4, r0
24002ba6:	d034      	beq.n	24002c12 <HAL_DMAEx_MultiBufferStart+0xf6>
24002ba8:	3018      	adds	r0, #24
24002baa:	4284      	cmp	r4, r0
24002bac:	d031      	beq.n	24002c12 <HAL_DMAEx_MultiBufferStart+0xf6>
24002bae:	3018      	adds	r0, #24
24002bb0:	4284      	cmp	r4, r0
24002bb2:	d02e      	beq.n	24002c12 <HAL_DMAEx_MultiBufferStart+0xf6>
24002bb4:	3018      	adds	r0, #24
24002bb6:	4284      	cmp	r4, r0
24002bb8:	d02b      	beq.n	24002c12 <HAL_DMAEx_MultiBufferStart+0xf6>
24002bba:	3018      	adds	r0, #24
24002bbc:	4284      	cmp	r4, r0
24002bbe:	d028      	beq.n	24002c12 <HAL_DMAEx_MultiBufferStart+0xf6>
        ((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR |= (BDMA_CCR_DBM | BDMA_CCR_CIRC);
24002bc0:	6820      	ldr	r0, [r4, #0]
24002bc2:	f440 4000 	orr.w	r0, r0, #32768	@ 0x8000
24002bc6:	f040 0020 	orr.w	r0, r0, #32
24002bca:	6020      	str	r0, [r4, #0]
        ((BDMA_Channel_TypeDef   *)hdma->Instance)->CM1AR = SecondMemAddress;
24002bcc:	6123      	str	r3, [r4, #16]
        *ifcRegister_Base = (BDMA_ISR_GIF0) << (hdma->StreamIndex & 0x1FU);
24002bce:	2301      	movs	r3, #1
24002bd0:	40b3      	lsls	r3, r6
24002bd2:	f8cc 3004 	str.w	r3, [ip, #4]
      if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
24002bd6:	4b49      	ldr	r3, [pc, #292]	@ (24002cfc <HAL_DMAEx_MultiBufferStart+0x1e0>)
24002bd8:	429c      	cmp	r4, r3
24002bda:	d027      	beq.n	24002c2c <HAL_DMAEx_MultiBufferStart+0x110>
24002bdc:	3314      	adds	r3, #20
24002bde:	429c      	cmp	r4, r3
24002be0:	d024      	beq.n	24002c2c <HAL_DMAEx_MultiBufferStart+0x110>
24002be2:	3314      	adds	r3, #20
24002be4:	429c      	cmp	r4, r3
24002be6:	d021      	beq.n	24002c2c <HAL_DMAEx_MultiBufferStart+0x110>
24002be8:	3314      	adds	r3, #20
24002bea:	429c      	cmp	r4, r3
24002bec:	d01e      	beq.n	24002c2c <HAL_DMAEx_MultiBufferStart+0x110>
24002bee:	3314      	adds	r3, #20
24002bf0:	429c      	cmp	r4, r3
24002bf2:	d01b      	beq.n	24002c2c <HAL_DMAEx_MultiBufferStart+0x110>
24002bf4:	3314      	adds	r3, #20
24002bf6:	429c      	cmp	r4, r3
24002bf8:	d018      	beq.n	24002c2c <HAL_DMAEx_MultiBufferStart+0x110>
24002bfa:	3314      	adds	r3, #20
24002bfc:	429c      	cmp	r4, r3
24002bfe:	d015      	beq.n	24002c2c <HAL_DMAEx_MultiBufferStart+0x110>
24002c00:	3314      	adds	r3, #20
24002c02:	429c      	cmp	r4, r3
24002c04:	d012      	beq.n	24002c2c <HAL_DMAEx_MultiBufferStart+0x110>
      __HAL_DMA_ENABLE(hdma);
24002c06:	6823      	ldr	r3, [r4, #0]
  HAL_StatusTypeDef status = HAL_OK;
24002c08:	2000      	movs	r0, #0
      __HAL_DMA_ENABLE(hdma);
24002c0a:	f043 0301 	orr.w	r3, r3, #1
24002c0e:	6023      	str	r3, [r4, #0]
}
24002c10:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        ((DMA_Stream_TypeDef   *)hdma->Instance)->CR |= DMA_SxCR_DBM;
24002c12:	6820      	ldr	r0, [r4, #0]
      if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
24002c14:	42bc      	cmp	r4, r7
        ((DMA_Stream_TypeDef   *)hdma->Instance)->CR |= DMA_SxCR_DBM;
24002c16:	f440 2080 	orr.w	r0, r0, #262144	@ 0x40000
24002c1a:	6020      	str	r0, [r4, #0]
        ((DMA_Stream_TypeDef   *)hdma->Instance)->M1AR = SecondMemAddress;
24002c1c:	6123      	str	r3, [r4, #16]
        *ifcRegister_Base = 0x3FUL << (hdma->StreamIndex & 0x1FU);
24002c1e:	f04f 033f 	mov.w	r3, #63	@ 0x3f
24002c22:	fa03 f306 	lsl.w	r3, r3, r6
24002c26:	f8cc 3008 	str.w	r3, [ip, #8]
      if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
24002c2a:	d12b      	bne.n	24002c84 <HAL_DMAEx_MultiBufferStart+0x168>
        DMA_MultiBufferSetConfig(hdma, SrcAddress, DstAddress, DataLength);
24002c2c:	9b06      	ldr	r3, [sp, #24]
24002c2e:	4628      	mov	r0, r5
24002c30:	f7ff ff44 	bl	24002abc <DMA_MultiBufferSetConfig>
        hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
24002c34:	e9d5 3219 	ldrd	r3, r2, [r5, #100]	@ 0x64
24002c38:	605a      	str	r2, [r3, #4]
        if(hdma->DMAmuxRequestGen != 0U)
24002c3a:	6eeb      	ldr	r3, [r5, #108]	@ 0x6c
24002c3c:	2b00      	cmp	r3, #0
24002c3e:	d150      	bne.n	24002ce2 <HAL_DMAEx_MultiBufferStart+0x1c6>
      __HAL_DMA_ENABLE(hdma);
24002c40:	42bc      	cmp	r4, r7
24002c42:	d0e0      	beq.n	24002c06 <HAL_DMAEx_MultiBufferStart+0xea>
24002c44:	4b2c      	ldr	r3, [pc, #176]	@ (24002cf8 <HAL_DMAEx_MultiBufferStart+0x1dc>)
24002c46:	429c      	cmp	r4, r3
24002c48:	d0dd      	beq.n	24002c06 <HAL_DMAEx_MultiBufferStart+0xea>
24002c4a:	3318      	adds	r3, #24
24002c4c:	429c      	cmp	r4, r3
24002c4e:	d0da      	beq.n	24002c06 <HAL_DMAEx_MultiBufferStart+0xea>
24002c50:	3318      	adds	r3, #24
24002c52:	429c      	cmp	r4, r3
24002c54:	d0d7      	beq.n	24002c06 <HAL_DMAEx_MultiBufferStart+0xea>
24002c56:	3318      	adds	r3, #24
24002c58:	429c      	cmp	r4, r3
24002c5a:	d0d4      	beq.n	24002c06 <HAL_DMAEx_MultiBufferStart+0xea>
24002c5c:	3318      	adds	r3, #24
24002c5e:	429c      	cmp	r4, r3
24002c60:	d0d1      	beq.n	24002c06 <HAL_DMAEx_MultiBufferStart+0xea>
24002c62:	3318      	adds	r3, #24
24002c64:	429c      	cmp	r4, r3
24002c66:	d0ce      	beq.n	24002c06 <HAL_DMAEx_MultiBufferStart+0xea>
24002c68:	3318      	adds	r3, #24
24002c6a:	429c      	cmp	r4, r3
24002c6c:	d0cb      	beq.n	24002c06 <HAL_DMAEx_MultiBufferStart+0xea>
24002c6e:	f503 7356 	add.w	r3, r3, #856	@ 0x358
24002c72:	429c      	cmp	r4, r3
24002c74:	d0c7      	beq.n	24002c06 <HAL_DMAEx_MultiBufferStart+0xea>
24002c76:	3318      	adds	r3, #24
24002c78:	429c      	cmp	r4, r3
24002c7a:	d0c4      	beq.n	24002c06 <HAL_DMAEx_MultiBufferStart+0xea>
24002c7c:	3318      	adds	r3, #24
24002c7e:	429c      	cmp	r4, r3
24002c80:	d0c1      	beq.n	24002c06 <HAL_DMAEx_MultiBufferStart+0xea>
24002c82:	e7c0      	b.n	24002c06 <HAL_DMAEx_MultiBufferStart+0xea>
      if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
24002c84:	4b1c      	ldr	r3, [pc, #112]	@ (24002cf8 <HAL_DMAEx_MultiBufferStart+0x1dc>)
24002c86:	429c      	cmp	r4, r3
24002c88:	d0d0      	beq.n	24002c2c <HAL_DMAEx_MultiBufferStart+0x110>
24002c8a:	3318      	adds	r3, #24
24002c8c:	429c      	cmp	r4, r3
24002c8e:	d0cd      	beq.n	24002c2c <HAL_DMAEx_MultiBufferStart+0x110>
24002c90:	3318      	adds	r3, #24
24002c92:	429c      	cmp	r4, r3
24002c94:	d0ca      	beq.n	24002c2c <HAL_DMAEx_MultiBufferStart+0x110>
24002c96:	3318      	adds	r3, #24
24002c98:	429c      	cmp	r4, r3
24002c9a:	d0c7      	beq.n	24002c2c <HAL_DMAEx_MultiBufferStart+0x110>
24002c9c:	3318      	adds	r3, #24
24002c9e:	429c      	cmp	r4, r3
24002ca0:	d0c4      	beq.n	24002c2c <HAL_DMAEx_MultiBufferStart+0x110>
24002ca2:	3318      	adds	r3, #24
24002ca4:	429c      	cmp	r4, r3
24002ca6:	d0c1      	beq.n	24002c2c <HAL_DMAEx_MultiBufferStart+0x110>
24002ca8:	3318      	adds	r3, #24
24002caa:	429c      	cmp	r4, r3
24002cac:	d0be      	beq.n	24002c2c <HAL_DMAEx_MultiBufferStart+0x110>
24002cae:	f503 7356 	add.w	r3, r3, #856	@ 0x358
24002cb2:	429c      	cmp	r4, r3
24002cb4:	d0ba      	beq.n	24002c2c <HAL_DMAEx_MultiBufferStart+0x110>
24002cb6:	3318      	adds	r3, #24
24002cb8:	429c      	cmp	r4, r3
24002cba:	d0b7      	beq.n	24002c2c <HAL_DMAEx_MultiBufferStart+0x110>
24002cbc:	3318      	adds	r3, #24
24002cbe:	429c      	cmp	r4, r3
24002cc0:	d0b4      	beq.n	24002c2c <HAL_DMAEx_MultiBufferStart+0x110>
24002cc2:	3318      	adds	r3, #24
24002cc4:	429c      	cmp	r4, r3
24002cc6:	d0b1      	beq.n	24002c2c <HAL_DMAEx_MultiBufferStart+0x110>
24002cc8:	3318      	adds	r3, #24
24002cca:	429c      	cmp	r4, r3
24002ccc:	d0ae      	beq.n	24002c2c <HAL_DMAEx_MultiBufferStart+0x110>
24002cce:	3318      	adds	r3, #24
24002cd0:	429c      	cmp	r4, r3
24002cd2:	d0ab      	beq.n	24002c2c <HAL_DMAEx_MultiBufferStart+0x110>
24002cd4:	3318      	adds	r3, #24
24002cd6:	429c      	cmp	r4, r3
24002cd8:	d0a8      	beq.n	24002c2c <HAL_DMAEx_MultiBufferStart+0x110>
24002cda:	3318      	adds	r3, #24
24002cdc:	429c      	cmp	r4, r3
24002cde:	d0a5      	beq.n	24002c2c <HAL_DMAEx_MultiBufferStart+0x110>
24002ce0:	e779      	b.n	24002bd6 <HAL_DMAEx_MultiBufferStart+0xba>
          hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
24002ce2:	e9d5 321c 	ldrd	r3, r2, [r5, #112]	@ 0x70
24002ce6:	605a      	str	r2, [r3, #4]
24002ce8:	e7aa      	b.n	24002c40 <HAL_DMAEx_MultiBufferStart+0x124>
      hdma->ErrorCode = HAL_DMA_ERROR_BUSY;
24002cea:	f44f 6300 	mov.w	r3, #2048	@ 0x800
24002cee:	e71c      	b.n	24002b2a <HAL_DMAEx_MultiBufferStart+0xe>
    __HAL_LOCK(hdma);
24002cf0:	2002      	movs	r0, #2
24002cf2:	e78d      	b.n	24002c10 <HAL_DMAEx_MultiBufferStart+0xf4>
24002cf4:	40020010 	.word	0x40020010
24002cf8:	40020028 	.word	0x40020028
24002cfc:	58025408 	.word	0x58025408

24002d00 <HAL_DMAEx_MultiBufferStart_IT>:
{
24002d00:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
24002d02:	4605      	mov	r5, r0
  if(hdma->Init.Direction == DMA_MEMORY_TO_MEMORY)
24002d04:	6880      	ldr	r0, [r0, #8]
24002d06:	2880      	cmp	r0, #128	@ 0x80
24002d08:	d104      	bne.n	24002d14 <HAL_DMAEx_MultiBufferStart_IT+0x14>
    hdma->ErrorCode = HAL_DMA_ERROR_NOT_SUPPORTED;
24002d0a:	f44f 7380 	mov.w	r3, #256	@ 0x100
    return HAL_ERROR;
24002d0e:	2001      	movs	r0, #1
    hdma->ErrorCode = HAL_DMA_ERROR_BUSY;
24002d10:	656b      	str	r3, [r5, #84]	@ 0x54
    status = HAL_ERROR;
24002d12:	e1c5      	b.n	240030a0 <HAL_DMAEx_MultiBufferStart_IT+0x3a0>
  __HAL_LOCK(hdma);
24002d14:	f895 0034 	ldrb.w	r0, [r5, #52]	@ 0x34
24002d18:	2801      	cmp	r0, #1
24002d1a:	f000 81ca 	beq.w	240030b2 <HAL_DMAEx_MultiBufferStart_IT+0x3b2>
24002d1e:	2001      	movs	r0, #1
24002d20:	f885 0034 	strb.w	r0, [r5, #52]	@ 0x34
  if(HAL_DMA_STATE_READY == hdma->State)
24002d24:	f895 0035 	ldrb.w	r0, [r5, #53]	@ 0x35
24002d28:	2801      	cmp	r0, #1
24002d2a:	f040 81bf 	bne.w	240030ac <HAL_DMAEx_MultiBufferStart_IT+0x3ac>
    hdma->State = HAL_DMA_STATE_BUSY;
24002d2e:	2002      	movs	r0, #2
    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
24002d30:	682c      	ldr	r4, [r5, #0]
24002d32:	4e7f      	ldr	r6, [pc, #508]	@ (24002f30 <HAL_DMAEx_MultiBufferStart_IT+0x230>)
    hdma->State = HAL_DMA_STATE_BUSY;
24002d34:	f885 0035 	strb.w	r0, [r5, #53]	@ 0x35
    hdma->ErrorCode = HAL_DMA_ERROR_NONE;
24002d38:	2000      	movs	r0, #0
    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
24002d3a:	42b4      	cmp	r4, r6
    hdma->ErrorCode = HAL_DMA_ERROR_NONE;
24002d3c:	6568      	str	r0, [r5, #84]	@ 0x54
      *ifcRegister_Base = (BDMA_ISR_GIF0) << (hdma->StreamIndex & 0x1FU);
24002d3e:	e9d5 c716 	ldrd	ip, r7, [r5, #88]	@ 0x58
24002d42:	f007 071f 	and.w	r7, r7, #31
    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
24002d46:	f000 80e9 	beq.w	24002f1c <HAL_DMAEx_MultiBufferStart_IT+0x21c>
24002d4a:	487a      	ldr	r0, [pc, #488]	@ (24002f34 <HAL_DMAEx_MultiBufferStart_IT+0x234>)
24002d4c:	4284      	cmp	r4, r0
24002d4e:	f000 80e5 	beq.w	24002f1c <HAL_DMAEx_MultiBufferStart_IT+0x21c>
24002d52:	3018      	adds	r0, #24
24002d54:	4284      	cmp	r4, r0
24002d56:	f000 80e1 	beq.w	24002f1c <HAL_DMAEx_MultiBufferStart_IT+0x21c>
24002d5a:	3018      	adds	r0, #24
24002d5c:	4284      	cmp	r4, r0
24002d5e:	f000 80dd 	beq.w	24002f1c <HAL_DMAEx_MultiBufferStart_IT+0x21c>
24002d62:	3018      	adds	r0, #24
24002d64:	4284      	cmp	r4, r0
24002d66:	f000 80d9 	beq.w	24002f1c <HAL_DMAEx_MultiBufferStart_IT+0x21c>
24002d6a:	3018      	adds	r0, #24
24002d6c:	4284      	cmp	r4, r0
24002d6e:	f000 80d5 	beq.w	24002f1c <HAL_DMAEx_MultiBufferStart_IT+0x21c>
24002d72:	3018      	adds	r0, #24
24002d74:	4284      	cmp	r4, r0
24002d76:	f000 80d1 	beq.w	24002f1c <HAL_DMAEx_MultiBufferStart_IT+0x21c>
24002d7a:	3018      	adds	r0, #24
24002d7c:	4284      	cmp	r4, r0
24002d7e:	f000 80cd 	beq.w	24002f1c <HAL_DMAEx_MultiBufferStart_IT+0x21c>
24002d82:	f500 7056 	add.w	r0, r0, #856	@ 0x358
24002d86:	4284      	cmp	r4, r0
24002d88:	f000 80c8 	beq.w	24002f1c <HAL_DMAEx_MultiBufferStart_IT+0x21c>
24002d8c:	3018      	adds	r0, #24
24002d8e:	4284      	cmp	r4, r0
24002d90:	f000 80c4 	beq.w	24002f1c <HAL_DMAEx_MultiBufferStart_IT+0x21c>
24002d94:	3018      	adds	r0, #24
24002d96:	4284      	cmp	r4, r0
24002d98:	f000 80c0 	beq.w	24002f1c <HAL_DMAEx_MultiBufferStart_IT+0x21c>
24002d9c:	3018      	adds	r0, #24
24002d9e:	4284      	cmp	r4, r0
24002da0:	f000 80bc 	beq.w	24002f1c <HAL_DMAEx_MultiBufferStart_IT+0x21c>
24002da4:	3018      	adds	r0, #24
24002da6:	4284      	cmp	r4, r0
24002da8:	f000 80b8 	beq.w	24002f1c <HAL_DMAEx_MultiBufferStart_IT+0x21c>
24002dac:	3018      	adds	r0, #24
24002dae:	4284      	cmp	r4, r0
24002db0:	f000 80b4 	beq.w	24002f1c <HAL_DMAEx_MultiBufferStart_IT+0x21c>
24002db4:	3018      	adds	r0, #24
24002db6:	4284      	cmp	r4, r0
24002db8:	f000 80b0 	beq.w	24002f1c <HAL_DMAEx_MultiBufferStart_IT+0x21c>
24002dbc:	3018      	adds	r0, #24
24002dbe:	4284      	cmp	r4, r0
24002dc0:	f000 80ac 	beq.w	24002f1c <HAL_DMAEx_MultiBufferStart_IT+0x21c>
      ((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR |= (BDMA_CCR_DBM | BDMA_CCR_CIRC);
24002dc4:	6820      	ldr	r0, [r4, #0]
24002dc6:	f440 4000 	orr.w	r0, r0, #32768	@ 0x8000
24002dca:	f040 0020 	orr.w	r0, r0, #32
24002dce:	6020      	str	r0, [r4, #0]
      ((BDMA_Channel_TypeDef   *)hdma->Instance)->CM1AR = SecondMemAddress;
24002dd0:	6123      	str	r3, [r4, #16]
      *ifcRegister_Base = (BDMA_ISR_GIF0) << (hdma->StreamIndex & 0x1FU);
24002dd2:	2301      	movs	r3, #1
24002dd4:	40bb      	lsls	r3, r7
24002dd6:	f8cc 3004 	str.w	r3, [ip, #4]
    DMA_MultiBufferSetConfig(hdma, SrcAddress, DstAddress, DataLength);
24002dda:	9b06      	ldr	r3, [sp, #24]
24002ddc:	4628      	mov	r0, r5
24002dde:	f7ff fe6d 	bl	24002abc <DMA_MultiBufferSetConfig>
    if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
24002de2:	42b4      	cmp	r4, r6
24002de4:	6c2a      	ldr	r2, [r5, #64]	@ 0x40
24002de6:	f000 80a9 	beq.w	24002f3c <HAL_DMAEx_MultiBufferStart_IT+0x23c>
24002dea:	4b52      	ldr	r3, [pc, #328]	@ (24002f34 <HAL_DMAEx_MultiBufferStart_IT+0x234>)
24002dec:	429c      	cmp	r4, r3
24002dee:	f000 80a5 	beq.w	24002f3c <HAL_DMAEx_MultiBufferStart_IT+0x23c>
24002df2:	3318      	adds	r3, #24
24002df4:	429c      	cmp	r4, r3
24002df6:	f000 80a1 	beq.w	24002f3c <HAL_DMAEx_MultiBufferStart_IT+0x23c>
24002dfa:	3318      	adds	r3, #24
24002dfc:	429c      	cmp	r4, r3
24002dfe:	f000 809d 	beq.w	24002f3c <HAL_DMAEx_MultiBufferStart_IT+0x23c>
24002e02:	3318      	adds	r3, #24
24002e04:	429c      	cmp	r4, r3
24002e06:	f000 8099 	beq.w	24002f3c <HAL_DMAEx_MultiBufferStart_IT+0x23c>
24002e0a:	3318      	adds	r3, #24
24002e0c:	429c      	cmp	r4, r3
24002e0e:	f000 8095 	beq.w	24002f3c <HAL_DMAEx_MultiBufferStart_IT+0x23c>
24002e12:	3318      	adds	r3, #24
24002e14:	429c      	cmp	r4, r3
24002e16:	f000 8091 	beq.w	24002f3c <HAL_DMAEx_MultiBufferStart_IT+0x23c>
24002e1a:	3318      	adds	r3, #24
24002e1c:	429c      	cmp	r4, r3
24002e1e:	f000 808d 	beq.w	24002f3c <HAL_DMAEx_MultiBufferStart_IT+0x23c>
24002e22:	f503 7356 	add.w	r3, r3, #856	@ 0x358
24002e26:	429c      	cmp	r4, r3
24002e28:	f000 8088 	beq.w	24002f3c <HAL_DMAEx_MultiBufferStart_IT+0x23c>
24002e2c:	3318      	adds	r3, #24
24002e2e:	429c      	cmp	r4, r3
24002e30:	f000 8084 	beq.w	24002f3c <HAL_DMAEx_MultiBufferStart_IT+0x23c>
24002e34:	3318      	adds	r3, #24
24002e36:	429c      	cmp	r4, r3
24002e38:	f000 8080 	beq.w	24002f3c <HAL_DMAEx_MultiBufferStart_IT+0x23c>
24002e3c:	3318      	adds	r3, #24
24002e3e:	429c      	cmp	r4, r3
24002e40:	d07c      	beq.n	24002f3c <HAL_DMAEx_MultiBufferStart_IT+0x23c>
24002e42:	3318      	adds	r3, #24
24002e44:	429c      	cmp	r4, r3
24002e46:	d079      	beq.n	24002f3c <HAL_DMAEx_MultiBufferStart_IT+0x23c>
24002e48:	3318      	adds	r3, #24
24002e4a:	429c      	cmp	r4, r3
24002e4c:	d076      	beq.n	24002f3c <HAL_DMAEx_MultiBufferStart_IT+0x23c>
24002e4e:	3318      	adds	r3, #24
24002e50:	429c      	cmp	r4, r3
24002e52:	d073      	beq.n	24002f3c <HAL_DMAEx_MultiBufferStart_IT+0x23c>
24002e54:	3318      	adds	r3, #24
24002e56:	429c      	cmp	r4, r3
24002e58:	d070      	beq.n	24002f3c <HAL_DMAEx_MultiBufferStart_IT+0x23c>
24002e5a:	4b37      	ldr	r3, [pc, #220]	@ (24002f38 <HAL_DMAEx_MultiBufferStart_IT+0x238>)
24002e5c:	429c      	cmp	r4, r3
24002e5e:	d06d      	beq.n	24002f3c <HAL_DMAEx_MultiBufferStart_IT+0x23c>
24002e60:	3314      	adds	r3, #20
24002e62:	429c      	cmp	r4, r3
24002e64:	d06a      	beq.n	24002f3c <HAL_DMAEx_MultiBufferStart_IT+0x23c>
24002e66:	3314      	adds	r3, #20
24002e68:	429c      	cmp	r4, r3
24002e6a:	d067      	beq.n	24002f3c <HAL_DMAEx_MultiBufferStart_IT+0x23c>
24002e6c:	3314      	adds	r3, #20
24002e6e:	429c      	cmp	r4, r3
24002e70:	d064      	beq.n	24002f3c <HAL_DMAEx_MultiBufferStart_IT+0x23c>
24002e72:	3314      	adds	r3, #20
24002e74:	429c      	cmp	r4, r3
24002e76:	d061      	beq.n	24002f3c <HAL_DMAEx_MultiBufferStart_IT+0x23c>
24002e78:	3314      	adds	r3, #20
24002e7a:	429c      	cmp	r4, r3
24002e7c:	d05e      	beq.n	24002f3c <HAL_DMAEx_MultiBufferStart_IT+0x23c>
24002e7e:	3314      	adds	r3, #20
24002e80:	429c      	cmp	r4, r3
24002e82:	d05b      	beq.n	24002f3c <HAL_DMAEx_MultiBufferStart_IT+0x23c>
24002e84:	3314      	adds	r3, #20
24002e86:	429c      	cmp	r4, r3
24002e88:	d058      	beq.n	24002f3c <HAL_DMAEx_MultiBufferStart_IT+0x23c>
      MODIFY_REG(((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR, (BDMA_CCR_TCIE | BDMA_CCR_HTIE | BDMA_CCR_TEIE), (BDMA_CCR_TCIE | BDMA_CCR_TEIE));
24002e8a:	6823      	ldr	r3, [r4, #0]
24002e8c:	f023 030e 	bic.w	r3, r3, #14
24002e90:	f043 030a 	orr.w	r3, r3, #10
24002e94:	6023      	str	r3, [r4, #0]
      if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
24002e96:	2a00      	cmp	r2, #0
24002e98:	f040 80d9 	bne.w	2400304e <HAL_DMAEx_MultiBufferStart_IT+0x34e>
24002e9c:	6cab      	ldr	r3, [r5, #72]	@ 0x48
24002e9e:	2b00      	cmp	r3, #0
24002ea0:	f040 80d5 	bne.w	2400304e <HAL_DMAEx_MultiBufferStart_IT+0x34e>
    if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
24002ea4:	4b24      	ldr	r3, [pc, #144]	@ (24002f38 <HAL_DMAEx_MultiBufferStart_IT+0x238>)
24002ea6:	429c      	cmp	r4, r3
24002ea8:	f040 80d9 	bne.w	2400305e <HAL_DMAEx_MultiBufferStart_IT+0x35e>
      if((hdma->DMAmuxChannel->CCR & DMAMUX_CxCR_SE) != 0U)
24002eac:	6e2b      	ldr	r3, [r5, #96]	@ 0x60
24002eae:	681a      	ldr	r2, [r3, #0]
24002eb0:	03d2      	lsls	r2, r2, #15
24002eb2:	f100 80f6 	bmi.w	240030a2 <HAL_DMAEx_MultiBufferStart_IT+0x3a2>
      if(hdma->DMAmuxRequestGen != 0U)
24002eb6:	6eeb      	ldr	r3, [r5, #108]	@ 0x6c
24002eb8:	b11b      	cbz	r3, 24002ec2 <HAL_DMAEx_MultiBufferStart_IT+0x1c2>
        hdma->DMAmuxRequestGen->RGCR |= DMAMUX_RGxCR_OIE;
24002eba:	681a      	ldr	r2, [r3, #0]
24002ebc:	f442 7280 	orr.w	r2, r2, #256	@ 0x100
24002ec0:	601a      	str	r2, [r3, #0]
    __HAL_DMA_ENABLE(hdma);
24002ec2:	42b4      	cmp	r4, r6
24002ec4:	f000 80e7 	beq.w	24003096 <HAL_DMAEx_MultiBufferStart_IT+0x396>
24002ec8:	4b1a      	ldr	r3, [pc, #104]	@ (24002f34 <HAL_DMAEx_MultiBufferStart_IT+0x234>)
24002eca:	429c      	cmp	r4, r3
24002ecc:	f000 80e3 	beq.w	24003096 <HAL_DMAEx_MultiBufferStart_IT+0x396>
24002ed0:	3318      	adds	r3, #24
24002ed2:	429c      	cmp	r4, r3
24002ed4:	f000 80df 	beq.w	24003096 <HAL_DMAEx_MultiBufferStart_IT+0x396>
24002ed8:	3318      	adds	r3, #24
24002eda:	429c      	cmp	r4, r3
24002edc:	f000 80db 	beq.w	24003096 <HAL_DMAEx_MultiBufferStart_IT+0x396>
24002ee0:	3318      	adds	r3, #24
24002ee2:	429c      	cmp	r4, r3
24002ee4:	f000 80d7 	beq.w	24003096 <HAL_DMAEx_MultiBufferStart_IT+0x396>
24002ee8:	3318      	adds	r3, #24
24002eea:	429c      	cmp	r4, r3
24002eec:	f000 80d3 	beq.w	24003096 <HAL_DMAEx_MultiBufferStart_IT+0x396>
24002ef0:	3318      	adds	r3, #24
24002ef2:	429c      	cmp	r4, r3
24002ef4:	f000 80cf 	beq.w	24003096 <HAL_DMAEx_MultiBufferStart_IT+0x396>
24002ef8:	3318      	adds	r3, #24
24002efa:	429c      	cmp	r4, r3
24002efc:	f000 80cb 	beq.w	24003096 <HAL_DMAEx_MultiBufferStart_IT+0x396>
24002f00:	f503 7356 	add.w	r3, r3, #856	@ 0x358
24002f04:	429c      	cmp	r4, r3
24002f06:	f000 80c6 	beq.w	24003096 <HAL_DMAEx_MultiBufferStart_IT+0x396>
24002f0a:	3318      	adds	r3, #24
24002f0c:	429c      	cmp	r4, r3
24002f0e:	f000 80c2 	beq.w	24003096 <HAL_DMAEx_MultiBufferStart_IT+0x396>
24002f12:	3318      	adds	r3, #24
24002f14:	429c      	cmp	r4, r3
24002f16:	f000 80be 	beq.w	24003096 <HAL_DMAEx_MultiBufferStart_IT+0x396>
24002f1a:	e0bc      	b.n	24003096 <HAL_DMAEx_MultiBufferStart_IT+0x396>
      ((DMA_Stream_TypeDef   *)hdma->Instance)->CR |= DMA_SxCR_DBM;
24002f1c:	6820      	ldr	r0, [r4, #0]
24002f1e:	f440 2080 	orr.w	r0, r0, #262144	@ 0x40000
24002f22:	6020      	str	r0, [r4, #0]
      ((DMA_Stream_TypeDef   *)hdma->Instance)->M1AR = SecondMemAddress;
24002f24:	6123      	str	r3, [r4, #16]
      *ifcRegister_Base = 0x3FUL << (hdma->StreamIndex & 0x1FU);
24002f26:	233f      	movs	r3, #63	@ 0x3f
24002f28:	40bb      	lsls	r3, r7
24002f2a:	f8cc 3008 	str.w	r3, [ip, #8]
24002f2e:	e754      	b.n	24002dda <HAL_DMAEx_MultiBufferStart_IT+0xda>
24002f30:	40020010 	.word	0x40020010
24002f34:	40020028 	.word	0x40020028
24002f38:	58025408 	.word	0x58025408
      hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
24002f3c:	e9d5 3119 	ldrd	r3, r1, [r5, #100]	@ 0x64
24002f40:	6059      	str	r1, [r3, #4]
      if(hdma->DMAmuxRequestGen != 0U)
24002f42:	6eeb      	ldr	r3, [r5, #108]	@ 0x6c
24002f44:	b113      	cbz	r3, 24002f4c <HAL_DMAEx_MultiBufferStart_IT+0x24c>
        hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
24002f46:	e9d5 311c 	ldrd	r3, r1, [r5, #112]	@ 0x70
24002f4a:	6059      	str	r1, [r3, #4]
    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
24002f4c:	42b4      	cmp	r4, r6
24002f4e:	d02e      	beq.n	24002fae <HAL_DMAEx_MultiBufferStart_IT+0x2ae>
24002f50:	4b59      	ldr	r3, [pc, #356]	@ (240030b8 <HAL_DMAEx_MultiBufferStart_IT+0x3b8>)
24002f52:	429c      	cmp	r4, r3
24002f54:	d02b      	beq.n	24002fae <HAL_DMAEx_MultiBufferStart_IT+0x2ae>
24002f56:	3318      	adds	r3, #24
24002f58:	429c      	cmp	r4, r3
24002f5a:	d028      	beq.n	24002fae <HAL_DMAEx_MultiBufferStart_IT+0x2ae>
24002f5c:	3318      	adds	r3, #24
24002f5e:	429c      	cmp	r4, r3
24002f60:	d025      	beq.n	24002fae <HAL_DMAEx_MultiBufferStart_IT+0x2ae>
24002f62:	3318      	adds	r3, #24
24002f64:	429c      	cmp	r4, r3
24002f66:	d022      	beq.n	24002fae <HAL_DMAEx_MultiBufferStart_IT+0x2ae>
24002f68:	3318      	adds	r3, #24
24002f6a:	429c      	cmp	r4, r3
24002f6c:	d01f      	beq.n	24002fae <HAL_DMAEx_MultiBufferStart_IT+0x2ae>
24002f6e:	3318      	adds	r3, #24
24002f70:	429c      	cmp	r4, r3
24002f72:	d01c      	beq.n	24002fae <HAL_DMAEx_MultiBufferStart_IT+0x2ae>
24002f74:	3318      	adds	r3, #24
24002f76:	429c      	cmp	r4, r3
24002f78:	d019      	beq.n	24002fae <HAL_DMAEx_MultiBufferStart_IT+0x2ae>
24002f7a:	f503 7356 	add.w	r3, r3, #856	@ 0x358
24002f7e:	429c      	cmp	r4, r3
24002f80:	d015      	beq.n	24002fae <HAL_DMAEx_MultiBufferStart_IT+0x2ae>
24002f82:	3318      	adds	r3, #24
24002f84:	429c      	cmp	r4, r3
24002f86:	d012      	beq.n	24002fae <HAL_DMAEx_MultiBufferStart_IT+0x2ae>
24002f88:	3318      	adds	r3, #24
24002f8a:	429c      	cmp	r4, r3
24002f8c:	d00f      	beq.n	24002fae <HAL_DMAEx_MultiBufferStart_IT+0x2ae>
24002f8e:	3318      	adds	r3, #24
24002f90:	429c      	cmp	r4, r3
24002f92:	d00c      	beq.n	24002fae <HAL_DMAEx_MultiBufferStart_IT+0x2ae>
24002f94:	3318      	adds	r3, #24
24002f96:	429c      	cmp	r4, r3
24002f98:	d009      	beq.n	24002fae <HAL_DMAEx_MultiBufferStart_IT+0x2ae>
24002f9a:	3318      	adds	r3, #24
24002f9c:	429c      	cmp	r4, r3
24002f9e:	d006      	beq.n	24002fae <HAL_DMAEx_MultiBufferStart_IT+0x2ae>
24002fa0:	3318      	adds	r3, #24
24002fa2:	429c      	cmp	r4, r3
24002fa4:	d003      	beq.n	24002fae <HAL_DMAEx_MultiBufferStart_IT+0x2ae>
24002fa6:	3318      	adds	r3, #24
24002fa8:	429c      	cmp	r4, r3
24002faa:	f47f af6e 	bne.w	24002e8a <HAL_DMAEx_MultiBufferStart_IT+0x18a>
      MODIFY_REG(((DMA_Stream_TypeDef   *)hdma->Instance)->CR, (DMA_IT_TC | DMA_IT_TE | DMA_IT_DME | DMA_IT_HT), (DMA_IT_TC | DMA_IT_TE | DMA_IT_DME));
24002fae:	6823      	ldr	r3, [r4, #0]
24002fb0:	f023 031e 	bic.w	r3, r3, #30
24002fb4:	f043 0316 	orr.w	r3, r3, #22
24002fb8:	6023      	str	r3, [r4, #0]
      ((DMA_Stream_TypeDef   *)hdma->Instance)->FCR |= DMA_IT_FE;
24002fba:	6963      	ldr	r3, [r4, #20]
24002fbc:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
24002fc0:	6163      	str	r3, [r4, #20]
      if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
24002fc2:	b90a      	cbnz	r2, 24002fc8 <HAL_DMAEx_MultiBufferStart_IT+0x2c8>
24002fc4:	6cab      	ldr	r3, [r5, #72]	@ 0x48
24002fc6:	b11b      	cbz	r3, 24002fd0 <HAL_DMAEx_MultiBufferStart_IT+0x2d0>
        ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  |= DMA_IT_HT;
24002fc8:	6823      	ldr	r3, [r4, #0]
24002fca:	f043 0308 	orr.w	r3, r3, #8
24002fce:	6023      	str	r3, [r4, #0]
    if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
24002fd0:	42b4      	cmp	r4, r6
24002fd2:	f43f af6b 	beq.w	24002eac <HAL_DMAEx_MultiBufferStart_IT+0x1ac>
24002fd6:	4b38      	ldr	r3, [pc, #224]	@ (240030b8 <HAL_DMAEx_MultiBufferStart_IT+0x3b8>)
24002fd8:	429c      	cmp	r4, r3
24002fda:	f43f af67 	beq.w	24002eac <HAL_DMAEx_MultiBufferStart_IT+0x1ac>
24002fde:	3318      	adds	r3, #24
24002fe0:	429c      	cmp	r4, r3
24002fe2:	f43f af63 	beq.w	24002eac <HAL_DMAEx_MultiBufferStart_IT+0x1ac>
24002fe6:	3318      	adds	r3, #24
24002fe8:	429c      	cmp	r4, r3
24002fea:	f43f af5f 	beq.w	24002eac <HAL_DMAEx_MultiBufferStart_IT+0x1ac>
24002fee:	3318      	adds	r3, #24
24002ff0:	429c      	cmp	r4, r3
24002ff2:	f43f af5b 	beq.w	24002eac <HAL_DMAEx_MultiBufferStart_IT+0x1ac>
24002ff6:	3318      	adds	r3, #24
24002ff8:	429c      	cmp	r4, r3
24002ffa:	f43f af57 	beq.w	24002eac <HAL_DMAEx_MultiBufferStart_IT+0x1ac>
24002ffe:	3318      	adds	r3, #24
24003000:	429c      	cmp	r4, r3
24003002:	f43f af53 	beq.w	24002eac <HAL_DMAEx_MultiBufferStart_IT+0x1ac>
24003006:	3318      	adds	r3, #24
24003008:	429c      	cmp	r4, r3
2400300a:	f43f af4f 	beq.w	24002eac <HAL_DMAEx_MultiBufferStart_IT+0x1ac>
2400300e:	f503 7356 	add.w	r3, r3, #856	@ 0x358
24003012:	429c      	cmp	r4, r3
24003014:	f43f af4a 	beq.w	24002eac <HAL_DMAEx_MultiBufferStart_IT+0x1ac>
24003018:	3318      	adds	r3, #24
2400301a:	429c      	cmp	r4, r3
2400301c:	f43f af46 	beq.w	24002eac <HAL_DMAEx_MultiBufferStart_IT+0x1ac>
24003020:	3318      	adds	r3, #24
24003022:	429c      	cmp	r4, r3
24003024:	f43f af42 	beq.w	24002eac <HAL_DMAEx_MultiBufferStart_IT+0x1ac>
24003028:	3318      	adds	r3, #24
2400302a:	429c      	cmp	r4, r3
2400302c:	f43f af3e 	beq.w	24002eac <HAL_DMAEx_MultiBufferStart_IT+0x1ac>
24003030:	3318      	adds	r3, #24
24003032:	429c      	cmp	r4, r3
24003034:	f43f af3a 	beq.w	24002eac <HAL_DMAEx_MultiBufferStart_IT+0x1ac>
24003038:	3318      	adds	r3, #24
2400303a:	429c      	cmp	r4, r3
2400303c:	f43f af36 	beq.w	24002eac <HAL_DMAEx_MultiBufferStart_IT+0x1ac>
24003040:	3318      	adds	r3, #24
24003042:	429c      	cmp	r4, r3
24003044:	f43f af32 	beq.w	24002eac <HAL_DMAEx_MultiBufferStart_IT+0x1ac>
24003048:	3318      	adds	r3, #24
2400304a:	429c      	cmp	r4, r3
2400304c:	e004      	b.n	24003058 <HAL_DMAEx_MultiBufferStart_IT+0x358>
        ((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR  |= BDMA_CCR_HTIE;
2400304e:	6823      	ldr	r3, [r4, #0]
    if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
24003050:	42b4      	cmp	r4, r6
        ((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR  |= BDMA_CCR_HTIE;
24003052:	f043 0304 	orr.w	r3, r3, #4
24003056:	6023      	str	r3, [r4, #0]
    if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
24003058:	f47f af24 	bne.w	24002ea4 <HAL_DMAEx_MultiBufferStart_IT+0x1a4>
2400305c:	e726      	b.n	24002eac <HAL_DMAEx_MultiBufferStart_IT+0x1ac>
2400305e:	4b17      	ldr	r3, [pc, #92]	@ (240030bc <HAL_DMAEx_MultiBufferStart_IT+0x3bc>)
24003060:	429c      	cmp	r4, r3
24003062:	f43f af23 	beq.w	24002eac <HAL_DMAEx_MultiBufferStart_IT+0x1ac>
24003066:	3314      	adds	r3, #20
24003068:	429c      	cmp	r4, r3
2400306a:	f43f af1f 	beq.w	24002eac <HAL_DMAEx_MultiBufferStart_IT+0x1ac>
2400306e:	3314      	adds	r3, #20
24003070:	429c      	cmp	r4, r3
24003072:	f43f af1b 	beq.w	24002eac <HAL_DMAEx_MultiBufferStart_IT+0x1ac>
24003076:	3314      	adds	r3, #20
24003078:	429c      	cmp	r4, r3
2400307a:	f43f af17 	beq.w	24002eac <HAL_DMAEx_MultiBufferStart_IT+0x1ac>
2400307e:	3314      	adds	r3, #20
24003080:	429c      	cmp	r4, r3
24003082:	f43f af13 	beq.w	24002eac <HAL_DMAEx_MultiBufferStart_IT+0x1ac>
24003086:	3314      	adds	r3, #20
24003088:	429c      	cmp	r4, r3
2400308a:	f43f af0f 	beq.w	24002eac <HAL_DMAEx_MultiBufferStart_IT+0x1ac>
2400308e:	3314      	adds	r3, #20
24003090:	429c      	cmp	r4, r3
24003092:	f43f af0b 	beq.w	24002eac <HAL_DMAEx_MultiBufferStart_IT+0x1ac>
    __HAL_DMA_ENABLE(hdma);
24003096:	6823      	ldr	r3, [r4, #0]
  HAL_StatusTypeDef status = HAL_OK;
24003098:	2000      	movs	r0, #0
    __HAL_DMA_ENABLE(hdma);
2400309a:	f043 0301 	orr.w	r3, r3, #1
2400309e:	6023      	str	r3, [r4, #0]
}
240030a0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        hdma->DMAmuxChannel->CCR |= DMAMUX_CxCR_SOIE;
240030a2:	681a      	ldr	r2, [r3, #0]
240030a4:	f442 7280 	orr.w	r2, r2, #256	@ 0x100
240030a8:	601a      	str	r2, [r3, #0]
240030aa:	e704      	b.n	24002eb6 <HAL_DMAEx_MultiBufferStart_IT+0x1b6>
    hdma->ErrorCode = HAL_DMA_ERROR_BUSY;
240030ac:	f44f 6300 	mov.w	r3, #2048	@ 0x800
240030b0:	e62d      	b.n	24002d0e <HAL_DMAEx_MultiBufferStart_IT+0xe>
  __HAL_LOCK(hdma);
240030b2:	2002      	movs	r0, #2
240030b4:	e7f4      	b.n	240030a0 <HAL_DMAEx_MultiBufferStart_IT+0x3a0>
240030b6:	bf00      	nop
240030b8:	40020028 	.word	0x40020028
240030bc:	5802541c 	.word	0x5802541c

240030c0 <HAL_DMAEx_ChangeMemory>:
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
240030c0:	6803      	ldr	r3, [r0, #0]
240030c2:	4814      	ldr	r0, [pc, #80]	@ (24003114 <HAL_DMAEx_ChangeMemory+0x54>)
240030c4:	4283      	cmp	r3, r0
240030c6:	d01e      	beq.n	24003106 <HAL_DMAEx_ChangeMemory+0x46>
240030c8:	3018      	adds	r0, #24
240030ca:	4283      	cmp	r3, r0
240030cc:	d01b      	beq.n	24003106 <HAL_DMAEx_ChangeMemory+0x46>
240030ce:	3018      	adds	r0, #24
240030d0:	4283      	cmp	r3, r0
240030d2:	d018      	beq.n	24003106 <HAL_DMAEx_ChangeMemory+0x46>
240030d4:	3018      	adds	r0, #24
240030d6:	4283      	cmp	r3, r0
240030d8:	d015      	beq.n	24003106 <HAL_DMAEx_ChangeMemory+0x46>
240030da:	3018      	adds	r0, #24
240030dc:	4283      	cmp	r3, r0
240030de:	d012      	beq.n	24003106 <HAL_DMAEx_ChangeMemory+0x46>
240030e0:	3018      	adds	r0, #24
240030e2:	4283      	cmp	r3, r0
240030e4:	d00f      	beq.n	24003106 <HAL_DMAEx_ChangeMemory+0x46>
240030e6:	3018      	adds	r0, #24
240030e8:	4283      	cmp	r3, r0
240030ea:	d00c      	beq.n	24003106 <HAL_DMAEx_ChangeMemory+0x46>
240030ec:	3018      	adds	r0, #24
240030ee:	4283      	cmp	r3, r0
240030f0:	d009      	beq.n	24003106 <HAL_DMAEx_ChangeMemory+0x46>
240030f2:	f500 7056 	add.w	r0, r0, #856	@ 0x358
240030f6:	4283      	cmp	r3, r0
240030f8:	d005      	beq.n	24003106 <HAL_DMAEx_ChangeMemory+0x46>
240030fa:	3018      	adds	r0, #24
240030fc:	4283      	cmp	r3, r0
240030fe:	d002      	beq.n	24003106 <HAL_DMAEx_ChangeMemory+0x46>
24003100:	3018      	adds	r0, #24
24003102:	4283      	cmp	r3, r0
24003104:	d0ff      	beq.n	24003106 <HAL_DMAEx_ChangeMemory+0x46>
    if(memory == MEMORY0)
24003106:	b912      	cbnz	r2, 2400310e <HAL_DMAEx_ChangeMemory+0x4e>
      ((BDMA_Channel_TypeDef   *)hdma->Instance)->CM0AR = Address;
24003108:	60d9      	str	r1, [r3, #12]
}
2400310a:	2000      	movs	r0, #0
2400310c:	4770      	bx	lr
      ((BDMA_Channel_TypeDef   *)hdma->Instance)->CM1AR = Address;
2400310e:	6119      	str	r1, [r3, #16]
24003110:	e7fb      	b.n	2400310a <HAL_DMAEx_ChangeMemory+0x4a>
24003112:	bf00      	nop
24003114:	40020010 	.word	0x40020010

24003118 <HAL_DMAEx_ConfigMuxSync>:
{
24003118:	b5f0      	push	{r4, r5, r6, r7, lr}
  if(pSyncConfig->SyncEnable == ENABLE)
2400311a:	7a0b      	ldrb	r3, [r1, #8]
{
2400311c:	4602      	mov	r2, r0
  if(hdma->State == HAL_DMA_STATE_READY)
2400311e:	f890 0035 	ldrb.w	r0, [r0, #53]	@ 0x35
  if(pSyncConfig->SyncEnable == ENABLE)
24003122:	2b01      	cmp	r3, #1
  uint32_t syncPolarity = 0;
24003124:	bf16      	itet	ne
24003126:	2400      	movne	r4, #0
    syncPolarity = pSyncConfig->SyncPolarity;
24003128:	e9d1 7400 	ldrdeq	r7, r4, [r1]
  uint32_t syncSignalID = 0;
2400312c:	4627      	movne	r7, r4
  if(hdma->State == HAL_DMA_STATE_READY)
2400312e:	2801      	cmp	r0, #1
24003130:	d11b      	bne.n	2400316a <HAL_DMAEx_ConfigMuxSync+0x52>
    __HAL_LOCK(hdma);
24003132:	f892 0034 	ldrb.w	r0, [r2, #52]	@ 0x34
24003136:	2801      	cmp	r0, #1
24003138:	d01c      	beq.n	24003174 <HAL_DMAEx_ConfigMuxSync+0x5c>
    CLEAR_BIT(hdma->DMAmuxChannel->CCR,(DMAMUX_CxCR_SE | DMAMUX_CxCR_EGE));
2400313a:	6e10      	ldr	r0, [r2, #96]	@ 0x60
    MODIFY_REG( hdma->DMAmuxChannel->CCR, \
2400313c:	041b      	lsls	r3, r3, #16
2400313e:	68ce      	ldr	r6, [r1, #12]
    CLEAR_BIT(hdma->DMAmuxChannel->CCR,(DMAMUX_CxCR_SE | DMAMUX_CxCR_EGE));
24003140:	6805      	ldr	r5, [r0, #0]
    MODIFY_REG( hdma->DMAmuxChannel->CCR, \
24003142:	3e01      	subs	r6, #1
    CLEAR_BIT(hdma->DMAmuxChannel->CCR,(DMAMUX_CxCR_SE | DMAMUX_CxCR_EGE));
24003144:	f425 3581 	bic.w	r5, r5, #66048	@ 0x10200
    MODIFY_REG( hdma->DMAmuxChannel->CCR, \
24003148:	ea43 43c6 	orr.w	r3, r3, r6, lsl #19
    CLEAR_BIT(hdma->DMAmuxChannel->CCR,(DMAMUX_CxCR_SE | DMAMUX_CxCR_EGE));
2400314c:	6005      	str	r5, [r0, #0]
    MODIFY_REG( hdma->DMAmuxChannel->CCR, \
2400314e:	6805      	ldr	r5, [r0, #0]
24003150:	7a49      	ldrb	r1, [r1, #9]
24003152:	b2ed      	uxtb	r5, r5
24003154:	432b      	orrs	r3, r5
24003156:	ea43 2341 	orr.w	r3, r3, r1, lsl #9
2400315a:	4323      	orrs	r3, r4
2400315c:	ea43 6307 	orr.w	r3, r3, r7, lsl #24
24003160:	6003      	str	r3, [r0, #0]
    __HAL_UNLOCK(hdma);
24003162:	2000      	movs	r0, #0
24003164:	f882 0034 	strb.w	r0, [r2, #52]	@ 0x34
}
24003168:	bdf0      	pop	{r4, r5, r6, r7, pc}
    hdma->ErrorCode = HAL_DMA_ERROR_BUSY;
2400316a:	f44f 6300 	mov.w	r3, #2048	@ 0x800
    return HAL_ERROR;
2400316e:	2001      	movs	r0, #1
    hdma->ErrorCode = HAL_DMA_ERROR_BUSY;
24003170:	6553      	str	r3, [r2, #84]	@ 0x54
    return HAL_ERROR;
24003172:	e7f9      	b.n	24003168 <HAL_DMAEx_ConfigMuxSync+0x50>
    __HAL_LOCK(hdma);
24003174:	2002      	movs	r0, #2
24003176:	e7f7      	b.n	24003168 <HAL_DMAEx_ConfigMuxSync+0x50>

24003178 <HAL_DMAEx_ConfigMuxRequestGenerator>:
{
24003178:	b530      	push	{r4, r5, lr}
  if(hdma->DMAmuxRequestGen == 0U)
2400317a:	6ec4      	ldr	r4, [r0, #108]	@ 0x6c
{
2400317c:	4603      	mov	r3, r0
  HAL_DMA_StateTypeDef temp_state = hdma->State;
2400317e:	f890 2035 	ldrb.w	r2, [r0, #53]	@ 0x35
24003182:	b2d2      	uxtb	r2, r2
  if(hdma->DMAmuxRequestGen == 0U)
24003184:	b91c      	cbnz	r4, 2400318e <HAL_DMAEx_ConfigMuxRequestGenerator+0x16>
    hdma->ErrorCode = HAL_DMA_ERROR_PARAM;
24003186:	2240      	movs	r2, #64	@ 0x40
  return status;
24003188:	2001      	movs	r0, #1
    hdma->ErrorCode = HAL_DMA_ERROR_PARAM;
2400318a:	655a      	str	r2, [r3, #84]	@ 0x54
}
2400318c:	bd30      	pop	{r4, r5, pc}
  else if(((hdma->DMAmuxRequestGen->RGCR & DMAMUX_RGxCR_GE) == 0U) && (temp_state == HAL_DMA_STATE_READY))
2400318e:	6820      	ldr	r0, [r4, #0]
24003190:	f410 3080 	ands.w	r0, r0, #65536	@ 0x10000
24003194:	d110      	bne.n	240031b8 <HAL_DMAEx_ConfigMuxRequestGenerator+0x40>
24003196:	2a01      	cmp	r2, #1
24003198:	d10e      	bne.n	240031b8 <HAL_DMAEx_ConfigMuxRequestGenerator+0x40>
    __HAL_LOCK(hdma);
2400319a:	f893 2034 	ldrb.w	r2, [r3, #52]	@ 0x34
2400319e:	2a01      	cmp	r2, #1
240031a0:	d00d      	beq.n	240031be <HAL_DMAEx_ConfigMuxRequestGenerator+0x46>
                                  ((pRequestGeneratorConfig->RequestNumber - 1U) << DMAMUX_RGxCR_GNBREQ_Pos)| \
240031a2:	688a      	ldr	r2, [r1, #8]
240031a4:	1e55      	subs	r5, r2, #1
240031a6:	e9d1 2100 	ldrd	r2, r1, [r1]
240031aa:	430a      	orrs	r2, r1
240031ac:	ea42 42c5 	orr.w	r2, r2, r5, lsl #19
    hdma->DMAmuxRequestGen->RGCR = pRequestGeneratorConfig->SignalID | \
240031b0:	6022      	str	r2, [r4, #0]
    __HAL_UNLOCK(hdma);
240031b2:	f883 0034 	strb.w	r0, [r3, #52]	@ 0x34
    return HAL_OK;
240031b6:	e7e9      	b.n	2400318c <HAL_DMAEx_ConfigMuxRequestGenerator+0x14>
    hdma->ErrorCode = HAL_DMA_ERROR_BUSY;
240031b8:	f44f 6200 	mov.w	r2, #2048	@ 0x800
240031bc:	e7e4      	b.n	24003188 <HAL_DMAEx_ConfigMuxRequestGenerator+0x10>
    __HAL_LOCK(hdma);
240031be:	2002      	movs	r0, #2
240031c0:	e7e4      	b.n	2400318c <HAL_DMAEx_ConfigMuxRequestGenerator+0x14>

240031c2 <HAL_DMAEx_EnableMuxRequestGenerator>:
  if((hdma->State != HAL_DMA_STATE_RESET) && (hdma->DMAmuxRequestGen != 0U))
240031c2:	f890 3035 	ldrb.w	r3, [r0, #53]	@ 0x35
240031c6:	b13b      	cbz	r3, 240031d8 <HAL_DMAEx_EnableMuxRequestGenerator+0x16>
240031c8:	6ec3      	ldr	r3, [r0, #108]	@ 0x6c
240031ca:	b12b      	cbz	r3, 240031d8 <HAL_DMAEx_EnableMuxRequestGenerator+0x16>
    hdma->DMAmuxRequestGen->RGCR |= DMAMUX_RGxCR_GE;
240031cc:	681a      	ldr	r2, [r3, #0]
   return HAL_OK;
240031ce:	2000      	movs	r0, #0
    hdma->DMAmuxRequestGen->RGCR |= DMAMUX_RGxCR_GE;
240031d0:	f442 3280 	orr.w	r2, r2, #65536	@ 0x10000
240031d4:	601a      	str	r2, [r3, #0]
   return HAL_OK;
240031d6:	4770      	bx	lr
   return HAL_ERROR;
240031d8:	2001      	movs	r0, #1
}
240031da:	4770      	bx	lr

240031dc <HAL_DMAEx_DisableMuxRequestGenerator>:
  if((hdma->State != HAL_DMA_STATE_RESET) && (hdma->DMAmuxRequestGen != 0U))
240031dc:	f890 3035 	ldrb.w	r3, [r0, #53]	@ 0x35
240031e0:	b13b      	cbz	r3, 240031f2 <HAL_DMAEx_DisableMuxRequestGenerator+0x16>
240031e2:	6ec3      	ldr	r3, [r0, #108]	@ 0x6c
240031e4:	b12b      	cbz	r3, 240031f2 <HAL_DMAEx_DisableMuxRequestGenerator+0x16>
    hdma->DMAmuxRequestGen->RGCR &= ~DMAMUX_RGxCR_GE;
240031e6:	681a      	ldr	r2, [r3, #0]
   return HAL_OK;
240031e8:	2000      	movs	r0, #0
    hdma->DMAmuxRequestGen->RGCR &= ~DMAMUX_RGxCR_GE;
240031ea:	f422 3280 	bic.w	r2, r2, #65536	@ 0x10000
240031ee:	601a      	str	r2, [r3, #0]
   return HAL_OK;
240031f0:	4770      	bx	lr
   return HAL_ERROR;
240031f2:	2001      	movs	r0, #1
}
240031f4:	4770      	bx	lr

240031f6 <HAL_DMAEx_MUX_IRQHandler>:
  if((hdma->DMAmuxChannelStatus->CSR & hdma->DMAmuxChannelStatusMask) != 0U)
240031f6:	6e42      	ldr	r2, [r0, #100]	@ 0x64
240031f8:	6e81      	ldr	r1, [r0, #104]	@ 0x68
240031fa:	6813      	ldr	r3, [r2, #0]
240031fc:	420b      	tst	r3, r1
{
240031fe:	b570      	push	{r4, r5, r6, lr}
24003200:	4604      	mov	r4, r0
  if((hdma->DMAmuxChannelStatus->CSR & hdma->DMAmuxChannelStatusMask) != 0U)
24003202:	d00c      	beq.n	2400321e <HAL_DMAEx_MUX_IRQHandler+0x28>
    hdma->DMAmuxChannel->CCR &= ~DMAMUX_CxCR_SOIE;
24003204:	6e05      	ldr	r5, [r0, #96]	@ 0x60
24003206:	682b      	ldr	r3, [r5, #0]
24003208:	f423 7380 	bic.w	r3, r3, #256	@ 0x100
2400320c:	602b      	str	r3, [r5, #0]
    hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
2400320e:	6051      	str	r1, [r2, #4]
    hdma->ErrorCode |= HAL_DMA_ERROR_SYNC;
24003210:	6d43      	ldr	r3, [r0, #84]	@ 0x54
24003212:	f443 7300 	orr.w	r3, r3, #512	@ 0x200
24003216:	6543      	str	r3, [r0, #84]	@ 0x54
    if(hdma->XferErrorCallback != NULL)
24003218:	6cc3      	ldr	r3, [r0, #76]	@ 0x4c
2400321a:	b103      	cbz	r3, 2400321e <HAL_DMAEx_MUX_IRQHandler+0x28>
      hdma->XferErrorCallback(hdma);
2400321c:	4798      	blx	r3
  if(hdma->DMAmuxRequestGen != 0)
2400321e:	6ee3      	ldr	r3, [r4, #108]	@ 0x6c
24003220:	b19b      	cbz	r3, 2400324a <HAL_DMAEx_MUX_IRQHandler+0x54>
    if((hdma->DMAmuxRequestGenStatus->RGSR & hdma->DMAmuxRequestGenStatusMask) != 0U)
24003222:	6f21      	ldr	r1, [r4, #112]	@ 0x70
24003224:	6f60      	ldr	r0, [r4, #116]	@ 0x74
24003226:	680a      	ldr	r2, [r1, #0]
24003228:	4202      	tst	r2, r0
2400322a:	d00e      	beq.n	2400324a <HAL_DMAEx_MUX_IRQHandler+0x54>
      hdma->DMAmuxRequestGen->RGCR &= ~DMAMUX_RGxCR_OIE;
2400322c:	681a      	ldr	r2, [r3, #0]
2400322e:	f422 7280 	bic.w	r2, r2, #256	@ 0x100
24003232:	601a      	str	r2, [r3, #0]
      hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
24003234:	6048      	str	r0, [r1, #4]
      hdma->ErrorCode |= HAL_DMA_ERROR_REQGEN;
24003236:	6d63      	ldr	r3, [r4, #84]	@ 0x54
24003238:	f443 6380 	orr.w	r3, r3, #1024	@ 0x400
2400323c:	6563      	str	r3, [r4, #84]	@ 0x54
      if(hdma->XferErrorCallback != NULL)
2400323e:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
24003240:	b11b      	cbz	r3, 2400324a <HAL_DMAEx_MUX_IRQHandler+0x54>
        hdma->XferErrorCallback(hdma);
24003242:	4620      	mov	r0, r4
}
24003244:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        hdma->XferErrorCallback(hdma);
24003248:	4718      	bx	r3
}
2400324a:	bd70      	pop	{r4, r5, r6, pc}

2400324c <HAL_EXTI_SetConfigLine>:
  * @param  hexti Exti handle.
  * @param  pExtiConfig Pointer on EXTI configuration to be set.
  * @retval HAL Status.
  */
HAL_StatusTypeDef HAL_EXTI_SetConfigLine(EXTI_HandleTypeDef *hexti, EXTI_ConfigTypeDef *pExtiConfig)
{
2400324c:	b5f0      	push	{r4, r5, r6, r7, lr}
  uint32_t maskline;
  uint32_t offset;
  uint32_t pcrlinepos;

  /* Check null pointer */
  if ((hexti == NULL) || (pExtiConfig == NULL))
2400324e:	2800      	cmp	r0, #0
24003250:	d074      	beq.n	2400333c <HAL_EXTI_SetConfigLine+0xf0>
24003252:	2900      	cmp	r1, #0
24003254:	d072      	beq.n	2400333c <HAL_EXTI_SetConfigLine+0xf0>
  /* Check the parameters */
  assert_param(IS_EXTI_LINE(pExtiConfig->Line));
  assert_param(IS_EXTI_MODE(pExtiConfig->Mode));

  /* Assign line number to handle */
  hexti->Line = pExtiConfig->Line;
24003256:	680c      	ldr	r4, [r1, #0]

  /* compute line register offset and line mask */
  offset = ((pExtiConfig->Line & EXTI_REG_MASK) >> EXTI_REG_SHIFT);
  linepos = (pExtiConfig->Line & EXTI_PIN_MASK);
  maskline = (1UL << linepos);
24003258:	2301      	movs	r3, #1
  linepos = (pExtiConfig->Line & EXTI_PIN_MASK);
2400325a:	f004 051f 	and.w	r5, r4, #31
  hexti->Line = pExtiConfig->Line;
2400325e:	6004      	str	r4, [r0, #0]

  /* Configure triggers for configurable lines */
  if ((pExtiConfig->Line & EXTI_CONFIG) != 0x00U)
24003260:	01a0      	lsls	r0, r4, #6
  offset = ((pExtiConfig->Line & EXTI_REG_MASK) >> EXTI_REG_SHIFT);
24003262:	f3c4 4201 	ubfx	r2, r4, #16, #2
  maskline = (1UL << linepos);
24003266:	fa03 f305 	lsl.w	r3, r3, r5
  if ((pExtiConfig->Line & EXTI_CONFIG) != 0x00U)
2400326a:	d52b      	bpl.n	240032c4 <HAL_EXTI_SetConfigLine+0x78>
  {
    assert_param(IS_EXTI_TRIGGER(pExtiConfig->Trigger));

    /* Configure rising trigger */
    regaddr = (__IO uint32_t *)(&EXTI->RTSR1 + (EXTI_CONFIG_OFFSET * offset));
2400326c:	0150      	lsls	r0, r2, #5
    regval = *regaddr;

    /* Mask or set line */
    if ((pExtiConfig->Trigger & EXTI_TRIGGER_RISING) != 0x00U)
2400326e:	688f      	ldr	r7, [r1, #8]
    regaddr = (__IO uint32_t *)(&EXTI->RTSR1 + (EXTI_CONFIG_OFFSET * offset));
24003270:	f100 40b0 	add.w	r0, r0, #1476395008	@ 0x58000000
    if ((pExtiConfig->Trigger & EXTI_TRIGGER_RISING) != 0x00U)
24003274:	07ff      	lsls	r7, r7, #31
    regval = *regaddr;
24003276:	6806      	ldr	r6, [r0, #0]
    {
      regval |= maskline;
24003278:	bf4c      	ite	mi
2400327a:	431e      	orrmi	r6, r3
    }
    else
    {
      regval &= ~maskline;
2400327c:	439e      	bicpl	r6, r3
    }

    /* Store rising trigger mode */
    *regaddr = regval;
2400327e:	6006      	str	r6, [r0, #0]
    /* Configure falling trigger */
    regaddr = (__IO uint32_t *)(&EXTI->FTSR1 + (EXTI_CONFIG_OFFSET * offset));
    regval = *regaddr;

    /* Mask or set line */
    if ((pExtiConfig->Trigger & EXTI_TRIGGER_FALLING) != 0x00U)
24003280:	688f      	ldr	r7, [r1, #8]
    regval = *regaddr;
24003282:	6846      	ldr	r6, [r0, #4]
    if ((pExtiConfig->Trigger & EXTI_TRIGGER_FALLING) != 0x00U)
24003284:	07bf      	lsls	r7, r7, #30
    {
      regval |= maskline;
24003286:	bf4c      	ite	mi
24003288:	431e      	orrmi	r6, r3
    }
    else
    {
      regval &= ~maskline;
2400328a:	439e      	bicpl	r6, r3
    }

    /* Store falling trigger mode */
    *regaddr = regval;
2400328c:	6046      	str	r6, [r0, #4]

    /* Configure gpio port selection in case of gpio exti line */
    if ((pExtiConfig->Line & EXTI_GPIO) == EXTI_GPIO)
2400328e:	6808      	ldr	r0, [r1, #0]
24003290:	f000 60c0 	and.w	r0, r0, #100663296	@ 0x6000000
24003294:	f1b0 6fc0 	cmp.w	r0, #100663296	@ 0x6000000
24003298:	d114      	bne.n	240032c4 <HAL_EXTI_SetConfigLine+0x78>
    {
      assert_param(IS_EXTI_GPIO_PORT(pExtiConfig->GPIOSel));
      assert_param(IS_EXTI_GPIO_PIN(linepos));

      regval = SYSCFG->EXTICR[(linepos >> 2U) & 0x03UL];
2400329a:	f005 000c 	and.w	r0, r5, #12
      regval &= ~(SYSCFG_EXTICR1_EXTI0 << (SYSCFG_EXTICR1_EXTI1_Pos * (linepos & 0x03U)));
2400329e:	f004 0703 	and.w	r7, r4, #3
240032a2:	f04f 0c0f 	mov.w	ip, #15
240032a6:	f100 40b0 	add.w	r0, r0, #1476395008	@ 0x58000000
240032aa:	00bf      	lsls	r7, r7, #2
      regval = SYSCFG->EXTICR[(linepos >> 2U) & 0x03UL];
240032ac:	f8d0 6408 	ldr.w	r6, [r0, #1032]	@ 0x408
      regval &= ~(SYSCFG_EXTICR1_EXTI0 << (SYSCFG_EXTICR1_EXTI1_Pos * (linepos & 0x03U)));
240032b0:	fa0c fc07 	lsl.w	ip, ip, r7
240032b4:	ea26 0c0c 	bic.w	ip, r6, ip
      regval |= (pExtiConfig->GPIOSel << (SYSCFG_EXTICR1_EXTI1_Pos * (linepos & 0x03U)));
240032b8:	68ce      	ldr	r6, [r1, #12]
240032ba:	40be      	lsls	r6, r7
240032bc:	ea46 060c 	orr.w	r6, r6, ip
      SYSCFG->EXTICR[(linepos >> 2U) & 0x03UL] = regval;
240032c0:	f8c0 6408 	str.w	r6, [r0, #1032]	@ 0x408
    }
  }

  /* Configure interrupt mode : read current mode */
  regaddr = (__IO uint32_t *)(&EXTI->IMR1 + (EXTI_MODE_OFFSET * offset));
240032c4:	0110      	lsls	r0, r2, #4
  regval = *regaddr;

  /* Mask or set line */
  if ((pExtiConfig->Mode & EXTI_MODE_INTERRUPT) != 0x00U)
240032c6:	684f      	ldr	r7, [r1, #4]
  regaddr = (__IO uint32_t *)(&EXTI->IMR1 + (EXTI_MODE_OFFSET * offset));
240032c8:	f100 40b0 	add.w	r0, r0, #1476395008	@ 0x58000000
  if ((pExtiConfig->Mode & EXTI_MODE_INTERRUPT) != 0x00U)
240032cc:	07ff      	lsls	r7, r7, #31
  regval = *regaddr;
240032ce:	f8d0 6080 	ldr.w	r6, [r0, #128]	@ 0x80
  {
    regval |= maskline;
240032d2:	bf4c      	ite	mi
240032d4:	431e      	orrmi	r6, r3
  }
  else
  {
    regval &= ~maskline;
240032d6:	439e      	bicpl	r6, r3
  }

  /* Store interrupt mode */
  *regaddr = regval;
240032d8:	f8c0 6080 	str.w	r6, [r0, #128]	@ 0x80
  /* Configure event mode : read current mode */
  regaddr = (__IO uint32_t *)(&EXTI->EMR1 + (EXTI_MODE_OFFSET * offset));
  regval = *regaddr;

  /* Mask or set line */
  if ((pExtiConfig->Mode & EXTI_MODE_EVENT) != 0x00U)
240032dc:	684f      	ldr	r7, [r1, #4]
  regval = *regaddr;
240032de:	f8d0 6084 	ldr.w	r6, [r0, #132]	@ 0x84
  if ((pExtiConfig->Mode & EXTI_MODE_EVENT) != 0x00U)
240032e2:	07bf      	lsls	r7, r7, #30
  {
    regval |= maskline;
240032e4:	bf4c      	ite	mi
240032e6:	431e      	orrmi	r6, r3
  }
  else
  {
    regval &= ~maskline;
240032e8:	439e      	bicpl	r6, r3
  }

  /* Store event mode */
  *regaddr = regval;
240032ea:	f8c0 6084 	str.w	r6, [r0, #132]	@ 0x84
  /* Store event mode */
  *regaddr = regval;
#endif /* DUAL_CORE */

  /* Configure the D3 PendClear source in case of Wakeup target is Any */
  if ((pExtiConfig->Line & EXTI_TARGET_MASK) == EXTI_TARGET_MSK_ALL)
240032ee:	6808      	ldr	r0, [r1, #0]
240032f0:	f400 1040 	and.w	r0, r0, #3145728	@ 0x300000
240032f4:	f5b0 1f40 	cmp.w	r0, #3145728	@ 0x300000
240032f8:	d108      	bne.n	2400330c <HAL_EXTI_SetConfigLine+0xc0>
  {
    assert_param(IS_EXTI_D3_PENDCLR_SRC(pExtiConfig->PendClearSource));

    /*Calc the PMR register address for the given line */
    regaddr = (__IO uint32_t *)(&EXTI->D3PMR1 + (EXTI_CONFIG_OFFSET * offset));
240032fa:	0152      	lsls	r2, r2, #5
    regval = *regaddr;

    if(pExtiConfig->PendClearSource == EXTI_D3_PENDCLR_SRC_NONE)
240032fc:	690e      	ldr	r6, [r1, #16]
    regaddr = (__IO uint32_t *)(&EXTI->D3PMR1 + (EXTI_CONFIG_OFFSET * offset));
240032fe:	f102 42b0 	add.w	r2, r2, #1476395008	@ 0x58000000
    regval = *regaddr;
24003302:	68d0      	ldr	r0, [r2, #12]
    if(pExtiConfig->PendClearSource == EXTI_D3_PENDCLR_SRC_NONE)
24003304:	b926      	cbnz	r6, 24003310 <HAL_EXTI_SetConfigLine+0xc4>
    {
      /* Clear D3PMRx register for the given line */
      regval &= ~maskline;
24003306:	ea20 0003 	bic.w	r0, r0, r3
      /* Store D3PMRx register value */
      *regaddr = regval;
2400330a:	60d0      	str	r0, [r2, #12]
      regval = (*regaddr & (~(pcrlinepos * pcrlinepos * 3UL))) | (pcrlinepos * pcrlinepos * (pExtiConfig->PendClearSource - 1UL));
      *regaddr = regval;
    }
  }

  return HAL_OK;
2400330c:	2000      	movs	r0, #0
}
2400330e:	bdf0      	pop	{r4, r5, r6, r7, pc}
      regval |= maskline;
24003310:	4318      	orrs	r0, r3
      *regaddr = regval;
24003312:	60d0      	str	r0, [r2, #12]
      if(linepos < 16UL)
24003314:	06e0      	lsls	r0, r4, #27
      regval = (*regaddr & (~(pcrlinepos * pcrlinepos * 3UL))) | (pcrlinepos * pcrlinepos * (pExtiConfig->PendClearSource - 1UL));
24003316:	6909      	ldr	r1, [r1, #16]
        pcrlinepos = 1UL << (linepos - 16UL);
24003318:	bf45      	ittet	mi
2400331a:	2301      	movmi	r3, #1
2400331c:	3d10      	submi	r5, #16
        regaddr = (__IO uint32_t *)(&EXTI->D3PCR1L + (EXTI_CONFIG_OFFSET * offset));
2400331e:	3210      	addpl	r2, #16
        regaddr = (__IO uint32_t *)(&EXTI->D3PCR1H + (EXTI_CONFIG_OFFSET * offset));
24003320:	3214      	addmi	r2, #20
        pcrlinepos = 1UL << (linepos - 16UL);
24003322:	bf48      	it	mi
24003324:	40ab      	lslmi	r3, r5
      regval = (*regaddr & (~(pcrlinepos * pcrlinepos * 3UL))) | (pcrlinepos * pcrlinepos * (pExtiConfig->PendClearSource - 1UL));
24003326:	3901      	subs	r1, #1
24003328:	6810      	ldr	r0, [r2, #0]
2400332a:	435b      	muls	r3, r3
2400332c:	eb03 0443 	add.w	r4, r3, r3, lsl #1
24003330:	434b      	muls	r3, r1
24003332:	ea20 0004 	bic.w	r0, r0, r4
24003336:	4303      	orrs	r3, r0
      *regaddr = regval;
24003338:	6013      	str	r3, [r2, #0]
2400333a:	e7e7      	b.n	2400330c <HAL_EXTI_SetConfigLine+0xc0>
    return HAL_ERROR;
2400333c:	2001      	movs	r0, #1
2400333e:	e7e6      	b.n	2400330e <HAL_EXTI_SetConfigLine+0xc2>

24003340 <HAL_EXTI_GetConfigLine>:
  * @param  hexti Exti handle.
  * @param  pExtiConfig Pointer on structure to store Exti configuration.
  * @retval HAL Status.
  */
HAL_StatusTypeDef HAL_EXTI_GetConfigLine(EXTI_HandleTypeDef *hexti, EXTI_ConfigTypeDef *pExtiConfig)
{
24003340:	b570      	push	{r4, r5, r6, lr}
  uint32_t maskline;
  uint32_t offset;
  uint32_t pcrlinepos;

  /* Check null pointer */
  if ((hexti == NULL) || (pExtiConfig == NULL))
24003342:	2800      	cmp	r0, #0
24003344:	d063      	beq.n	2400340e <HAL_EXTI_GetConfigLine+0xce>
24003346:	2900      	cmp	r1, #0
24003348:	d061      	beq.n	2400340e <HAL_EXTI_GetConfigLine+0xce>

  /* Check the parameter */
  assert_param(IS_EXTI_LINE(hexti->Line));

  /* Store handle line number to configuration structure */
  pExtiConfig->Line = hexti->Line;
2400334a:	6805      	ldr	r5, [r0, #0]

  /* compute line register offset and line mask */
  offset = ((pExtiConfig->Line & EXTI_REG_MASK) >> EXTI_REG_SHIFT);
  linepos = (pExtiConfig->Line & EXTI_PIN_MASK);
  maskline = (1UL << linepos);
2400334c:	2301      	movs	r3, #1
  offset = ((pExtiConfig->Line & EXTI_REG_MASK) >> EXTI_REG_SHIFT);
2400334e:	f3c5 4001 	ubfx	r0, r5, #16, #2
  linepos = (pExtiConfig->Line & EXTI_PIN_MASK);
24003352:	f005 041f 	and.w	r4, r5, #31
  pExtiConfig->Line = hexti->Line;
24003356:	600d      	str	r5, [r1, #0]

  /* 1] Get core mode : interrupt */
  regaddr = (__IO uint32_t *)(&EXTI->IMR1 + (EXTI_MODE_OFFSET * offset));
24003358:	0106      	lsls	r6, r0, #4
  maskline = (1UL << linepos);
2400335a:	40a3      	lsls	r3, r4
  regaddr = (__IO uint32_t *)(&EXTI->IMR1 + (EXTI_MODE_OFFSET * offset));
2400335c:	f106 46b0 	add.w	r6, r6, #1476395008	@ 0x58000000
  regval = *regaddr;
24003360:	f8d6 2080 	ldr.w	r2, [r6, #128]	@ 0x80

  pExtiConfig->Mode = EXTI_MODE_NONE;

  /* Check if selected line is enable */
  if ((regval & maskline) != 0x00U)
24003364:	4213      	tst	r3, r2
24003366:	bf14      	ite	ne
24003368:	2201      	movne	r2, #1
2400336a:	2200      	moveq	r2, #0
2400336c:	604a      	str	r2, [r1, #4]
    pExtiConfig->Mode = EXTI_MODE_INTERRUPT;
  }

  /* Get event mode */
  regaddr = (__IO uint32_t *)(&EXTI->EMR1 + (EXTI_MODE_OFFSET * offset));
  regval = *regaddr;
2400336e:	f8d6 6084 	ldr.w	r6, [r6, #132]	@ 0x84

  /* Check if selected line is enable */
  if ((regval & maskline) != 0x00U)
24003372:	4233      	tst	r3, r6
  {
    pExtiConfig->Mode |= EXTI_MODE_EVENT;
24003374:	bf1c      	itt	ne
24003376:	f042 0202 	orrne.w	r2, r2, #2
2400337a:	604a      	strne	r2, [r1, #4]
    pExtiConfig->Mode |= EXTI_MODE_CORE2_EVENT;
  }
#endif /*DUAL_CORE*/

  /* 2] Get trigger for configurable lines : rising */
  if ((pExtiConfig->Line & EXTI_CONFIG) != 0x00U)
2400337c:	f015 7200 	ands.w	r2, r5, #33554432	@ 0x2000000
24003380:	d030      	beq.n	240033e4 <HAL_EXTI_GetConfigLine+0xa4>
  {
    regaddr = (__IO uint32_t *)(&EXTI->RTSR1 + (EXTI_CONFIG_OFFSET * offset));
24003382:	0146      	lsls	r6, r0, #5
24003384:	f106 46b0 	add.w	r6, r6, #1476395008	@ 0x58000000
    regval = *regaddr;
24003388:	6832      	ldr	r2, [r6, #0]

    /* Check if configuration of selected line is enable */
    if ((regval & maskline) != 0x00U)
2400338a:	4213      	tst	r3, r2
2400338c:	bf14      	ite	ne
2400338e:	2201      	movne	r2, #1
24003390:	2200      	moveq	r2, #0
24003392:	608a      	str	r2, [r1, #8]
      pExtiConfig->Trigger = EXTI_TRIGGER_NONE;
    }

    /* Get falling configuration */
    regaddr = (__IO uint32_t *)(&EXTI->FTSR1 + (EXTI_CONFIG_OFFSET * offset));
    regval = *regaddr;
24003394:	6876      	ldr	r6, [r6, #4]

    /* Check if configuration of selected line is enable */
    if ((regval & maskline) != 0x00U)
24003396:	4233      	tst	r3, r6
    {
      pExtiConfig->Trigger |= EXTI_TRIGGER_FALLING;
24003398:	bf1c      	itt	ne
2400339a:	f042 0202 	orrne.w	r2, r2, #2
2400339e:	608a      	strne	r2, [r1, #8]
    }

    /* Get Gpio port selection for gpio lines */
    if ((pExtiConfig->Line & EXTI_GPIO) == EXTI_GPIO)
240033a0:	f005 62c0 	and.w	r2, r5, #100663296	@ 0x6000000
240033a4:	f1b2 6fc0 	cmp.w	r2, #100663296	@ 0x6000000
240033a8:	d00f      	beq.n	240033ca <HAL_EXTI_GetConfigLine+0x8a>
{
240033aa:	2200      	movs	r2, #0
      regval = SYSCFG->EXTICR[(linepos >> 2U) & 0x03UL];
      pExtiConfig->GPIOSel = ((regval << (SYSCFG_EXTICR1_EXTI1_Pos * (3UL - (linepos & 0x03UL)))) >> 24U);
    }
    else
    {
      pExtiConfig->GPIOSel = 0x00U;
240033ac:	60ca      	str	r2, [r1, #12]
    pExtiConfig->Trigger = EXTI_TRIGGER_NONE;
    pExtiConfig->GPIOSel = 0x00U;
  }

  /* 3] Get D3 Pend Clear source */
  if ((pExtiConfig->Line & EXTI_TARGET_MASK) == EXTI_TARGET_MSK_ALL)
240033ae:	f405 1240 	and.w	r2, r5, #3145728	@ 0x300000
240033b2:	f5b2 1f40 	cmp.w	r2, #3145728	@ 0x300000
240033b6:	d117      	bne.n	240033e8 <HAL_EXTI_GetConfigLine+0xa8>
  {
    regaddr = (__IO uint32_t *)(&EXTI->D3PMR1 + (EXTI_CONFIG_OFFSET * offset));
240033b8:	0140      	lsls	r0, r0, #5
240033ba:	f100 40b0 	add.w	r0, r0, #1476395008	@ 0x58000000
    if(((*regaddr) & linepos) == 0UL)
240033be:	68c2      	ldr	r2, [r0, #12]
240033c0:	4022      	ands	r2, r4
240033c2:	d113      	bne.n	240033ec <HAL_EXTI_GetConfigLine+0xac>
  {
    /* if line wakeup target is not any, then no pend clear source is used  */
    pExtiConfig->PendClearSource = EXTI_D3_PENDCLR_SRC_NONE;
  }

  return HAL_OK;
240033c4:	2000      	movs	r0, #0
      pExtiConfig->PendClearSource = EXTI_D3_PENDCLR_SRC_NONE;
240033c6:	610a      	str	r2, [r1, #16]
}
240033c8:	bd70      	pop	{r4, r5, r6, pc}
      regval = SYSCFG->EXTICR[(linepos >> 2U) & 0x03UL];
240033ca:	f3c4 0281 	ubfx	r2, r4, #2, #2
240033ce:	4e11      	ldr	r6, [pc, #68]	@ (24003414 <HAL_EXTI_GetConfigLine+0xd4>)
240033d0:	3202      	adds	r2, #2
240033d2:	f856 2022 	ldr.w	r2, [r6, r2, lsl #2]
      pExtiConfig->GPIOSel = ((regval << (SYSCFG_EXTICR1_EXTI1_Pos * (3UL - (linepos & 0x03UL)))) >> 24U);
240033d6:	43e6      	mvns	r6, r4
240033d8:	f006 0603 	and.w	r6, r6, #3
240033dc:	00b6      	lsls	r6, r6, #2
240033de:	40b2      	lsls	r2, r6
240033e0:	0e12      	lsrs	r2, r2, #24
240033e2:	e7e3      	b.n	240033ac <HAL_EXTI_GetConfigLine+0x6c>
    pExtiConfig->Trigger = EXTI_TRIGGER_NONE;
240033e4:	608a      	str	r2, [r1, #8]
    pExtiConfig->GPIOSel = 0x00U;
240033e6:	e7e0      	b.n	240033aa <HAL_EXTI_GetConfigLine+0x6a>
240033e8:	2200      	movs	r2, #0
240033ea:	e7eb      	b.n	240033c4 <HAL_EXTI_GetConfigLine+0x84>
      if(linepos < 16UL)
240033ec:	06ea      	lsls	r2, r5, #27
        pcrlinepos = 1UL << (linepos - 16UL);
240033ee:	bf45      	ittet	mi
240033f0:	2301      	movmi	r3, #1
240033f2:	3c10      	submi	r4, #16
        regaddr = (__IO uint32_t *)(&EXTI->D3PCR1L + (EXTI_CONFIG_OFFSET * offset));
240033f4:	3010      	addpl	r0, #16
        regaddr = (__IO uint32_t *)(&EXTI->D3PCR1H + (EXTI_CONFIG_OFFSET * offset));
240033f6:	3014      	addmi	r0, #20
        pcrlinepos = 1UL << (linepos - 16UL);
240033f8:	bf48      	it	mi
240033fa:	40a3      	lslmi	r3, r4
      pExtiConfig->PendClearSource = 1UL + ((*regaddr & (pcrlinepos * pcrlinepos * 3UL)) / (pcrlinepos * pcrlinepos));
240033fc:	6800      	ldr	r0, [r0, #0]
240033fe:	435b      	muls	r3, r3
24003400:	eb03 0243 	add.w	r2, r3, r3, lsl #1
24003404:	4002      	ands	r2, r0
24003406:	fbb2 f2f3 	udiv	r2, r2, r3
2400340a:	3201      	adds	r2, #1
2400340c:	e7da      	b.n	240033c4 <HAL_EXTI_GetConfigLine+0x84>
    return HAL_ERROR;
2400340e:	2001      	movs	r0, #1
24003410:	e7da      	b.n	240033c8 <HAL_EXTI_GetConfigLine+0x88>
24003412:	bf00      	nop
24003414:	58000400 	.word	0x58000400

24003418 <HAL_EXTI_ClearConfigLine>:
  * @brief  Clear whole configuration of a dedicated Exti line.
  * @param  hexti Exti handle.
  * @retval HAL Status.
  */
HAL_StatusTypeDef HAL_EXTI_ClearConfigLine(EXTI_HandleTypeDef *hexti)
{
24003418:	b5f0      	push	{r4, r5, r6, r7, lr}
  uint32_t maskline;
  uint32_t offset;
  uint32_t pcrlinepos;

  /* Check null pointer */
  if (hexti == NULL)
2400341a:	2800      	cmp	r0, #0
2400341c:	d058      	beq.n	240034d0 <HAL_EXTI_ClearConfigLine+0xb8>

  /* Check the parameter */
  assert_param(IS_EXTI_LINE(hexti->Line));

  /* compute line register offset and line mask */
  offset = ((hexti->Line & EXTI_REG_MASK) >> EXTI_REG_SHIFT);
2400341e:	6806      	ldr	r6, [r0, #0]
  linepos = (hexti->Line & EXTI_PIN_MASK);
  maskline = (1UL << linepos);
24003420:	2301      	movs	r3, #1
  offset = ((hexti->Line & EXTI_REG_MASK) >> EXTI_REG_SHIFT);
24003422:	f3c6 4201 	ubfx	r2, r6, #16, #2
  linepos = (hexti->Line & EXTI_PIN_MASK);
24003426:	f006 041f 	and.w	r4, r6, #31

  /* 1] Clear interrupt mode */
  regaddr = (__IO uint32_t *)(&EXTI->IMR1 + (EXTI_MODE_OFFSET * offset));
2400342a:	0111      	lsls	r1, r2, #4
  maskline = (1UL << linepos);
2400342c:	40a3      	lsls	r3, r4
  regaddr = (__IO uint32_t *)(&EXTI->IMR1 + (EXTI_MODE_OFFSET * offset));
2400342e:	f101 41b0 	add.w	r1, r1, #1476395008	@ 0x58000000
  regval = (*regaddr & ~maskline);
24003432:	43dd      	mvns	r5, r3
24003434:	f8d1 7080 	ldr.w	r7, [r1, #128]	@ 0x80
24003438:	ea27 0703 	bic.w	r7, r7, r3
  *regaddr = regval;
2400343c:	f8c1 7080 	str.w	r7, [r1, #128]	@ 0x80

  /* 2] Clear event mode */
  regaddr = (__IO uint32_t *)(&EXTI->EMR1 + (EXTI_MODE_OFFSET * offset));
  regval = (*regaddr & ~maskline);
24003440:	f8d1 7084 	ldr.w	r7, [r1, #132]	@ 0x84
24003444:	ea27 0703 	bic.w	r7, r7, r3
  *regaddr = regval;
24003448:	f8c1 7084 	str.w	r7, [r1, #132]	@ 0x84
  regval = (*regaddr & ~maskline);
  *regaddr = regval;
#endif /* DUAL_CORE */

  /* 3] Clear triggers in case of configurable lines */
  if ((hexti->Line & EXTI_CONFIG) != 0x00U)
2400344c:	6801      	ldr	r1, [r0, #0]
2400344e:	018f      	lsls	r7, r1, #6
24003450:	d520      	bpl.n	24003494 <HAL_EXTI_ClearConfigLine+0x7c>
  {
    regaddr = (__IO uint32_t *)(&EXTI->RTSR1 + (EXTI_CONFIG_OFFSET * offset));
24003452:	0151      	lsls	r1, r2, #5
24003454:	f101 41b0 	add.w	r1, r1, #1476395008	@ 0x58000000
    regval = (*regaddr & ~maskline);
24003458:	680f      	ldr	r7, [r1, #0]
2400345a:	402f      	ands	r7, r5
    *regaddr = regval;
2400345c:	600f      	str	r7, [r1, #0]

    regaddr = (__IO uint32_t *)(&EXTI->FTSR1 + (EXTI_CONFIG_OFFSET * offset));
    regval = (*regaddr & ~maskline);
2400345e:	684f      	ldr	r7, [r1, #4]
24003460:	402f      	ands	r7, r5
    *regaddr = regval;
24003462:	604f      	str	r7, [r1, #4]

    /* Get Gpio port selection for gpio lines */
    if ((hexti->Line & EXTI_GPIO) == EXTI_GPIO)
24003464:	6801      	ldr	r1, [r0, #0]
24003466:	f001 61c0 	and.w	r1, r1, #100663296	@ 0x6000000
2400346a:	f1b1 6fc0 	cmp.w	r1, #100663296	@ 0x6000000
2400346e:	d111      	bne.n	24003494 <HAL_EXTI_ClearConfigLine+0x7c>
    {
      assert_param(IS_EXTI_GPIO_PIN(linepos));

      regval = SYSCFG->EXTICR[(linepos >> 2U) & 0x03UL];
24003470:	f004 010c 	and.w	r1, r4, #12
      regval &= ~(SYSCFG_EXTICR1_EXTI0 << (SYSCFG_EXTICR1_EXTI1_Pos * (linepos & 0x03UL)));
24003474:	f006 0e03 	and.w	lr, r6, #3
24003478:	f04f 0c0f 	mov.w	ip, #15
2400347c:	f101 41b0 	add.w	r1, r1, #1476395008	@ 0x58000000
24003480:	ea4f 0e8e 	mov.w	lr, lr, lsl #2
      regval = SYSCFG->EXTICR[(linepos >> 2U) & 0x03UL];
24003484:	f8d1 7408 	ldr.w	r7, [r1, #1032]	@ 0x408
      regval &= ~(SYSCFG_EXTICR1_EXTI0 << (SYSCFG_EXTICR1_EXTI1_Pos * (linepos & 0x03UL)));
24003488:	fa0c fc0e 	lsl.w	ip, ip, lr
2400348c:	ea27 070c 	bic.w	r7, r7, ip
      SYSCFG->EXTICR[(linepos >> 2U) & 0x03UL] = regval;
24003490:	f8c1 7408 	str.w	r7, [r1, #1032]	@ 0x408
    }
  }

  /* 4] Clear D3 Config lines */
  if ((hexti->Line & EXTI_TARGET_MASK) == EXTI_TARGET_MSK_ALL)
24003494:	6801      	ldr	r1, [r0, #0]
24003496:	f401 1140 	and.w	r1, r1, #3145728	@ 0x300000
2400349a:	f5b1 1f40 	cmp.w	r1, #3145728	@ 0x300000
2400349e:	d001      	beq.n	240034a4 <HAL_EXTI_ClearConfigLine+0x8c>

    /*Clear D3 PendClear source */
    *regaddr &= (~(pcrlinepos * pcrlinepos * 3UL));
  }

  return HAL_OK;
240034a0:	2000      	movs	r0, #0
}
240034a2:	bdf0      	pop	{r4, r5, r6, r7, pc}
    regaddr = (__IO uint32_t *)(&EXTI->D3PMR1 + (EXTI_CONFIG_OFFSET * offset));
240034a4:	0152      	lsls	r2, r2, #5
240034a6:	f102 42b0 	add.w	r2, r2, #1476395008	@ 0x58000000
    *regaddr = (*regaddr & ~maskline);
240034aa:	68d1      	ldr	r1, [r2, #12]
240034ac:	400d      	ands	r5, r1
    if(linepos < 16UL)
240034ae:	06f1      	lsls	r1, r6, #27
      pcrlinepos = 1UL << (linepos - 16UL);
240034b0:	bf44      	itt	mi
240034b2:	2301      	movmi	r3, #1
240034b4:	3c10      	submi	r4, #16
    *regaddr = (*regaddr & ~maskline);
240034b6:	60d5      	str	r5, [r2, #12]
      regaddr = (__IO uint32_t *)(&EXTI->D3PCR1L + (EXTI_CONFIG_OFFSET * offset));
240034b8:	bf52      	itee	pl
240034ba:	3210      	addpl	r2, #16
      pcrlinepos = 1UL << (linepos - 16UL);
240034bc:	40a3      	lslmi	r3, r4
      regaddr = (__IO uint32_t *)(&EXTI->D3PCR1H + (EXTI_CONFIG_OFFSET * offset));
240034be:	3214      	addmi	r2, #20
    *regaddr &= (~(pcrlinepos * pcrlinepos * 3UL));
240034c0:	435b      	muls	r3, r3
240034c2:	6811      	ldr	r1, [r2, #0]
240034c4:	eb03 0343 	add.w	r3, r3, r3, lsl #1
240034c8:	ea21 0303 	bic.w	r3, r1, r3
240034cc:	6013      	str	r3, [r2, #0]
240034ce:	e7e7      	b.n	240034a0 <HAL_EXTI_ClearConfigLine+0x88>
    return HAL_ERROR;
240034d0:	2001      	movs	r0, #1
240034d2:	e7e6      	b.n	240034a2 <HAL_EXTI_ClearConfigLine+0x8a>

240034d4 <HAL_EXTI_RegisterCallback>:
HAL_StatusTypeDef HAL_EXTI_RegisterCallback(EXTI_HandleTypeDef *hexti, EXTI_CallbackIDTypeDef CallbackID, void (*pPendingCbfn)(void))
{
  HAL_StatusTypeDef status = HAL_OK;

  /* Check null pointer */
  if (hexti == NULL)
240034d4:	b118      	cbz	r0, 240034de <HAL_EXTI_RegisterCallback+0xa>
  {
    return HAL_ERROR;
  }

  switch (CallbackID)
240034d6:	b911      	cbnz	r1, 240034de <HAL_EXTI_RegisterCallback+0xa>
  {
    case  HAL_EXTI_COMMON_CB_ID:
      hexti->PendingCallback = pPendingCbfn;
240034d8:	6042      	str	r2, [r0, #4]
      status = HAL_ERROR;
      break;
  }

  return status;
}
240034da:	4608      	mov	r0, r1
240034dc:	4770      	bx	lr
    return HAL_ERROR;
240034de:	2101      	movs	r1, #1
240034e0:	e7fb      	b.n	240034da <HAL_EXTI_RegisterCallback+0x6>

240034e2 <HAL_EXTI_GetHandle>:
{
  /* Check the parameters */
  assert_param(IS_EXTI_LINE(ExtiLine));

  /* Check null pointer */
  if (hexti == NULL)
240034e2:	b110      	cbz	r0, 240034ea <HAL_EXTI_GetHandle+0x8>
    return HAL_ERROR;
  }
  else
  {
    /* Store line number as handle private field */
    hexti->Line = ExtiLine;
240034e4:	6001      	str	r1, [r0, #0]

    return HAL_OK;
240034e6:	2000      	movs	r0, #0
240034e8:	4770      	bx	lr
    return HAL_ERROR;
240034ea:	2001      	movs	r0, #1
  }
}
240034ec:	4770      	bx	lr

240034ee <HAL_EXTI_IRQHandler>:
  uint32_t regval;
  uint32_t maskline;
  uint32_t offset;

  /* Compute line register offset and line mask */
  offset = ((hexti->Line & EXTI_REG_MASK) >> EXTI_REG_SHIFT);
240034ee:	6803      	ldr	r3, [r0, #0]
  maskline = (1UL << (hexti->Line & EXTI_PIN_MASK));
240034f0:	2201      	movs	r2, #1
240034f2:	f003 011f 	and.w	r1, r3, #31
  offset = ((hexti->Line & EXTI_REG_MASK) >> EXTI_REG_SHIFT);
240034f6:	f3c3 4301 	ubfx	r3, r3, #16, #2
  {
    /* Get pending register address */
    regaddr = (__IO uint32_t *)(&EXTI->C2PR1 + (EXTI_MODE_OFFSET * offset));
  }
#else
  regaddr = (__IO uint32_t *)(&EXTI->PR1 + (EXTI_MODE_OFFSET * offset));
240034fa:	011b      	lsls	r3, r3, #4
  maskline = (1UL << (hexti->Line & EXTI_PIN_MASK));
240034fc:	408a      	lsls	r2, r1
  regaddr = (__IO uint32_t *)(&EXTI->PR1 + (EXTI_MODE_OFFSET * offset));
240034fe:	f103 43b0 	add.w	r3, r3, #1476395008	@ 0x58000000
#endif /* DUAL_CORE */

  /* Get pending bit  */
  regval = (*regaddr & maskline);
24003502:	f8d3 1088 	ldr.w	r1, [r3, #136]	@ 0x88

  if (regval != 0x00U)
24003506:	4211      	tst	r1, r2
24003508:	d004      	beq.n	24003514 <HAL_EXTI_IRQHandler+0x26>
  {
    /* Clear pending bit */
    *regaddr = maskline;
2400350a:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88

    /* Call callback */
    if (hexti->PendingCallback != NULL)
2400350e:	6843      	ldr	r3, [r0, #4]
24003510:	b103      	cbz	r3, 24003514 <HAL_EXTI_IRQHandler+0x26>
    {
      hexti->PendingCallback();
24003512:	4718      	bx	r3
    }
  }
}
24003514:	4770      	bx	lr

24003516 <HAL_EXTI_GetPending>:
  assert_param(IS_EXTI_LINE(hexti->Line));
  assert_param(IS_EXTI_CONFIG_LINE(hexti->Line));
  assert_param(IS_EXTI_PENDING_EDGE(Edge));

  /* compute line register offset and line mask */
  offset = ((hexti->Line & EXTI_REG_MASK) >> EXTI_REG_SHIFT);
24003516:	6803      	ldr	r3, [r0, #0]
  linepos = (hexti->Line & EXTI_PIN_MASK);
24003518:	f003 001f 	and.w	r0, r3, #31
  offset = ((hexti->Line & EXTI_REG_MASK) >> EXTI_REG_SHIFT);
2400351c:	f3c3 4301 	ubfx	r3, r3, #16, #2
  {
    /* Get pending register address */
    regaddr = (__IO uint32_t *)(&EXTI->C2PR1 + (EXTI_MODE_OFFSET * offset));
  }
#else
  regaddr = (__IO uint32_t *)(&EXTI->PR1 + (EXTI_MODE_OFFSET * offset));
24003520:	011b      	lsls	r3, r3, #4
24003522:	f103 43b0 	add.w	r3, r3, #1476395008	@ 0x58000000
#endif /* DUAL_CORE */

  /* return 1 if bit is set else 0 */
  regval = ((*regaddr & maskline) >> linepos);
24003526:	f8d3 2088 	ldr.w	r2, [r3, #136]	@ 0x88
  maskline = (1UL << linepos);
2400352a:	2301      	movs	r3, #1
2400352c:	4083      	lsls	r3, r0
  regval = ((*regaddr & maskline) >> linepos);
2400352e:	4013      	ands	r3, r2
  return regval;
}
24003530:	fa23 f000 	lsr.w	r0, r3, r0
24003534:	4770      	bx	lr

24003536 <HAL_EXTI_ClearPending>:
  assert_param(IS_EXTI_LINE(hexti->Line));
  assert_param(IS_EXTI_CONFIG_LINE(hexti->Line));
  assert_param(IS_EXTI_PENDING_EDGE(Edge));

  /* compute line register offset and line mask */
  offset = ((hexti->Line & EXTI_REG_MASK) >> EXTI_REG_SHIFT);
24003536:	6803      	ldr	r3, [r0, #0]
  maskline = (1UL << (hexti->Line & EXTI_PIN_MASK));
24003538:	2201      	movs	r2, #1
2400353a:	f003 011f 	and.w	r1, r3, #31
  offset = ((hexti->Line & EXTI_REG_MASK) >> EXTI_REG_SHIFT);
2400353e:	f3c3 4301 	ubfx	r3, r3, #16, #2
  {
    /* Get pending register address */
    regaddr = (__IO uint32_t *)(&EXTI->C2PR1 + (EXTI_MODE_OFFSET * offset));
  }
#else
  regaddr = (__IO uint32_t *)(&EXTI->PR1 + (EXTI_MODE_OFFSET * offset));
24003542:	011b      	lsls	r3, r3, #4
  maskline = (1UL << (hexti->Line & EXTI_PIN_MASK));
24003544:	408a      	lsls	r2, r1
  regaddr = (__IO uint32_t *)(&EXTI->PR1 + (EXTI_MODE_OFFSET * offset));
24003546:	f103 43b0 	add.w	r3, r3, #1476395008	@ 0x58000000
#endif /* DUAL_CORE */

  /* Clear Pending bit */
  *regaddr =  maskline;
2400354a:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88
}
2400354e:	4770      	bx	lr

24003550 <HAL_EXTI_GenerateSWI>:
  /* Check parameters */
  assert_param(IS_EXTI_LINE(hexti->Line));
  assert_param(IS_EXTI_CONFIG_LINE(hexti->Line));

  /* compute line register offset and line mask */
  offset = ((hexti->Line & EXTI_REG_MASK) >> EXTI_REG_SHIFT);
24003550:	6803      	ldr	r3, [r0, #0]
  maskline = (1UL << (hexti->Line & EXTI_PIN_MASK));
24003552:	2201      	movs	r2, #1
24003554:	f003 011f 	and.w	r1, r3, #31
  offset = ((hexti->Line & EXTI_REG_MASK) >> EXTI_REG_SHIFT);
24003558:	f3c3 4301 	ubfx	r3, r3, #16, #2

  regaddr = (__IO uint32_t *)(&EXTI->SWIER1 + (EXTI_CONFIG_OFFSET * offset));
2400355c:	015b      	lsls	r3, r3, #5
  maskline = (1UL << (hexti->Line & EXTI_PIN_MASK));
2400355e:	408a      	lsls	r2, r1
  regaddr = (__IO uint32_t *)(&EXTI->SWIER1 + (EXTI_CONFIG_OFFSET * offset));
24003560:	f103 43b0 	add.w	r3, r3, #1476395008	@ 0x58000000
  *regaddr = maskline;
24003564:	609a      	str	r2, [r3, #8]
}
24003566:	4770      	bx	lr

24003568 <HAL_FLASH_EndOfOperationCallback>:
  UNUSED(ReturnValue);

  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_FLASH_EndOfOperationCallback could be implemented in the user file
   */
}
24003568:	4770      	bx	lr

2400356a <HAL_FLASH_OperationErrorCallback>:
  *                 Mass Erase: Bank number which has been requested to erase
  *                 Sectors Erase: Sector number which returned an error
  *                 Program: Address which was selected for data program
  * @retval None
  */
__weak void HAL_FLASH_OperationErrorCallback(uint32_t ReturnValue)
2400356a:	4770      	bx	lr

2400356c <HAL_FLASH_IRQHandler>:
{
2400356c:	b570      	push	{r4, r5, r6, lr}
  if(__HAL_FLASH_GET_FLAG_BANK1(FLASH_SR_EOP) != RESET)
2400356e:	4d6a      	ldr	r5, [pc, #424]	@ (24003718 <HAL_FLASH_IRQHandler+0x1ac>)
24003570:	4c6a      	ldr	r4, [pc, #424]	@ (2400371c <HAL_FLASH_IRQHandler+0x1b0>)
24003572:	692b      	ldr	r3, [r5, #16]
24003574:	f413 3f80 	tst.w	r3, #65536	@ 0x10000
24003578:	d017      	beq.n	240035aa <HAL_FLASH_IRQHandler+0x3e>
    if(pFlash.ProcedureOnGoing == FLASH_PROC_SECTERASE_BANK1)
2400357a:	7823      	ldrb	r3, [r4, #0]
2400357c:	2b01      	cmp	r3, #1
2400357e:	b2de      	uxtb	r6, r3
24003580:	d17b      	bne.n	2400367a <HAL_FLASH_IRQHandler+0x10e>
      pFlash.NbSectorsToErase--;
24003582:	6863      	ldr	r3, [r4, #4]
24003584:	3b01      	subs	r3, #1
24003586:	6063      	str	r3, [r4, #4]
      if(pFlash.NbSectorsToErase != 0U)
24003588:	6863      	ldr	r3, [r4, #4]
2400358a:	2b00      	cmp	r3, #0
2400358c:	d06a      	beq.n	24003664 <HAL_FLASH_IRQHandler+0xf8>
        HAL_FLASH_EndOfOperationCallback(pFlash.Sector);
2400358e:	68e0      	ldr	r0, [r4, #12]
24003590:	f7ff ffea 	bl	24003568 <HAL_FLASH_EndOfOperationCallback>
        __HAL_FLASH_CLEAR_FLAG_BANK1(FLASH_FLAG_EOP_BANK1);
24003594:	f44f 3380 	mov.w	r3, #65536	@ 0x10000
        FLASH_Erase_Sector(temp, FLASH_BANK_1, pFlash.VoltageForErase);
24003598:	4631      	mov	r1, r6
        __HAL_FLASH_CLEAR_FLAG_BANK1(FLASH_FLAG_EOP_BANK1);
2400359a:	616b      	str	r3, [r5, #20]
        pFlash.Sector++;
2400359c:	68e3      	ldr	r3, [r4, #12]
2400359e:	3301      	adds	r3, #1
240035a0:	60e3      	str	r3, [r4, #12]
        temp = pFlash.Sector;
240035a2:	68e0      	ldr	r0, [r4, #12]
        FLASH_Erase_Sector(temp, FLASH_BANK_1, pFlash.VoltageForErase);
240035a4:	68a2      	ldr	r2, [r4, #8]
240035a6:	f000 fd67 	bl	24004078 <FLASH_Erase_Sector>
  if(__HAL_FLASH_GET_FLAG_BANK2(FLASH_SR_EOP) != RESET)
240035aa:	4d5b      	ldr	r5, [pc, #364]	@ (24003718 <HAL_FLASH_IRQHandler+0x1ac>)
240035ac:	f8d5 3110 	ldr.w	r3, [r5, #272]	@ 0x110
240035b0:	03db      	lsls	r3, r3, #15
240035b2:	d518      	bpl.n	240035e6 <HAL_FLASH_IRQHandler+0x7a>
    if(pFlash.ProcedureOnGoing == FLASH_PROC_SECTERASE_BANK2)
240035b4:	7823      	ldrb	r3, [r4, #0]
240035b6:	2b04      	cmp	r3, #4
240035b8:	f040 8084 	bne.w	240036c4 <HAL_FLASH_IRQHandler+0x158>
      pFlash.NbSectorsToErase--;
240035bc:	6863      	ldr	r3, [r4, #4]
240035be:	3b01      	subs	r3, #1
240035c0:	6063      	str	r3, [r4, #4]
      if(pFlash.NbSectorsToErase != 0U)
240035c2:	6863      	ldr	r3, [r4, #4]
240035c4:	2b00      	cmp	r3, #0
240035c6:	d071      	beq.n	240036ac <HAL_FLASH_IRQHandler+0x140>
        HAL_FLASH_EndOfOperationCallback(pFlash.Sector);
240035c8:	68e0      	ldr	r0, [r4, #12]
240035ca:	f7ff ffcd 	bl	24003568 <HAL_FLASH_EndOfOperationCallback>
        __HAL_FLASH_CLEAR_FLAG_BANK2(FLASH_FLAG_EOP_BANK2);
240035ce:	f44f 3380 	mov.w	r3, #65536	@ 0x10000
        FLASH_Erase_Sector(temp, FLASH_BANK_2, pFlash.VoltageForErase);
240035d2:	2102      	movs	r1, #2
        __HAL_FLASH_CLEAR_FLAG_BANK2(FLASH_FLAG_EOP_BANK2);
240035d4:	f8c5 3114 	str.w	r3, [r5, #276]	@ 0x114
        pFlash.Sector++;
240035d8:	68e3      	ldr	r3, [r4, #12]
240035da:	3301      	adds	r3, #1
240035dc:	60e3      	str	r3, [r4, #12]
        temp = pFlash.Sector;
240035de:	68e0      	ldr	r0, [r4, #12]
        FLASH_Erase_Sector(temp, FLASH_BANK_2, pFlash.VoltageForErase);
240035e0:	68a2      	ldr	r2, [r4, #8]
240035e2:	f000 fd49 	bl	24004078 <FLASH_Erase_Sector>
  errorflag = FLASH->SR1 & (FLASH_FLAG_WRPERR_BANK1 | FLASH_FLAG_PGSERR_BANK1 | FLASH_FLAG_STRBERR_BANK1 | \
240035e6:	494c      	ldr	r1, [pc, #304]	@ (24003718 <HAL_FLASH_IRQHandler+0x1ac>)
240035e8:	690b      	ldr	r3, [r1, #16]
  if(errorflag != 0U)
240035ea:	f413 03dc 	ands.w	r3, r3, #7208960	@ 0x6e0000
240035ee:	d00f      	beq.n	24003610 <HAL_FLASH_IRQHandler+0xa4>
    pFlash.ErrorCode |= errorflag;
240035f0:	69a2      	ldr	r2, [r4, #24]
240035f2:	431a      	orrs	r2, r3
240035f4:	61a2      	str	r2, [r4, #24]
    __HAL_FLASH_CLEAR_FLAG_BANK1(errorflag);
240035f6:	614b      	str	r3, [r1, #20]
    procedure = pFlash.ProcedureOnGoing;
240035f8:	7822      	ldrb	r2, [r4, #0]
    if(procedure == FLASH_PROC_SECTERASE_BANK1)
240035fa:	2a01      	cmp	r2, #1
    procedure = pFlash.ProcedureOnGoing;
240035fc:	b2d3      	uxtb	r3, r2
    if(procedure == FLASH_PROC_SECTERASE_BANK1)
240035fe:	d17b      	bne.n	240036f8 <HAL_FLASH_IRQHandler+0x18c>
      pFlash.Sector = 0xFFFFFFFFU;
24003600:	f04f 33ff 	mov.w	r3, #4294967295
      temp = pFlash.Sector;
24003604:	68e0      	ldr	r0, [r4, #12]
      pFlash.Sector = 0xFFFFFFFFU;
24003606:	60e3      	str	r3, [r4, #12]
    pFlash.ProcedureOnGoing = FLASH_PROC_NONE;
24003608:	2300      	movs	r3, #0
2400360a:	7023      	strb	r3, [r4, #0]
    HAL_FLASH_OperationErrorCallback(temp);
2400360c:	f7ff ffad 	bl	2400356a <HAL_FLASH_OperationErrorCallback>
  errorflag = FLASH->SR2 & ((FLASH_FLAG_WRPERR_BANK2 | FLASH_FLAG_PGSERR_BANK2 | FLASH_FLAG_STRBERR_BANK2 | \
24003610:	4941      	ldr	r1, [pc, #260]	@ (24003718 <HAL_FLASH_IRQHandler+0x1ac>)
24003612:	f8d1 3110 	ldr.w	r3, [r1, #272]	@ 0x110
  if(errorflag != 0U)
24003616:	f413 03dc 	ands.w	r3, r3, #7208960	@ 0x6e0000
2400361a:	d012      	beq.n	24003642 <HAL_FLASH_IRQHandler+0xd6>
    pFlash.ErrorCode |= (errorflag | 0x80000000U);
2400361c:	69a2      	ldr	r2, [r4, #24]
2400361e:	431a      	orrs	r2, r3
24003620:	f042 4200 	orr.w	r2, r2, #2147483648	@ 0x80000000
24003624:	61a2      	str	r2, [r4, #24]
    __HAL_FLASH_CLEAR_FLAG_BANK2(errorflag);
24003626:	f8c1 3114 	str.w	r3, [r1, #276]	@ 0x114
    procedure = pFlash.ProcedureOnGoing;
2400362a:	7822      	ldrb	r2, [r4, #0]
    if(procedure== FLASH_PROC_SECTERASE_BANK2)
2400362c:	2a04      	cmp	r2, #4
    procedure = pFlash.ProcedureOnGoing;
2400362e:	b2d3      	uxtb	r3, r2
    if(procedure== FLASH_PROC_SECTERASE_BANK2)
24003630:	d16a      	bne.n	24003708 <HAL_FLASH_IRQHandler+0x19c>
      pFlash.Sector = 0xFFFFFFFFU;
24003632:	f04f 33ff 	mov.w	r3, #4294967295
      temp = pFlash.Sector;
24003636:	68e0      	ldr	r0, [r4, #12]
      pFlash.Sector = 0xFFFFFFFFU;
24003638:	60e3      	str	r3, [r4, #12]
    pFlash.ProcedureOnGoing = FLASH_PROC_NONE;
2400363a:	2300      	movs	r3, #0
2400363c:	7023      	strb	r3, [r4, #0]
    HAL_FLASH_OperationErrorCallback(temp);
2400363e:	f7ff ff94 	bl	2400356a <HAL_FLASH_OperationErrorCallback>
  if(pFlash.ProcedureOnGoing == FLASH_PROC_NONE)
24003642:	7823      	ldrb	r3, [r4, #0]
24003644:	f003 01ff 	and.w	r1, r3, #255	@ 0xff
24003648:	b95b      	cbnz	r3, 24003662 <HAL_FLASH_IRQHandler+0xf6>
    __HAL_FLASH_DISABLE_IT_BANK1(FLASH_IT_EOP_BANK1    | FLASH_IT_WRPERR_BANK1 | FLASH_IT_PGSERR_BANK1 | \
2400364a:	4b33      	ldr	r3, [pc, #204]	@ (24003718 <HAL_FLASH_IRQHandler+0x1ac>)
2400364c:	68da      	ldr	r2, [r3, #12]
2400364e:	f422 02de 	bic.w	r2, r2, #7274496	@ 0x6f0000
24003652:	60da      	str	r2, [r3, #12]
    __HAL_FLASH_DISABLE_IT_BANK2(FLASH_IT_EOP_BANK2    | FLASH_IT_WRPERR_BANK2 | FLASH_IT_PGSERR_BANK2 | \
24003654:	f8d3 210c 	ldr.w	r2, [r3, #268]	@ 0x10c
24003658:	f422 02de 	bic.w	r2, r2, #7274496	@ 0x6f0000
2400365c:	f8c3 210c 	str.w	r2, [r3, #268]	@ 0x10c
    __HAL_UNLOCK(&pFlash);
24003660:	7521      	strb	r1, [r4, #20]
}
24003662:	bd70      	pop	{r4, r5, r6, pc}
        pFlash.Sector = 0xFFFFFFFFU;
24003664:	f04f 32ff 	mov.w	r2, #4294967295
24003668:	60e2      	str	r2, [r4, #12]
        pFlash.ProcedureOnGoing = FLASH_PROC_NONE;
2400366a:	7023      	strb	r3, [r4, #0]
        HAL_FLASH_EndOfOperationCallback(pFlash.Sector);
2400366c:	68e0      	ldr	r0, [r4, #12]
2400366e:	f7ff ff7b 	bl	24003568 <HAL_FLASH_EndOfOperationCallback>
        __HAL_FLASH_CLEAR_FLAG_BANK1(FLASH_FLAG_EOP_BANK1);
24003672:	f44f 3380 	mov.w	r3, #65536	@ 0x10000
24003676:	616b      	str	r3, [r5, #20]
24003678:	e797      	b.n	240035aa <HAL_FLASH_IRQHandler+0x3e>
      procedure = pFlash.ProcedureOnGoing;
2400367a:	7823      	ldrb	r3, [r4, #0]
      if((procedure == FLASH_PROC_MASSERASE_BANK1) || (procedure == FLASH_PROC_ALLBANK_MASSERASE))
2400367c:	2b02      	cmp	r3, #2
      procedure = pFlash.ProcedureOnGoing;
2400367e:	b2dd      	uxtb	r5, r3
      if((procedure == FLASH_PROC_MASSERASE_BANK1) || (procedure == FLASH_PROC_ALLBANK_MASSERASE))
24003680:	d001      	beq.n	24003686 <HAL_FLASH_IRQHandler+0x11a>
24003682:	2d07      	cmp	r5, #7
24003684:	d106      	bne.n	24003694 <HAL_FLASH_IRQHandler+0x128>
        HAL_FLASH_EndOfOperationCallback(FLASH_BANK_1);
24003686:	2001      	movs	r0, #1
24003688:	f7ff ff6e 	bl	24003568 <HAL_FLASH_EndOfOperationCallback>
      if((procedure != FLASH_PROC_SECTERASE_BANK2) && \
2400368c:	3d04      	subs	r5, #4
2400368e:	2d02      	cmp	r5, #2
24003690:	d98b      	bls.n	240035aa <HAL_FLASH_IRQHandler+0x3e>
24003692:	e004      	b.n	2400369e <HAL_FLASH_IRQHandler+0x132>
      else if(procedure == FLASH_PROC_PROGRAM_BANK1)
24003694:	2d03      	cmp	r5, #3
24003696:	d1f9      	bne.n	2400368c <HAL_FLASH_IRQHandler+0x120>
        HAL_FLASH_EndOfOperationCallback(pFlash.Address);
24003698:	6920      	ldr	r0, [r4, #16]
2400369a:	f7ff ff65 	bl	24003568 <HAL_FLASH_EndOfOperationCallback>
        pFlash.ProcedureOnGoing = FLASH_PROC_NONE;
2400369e:	2300      	movs	r3, #0
        __HAL_FLASH_CLEAR_FLAG_BANK1(FLASH_FLAG_EOP_BANK1);
240036a0:	f44f 3280 	mov.w	r2, #65536	@ 0x10000
        pFlash.ProcedureOnGoing = FLASH_PROC_NONE;
240036a4:	7023      	strb	r3, [r4, #0]
        __HAL_FLASH_CLEAR_FLAG_BANK1(FLASH_FLAG_EOP_BANK1);
240036a6:	4b1c      	ldr	r3, [pc, #112]	@ (24003718 <HAL_FLASH_IRQHandler+0x1ac>)
240036a8:	615a      	str	r2, [r3, #20]
240036aa:	e77e      	b.n	240035aa <HAL_FLASH_IRQHandler+0x3e>
        pFlash.Sector = 0xFFFFFFFFU;
240036ac:	f04f 32ff 	mov.w	r2, #4294967295
240036b0:	60e2      	str	r2, [r4, #12]
        pFlash.ProcedureOnGoing = FLASH_PROC_NONE;
240036b2:	7023      	strb	r3, [r4, #0]
        HAL_FLASH_EndOfOperationCallback(pFlash.Sector);
240036b4:	68e0      	ldr	r0, [r4, #12]
240036b6:	f7ff ff57 	bl	24003568 <HAL_FLASH_EndOfOperationCallback>
        __HAL_FLASH_CLEAR_FLAG_BANK2(FLASH_FLAG_EOP_BANK2);
240036ba:	f44f 3380 	mov.w	r3, #65536	@ 0x10000
240036be:	f8c5 3114 	str.w	r3, [r5, #276]	@ 0x114
240036c2:	e790      	b.n	240035e6 <HAL_FLASH_IRQHandler+0x7a>
      procedure = pFlash.ProcedureOnGoing;
240036c4:	7822      	ldrb	r2, [r4, #0]
240036c6:	b2d3      	uxtb	r3, r2
      if((procedure == FLASH_PROC_MASSERASE_BANK2) || (procedure == FLASH_PROC_ALLBANK_MASSERASE))
240036c8:	f002 02fd 	and.w	r2, r2, #253	@ 0xfd
240036cc:	2a05      	cmp	r2, #5
240036ce:	d10a      	bne.n	240036e6 <HAL_FLASH_IRQHandler+0x17a>
        HAL_FLASH_EndOfOperationCallback(FLASH_BANK_2);
240036d0:	2002      	movs	r0, #2
        HAL_FLASH_EndOfOperationCallback(pFlash.Address);
240036d2:	f7ff ff49 	bl	24003568 <HAL_FLASH_EndOfOperationCallback>
        pFlash.ProcedureOnGoing = FLASH_PROC_NONE;
240036d6:	2300      	movs	r3, #0
        __HAL_FLASH_CLEAR_FLAG_BANK2(FLASH_FLAG_EOP_BANK2);
240036d8:	f44f 3280 	mov.w	r2, #65536	@ 0x10000
        pFlash.ProcedureOnGoing = FLASH_PROC_NONE;
240036dc:	7023      	strb	r3, [r4, #0]
        __HAL_FLASH_CLEAR_FLAG_BANK2(FLASH_FLAG_EOP_BANK2);
240036de:	4b0e      	ldr	r3, [pc, #56]	@ (24003718 <HAL_FLASH_IRQHandler+0x1ac>)
240036e0:	f8c3 2114 	str.w	r2, [r3, #276]	@ 0x114
240036e4:	e77f      	b.n	240035e6 <HAL_FLASH_IRQHandler+0x7a>
      else if(procedure == FLASH_PROC_PROGRAM_BANK2)
240036e6:	2b06      	cmp	r3, #6
240036e8:	d101      	bne.n	240036ee <HAL_FLASH_IRQHandler+0x182>
        HAL_FLASH_EndOfOperationCallback(pFlash.Address);
240036ea:	6920      	ldr	r0, [r4, #16]
240036ec:	e7f1      	b.n	240036d2 <HAL_FLASH_IRQHandler+0x166>
      if((procedure != FLASH_PROC_SECTERASE_BANK1) && \
240036ee:	3b01      	subs	r3, #1
240036f0:	2b02      	cmp	r3, #2
240036f2:	f67f af78 	bls.w	240035e6 <HAL_FLASH_IRQHandler+0x7a>
240036f6:	e7ee      	b.n	240036d6 <HAL_FLASH_IRQHandler+0x16a>
    else if((procedure == FLASH_PROC_MASSERASE_BANK1) || (procedure == FLASH_PROC_ALLBANK_MASSERASE))
240036f8:	2b02      	cmp	r3, #2
240036fa:	d003      	beq.n	24003704 <HAL_FLASH_IRQHandler+0x198>
240036fc:	2b07      	cmp	r3, #7
240036fe:	d001      	beq.n	24003704 <HAL_FLASH_IRQHandler+0x198>
      temp = pFlash.Address;
24003700:	6920      	ldr	r0, [r4, #16]
24003702:	e781      	b.n	24003608 <HAL_FLASH_IRQHandler+0x9c>
      temp = FLASH_BANK_1;
24003704:	2001      	movs	r0, #1
24003706:	e77f      	b.n	24003608 <HAL_FLASH_IRQHandler+0x9c>
    else if((procedure == FLASH_PROC_MASSERASE_BANK2) || (procedure == FLASH_PROC_ALLBANK_MASSERASE))
24003708:	f003 03fd 	and.w	r3, r3, #253	@ 0xfd
2400370c:	2b05      	cmp	r3, #5
2400370e:	d001      	beq.n	24003714 <HAL_FLASH_IRQHandler+0x1a8>
      temp = pFlash.Address;
24003710:	6920      	ldr	r0, [r4, #16]
24003712:	e792      	b.n	2400363a <HAL_FLASH_IRQHandler+0xce>
      temp = FLASH_BANK_2;
24003714:	2002      	movs	r0, #2
24003716:	e790      	b.n	2400363a <HAL_FLASH_IRQHandler+0xce>
24003718:	52002000 	.word	0x52002000
2400371c:	2400057c 	.word	0x2400057c

24003720 <HAL_FLASH_Unlock>:
  * @brief  Unlock the FLASH control registers access
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASH_Unlock(void)
{
  if(READ_BIT(FLASH->CR1, FLASH_CR_LOCK) != 0U)
24003720:	4b10      	ldr	r3, [pc, #64]	@ (24003764 <HAL_FLASH_Unlock+0x44>)
24003722:	68da      	ldr	r2, [r3, #12]
24003724:	07d2      	lsls	r2, r2, #31
24003726:	d406      	bmi.n	24003736 <HAL_FLASH_Unlock+0x16>
    {
      return HAL_ERROR;
    }
  }

  if(READ_BIT(FLASH->CR2, FLASH_CR_LOCK) != 0U)
24003728:	4b0e      	ldr	r3, [pc, #56]	@ (24003764 <HAL_FLASH_Unlock+0x44>)
2400372a:	f8d3 010c 	ldr.w	r0, [r3, #268]	@ 0x10c
2400372e:	f010 0001 	ands.w	r0, r0, #1
24003732:	d10a      	bne.n	2400374a <HAL_FLASH_Unlock+0x2a>
24003734:	4770      	bx	lr
    WRITE_REG(FLASH->KEYR1, FLASH_KEY1);
24003736:	4a0c      	ldr	r2, [pc, #48]	@ (24003768 <HAL_FLASH_Unlock+0x48>)
24003738:	605a      	str	r2, [r3, #4]
    WRITE_REG(FLASH->KEYR1, FLASH_KEY2);
2400373a:	f102 3288 	add.w	r2, r2, #2290649224	@ 0x88888888
2400373e:	605a      	str	r2, [r3, #4]
    if (READ_BIT(FLASH->CR1, FLASH_CR_LOCK) != 0U)
24003740:	68db      	ldr	r3, [r3, #12]
24003742:	07db      	lsls	r3, r3, #31
24003744:	d5f0      	bpl.n	24003728 <HAL_FLASH_Unlock+0x8>
      return HAL_ERROR;
24003746:	2001      	movs	r0, #1
      return HAL_ERROR;
    }
  }

  return HAL_OK;
}
24003748:	4770      	bx	lr
    WRITE_REG(FLASH->KEYR2, FLASH_KEY1);
2400374a:	4a07      	ldr	r2, [pc, #28]	@ (24003768 <HAL_FLASH_Unlock+0x48>)
2400374c:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104
    WRITE_REG(FLASH->KEYR2, FLASH_KEY2);
24003750:	f102 3288 	add.w	r2, r2, #2290649224	@ 0x88888888
24003754:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104
    if (READ_BIT(FLASH->CR2, FLASH_CR_LOCK) != 0U)
24003758:	f8d3 010c 	ldr.w	r0, [r3, #268]	@ 0x10c
2400375c:	f000 0001 	and.w	r0, r0, #1
24003760:	4770      	bx	lr
24003762:	bf00      	nop
24003764:	52002000 	.word	0x52002000
24003768:	45670123 	.word	0x45670123

2400376c <HAL_FLASH_Lock>:
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASH_Lock(void)
{
  /* Set the LOCK Bit to lock the FLASH Bank1 Control Register access */
  SET_BIT(FLASH->CR1, FLASH_CR_LOCK);
2400376c:	4b0a      	ldr	r3, [pc, #40]	@ (24003798 <HAL_FLASH_Lock+0x2c>)
2400376e:	68da      	ldr	r2, [r3, #12]
24003770:	f042 0201 	orr.w	r2, r2, #1
24003774:	60da      	str	r2, [r3, #12]

  /* Verify Flash Bank1 is locked */
  if (READ_BIT(FLASH->CR1, FLASH_CR_LOCK) == 0U)
24003776:	68da      	ldr	r2, [r3, #12]
24003778:	07d2      	lsls	r2, r2, #31
2400377a:	d50b      	bpl.n	24003794 <HAL_FLASH_Lock+0x28>
  {
    return HAL_ERROR;
  }

  /* Set the LOCK Bit to lock the FLASH Bank2 Control Register access */
  SET_BIT(FLASH->CR2, FLASH_CR_LOCK);
2400377c:	f8d3 210c 	ldr.w	r2, [r3, #268]	@ 0x10c
24003780:	f042 0201 	orr.w	r2, r2, #1
24003784:	f8c3 210c 	str.w	r2, [r3, #268]	@ 0x10c

  /* Verify Flash Bank2 is locked */
  if (READ_BIT(FLASH->CR2, FLASH_CR_LOCK) == 0U)
24003788:	f8d3 010c 	ldr.w	r0, [r3, #268]	@ 0x10c
2400378c:	43c0      	mvns	r0, r0
2400378e:	f000 0001 	and.w	r0, r0, #1
24003792:	4770      	bx	lr
    return HAL_ERROR;
24003794:	2001      	movs	r0, #1
  {
    return HAL_ERROR;
  }

  return HAL_OK;
}
24003796:	4770      	bx	lr
24003798:	52002000 	.word	0x52002000

2400379c <HAL_FLASH_OB_Unlock>:
  * @brief  Unlock the FLASH Option Control Registers access.
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASH_OB_Unlock(void)
{
  if(READ_BIT(FLASH->OPTCR, FLASH_OPTCR_OPTLOCK) != 0U)
2400379c:	4b06      	ldr	r3, [pc, #24]	@ (240037b8 <HAL_FLASH_OB_Unlock+0x1c>)
2400379e:	6998      	ldr	r0, [r3, #24]
240037a0:	f010 0001 	ands.w	r0, r0, #1
240037a4:	d007      	beq.n	240037b6 <HAL_FLASH_OB_Unlock+0x1a>
  {
    /* Authorizes the Option Byte registers programming */
    WRITE_REG(FLASH->OPTKEYR, FLASH_OPT_KEY1);
240037a6:	4a05      	ldr	r2, [pc, #20]	@ (240037bc <HAL_FLASH_OB_Unlock+0x20>)
240037a8:	609a      	str	r2, [r3, #8]
    WRITE_REG(FLASH->OPTKEYR, FLASH_OPT_KEY2);
240037aa:	f102 3244 	add.w	r2, r2, #1145324612	@ 0x44444444
240037ae:	609a      	str	r2, [r3, #8]

    /* Verify that the Option Bytes are unlocked */
    if (READ_BIT(FLASH->OPTCR, FLASH_OPTCR_OPTLOCK) != 0U)
240037b0:	6998      	ldr	r0, [r3, #24]
240037b2:	f000 0001 	and.w	r0, r0, #1
      return HAL_ERROR;
    }
  }

  return HAL_OK;
}
240037b6:	4770      	bx	lr
240037b8:	52002000 	.word	0x52002000
240037bc:	08192a3b 	.word	0x08192a3b

240037c0 <HAL_FLASH_OB_Lock>:
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASH_OB_Lock(void)
{
  /* Set the OPTLOCK Bit to lock the FLASH Option Byte Registers access */
  SET_BIT(FLASH->OPTCR, FLASH_OPTCR_OPTLOCK);
240037c0:	4b04      	ldr	r3, [pc, #16]	@ (240037d4 <HAL_FLASH_OB_Lock+0x14>)
240037c2:	699a      	ldr	r2, [r3, #24]
240037c4:	f042 0201 	orr.w	r2, r2, #1
240037c8:	619a      	str	r2, [r3, #24]

  /* Verify that the Option Bytes are locked */
  if (READ_BIT(FLASH->OPTCR, FLASH_OPTCR_OPTLOCK) == 0U)
240037ca:	6998      	ldr	r0, [r3, #24]
  {
    return HAL_ERROR;
  }

  return HAL_OK;
}
240037cc:	43c0      	mvns	r0, r0
240037ce:	f000 0001 	and.w	r0, r0, #1
240037d2:	4770      	bx	lr
240037d4:	52002000 	.word	0x52002000

240037d8 <HAL_FLASH_GetError>:
  *            @arg HAL_FLASH_ERROR_CRCRD_BANK2: CRC Read Error on Bank 2
*/

uint32_t HAL_FLASH_GetError(void)
{
   return pFlash.ErrorCode;
240037d8:	4b01      	ldr	r3, [pc, #4]	@ (240037e0 <HAL_FLASH_GetError+0x8>)
240037da:	6998      	ldr	r0, [r3, #24]
}
240037dc:	4770      	bx	lr
240037de:	bf00      	nop
240037e0:	2400057c 	.word	0x2400057c

240037e4 <FLASH_WaitForLastOperation>:
  * @param  Timeout maximum flash operation timeout
  * @param  Bank flash FLASH_BANK_1 or FLASH_BANK_2
  * @retval HAL_StatusTypeDef HAL Status
  */
HAL_StatusTypeDef FLASH_WaitForLastOperation(uint32_t Timeout, uint32_t Bank)
{
240037e4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
240037e8:	460c      	mov	r4, r1
240037ea:	4605      	mov	r5, r0
  /* Wait for the FLASH operation to complete by polling on QW flag to be reset.
     Even if the FLASH operation fails, the QW flag will be reset and an error
     flag will be set */

  uint32_t bsyflag, errorflag;
  uint32_t tickstart = HAL_GetTick();
240037ec:	f00e fb0c 	bl	24011e08 <HAL_GetTick>
  {
    bsyflag = FLASH_FLAG_QW_BANK1;
  }
  else
  {
    bsyflag = FLASH_FLAG_QW_BANK2;
240037f0:	4f27      	ldr	r7, [pc, #156]	@ (24003890 <FLASH_WaitForLastOperation+0xac>)
240037f2:	2c01      	cmp	r4, #1
  uint32_t tickstart = HAL_GetTick();
240037f4:	4606      	mov	r6, r0
  if(Bank == FLASH_BANK_1)
240037f6:	f8df 809c 	ldr.w	r8, [pc, #156]	@ 24003894 <FLASH_WaitForLastOperation+0xb0>
    bsyflag = FLASH_FLAG_QW_BANK2;
240037fa:	bf08      	it	eq
240037fc:	2704      	moveq	r7, #4
  }

  while(__HAL_FLASH_GET_FLAG(bsyflag))
240037fe:	2f04      	cmp	r7, #4
24003800:	d123      	bne.n	2400384a <FLASH_WaitForLastOperation+0x66>
24003802:	f8d8 3010 	ldr.w	r3, [r8, #16]
24003806:	f3c3 0380 	ubfx	r3, r3, #2, #1
2400380a:	b99b      	cbnz	r3, 24003834 <FLASH_WaitForLastOperation+0x50>
      }
    }
  }

  /* Get Error Flags */
  if (Bank == FLASH_BANK_1)
2400380c:	2c01      	cmp	r4, #1
2400380e:	4b21      	ldr	r3, [pc, #132]	@ (24003894 <FLASH_WaitForLastOperation+0xb0>)
24003810:	4a21      	ldr	r2, [pc, #132]	@ (24003898 <FLASH_WaitForLastOperation+0xb4>)
24003812:	d11d      	bne.n	24003850 <FLASH_WaitForLastOperation+0x6c>
  {
    errorflag = FLASH->SR1 & FLASH_FLAG_ALL_ERRORS_BANK1;
24003814:	691b      	ldr	r3, [r3, #16]
24003816:	4013      	ands	r3, r2
  {
    errorflag = (FLASH->SR2 & FLASH_FLAG_ALL_ERRORS_BANK2) | 0x80000000U;
  }

  /* In case of error reported in Flash SR1 or SR2 registers (ECCC not managed as an error) */
  if((errorflag & 0x7DFFFFFFU) != 0U)
24003818:	f023 4202 	bic.w	r2, r3, #2181038080	@ 0x82000000
2400381c:	b31a      	cbz	r2, 24003866 <FLASH_WaitForLastOperation+0x82>
  {
    /*Save the error code*/
    pFlash.ErrorCode |= errorflag;
2400381e:	491f      	ldr	r1, [pc, #124]	@ (2400389c <FLASH_WaitForLastOperation+0xb8>)

    /* Clear error programming flags */
    __HAL_FLASH_CLEAR_FLAG(errorflag);
24003820:	2b00      	cmp	r3, #0
    pFlash.ErrorCode |= errorflag;
24003822:	698a      	ldr	r2, [r1, #24]
24003824:	ea42 0203 	orr.w	r2, r2, r3
24003828:	618a      	str	r2, [r1, #24]
    __HAL_FLASH_CLEAR_FLAG(errorflag);
2400382a:	4a1a      	ldr	r2, [pc, #104]	@ (24003894 <FLASH_WaitForLastOperation+0xb0>)
2400382c:	db16      	blt.n	2400385c <FLASH_WaitForLastOperation+0x78>
2400382e:	6153      	str	r3, [r2, #20]

    return HAL_ERROR;
24003830:	2001      	movs	r0, #1
24003832:	e022      	b.n	2400387a <FLASH_WaitForLastOperation+0x96>
    if(Timeout != HAL_MAX_DELAY)
24003834:	1c68      	adds	r0, r5, #1
24003836:	d0e2      	beq.n	240037fe <FLASH_WaitForLastOperation+0x1a>
      if(((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
24003838:	f00e fae6 	bl	24011e08 <HAL_GetTick>
2400383c:	1b80      	subs	r0, r0, r6
2400383e:	42a8      	cmp	r0, r5
24003840:	d801      	bhi.n	24003846 <FLASH_WaitForLastOperation+0x62>
24003842:	2d00      	cmp	r5, #0
24003844:	d1db      	bne.n	240037fe <FLASH_WaitForLastOperation+0x1a>
        return HAL_TIMEOUT;
24003846:	2003      	movs	r0, #3
24003848:	e017      	b.n	2400387a <FLASH_WaitForLastOperation+0x96>
  while(__HAL_FLASH_GET_FLAG(bsyflag))
2400384a:	f8d8 3110 	ldr.w	r3, [r8, #272]	@ 0x110
2400384e:	e7da      	b.n	24003806 <FLASH_WaitForLastOperation+0x22>
    errorflag = (FLASH->SR2 & FLASH_FLAG_ALL_ERRORS_BANK2) | 0x80000000U;
24003850:	f8d3 3110 	ldr.w	r3, [r3, #272]	@ 0x110
24003854:	4013      	ands	r3, r2
24003856:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
2400385a:	e7dd      	b.n	24003818 <FLASH_WaitForLastOperation+0x34>
    __HAL_FLASH_CLEAR_FLAG(errorflag);
2400385c:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
24003860:	f8c2 3114 	str.w	r3, [r2, #276]	@ 0x114
24003864:	e7e4      	b.n	24003830 <FLASH_WaitForLastOperation+0x4c>
  }

  /* Check FLASH End of Operation flag  */
  if(Bank == FLASH_BANK_1)
24003866:	2c01      	cmp	r4, #1
24003868:	4b0a      	ldr	r3, [pc, #40]	@ (24003894 <FLASH_WaitForLastOperation+0xb0>)
2400386a:	d108      	bne.n	2400387e <FLASH_WaitForLastOperation+0x9a>
  {
    if (__HAL_FLASH_GET_FLAG_BANK1(FLASH_FLAG_EOP_BANK1))
2400386c:	691a      	ldr	r2, [r3, #16]
2400386e:	03d1      	lsls	r1, r2, #15
24003870:	d502      	bpl.n	24003878 <FLASH_WaitForLastOperation+0x94>
    {
      /* Clear FLASH End of Operation pending bit */
      __HAL_FLASH_CLEAR_FLAG_BANK1(FLASH_FLAG_EOP_BANK1);
24003872:	f44f 3280 	mov.w	r2, #65536	@ 0x10000
24003876:	615a      	str	r2, [r3, #20]
      /* Clear FLASH End of Operation pending bit */
      __HAL_FLASH_CLEAR_FLAG_BANK2(FLASH_FLAG_EOP_BANK2);
    }
  }

  return HAL_OK;
24003878:	2000      	movs	r0, #0
}
2400387a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if (__HAL_FLASH_GET_FLAG_BANK2(FLASH_FLAG_EOP_BANK2))
2400387e:	f8d3 2110 	ldr.w	r2, [r3, #272]	@ 0x110
24003882:	03d2      	lsls	r2, r2, #15
24003884:	d5f8      	bpl.n	24003878 <FLASH_WaitForLastOperation+0x94>
      __HAL_FLASH_CLEAR_FLAG_BANK2(FLASH_FLAG_EOP_BANK2);
24003886:	f44f 3280 	mov.w	r2, #65536	@ 0x10000
2400388a:	f8c3 2114 	str.w	r2, [r3, #276]	@ 0x114
2400388e:	e7f3      	b.n	24003878 <FLASH_WaitForLastOperation+0x94>
24003890:	80000004 	.word	0x80000004
24003894:	52002000 	.word	0x52002000
24003898:	17ee0000 	.word	0x17ee0000
2400389c:	2400057c 	.word	0x2400057c

240038a0 <HAL_FLASH_Program>:
{
240038a0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  __HAL_LOCK(&pFlash);
240038a2:	4c26      	ldr	r4, [pc, #152]	@ (2400393c <HAL_FLASH_Program+0x9c>)
{
240038a4:	460e      	mov	r6, r1
240038a6:	4617      	mov	r7, r2
  __HAL_LOCK(&pFlash);
240038a8:	7d23      	ldrb	r3, [r4, #20]
240038aa:	2b01      	cmp	r3, #1
240038ac:	d043      	beq.n	24003936 <HAL_FLASH_Program+0x96>
240038ae:	2301      	movs	r3, #1
  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, bank);
240038b0:	f24c 3050 	movw	r0, #50000	@ 0xc350
  __HAL_LOCK(&pFlash);
240038b4:	7523      	strb	r3, [r4, #20]
  if(IS_FLASH_PROGRAM_ADDRESS_BANK1(FlashAddress))
240038b6:	f101 4378 	add.w	r3, r1, #4160749568	@ 0xf8000000
    bank = FLASH_BANK_1;
240038ba:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
240038be:	f04f 0300 	mov.w	r3, #0
    bank = FLASH_BANK_1;
240038c2:	bf2c      	ite	cs
240038c4:	2502      	movcs	r5, #2
240038c6:	2501      	movcc	r5, #1
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
240038c8:	61a3      	str	r3, [r4, #24]
  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, bank);
240038ca:	4629      	mov	r1, r5
240038cc:	f7ff ff8a 	bl	240037e4 <FLASH_WaitForLastOperation>
  if(status == HAL_OK)
240038d0:	bb00      	cbnz	r0, 24003914 <HAL_FLASH_Program+0x74>
    if(bank == FLASH_BANK_1)
240038d2:	2d01      	cmp	r5, #1
240038d4:	4b1a      	ldr	r3, [pc, #104]	@ (24003940 <HAL_FLASH_Program+0xa0>)
240038d6:	d120      	bne.n	2400391a <HAL_FLASH_Program+0x7a>
        SET_BIT(FLASH->CR1, FLASH_CR_PG);
240038d8:	68da      	ldr	r2, [r3, #12]
240038da:	f042 0202 	orr.w	r2, r2, #2
240038de:	60da      	str	r2, [r3, #12]
240038e0:	f3bf 8f6f 	isb	sy
  __ASM volatile ("dsb 0xF":::"memory");
240038e4:	f3bf 8f4f 	dsb	sy
}
240038e8:	2300      	movs	r3, #0
        *dest_addr = *src_addr;
240038ea:	58fa      	ldr	r2, [r7, r3]
240038ec:	50f2      	str	r2, [r6, r3]
     } while (row_index != 0U);
240038ee:	3304      	adds	r3, #4
240038f0:	2b20      	cmp	r3, #32
240038f2:	d1fa      	bne.n	240038ea <HAL_FLASH_Program+0x4a>
  __ASM volatile ("isb 0xF":::"memory");
240038f4:	f3bf 8f6f 	isb	sy
  __ASM volatile ("dsb 0xF":::"memory");
240038f8:	f3bf 8f4f 	dsb	sy
    status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, bank);
240038fc:	f24c 3050 	movw	r0, #50000	@ 0xc350
24003900:	4629      	mov	r1, r5
24003902:	f7ff ff6f 	bl	240037e4 <FLASH_WaitForLastOperation>
      if(bank == FLASH_BANK_1)
24003906:	2d01      	cmp	r5, #1
24003908:	4b0d      	ldr	r3, [pc, #52]	@ (24003940 <HAL_FLASH_Program+0xa0>)
2400390a:	d10d      	bne.n	24003928 <HAL_FLASH_Program+0x88>
        CLEAR_BIT(FLASH->CR1, FLASH_CR_PG);
2400390c:	68da      	ldr	r2, [r3, #12]
2400390e:	f022 0202 	bic.w	r2, r2, #2
24003912:	60da      	str	r2, [r3, #12]
  __HAL_UNLOCK(&pFlash);
24003914:	2300      	movs	r3, #0
24003916:	7523      	strb	r3, [r4, #20]
}
24003918:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      SET_BIT(FLASH->CR2, FLASH_CR_PG);
2400391a:	f8d3 210c 	ldr.w	r2, [r3, #268]	@ 0x10c
2400391e:	f042 0202 	orr.w	r2, r2, #2
24003922:	f8c3 210c 	str.w	r2, [r3, #268]	@ 0x10c
24003926:	e7db      	b.n	240038e0 <HAL_FLASH_Program+0x40>
        CLEAR_BIT(FLASH->CR2, FLASH_CR_PG);
24003928:	f8d3 210c 	ldr.w	r2, [r3, #268]	@ 0x10c
2400392c:	f022 0202 	bic.w	r2, r2, #2
24003930:	f8c3 210c 	str.w	r2, [r3, #268]	@ 0x10c
24003934:	e7ee      	b.n	24003914 <HAL_FLASH_Program+0x74>
  __HAL_LOCK(&pFlash);
24003936:	2002      	movs	r0, #2
24003938:	e7ee      	b.n	24003918 <HAL_FLASH_Program+0x78>
2400393a:	bf00      	nop
2400393c:	2400057c 	.word	0x2400057c
24003940:	52002000 	.word	0x52002000

24003944 <HAL_FLASH_Program_IT>:
{
24003944:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  __HAL_LOCK(&pFlash);
24003948:	4c25      	ldr	r4, [pc, #148]	@ (240039e0 <HAL_FLASH_Program_IT+0x9c>)
{
2400394a:	460d      	mov	r5, r1
2400394c:	4616      	mov	r6, r2
  __HAL_LOCK(&pFlash);
2400394e:	7d23      	ldrb	r3, [r4, #20]
24003950:	2b01      	cmp	r3, #1
24003952:	d042      	beq.n	240039da <HAL_FLASH_Program_IT+0x96>
24003954:	2301      	movs	r3, #1
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
24003956:	f04f 0800 	mov.w	r8, #0
  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, bank);
2400395a:	f24c 3050 	movw	r0, #50000	@ 0xc350
  __HAL_LOCK(&pFlash);
2400395e:	7523      	strb	r3, [r4, #20]
  if(IS_FLASH_PROGRAM_ADDRESS_BANK1(FlashAddress))
24003960:	f101 4378 	add.w	r3, r1, #4160749568	@ 0xf8000000
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
24003964:	f8c4 8018 	str.w	r8, [r4, #24]
    bank = FLASH_BANK_2;
24003968:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
2400396c:	bf34      	ite	cc
2400396e:	2701      	movcc	r7, #1
24003970:	2702      	movcs	r7, #2
  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, bank);
24003972:	4639      	mov	r1, r7
24003974:	f7ff ff36 	bl	240037e4 <FLASH_WaitForLastOperation>
  if (status != HAL_OK)
24003978:	b118      	cbz	r0, 24003982 <HAL_FLASH_Program_IT+0x3e>
    __HAL_UNLOCK(&pFlash);
2400397a:	f884 8014 	strb.w	r8, [r4, #20]
}
2400397e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if(bank == FLASH_BANK_1)
24003982:	2f01      	cmp	r7, #1
24003984:	4b17      	ldr	r3, [pc, #92]	@ (240039e4 <HAL_FLASH_Program_IT+0xa0>)
    pFlash.Address = FlashAddress;
24003986:	6125      	str	r5, [r4, #16]
    if(bank == FLASH_BANK_1)
24003988:	d118      	bne.n	240039bc <HAL_FLASH_Program_IT+0x78>
      pFlash.ProcedureOnGoing = FLASH_PROC_PROGRAM_BANK1;
2400398a:	2203      	movs	r2, #3
2400398c:	7022      	strb	r2, [r4, #0]
        SET_BIT(FLASH->CR1, FLASH_CR_PG);
2400398e:	68da      	ldr	r2, [r3, #12]
24003990:	f042 0202 	orr.w	r2, r2, #2
24003994:	60da      	str	r2, [r3, #12]
      __HAL_FLASH_ENABLE_IT_BANK1(FLASH_IT_EOP_BANK1     | FLASH_IT_WRPERR_BANK1 | FLASH_IT_PGSERR_BANK1 | \
24003996:	68da      	ldr	r2, [r3, #12]
24003998:	f442 02de 	orr.w	r2, r2, #7274496	@ 0x6f0000
2400399c:	60da      	str	r2, [r3, #12]
  __ASM volatile ("isb 0xF":::"memory");
2400399e:	f3bf 8f6f 	isb	sy
  __ASM volatile ("dsb 0xF":::"memory");
240039a2:	f3bf 8f4f 	dsb	sy
}
240039a6:	2300      	movs	r3, #0
        *dest_addr = *src_addr;
240039a8:	58f2      	ldr	r2, [r6, r3]
240039aa:	50ea      	str	r2, [r5, r3]
      } while (row_index != 0U);
240039ac:	3304      	adds	r3, #4
240039ae:	2b20      	cmp	r3, #32
240039b0:	d1fa      	bne.n	240039a8 <HAL_FLASH_Program_IT+0x64>
  __ASM volatile ("isb 0xF":::"memory");
240039b2:	f3bf 8f6f 	isb	sy
  __ASM volatile ("dsb 0xF":::"memory");
240039b6:	f3bf 8f4f 	dsb	sy
}
240039ba:	e7e0      	b.n	2400397e <HAL_FLASH_Program_IT+0x3a>
      pFlash.ProcedureOnGoing = FLASH_PROC_PROGRAM_BANK2;
240039bc:	2206      	movs	r2, #6
240039be:	7022      	strb	r2, [r4, #0]
      SET_BIT(FLASH->CR2, FLASH_CR_PG);
240039c0:	f8d3 210c 	ldr.w	r2, [r3, #268]	@ 0x10c
240039c4:	f042 0202 	orr.w	r2, r2, #2
240039c8:	f8c3 210c 	str.w	r2, [r3, #268]	@ 0x10c
      __HAL_FLASH_ENABLE_IT_BANK2(FLASH_IT_EOP_BANK2     | FLASH_IT_WRPERR_BANK2 | FLASH_IT_PGSERR_BANK2 | \
240039cc:	f8d3 210c 	ldr.w	r2, [r3, #268]	@ 0x10c
240039d0:	f442 02de 	orr.w	r2, r2, #7274496	@ 0x6f0000
240039d4:	f8c3 210c 	str.w	r2, [r3, #268]	@ 0x10c
240039d8:	e7e1      	b.n	2400399e <HAL_FLASH_Program_IT+0x5a>
  __HAL_LOCK(&pFlash);
240039da:	2002      	movs	r0, #2
240039dc:	e7cf      	b.n	2400397e <HAL_FLASH_Program_IT+0x3a>
240039de:	bf00      	nop
240039e0:	2400057c 	.word	0x2400057c
240039e4:	52002000 	.word	0x52002000

240039e8 <FLASH_OB_WaitForLastOperation>:
  * @brief  Wait for a FLASH Option Bytes change operation to complete.
  * @param  Timeout maximum flash operation timeout
  * @retval HAL_StatusTypeDef HAL Status
  */
HAL_StatusTypeDef FLASH_OB_WaitForLastOperation(uint32_t Timeout)
{
240039e8:	b570      	push	{r4, r5, r6, lr}
240039ea:	4604      	mov	r4, r0
  /* Get timeout */
  uint32_t tickstart = HAL_GetTick();

  /* Wait for the FLASH Option Bytes change operation to complete by polling on OPT_BUSY flag to be reset */
  while(READ_BIT(FLASH->OPTSR_CUR, FLASH_OPTSR_OPT_BUSY) != 0U)
240039ec:	4d10      	ldr	r5, [pc, #64]	@ (24003a30 <FLASH_OB_WaitForLastOperation+0x48>)
  uint32_t tickstart = HAL_GetTick();
240039ee:	f00e fa0b 	bl	24011e08 <HAL_GetTick>
240039f2:	4606      	mov	r6, r0
  while(READ_BIT(FLASH->OPTSR_CUR, FLASH_OPTSR_OPT_BUSY) != 0U)
240039f4:	69eb      	ldr	r3, [r5, #28]
240039f6:	07db      	lsls	r3, r3, #31
240039f8:	d40e      	bmi.n	24003a18 <FLASH_OB_WaitForLastOperation+0x30>
      }
    }
  }

  /* Check option byte change error */
  if(READ_BIT(FLASH->OPTSR_CUR, FLASH_OPTSR_OPTCHANGEERR) != 0U)
240039fa:	69e8      	ldr	r0, [r5, #28]
240039fc:	f010 4080 	ands.w	r0, r0, #1073741824	@ 0x40000000
24003a00:	d009      	beq.n	24003a16 <FLASH_OB_WaitForLastOperation+0x2e>
  {
    /* Save the error code */
    pFlash.ErrorCode |= HAL_FLASH_ERROR_OB_CHANGE;
24003a02:	4a0c      	ldr	r2, [pc, #48]	@ (24003a34 <FLASH_OB_WaitForLastOperation+0x4c>)

    /* Clear the OB error flag */
    FLASH->OPTCCR |= FLASH_OPTCCR_CLR_OPTCHANGEERR;
24003a04:	2001      	movs	r0, #1
    pFlash.ErrorCode |= HAL_FLASH_ERROR_OB_CHANGE;
24003a06:	6993      	ldr	r3, [r2, #24]
24003a08:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
24003a0c:	6193      	str	r3, [r2, #24]
    FLASH->OPTCCR |= FLASH_OPTCCR_CLR_OPTCHANGEERR;
24003a0e:	6a6b      	ldr	r3, [r5, #36]	@ 0x24
24003a10:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
24003a14:	626b      	str	r3, [r5, #36]	@ 0x24
    return HAL_ERROR;
  }

  /* If there is no error flag set */
  return HAL_OK;
}
24003a16:	bd70      	pop	{r4, r5, r6, pc}
    if(Timeout != HAL_MAX_DELAY)
24003a18:	1c62      	adds	r2, r4, #1
24003a1a:	d0eb      	beq.n	240039f4 <FLASH_OB_WaitForLastOperation+0xc>
      if(((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
24003a1c:	f00e f9f4 	bl	24011e08 <HAL_GetTick>
24003a20:	1b80      	subs	r0, r0, r6
24003a22:	42a0      	cmp	r0, r4
24003a24:	d801      	bhi.n	24003a2a <FLASH_OB_WaitForLastOperation+0x42>
24003a26:	2c00      	cmp	r4, #0
24003a28:	d1e4      	bne.n	240039f4 <FLASH_OB_WaitForLastOperation+0xc>
        return HAL_TIMEOUT;
24003a2a:	2003      	movs	r0, #3
24003a2c:	e7f3      	b.n	24003a16 <FLASH_OB_WaitForLastOperation+0x2e>
24003a2e:	bf00      	nop
24003a30:	52002000 	.word	0x52002000
24003a34:	2400057c 	.word	0x2400057c

24003a38 <FLASH_CRC_WaitForLastOperation>:
  * @param  Timeout maximum flash operation timeout
  * @param  Bank flash FLASH_BANK_1 or FLASH_BANK_2
  * @retval HAL_StatusTypeDef HAL Status
  */
HAL_StatusTypeDef FLASH_CRC_WaitForLastOperation(uint32_t Timeout, uint32_t Bank)
{
24003a38:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
24003a3c:	460d      	mov	r5, r1
24003a3e:	4604      	mov	r4, r0
  uint32_t bsyflag;
  uint32_t tickstart = HAL_GetTick();
24003a40:	f00e f9e2 	bl	24011e08 <HAL_GetTick>
  {
    bsyflag = FLASH_FLAG_CRC_BUSY_BANK1;
  }
  else
  {
    bsyflag = FLASH_FLAG_CRC_BUSY_BANK2;
24003a44:	4f1d      	ldr	r7, [pc, #116]	@ (24003abc <FLASH_CRC_WaitForLastOperation+0x84>)
24003a46:	2d01      	cmp	r5, #1
  uint32_t tickstart = HAL_GetTick();
24003a48:	4606      	mov	r6, r0
  if(Bank == FLASH_BANK_1)
24003a4a:	f8df 8074 	ldr.w	r8, [pc, #116]	@ 24003ac0 <FLASH_CRC_WaitForLastOperation+0x88>
    bsyflag = FLASH_FLAG_CRC_BUSY_BANK2;
24003a4e:	bf08      	it	eq
24003a50:	2708      	moveq	r7, #8
  }

  /* Wait for the FLASH CRC computation to complete by polling on CRC_BUSY flag to be reset */
  while(__HAL_FLASH_GET_FLAG(bsyflag))
24003a52:	2f08      	cmp	r7, #8
24003a54:	d120      	bne.n	24003a98 <FLASH_CRC_WaitForLastOperation+0x60>
24003a56:	f8d8 3010 	ldr.w	r3, [r8, #16]
24003a5a:	071b      	lsls	r3, r3, #28
24003a5c:	d411      	bmi.n	24003a82 <FLASH_CRC_WaitForLastOperation+0x4a>
      }
    }
  }

  /* Check FLASH CRC read error flag  */
  if(Bank == FLASH_BANK_1)
24003a5e:	2d01      	cmp	r5, #1
24003a60:	4b17      	ldr	r3, [pc, #92]	@ (24003ac0 <FLASH_CRC_WaitForLastOperation+0x88>)
24003a62:	d11c      	bne.n	24003a9e <FLASH_CRC_WaitForLastOperation+0x66>
  {
    if (__HAL_FLASH_GET_FLAG_BANK1(FLASH_FLAG_CRCRDERR_BANK1))
24003a64:	6918      	ldr	r0, [r3, #16]
24003a66:	f010 5080 	ands.w	r0, r0, #268435456	@ 0x10000000
24003a6a:	d008      	beq.n	24003a7e <FLASH_CRC_WaitForLastOperation+0x46>
    {
      /* Save the error code */
      pFlash.ErrorCode |= HAL_FLASH_ERROR_CRCRD_BANK1;
24003a6c:	4915      	ldr	r1, [pc, #84]	@ (24003ac4 <FLASH_CRC_WaitForLastOperation+0x8c>)
24003a6e:	698a      	ldr	r2, [r1, #24]
24003a70:	f042 5280 	orr.w	r2, r2, #268435456	@ 0x10000000
24003a74:	618a      	str	r2, [r1, #24]

      /* Clear FLASH CRC read error pending bit */
      __HAL_FLASH_CLEAR_FLAG_BANK1(FLASH_FLAG_CRCRDERR_BANK1);
24003a76:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
24003a7a:	615a      	str	r2, [r3, #20]

      return HAL_ERROR;
24003a7c:	2001      	movs	r0, #1
    }
  }

  /* If there is no error flag set */
  return HAL_OK;
}
24003a7e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if(Timeout != HAL_MAX_DELAY)
24003a82:	1c62      	adds	r2, r4, #1
24003a84:	d0e5      	beq.n	24003a52 <FLASH_CRC_WaitForLastOperation+0x1a>
      if(((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
24003a86:	f00e f9bf 	bl	24011e08 <HAL_GetTick>
24003a8a:	1b80      	subs	r0, r0, r6
24003a8c:	42a0      	cmp	r0, r4
24003a8e:	d801      	bhi.n	24003a94 <FLASH_CRC_WaitForLastOperation+0x5c>
24003a90:	2c00      	cmp	r4, #0
24003a92:	d1de      	bne.n	24003a52 <FLASH_CRC_WaitForLastOperation+0x1a>
        return HAL_TIMEOUT;
24003a94:	2003      	movs	r0, #3
24003a96:	e7f2      	b.n	24003a7e <FLASH_CRC_WaitForLastOperation+0x46>
  while(__HAL_FLASH_GET_FLAG(bsyflag))
24003a98:	f8d8 3110 	ldr.w	r3, [r8, #272]	@ 0x110
24003a9c:	e7dd      	b.n	24003a5a <FLASH_CRC_WaitForLastOperation+0x22>
    if (__HAL_FLASH_GET_FLAG_BANK2(FLASH_FLAG_CRCRDERR_BANK2))
24003a9e:	f8d3 0110 	ldr.w	r0, [r3, #272]	@ 0x110
24003aa2:	f010 5080 	ands.w	r0, r0, #268435456	@ 0x10000000
24003aa6:	d0ea      	beq.n	24003a7e <FLASH_CRC_WaitForLastOperation+0x46>
      pFlash.ErrorCode |= HAL_FLASH_ERROR_CRCRD_BANK2;
24003aa8:	4906      	ldr	r1, [pc, #24]	@ (24003ac4 <FLASH_CRC_WaitForLastOperation+0x8c>)
24003aaa:	698a      	ldr	r2, [r1, #24]
24003aac:	f042 4210 	orr.w	r2, r2, #2415919104	@ 0x90000000
24003ab0:	618a      	str	r2, [r1, #24]
      __HAL_FLASH_CLEAR_FLAG_BANK2(FLASH_FLAG_CRCRDERR_BANK2);
24003ab2:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
24003ab6:	f8c3 2114 	str.w	r2, [r3, #276]	@ 0x114
      return HAL_ERROR;
24003aba:	e7df      	b.n	24003a7c <FLASH_CRC_WaitForLastOperation+0x44>
24003abc:	80000008 	.word	0x80000008
24003ac0:	52002000 	.word	0x52002000
24003ac4:	2400057c 	.word	0x2400057c

24003ac8 <HAL_FLASH_OB_Launch>:
{
24003ac8:	b508      	push	{r3, lr}
  if (FLASH_CRC_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_1) != HAL_OK)
24003aca:	2101      	movs	r1, #1
24003acc:	f24c 3050 	movw	r0, #50000	@ 0xc350
24003ad0:	f7ff ffb2 	bl	24003a38 <FLASH_CRC_WaitForLastOperation>
24003ad4:	b980      	cbnz	r0, 24003af8 <HAL_FLASH_OB_Launch+0x30>
  else if (FLASH_CRC_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_2) != HAL_OK)
24003ad6:	2102      	movs	r1, #2
24003ad8:	f24c 3050 	movw	r0, #50000	@ 0xc350
24003adc:	f7ff ffac 	bl	24003a38 <FLASH_CRC_WaitForLastOperation>
24003ae0:	b950      	cbnz	r0, 24003af8 <HAL_FLASH_OB_Launch+0x30>
    SET_BIT(FLASH->OPTCR, FLASH_OPTCR_OPTSTART);
24003ae2:	4a06      	ldr	r2, [pc, #24]	@ (24003afc <HAL_FLASH_OB_Launch+0x34>)
    status = FLASH_OB_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
24003ae4:	f24c 3050 	movw	r0, #50000	@ 0xc350
    SET_BIT(FLASH->OPTCR, FLASH_OPTCR_OPTSTART);
24003ae8:	6993      	ldr	r3, [r2, #24]
24003aea:	f043 0302 	orr.w	r3, r3, #2
24003aee:	6193      	str	r3, [r2, #24]
}
24003af0:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    status = FLASH_OB_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
24003af4:	f7ff bf78 	b.w	240039e8 <FLASH_OB_WaitForLastOperation>
}
24003af8:	2001      	movs	r0, #1
24003afa:	bd08      	pop	{r3, pc}
24003afc:	52002000 	.word	0x52002000

24003b00 <FLASH_MassErase>:
  UNUSED(VoltageRange);
#endif /* FLASH_CR_PSIZE */
  assert_param(IS_FLASH_BANK(Banks));

  /* Flash Mass Erase */
  if((Banks & FLASH_BANK_BOTH) == FLASH_BANK_BOTH)
24003b00:	f001 0303 	and.w	r3, r1, #3
24003b04:	2b03      	cmp	r3, #3
24003b06:	d117      	bne.n	24003b38 <FLASH_MassErase+0x38>
  {
#if defined (FLASH_CR_PSIZE)
    /* Reset Program/erase VoltageRange for Bank1 and Bank2 */
    FLASH->CR1 &= (~FLASH_CR_PSIZE);
24003b08:	4b1d      	ldr	r3, [pc, #116]	@ (24003b80 <FLASH_MassErase+0x80>)
24003b0a:	68da      	ldr	r2, [r3, #12]
24003b0c:	f022 0230 	bic.w	r2, r2, #48	@ 0x30
24003b10:	60da      	str	r2, [r3, #12]
    FLASH->CR2 &= (~FLASH_CR_PSIZE);
24003b12:	f8d3 210c 	ldr.w	r2, [r3, #268]	@ 0x10c
24003b16:	f022 0230 	bic.w	r2, r2, #48	@ 0x30
24003b1a:	f8c3 210c 	str.w	r2, [r3, #268]	@ 0x10c

    /* Set voltage range */
    FLASH->CR1 |= VoltageRange;
24003b1e:	68da      	ldr	r2, [r3, #12]
24003b20:	4302      	orrs	r2, r0
24003b22:	60da      	str	r2, [r3, #12]
    FLASH->CR2 |= VoltageRange;
24003b24:	f8d3 210c 	ldr.w	r2, [r3, #268]	@ 0x10c
24003b28:	4302      	orrs	r2, r0
24003b2a:	f8c3 210c 	str.w	r2, [r3, #268]	@ 0x10c
#endif /* FLASH_CR_PSIZE */

    /* Set Mass Erase Bit */
    FLASH->OPTCR |= FLASH_OPTCR_MER;
24003b2e:	699a      	ldr	r2, [r3, #24]
24003b30:	f042 0210 	orr.w	r2, r2, #16
24003b34:	619a      	str	r2, [r3, #24]
24003b36:	4770      	bx	lr
  }
  else
  {
    /* Proceed to erase Flash Bank  */
    if((Banks & FLASH_BANK_1) == FLASH_BANK_1)
24003b38:	07ca      	lsls	r2, r1, #31
24003b3a:	d50b      	bpl.n	24003b54 <FLASH_MassErase+0x54>
    {
#if defined (FLASH_CR_PSIZE)
      /* Set Program/erase VoltageRange for Bank1 */
      FLASH->CR1 &= (~FLASH_CR_PSIZE);
24003b3c:	4b10      	ldr	r3, [pc, #64]	@ (24003b80 <FLASH_MassErase+0x80>)
24003b3e:	68da      	ldr	r2, [r3, #12]
24003b40:	f022 0230 	bic.w	r2, r2, #48	@ 0x30
24003b44:	60da      	str	r2, [r3, #12]
      FLASH->CR1 |=  VoltageRange;
24003b46:	68da      	ldr	r2, [r3, #12]
24003b48:	4302      	orrs	r2, r0
24003b4a:	60da      	str	r2, [r3, #12]
#endif /* FLASH_CR_PSIZE */

      /* Erase Bank1 */
      FLASH->CR1 |= (FLASH_CR_BER | FLASH_CR_START);
24003b4c:	68da      	ldr	r2, [r3, #12]
24003b4e:	f042 0288 	orr.w	r2, r2, #136	@ 0x88
24003b52:	60da      	str	r2, [r3, #12]
    }
    if((Banks & FLASH_BANK_2) == FLASH_BANK_2)
24003b54:	078b      	lsls	r3, r1, #30
24003b56:	d511      	bpl.n	24003b7c <FLASH_MassErase+0x7c>
    {
#if defined (FLASH_CR_PSIZE)
      /* Set Program/erase VoltageRange for Bank2 */
      FLASH->CR2 &= (~FLASH_CR_PSIZE);
24003b58:	4b09      	ldr	r3, [pc, #36]	@ (24003b80 <FLASH_MassErase+0x80>)
24003b5a:	f8d3 210c 	ldr.w	r2, [r3, #268]	@ 0x10c
24003b5e:	f022 0230 	bic.w	r2, r2, #48	@ 0x30
24003b62:	f8c3 210c 	str.w	r2, [r3, #268]	@ 0x10c
      FLASH->CR2 |= VoltageRange;
24003b66:	f8d3 210c 	ldr.w	r2, [r3, #268]	@ 0x10c
24003b6a:	4310      	orrs	r0, r2
24003b6c:	f8c3 010c 	str.w	r0, [r3, #268]	@ 0x10c
#endif /* FLASH_CR_PSIZE */

      /* Erase Bank2 */
      FLASH->CR2 |= (FLASH_CR_BER | FLASH_CR_START);
24003b70:	f8d3 210c 	ldr.w	r2, [r3, #268]	@ 0x10c
24003b74:	f042 0288 	orr.w	r2, r2, #136	@ 0x88
24003b78:	f8c3 210c 	str.w	r2, [r3, #268]	@ 0x10c
    }
  }
}
24003b7c:	4770      	bx	lr
24003b7e:	bf00      	nop
24003b80:	52002000 	.word	0x52002000

24003b84 <HAL_FLASHEx_OBProgram>:
{
24003b84:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  __HAL_LOCK(&pFlash);
24003b86:	4e8c      	ldr	r6, [pc, #560]	@ (24003db8 <HAL_FLASHEx_OBProgram+0x234>)
{
24003b88:	4604      	mov	r4, r0
  __HAL_LOCK(&pFlash);
24003b8a:	7d33      	ldrb	r3, [r6, #20]
24003b8c:	2b01      	cmp	r3, #1
24003b8e:	f000 8111 	beq.w	24003db4 <HAL_FLASHEx_OBProgram+0x230>
24003b92:	2101      	movs	r1, #1
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
24003b94:	2300      	movs	r3, #0
  if(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_1) != HAL_OK)
24003b96:	f24c 3050 	movw	r0, #50000	@ 0xc350
  __HAL_LOCK(&pFlash);
24003b9a:	7531      	strb	r1, [r6, #20]
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
24003b9c:	61b3      	str	r3, [r6, #24]
  if(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_1) != HAL_OK)
24003b9e:	f7ff fe21 	bl	240037e4 <FLASH_WaitForLastOperation>
24003ba2:	b118      	cbz	r0, 24003bac <HAL_FLASHEx_OBProgram+0x28>
    status = HAL_ERROR;
24003ba4:	2001      	movs	r0, #1
  __HAL_UNLOCK(&pFlash);
24003ba6:	2300      	movs	r3, #0
24003ba8:	7533      	strb	r3, [r6, #20]
}
24003baa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  else if(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_2) != HAL_OK)
24003bac:	2102      	movs	r1, #2
24003bae:	f24c 3050 	movw	r0, #50000	@ 0xc350
24003bb2:	f7ff fe17 	bl	240037e4 <FLASH_WaitForLastOperation>
24003bb6:	2800      	cmp	r0, #0
24003bb8:	d1f4      	bne.n	24003ba4 <HAL_FLASHEx_OBProgram+0x20>
    if((pOBInit->OptionType & OPTIONBYTE_WRP) == OPTIONBYTE_WRP)
24003bba:	6827      	ldr	r7, [r4, #0]
24003bbc:	07f9      	lsls	r1, r7, #31
24003bbe:	d51a      	bpl.n	24003bf6 <HAL_FLASHEx_OBProgram+0x72>
      if(pOBInit->WRPState == OB_WRPSTATE_ENABLE)
24003bc0:	6865      	ldr	r5, [r4, #4]
        FLASH_OB_EnableWRP(pOBInit->WRPSector,pOBInit->Banks);
24003bc2:	69e2      	ldr	r2, [r4, #28]
      if(pOBInit->WRPState == OB_WRPSTATE_ENABLE)
24003bc4:	2d01      	cmp	r5, #1
        FLASH_OB_EnableWRP(pOBInit->WRPSector,pOBInit->Banks);
24003bc6:	68a3      	ldr	r3, [r4, #8]
{
  /* Check the parameters */
  assert_param(IS_OB_WRP_SECTOR(WRPSector));
  assert_param(IS_FLASH_BANK(Banks));

  if((Banks & FLASH_BANK_1) == FLASH_BANK_1)
24003bc8:	f002 0101 	and.w	r1, r2, #1
24003bcc:	f002 0202 	and.w	r2, r2, #2
      if(pOBInit->WRPState == OB_WRPSTATE_ENABLE)
24003bd0:	f040 80dd 	bne.w	24003d8e <HAL_FLASHEx_OBProgram+0x20a>
  if((Banks & FLASH_BANK_1) == FLASH_BANK_1)
24003bd4:	b131      	cbz	r1, 24003be4 <HAL_FLASHEx_OBProgram+0x60>
  {
    /* Enable Write Protection for bank 1 */
    FLASH->WPSN_PRG1 &= (~(WRPSector & FLASH_WPSN_WRPSN));
24003bd6:	4d79      	ldr	r5, [pc, #484]	@ (24003dbc <HAL_FLASHEx_OBProgram+0x238>)
24003bd8:	fa5f fc83 	uxtb.w	ip, r3
24003bdc:	6be9      	ldr	r1, [r5, #60]	@ 0x3c
24003bde:	ea21 010c 	bic.w	r1, r1, ip
24003be2:	63e9      	str	r1, [r5, #60]	@ 0x3c
  }

  if((Banks & FLASH_BANK_2) == FLASH_BANK_2)
24003be4:	b13a      	cbz	r2, 24003bf6 <HAL_FLASHEx_OBProgram+0x72>
  {
    /* Enable Write Protection for bank 2 */
    FLASH->WPSN_PRG2 &= (~(WRPSector & FLASH_WPSN_WRPSN));
24003be6:	4975      	ldr	r1, [pc, #468]	@ (24003dbc <HAL_FLASHEx_OBProgram+0x238>)
24003be8:	b2db      	uxtb	r3, r3
24003bea:	f8d1 213c 	ldr.w	r2, [r1, #316]	@ 0x13c
24003bee:	ea22 0303 	bic.w	r3, r2, r3
24003bf2:	f8c1 313c 	str.w	r3, [r1, #316]	@ 0x13c
    if((pOBInit->OptionType & OPTIONBYTE_RDP) != 0U)
24003bf6:	07ba      	lsls	r2, r7, #30
24003bf8:	d506      	bpl.n	24003c08 <HAL_FLASHEx_OBProgram+0x84>
{
  /* Check the parameters */
  assert_param(IS_OB_RDP_LEVEL(RDPLevel));

  /* Configure the RDP level in the option bytes register */
  MODIFY_REG(FLASH->OPTSR_PRG, FLASH_OPTSR_RDP, RDPLevel);
24003bfa:	4a70      	ldr	r2, [pc, #448]	@ (24003dbc <HAL_FLASHEx_OBProgram+0x238>)
24003bfc:	68e1      	ldr	r1, [r4, #12]
24003bfe:	6a13      	ldr	r3, [r2, #32]
24003c00:	f423 437f 	bic.w	r3, r3, #65280	@ 0xff00
24003c04:	430b      	orrs	r3, r1
24003c06:	6213      	str	r3, [r2, #32]
    if((pOBInit->OptionType & OPTIONBYTE_USER) != 0U)
24003c08:	077b      	lsls	r3, r7, #29
24003c0a:	d554      	bpl.n	24003cb6 <HAL_FLASHEx_OBProgram+0x132>
      FLASH_OB_UserConfig(pOBInit->USERType, pOBInit->USERConfig);
24003c0c:	e9d4 5105 	ldrd	r5, r1, [r4, #20]
  uint32_t optr_reg_mask = 0;

  /* Check the parameters */
  assert_param(IS_OB_USER_TYPE(UserType));

  if((UserType & OB_USER_IWDG1_SW) != 0U)
24003c10:	f015 0301 	ands.w	r3, r5, #1
  {
    /* IWDG_HW option byte should be modified */
    assert_param(IS_OB_IWDG1_SOURCE(UserConfig & FLASH_OPTSR_IWDG1_SW));

    /* Set value and mask for IWDG_HW option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTSR_IWDG1_SW);
24003c14:	bf1a      	itte	ne
24003c16:	f001 0310 	andne.w	r3, r1, #16
    optr_reg_mask |= FLASH_OPTSR_IWDG1_SW;
24003c1a:	2210      	movne	r2, #16
  uint32_t optr_reg_mask = 0;
24003c1c:	461a      	moveq	r2, r3
    /* Set value and mask for IWDG2_SW option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTSR_IWDG2_SW);
    optr_reg_mask |= FLASH_OPTSR_IWDG2_SW;
  }
#endif /*DUAL_CORE*/
  if((UserType & OB_USER_NRST_STOP_D1) != 0U)
24003c1e:	f015 0f02 	tst.w	r5, #2
  {
    /* NRST_STOP option byte should be modified */
    assert_param(IS_OB_STOP_D1_RESET(UserConfig & FLASH_OPTSR_NRST_STOP_D1));

    /* Set value and mask for NRST_STOP option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTSR_NRST_STOP_D1);
24003c22:	bf1e      	ittt	ne
24003c24:	f001 0c40 	andne.w	ip, r1, #64	@ 0x40
    optr_reg_mask |= FLASH_OPTSR_NRST_STOP_D1;
24003c28:	f042 0240 	orrne.w	r2, r2, #64	@ 0x40
    optr_reg_val |= (UserConfig & FLASH_OPTSR_NRST_STOP_D1);
24003c2c:	ea43 030c 	orrne.w	r3, r3, ip
  }

  if((UserType & OB_USER_NRST_STDBY_D1) != 0U)
24003c30:	f015 0f04 	tst.w	r5, #4
  {
    /* NRST_STDBY option byte should be modified */
    assert_param(IS_OB_STDBY_D1_RESET(UserConfig & FLASH_OPTSR_NRST_STBY_D1));

    /* Set value and mask for NRST_STDBY option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTSR_NRST_STBY_D1);
24003c34:	bf1e      	ittt	ne
24003c36:	f001 0c80 	andne.w	ip, r1, #128	@ 0x80
    optr_reg_mask |= FLASH_OPTSR_NRST_STBY_D1;
24003c3a:	f042 0280 	orrne.w	r2, r2, #128	@ 0x80
    optr_reg_val |= (UserConfig & FLASH_OPTSR_NRST_STBY_D1);
24003c3e:	ea43 030c 	orrne.w	r3, r3, ip
  }

  if((UserType & OB_USER_IWDG_STOP) != 0U)
24003c42:	f015 0f08 	tst.w	r5, #8
  {
    /* IWDG_STOP option byte should be modified */
    assert_param(IS_OB_USER_IWDG_STOP(UserConfig & FLASH_OPTSR_FZ_IWDG_STOP));

    /* Set value and mask for IWDG_STOP option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTSR_FZ_IWDG_STOP);
24003c46:	bf1e      	ittt	ne
24003c48:	f401 3c00 	andne.w	ip, r1, #131072	@ 0x20000
    optr_reg_mask |= FLASH_OPTSR_FZ_IWDG_STOP;
24003c4c:	f442 3200 	orrne.w	r2, r2, #131072	@ 0x20000
    optr_reg_val |= (UserConfig & FLASH_OPTSR_FZ_IWDG_STOP);
24003c50:	ea43 030c 	orrne.w	r3, r3, ip
  }

  if((UserType & OB_USER_IWDG_STDBY) != 0U)
24003c54:	f015 0f10 	tst.w	r5, #16
  {
    /* IWDG_STDBY option byte should be modified */
    assert_param(IS_OB_USER_IWDG_STDBY(UserConfig & FLASH_OPTSR_FZ_IWDG_SDBY));

    /* Set value and mask for IWDG_STDBY option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTSR_FZ_IWDG_SDBY);
24003c58:	bf1e      	ittt	ne
24003c5a:	f401 2c80 	andne.w	ip, r1, #262144	@ 0x40000
    optr_reg_mask |= FLASH_OPTSR_FZ_IWDG_SDBY;
24003c5e:	f442 2280 	orrne.w	r2, r2, #262144	@ 0x40000
    optr_reg_val |= (UserConfig & FLASH_OPTSR_FZ_IWDG_SDBY);
24003c62:	ea43 030c 	orrne.w	r3, r3, ip
  }

  if((UserType & OB_USER_ST_RAM_SIZE) != 0U)
24003c66:	f015 0f20 	tst.w	r5, #32
  {
    /* ST_RAM_SIZE option byte should be modified */
    assert_param(IS_OB_USER_ST_RAM_SIZE(UserConfig & FLASH_OPTSR_ST_RAM_SIZE));

    /* Set value and mask for ST_RAM_SIZE option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTSR_ST_RAM_SIZE);
24003c6a:	bf1e      	ittt	ne
24003c6c:	f401 1cc0 	andne.w	ip, r1, #1572864	@ 0x180000
    optr_reg_mask |= FLASH_OPTSR_ST_RAM_SIZE;
24003c70:	f442 12c0 	orrne.w	r2, r2, #1572864	@ 0x180000
    optr_reg_val |= (UserConfig & FLASH_OPTSR_ST_RAM_SIZE);
24003c74:	ea43 030c 	orrne.w	r3, r3, ip
  }

  if((UserType & OB_USER_SECURITY) != 0U)
24003c78:	f015 0f40 	tst.w	r5, #64	@ 0x40
  {
    /* SECURITY option byte should be modified */
    assert_param(IS_OB_USER_SECURITY(UserConfig & FLASH_OPTSR_SECURITY));

    /* Set value and mask for SECURITY option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTSR_SECURITY);
24003c7c:	bf1e      	ittt	ne
24003c7e:	f401 1c00 	andne.w	ip, r1, #2097152	@ 0x200000
    optr_reg_mask |= FLASH_OPTSR_SECURITY;
24003c82:	f442 1200 	orrne.w	r2, r2, #2097152	@ 0x200000
    optr_reg_val |= (UserConfig & FLASH_OPTSR_SECURITY);
24003c86:	ea43 030c 	orrne.w	r3, r3, ip
    /* Set value and mask for NRST_STDBY option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTSR_NRST_STBY_D2);
    optr_reg_mask |= FLASH_OPTSR_NRST_STBY_D2;
  }
#endif /* DUAL_CORE */
  if((UserType & OB_USER_SWAP_BANK) != 0U)
24003c8a:	f415 7f80 	tst.w	r5, #256	@ 0x100
  {
    /* SWAP_BANK_OPT option byte should be modified */
    assert_param(IS_OB_USER_SWAP_BANK(UserConfig & FLASH_OPTSR_SWAP_BANK_OPT));

    /* Set value and mask for SWAP_BANK_OPT option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTSR_SWAP_BANK_OPT);
24003c8e:	bf1e      	ittt	ne
24003c90:	f001 4c00 	andne.w	ip, r1, #2147483648	@ 0x80000000
    optr_reg_mask |= FLASH_OPTSR_SWAP_BANK_OPT;
24003c94:	f042 4200 	orrne.w	r2, r2, #2147483648	@ 0x80000000
    optr_reg_val |= (UserConfig & FLASH_OPTSR_SWAP_BANK_OPT);
24003c98:	ea43 030c 	orrne.w	r3, r3, ip
  }

  if((UserType & OB_USER_IOHSLV) != 0U)
24003c9c:	062d      	lsls	r5, r5, #24
    optr_reg_mask |= FLASH_OPTSR_VDDMMC_HSLV;
  }
#endif /* FLASH_OPTSR_VDDMMC_HSLV */

  /* Configure the option bytes register */
  MODIFY_REG(FLASH->OPTSR_PRG, optr_reg_mask, optr_reg_val);
24003c9e:	4d47      	ldr	r5, [pc, #284]	@ (24003dbc <HAL_FLASHEx_OBProgram+0x238>)
    optr_reg_val |= (UserConfig & FLASH_OPTSR_IO_HSLV);
24003ca0:	bf42      	ittt	mi
24003ca2:	f001 5100 	andmi.w	r1, r1, #536870912	@ 0x20000000
    optr_reg_mask |= FLASH_OPTSR_IO_HSLV;
24003ca6:	f042 5200 	orrmi.w	r2, r2, #536870912	@ 0x20000000
    optr_reg_val |= (UserConfig & FLASH_OPTSR_IO_HSLV);
24003caa:	430b      	orrmi	r3, r1
  MODIFY_REG(FLASH->OPTSR_PRG, optr_reg_mask, optr_reg_val);
24003cac:	6a29      	ldr	r1, [r5, #32]
24003cae:	ea21 0202 	bic.w	r2, r1, r2
24003cb2:	4313      	orrs	r3, r2
24003cb4:	622b      	str	r3, [r5, #32]
    if((pOBInit->OptionType & OPTIONBYTE_PCROP) != 0U)
24003cb6:	073b      	lsls	r3, r7, #28
24003cb8:	d523      	bpl.n	24003d02 <HAL_FLASHEx_OBProgram+0x17e>
      FLASH_OB_PCROPConfig(pOBInit->PCROPConfig, pOBInit->PCROPStartAddr, pOBInit->PCROPEndAddr, pOBInit->Banks);
24003cba:	f8d4 e01c 	ldr.w	lr, [r4, #28]
24003cbe:	6aa1      	ldr	r1, [r4, #40]	@ 0x28
{
  /* Check the parameters */
  assert_param(IS_FLASH_BANK(Banks));
  assert_param(IS_OB_PCROP_RDP(PCROPConfig));

  if((Banks & FLASH_BANK_1) == FLASH_BANK_1)
24003cc0:	f01e 0f01 	tst.w	lr, #1
      FLASH_OB_PCROPConfig(pOBInit->PCROPConfig, pOBInit->PCROPStartAddr, pOBInit->PCROPEndAddr, pOBInit->Banks);
24003cc4:	e9d4 2508 	ldrd	r2, r5, [r4, #32]
  if((Banks & FLASH_BANK_1) == FLASH_BANK_1)
24003cc8:	d00c      	beq.n	24003ce4 <HAL_FLASHEx_OBProgram+0x160>
    assert_param(IS_FLASH_PROGRAM_ADDRESS_BANK1(PCROPStartAddr));
    assert_param(IS_FLASH_PROGRAM_ADDRESS_BANK1(PCROPEndAddr));

    /* Configure the Proprietary code readout protection */
    FLASH->PRAR_PRG1 = ((PCROPStartAddr - FLASH_BANK1_BASE) >> 8)                                 | \
                       (((PCROPEndAddr - FLASH_BANK1_BASE) >> 8) << FLASH_PRAR_PROT_AREA_END_Pos) | \
24003cca:	020b      	lsls	r3, r1, #8
    FLASH->PRAR_PRG1 = ((PCROPStartAddr - FLASH_BANK1_BASE) >> 8)                                 | \
24003ccc:	f105 4c78 	add.w	ip, r5, #4160749568	@ 0xf8000000
                       (((PCROPEndAddr - FLASH_BANK1_BASE) >> 8) << FLASH_PRAR_PROT_AREA_END_Pos) | \
24003cd0:	0c1b      	lsrs	r3, r3, #16
24003cd2:	ea42 2c1c 	orr.w	ip, r2, ip, lsr #8
24003cd6:	041b      	lsls	r3, r3, #16
24003cd8:	ea43 030c 	orr.w	r3, r3, ip
    FLASH->PRAR_PRG1 = ((PCROPStartAddr - FLASH_BANK1_BASE) >> 8)                                 | \
24003cdc:	f8df c0dc 	ldr.w	ip, [pc, #220]	@ 24003dbc <HAL_FLASHEx_OBProgram+0x238>
24003ce0:	f8cc 302c 	str.w	r3, [ip, #44]	@ 0x2c
                       PCROPConfig;
  }

  if((Banks & FLASH_BANK_2) == FLASH_BANK_2)
24003ce4:	f01e 0f02 	tst.w	lr, #2
24003ce8:	d00b      	beq.n	24003d02 <HAL_FLASHEx_OBProgram+0x17e>
    assert_param(IS_FLASH_PROGRAM_ADDRESS_BANK2(PCROPStartAddr));
    assert_param(IS_FLASH_PROGRAM_ADDRESS_BANK2(PCROPEndAddr));

    /* Configure the Proprietary code readout protection */
    FLASH->PRAR_PRG2 = ((PCROPStartAddr - FLASH_BANK2_BASE) >> 8)                                 | \
                       (((PCROPEndAddr - FLASH_BANK2_BASE) >> 8) << FLASH_PRAR_PROT_AREA_END_Pos) | \
24003cea:	f1a1 6101 	sub.w	r1, r1, #135266304	@ 0x8100000
    FLASH->PRAR_PRG2 = ((PCROPStartAddr - FLASH_BANK2_BASE) >> 8)                                 | \
24003cee:	f1a5 6501 	sub.w	r5, r5, #135266304	@ 0x8100000
24003cf2:	4b32      	ldr	r3, [pc, #200]	@ (24003dbc <HAL_FLASHEx_OBProgram+0x238>)
                       (((PCROPEndAddr - FLASH_BANK2_BASE) >> 8) << FLASH_PRAR_PROT_AREA_END_Pos) | \
24003cf4:	0a09      	lsrs	r1, r1, #8
24003cf6:	ea42 2215 	orr.w	r2, r2, r5, lsr #8
24003cfa:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
    FLASH->PRAR_PRG2 = ((PCROPStartAddr - FLASH_BANK2_BASE) >> 8)                                 | \
24003cfe:	f8c3 212c 	str.w	r2, [r3, #300]	@ 0x12c
    if((pOBInit->OptionType & OPTIONBYTE_BOR) == OPTIONBYTE_BOR)
24003d02:	06fd      	lsls	r5, r7, #27
24003d04:	d506      	bpl.n	24003d14 <HAL_FLASHEx_OBProgram+0x190>
static void FLASH_OB_BOR_LevelConfig(uint32_t Level)
{
  assert_param(IS_OB_BOR_LEVEL(Level));

  /* Configure BOR_LEV option byte */
  MODIFY_REG(FLASH->OPTSR_PRG, FLASH_OPTSR_BOR_LEV, Level);
24003d06:	4a2d      	ldr	r2, [pc, #180]	@ (24003dbc <HAL_FLASHEx_OBProgram+0x238>)
24003d08:	6921      	ldr	r1, [r4, #16]
24003d0a:	6a13      	ldr	r3, [r2, #32]
24003d0c:	f023 030c 	bic.w	r3, r3, #12
24003d10:	430b      	orrs	r3, r1
24003d12:	6213      	str	r3, [r2, #32]
    if((pOBInit->OptionType & OPTIONBYTE_BOOTADD) == OPTIONBYTE_BOOTADD)
24003d14:	0679      	lsls	r1, r7, #25
24003d16:	d513      	bpl.n	24003d40 <HAL_FLASHEx_OBProgram+0x1bc>
      FLASH_OB_BootAddConfig(pOBInit->BootConfig, pOBInit->BootAddr0, pOBInit->BootAddr1);
24003d18:	6ae1      	ldr	r1, [r4, #44]	@ 0x2c
24003d1a:	f8d4 c034 	ldr.w	ip, [r4, #52]	@ 0x34
static void FLASH_OB_BootAddConfig(uint32_t BootOption, uint32_t BootAddress0, uint32_t BootAddress1)
{
  /* Check the parameters */
  assert_param(IS_OB_BOOT_ADD_OPTION(BootOption));

  if((BootOption & OB_BOOT_ADD0) == OB_BOOT_ADD0)
24003d1e:	07ca      	lsls	r2, r1, #31
24003d20:	d506      	bpl.n	24003d30 <HAL_FLASHEx_OBProgram+0x1ac>

    /* Configure CM7 BOOT ADD0 */
#if defined(DUAL_CORE)
    MODIFY_REG(FLASH->BOOT7_PRG, FLASH_BOOT7_BCM7_ADD0, (BootAddress0 >> 16));
#else /* Single Core*/
    MODIFY_REG(FLASH->BOOT_PRG, FLASH_BOOT_ADD0, (BootAddress0 >> 16));
24003d22:	4d26      	ldr	r5, [pc, #152]	@ (24003dbc <HAL_FLASHEx_OBProgram+0x238>)
24003d24:	8e62      	ldrh	r2, [r4, #50]	@ 0x32
24003d26:	6c6b      	ldr	r3, [r5, #68]	@ 0x44
24003d28:	0c1b      	lsrs	r3, r3, #16
24003d2a:	041b      	lsls	r3, r3, #16
24003d2c:	4313      	orrs	r3, r2
24003d2e:	646b      	str	r3, [r5, #68]	@ 0x44
#endif /* DUAL_CORE */
  }

  if((BootOption & OB_BOOT_ADD1) == OB_BOOT_ADD1)
24003d30:	078b      	lsls	r3, r1, #30
24003d32:	d505      	bpl.n	24003d40 <HAL_FLASHEx_OBProgram+0x1bc>

    /* Configure CM7 BOOT ADD1 */
#if defined(DUAL_CORE)
    MODIFY_REG(FLASH->BOOT7_PRG, FLASH_BOOT7_BCM7_ADD1, BootAddress1);
#else /* Single Core*/
    MODIFY_REG(FLASH->BOOT_PRG, FLASH_BOOT_ADD1, BootAddress1);
24003d34:	4a21      	ldr	r2, [pc, #132]	@ (24003dbc <HAL_FLASHEx_OBProgram+0x238>)
24003d36:	6c53      	ldr	r3, [r2, #68]	@ 0x44
24003d38:	b29b      	uxth	r3, r3
24003d3a:	ea43 030c 	orr.w	r3, r3, ip
24003d3e:	6453      	str	r3, [r2, #68]	@ 0x44
    if((pOBInit->OptionType & OPTIONBYTE_SECURE_AREA) == OPTIONBYTE_SECURE_AREA)
24003d40:	06bd      	lsls	r5, r7, #26
24003d42:	f57f af30 	bpl.w	24003ba6 <HAL_FLASHEx_OBProgram+0x22>
      FLASH_OB_SecureAreaConfig(pOBInit->SecureAreaConfig, pOBInit->SecureAreaStartAddr, pOBInit->SecureAreaEndAddr,pOBInit->Banks);
24003d46:	69e5      	ldr	r5, [r4, #28]
24003d48:	6c22      	ldr	r2, [r4, #64]	@ 0x40
24003d4a:	e9d4 370e 	ldrd	r3, r7, [r4, #56]	@ 0x38
{
  /* Check the parameters */
  assert_param(IS_FLASH_BANK(Banks));
  assert_param(IS_OB_SECURE_RDP(SecureAreaConfig));

  if((Banks & FLASH_BANK_1) == FLASH_BANK_1)
24003d4e:	07ec      	lsls	r4, r5, #31
24003d50:	d50b      	bpl.n	24003d6a <HAL_FLASHEx_OBProgram+0x1e6>
    /* Check the parameters */
    assert_param(IS_FLASH_PROGRAM_ADDRESS_BANK1(SecureAreaStartAddr));
    assert_param(IS_FLASH_PROGRAM_ADDRESS_BANK1(SecureAreaEndAddr));

    /* Configure the secure area */
    FLASH->SCAR_PRG1 = ((SecureAreaStartAddr - FLASH_BANK1_BASE) >> 8)                                | \
24003d52:	f107 4478 	add.w	r4, r7, #4160749568	@ 0xf8000000
                       (((SecureAreaEndAddr - FLASH_BANK1_BASE) >> 8) << FLASH_SCAR_SEC_AREA_END_Pos) | \
                       (SecureAreaConfig & FLASH_SCAR_DMES);
24003d56:	f003 4100 	and.w	r1, r3, #2147483648	@ 0x80000000
                       (((SecureAreaEndAddr - FLASH_BANK1_BASE) >> 8) << FLASH_SCAR_SEC_AREA_END_Pos) | \
24003d5a:	ea41 2114 	orr.w	r1, r1, r4, lsr #8
24003d5e:	0214      	lsls	r4, r2, #8
24003d60:	0c24      	lsrs	r4, r4, #16
24003d62:	0424      	lsls	r4, r4, #16
24003d64:	4321      	orrs	r1, r4
    FLASH->SCAR_PRG1 = ((SecureAreaStartAddr - FLASH_BANK1_BASE) >> 8)                                | \
24003d66:	4c15      	ldr	r4, [pc, #84]	@ (24003dbc <HAL_FLASHEx_OBProgram+0x238>)
24003d68:	6361      	str	r1, [r4, #52]	@ 0x34
  }

  if((Banks & FLASH_BANK_2) == FLASH_BANK_2)
24003d6a:	07a9      	lsls	r1, r5, #30
24003d6c:	f57f af1b 	bpl.w	24003ba6 <HAL_FLASHEx_OBProgram+0x22>
    /* Check the parameters */
    assert_param(IS_FLASH_PROGRAM_ADDRESS_BANK2(SecureAreaStartAddr));
    assert_param(IS_FLASH_PROGRAM_ADDRESS_BANK2(SecureAreaEndAddr));

    /* Configure the secure area */
    FLASH->SCAR_PRG2 = ((SecureAreaStartAddr - FLASH_BANK2_BASE) >> 8)                                | \
24003d70:	f1a7 6101 	sub.w	r1, r7, #135266304	@ 0x8100000
                       (((SecureAreaEndAddr - FLASH_BANK2_BASE) >> 8) << FLASH_SCAR_SEC_AREA_END_Pos) | \
                       (SecureAreaConfig & FLASH_SCAR_DMES);
24003d74:	f003 4300 	and.w	r3, r3, #2147483648	@ 0x80000000
                       (((SecureAreaEndAddr - FLASH_BANK2_BASE) >> 8) << FLASH_SCAR_SEC_AREA_END_Pos) | \
24003d78:	f1a2 6201 	sub.w	r2, r2, #135266304	@ 0x8100000
24003d7c:	ea43 2311 	orr.w	r3, r3, r1, lsr #8
24003d80:	0a12      	lsrs	r2, r2, #8
24003d82:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
    FLASH->SCAR_PRG2 = ((SecureAreaStartAddr - FLASH_BANK2_BASE) >> 8)                                | \
24003d86:	4a0d      	ldr	r2, [pc, #52]	@ (24003dbc <HAL_FLASHEx_OBProgram+0x238>)
24003d88:	f8c2 3134 	str.w	r3, [r2, #308]	@ 0x134
24003d8c:	e70b      	b.n	24003ba6 <HAL_FLASHEx_OBProgram+0x22>
  if((Banks & FLASH_BANK_1) == FLASH_BANK_1)
24003d8e:	b131      	cbz	r1, 24003d9e <HAL_FLASHEx_OBProgram+0x21a>
    FLASH->WPSN_PRG1 |= (WRPSector & FLASH_WPSN_WRPSN);
24003d90:	4d0a      	ldr	r5, [pc, #40]	@ (24003dbc <HAL_FLASHEx_OBProgram+0x238>)
24003d92:	b2d9      	uxtb	r1, r3
24003d94:	f8d5 c03c 	ldr.w	ip, [r5, #60]	@ 0x3c
24003d98:	ea41 010c 	orr.w	r1, r1, ip
24003d9c:	63e9      	str	r1, [r5, #60]	@ 0x3c
  if((Banks & FLASH_BANK_2) == FLASH_BANK_2)
24003d9e:	2a00      	cmp	r2, #0
24003da0:	f43f af29 	beq.w	24003bf6 <HAL_FLASHEx_OBProgram+0x72>
    FLASH->WPSN_PRG2 |= (WRPSector & FLASH_WPSN_WRPSN);
24003da4:	4a05      	ldr	r2, [pc, #20]	@ (24003dbc <HAL_FLASHEx_OBProgram+0x238>)
24003da6:	b2db      	uxtb	r3, r3
24003da8:	f8d2 113c 	ldr.w	r1, [r2, #316]	@ 0x13c
24003dac:	430b      	orrs	r3, r1
24003dae:	f8c2 313c 	str.w	r3, [r2, #316]	@ 0x13c
24003db2:	e720      	b.n	24003bf6 <HAL_FLASHEx_OBProgram+0x72>
  __HAL_LOCK(&pFlash);
24003db4:	2002      	movs	r0, #2
24003db6:	e6f8      	b.n	24003baa <HAL_FLASHEx_OBProgram+0x26>
24003db8:	2400057c 	.word	0x2400057c
24003dbc:	52002000 	.word	0x52002000

24003dc0 <HAL_FLASHEx_OBGetConfig>:
  pOBInit->OptionType = (OPTIONBYTE_USER | OPTIONBYTE_RDP | OPTIONBYTE_BOR);
24003dc0:	2316      	movs	r3, #22
  uint32_t rdp_level = READ_BIT(FLASH->OPTSR_CUR, FLASH_OPTSR_RDP);
24003dc2:	4a31      	ldr	r2, [pc, #196]	@ (24003e88 <HAL_FLASHEx_OBGetConfig+0xc8>)
  pOBInit->OptionType = (OPTIONBYTE_USER | OPTIONBYTE_RDP | OPTIONBYTE_BOR);
24003dc4:	6003      	str	r3, [r0, #0]
  uint32_t rdp_level = READ_BIT(FLASH->OPTSR_CUR, FLASH_OPTSR_RDP);
24003dc6:	69d3      	ldr	r3, [r2, #28]
24003dc8:	f403 437f 	and.w	r3, r3, #65280	@ 0xff00
  if ((rdp_level != OB_RDP_LEVEL_0) && (rdp_level != OB_RDP_LEVEL_2))
24003dcc:	f5b3 4f2a 	cmp.w	r3, #43520	@ 0xaa00
{
24003dd0:	b530      	push	{r4, r5, lr}
  if ((rdp_level != OB_RDP_LEVEL_0) && (rdp_level != OB_RDP_LEVEL_2))
24003dd2:	d006      	beq.n	24003de2 <HAL_FLASHEx_OBGetConfig+0x22>
24003dd4:	f5b3 4f4c 	cmp.w	r3, #52224	@ 0xcc00
24003dd8:	bf0c      	ite	eq
24003dda:	f44f 434c 	moveq.w	r3, #52224	@ 0xcc00
24003dde:	f44f 43aa 	movne.w	r3, #21760	@ 0x5500
  pOBInit->RDPLevel = FLASH_OB_GetRDP();
24003de2:	60c3      	str	r3, [r0, #12]
  uint32_t userConfig = READ_REG(FLASH->OPTSR_CUR);
24003de4:	69d3      	ldr	r3, [r2, #28]
  if ((pOBInit->Banks == FLASH_BANK_1) || (pOBInit->Banks == FLASH_BANK_2))
24003de6:	69c4      	ldr	r4, [r0, #28]
  userConfig &= (~(FLASH_OPTSR_BOR_LEV | FLASH_OPTSR_RDP));
24003de8:	f423 437f 	bic.w	r3, r3, #65280	@ 0xff00
24003dec:	f023 030c 	bic.w	r3, r3, #12
  pOBInit->USERConfig = FLASH_OB_GetUser();
24003df0:	6183      	str	r3, [r0, #24]
  return (FLASH->OPTSR_CUR & FLASH_OPTSR_BOR_LEV);
24003df2:	69d3      	ldr	r3, [r2, #28]
24003df4:	f003 030c 	and.w	r3, r3, #12
  pOBInit->BORLevel = FLASH_OB_GetBOR();
24003df8:	6103      	str	r3, [r0, #16]
  if ((pOBInit->Banks == FLASH_BANK_1) || (pOBInit->Banks == FLASH_BANK_2))
24003dfa:	1e63      	subs	r3, r4, #1
24003dfc:	2b01      	cmp	r3, #1
24003dfe:	d82d      	bhi.n	24003e5c <HAL_FLASHEx_OBGetConfig+0x9c>
    pOBInit->OptionType |= (OPTIONBYTE_WRP | OPTIONBYTE_PCROP | OPTIONBYTE_SECURE_AREA);
24003e00:	233f      	movs	r3, #63	@ 0x3f
  if((Bank & FLASH_BANK_BOTH) == FLASH_BANK_1)
24003e02:	2c01      	cmp	r4, #1
    pOBInit->OptionType |= (OPTIONBYTE_WRP | OPTIONBYTE_PCROP | OPTIONBYTE_SECURE_AREA);
24003e04:	6003      	str	r3, [r0, #0]
  if((Bank & FLASH_BANK_BOTH) == FLASH_BANK_1)
24003e06:	d035      	beq.n	24003e74 <HAL_FLASHEx_OBGetConfig+0xb4>
    regvalue = FLASH->WPSN_CUR2;
24003e08:	f8d2 3138 	ldr.w	r3, [r2, #312]	@ 0x138
  (*WRPSector) = (~regvalue) & FLASH_WPSN_WRPSN;
24003e0c:	43db      	mvns	r3, r3
24003e0e:	b2db      	uxtb	r3, r3
24003e10:	6083      	str	r3, [r0, #8]
  if(*WRPSector == 0U)
24003e12:	3b00      	subs	r3, #0
24003e14:	bf18      	it	ne
24003e16:	2301      	movne	r3, #1
  if((Bank & FLASH_BANK_BOTH) == FLASH_BANK_1)
24003e18:	2c01      	cmp	r4, #1
24003e1a:	6043      	str	r3, [r0, #4]
24003e1c:	4b1a      	ldr	r3, [pc, #104]	@ (24003e88 <HAL_FLASHEx_OBGetConfig+0xc8>)
24003e1e:	d12b      	bne.n	24003e78 <HAL_FLASHEx_OBGetConfig+0xb8>
    regvalue = FLASH->PRAR_CUR1;
24003e20:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
    bankBase = FLASH_BANK1_BASE;
24003e22:	f04f 6100 	mov.w	r1, #134217728	@ 0x8000000
  (*PCROPConfig) =  (regvalue & FLASH_PRAR_DMEP);
24003e26:	f002 4300 	and.w	r3, r2, #2147483648	@ 0x80000000
{
  uint32_t regvalue = 0;
  uint32_t bankBase = 0;

  /* Check Bank parameter value */
  if((Bank & FLASH_BANK_BOTH) == FLASH_BANK_1)
24003e2a:	2c01      	cmp	r4, #1
  (*PCROPConfig) =  (regvalue & FLASH_PRAR_DMEP);
24003e2c:	6203      	str	r3, [r0, #32]
  (*PCROPStartAddr) = ((regvalue & FLASH_PRAR_PROT_AREA_START) << 8) + bankBase;
24003e2e:	4b17      	ldr	r3, [pc, #92]	@ (24003e8c <HAL_FLASHEx_OBGetConfig+0xcc>)
24003e30:	ea03 2502 	and.w	r5, r3, r2, lsl #8
  (*PCROPEndAddr) = ((*PCROPEndAddr) << 8) + bankBase;
24003e34:	ea03 2212 	and.w	r2, r3, r2, lsr #8
  (*PCROPStartAddr) = ((regvalue & FLASH_PRAR_PROT_AREA_START) << 8) + bankBase;
24003e38:	440d      	add	r5, r1
  (*PCROPEndAddr) = ((*PCROPEndAddr) << 8) + bankBase;
24003e3a:	440a      	add	r2, r1
  (*PCROPStartAddr) = ((regvalue & FLASH_PRAR_PROT_AREA_START) << 8) + bankBase;
24003e3c:	6245      	str	r5, [r0, #36]	@ 0x24
  (*PCROPEndAddr) = ((*PCROPEndAddr) << 8) + bankBase;
24003e3e:	6282      	str	r2, [r0, #40]	@ 0x28
  if((Bank & FLASH_BANK_BOTH) == FLASH_BANK_1)
24003e40:	4a11      	ldr	r2, [pc, #68]	@ (24003e88 <HAL_FLASHEx_OBGetConfig+0xc8>)
24003e42:	d11e      	bne.n	24003e82 <HAL_FLASHEx_OBGetConfig+0xc2>
  {
    regvalue = FLASH->SCAR_CUR1;
24003e44:	6b12      	ldr	r2, [r2, #48]	@ 0x30
    regvalue = FLASH->SCAR_CUR2;
    bankBase = FLASH_BANK2_BASE;
  }

  /* Get the secure area settings */
  (*SecureAreaConfig) = (regvalue & FLASH_SCAR_DMES);
24003e46:	f002 4400 	and.w	r4, r2, #2147483648	@ 0x80000000
24003e4a:	6384      	str	r4, [r0, #56]	@ 0x38
  (*SecureAreaStartAddr) = ((regvalue & FLASH_SCAR_SEC_AREA_START) << 8) + bankBase;
24003e4c:	ea03 2402 	and.w	r4, r3, r2, lsl #8
  (*SecureAreaEndAddr) = (regvalue & FLASH_SCAR_SEC_AREA_END) >> FLASH_SCAR_SEC_AREA_END_Pos;
  (*SecureAreaEndAddr) = ((*SecureAreaEndAddr) << 8) + bankBase;
24003e50:	ea03 2312 	and.w	r3, r3, r2, lsr #8
  (*SecureAreaStartAddr) = ((regvalue & FLASH_SCAR_SEC_AREA_START) << 8) + bankBase;
24003e54:	440c      	add	r4, r1
  (*SecureAreaEndAddr) = ((*SecureAreaEndAddr) << 8) + bankBase;
24003e56:	440b      	add	r3, r1
  (*SecureAreaStartAddr) = ((regvalue & FLASH_SCAR_SEC_AREA_START) << 8) + bankBase;
24003e58:	63c4      	str	r4, [r0, #60]	@ 0x3c
  (*SecureAreaEndAddr) = ((*SecureAreaEndAddr) << 8) + bankBase;
24003e5a:	6403      	str	r3, [r0, #64]	@ 0x40
  regvalue = FLASH->BOOT_CUR;
24003e5c:	4b0a      	ldr	r3, [pc, #40]	@ (24003e88 <HAL_FLASHEx_OBGetConfig+0xc8>)
24003e5e:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
  (*BootAddress0) = (regvalue & FLASH_BOOT_ADD0) << 16;
24003e60:	041a      	lsls	r2, r3, #16
  (*BootAddress1) = (regvalue & FLASH_BOOT_ADD1);
24003e62:	0c1b      	lsrs	r3, r3, #16
  (*BootAddress0) = (regvalue & FLASH_BOOT_ADD0) << 16;
24003e64:	6302      	str	r2, [r0, #48]	@ 0x30
  (*BootAddress1) = (regvalue & FLASH_BOOT_ADD1);
24003e66:	041b      	lsls	r3, r3, #16
24003e68:	6343      	str	r3, [r0, #52]	@ 0x34
  pOBInit->OptionType |= OPTIONBYTE_BOOTADD;
24003e6a:	6803      	ldr	r3, [r0, #0]
24003e6c:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
24003e70:	6003      	str	r3, [r0, #0]
}
24003e72:	bd30      	pop	{r4, r5, pc}
    regvalue = FLASH->WPSN_CUR1;
24003e74:	6b93      	ldr	r3, [r2, #56]	@ 0x38
  if((Bank & FLASH_BANK_BOTH) == FLASH_BANK_2)
24003e76:	e7c9      	b.n	24003e0c <HAL_FLASHEx_OBGetConfig+0x4c>
    regvalue = FLASH->PRAR_CUR2;
24003e78:	f8d3 2128 	ldr.w	r2, [r3, #296]	@ 0x128
    bankBase = FLASH_BANK2_BASE;
24003e7c:	f04f 6101 	mov.w	r1, #135266304	@ 0x8100000
24003e80:	e7d1      	b.n	24003e26 <HAL_FLASHEx_OBGetConfig+0x66>
    regvalue = FLASH->SCAR_CUR2;
24003e82:	f8d2 2130 	ldr.w	r2, [r2, #304]	@ 0x130
    bankBase = FLASH_BANK2_BASE;
24003e86:	e7de      	b.n	24003e46 <HAL_FLASHEx_OBGetConfig+0x86>
24003e88:	52002000 	.word	0x52002000
24003e8c:	000fff00 	.word	0x000fff00

24003e90 <HAL_FLASHEx_Unlock_Bank1>:
  if(READ_BIT(FLASH->CR1, FLASH_CR_LOCK) != 0U)
24003e90:	4b06      	ldr	r3, [pc, #24]	@ (24003eac <HAL_FLASHEx_Unlock_Bank1+0x1c>)
24003e92:	68d8      	ldr	r0, [r3, #12]
24003e94:	f010 0001 	ands.w	r0, r0, #1
24003e98:	d007      	beq.n	24003eaa <HAL_FLASHEx_Unlock_Bank1+0x1a>
    WRITE_REG(FLASH->KEYR1, FLASH_KEY1);
24003e9a:	4a05      	ldr	r2, [pc, #20]	@ (24003eb0 <HAL_FLASHEx_Unlock_Bank1+0x20>)
24003e9c:	605a      	str	r2, [r3, #4]
    WRITE_REG(FLASH->KEYR1, FLASH_KEY2);
24003e9e:	f102 3288 	add.w	r2, r2, #2290649224	@ 0x88888888
24003ea2:	605a      	str	r2, [r3, #4]
    if (READ_BIT(FLASH->CR1, FLASH_CR_LOCK) != 0U)
24003ea4:	68d8      	ldr	r0, [r3, #12]
24003ea6:	f000 0001 	and.w	r0, r0, #1
}
24003eaa:	4770      	bx	lr
24003eac:	52002000 	.word	0x52002000
24003eb0:	45670123 	.word	0x45670123

24003eb4 <HAL_FLASHEx_Lock_Bank1>:
  SET_BIT(FLASH->CR1, FLASH_CR_LOCK);
24003eb4:	4a03      	ldr	r2, [pc, #12]	@ (24003ec4 <HAL_FLASHEx_Lock_Bank1+0x10>)
}
24003eb6:	2000      	movs	r0, #0
  SET_BIT(FLASH->CR1, FLASH_CR_LOCK);
24003eb8:	68d3      	ldr	r3, [r2, #12]
24003eba:	f043 0301 	orr.w	r3, r3, #1
24003ebe:	60d3      	str	r3, [r2, #12]
}
24003ec0:	4770      	bx	lr
24003ec2:	bf00      	nop
24003ec4:	52002000 	.word	0x52002000

24003ec8 <HAL_FLASHEx_Unlock_Bank2>:
  if(READ_BIT(FLASH->CR2, FLASH_CR_LOCK) != 0U)
24003ec8:	4b08      	ldr	r3, [pc, #32]	@ (24003eec <HAL_FLASHEx_Unlock_Bank2+0x24>)
24003eca:	f8d3 010c 	ldr.w	r0, [r3, #268]	@ 0x10c
24003ece:	f010 0001 	ands.w	r0, r0, #1
24003ed2:	d00a      	beq.n	24003eea <HAL_FLASHEx_Unlock_Bank2+0x22>
    WRITE_REG(FLASH->KEYR2, FLASH_KEY1);
24003ed4:	4a06      	ldr	r2, [pc, #24]	@ (24003ef0 <HAL_FLASHEx_Unlock_Bank2+0x28>)
24003ed6:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104
    WRITE_REG(FLASH->KEYR2, FLASH_KEY2);
24003eda:	f102 3288 	add.w	r2, r2, #2290649224	@ 0x88888888
24003ede:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104
    if (READ_BIT(FLASH->CR2, FLASH_CR_LOCK) != 0U)
24003ee2:	f8d3 010c 	ldr.w	r0, [r3, #268]	@ 0x10c
24003ee6:	f000 0001 	and.w	r0, r0, #1
}
24003eea:	4770      	bx	lr
24003eec:	52002000 	.word	0x52002000
24003ef0:	45670123 	.word	0x45670123

24003ef4 <HAL_FLASHEx_Lock_Bank2>:
  SET_BIT(FLASH->CR2, FLASH_CR_LOCK);
24003ef4:	4a04      	ldr	r2, [pc, #16]	@ (24003f08 <HAL_FLASHEx_Lock_Bank2+0x14>)
}
24003ef6:	2000      	movs	r0, #0
  SET_BIT(FLASH->CR2, FLASH_CR_LOCK);
24003ef8:	f8d2 310c 	ldr.w	r3, [r2, #268]	@ 0x10c
24003efc:	f043 0301 	orr.w	r3, r3, #1
24003f00:	f8c2 310c 	str.w	r3, [r2, #268]	@ 0x10c
}
24003f04:	4770      	bx	lr
24003f06:	bf00      	nop
24003f08:	52002000 	.word	0x52002000

24003f0c <HAL_FLASHEx_ComputeCRC>:
{
24003f0c:	b538      	push	{r3, r4, r5, lr}
24003f0e:	4604      	mov	r4, r0
  status = FLASH_OB_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
24003f10:	f24c 3050 	movw	r0, #50000	@ 0xc350
{
24003f14:	460d      	mov	r5, r1
  status = FLASH_OB_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
24003f16:	f7ff fd67 	bl	240039e8 <FLASH_OB_WaitForLastOperation>
  if (status == HAL_OK)
24003f1a:	2800      	cmp	r0, #0
24003f1c:	d134      	bne.n	24003f88 <HAL_FLASHEx_ComputeCRC+0x7c>
    if (pCRCInit->Bank == FLASH_BANK_1)
24003f1e:	68a3      	ldr	r3, [r4, #8]
      FLASH->CRCCR1 |= FLASH_CRCCR_CLEAN_CRC | pCRCInit->BurstSize | pCRCInit->TypeCRC;
24003f20:	e9d4 2000 	ldrd	r2, r0, [r4]
    if (pCRCInit->Bank == FLASH_BANK_1)
24003f24:	2b01      	cmp	r3, #1
24003f26:	4b52      	ldr	r3, [pc, #328]	@ (24004070 <HAL_FLASHEx_ComputeCRC+0x164>)
      FLASH->CRCCR1 |= FLASH_CRCCR_CLEAN_CRC | pCRCInit->BurstSize | pCRCInit->TypeCRC;
24003f28:	ea40 0002 	orr.w	r0, r0, r2
    if (pCRCInit->Bank == FLASH_BANK_1)
24003f2c:	d145      	bne.n	24003fba <HAL_FLASHEx_ComputeCRC+0xae>
      FLASH->CR1 |= FLASH_CR_CRC_EN;
24003f2e:	68d9      	ldr	r1, [r3, #12]
      if (pCRCInit->TypeCRC == FLASH_CRC_SECTORS)
24003f30:	f5b2 7f80 	cmp.w	r2, #256	@ 0x100
      FLASH->CR1 |= FLASH_CR_CRC_EN;
24003f34:	f441 4100 	orr.w	r1, r1, #32768	@ 0x8000
24003f38:	60d9      	str	r1, [r3, #12]
      FLASH->CCR1 |= (FLASH_CCR_CLR_CRCEND | FLASH_CCR_CLR_CRCRDERR);
24003f3a:	6959      	ldr	r1, [r3, #20]
24003f3c:	f041 51c0 	orr.w	r1, r1, #402653184	@ 0x18000000
24003f40:	6159      	str	r1, [r3, #20]
      FLASH->CRCCR1 |= FLASH_CRCCR_CLEAN_CRC | pCRCInit->BurstSize | pCRCInit->TypeCRC;
24003f42:	6d19      	ldr	r1, [r3, #80]	@ 0x50
24003f44:	ea41 0100 	orr.w	r1, r1, r0
24003f48:	f441 3100 	orr.w	r1, r1, #131072	@ 0x20000
24003f4c:	6519      	str	r1, [r3, #80]	@ 0x50
      if (pCRCInit->TypeCRC == FLASH_CRC_SECTORS)
24003f4e:	d127      	bne.n	24003fa0 <HAL_FLASHEx_ComputeCRC+0x94>
        FLASH->CRCCR1 |= FLASH_CRCCR_CLEAN_SECT;
24003f50:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
24003f52:	f442 6280 	orr.w	r2, r2, #1024	@ 0x400
24003f56:	651a      	str	r2, [r3, #80]	@ 0x50
        for(sector_index = pCRCInit->Sector; sector_index < (pCRCInit->NbSectors + pCRCInit->Sector); sector_index++)
24003f58:	e9d4 2003 	ldrd	r2, r0, [r4, #12]
24003f5c:	4410      	add	r0, r2
24003f5e:	4290      	cmp	r0, r2
24003f60:	d813      	bhi.n	24003f8a <HAL_FLASHEx_ComputeCRC+0x7e>
      FLASH->CRCCR1 |= FLASH_CRCCR_START_CRC;
24003f62:	4c43      	ldr	r4, [pc, #268]	@ (24004070 <HAL_FLASHEx_ComputeCRC+0x164>)
      status = FLASH_CRC_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_1);
24003f64:	2101      	movs	r1, #1
24003f66:	f24c 3050 	movw	r0, #50000	@ 0xc350
      FLASH->CRCCR1 |= FLASH_CRCCR_START_CRC;
24003f6a:	6d23      	ldr	r3, [r4, #80]	@ 0x50
24003f6c:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
24003f70:	6523      	str	r3, [r4, #80]	@ 0x50
      status = FLASH_CRC_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_1);
24003f72:	f7ff fd61 	bl	24003a38 <FLASH_CRC_WaitForLastOperation>
      (*CRC_Result) = FLASH->CRCDATA;
24003f76:	6de3      	ldr	r3, [r4, #92]	@ 0x5c
24003f78:	602b      	str	r3, [r5, #0]
      FLASH->CR1 &= (~FLASH_CR_CRC_EN);
24003f7a:	68e3      	ldr	r3, [r4, #12]
24003f7c:	f423 4300 	bic.w	r3, r3, #32768	@ 0x8000
24003f80:	60e3      	str	r3, [r4, #12]
      __HAL_FLASH_CLEAR_FLAG_BANK1(FLASH_FLAG_CRCEND_BANK1 | FLASH_FLAG_CRCRDERR_BANK1);
24003f82:	f04f 53c0 	mov.w	r3, #402653184	@ 0x18000000
24003f86:	6163      	str	r3, [r4, #20]
}
24003f88:	bd38      	pop	{r3, r4, r5, pc}
  assert_param(IS_FLASH_SECTOR(Sector));

  if (Bank == FLASH_BANK_1)
  {
    /* Clear CRC sector */
    FLASH->CRCCR1 &= (~FLASH_CRCCR_CRC_SECT);
24003f8a:	6d19      	ldr	r1, [r3, #80]	@ 0x50
24003f8c:	f021 0107 	bic.w	r1, r1, #7
24003f90:	6519      	str	r1, [r3, #80]	@ 0x50

    /* Select CRC Sector and activate ADD_SECT bit */
    FLASH->CRCCR1 |= Sector | FLASH_CRCCR_ADD_SECT;
24003f92:	6d19      	ldr	r1, [r3, #80]	@ 0x50
24003f94:	4311      	orrs	r1, r2
        for(sector_index = pCRCInit->Sector; sector_index < (pCRCInit->NbSectors + pCRCInit->Sector); sector_index++)
24003f96:	3201      	adds	r2, #1
    FLASH->CRCCR1 |= Sector | FLASH_CRCCR_ADD_SECT;
24003f98:	f441 7100 	orr.w	r1, r1, #512	@ 0x200
24003f9c:	6519      	str	r1, [r3, #80]	@ 0x50
        for(sector_index = pCRCInit->Sector; sector_index < (pCRCInit->NbSectors + pCRCInit->Sector); sector_index++)
24003f9e:	e7de      	b.n	24003f5e <HAL_FLASHEx_ComputeCRC+0x52>
      else if (pCRCInit->TypeCRC == FLASH_CRC_BANK)
24003fa0:	4934      	ldr	r1, [pc, #208]	@ (24004074 <HAL_FLASHEx_ComputeCRC+0x168>)
24003fa2:	428a      	cmp	r2, r1
24003fa4:	d104      	bne.n	24003fb0 <HAL_FLASHEx_ComputeCRC+0xa4>
        FLASH->CRCCR1 |= FLASH_CRCCR_ALL_BANK;
24003fa6:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
24003fa8:	f442 0280 	orr.w	r2, r2, #4194304	@ 0x400000
24003fac:	651a      	str	r2, [r3, #80]	@ 0x50
24003fae:	e7d8      	b.n	24003f62 <HAL_FLASHEx_ComputeCRC+0x56>
        FLASH_CRC_SelectAddress(pCRCInit->CRCStartAddr, pCRCInit->CRCEndAddr, FLASH_BANK_1);
24003fb0:	e9d4 1205 	ldrd	r1, r2, [r4, #20]
  {
    assert_param(IS_FLASH_PROGRAM_ADDRESS_BANK1(CRCStartAddr));
    assert_param(IS_FLASH_PROGRAM_ADDRESS_BANK1(CRCEndAddr));

    /* Write CRC Start and End addresses */
    FLASH->CRCSADD1 = CRCStartAddr;
24003fb4:	6559      	str	r1, [r3, #84]	@ 0x54
    FLASH->CRCEADD1 = CRCEndAddr;
24003fb6:	659a      	str	r2, [r3, #88]	@ 0x58
24003fb8:	e7d3      	b.n	24003f62 <HAL_FLASHEx_ComputeCRC+0x56>
      FLASH->CR2 |= FLASH_CR_CRC_EN;
24003fba:	f8d3 110c 	ldr.w	r1, [r3, #268]	@ 0x10c
      if (pCRCInit->TypeCRC == FLASH_CRC_SECTORS)
24003fbe:	f5b2 7f80 	cmp.w	r2, #256	@ 0x100
      FLASH->CR2 |= FLASH_CR_CRC_EN;
24003fc2:	f441 4100 	orr.w	r1, r1, #32768	@ 0x8000
24003fc6:	f8c3 110c 	str.w	r1, [r3, #268]	@ 0x10c
      FLASH->CCR2 |= (FLASH_CCR_CLR_CRCEND | FLASH_CCR_CLR_CRCRDERR);
24003fca:	f8d3 1114 	ldr.w	r1, [r3, #276]	@ 0x114
24003fce:	f041 51c0 	orr.w	r1, r1, #402653184	@ 0x18000000
24003fd2:	f8c3 1114 	str.w	r1, [r3, #276]	@ 0x114
      FLASH->CRCCR2 |= FLASH_CRCCR_CLEAN_CRC | pCRCInit->BurstSize | pCRCInit->TypeCRC;
24003fd6:	f8d3 1150 	ldr.w	r1, [r3, #336]	@ 0x150
24003fda:	ea41 0100 	orr.w	r1, r1, r0
24003fde:	f441 3100 	orr.w	r1, r1, #131072	@ 0x20000
24003fe2:	f8c3 1150 	str.w	r1, [r3, #336]	@ 0x150
      if (pCRCInit->TypeCRC == FLASH_CRC_SECTORS)
24003fe6:	d132      	bne.n	2400404e <HAL_FLASHEx_ComputeCRC+0x142>
        FLASH->CRCCR2 |= FLASH_CRCCR_CLEAN_SECT;
24003fe8:	f8d3 2150 	ldr.w	r2, [r3, #336]	@ 0x150
24003fec:	f442 6280 	orr.w	r2, r2, #1024	@ 0x400
24003ff0:	f8c3 2150 	str.w	r2, [r3, #336]	@ 0x150
        for(sector_index = pCRCInit->Sector; sector_index < (pCRCInit->NbSectors + pCRCInit->Sector); sector_index++)
24003ff4:	e9d4 2003 	ldrd	r2, r0, [r4, #12]
24003ff8:	4410      	add	r0, r2
24003ffa:	4290      	cmp	r0, r2
24003ffc:	d818      	bhi.n	24004030 <HAL_FLASHEx_ComputeCRC+0x124>
      FLASH->CRCCR2 |= FLASH_CRCCR_START_CRC;
24003ffe:	4c1c      	ldr	r4, [pc, #112]	@ (24004070 <HAL_FLASHEx_ComputeCRC+0x164>)
      status = FLASH_CRC_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_2);
24004000:	2102      	movs	r1, #2
24004002:	f24c 3050 	movw	r0, #50000	@ 0xc350
      FLASH->CRCCR2 |= FLASH_CRCCR_START_CRC;
24004006:	f8d4 3150 	ldr.w	r3, [r4, #336]	@ 0x150
2400400a:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
2400400e:	f8c4 3150 	str.w	r3, [r4, #336]	@ 0x150
      status = FLASH_CRC_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_2);
24004012:	f7ff fd11 	bl	24003a38 <FLASH_CRC_WaitForLastOperation>
      (*CRC_Result) = FLASH->CRCDATA;
24004016:	6de3      	ldr	r3, [r4, #92]	@ 0x5c
24004018:	602b      	str	r3, [r5, #0]
      FLASH->CR2 &= (~FLASH_CR_CRC_EN);
2400401a:	f8d4 310c 	ldr.w	r3, [r4, #268]	@ 0x10c
2400401e:	f423 4300 	bic.w	r3, r3, #32768	@ 0x8000
24004022:	f8c4 310c 	str.w	r3, [r4, #268]	@ 0x10c
      __HAL_FLASH_CLEAR_FLAG_BANK2(FLASH_FLAG_CRCEND_BANK2 | FLASH_FLAG_CRCRDERR_BANK2);
24004026:	f04f 53c0 	mov.w	r3, #402653184	@ 0x18000000
2400402a:	f8c4 3114 	str.w	r3, [r4, #276]	@ 0x114
2400402e:	e7ab      	b.n	24003f88 <HAL_FLASHEx_ComputeCRC+0x7c>
    FLASH->CRCCR2 &= (~FLASH_CRCCR_CRC_SECT);
24004030:	f8d3 1150 	ldr.w	r1, [r3, #336]	@ 0x150
24004034:	f021 0107 	bic.w	r1, r1, #7
24004038:	f8c3 1150 	str.w	r1, [r3, #336]	@ 0x150
    FLASH->CRCCR2 |= Sector | FLASH_CRCCR_ADD_SECT;
2400403c:	f8d3 1150 	ldr.w	r1, [r3, #336]	@ 0x150
24004040:	4311      	orrs	r1, r2
        for(sector_index = pCRCInit->Sector; sector_index < (pCRCInit->NbSectors + pCRCInit->Sector); sector_index++)
24004042:	3201      	adds	r2, #1
    FLASH->CRCCR2 |= Sector | FLASH_CRCCR_ADD_SECT;
24004044:	f441 7100 	orr.w	r1, r1, #512	@ 0x200
24004048:	f8c3 1150 	str.w	r1, [r3, #336]	@ 0x150
        for(sector_index = pCRCInit->Sector; sector_index < (pCRCInit->NbSectors + pCRCInit->Sector); sector_index++)
2400404c:	e7d5      	b.n	24003ffa <HAL_FLASHEx_ComputeCRC+0xee>
      else if (pCRCInit->TypeCRC == FLASH_CRC_BANK)
2400404e:	4909      	ldr	r1, [pc, #36]	@ (24004074 <HAL_FLASHEx_ComputeCRC+0x168>)
24004050:	428a      	cmp	r2, r1
24004052:	d106      	bne.n	24004062 <HAL_FLASHEx_ComputeCRC+0x156>
        FLASH->CRCCR2 |= FLASH_CRCCR_ALL_BANK;
24004054:	f8d3 2150 	ldr.w	r2, [r3, #336]	@ 0x150
24004058:	f442 0280 	orr.w	r2, r2, #4194304	@ 0x400000
2400405c:	f8c3 2150 	str.w	r2, [r3, #336]	@ 0x150
24004060:	e7cd      	b.n	24003ffe <HAL_FLASHEx_ComputeCRC+0xf2>
        FLASH_CRC_SelectAddress(pCRCInit->CRCStartAddr, pCRCInit->CRCEndAddr, FLASH_BANK_2);
24004062:	e9d4 1205 	ldrd	r1, r2, [r4, #20]
  {
    assert_param(IS_FLASH_PROGRAM_ADDRESS_BANK2(CRCStartAddr));
    assert_param(IS_FLASH_PROGRAM_ADDRESS_BANK2(CRCEndAddr));

    /* Write CRC Start and End addresses */
    FLASH->CRCSADD2 = CRCStartAddr;
24004066:	f8c3 1154 	str.w	r1, [r3, #340]	@ 0x154
    FLASH->CRCEADD2 = CRCEndAddr;
2400406a:	f8c3 2158 	str.w	r2, [r3, #344]	@ 0x158
2400406e:	e7c6      	b.n	24003ffe <HAL_FLASHEx_ComputeCRC+0xf2>
24004070:	52002000 	.word	0x52002000
24004074:	00400100 	.word	0x00400100

24004078 <FLASH_Erase_Sector>:
{
24004078:	b510      	push	{r4, lr}
  if((Banks & FLASH_BANK_1) == FLASH_BANK_1)
2400407a:	07cc      	lsls	r4, r1, #31
2400407c:	d50b      	bpl.n	24004096 <FLASH_Erase_Sector+0x1e>
    FLASH->CR1 &= ~(FLASH_CR_PSIZE | FLASH_CR_SNB);
2400407e:	4c0f      	ldr	r4, [pc, #60]	@ (240040bc <FLASH_Erase_Sector+0x44>)
24004080:	68e3      	ldr	r3, [r4, #12]
24004082:	f423 63e6 	bic.w	r3, r3, #1840	@ 0x730
24004086:	60e3      	str	r3, [r4, #12]
    FLASH->CR1 |= (FLASH_CR_SER | VoltageRange | (Sector << FLASH_CR_SNB_Pos) | FLASH_CR_START);
24004088:	68e3      	ldr	r3, [r4, #12]
2400408a:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
2400408e:	4313      	orrs	r3, r2
24004090:	f043 0384 	orr.w	r3, r3, #132	@ 0x84
24004094:	60e3      	str	r3, [r4, #12]
  if((Banks & FLASH_BANK_2) == FLASH_BANK_2)
24004096:	078b      	lsls	r3, r1, #30
24004098:	d50f      	bpl.n	240040ba <FLASH_Erase_Sector+0x42>
    FLASH->CR2 &= ~(FLASH_CR_PSIZE | FLASH_CR_SNB);
2400409a:	4908      	ldr	r1, [pc, #32]	@ (240040bc <FLASH_Erase_Sector+0x44>)
2400409c:	f8d1 310c 	ldr.w	r3, [r1, #268]	@ 0x10c
240040a0:	f423 63e6 	bic.w	r3, r3, #1840	@ 0x730
240040a4:	f8c1 310c 	str.w	r3, [r1, #268]	@ 0x10c
    FLASH->CR2 |= (FLASH_CR_SER | VoltageRange  | (Sector << FLASH_CR_SNB_Pos) | FLASH_CR_START);
240040a8:	f8d1 310c 	ldr.w	r3, [r1, #268]	@ 0x10c
240040ac:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
240040b0:	4302      	orrs	r2, r0
240040b2:	f042 0284 	orr.w	r2, r2, #132	@ 0x84
240040b6:	f8c1 210c 	str.w	r2, [r1, #268]	@ 0x10c
}
240040ba:	bd10      	pop	{r4, pc}
240040bc:	52002000 	.word	0x52002000

240040c0 <HAL_FLASHEx_Erase>:
{
240040c0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  __HAL_LOCK(&pFlash);
240040c4:	4f44      	ldr	r7, [pc, #272]	@ (240041d8 <HAL_FLASHEx_Erase+0x118>)
{
240040c6:	4605      	mov	r5, r0
240040c8:	4688      	mov	r8, r1
  __HAL_LOCK(&pFlash);
240040ca:	7d3b      	ldrb	r3, [r7, #20]
240040cc:	2b01      	cmp	r3, #1
240040ce:	f000 8081 	beq.w	240041d4 <HAL_FLASHEx_Erase+0x114>
240040d2:	2101      	movs	r1, #1
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
240040d4:	2300      	movs	r3, #0
  __HAL_LOCK(&pFlash);
240040d6:	7539      	strb	r1, [r7, #20]
  if((pEraseInit->Banks & FLASH_BANK_1) == FLASH_BANK_1)
240040d8:	6844      	ldr	r4, [r0, #4]
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
240040da:	61bb      	str	r3, [r7, #24]
  if((pEraseInit->Banks & FLASH_BANK_1) == FLASH_BANK_1)
240040dc:	400c      	ands	r4, r1
240040de:	d006      	beq.n	240040ee <HAL_FLASHEx_Erase+0x2e>
    if(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_1) != HAL_OK)
240040e0:	f24c 3050 	movw	r0, #50000	@ 0xc350
240040e4:	f7ff fb7e 	bl	240037e4 <FLASH_WaitForLastOperation>
240040e8:	1e04      	subs	r4, r0, #0
240040ea:	bf18      	it	ne
240040ec:	2401      	movne	r4, #1
  if((pEraseInit->Banks & FLASH_BANK_2) == FLASH_BANK_2)
240040ee:	686b      	ldr	r3, [r5, #4]
240040f0:	0798      	lsls	r0, r3, #30
240040f2:	d406      	bmi.n	24004102 <HAL_FLASHEx_Erase+0x42>
  if(status == HAL_OK)
240040f4:	b16c      	cbz	r4, 24004112 <HAL_FLASHEx_Erase+0x52>
240040f6:	2401      	movs	r4, #1
  __HAL_UNLOCK(&pFlash);
240040f8:	2300      	movs	r3, #0
240040fa:	753b      	strb	r3, [r7, #20]
}
240040fc:	4620      	mov	r0, r4
240040fe:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_2) != HAL_OK)
24004102:	2102      	movs	r1, #2
24004104:	f24c 3050 	movw	r0, #50000	@ 0xc350
24004108:	f7ff fb6c 	bl	240037e4 <FLASH_WaitForLastOperation>
2400410c:	2800      	cmp	r0, #0
2400410e:	d0f1      	beq.n	240040f4 <HAL_FLASHEx_Erase+0x34>
24004110:	e7f1      	b.n	240040f6 <HAL_FLASHEx_Erase+0x36>
    if(pEraseInit->TypeErase == FLASH_TYPEERASE_MASSERASE)
24004112:	682e      	ldr	r6, [r5, #0]
24004114:	2e01      	cmp	r6, #1
24004116:	d125      	bne.n	24004164 <HAL_FLASHEx_Erase+0xa4>
      FLASH_MassErase(pEraseInit->VoltageRange, pEraseInit->Banks);
24004118:	6869      	ldr	r1, [r5, #4]
2400411a:	6928      	ldr	r0, [r5, #16]
2400411c:	f7ff fcf0 	bl	24003b00 <FLASH_MassErase>
      if((pEraseInit->Banks & FLASH_BANK_1) == FLASH_BANK_1)
24004120:	07c9      	lsls	r1, r1, #31
24004122:	d50c      	bpl.n	2400413e <HAL_FLASHEx_Erase+0x7e>
        if(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_1) != HAL_OK)
24004124:	4631      	mov	r1, r6
24004126:	f24c 3050 	movw	r0, #50000	@ 0xc350
2400412a:	f7ff fb5b 	bl	240037e4 <FLASH_WaitForLastOperation>
        FLASH->CR1 &= (~FLASH_CR_BER);
2400412e:	4a2b      	ldr	r2, [pc, #172]	@ (240041dc <HAL_FLASHEx_Erase+0x11c>)
        if(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_1) != HAL_OK)
24004130:	1e04      	subs	r4, r0, #0
        FLASH->CR1 &= (~FLASH_CR_BER);
24004132:	68d3      	ldr	r3, [r2, #12]
        if(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_1) != HAL_OK)
24004134:	bf18      	it	ne
24004136:	2401      	movne	r4, #1
        FLASH->CR1 &= (~FLASH_CR_BER);
24004138:	f023 0308 	bic.w	r3, r3, #8
2400413c:	60d3      	str	r3, [r2, #12]
      if((pEraseInit->Banks & FLASH_BANK_2) == FLASH_BANK_2)
2400413e:	686b      	ldr	r3, [r5, #4]
24004140:	079a      	lsls	r2, r3, #30
24004142:	d5d9      	bpl.n	240040f8 <HAL_FLASHEx_Erase+0x38>
        if(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_2) != HAL_OK)
24004144:	2102      	movs	r1, #2
24004146:	f24c 3050 	movw	r0, #50000	@ 0xc350
2400414a:	f7ff fb4b 	bl	240037e4 <FLASH_WaitForLastOperation>
        FLASH->CR2 &= (~FLASH_CR_BER);
2400414e:	4a23      	ldr	r2, [pc, #140]	@ (240041dc <HAL_FLASHEx_Erase+0x11c>)
          status = HAL_ERROR;
24004150:	2800      	cmp	r0, #0
        FLASH->CR2 &= (~FLASH_CR_BER);
24004152:	f8d2 310c 	ldr.w	r3, [r2, #268]	@ 0x10c
          status = HAL_ERROR;
24004156:	bf18      	it	ne
24004158:	2401      	movne	r4, #1
        FLASH->CR2 &= (~FLASH_CR_BER);
2400415a:	f023 0308 	bic.w	r3, r3, #8
2400415e:	f8c2 310c 	str.w	r3, [r2, #268]	@ 0x10c
24004162:	e7c9      	b.n	240040f8 <HAL_FLASHEx_Erase+0x38>
      *SectorError = 0xFFFFFFFFU;
24004164:	f04f 33ff 	mov.w	r3, #4294967295
          FLASH->CR1 &= (~(FLASH_CR_SER | FLASH_CR_SNB));
24004168:	f8df 9070 	ldr.w	r9, [pc, #112]	@ 240041dc <HAL_FLASHEx_Erase+0x11c>
2400416c:	f8df a070 	ldr.w	sl, [pc, #112]	@ 240041e0 <HAL_FLASHEx_Erase+0x120>
      *SectorError = 0xFFFFFFFFU;
24004170:	f8c8 3000 	str.w	r3, [r8]
      for(sector_index = pEraseInit->Sector; sector_index < (pEraseInit->NbSectors + pEraseInit->Sector); sector_index++)
24004174:	68ae      	ldr	r6, [r5, #8]
24004176:	e9d5 2302 	ldrd	r2, r3, [r5, #8]
2400417a:	4413      	add	r3, r2
2400417c:	42b3      	cmp	r3, r6
2400417e:	d9bb      	bls.n	240040f8 <HAL_FLASHEx_Erase+0x38>
        FLASH_Erase_Sector(sector_index, pEraseInit->Banks, pEraseInit->VoltageRange);
24004180:	f8d5 b004 	ldr.w	fp, [r5, #4]
24004184:	4630      	mov	r0, r6
24004186:	692a      	ldr	r2, [r5, #16]
24004188:	4659      	mov	r1, fp
2400418a:	f7ff ff75 	bl	24004078 <FLASH_Erase_Sector>
        if((pEraseInit->Banks & FLASH_BANK_1) == FLASH_BANK_1)
2400418e:	f01b 0001 	ands.w	r0, fp, #1
24004192:	d00a      	beq.n	240041aa <HAL_FLASHEx_Erase+0xea>
          status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_1);
24004194:	2101      	movs	r1, #1
24004196:	f24c 3050 	movw	r0, #50000	@ 0xc350
2400419a:	f7ff fb23 	bl	240037e4 <FLASH_WaitForLastOperation>
          FLASH->CR1 &= (~(FLASH_CR_SER | FLASH_CR_SNB));
2400419e:	f8d9 300c 	ldr.w	r3, [r9, #12]
240041a2:	ea03 030a 	and.w	r3, r3, sl
240041a6:	f8c9 300c 	str.w	r3, [r9, #12]
        if((pEraseInit->Banks & FLASH_BANK_2) == FLASH_BANK_2)
240041aa:	686b      	ldr	r3, [r5, #4]
240041ac:	079b      	lsls	r3, r3, #30
240041ae:	d50a      	bpl.n	240041c6 <HAL_FLASHEx_Erase+0x106>
          status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_2);
240041b0:	2102      	movs	r1, #2
240041b2:	f24c 3050 	movw	r0, #50000	@ 0xc350
240041b6:	f7ff fb15 	bl	240037e4 <FLASH_WaitForLastOperation>
          FLASH->CR2 &= (~(FLASH_CR_SER | FLASH_CR_SNB));
240041ba:	f8d9 310c 	ldr.w	r3, [r9, #268]	@ 0x10c
240041be:	ea03 030a 	and.w	r3, r3, sl
240041c2:	f8c9 310c 	str.w	r3, [r9, #268]	@ 0x10c
        if(status != HAL_OK)
240041c6:	b118      	cbz	r0, 240041d0 <HAL_FLASHEx_Erase+0x110>
          break;
240041c8:	4604      	mov	r4, r0
          *SectorError = sector_index;
240041ca:	f8c8 6000 	str.w	r6, [r8]
          break;
240041ce:	e793      	b.n	240040f8 <HAL_FLASHEx_Erase+0x38>
      for(sector_index = pEraseInit->Sector; sector_index < (pEraseInit->NbSectors + pEraseInit->Sector); sector_index++)
240041d0:	3601      	adds	r6, #1
240041d2:	e7d0      	b.n	24004176 <HAL_FLASHEx_Erase+0xb6>
  __HAL_LOCK(&pFlash);
240041d4:	2402      	movs	r4, #2
240041d6:	e791      	b.n	240040fc <HAL_FLASHEx_Erase+0x3c>
240041d8:	2400057c 	.word	0x2400057c
240041dc:	52002000 	.word	0x52002000
240041e0:	fffff8fb 	.word	0xfffff8fb

240041e4 <HAL_FLASHEx_Erase_IT>:
{
240041e4:	b570      	push	{r4, r5, r6, lr}
  __HAL_LOCK(&pFlash);
240041e6:	4d2a      	ldr	r5, [pc, #168]	@ (24004290 <HAL_FLASHEx_Erase_IT+0xac>)
{
240041e8:	4606      	mov	r6, r0
  __HAL_LOCK(&pFlash);
240041ea:	7d2b      	ldrb	r3, [r5, #20]
240041ec:	2b01      	cmp	r3, #1
240041ee:	d04d      	beq.n	2400428c <HAL_FLASHEx_Erase_IT+0xa8>
240041f0:	2101      	movs	r1, #1
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
240041f2:	2300      	movs	r3, #0
  __HAL_LOCK(&pFlash);
240041f4:	7529      	strb	r1, [r5, #20]
  if((pEraseInit->Banks & FLASH_BANK_1) == FLASH_BANK_1)
240041f6:	6844      	ldr	r4, [r0, #4]
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
240041f8:	61ab      	str	r3, [r5, #24]
  if((pEraseInit->Banks & FLASH_BANK_1) == FLASH_BANK_1)
240041fa:	400c      	ands	r4, r1
240041fc:	d006      	beq.n	2400420c <HAL_FLASHEx_Erase_IT+0x28>
    if(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_1) != HAL_OK)
240041fe:	f24c 3050 	movw	r0, #50000	@ 0xc350
24004202:	f7ff faef 	bl	240037e4 <FLASH_WaitForLastOperation>
24004206:	1e04      	subs	r4, r0, #0
24004208:	bf18      	it	ne
2400420a:	2401      	movne	r4, #1
  if((pEraseInit->Banks & FLASH_BANK_2) == FLASH_BANK_2)
2400420c:	6873      	ldr	r3, [r6, #4]
2400420e:	0799      	lsls	r1, r3, #30
24004210:	d41c      	bmi.n	2400424c <HAL_FLASHEx_Erase_IT+0x68>
  if (status != HAL_OK)
24004212:	bb14      	cbnz	r4, 2400425a <HAL_FLASHEx_Erase_IT+0x76>
    if((pEraseInit->Banks & FLASH_BANK_1) == FLASH_BANK_1)
24004214:	6871      	ldr	r1, [r6, #4]
24004216:	07ca      	lsls	r2, r1, #31
24004218:	d504      	bpl.n	24004224 <HAL_FLASHEx_Erase_IT+0x40>
      __HAL_FLASH_ENABLE_IT_BANK1(FLASH_IT_EOP_BANK1     | FLASH_IT_WRPERR_BANK1 | FLASH_IT_PGSERR_BANK1 | \
2400421a:	4a1e      	ldr	r2, [pc, #120]	@ (24004294 <HAL_FLASHEx_Erase_IT+0xb0>)
2400421c:	68d3      	ldr	r3, [r2, #12]
2400421e:	f443 03de 	orr.w	r3, r3, #7274496	@ 0x6f0000
24004222:	60d3      	str	r3, [r2, #12]
    if((pEraseInit->Banks & FLASH_BANK_2) == FLASH_BANK_2)
24004224:	078b      	lsls	r3, r1, #30
24004226:	d506      	bpl.n	24004236 <HAL_FLASHEx_Erase_IT+0x52>
      __HAL_FLASH_ENABLE_IT_BANK2(FLASH_IT_EOP_BANK2     | FLASH_IT_WRPERR_BANK2 | FLASH_IT_PGSERR_BANK2 | \
24004228:	4a1a      	ldr	r2, [pc, #104]	@ (24004294 <HAL_FLASHEx_Erase_IT+0xb0>)
2400422a:	f8d2 310c 	ldr.w	r3, [r2, #268]	@ 0x10c
2400422e:	f443 03de 	orr.w	r3, r3, #7274496	@ 0x6f0000
24004232:	f8c2 310c 	str.w	r3, [r2, #268]	@ 0x10c
    if(pEraseInit->TypeErase == FLASH_TYPEERASE_MASSERASE)
24004236:	6833      	ldr	r3, [r6, #0]
24004238:	2b01      	cmp	r3, #1
2400423a:	d118      	bne.n	2400426e <HAL_FLASHEx_Erase_IT+0x8a>
      if(pEraseInit->Banks == FLASH_BANK_1)
2400423c:	2901      	cmp	r1, #1
2400423e:	d111      	bne.n	24004264 <HAL_FLASHEx_Erase_IT+0x80>
        pFlash.ProcedureOnGoing = FLASH_PROC_MASSERASE_BANK1;
24004240:	2302      	movs	r3, #2
        pFlash.ProcedureOnGoing = FLASH_PROC_ALLBANK_MASSERASE;
24004242:	702b      	strb	r3, [r5, #0]
      FLASH_MassErase(pEraseInit->VoltageRange, pEraseInit->Banks);
24004244:	6930      	ldr	r0, [r6, #16]
24004246:	f7ff fc5b 	bl	24003b00 <FLASH_MassErase>
2400424a:	e009      	b.n	24004260 <HAL_FLASHEx_Erase_IT+0x7c>
    if(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_2) != HAL_OK)
2400424c:	2102      	movs	r1, #2
2400424e:	f24c 3050 	movw	r0, #50000	@ 0xc350
24004252:	f7ff fac7 	bl	240037e4 <FLASH_WaitForLastOperation>
24004256:	2800      	cmp	r0, #0
24004258:	d0db      	beq.n	24004212 <HAL_FLASHEx_Erase_IT+0x2e>
    __HAL_UNLOCK(&pFlash);
2400425a:	2300      	movs	r3, #0
2400425c:	2401      	movs	r4, #1
2400425e:	752b      	strb	r3, [r5, #20]
}
24004260:	4620      	mov	r0, r4
24004262:	bd70      	pop	{r4, r5, r6, pc}
      else if(pEraseInit->Banks == FLASH_BANK_2)
24004264:	2902      	cmp	r1, #2
        pFlash.ProcedureOnGoing = FLASH_PROC_MASSERASE_BANK2;
24004266:	bf0c      	ite	eq
24004268:	2305      	moveq	r3, #5
        pFlash.ProcedureOnGoing = FLASH_PROC_ALLBANK_MASSERASE;
2400426a:	2307      	movne	r3, #7
2400426c:	e7e9      	b.n	24004242 <HAL_FLASHEx_Erase_IT+0x5e>
      if(pEraseInit->Banks == FLASH_BANK_1)
2400426e:	2901      	cmp	r1, #1
24004270:	d109      	bne.n	24004286 <HAL_FLASHEx_Erase_IT+0xa2>
        pFlash.ProcedureOnGoing = FLASH_PROC_SECTERASE_BANK1;
24004272:	7029      	strb	r1, [r5, #0]
      pFlash.NbSectorsToErase = pEraseInit->NbSectors;
24004274:	68f3      	ldr	r3, [r6, #12]
      pFlash.Sector = pEraseInit->Sector;
24004276:	68b0      	ldr	r0, [r6, #8]
      pFlash.VoltageForErase = pEraseInit->VoltageRange;
24004278:	6932      	ldr	r2, [r6, #16]
      pFlash.NbSectorsToErase = pEraseInit->NbSectors;
2400427a:	606b      	str	r3, [r5, #4]
      pFlash.Sector = pEraseInit->Sector;
2400427c:	60e8      	str	r0, [r5, #12]
      pFlash.VoltageForErase = pEraseInit->VoltageRange;
2400427e:	60aa      	str	r2, [r5, #8]
      FLASH_Erase_Sector(pEraseInit->Sector, pEraseInit->Banks, pEraseInit->VoltageRange);
24004280:	f7ff fefa 	bl	24004078 <FLASH_Erase_Sector>
24004284:	e7ec      	b.n	24004260 <HAL_FLASHEx_Erase_IT+0x7c>
        pFlash.ProcedureOnGoing = FLASH_PROC_SECTERASE_BANK2;
24004286:	2304      	movs	r3, #4
24004288:	702b      	strb	r3, [r5, #0]
2400428a:	e7f3      	b.n	24004274 <HAL_FLASHEx_Erase_IT+0x90>
  __HAL_LOCK(&pFlash);
2400428c:	2402      	movs	r4, #2
2400428e:	e7e7      	b.n	24004260 <HAL_FLASHEx_Erase_IT+0x7c>
24004290:	2400057c 	.word	0x2400057c
24004294:	52002000 	.word	0x52002000

24004298 <HAL_GPIO_Init>:
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
24004298:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint32_t position = 0x00U;
2400429c:	2300      	movs	r3, #0
      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if ((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
2400429e:	f8df e1b8 	ldr.w	lr, [pc, #440]	@ 24004458 <HAL_GPIO_Init+0x1c0>

        temp = SYSCFG->EXTICR[position >> 2U];
        temp &= ~(0x0FUL << (4U * (position & 0x03U)));
240042a2:	f04f 090f 	mov.w	r9, #15
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
        SYSCFG->EXTICR[position >> 2U] = temp;

        /* Clear EXTI line configuration */
        temp = EXTI_CurrentCPU->IMR1;
240042a6:	f04f 44b0 	mov.w	r4, #1476395008	@ 0x58000000
  while (((GPIO_Init->Pin) >> position) != 0x00U)
240042aa:	680a      	ldr	r2, [r1, #0]
240042ac:	fa32 f503 	lsrs.w	r5, r2, r3
240042b0:	d102      	bne.n	240042b8 <HAL_GPIO_Init+0x20>
      }
    }

    position++;
  }
}
240042b2:	b003      	add	sp, #12
240042b4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    iocurrent = (GPIO_Init->Pin) & (1UL << position);
240042b8:	2501      	movs	r5, #1
240042ba:	fa05 f803 	lsl.w	r8, r5, r3
    if (iocurrent != 0x00U)
240042be:	ea18 0202 	ands.w	r2, r8, r2
240042c2:	f000 80b3 	beq.w	2400442c <HAL_GPIO_Init+0x194>
      if ((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
240042c6:	684d      	ldr	r5, [r1, #4]
240042c8:	ea4f 0c43 	mov.w	ip, r3, lsl #1
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
240042cc:	2603      	movs	r6, #3
      if ((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
240042ce:	f025 0a10 	bic.w	sl, r5, #16
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
240042d2:	fa06 f60c 	lsl.w	r6, r6, ip
      if ((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
240042d6:	f10a 37ff 	add.w	r7, sl, #4294967295
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
240042da:	43f6      	mvns	r6, r6
      if ((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
240042dc:	2f01      	cmp	r7, #1
240042de:	d810      	bhi.n	24004302 <HAL_GPIO_Init+0x6a>
        temp = GPIOx->OSPEEDR;
240042e0:	6887      	ldr	r7, [r0, #8]
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
240042e2:	ea07 0b06 	and.w	fp, r7, r6
        temp |= (GPIO_Init->Speed << (position * 2U));
240042e6:	68cf      	ldr	r7, [r1, #12]
240042e8:	fa07 f70c 	lsl.w	r7, r7, ip
240042ec:	ea47 070b 	orr.w	r7, r7, fp
        GPIOx->OSPEEDR = temp;
240042f0:	6087      	str	r7, [r0, #8]
        temp = GPIOx->OTYPER;
240042f2:	6847      	ldr	r7, [r0, #4]
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
240042f4:	ea27 0808 	bic.w	r8, r7, r8
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4U) << position);
240042f8:	092f      	lsrs	r7, r5, #4
240042fa:	409f      	lsls	r7, r3
240042fc:	ea47 0708 	orr.w	r7, r7, r8
        GPIOx->OTYPER = temp;
24004300:	6047      	str	r7, [r0, #4]
      temp = GPIOx->PUPDR;
24004302:	68c7      	ldr	r7, [r0, #12]
      if ((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
24004304:	f1ba 0f02 	cmp.w	sl, #2
      temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
24004308:	ea07 0806 	and.w	r8, r7, r6
      temp |= ((GPIO_Init->Pull) << (position * 2U));
2400430c:	688f      	ldr	r7, [r1, #8]
2400430e:	fa07 f70c 	lsl.w	r7, r7, ip
24004312:	ea47 0708 	orr.w	r7, r7, r8
      GPIOx->PUPDR = temp;
24004316:	60c7      	str	r7, [r0, #12]
      if ((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
24004318:	d114      	bne.n	24004344 <HAL_GPIO_Init+0xac>
        temp = GPIOx->AFR[position >> 3U];
2400431a:	ea4f 08d3 	mov.w	r8, r3, lsr #3
        temp &= ~(0xFU << ((position & 0x07U) * 4U));
2400431e:	f003 0a07 	and.w	sl, r3, #7
24004322:	eb00 0888 	add.w	r8, r0, r8, lsl #2
24004326:	ea4f 0a8a 	mov.w	sl, sl, lsl #2
        temp = GPIOx->AFR[position >> 3U];
2400432a:	f8d8 7020 	ldr.w	r7, [r8, #32]
        temp &= ~(0xFU << ((position & 0x07U) * 4U));
2400432e:	fa09 fb0a 	lsl.w	fp, r9, sl
24004332:	ea27 0b0b 	bic.w	fp, r7, fp
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07U) * 4U));
24004336:	690f      	ldr	r7, [r1, #16]
24004338:	fa07 f70a 	lsl.w	r7, r7, sl
2400433c:	ea47 070b 	orr.w	r7, r7, fp
        GPIOx->AFR[position >> 3U] = temp;
24004340:	f8c8 7020 	str.w	r7, [r8, #32]
      temp = GPIOx->MODER;
24004344:	6807      	ldr	r7, [r0, #0]
      temp &= ~(GPIO_MODER_MODE0 << (position * 2U));
24004346:	4037      	ands	r7, r6
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
24004348:	f005 0603 	and.w	r6, r5, #3
2400434c:	fa06 f60c 	lsl.w	r6, r6, ip
24004350:	433e      	orrs	r6, r7
      GPIOx->MODER = temp;
24004352:	6006      	str	r6, [r0, #0]
      if ((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
24004354:	00ee      	lsls	r6, r5, #3
24004356:	d569      	bpl.n	2400442c <HAL_GPIO_Init+0x194>
        __HAL_RCC_SYSCFG_CLK_ENABLE();
24004358:	f8de 60f4 	ldr.w	r6, [lr, #244]	@ 0xf4
2400435c:	f023 0703 	bic.w	r7, r3, #3
        temp &= ~(0x0FUL << (4U * (position & 0x03U)));
24004360:	f003 0c03 	and.w	ip, r3, #3
        __HAL_RCC_SYSCFG_CLK_ENABLE();
24004364:	f046 0602 	orr.w	r6, r6, #2
24004368:	f107 47b0 	add.w	r7, r7, #1476395008	@ 0x58000000
        temp &= ~(0x0FUL << (4U * (position & 0x03U)));
2400436c:	ea4f 0c8c 	mov.w	ip, ip, lsl #2
        __HAL_RCC_SYSCFG_CLK_ENABLE();
24004370:	f8ce 60f4 	str.w	r6, [lr, #244]	@ 0xf4
24004374:	f507 6780 	add.w	r7, r7, #1024	@ 0x400
24004378:	f8de 60f4 	ldr.w	r6, [lr, #244]	@ 0xf4
        temp &= ~(0x0FUL << (4U * (position & 0x03U)));
2400437c:	fa09 f80c 	lsl.w	r8, r9, ip
        __HAL_RCC_SYSCFG_CLK_ENABLE();
24004380:	f006 0602 	and.w	r6, r6, #2
24004384:	9601      	str	r6, [sp, #4]
24004386:	9e01      	ldr	r6, [sp, #4]
        temp = SYSCFG->EXTICR[position >> 2U];
24004388:	68be      	ldr	r6, [r7, #8]
        temp &= ~(0x0FUL << (4U * (position & 0x03U)));
2400438a:	ea26 0808 	bic.w	r8, r6, r8
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
2400438e:	4e31      	ldr	r6, [pc, #196]	@ (24004454 <HAL_GPIO_Init+0x1bc>)
24004390:	42b0      	cmp	r0, r6
24004392:	d04d      	beq.n	24004430 <HAL_GPIO_Init+0x198>
24004394:	f506 6680 	add.w	r6, r6, #1024	@ 0x400
24004398:	42b0      	cmp	r0, r6
2400439a:	d04b      	beq.n	24004434 <HAL_GPIO_Init+0x19c>
2400439c:	f506 6680 	add.w	r6, r6, #1024	@ 0x400
240043a0:	42b0      	cmp	r0, r6
240043a2:	d049      	beq.n	24004438 <HAL_GPIO_Init+0x1a0>
240043a4:	f506 6680 	add.w	r6, r6, #1024	@ 0x400
240043a8:	42b0      	cmp	r0, r6
240043aa:	d047      	beq.n	2400443c <HAL_GPIO_Init+0x1a4>
240043ac:	f506 6680 	add.w	r6, r6, #1024	@ 0x400
240043b0:	42b0      	cmp	r0, r6
240043b2:	d045      	beq.n	24004440 <HAL_GPIO_Init+0x1a8>
240043b4:	f506 6680 	add.w	r6, r6, #1024	@ 0x400
240043b8:	42b0      	cmp	r0, r6
240043ba:	d043      	beq.n	24004444 <HAL_GPIO_Init+0x1ac>
240043bc:	f506 6680 	add.w	r6, r6, #1024	@ 0x400
240043c0:	42b0      	cmp	r0, r6
240043c2:	d041      	beq.n	24004448 <HAL_GPIO_Init+0x1b0>
240043c4:	f506 6680 	add.w	r6, r6, #1024	@ 0x400
240043c8:	42b0      	cmp	r0, r6
240043ca:	d03f      	beq.n	2400444c <HAL_GPIO_Init+0x1b4>
240043cc:	f506 6680 	add.w	r6, r6, #1024	@ 0x400
240043d0:	42b0      	cmp	r0, r6
240043d2:	d03d      	beq.n	24004450 <HAL_GPIO_Init+0x1b8>
240043d4:	f506 6680 	add.w	r6, r6, #1024	@ 0x400
240043d8:	42b0      	cmp	r0, r6
240043da:	bf14      	ite	ne
240043dc:	260a      	movne	r6, #10
240043de:	2609      	moveq	r6, #9
240043e0:	fa06 f60c 	lsl.w	r6, r6, ip
        if ((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
240043e4:	f415 3f80 	tst.w	r5, #65536	@ 0x10000
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
240043e8:	ea46 0608 	orr.w	r6, r6, r8
        SYSCFG->EXTICR[position >> 2U] = temp;
240043ec:	60be      	str	r6, [r7, #8]
        temp &= ~(iocurrent);
240043ee:	ea6f 0702 	mvn.w	r7, r2
        temp = EXTI_CurrentCPU->IMR1;
240043f2:	f8d4 6080 	ldr.w	r6, [r4, #128]	@ 0x80
        temp &= ~(iocurrent);
240043f6:	bf0c      	ite	eq
240043f8:	403e      	andeq	r6, r7
          temp |= iocurrent;
240043fa:	4316      	orrne	r6, r2
        if ((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
240043fc:	f415 3f00 	tst.w	r5, #131072	@ 0x20000
        EXTI_CurrentCPU->IMR1 = temp;
24004400:	f8c4 6080 	str.w	r6, [r4, #128]	@ 0x80
        temp = EXTI_CurrentCPU->EMR1;
24004404:	f8d4 6084 	ldr.w	r6, [r4, #132]	@ 0x84
        temp &= ~(iocurrent);
24004408:	bf0c      	ite	eq
2400440a:	403e      	andeq	r6, r7
          temp |= iocurrent;
2400440c:	4316      	orrne	r6, r2
        if ((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
2400440e:	f415 1f80 	tst.w	r5, #1048576	@ 0x100000
        EXTI_CurrentCPU->EMR1 = temp;
24004412:	f8c4 6084 	str.w	r6, [r4, #132]	@ 0x84
        temp = EXTI->RTSR1;
24004416:	6826      	ldr	r6, [r4, #0]
        temp &= ~(iocurrent);
24004418:	bf0c      	ite	eq
2400441a:	403e      	andeq	r6, r7
          temp |= iocurrent;
2400441c:	4316      	orrne	r6, r2
        if ((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
2400441e:	02ad      	lsls	r5, r5, #10
        EXTI->RTSR1 = temp;
24004420:	6026      	str	r6, [r4, #0]
        temp = EXTI->FTSR1;
24004422:	6866      	ldr	r6, [r4, #4]
        temp &= ~(iocurrent);
24004424:	bf54      	ite	pl
24004426:	403e      	andpl	r6, r7
          temp |= iocurrent;
24004428:	4316      	orrmi	r6, r2
        EXTI->FTSR1 = temp;
2400442a:	6066      	str	r6, [r4, #4]
    position++;
2400442c:	3301      	adds	r3, #1
2400442e:	e73c      	b.n	240042aa <HAL_GPIO_Init+0x12>
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
24004430:	2600      	movs	r6, #0
24004432:	e7d5      	b.n	240043e0 <HAL_GPIO_Init+0x148>
24004434:	2601      	movs	r6, #1
24004436:	e7d3      	b.n	240043e0 <HAL_GPIO_Init+0x148>
24004438:	2602      	movs	r6, #2
2400443a:	e7d1      	b.n	240043e0 <HAL_GPIO_Init+0x148>
2400443c:	2603      	movs	r6, #3
2400443e:	e7cf      	b.n	240043e0 <HAL_GPIO_Init+0x148>
24004440:	2604      	movs	r6, #4
24004442:	e7cd      	b.n	240043e0 <HAL_GPIO_Init+0x148>
24004444:	2605      	movs	r6, #5
24004446:	e7cb      	b.n	240043e0 <HAL_GPIO_Init+0x148>
24004448:	2606      	movs	r6, #6
2400444a:	e7c9      	b.n	240043e0 <HAL_GPIO_Init+0x148>
2400444c:	2607      	movs	r6, #7
2400444e:	e7c7      	b.n	240043e0 <HAL_GPIO_Init+0x148>
24004450:	2608      	movs	r6, #8
24004452:	e7c5      	b.n	240043e0 <HAL_GPIO_Init+0x148>
24004454:	58020000 	.word	0x58020000
24004458:	58024400 	.word	0x58024400

2400445c <HAL_GPIO_DeInit>:
  * @param  GPIO_Pin: specifies the port bit to be written.
  *          This parameter can be one of GPIO_PIN_x where x can be (0..15).
  * @retval None
  */
void HAL_GPIO_DeInit(GPIO_TypeDef  *GPIOx, uint32_t GPIO_Pin)
{
2400445c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint32_t position = 0x00U;
24004460:	2200      	movs	r2, #0

  /* Configure the port pins */
  while ((GPIO_Pin >> position) != 0x00U)
  {
    /* Get current io position */
    iocurrent = GPIO_Pin & (1UL << position) ;
24004462:	f04f 0a01 	mov.w	sl, #1
    if (iocurrent != 0x00U)
    {
      /*------------------------- EXTI Mode Configuration --------------------*/
      /* Clear the External Interrupt or Event for the current IO */
      tmp = SYSCFG->EXTICR[position >> 2U];
      tmp &= (0x0FUL << (4U * (position & 0x03U)));
24004466:	f04f 080f 	mov.w	r8, #15
        SYSCFG->EXTICR[position >> 2U] &= ~tmp;
      }

      /*------------------------- GPIO Mode Configuration --------------------*/
      /* Configure IO in Analog Mode */
      GPIOx->MODER |= (GPIO_MODER_MODE0 << (position * 2U));
2400446a:	f04f 0b03 	mov.w	fp, #3
        EXTI_CurrentCPU->IMR1 &= ~(iocurrent);
2400446e:	f04f 44b0 	mov.w	r4, #1476395008	@ 0x58000000
  while ((GPIO_Pin >> position) != 0x00U)
24004472:	fa31 f302 	lsrs.w	r3, r1, r2
24004476:	d101      	bne.n	2400447c <HAL_GPIO_DeInit+0x20>
      GPIOx->OSPEEDR &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
    }

    position++;
  }
}
24004478:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    iocurrent = GPIO_Pin & (1UL << position) ;
2400447c:	fa0a fc02 	lsl.w	ip, sl, r2
    if (iocurrent != 0x00U)
24004480:	ea1c 0601 	ands.w	r6, ip, r1
24004484:	d070      	beq.n	24004568 <HAL_GPIO_DeInit+0x10c>
      tmp = SYSCFG->EXTICR[position >> 2U];
24004486:	f022 0503 	bic.w	r5, r2, #3
      tmp &= (0x0FUL << (4U * (position & 0x03U)));
2400448a:	f002 0703 	and.w	r7, r2, #3
2400448e:	f105 45b0 	add.w	r5, r5, #1476395008	@ 0x58000000
24004492:	00bf      	lsls	r7, r7, #2
      tmp = SYSCFG->EXTICR[position >> 2U];
24004494:	f8d5 3408 	ldr.w	r3, [r5, #1032]	@ 0x408
      tmp &= (0x0FUL << (4U * (position & 0x03U)));
24004498:	fa08 f907 	lsl.w	r9, r8, r7
2400449c:	f505 6580 	add.w	r5, r5, #1024	@ 0x400
240044a0:	ea09 0e03 	and.w	lr, r9, r3
      if (tmp == (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U))))
240044a4:	4b3a      	ldr	r3, [pc, #232]	@ (24004590 <HAL_GPIO_DeInit+0x134>)
240044a6:	4298      	cmp	r0, r3
240044a8:	d060      	beq.n	2400456c <HAL_GPIO_DeInit+0x110>
240044aa:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
240044ae:	4298      	cmp	r0, r3
240044b0:	d05e      	beq.n	24004570 <HAL_GPIO_DeInit+0x114>
240044b2:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
240044b6:	4298      	cmp	r0, r3
240044b8:	d05c      	beq.n	24004574 <HAL_GPIO_DeInit+0x118>
240044ba:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
240044be:	4298      	cmp	r0, r3
240044c0:	d05a      	beq.n	24004578 <HAL_GPIO_DeInit+0x11c>
240044c2:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
240044c6:	4298      	cmp	r0, r3
240044c8:	d058      	beq.n	2400457c <HAL_GPIO_DeInit+0x120>
240044ca:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
240044ce:	4298      	cmp	r0, r3
240044d0:	d056      	beq.n	24004580 <HAL_GPIO_DeInit+0x124>
240044d2:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
240044d6:	4298      	cmp	r0, r3
240044d8:	d054      	beq.n	24004584 <HAL_GPIO_DeInit+0x128>
240044da:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
240044de:	4298      	cmp	r0, r3
240044e0:	d052      	beq.n	24004588 <HAL_GPIO_DeInit+0x12c>
240044e2:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
240044e6:	4298      	cmp	r0, r3
240044e8:	d050      	beq.n	2400458c <HAL_GPIO_DeInit+0x130>
240044ea:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
240044ee:	4298      	cmp	r0, r3
240044f0:	bf0c      	ite	eq
240044f2:	2309      	moveq	r3, #9
240044f4:	230a      	movne	r3, #10
240044f6:	40bb      	lsls	r3, r7
240044f8:	4573      	cmp	r3, lr
240044fa:	d117      	bne.n	2400452c <HAL_GPIO_DeInit+0xd0>
        EXTI_CurrentCPU->IMR1 &= ~(iocurrent);
240044fc:	f8d4 3080 	ldr.w	r3, [r4, #128]	@ 0x80
24004500:	ea23 0306 	bic.w	r3, r3, r6
24004504:	f8c4 3080 	str.w	r3, [r4, #128]	@ 0x80
        EXTI_CurrentCPU->EMR1 &= ~(iocurrent);
24004508:	f8d4 3084 	ldr.w	r3, [r4, #132]	@ 0x84
2400450c:	ea23 0306 	bic.w	r3, r3, r6
24004510:	f8c4 3084 	str.w	r3, [r4, #132]	@ 0x84
        EXTI->RTSR1 &= ~(iocurrent);
24004514:	6823      	ldr	r3, [r4, #0]
24004516:	ea23 0306 	bic.w	r3, r3, r6
2400451a:	6023      	str	r3, [r4, #0]
        EXTI->FTSR1 &= ~(iocurrent);
2400451c:	6863      	ldr	r3, [r4, #4]
2400451e:	ea23 0306 	bic.w	r3, r3, r6
24004522:	6063      	str	r3, [r4, #4]
        SYSCFG->EXTICR[position >> 2U] &= ~tmp;
24004524:	68ab      	ldr	r3, [r5, #8]
24004526:	ea23 0309 	bic.w	r3, r3, r9
2400452a:	60ab      	str	r3, [r5, #8]
      GPIOx->MODER |= (GPIO_MODER_MODE0 << (position * 2U));
2400452c:	0053      	lsls	r3, r2, #1
2400452e:	6805      	ldr	r5, [r0, #0]
      GPIOx->AFR[position >> 3U] &= ~(0xFU << ((position & 0x07U) * 4U)) ;
24004530:	08d6      	lsrs	r6, r2, #3
      GPIOx->MODER |= (GPIO_MODER_MODE0 << (position * 2U));
24004532:	fa0b f303 	lsl.w	r3, fp, r3
24004536:	eb00 0686 	add.w	r6, r0, r6, lsl #2
2400453a:	431d      	orrs	r5, r3
2400453c:	6005      	str	r5, [r0, #0]
      GPIOx->AFR[position >> 3U] &= ~(0xFU << ((position & 0x07U) * 4U)) ;
2400453e:	f002 0507 	and.w	r5, r2, #7
24004542:	6a37      	ldr	r7, [r6, #32]
24004544:	00ad      	lsls	r5, r5, #2
24004546:	fa08 f505 	lsl.w	r5, r8, r5
2400454a:	ea27 0705 	bic.w	r7, r7, r5
2400454e:	6237      	str	r7, [r6, #32]
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
24004550:	68c5      	ldr	r5, [r0, #12]
24004552:	ea25 0503 	bic.w	r5, r5, r3
24004556:	60c5      	str	r5, [r0, #12]
      GPIOx->OTYPER  &= ~(GPIO_OTYPER_OT0 << position) ;
24004558:	6845      	ldr	r5, [r0, #4]
2400455a:	ea25 050c 	bic.w	r5, r5, ip
2400455e:	6045      	str	r5, [r0, #4]
      GPIOx->OSPEEDR &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
24004560:	6885      	ldr	r5, [r0, #8]
24004562:	ea25 0303 	bic.w	r3, r5, r3
24004566:	6083      	str	r3, [r0, #8]
    position++;
24004568:	3201      	adds	r2, #1
2400456a:	e782      	b.n	24004472 <HAL_GPIO_DeInit+0x16>
      if (tmp == (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U))))
2400456c:	2300      	movs	r3, #0
2400456e:	e7c2      	b.n	240044f6 <HAL_GPIO_DeInit+0x9a>
24004570:	2301      	movs	r3, #1
24004572:	e7c0      	b.n	240044f6 <HAL_GPIO_DeInit+0x9a>
24004574:	2302      	movs	r3, #2
24004576:	e7be      	b.n	240044f6 <HAL_GPIO_DeInit+0x9a>
24004578:	2303      	movs	r3, #3
2400457a:	e7bc      	b.n	240044f6 <HAL_GPIO_DeInit+0x9a>
2400457c:	2304      	movs	r3, #4
2400457e:	e7ba      	b.n	240044f6 <HAL_GPIO_DeInit+0x9a>
24004580:	2305      	movs	r3, #5
24004582:	e7b8      	b.n	240044f6 <HAL_GPIO_DeInit+0x9a>
24004584:	2306      	movs	r3, #6
24004586:	e7b6      	b.n	240044f6 <HAL_GPIO_DeInit+0x9a>
24004588:	2307      	movs	r3, #7
2400458a:	e7b4      	b.n	240044f6 <HAL_GPIO_DeInit+0x9a>
2400458c:	2308      	movs	r3, #8
2400458e:	e7b2      	b.n	240044f6 <HAL_GPIO_DeInit+0x9a>
24004590:	58020000 	.word	0x58020000

24004594 <HAL_GPIO_ReadPin>:
  GPIO_PinState bitstatus;

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  if ((GPIOx->IDR & GPIO_Pin) != 0x00U)
24004594:	6903      	ldr	r3, [r0, #16]
24004596:	4219      	tst	r1, r3
  else
  {
    bitstatus = GPIO_PIN_RESET;
  }
  return bitstatus;
}
24004598:	bf14      	ite	ne
2400459a:	2001      	movne	r0, #1
2400459c:	2000      	moveq	r0, #0
2400459e:	4770      	bx	lr

240045a0 <HAL_GPIO_WritePin>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if (PinState != GPIO_PIN_RESET)
240045a0:	b10a      	cbz	r2, 240045a6 <HAL_GPIO_WritePin+0x6>
  {
    GPIOx->BSRR = GPIO_Pin;
  }
  else
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << GPIO_NUMBER;
240045a2:	6181      	str	r1, [r0, #24]
  }
}
240045a4:	4770      	bx	lr
    GPIOx->BSRR = (uint32_t)GPIO_Pin << GPIO_NUMBER;
240045a6:	0409      	lsls	r1, r1, #16
240045a8:	e7fb      	b.n	240045a2 <HAL_GPIO_WritePin+0x2>

240045aa <HAL_GPIO_TogglePin>:
void HAL_GPIO_TogglePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin)
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  if ((GPIOx->ODR & GPIO_Pin) == GPIO_Pin)
240045aa:	6943      	ldr	r3, [r0, #20]
240045ac:	ea31 0303 	bics.w	r3, r1, r3
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << GPIO_NUMBER;
240045b0:	bf08      	it	eq
240045b2:	0409      	lsleq	r1, r1, #16
  }
  else
  {
    GPIOx->BSRR = GPIO_Pin;
240045b4:	6181      	str	r1, [r0, #24]
  }
}
240045b6:	4770      	bx	lr

240045b8 <HAL_GPIO_LockPin>:
  * @param  GPIO_Pin: specifies the port bit to be locked.
  *         This parameter can be any combination of GPIO_PIN_x where x can be (0..15).
  * @retval None
  */
HAL_StatusTypeDef HAL_GPIO_LockPin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin)
{
240045b8:	b082      	sub	sp, #8
  __IO uint32_t tmp = GPIO_LCKR_LCKK;
240045ba:	f44f 3380 	mov.w	r3, #65536	@ 0x10000
240045be:	9301      	str	r3, [sp, #4]
  /* Check the parameters */
  assert_param(IS_GPIO_LOCK_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  /* Apply lock key write sequence */
  tmp |= GPIO_Pin;
240045c0:	9b01      	ldr	r3, [sp, #4]
240045c2:	430b      	orrs	r3, r1
240045c4:	9301      	str	r3, [sp, #4]
  /* Set LCKx bit(s): LCKK='1' + LCK[15-0] */
  GPIOx->LCKR = tmp;
240045c6:	9b01      	ldr	r3, [sp, #4]
240045c8:	61c3      	str	r3, [r0, #28]
  /* Reset LCKx bit(s): LCKK='0' + LCK[15-0] */
  GPIOx->LCKR = GPIO_Pin;
240045ca:	61c1      	str	r1, [r0, #28]
  /* Set LCKx bit(s): LCKK='1' + LCK[15-0] */
  GPIOx->LCKR = tmp;
240045cc:	9b01      	ldr	r3, [sp, #4]
240045ce:	61c3      	str	r3, [r0, #28]
  /* Read LCKK register. This read is mandatory to complete key lock sequence*/
  tmp = GPIOx->LCKR;
240045d0:	69c3      	ldr	r3, [r0, #28]
240045d2:	9301      	str	r3, [sp, #4]

  /* read again in order to confirm lock is active */
  if ((GPIOx->LCKR & GPIO_LCKR_LCKK) != 0x00U)
240045d4:	69c0      	ldr	r0, [r0, #28]
240045d6:	f480 3080 	eor.w	r0, r0, #65536	@ 0x10000
  }
  else
  {
    return HAL_ERROR;
  }
}
240045da:	f3c0 4000 	ubfx	r0, r0, #16, #1
240045de:	b002      	add	sp, #8
240045e0:	4770      	bx	lr

240045e2 <HAL_GPIO_EXTI_Callback>:
  UNUSED(GPIO_Pin);

  /* NOTE: This function Should not be modified, when the callback is needed,
           the HAL_GPIO_EXTI_Callback could be implemented in the user file
   */
}
240045e2:	4770      	bx	lr

240045e4 <HAL_GPIO_EXTI_IRQHandler>:
  if (__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != 0x00U)
240045e4:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
240045e8:	f8d2 1088 	ldr.w	r1, [r2, #136]	@ 0x88
240045ec:	4201      	tst	r1, r0
{
240045ee:	b508      	push	{r3, lr}
  if (__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != 0x00U)
240045f0:	d003      	beq.n	240045fa <HAL_GPIO_EXTI_IRQHandler+0x16>
    __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);
240045f2:	f8c2 0088 	str.w	r0, [r2, #136]	@ 0x88
    HAL_GPIO_EXTI_Callback(GPIO_Pin);
240045f6:	f7ff fff4 	bl	240045e2 <HAL_GPIO_EXTI_Callback>
}
240045fa:	bd08      	pop	{r3, pc}

240045fc <HAL_HSEM_Take>:
    /*take success when MasterID and ProcessID match and take bit set*/
    return HAL_OK;
  }
#else
  /* First step  write R register with MasterID, processID and take bit=1*/
  HSEM->R[SemID] = (ProcessID | HSEM_CR_COREID_CURRENT | HSEM_R_LOCK);
240045fc:	f041 4100 	orr.w	r1, r1, #2147483648	@ 0x80000000
24004600:	4b05      	ldr	r3, [pc, #20]	@ (24004618 <HAL_HSEM_Take+0x1c>)
24004602:	f441 7140 	orr.w	r1, r1, #768	@ 0x300
24004606:	f843 1020 	str.w	r1, [r3, r0, lsl #2]

  /* second step : read the R register . Take achieved if MasterID and processID match and take bit set to 1 */
  if (HSEM->R[SemID] == (ProcessID | HSEM_CR_COREID_CURRENT | HSEM_R_LOCK))
2400460a:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
  }
#endif

  /* Semaphore take fails*/
  return HAL_ERROR;
}
2400460e:	1a08      	subs	r0, r1, r0
24004610:	bf18      	it	ne
24004612:	2001      	movne	r0, #1
24004614:	4770      	bx	lr
24004616:	bf00      	nop
24004618:	58026400 	.word	0x58026400

2400461c <HAL_HSEM_FastTake>:
    /*take success when MasterID match and take bit set*/
    return HAL_OK;
  }
#else
  /* Read the RLR register to take the semaphore */
  if (HSEM->RLR[SemID] == (HSEM_CR_COREID_CURRENT | HSEM_RLR_LOCK))
2400461c:	4b04      	ldr	r3, [pc, #16]	@ (24004630 <HAL_HSEM_FastTake+0x14>)
2400461e:	3020      	adds	r0, #32
24004620:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
  }
#endif

  /* Semaphore take fails */
  return HAL_ERROR;
}
24004624:	4b03      	ldr	r3, [pc, #12]	@ (24004634 <HAL_HSEM_FastTake+0x18>)
24004626:	1ac0      	subs	r0, r0, r3
24004628:	bf18      	it	ne
2400462a:	2001      	movne	r0, #1
2400462c:	4770      	bx	lr
2400462e:	bf00      	nop
24004630:	58026400 	.word	0x58026400
24004634:	80000300 	.word	0x80000300

24004638 <HAL_HSEM_IsSemTaken>:
  * @param  SemID: semaphore ID
  * @retval HAL HSEM state
  */
uint32_t HAL_HSEM_IsSemTaken(uint32_t SemID)
{
  return (((HSEM->R[SemID] & HSEM_R_LOCK) != 0U) ? 1UL : 0UL);
24004638:	4b02      	ldr	r3, [pc, #8]	@ (24004644 <HAL_HSEM_IsSemTaken+0xc>)
2400463a:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
}
2400463e:	0fc0      	lsrs	r0, r0, #31
24004640:	4770      	bx	lr
24004642:	bf00      	nop
24004644:	58026400 	.word	0x58026400

24004648 <HAL_HSEM_Release>:

  /* Clear the semaphore by writing to the R register : the MasterID , the processID and take bit = 0  */
#if  USE_MULTI_CORE_SHARED_CODE != 0U
  HSEM->R[SemID] = (ProcessID | ((HAL_GetCurrentCPUID() << POSITION_VAL(HSEM_R_MASTERID)) & HSEM_R_MASTERID));
#else
  HSEM->R[SemID] = (ProcessID | HSEM_CR_COREID_CURRENT);
24004648:	f441 7140 	orr.w	r1, r1, #768	@ 0x300
2400464c:	4b01      	ldr	r3, [pc, #4]	@ (24004654 <HAL_HSEM_Release+0xc>)
2400464e:	f843 1020 	str.w	r1, [r3, r0, lsl #2]
#endif

}
24004652:	4770      	bx	lr
24004654:	58026400 	.word	0x58026400

24004658 <HAL_HSEM_ReleaseAll>:
void HAL_HSEM_ReleaseAll(uint32_t Key, uint32_t CoreID)
{
  assert_param(IS_HSEM_KEY(Key));
  assert_param(IS_HSEM_COREID(CoreID));

  HSEM->CR = ((Key << HSEM_CR_KEY_Pos) | (CoreID << HSEM_CR_COREID_Pos));
24004658:	0209      	lsls	r1, r1, #8
2400465a:	4b03      	ldr	r3, [pc, #12]	@ (24004668 <HAL_HSEM_ReleaseAll+0x10>)
2400465c:	ea41 4100 	orr.w	r1, r1, r0, lsl #16
24004660:	f8c3 1140 	str.w	r1, [r3, #320]	@ 0x140
}
24004664:	4770      	bx	lr
24004666:	bf00      	nop
24004668:	58026400 	.word	0x58026400

2400466c <HAL_HSEM_SetClearKey>:
  */
void  HAL_HSEM_SetClearKey(uint32_t Key)
{
  assert_param(IS_HSEM_KEY(Key));

  MODIFY_REG(HSEM->KEYR, HSEM_KEYR_KEY, (Key << HSEM_KEYR_KEY_Pos));
2400466c:	4a04      	ldr	r2, [pc, #16]	@ (24004680 <HAL_HSEM_SetClearKey+0x14>)
2400466e:	f8d2 3144 	ldr.w	r3, [r2, #324]	@ 0x144
24004672:	b29b      	uxth	r3, r3
24004674:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
24004678:	f8c2 3144 	str.w	r3, [r2, #324]	@ 0x144

}
2400467c:	4770      	bx	lr
2400467e:	bf00      	nop
24004680:	58026400 	.word	0x58026400

24004684 <HAL_HSEM_GetClearKey>:
  * @brief  Get semaphore Key .
  * @retval Semaphore Key , value from 0 to 0xFFFF
  */
uint32_t HAL_HSEM_GetClearKey(void)
{
  return (HSEM->KEYR >> HSEM_KEYR_KEY_Pos);
24004684:	4b02      	ldr	r3, [pc, #8]	@ (24004690 <HAL_HSEM_GetClearKey+0xc>)
24004686:	f8d3 0144 	ldr.w	r0, [r3, #324]	@ 0x144
}
2400468a:	0c00      	lsrs	r0, r0, #16
2400468c:	4770      	bx	lr
2400468e:	bf00      	nop
24004690:	58026400 	.word	0x58026400

24004694 <HAL_HSEM_ActivateNotification>:
  {
    /*Use interrupt line 1 for CPU2 Master*/
    HSEM->C2IER |= SemMask;
  }
#else
  HSEM_COMMON->IER |= SemMask;
24004694:	4a02      	ldr	r2, [pc, #8]	@ (240046a0 <HAL_HSEM_ActivateNotification+0xc>)
24004696:	6813      	ldr	r3, [r2, #0]
24004698:	4303      	orrs	r3, r0
2400469a:	6013      	str	r3, [r2, #0]
#endif
}
2400469c:	4770      	bx	lr
2400469e:	bf00      	nop
240046a0:	58026500 	.word	0x58026500

240046a4 <HAL_HSEM_DeactivateNotification>:
  {
    /*Use interrupt line 1 for CPU2 Master*/
    HSEM->C2IER &= ~SemMask;
  }
#else
  HSEM_COMMON->IER &= ~SemMask;
240046a4:	4a02      	ldr	r2, [pc, #8]	@ (240046b0 <HAL_HSEM_DeactivateNotification+0xc>)
240046a6:	6813      	ldr	r3, [r2, #0]
240046a8:	ea23 0300 	bic.w	r3, r3, r0
240046ac:	6013      	str	r3, [r2, #0]
#endif
}
240046ae:	4770      	bx	lr
240046b0:	58026500 	.word	0x58026500

240046b4 <HAL_HSEM_FreeCallback>:
  UNUSED(SemMask);

  /* NOTE : This function should not be modified, when the callback is needed,
  the HAL_HSEM_FreeCallback can be implemented in the user file
    */
}
240046b4:	4770      	bx	lr

240046b6 <HAL_HSEM_IRQHandler>:
{
240046b6:	b508      	push	{r3, lr}
  statusreg = HSEM_COMMON->MISR;
240046b8:	4b04      	ldr	r3, [pc, #16]	@ (240046cc <HAL_HSEM_IRQHandler+0x16>)
240046ba:	68d8      	ldr	r0, [r3, #12]
  HSEM_COMMON->IER &= ~((uint32_t)statusreg);
240046bc:	681a      	ldr	r2, [r3, #0]
240046be:	ea22 0200 	bic.w	r2, r2, r0
240046c2:	601a      	str	r2, [r3, #0]
  HSEM_COMMON->ICR = ((uint32_t)statusreg);
240046c4:	6058      	str	r0, [r3, #4]
  HAL_HSEM_FreeCallback(statusreg);
240046c6:	f7ff fff5 	bl	240046b4 <HAL_HSEM_FreeCallback>
}
240046ca:	bd08      	pop	{r3, pc}
240046cc:	58026500 	.word	0x58026500

240046d0 <I2C_Flush_TXDR>:
  */
static void I2C_Flush_TXDR(I2C_HandleTypeDef *hi2c)
{
  /* If a pending TXIS flag is set */
  /* Write a dummy data in TXDR to clear it */
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
240046d0:	6803      	ldr	r3, [r0, #0]
240046d2:	699a      	ldr	r2, [r3, #24]
240046d4:	0791      	lsls	r1, r2, #30
240046d6:	d501      	bpl.n	240046dc <I2C_Flush_TXDR+0xc>
  {
    hi2c->Instance->TXDR = 0x00U;
240046d8:	2200      	movs	r2, #0
240046da:	629a      	str	r2, [r3, #40]	@ 0x28
  }

  /* Flush TX register if not empty */
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
240046dc:	699a      	ldr	r2, [r3, #24]
240046de:	07d2      	lsls	r2, r2, #31
240046e0:	d403      	bmi.n	240046ea <I2C_Flush_TXDR+0x1a>
  {
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
240046e2:	699a      	ldr	r2, [r3, #24]
240046e4:	f042 0201 	orr.w	r2, r2, #1
240046e8:	619a      	str	r2, [r3, #24]
  }
}
240046ea:	4770      	bx	lr

240046ec <I2C_TransferConfig>:
  *     @arg @ref I2C_GENERATE_START_READ Generate Restart for read request.
  *     @arg @ref I2C_GENERATE_START_WRITE Generate Restart for write request.
  * @retval None
  */
static void I2C_TransferConfig(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t Size, uint32_t Mode, uint32_t Request)
{
240046ec:	b530      	push	{r4, r5, lr}
240046ee:	9d03      	ldr	r5, [sp, #12]
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));

  /* update CR2 register */
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
240046f0:	f3c1 0109 	ubfx	r1, r1, #0, #10
240046f4:	6804      	ldr	r4, [r0, #0]
240046f6:	ea45 4202 	orr.w	r2, r5, r2, lsl #16
240046fa:	6860      	ldr	r0, [r4, #4]
240046fc:	431a      	orrs	r2, r3
240046fe:	4b04      	ldr	r3, [pc, #16]	@ (24004710 <I2C_TransferConfig+0x24>)
24004700:	ea43 5355 	orr.w	r3, r3, r5, lsr #21
24004704:	430a      	orrs	r2, r1
24004706:	ea20 0003 	bic.w	r0, r0, r3
2400470a:	4302      	orrs	r2, r0
2400470c:	6062      	str	r2, [r4, #4]
             (uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | (((uint32_t)Size << I2C_CR2_NBYTES_Pos) & I2C_CR2_NBYTES) | (uint32_t)Mode | (uint32_t)Request));
}
2400470e:	bd30      	pop	{r4, r5, pc}
24004710:	03ff63ff 	.word	0x03ff63ff

24004714 <I2C_Enable_IRQ>:
  */
static void I2C_Enable_IRQ(I2C_HandleTypeDef *hi2c, uint16_t InterruptRequest)
{
  uint32_t tmpisr = 0U;

  if ((hi2c->XferISR == I2C_Master_ISR_DMA) || \
24004714:	6b42      	ldr	r2, [r0, #52]	@ 0x34
      tmpisr |= I2C_IT_TCI;
    }
  }
  else
  {
    if ((InterruptRequest & I2C_XFER_LISTEN_IT) == I2C_XFER_LISTEN_IT)
24004716:	b20b      	sxth	r3, r1
{
24004718:	b510      	push	{r4, lr}
  if ((hi2c->XferISR == I2C_Master_ISR_DMA) || \
2400471a:	4c17      	ldr	r4, [pc, #92]	@ (24004778 <I2C_Enable_IRQ+0x64>)
2400471c:	42a2      	cmp	r2, r4
2400471e:	d002      	beq.n	24004726 <I2C_Enable_IRQ+0x12>
24004720:	4c16      	ldr	r4, [pc, #88]	@ (2400477c <I2C_Enable_IRQ+0x68>)
24004722:	42a2      	cmp	r2, r4
24004724:	d111      	bne.n	2400474a <I2C_Enable_IRQ+0x36>
    if ((InterruptRequest & I2C_XFER_LISTEN_IT) == I2C_XFER_LISTEN_IT)
24004726:	2b00      	cmp	r3, #0
24004728:	db20      	blt.n	2400476c <I2C_Enable_IRQ+0x58>
    if (InterruptRequest == I2C_XFER_ERROR_IT)
2400472a:	2910      	cmp	r1, #16
2400472c:	d020      	beq.n	24004770 <I2C_Enable_IRQ+0x5c>
    if (InterruptRequest == I2C_XFER_CPLT_IT)
2400472e:	2920      	cmp	r1, #32
24004730:	d020      	beq.n	24004774 <I2C_Enable_IRQ+0x60>
    if (InterruptRequest == I2C_XFER_RELOAD_IT)
24004732:	f1a1 0c40 	sub.w	ip, r1, #64	@ 0x40
24004736:	f1dc 0100 	rsbs	r1, ip, #0
2400473a:	eb41 010c 	adc.w	r1, r1, ip
2400473e:	018b      	lsls	r3, r1, #6
  }

  /* Enable interrupts only at the end */
  /* to avoid the risk of I2C interrupt handle execution before */
  /* all interrupts requested done */
  __HAL_I2C_ENABLE_IT(hi2c, tmpisr);
24004740:	6801      	ldr	r1, [r0, #0]
24004742:	680a      	ldr	r2, [r1, #0]
24004744:	4313      	orrs	r3, r2
24004746:	600b      	str	r3, [r1, #0]
}
24004748:	bd10      	pop	{r4, pc}
      tmpisr |= I2C_IT_ADDRI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_ERRI;
2400474a:	2b00      	cmp	r3, #0
2400474c:	bfac      	ite	ge
2400474e:	2300      	movge	r3, #0
24004750:	23b8      	movlt	r3, #184	@ 0xb8
    if ((InterruptRequest & I2C_XFER_TX_IT) == I2C_XFER_TX_IT)
24004752:	07cc      	lsls	r4, r1, #31
      tmpisr |= I2C_IT_ERRI | I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_TXI;
24004754:	bf48      	it	mi
24004756:	f043 03f2 	orrmi.w	r3, r3, #242	@ 0xf2
    if ((InterruptRequest & I2C_XFER_RX_IT) == I2C_XFER_RX_IT)
2400475a:	078a      	lsls	r2, r1, #30
      tmpisr |= I2C_IT_ERRI | I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_RXI;
2400475c:	bf48      	it	mi
2400475e:	f043 03f4 	orrmi.w	r3, r3, #244	@ 0xf4
    if (InterruptRequest == I2C_XFER_CPLT_IT)
24004762:	2920      	cmp	r1, #32
24004764:	d1ec      	bne.n	24004740 <I2C_Enable_IRQ+0x2c>
      tmpisr |= I2C_IT_STOPI;
24004766:	f043 0320 	orr.w	r3, r3, #32
2400476a:	e7e9      	b.n	24004740 <I2C_Enable_IRQ+0x2c>
      tmpisr |= I2C_IT_ADDRI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_ERRI;
2400476c:	23b8      	movs	r3, #184	@ 0xb8
2400476e:	e7e7      	b.n	24004740 <I2C_Enable_IRQ+0x2c>
      tmpisr |= I2C_IT_ERRI | I2C_IT_NACKI;
24004770:	2390      	movs	r3, #144	@ 0x90
24004772:	e7e5      	b.n	24004740 <I2C_Enable_IRQ+0x2c>
      tmpisr |= (I2C_IT_STOPI | I2C_IT_TCI);
24004774:	2360      	movs	r3, #96	@ 0x60
24004776:	e7e3      	b.n	24004740 <I2C_Enable_IRQ+0x2c>
24004778:	24006c71 	.word	0x24006c71
2400477c:	240070c9 	.word	0x240070c9

24004780 <I2C_Disable_IRQ>:
  */
static void I2C_Disable_IRQ(I2C_HandleTypeDef *hi2c, uint16_t InterruptRequest)
{
  uint32_t tmpisr = 0U;

  if ((InterruptRequest & I2C_XFER_TX_IT) == I2C_XFER_TX_IT)
24004780:	f011 0301 	ands.w	r3, r1, #1
24004784:	d007      	beq.n	24004796 <I2C_Disable_IRQ+0x16>
  {
    /* Disable TC and TXI interrupts */
    tmpisr |= I2C_IT_TCI | I2C_IT_TXI;

    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
24004786:	f890 3041 	ldrb.w	r3, [r0, #65]	@ 0x41
2400478a:	f003 0328 	and.w	r3, r3, #40	@ 0x28
    tmpisr |= I2C_IT_TCI | I2C_IT_TXI;
2400478e:	2b28      	cmp	r3, #40	@ 0x28
24004790:	bf14      	ite	ne
24004792:	23f2      	movne	r3, #242	@ 0xf2
24004794:	2342      	moveq	r3, #66	@ 0x42
      /* Disable NACK and STOP interrupts */
      tmpisr |= I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_ERRI;
    }
  }

  if ((InterruptRequest & I2C_XFER_RX_IT) == I2C_XFER_RX_IT)
24004796:	078a      	lsls	r2, r1, #30
24004798:	d509      	bpl.n	240047ae <I2C_Disable_IRQ+0x2e>
  {
    /* Disable TC and RXI interrupts */
    tmpisr |= I2C_IT_TCI | I2C_IT_RXI;

    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
2400479a:	f890 2041 	ldrb.w	r2, [r0, #65]	@ 0x41
2400479e:	f002 0228 	and.w	r2, r2, #40	@ 0x28
240047a2:	2a28      	cmp	r2, #40	@ 0x28
    tmpisr |= I2C_IT_TCI | I2C_IT_RXI;
240047a4:	bf0c      	ite	eq
240047a6:	f043 0344 	orreq.w	r3, r3, #68	@ 0x44
    {
      /* Disable NACK and STOP interrupts */
      tmpisr |= I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_ERRI;
240047aa:	f043 03f4 	orrne.w	r3, r3, #244	@ 0xf4
    }
  }

  if ((InterruptRequest & I2C_XFER_LISTEN_IT) == I2C_XFER_LISTEN_IT)
240047ae:	040a      	lsls	r2, r1, #16
  }

  /* Disable interrupts only at the end */
  /* to avoid a breaking situation like at "t" time */
  /* all disable interrupts request are not done */
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
240047b0:	6801      	ldr	r1, [r0, #0]
    tmpisr |= I2C_IT_ADDRI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_ERRI;
240047b2:	bf48      	it	mi
240047b4:	f043 03b8 	orrmi.w	r3, r3, #184	@ 0xb8
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
240047b8:	680a      	ldr	r2, [r1, #0]
240047ba:	ea22 0303 	bic.w	r3, r2, r3
240047be:	600b      	str	r3, [r1, #0]
}
240047c0:	4770      	bx	lr

240047c2 <I2C_ConvertOtherXferOptions>:
static void I2C_ConvertOtherXferOptions(I2C_HandleTypeDef *hi2c)
{
  /* if user set XferOptions to I2C_OTHER_FRAME            */
  /* it request implicitly to generate a restart condition */
  /* set XferOptions to I2C_FIRST_FRAME                    */
  if (hi2c->XferOptions == I2C_OTHER_FRAME)
240047c2:	6ac3      	ldr	r3, [r0, #44]	@ 0x2c
240047c4:	2baa      	cmp	r3, #170	@ 0xaa
240047c6:	d102      	bne.n	240047ce <I2C_ConvertOtherXferOptions+0xc>
  {
    hi2c->XferOptions = I2C_FIRST_FRAME;
240047c8:	2300      	movs	r3, #0
  /* it request implicitly to generate a restart condition    */
  /* then generate a stop condition at the end of transfer    */
  /* set XferOptions to I2C_FIRST_AND_LAST_FRAME              */
  else if (hi2c->XferOptions == I2C_OTHER_AND_LAST_FRAME)
  {
    hi2c->XferOptions = I2C_FIRST_AND_LAST_FRAME;
240047ca:	62c3      	str	r3, [r0, #44]	@ 0x2c
  }
  else
  {
    /* Nothing to do */
  }
}
240047cc:	4770      	bx	lr
  else if (hi2c->XferOptions == I2C_OTHER_AND_LAST_FRAME)
240047ce:	6ac3      	ldr	r3, [r0, #44]	@ 0x2c
240047d0:	f5b3 4f2a 	cmp.w	r3, #43520	@ 0xaa00
240047d4:	d1fa      	bne.n	240047cc <I2C_ConvertOtherXferOptions+0xa>
    hi2c->XferOptions = I2C_FIRST_AND_LAST_FRAME;
240047d6:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
240047da:	e7f6      	b.n	240047ca <I2C_ConvertOtherXferOptions+0x8>

240047dc <I2C_IsAcknowledgeFailed>:
{
240047dc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
240047de:	6803      	ldr	r3, [r0, #0]
{
240047e0:	4604      	mov	r4, r0
240047e2:	460e      	mov	r6, r1
240047e4:	4617      	mov	r7, r2
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
240047e6:	6998      	ldr	r0, [r3, #24]
240047e8:	f010 0010 	ands.w	r0, r0, #16
240047ec:	d117      	bne.n	2400481e <I2C_IsAcknowledgeFailed+0x42>
}
240047ee:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      if (Timeout != HAL_MAX_DELAY)
240047f0:	1c72      	adds	r2, r6, #1
240047f2:	d015      	beq.n	24004820 <I2C_IsAcknowledgeFailed+0x44>
        if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
240047f4:	f00d fb08 	bl	24011e08 <HAL_GetTick>
240047f8:	1bc0      	subs	r0, r0, r7
240047fa:	4286      	cmp	r6, r0
240047fc:	d300      	bcc.n	24004800 <I2C_IsAcknowledgeFailed+0x24>
240047fe:	b976      	cbnz	r6, 2400481e <I2C_IsAcknowledgeFailed+0x42>
          hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
24004800:	6c63      	ldr	r3, [r4, #68]	@ 0x44
24004802:	f043 0320 	orr.w	r3, r3, #32
24004806:	6463      	str	r3, [r4, #68]	@ 0x44
          hi2c->State = HAL_I2C_STATE_READY;
24004808:	2320      	movs	r3, #32
2400480a:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
    hi2c->Mode = HAL_I2C_MODE_NONE;
2400480e:	2300      	movs	r3, #0
    __HAL_UNLOCK(hi2c);
24004810:	2001      	movs	r0, #1
    hi2c->Mode = HAL_I2C_MODE_NONE;
24004812:	f884 3042 	strb.w	r3, [r4, #66]	@ 0x42
    __HAL_UNLOCK(hi2c);
24004816:	2300      	movs	r3, #0
24004818:	f884 3040 	strb.w	r3, [r4, #64]	@ 0x40
2400481c:	e7e7      	b.n	240047ee <I2C_IsAcknowledgeFailed+0x12>
    while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
2400481e:	6825      	ldr	r5, [r4, #0]
24004820:	69ab      	ldr	r3, [r5, #24]
24004822:	069b      	lsls	r3, r3, #26
24004824:	d5e4      	bpl.n	240047f0 <I2C_IsAcknowledgeFailed+0x14>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
24004826:	2310      	movs	r3, #16
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
24004828:	2620      	movs	r6, #32
    I2C_Flush_TXDR(hi2c);
2400482a:	4620      	mov	r0, r4
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
2400482c:	61eb      	str	r3, [r5, #28]
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
2400482e:	61ee      	str	r6, [r5, #28]
    I2C_Flush_TXDR(hi2c);
24004830:	f7ff ff4e 	bl	240046d0 <I2C_Flush_TXDR>
    I2C_RESET_CR2(hi2c);
24004834:	686b      	ldr	r3, [r5, #4]
24004836:	f023 73ff 	bic.w	r3, r3, #33423360	@ 0x1fe0000
2400483a:	f423 338b 	bic.w	r3, r3, #71168	@ 0x11600
2400483e:	f423 73ff 	bic.w	r3, r3, #510	@ 0x1fe
24004842:	f023 0301 	bic.w	r3, r3, #1
24004846:	606b      	str	r3, [r5, #4]
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
24004848:	6c63      	ldr	r3, [r4, #68]	@ 0x44
2400484a:	f043 0304 	orr.w	r3, r3, #4
2400484e:	6463      	str	r3, [r4, #68]	@ 0x44
    hi2c->State = HAL_I2C_STATE_READY;
24004850:	f884 6041 	strb.w	r6, [r4, #65]	@ 0x41
24004854:	e7db      	b.n	2400480e <I2C_IsAcknowledgeFailed+0x32>

24004856 <I2C_WaitOnTXISFlagUntilTimeout>:
{
24004856:	b570      	push	{r4, r5, r6, lr}
24004858:	4604      	mov	r4, r0
2400485a:	460d      	mov	r5, r1
2400485c:	4616      	mov	r6, r2
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
2400485e:	6823      	ldr	r3, [r4, #0]
24004860:	699b      	ldr	r3, [r3, #24]
24004862:	079b      	lsls	r3, r3, #30
24004864:	d501      	bpl.n	2400486a <I2C_WaitOnTXISFlagUntilTimeout+0x14>
  return HAL_OK;
24004866:	2000      	movs	r0, #0
24004868:	e01b      	b.n	240048a2 <I2C_WaitOnTXISFlagUntilTimeout+0x4c>
    if (I2C_IsAcknowledgeFailed(hi2c, Timeout, Tickstart) != HAL_OK)
2400486a:	4632      	mov	r2, r6
2400486c:	4629      	mov	r1, r5
2400486e:	4620      	mov	r0, r4
24004870:	f7ff ffb4 	bl	240047dc <I2C_IsAcknowledgeFailed>
24004874:	b9a0      	cbnz	r0, 240048a0 <I2C_WaitOnTXISFlagUntilTimeout+0x4a>
    if (Timeout != HAL_MAX_DELAY)
24004876:	1c6a      	adds	r2, r5, #1
24004878:	d0f1      	beq.n	2400485e <I2C_WaitOnTXISFlagUntilTimeout+0x8>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
2400487a:	f00d fac5 	bl	24011e08 <HAL_GetTick>
2400487e:	1b80      	subs	r0, r0, r6
24004880:	42a8      	cmp	r0, r5
24004882:	d801      	bhi.n	24004888 <I2C_WaitOnTXISFlagUntilTimeout+0x32>
24004884:	2d00      	cmp	r5, #0
24004886:	d1ea      	bne.n	2400485e <I2C_WaitOnTXISFlagUntilTimeout+0x8>
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
24004888:	6c63      	ldr	r3, [r4, #68]	@ 0x44
2400488a:	f043 0320 	orr.w	r3, r3, #32
2400488e:	6463      	str	r3, [r4, #68]	@ 0x44
        hi2c->State = HAL_I2C_STATE_READY;
24004890:	2320      	movs	r3, #32
24004892:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
        hi2c->Mode = HAL_I2C_MODE_NONE;
24004896:	2300      	movs	r3, #0
24004898:	f884 3042 	strb.w	r3, [r4, #66]	@ 0x42
        __HAL_UNLOCK(hi2c);
2400489c:	f884 3040 	strb.w	r3, [r4, #64]	@ 0x40
      return HAL_ERROR;
240048a0:	2001      	movs	r0, #1
}
240048a2:	bd70      	pop	{r4, r5, r6, pc}

240048a4 <I2C_WaitOnSTOPFlagUntilTimeout>:
{
240048a4:	b570      	push	{r4, r5, r6, lr}
240048a6:	4604      	mov	r4, r0
240048a8:	460d      	mov	r5, r1
240048aa:	4616      	mov	r6, r2
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
240048ac:	6823      	ldr	r3, [r4, #0]
240048ae:	699b      	ldr	r3, [r3, #24]
240048b0:	069b      	lsls	r3, r3, #26
240048b2:	d501      	bpl.n	240048b8 <I2C_WaitOnSTOPFlagUntilTimeout+0x14>
  return HAL_OK;
240048b4:	2000      	movs	r0, #0
240048b6:	e019      	b.n	240048ec <I2C_WaitOnSTOPFlagUntilTimeout+0x48>
    if (I2C_IsAcknowledgeFailed(hi2c, Timeout, Tickstart) != HAL_OK)
240048b8:	4632      	mov	r2, r6
240048ba:	4629      	mov	r1, r5
240048bc:	4620      	mov	r0, r4
240048be:	f7ff ff8d 	bl	240047dc <I2C_IsAcknowledgeFailed>
240048c2:	b990      	cbnz	r0, 240048ea <I2C_WaitOnSTOPFlagUntilTimeout+0x46>
    if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
240048c4:	f00d faa0 	bl	24011e08 <HAL_GetTick>
240048c8:	1b80      	subs	r0, r0, r6
240048ca:	42a8      	cmp	r0, r5
240048cc:	d801      	bhi.n	240048d2 <I2C_WaitOnSTOPFlagUntilTimeout+0x2e>
240048ce:	2d00      	cmp	r5, #0
240048d0:	d1ec      	bne.n	240048ac <I2C_WaitOnSTOPFlagUntilTimeout+0x8>
      hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
240048d2:	6c63      	ldr	r3, [r4, #68]	@ 0x44
240048d4:	f043 0320 	orr.w	r3, r3, #32
240048d8:	6463      	str	r3, [r4, #68]	@ 0x44
      hi2c->State = HAL_I2C_STATE_READY;
240048da:	2320      	movs	r3, #32
240048dc:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
      hi2c->Mode = HAL_I2C_MODE_NONE;
240048e0:	2300      	movs	r3, #0
240048e2:	f884 3042 	strb.w	r3, [r4, #66]	@ 0x42
      __HAL_UNLOCK(hi2c);
240048e6:	f884 3040 	strb.w	r3, [r4, #64]	@ 0x40
      return HAL_ERROR;
240048ea:	2001      	movs	r0, #1
}
240048ec:	bd70      	pop	{r4, r5, r6, pc}

240048ee <I2C_WaitOnRXNEFlagUntilTimeout>:
{
240048ee:	b570      	push	{r4, r5, r6, lr}
240048f0:	4604      	mov	r4, r0
240048f2:	460d      	mov	r5, r1
240048f4:	4616      	mov	r6, r2
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == RESET)
240048f6:	6823      	ldr	r3, [r4, #0]
240048f8:	699b      	ldr	r3, [r3, #24]
240048fa:	075b      	lsls	r3, r3, #29
240048fc:	d40e      	bmi.n	2400491c <I2C_WaitOnRXNEFlagUntilTimeout+0x2e>
    if (I2C_IsAcknowledgeFailed(hi2c, Timeout, Tickstart) != HAL_OK)
240048fe:	4632      	mov	r2, r6
24004900:	4629      	mov	r1, r5
24004902:	4620      	mov	r0, r4
24004904:	f7ff ff6a 	bl	240047dc <I2C_IsAcknowledgeFailed>
24004908:	b9f0      	cbnz	r0, 24004948 <I2C_WaitOnRXNEFlagUntilTimeout+0x5a>
    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == SET)
2400490a:	6823      	ldr	r3, [r4, #0]
2400490c:	699a      	ldr	r2, [r3, #24]
2400490e:	0691      	lsls	r1, r2, #26
24004910:	d51c      	bpl.n	2400494c <I2C_WaitOnRXNEFlagUntilTimeout+0x5e>
      if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET) && (hi2c->XferSize > 0U))
24004912:	699a      	ldr	r2, [r3, #24]
24004914:	0752      	lsls	r2, r2, #29
24004916:	d503      	bpl.n	24004920 <I2C_WaitOnRXNEFlagUntilTimeout+0x32>
24004918:	8d22      	ldrh	r2, [r4, #40]	@ 0x28
2400491a:	b10a      	cbz	r2, 24004920 <I2C_WaitOnRXNEFlagUntilTimeout+0x32>
        return HAL_OK;
2400491c:	2000      	movs	r0, #0
}
2400491e:	bd70      	pop	{r4, r5, r6, pc}
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
24004920:	2120      	movs	r1, #32
24004922:	61d9      	str	r1, [r3, #28]
        I2C_RESET_CR2(hi2c);
24004924:	685a      	ldr	r2, [r3, #4]
24004926:	f022 72ff 	bic.w	r2, r2, #33423360	@ 0x1fe0000
2400492a:	f422 328b 	bic.w	r2, r2, #71168	@ 0x11600
2400492e:	f422 72ff 	bic.w	r2, r2, #510	@ 0x1fe
24004932:	f022 0201 	bic.w	r2, r2, #1
24004936:	605a      	str	r2, [r3, #4]
        hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
24004938:	2300      	movs	r3, #0
2400493a:	6463      	str	r3, [r4, #68]	@ 0x44
        hi2c->State = HAL_I2C_STATE_READY;
2400493c:	f884 1041 	strb.w	r1, [r4, #65]	@ 0x41
        hi2c->Mode = HAL_I2C_MODE_NONE;
24004940:	f884 3042 	strb.w	r3, [r4, #66]	@ 0x42
      __HAL_UNLOCK(hi2c);
24004944:	f884 3040 	strb.w	r3, [r4, #64]	@ 0x40
      return HAL_ERROR;
24004948:	2001      	movs	r0, #1
2400494a:	e7e8      	b.n	2400491e <I2C_WaitOnRXNEFlagUntilTimeout+0x30>
    if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
2400494c:	f00d fa5c 	bl	24011e08 <HAL_GetTick>
24004950:	1b80      	subs	r0, r0, r6
24004952:	42a8      	cmp	r0, r5
24004954:	d801      	bhi.n	2400495a <I2C_WaitOnRXNEFlagUntilTimeout+0x6c>
24004956:	2d00      	cmp	r5, #0
24004958:	d1cd      	bne.n	240048f6 <I2C_WaitOnRXNEFlagUntilTimeout+0x8>
      hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
2400495a:	6c63      	ldr	r3, [r4, #68]	@ 0x44
2400495c:	f043 0320 	orr.w	r3, r3, #32
24004960:	6463      	str	r3, [r4, #68]	@ 0x44
      hi2c->State = HAL_I2C_STATE_READY;
24004962:	2320      	movs	r3, #32
24004964:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
      __HAL_UNLOCK(hi2c);
24004968:	2300      	movs	r3, #0
2400496a:	e7eb      	b.n	24004944 <I2C_WaitOnRXNEFlagUntilTimeout+0x56>

2400496c <I2C_WaitOnFlagUntilTimeout>:
{
2400496c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
24004970:	9f06      	ldr	r7, [sp, #24]
24004972:	4604      	mov	r4, r0
24004974:	4688      	mov	r8, r1
24004976:	4616      	mov	r6, r2
24004978:	461d      	mov	r5, r3
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
2400497a:	6822      	ldr	r2, [r4, #0]
2400497c:	6993      	ldr	r3, [r2, #24]
2400497e:	ea38 0303 	bics.w	r3, r8, r3
24004982:	bf0c      	ite	eq
24004984:	2301      	moveq	r3, #1
24004986:	2300      	movne	r3, #0
24004988:	42b3      	cmp	r3, r6
2400498a:	d001      	beq.n	24004990 <I2C_WaitOnFlagUntilTimeout+0x24>
  return HAL_OK;
2400498c:	2000      	movs	r0, #0
2400498e:	e015      	b.n	240049bc <I2C_WaitOnFlagUntilTimeout+0x50>
    if (Timeout != HAL_MAX_DELAY)
24004990:	1c6b      	adds	r3, r5, #1
24004992:	d0f3      	beq.n	2400497c <I2C_WaitOnFlagUntilTimeout+0x10>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
24004994:	f00d fa38 	bl	24011e08 <HAL_GetTick>
24004998:	1bc0      	subs	r0, r0, r7
2400499a:	42a8      	cmp	r0, r5
2400499c:	d801      	bhi.n	240049a2 <I2C_WaitOnFlagUntilTimeout+0x36>
2400499e:	2d00      	cmp	r5, #0
240049a0:	d1eb      	bne.n	2400497a <I2C_WaitOnFlagUntilTimeout+0xe>
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
240049a2:	6c63      	ldr	r3, [r4, #68]	@ 0x44
        __HAL_UNLOCK(hi2c);
240049a4:	2001      	movs	r0, #1
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
240049a6:	f043 0320 	orr.w	r3, r3, #32
240049aa:	6463      	str	r3, [r4, #68]	@ 0x44
        hi2c->State = HAL_I2C_STATE_READY;
240049ac:	2320      	movs	r3, #32
240049ae:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
        hi2c->Mode = HAL_I2C_MODE_NONE;
240049b2:	2300      	movs	r3, #0
240049b4:	f884 3042 	strb.w	r3, [r4, #66]	@ 0x42
        __HAL_UNLOCK(hi2c);
240049b8:	f884 3040 	strb.w	r3, [r4, #64]	@ 0x40
}
240049bc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

240049c0 <I2C_RequestMemoryWrite>:
{
240049c0:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
240049c4:	461e      	mov	r6, r3
  I2C_TransferConfig(hi2c, DevAddress, (uint8_t)MemAddSize, I2C_RELOAD_MODE, I2C_GENERATE_START_WRITE);
240049c6:	4b18      	ldr	r3, [pc, #96]	@ (24004a28 <I2C_RequestMemoryWrite+0x68>)
{
240049c8:	4605      	mov	r5, r0
240049ca:	4614      	mov	r4, r2
  I2C_TransferConfig(hi2c, DevAddress, (uint8_t)MemAddSize, I2C_RELOAD_MODE, I2C_GENERATE_START_WRITE);
240049cc:	9300      	str	r3, [sp, #0]
240049ce:	b2f2      	uxtb	r2, r6
240049d0:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
{
240049d4:	e9dd 7808 	ldrd	r7, r8, [sp, #32]
  I2C_TransferConfig(hi2c, DevAddress, (uint8_t)MemAddSize, I2C_RELOAD_MODE, I2C_GENERATE_START_WRITE);
240049d8:	f7ff fe88 	bl	240046ec <I2C_TransferConfig>
  if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
240049dc:	4628      	mov	r0, r5
240049de:	4642      	mov	r2, r8
240049e0:	4639      	mov	r1, r7
240049e2:	f7ff ff38 	bl	24004856 <I2C_WaitOnTXISFlagUntilTimeout>
240049e6:	b118      	cbz	r0, 240049f0 <I2C_RequestMemoryWrite+0x30>
    return HAL_ERROR;
240049e8:	2001      	movs	r0, #1
}
240049ea:	b002      	add	sp, #8
240049ec:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
240049f0:	2e01      	cmp	r6, #1
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
240049f2:	682b      	ldr	r3, [r5, #0]
  if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
240049f4:	d10d      	bne.n	24004a12 <I2C_RequestMemoryWrite+0x52>
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
240049f6:	b2e4      	uxtb	r4, r4
  if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, Tickstart) != HAL_OK)
240049f8:	2200      	movs	r2, #0
240049fa:	2180      	movs	r1, #128	@ 0x80
240049fc:	4628      	mov	r0, r5
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
240049fe:	629c      	str	r4, [r3, #40]	@ 0x28
  if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, Tickstart) != HAL_OK)
24004a00:	463b      	mov	r3, r7
24004a02:	f8cd 8000 	str.w	r8, [sp]
24004a06:	f7ff ffb1 	bl	2400496c <I2C_WaitOnFlagUntilTimeout>
24004a0a:	3800      	subs	r0, #0
24004a0c:	bf18      	it	ne
24004a0e:	2001      	movne	r0, #1
24004a10:	e7eb      	b.n	240049ea <I2C_RequestMemoryWrite+0x2a>
    hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);
24004a12:	0a22      	lsrs	r2, r4, #8
    if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
24004a14:	4639      	mov	r1, r7
24004a16:	4628      	mov	r0, r5
    hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);
24004a18:	629a      	str	r2, [r3, #40]	@ 0x28
    if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
24004a1a:	4642      	mov	r2, r8
24004a1c:	f7ff ff1b 	bl	24004856 <I2C_WaitOnTXISFlagUntilTimeout>
24004a20:	2800      	cmp	r0, #0
24004a22:	d1e1      	bne.n	240049e8 <I2C_RequestMemoryWrite+0x28>
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
24004a24:	682b      	ldr	r3, [r5, #0]
24004a26:	e7e6      	b.n	240049f6 <I2C_RequestMemoryWrite+0x36>
24004a28:	80002000 	.word	0x80002000

24004a2c <I2C_RequestMemoryRead>:
{
24004a2c:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
24004a30:	461e      	mov	r6, r3
  I2C_TransferConfig(hi2c, DevAddress, (uint8_t)MemAddSize, I2C_SOFTEND_MODE, I2C_GENERATE_START_WRITE);
24004a32:	4b18      	ldr	r3, [pc, #96]	@ (24004a94 <I2C_RequestMemoryRead+0x68>)
{
24004a34:	4605      	mov	r5, r0
24004a36:	4614      	mov	r4, r2
  I2C_TransferConfig(hi2c, DevAddress, (uint8_t)MemAddSize, I2C_SOFTEND_MODE, I2C_GENERATE_START_WRITE);
24004a38:	9300      	str	r3, [sp, #0]
24004a3a:	b2f2      	uxtb	r2, r6
24004a3c:	2300      	movs	r3, #0
{
24004a3e:	e9dd 7808 	ldrd	r7, r8, [sp, #32]
  I2C_TransferConfig(hi2c, DevAddress, (uint8_t)MemAddSize, I2C_SOFTEND_MODE, I2C_GENERATE_START_WRITE);
24004a42:	f7ff fe53 	bl	240046ec <I2C_TransferConfig>
  if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
24004a46:	4628      	mov	r0, r5
24004a48:	4642      	mov	r2, r8
24004a4a:	4639      	mov	r1, r7
24004a4c:	f7ff ff03 	bl	24004856 <I2C_WaitOnTXISFlagUntilTimeout>
24004a50:	b118      	cbz	r0, 24004a5a <I2C_RequestMemoryRead+0x2e>
    return HAL_ERROR;
24004a52:	2001      	movs	r0, #1
}
24004a54:	b002      	add	sp, #8
24004a56:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
24004a5a:	2e01      	cmp	r6, #1
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
24004a5c:	682b      	ldr	r3, [r5, #0]
  if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
24004a5e:	d10d      	bne.n	24004a7c <I2C_RequestMemoryRead+0x50>
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
24004a60:	b2e4      	uxtb	r4, r4
  if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TC, RESET, Timeout, Tickstart) != HAL_OK)
24004a62:	2200      	movs	r2, #0
24004a64:	2140      	movs	r1, #64	@ 0x40
24004a66:	4628      	mov	r0, r5
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
24004a68:	629c      	str	r4, [r3, #40]	@ 0x28
  if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TC, RESET, Timeout, Tickstart) != HAL_OK)
24004a6a:	463b      	mov	r3, r7
24004a6c:	f8cd 8000 	str.w	r8, [sp]
24004a70:	f7ff ff7c 	bl	2400496c <I2C_WaitOnFlagUntilTimeout>
24004a74:	3800      	subs	r0, #0
24004a76:	bf18      	it	ne
24004a78:	2001      	movne	r0, #1
24004a7a:	e7eb      	b.n	24004a54 <I2C_RequestMemoryRead+0x28>
    hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);
24004a7c:	0a22      	lsrs	r2, r4, #8
    if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
24004a7e:	4639      	mov	r1, r7
24004a80:	4628      	mov	r0, r5
    hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);
24004a82:	629a      	str	r2, [r3, #40]	@ 0x28
    if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
24004a84:	4642      	mov	r2, r8
24004a86:	f7ff fee6 	bl	24004856 <I2C_WaitOnTXISFlagUntilTimeout>
24004a8a:	2800      	cmp	r0, #0
24004a8c:	d1e1      	bne.n	24004a52 <I2C_RequestMemoryRead+0x26>
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
24004a8e:	682b      	ldr	r3, [r5, #0]
24004a90:	e7e6      	b.n	24004a60 <I2C_RequestMemoryRead+0x34>
24004a92:	bf00      	nop
24004a94:	80002000 	.word	0x80002000

24004a98 <HAL_I2C_MspInit>:
}
24004a98:	4770      	bx	lr

24004a9a <HAL_I2C_Init>:
{
24004a9a:	b510      	push	{r4, lr}
  if (hi2c == NULL)
24004a9c:	4604      	mov	r4, r0
24004a9e:	2800      	cmp	r0, #0
24004aa0:	d04a      	beq.n	24004b38 <HAL_I2C_Init+0x9e>
  if (hi2c->State == HAL_I2C_STATE_RESET)
24004aa2:	f890 3041 	ldrb.w	r3, [r0, #65]	@ 0x41
24004aa6:	f003 02ff 	and.w	r2, r3, #255	@ 0xff
24004aaa:	b91b      	cbnz	r3, 24004ab4 <HAL_I2C_Init+0x1a>
    hi2c->Lock = HAL_UNLOCKED;
24004aac:	f880 2040 	strb.w	r2, [r0, #64]	@ 0x40
    HAL_I2C_MspInit(hi2c);
24004ab0:	f7ff fff2 	bl	24004a98 <HAL_I2C_MspInit>
  hi2c->State = HAL_I2C_STATE_BUSY;
24004ab4:	2324      	movs	r3, #36	@ 0x24
24004ab6:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
  __HAL_I2C_DISABLE(hi2c);
24004aba:	6823      	ldr	r3, [r4, #0]
24004abc:	681a      	ldr	r2, [r3, #0]
24004abe:	f022 0201 	bic.w	r2, r2, #1
24004ac2:	601a      	str	r2, [r3, #0]
  hi2c->Instance->TIMINGR = hi2c->Init.Timing & TIMING_CLEAR_MASK;
24004ac4:	6862      	ldr	r2, [r4, #4]
24004ac6:	f022 6270 	bic.w	r2, r2, #251658240	@ 0xf000000
24004aca:	611a      	str	r2, [r3, #16]
  hi2c->Instance->OAR1 &= ~I2C_OAR1_OA1EN;
24004acc:	689a      	ldr	r2, [r3, #8]
24004ace:	f422 4200 	bic.w	r2, r2, #32768	@ 0x8000
24004ad2:	609a      	str	r2, [r3, #8]
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | hi2c->Init.OwnAddress1);
24004ad4:	e9d4 2102 	ldrd	r2, r1, [r4, #8]
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
24004ad8:	2901      	cmp	r1, #1
24004ada:	d124      	bne.n	24004b26 <HAL_I2C_Init+0x8c>
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | hi2c->Init.OwnAddress1);
24004adc:	f442 4200 	orr.w	r2, r2, #32768	@ 0x8000
24004ae0:	609a      	str	r2, [r3, #8]
  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
24004ae2:	685a      	ldr	r2, [r3, #4]
  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
24004ae4:	2000      	movs	r0, #0
  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
24004ae6:	f042 7200 	orr.w	r2, r2, #33554432	@ 0x2000000
24004aea:	f442 4200 	orr.w	r2, r2, #32768	@ 0x8000
24004aee:	605a      	str	r2, [r3, #4]
  hi2c->Instance->OAR2 &= ~I2C_DUALADDRESS_ENABLE;
24004af0:	68da      	ldr	r2, [r3, #12]
24004af2:	f422 4200 	bic.w	r2, r2, #32768	@ 0x8000
24004af6:	60da      	str	r2, [r3, #12]
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | (hi2c->Init.OwnAddress2Masks << 8));
24004af8:	e9d4 2104 	ldrd	r2, r1, [r4, #16]
24004afc:	430a      	orrs	r2, r1
24004afe:	69a1      	ldr	r1, [r4, #24]
24004b00:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
24004b04:	60da      	str	r2, [r3, #12]
  hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
24004b06:	e9d4 2107 	ldrd	r2, r1, [r4, #28]
24004b0a:	430a      	orrs	r2, r1
24004b0c:	601a      	str	r2, [r3, #0]
  __HAL_I2C_ENABLE(hi2c);
24004b0e:	681a      	ldr	r2, [r3, #0]
24004b10:	f042 0201 	orr.w	r2, r2, #1
24004b14:	601a      	str	r2, [r3, #0]
  hi2c->State = HAL_I2C_STATE_READY;
24004b16:	2320      	movs	r3, #32
  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
24004b18:	6460      	str	r0, [r4, #68]	@ 0x44
  hi2c->State = HAL_I2C_STATE_READY;
24004b1a:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
  hi2c->PreviousState = I2C_STATE_NONE;
24004b1e:	6320      	str	r0, [r4, #48]	@ 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
24004b20:	f884 0042 	strb.w	r0, [r4, #66]	@ 0x42
}
24004b24:	bd10      	pop	{r4, pc}
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | I2C_OAR1_OA1MODE | hi2c->Init.OwnAddress1);
24004b26:	f442 4204 	orr.w	r2, r2, #33792	@ 0x8400
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
24004b2a:	2902      	cmp	r1, #2
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | I2C_OAR1_OA1MODE | hi2c->Init.OwnAddress1);
24004b2c:	609a      	str	r2, [r3, #8]
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
24004b2e:	d1d8      	bne.n	24004ae2 <HAL_I2C_Init+0x48>
    hi2c->Instance->CR2 = (I2C_CR2_ADD10);
24004b30:	f44f 6200 	mov.w	r2, #2048	@ 0x800
24004b34:	605a      	str	r2, [r3, #4]
24004b36:	e7d4      	b.n	24004ae2 <HAL_I2C_Init+0x48>
    return HAL_ERROR;
24004b38:	2001      	movs	r0, #1
24004b3a:	e7f3      	b.n	24004b24 <HAL_I2C_Init+0x8a>

24004b3c <HAL_I2C_MspDeInit>:
__weak void HAL_I2C_MspDeInit(I2C_HandleTypeDef *hi2c)
24004b3c:	4770      	bx	lr

24004b3e <HAL_I2C_DeInit>:
{
24004b3e:	b510      	push	{r4, lr}
  if (hi2c == NULL)
24004b40:	4604      	mov	r4, r0
24004b42:	b198      	cbz	r0, 24004b6c <HAL_I2C_DeInit+0x2e>
  __HAL_I2C_DISABLE(hi2c);
24004b44:	6802      	ldr	r2, [r0, #0]
  hi2c->State = HAL_I2C_STATE_BUSY;
24004b46:	2324      	movs	r3, #36	@ 0x24
24004b48:	f880 3041 	strb.w	r3, [r0, #65]	@ 0x41
  __HAL_I2C_DISABLE(hi2c);
24004b4c:	6813      	ldr	r3, [r2, #0]
24004b4e:	f023 0301 	bic.w	r3, r3, #1
24004b52:	6013      	str	r3, [r2, #0]
  HAL_I2C_MspDeInit(hi2c);
24004b54:	f7ff fff2 	bl	24004b3c <HAL_I2C_MspDeInit>
  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
24004b58:	2000      	movs	r0, #0
24004b5a:	6460      	str	r0, [r4, #68]	@ 0x44
  __HAL_UNLOCK(hi2c);
24004b5c:	f884 0040 	strb.w	r0, [r4, #64]	@ 0x40
  hi2c->State = HAL_I2C_STATE_RESET;
24004b60:	f884 0041 	strb.w	r0, [r4, #65]	@ 0x41
  hi2c->PreviousState = I2C_STATE_NONE;
24004b64:	6320      	str	r0, [r4, #48]	@ 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
24004b66:	f884 0042 	strb.w	r0, [r4, #66]	@ 0x42
}
24004b6a:	bd10      	pop	{r4, pc}
    return HAL_ERROR;
24004b6c:	2001      	movs	r0, #1
24004b6e:	e7fc      	b.n	24004b6a <HAL_I2C_DeInit+0x2c>

24004b70 <HAL_I2C_Master_Transmit>:
{
24004b70:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
24004b74:	4698      	mov	r8, r3
  if (hi2c->State == HAL_I2C_STATE_READY)
24004b76:	f890 3041 	ldrb.w	r3, [r0, #65]	@ 0x41
{
24004b7a:	4604      	mov	r4, r0
24004b7c:	460e      	mov	r6, r1
  if (hi2c->State == HAL_I2C_STATE_READY)
24004b7e:	2b20      	cmp	r3, #32
{
24004b80:	4691      	mov	r9, r2
24004b82:	9f0a      	ldr	r7, [sp, #40]	@ 0x28
  if (hi2c->State == HAL_I2C_STATE_READY)
24004b84:	f040 8086 	bne.w	24004c94 <HAL_I2C_Master_Transmit+0x124>
    __HAL_LOCK(hi2c);
24004b88:	f890 3040 	ldrb.w	r3, [r0, #64]	@ 0x40
24004b8c:	2b01      	cmp	r3, #1
24004b8e:	f000 8081 	beq.w	24004c94 <HAL_I2C_Master_Transmit+0x124>
24004b92:	f04f 0a01 	mov.w	sl, #1
24004b96:	f880 a040 	strb.w	sl, [r0, #64]	@ 0x40
    tickstart = HAL_GetTick();
24004b9a:	f00d f935 	bl	24011e08 <HAL_GetTick>
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
24004b9e:	2319      	movs	r3, #25
    tickstart = HAL_GetTick();
24004ba0:	4605      	mov	r5, r0
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
24004ba2:	9000      	str	r0, [sp, #0]
24004ba4:	4652      	mov	r2, sl
24004ba6:	f44f 4100 	mov.w	r1, #32768	@ 0x8000
24004baa:	4620      	mov	r0, r4
24004bac:	f7ff fede 	bl	2400496c <I2C_WaitOnFlagUntilTimeout>
24004bb0:	b118      	cbz	r0, 24004bba <HAL_I2C_Master_Transmit+0x4a>
      return HAL_ERROR;
24004bb2:	2001      	movs	r0, #1
}
24004bb4:	b002      	add	sp, #8
24004bb6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    hi2c->State     = HAL_I2C_STATE_BUSY_TX;
24004bba:	2321      	movs	r3, #33	@ 0x21
    hi2c->pBuffPtr  = pData;
24004bbc:	f8c4 9024 	str.w	r9, [r4, #36]	@ 0x24
    hi2c->XferISR   = NULL;
24004bc0:	6360      	str	r0, [r4, #52]	@ 0x34
    hi2c->State     = HAL_I2C_STATE_BUSY_TX;
24004bc2:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
    hi2c->Mode      = HAL_I2C_MODE_MASTER;
24004bc6:	2310      	movs	r3, #16
24004bc8:	f884 3042 	strb.w	r3, [r4, #66]	@ 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
24004bcc:	6460      	str	r0, [r4, #68]	@ 0x44
    hi2c->XferCount = Size;
24004bce:	f8a4 802a 	strh.w	r8, [r4, #42]	@ 0x2a
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
24004bd2:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
24004bd4:	b29b      	uxth	r3, r3
24004bd6:	2bff      	cmp	r3, #255	@ 0xff
24004bd8:	4b2f      	ldr	r3, [pc, #188]	@ (24004c98 <HAL_I2C_Master_Transmit+0x128>)
24004bda:	d926      	bls.n	24004c2a <HAL_I2C_Master_Transmit+0xba>
      hi2c->XferSize = MAX_NBYTE_SIZE;
24004bdc:	22ff      	movs	r2, #255	@ 0xff
24004bde:	8522      	strh	r2, [r4, #40]	@ 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_GENERATE_START_WRITE);
24004be0:	9300      	str	r3, [sp, #0]
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
24004be2:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
24004be6:	4631      	mov	r1, r6
24004be8:	4620      	mov	r0, r4
24004bea:	f7ff fd7f 	bl	240046ec <I2C_TransferConfig>
    while (hi2c->XferCount > 0U)
24004bee:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
      if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
24004bf0:	462a      	mov	r2, r5
24004bf2:	4639      	mov	r1, r7
24004bf4:	4620      	mov	r0, r4
    while (hi2c->XferCount > 0U)
24004bf6:	b29b      	uxth	r3, r3
24004bf8:	b9fb      	cbnz	r3, 24004c3a <HAL_I2C_Master_Transmit+0xca>
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
24004bfa:	f7ff fe53 	bl	240048a4 <I2C_WaitOnSTOPFlagUntilTimeout>
24004bfe:	2800      	cmp	r0, #0
24004c00:	d1d7      	bne.n	24004bb2 <HAL_I2C_Master_Transmit+0x42>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
24004c02:	6823      	ldr	r3, [r4, #0]
24004c04:	2120      	movs	r1, #32
24004c06:	61d9      	str	r1, [r3, #28]
    I2C_RESET_CR2(hi2c);
24004c08:	685a      	ldr	r2, [r3, #4]
24004c0a:	f022 72ff 	bic.w	r2, r2, #33423360	@ 0x1fe0000
24004c0e:	f422 328b 	bic.w	r2, r2, #71168	@ 0x11600
24004c12:	f422 72ff 	bic.w	r2, r2, #510	@ 0x1fe
24004c16:	f022 0201 	bic.w	r2, r2, #1
24004c1a:	605a      	str	r2, [r3, #4]
    hi2c->State = HAL_I2C_STATE_READY;
24004c1c:	f884 1041 	strb.w	r1, [r4, #65]	@ 0x41
    __HAL_UNLOCK(hi2c);
24004c20:	f884 0040 	strb.w	r0, [r4, #64]	@ 0x40
    hi2c->Mode  = HAL_I2C_MODE_NONE;
24004c24:	f884 0042 	strb.w	r0, [r4, #66]	@ 0x42
    return HAL_OK;
24004c28:	e7c4      	b.n	24004bb4 <HAL_I2C_Master_Transmit+0x44>
      hi2c->XferSize = hi2c->XferCount;
24004c2a:	8d62      	ldrh	r2, [r4, #42]	@ 0x2a
24004c2c:	b292      	uxth	r2, r2
24004c2e:	8522      	strh	r2, [r4, #40]	@ 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_WRITE);
24004c30:	9300      	str	r3, [sp, #0]
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
24004c32:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
24004c36:	b2d2      	uxtb	r2, r2
24004c38:	e7d5      	b.n	24004be6 <HAL_I2C_Master_Transmit+0x76>
      if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
24004c3a:	f7ff fe0c 	bl	24004856 <I2C_WaitOnTXISFlagUntilTimeout>
24004c3e:	2800      	cmp	r0, #0
24004c40:	d1b7      	bne.n	24004bb2 <HAL_I2C_Master_Transmit+0x42>
      hi2c->Instance->TXDR = *hi2c->pBuffPtr;
24004c42:	6a63      	ldr	r3, [r4, #36]	@ 0x24
24004c44:	6822      	ldr	r2, [r4, #0]
24004c46:	f813 1b01 	ldrb.w	r1, [r3], #1
24004c4a:	6291      	str	r1, [r2, #40]	@ 0x28
      hi2c->pBuffPtr++;
24004c4c:	6263      	str	r3, [r4, #36]	@ 0x24
      hi2c->XferCount--;
24004c4e:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
      hi2c->XferSize--;
24004c50:	8d22      	ldrh	r2, [r4, #40]	@ 0x28
      hi2c->XferCount--;
24004c52:	3b01      	subs	r3, #1
      hi2c->XferSize--;
24004c54:	3a01      	subs	r2, #1
      hi2c->XferCount--;
24004c56:	b29b      	uxth	r3, r3
      hi2c->XferSize--;
24004c58:	b292      	uxth	r2, r2
      hi2c->XferCount--;
24004c5a:	8563      	strh	r3, [r4, #42]	@ 0x2a
      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
24004c5c:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
      hi2c->XferSize--;
24004c5e:	8522      	strh	r2, [r4, #40]	@ 0x28
      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
24004c60:	b29b      	uxth	r3, r3
24004c62:	2b00      	cmp	r3, #0
24004c64:	d0c3      	beq.n	24004bee <HAL_I2C_Master_Transmit+0x7e>
24004c66:	2a00      	cmp	r2, #0
24004c68:	d1c1      	bne.n	24004bee <HAL_I2C_Master_Transmit+0x7e>
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
24004c6a:	463b      	mov	r3, r7
24004c6c:	2180      	movs	r1, #128	@ 0x80
24004c6e:	4620      	mov	r0, r4
24004c70:	9500      	str	r5, [sp, #0]
24004c72:	f7ff fe7b 	bl	2400496c <I2C_WaitOnFlagUntilTimeout>
24004c76:	2800      	cmp	r0, #0
24004c78:	d19b      	bne.n	24004bb2 <HAL_I2C_Master_Transmit+0x42>
        if (hi2c->XferCount > MAX_NBYTE_SIZE)
24004c7a:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
24004c7c:	b29b      	uxth	r3, r3
24004c7e:	2bff      	cmp	r3, #255	@ 0xff
24004c80:	d903      	bls.n	24004c8a <HAL_I2C_Master_Transmit+0x11a>
          hi2c->XferSize = MAX_NBYTE_SIZE;
24004c82:	22ff      	movs	r2, #255	@ 0xff
24004c84:	8522      	strh	r2, [r4, #40]	@ 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
24004c86:	9000      	str	r0, [sp, #0]
24004c88:	e7ab      	b.n	24004be2 <HAL_I2C_Master_Transmit+0x72>
          hi2c->XferSize = hi2c->XferCount;
24004c8a:	8d62      	ldrh	r2, [r4, #42]	@ 0x2a
24004c8c:	b292      	uxth	r2, r2
24004c8e:	8522      	strh	r2, [r4, #40]	@ 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
24004c90:	9000      	str	r0, [sp, #0]
24004c92:	e7ce      	b.n	24004c32 <HAL_I2C_Master_Transmit+0xc2>
    __HAL_LOCK(hi2c);
24004c94:	2002      	movs	r0, #2
24004c96:	e78d      	b.n	24004bb4 <HAL_I2C_Master_Transmit+0x44>
24004c98:	80002000 	.word	0x80002000

24004c9c <HAL_I2C_Master_Receive>:
{
24004c9c:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
24004ca0:	4698      	mov	r8, r3
  if (hi2c->State == HAL_I2C_STATE_READY)
24004ca2:	f890 3041 	ldrb.w	r3, [r0, #65]	@ 0x41
{
24004ca6:	4604      	mov	r4, r0
24004ca8:	460e      	mov	r6, r1
  if (hi2c->State == HAL_I2C_STATE_READY)
24004caa:	2b20      	cmp	r3, #32
{
24004cac:	4691      	mov	r9, r2
24004cae:	9f0a      	ldr	r7, [sp, #40]	@ 0x28
  if (hi2c->State == HAL_I2C_STATE_READY)
24004cb0:	f040 8087 	bne.w	24004dc2 <HAL_I2C_Master_Receive+0x126>
    __HAL_LOCK(hi2c);
24004cb4:	f890 3040 	ldrb.w	r3, [r0, #64]	@ 0x40
24004cb8:	2b01      	cmp	r3, #1
24004cba:	f000 8082 	beq.w	24004dc2 <HAL_I2C_Master_Receive+0x126>
24004cbe:	f04f 0a01 	mov.w	sl, #1
24004cc2:	f880 a040 	strb.w	sl, [r0, #64]	@ 0x40
    tickstart = HAL_GetTick();
24004cc6:	f00d f89f 	bl	24011e08 <HAL_GetTick>
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
24004cca:	2319      	movs	r3, #25
    tickstart = HAL_GetTick();
24004ccc:	4605      	mov	r5, r0
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
24004cce:	9000      	str	r0, [sp, #0]
24004cd0:	4652      	mov	r2, sl
24004cd2:	f44f 4100 	mov.w	r1, #32768	@ 0x8000
24004cd6:	4620      	mov	r0, r4
24004cd8:	f7ff fe48 	bl	2400496c <I2C_WaitOnFlagUntilTimeout>
24004cdc:	b118      	cbz	r0, 24004ce6 <HAL_I2C_Master_Receive+0x4a>
      return HAL_ERROR;
24004cde:	2001      	movs	r0, #1
}
24004ce0:	b002      	add	sp, #8
24004ce2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    hi2c->State     = HAL_I2C_STATE_BUSY_RX;
24004ce6:	2322      	movs	r3, #34	@ 0x22
    hi2c->pBuffPtr  = pData;
24004ce8:	f8c4 9024 	str.w	r9, [r4, #36]	@ 0x24
    hi2c->XferISR   = NULL;
24004cec:	6360      	str	r0, [r4, #52]	@ 0x34
    hi2c->State     = HAL_I2C_STATE_BUSY_RX;
24004cee:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
    hi2c->Mode      = HAL_I2C_MODE_MASTER;
24004cf2:	2310      	movs	r3, #16
24004cf4:	f884 3042 	strb.w	r3, [r4, #66]	@ 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
24004cf8:	6460      	str	r0, [r4, #68]	@ 0x44
    hi2c->XferCount = Size;
24004cfa:	f8a4 802a 	strh.w	r8, [r4, #42]	@ 0x2a
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
24004cfe:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
24004d00:	b29b      	uxth	r3, r3
24004d02:	2bff      	cmp	r3, #255	@ 0xff
24004d04:	4b30      	ldr	r3, [pc, #192]	@ (24004dc8 <HAL_I2C_Master_Receive+0x12c>)
24004d06:	d926      	bls.n	24004d56 <HAL_I2C_Master_Receive+0xba>
      hi2c->XferSize = MAX_NBYTE_SIZE;
24004d08:	22ff      	movs	r2, #255	@ 0xff
24004d0a:	8522      	strh	r2, [r4, #40]	@ 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_GENERATE_START_READ);
24004d0c:	9300      	str	r3, [sp, #0]
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
24004d0e:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
24004d12:	4631      	mov	r1, r6
24004d14:	4620      	mov	r0, r4
24004d16:	f7ff fce9 	bl	240046ec <I2C_TransferConfig>
    while (hi2c->XferCount > 0U)
24004d1a:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
      if (I2C_WaitOnRXNEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
24004d1c:	462a      	mov	r2, r5
24004d1e:	4639      	mov	r1, r7
24004d20:	4620      	mov	r0, r4
    while (hi2c->XferCount > 0U)
24004d22:	b29b      	uxth	r3, r3
24004d24:	b9fb      	cbnz	r3, 24004d66 <HAL_I2C_Master_Receive+0xca>
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
24004d26:	f7ff fdbd 	bl	240048a4 <I2C_WaitOnSTOPFlagUntilTimeout>
24004d2a:	2800      	cmp	r0, #0
24004d2c:	d1d7      	bne.n	24004cde <HAL_I2C_Master_Receive+0x42>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
24004d2e:	6823      	ldr	r3, [r4, #0]
24004d30:	2120      	movs	r1, #32
24004d32:	61d9      	str	r1, [r3, #28]
    I2C_RESET_CR2(hi2c);
24004d34:	685a      	ldr	r2, [r3, #4]
24004d36:	f022 72ff 	bic.w	r2, r2, #33423360	@ 0x1fe0000
24004d3a:	f422 328b 	bic.w	r2, r2, #71168	@ 0x11600
24004d3e:	f422 72ff 	bic.w	r2, r2, #510	@ 0x1fe
24004d42:	f022 0201 	bic.w	r2, r2, #1
24004d46:	605a      	str	r2, [r3, #4]
    hi2c->State = HAL_I2C_STATE_READY;
24004d48:	f884 1041 	strb.w	r1, [r4, #65]	@ 0x41
    __HAL_UNLOCK(hi2c);
24004d4c:	f884 0040 	strb.w	r0, [r4, #64]	@ 0x40
    hi2c->Mode  = HAL_I2C_MODE_NONE;
24004d50:	f884 0042 	strb.w	r0, [r4, #66]	@ 0x42
    return HAL_OK;
24004d54:	e7c4      	b.n	24004ce0 <HAL_I2C_Master_Receive+0x44>
      hi2c->XferSize = hi2c->XferCount;
24004d56:	8d62      	ldrh	r2, [r4, #42]	@ 0x2a
24004d58:	b292      	uxth	r2, r2
24004d5a:	8522      	strh	r2, [r4, #40]	@ 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_READ);
24004d5c:	9300      	str	r3, [sp, #0]
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
24004d5e:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
24004d62:	b2d2      	uxtb	r2, r2
24004d64:	e7d5      	b.n	24004d12 <HAL_I2C_Master_Receive+0x76>
      if (I2C_WaitOnRXNEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
24004d66:	f7ff fdc2 	bl	240048ee <I2C_WaitOnRXNEFlagUntilTimeout>
24004d6a:	2800      	cmp	r0, #0
24004d6c:	d1b7      	bne.n	24004cde <HAL_I2C_Master_Receive+0x42>
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
24004d6e:	6823      	ldr	r3, [r4, #0]
24004d70:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
24004d72:	6a63      	ldr	r3, [r4, #36]	@ 0x24
24004d74:	701a      	strb	r2, [r3, #0]
      hi2c->pBuffPtr++;
24004d76:	6a63      	ldr	r3, [r4, #36]	@ 0x24
      hi2c->XferSize--;
24004d78:	8d22      	ldrh	r2, [r4, #40]	@ 0x28
      hi2c->pBuffPtr++;
24004d7a:	3301      	adds	r3, #1
      hi2c->XferSize--;
24004d7c:	3a01      	subs	r2, #1
      hi2c->pBuffPtr++;
24004d7e:	6263      	str	r3, [r4, #36]	@ 0x24
      hi2c->XferCount--;
24004d80:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
      hi2c->XferSize--;
24004d82:	b292      	uxth	r2, r2
      hi2c->XferCount--;
24004d84:	3b01      	subs	r3, #1
      hi2c->XferSize--;
24004d86:	8522      	strh	r2, [r4, #40]	@ 0x28
      hi2c->XferCount--;
24004d88:	b29b      	uxth	r3, r3
24004d8a:	8563      	strh	r3, [r4, #42]	@ 0x2a
      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
24004d8c:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
24004d8e:	b29b      	uxth	r3, r3
24004d90:	2b00      	cmp	r3, #0
24004d92:	d0c2      	beq.n	24004d1a <HAL_I2C_Master_Receive+0x7e>
24004d94:	2a00      	cmp	r2, #0
24004d96:	d1c0      	bne.n	24004d1a <HAL_I2C_Master_Receive+0x7e>
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
24004d98:	463b      	mov	r3, r7
24004d9a:	2180      	movs	r1, #128	@ 0x80
24004d9c:	4620      	mov	r0, r4
24004d9e:	9500      	str	r5, [sp, #0]
24004da0:	f7ff fde4 	bl	2400496c <I2C_WaitOnFlagUntilTimeout>
24004da4:	2800      	cmp	r0, #0
24004da6:	d19a      	bne.n	24004cde <HAL_I2C_Master_Receive+0x42>
        if (hi2c->XferCount > MAX_NBYTE_SIZE)
24004da8:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
24004daa:	b29b      	uxth	r3, r3
24004dac:	2bff      	cmp	r3, #255	@ 0xff
24004dae:	d903      	bls.n	24004db8 <HAL_I2C_Master_Receive+0x11c>
          hi2c->XferSize = MAX_NBYTE_SIZE;
24004db0:	22ff      	movs	r2, #255	@ 0xff
24004db2:	8522      	strh	r2, [r4, #40]	@ 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
24004db4:	9000      	str	r0, [sp, #0]
24004db6:	e7aa      	b.n	24004d0e <HAL_I2C_Master_Receive+0x72>
          hi2c->XferSize = hi2c->XferCount;
24004db8:	8d62      	ldrh	r2, [r4, #42]	@ 0x2a
24004dba:	b292      	uxth	r2, r2
24004dbc:	8522      	strh	r2, [r4, #40]	@ 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
24004dbe:	9000      	str	r0, [sp, #0]
24004dc0:	e7cd      	b.n	24004d5e <HAL_I2C_Master_Receive+0xc2>
    __HAL_LOCK(hi2c);
24004dc2:	2002      	movs	r0, #2
24004dc4:	e78c      	b.n	24004ce0 <HAL_I2C_Master_Receive+0x44>
24004dc6:	bf00      	nop
24004dc8:	80002400 	.word	0x80002400

24004dcc <HAL_I2C_Slave_Transmit>:
{
24004dcc:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
24004dd0:	461d      	mov	r5, r3
  if (hi2c->State == HAL_I2C_STATE_READY)
24004dd2:	f890 3041 	ldrb.w	r3, [r0, #65]	@ 0x41
{
24004dd6:	4604      	mov	r4, r0
24004dd8:	4688      	mov	r8, r1
  if (hi2c->State == HAL_I2C_STATE_READY)
24004dda:	2b20      	cmp	r3, #32
{
24004ddc:	4617      	mov	r7, r2
  if (hi2c->State == HAL_I2C_STATE_READY)
24004dde:	fa5f f983 	uxtb.w	r9, r3
24004de2:	f040 8088 	bne.w	24004ef6 <HAL_I2C_Slave_Transmit+0x12a>
    if ((pData == NULL) || (Size == 0U))
24004de6:	b101      	cbz	r1, 24004dea <HAL_I2C_Slave_Transmit+0x1e>
24004de8:	b932      	cbnz	r2, 24004df8 <HAL_I2C_Slave_Transmit+0x2c>
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
24004dea:	f44f 7300 	mov.w	r3, #512	@ 0x200
24004dee:	6463      	str	r3, [r4, #68]	@ 0x44
      return  HAL_ERROR;
24004df0:	2001      	movs	r0, #1
}
24004df2:	b003      	add	sp, #12
24004df4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    __HAL_LOCK(hi2c);
24004df8:	f890 3040 	ldrb.w	r3, [r0, #64]	@ 0x40
24004dfc:	2b01      	cmp	r3, #1
24004dfe:	d07a      	beq.n	24004ef6 <HAL_I2C_Slave_Transmit+0x12a>
24004e00:	2301      	movs	r3, #1
24004e02:	f880 3040 	strb.w	r3, [r0, #64]	@ 0x40
    tickstart = HAL_GetTick();
24004e06:	f00c ffff 	bl	24011e08 <HAL_GetTick>
    hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
24004e0a:	6821      	ldr	r1, [r4, #0]
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
24004e0c:	2200      	movs	r2, #0
    hi2c->State     = HAL_I2C_STATE_BUSY_TX;
24004e0e:	2321      	movs	r3, #33	@ 0x21
    hi2c->pBuffPtr  = pData;
24004e10:	f8c4 8024 	str.w	r8, [r4, #36]	@ 0x24
    tickstart = HAL_GetTick();
24004e14:	4606      	mov	r6, r0
    hi2c->State     = HAL_I2C_STATE_BUSY_TX;
24004e16:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
    hi2c->Mode      = HAL_I2C_MODE_SLAVE;
24004e1a:	f884 9042 	strb.w	r9, [r4, #66]	@ 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
24004e1e:	6462      	str	r2, [r4, #68]	@ 0x44
    hi2c->XferCount = Size;
24004e20:	8567      	strh	r7, [r4, #42]	@ 0x2a
    hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
24004e22:	684b      	ldr	r3, [r1, #4]
    hi2c->XferISR   = NULL;
24004e24:	6362      	str	r2, [r4, #52]	@ 0x34
    hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
24004e26:	f423 4300 	bic.w	r3, r3, #32768	@ 0x8000
24004e2a:	604b      	str	r3, [r1, #4]
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, RESET, Timeout, tickstart) != HAL_OK)
24004e2c:	462b      	mov	r3, r5
24004e2e:	9000      	str	r0, [sp, #0]
24004e30:	2108      	movs	r1, #8
24004e32:	4620      	mov	r0, r4
24004e34:	f7ff fd9a 	bl	2400496c <I2C_WaitOnFlagUntilTimeout>
24004e38:	6823      	ldr	r3, [r4, #0]
24004e3a:	4602      	mov	r2, r0
24004e3c:	b120      	cbz	r0, 24004e48 <HAL_I2C_Slave_Transmit+0x7c>
      hi2c->Instance->CR2 |= I2C_CR2_NACK;
24004e3e:	685a      	ldr	r2, [r3, #4]
24004e40:	f442 4200 	orr.w	r2, r2, #32768	@ 0x8000
24004e44:	605a      	str	r2, [r3, #4]
      return HAL_ERROR;
24004e46:	e7d3      	b.n	24004df0 <HAL_I2C_Slave_Transmit+0x24>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
24004e48:	2708      	movs	r7, #8
24004e4a:	61df      	str	r7, [r3, #28]
    if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
24004e4c:	68e3      	ldr	r3, [r4, #12]
24004e4e:	2b02      	cmp	r3, #2
24004e50:	d109      	bne.n	24004e66 <HAL_I2C_Slave_Transmit+0x9a>
      if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, RESET, Timeout, tickstart) != HAL_OK)
24004e52:	462b      	mov	r3, r5
24004e54:	4639      	mov	r1, r7
24004e56:	4620      	mov	r0, r4
24004e58:	9600      	str	r6, [sp, #0]
24004e5a:	f7ff fd87 	bl	2400496c <I2C_WaitOnFlagUntilTimeout>
24004e5e:	6823      	ldr	r3, [r4, #0]
24004e60:	2800      	cmp	r0, #0
24004e62:	d1ec      	bne.n	24004e3e <HAL_I2C_Slave_Transmit+0x72>
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
24004e64:	61df      	str	r7, [r3, #28]
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_DIR, RESET, Timeout, tickstart) != HAL_OK)
24004e66:	462b      	mov	r3, r5
24004e68:	2200      	movs	r2, #0
24004e6a:	f44f 3180 	mov.w	r1, #65536	@ 0x10000
24004e6e:	4620      	mov	r0, r4
24004e70:	9600      	str	r6, [sp, #0]
24004e72:	f7ff fd7b 	bl	2400496c <I2C_WaitOnFlagUntilTimeout>
24004e76:	b198      	cbz	r0, 24004ea0 <HAL_I2C_Slave_Transmit+0xd4>
      hi2c->Instance->CR2 |= I2C_CR2_NACK;
24004e78:	6822      	ldr	r2, [r4, #0]
        hi2c->Instance->CR2 |= I2C_CR2_NACK;
24004e7a:	6853      	ldr	r3, [r2, #4]
24004e7c:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
24004e80:	6053      	str	r3, [r2, #4]
        return HAL_ERROR;
24004e82:	e7b5      	b.n	24004df0 <HAL_I2C_Slave_Transmit+0x24>
      if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
24004e84:	f7ff fce7 	bl	24004856 <I2C_WaitOnTXISFlagUntilTimeout>
24004e88:	6822      	ldr	r2, [r4, #0]
24004e8a:	2800      	cmp	r0, #0
24004e8c:	d1f5      	bne.n	24004e7a <HAL_I2C_Slave_Transmit+0xae>
      hi2c->Instance->TXDR = *hi2c->pBuffPtr;
24004e8e:	6a63      	ldr	r3, [r4, #36]	@ 0x24
24004e90:	f813 1b01 	ldrb.w	r1, [r3], #1
24004e94:	6291      	str	r1, [r2, #40]	@ 0x28
      hi2c->pBuffPtr++;
24004e96:	6263      	str	r3, [r4, #36]	@ 0x24
      hi2c->XferCount--;
24004e98:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
24004e9a:	3b01      	subs	r3, #1
24004e9c:	b29b      	uxth	r3, r3
24004e9e:	8563      	strh	r3, [r4, #42]	@ 0x2a
    while (hi2c->XferCount > 0U)
24004ea0:	8d67      	ldrh	r7, [r4, #42]	@ 0x2a
      if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
24004ea2:	4632      	mov	r2, r6
24004ea4:	4629      	mov	r1, r5
24004ea6:	4620      	mov	r0, r4
    while (hi2c->XferCount > 0U)
24004ea8:	b2bf      	uxth	r7, r7
24004eaa:	2f00      	cmp	r7, #0
24004eac:	d1ea      	bne.n	24004e84 <HAL_I2C_Slave_Transmit+0xb8>
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
24004eae:	f7ff fcf9 	bl	240048a4 <I2C_WaitOnSTOPFlagUntilTimeout>
24004eb2:	6823      	ldr	r3, [r4, #0]
24004eb4:	b138      	cbz	r0, 24004ec6 <HAL_I2C_Slave_Transmit+0xfa>
      hi2c->Instance->CR2 |= I2C_CR2_NACK;
24004eb6:	685a      	ldr	r2, [r3, #4]
24004eb8:	f442 4200 	orr.w	r2, r2, #32768	@ 0x8000
24004ebc:	605a      	str	r2, [r3, #4]
      if (hi2c->ErrorCode == HAL_I2C_ERROR_AF)
24004ebe:	6c62      	ldr	r2, [r4, #68]	@ 0x44
24004ec0:	2a04      	cmp	r2, #4
24004ec2:	d195      	bne.n	24004df0 <HAL_I2C_Slave_Transmit+0x24>
        hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
24004ec4:	6467      	str	r7, [r4, #68]	@ 0x44
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
24004ec6:	2720      	movs	r7, #32
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, Timeout, tickstart) != HAL_OK)
24004ec8:	2201      	movs	r2, #1
24004eca:	f44f 4100 	mov.w	r1, #32768	@ 0x8000
24004ece:	4620      	mov	r0, r4
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
24004ed0:	61df      	str	r7, [r3, #28]
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, Timeout, tickstart) != HAL_OK)
24004ed2:	462b      	mov	r3, r5
24004ed4:	9600      	str	r6, [sp, #0]
24004ed6:	f7ff fd49 	bl	2400496c <I2C_WaitOnFlagUntilTimeout>
24004eda:	6823      	ldr	r3, [r4, #0]
24004edc:	2800      	cmp	r0, #0
24004ede:	d1ae      	bne.n	24004e3e <HAL_I2C_Slave_Transmit+0x72>
    hi2c->Instance->CR2 |= I2C_CR2_NACK;
24004ee0:	685a      	ldr	r2, [r3, #4]
24004ee2:	f442 4200 	orr.w	r2, r2, #32768	@ 0x8000
24004ee6:	605a      	str	r2, [r3, #4]
    hi2c->State = HAL_I2C_STATE_READY;
24004ee8:	f884 7041 	strb.w	r7, [r4, #65]	@ 0x41
    __HAL_UNLOCK(hi2c);
24004eec:	f884 0040 	strb.w	r0, [r4, #64]	@ 0x40
    hi2c->Mode  = HAL_I2C_MODE_NONE;
24004ef0:	f884 0042 	strb.w	r0, [r4, #66]	@ 0x42
    return HAL_OK;
24004ef4:	e77d      	b.n	24004df2 <HAL_I2C_Slave_Transmit+0x26>
    __HAL_LOCK(hi2c);
24004ef6:	2002      	movs	r0, #2
24004ef8:	e77b      	b.n	24004df2 <HAL_I2C_Slave_Transmit+0x26>

24004efa <HAL_I2C_Slave_Receive>:
{
24004efa:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
24004efe:	461d      	mov	r5, r3
  if (hi2c->State == HAL_I2C_STATE_READY)
24004f00:	f890 3041 	ldrb.w	r3, [r0, #65]	@ 0x41
{
24004f04:	4604      	mov	r4, r0
24004f06:	4688      	mov	r8, r1
  if (hi2c->State == HAL_I2C_STATE_READY)
24004f08:	2b20      	cmp	r3, #32
{
24004f0a:	4617      	mov	r7, r2
  if (hi2c->State == HAL_I2C_STATE_READY)
24004f0c:	fa5f fa83 	uxtb.w	sl, r3
24004f10:	f040 8086 	bne.w	24005020 <HAL_I2C_Slave_Receive+0x126>
    if ((pData == NULL) || (Size == 0U))
24004f14:	b101      	cbz	r1, 24004f18 <HAL_I2C_Slave_Receive+0x1e>
24004f16:	b932      	cbnz	r2, 24004f26 <HAL_I2C_Slave_Receive+0x2c>
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
24004f18:	f44f 7300 	mov.w	r3, #512	@ 0x200
24004f1c:	6463      	str	r3, [r4, #68]	@ 0x44
      return  HAL_ERROR;
24004f1e:	2001      	movs	r0, #1
}
24004f20:	b002      	add	sp, #8
24004f22:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    __HAL_LOCK(hi2c);
24004f26:	f890 3040 	ldrb.w	r3, [r0, #64]	@ 0x40
24004f2a:	2b01      	cmp	r3, #1
24004f2c:	d078      	beq.n	24005020 <HAL_I2C_Slave_Receive+0x126>
24004f2e:	f04f 0901 	mov.w	r9, #1
24004f32:	f880 9040 	strb.w	r9, [r0, #64]	@ 0x40
    tickstart = HAL_GetTick();
24004f36:	f00c ff67 	bl	24011e08 <HAL_GetTick>
    hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
24004f3a:	6821      	ldr	r1, [r4, #0]
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
24004f3c:	2200      	movs	r2, #0
    hi2c->State     = HAL_I2C_STATE_BUSY_RX;
24004f3e:	2322      	movs	r3, #34	@ 0x22
    hi2c->pBuffPtr  = pData;
24004f40:	f8c4 8024 	str.w	r8, [r4, #36]	@ 0x24
    tickstart = HAL_GetTick();
24004f44:	4606      	mov	r6, r0
    hi2c->State     = HAL_I2C_STATE_BUSY_RX;
24004f46:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
    hi2c->Mode      = HAL_I2C_MODE_SLAVE;
24004f4a:	f884 a042 	strb.w	sl, [r4, #66]	@ 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
24004f4e:	6462      	str	r2, [r4, #68]	@ 0x44
    hi2c->XferCount = Size;
24004f50:	8567      	strh	r7, [r4, #42]	@ 0x2a
    hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
24004f52:	684b      	ldr	r3, [r1, #4]
    hi2c->XferISR   = NULL;
24004f54:	6362      	str	r2, [r4, #52]	@ 0x34
    hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
24004f56:	f423 4300 	bic.w	r3, r3, #32768	@ 0x8000
24004f5a:	604b      	str	r3, [r1, #4]
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, RESET, Timeout, tickstart) != HAL_OK)
24004f5c:	462b      	mov	r3, r5
24004f5e:	9000      	str	r0, [sp, #0]
24004f60:	2108      	movs	r1, #8
24004f62:	4620      	mov	r0, r4
24004f64:	f7ff fd02 	bl	2400496c <I2C_WaitOnFlagUntilTimeout>
24004f68:	6823      	ldr	r3, [r4, #0]
24004f6a:	b120      	cbz	r0, 24004f76 <HAL_I2C_Slave_Receive+0x7c>
      hi2c->Instance->CR2 |= I2C_CR2_NACK;
24004f6c:	685a      	ldr	r2, [r3, #4]
24004f6e:	f442 4200 	orr.w	r2, r2, #32768	@ 0x8000
24004f72:	605a      	str	r2, [r3, #4]
      return HAL_ERROR;
24004f74:	e7d3      	b.n	24004f1e <HAL_I2C_Slave_Receive+0x24>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
24004f76:	2208      	movs	r2, #8
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_DIR, SET, Timeout, tickstart) != HAL_OK)
24004f78:	f44f 3180 	mov.w	r1, #65536	@ 0x10000
24004f7c:	4620      	mov	r0, r4
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
24004f7e:	61da      	str	r2, [r3, #28]
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_DIR, SET, Timeout, tickstart) != HAL_OK)
24004f80:	462b      	mov	r3, r5
24004f82:	464a      	mov	r2, r9
24004f84:	9600      	str	r6, [sp, #0]
24004f86:	f7ff fcf1 	bl	2400496c <I2C_WaitOnFlagUntilTimeout>
24004f8a:	b328      	cbz	r0, 24004fd8 <HAL_I2C_Slave_Receive+0xde>
      hi2c->Instance->CR2 |= I2C_CR2_NACK;
24004f8c:	6822      	ldr	r2, [r4, #0]
24004f8e:	6853      	ldr	r3, [r2, #4]
24004f90:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
24004f94:	6053      	str	r3, [r2, #4]
      return HAL_ERROR;
24004f96:	e7c2      	b.n	24004f1e <HAL_I2C_Slave_Receive+0x24>
      if (I2C_WaitOnRXNEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
24004f98:	f7ff fca9 	bl	240048ee <I2C_WaitOnRXNEFlagUntilTimeout>
24004f9c:	6823      	ldr	r3, [r4, #0]
24004f9e:	b188      	cbz	r0, 24004fc4 <HAL_I2C_Slave_Receive+0xca>
        hi2c->Instance->CR2 |= I2C_CR2_NACK;
24004fa0:	685a      	ldr	r2, [r3, #4]
24004fa2:	f442 4200 	orr.w	r2, r2, #32768	@ 0x8000
24004fa6:	605a      	str	r2, [r3, #4]
        if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET)
24004fa8:	699a      	ldr	r2, [r3, #24]
24004faa:	0752      	lsls	r2, r2, #29
24004fac:	d5b7      	bpl.n	24004f1e <HAL_I2C_Slave_Receive+0x24>
          *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
24004fae:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
24004fb0:	6a63      	ldr	r3, [r4, #36]	@ 0x24
24004fb2:	701a      	strb	r2, [r3, #0]
          hi2c->pBuffPtr++;
24004fb4:	6a63      	ldr	r3, [r4, #36]	@ 0x24
24004fb6:	3301      	adds	r3, #1
24004fb8:	6263      	str	r3, [r4, #36]	@ 0x24
          hi2c->XferCount--;
24004fba:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
24004fbc:	3b01      	subs	r3, #1
24004fbe:	b29b      	uxth	r3, r3
24004fc0:	8563      	strh	r3, [r4, #42]	@ 0x2a
24004fc2:	e7ac      	b.n	24004f1e <HAL_I2C_Slave_Receive+0x24>
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
24004fc4:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
24004fc6:	6a63      	ldr	r3, [r4, #36]	@ 0x24
24004fc8:	701a      	strb	r2, [r3, #0]
      hi2c->pBuffPtr++;
24004fca:	6a63      	ldr	r3, [r4, #36]	@ 0x24
24004fcc:	3301      	adds	r3, #1
24004fce:	6263      	str	r3, [r4, #36]	@ 0x24
      hi2c->XferCount--;
24004fd0:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
24004fd2:	3b01      	subs	r3, #1
24004fd4:	b29b      	uxth	r3, r3
24004fd6:	8563      	strh	r3, [r4, #42]	@ 0x2a
    while (hi2c->XferCount > 0U)
24004fd8:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
      if (I2C_WaitOnRXNEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
24004fda:	4632      	mov	r2, r6
24004fdc:	4629      	mov	r1, r5
24004fde:	4620      	mov	r0, r4
    while (hi2c->XferCount > 0U)
24004fe0:	b29b      	uxth	r3, r3
24004fe2:	2b00      	cmp	r3, #0
24004fe4:	d1d8      	bne.n	24004f98 <HAL_I2C_Slave_Receive+0x9e>
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
24004fe6:	f7ff fc5d 	bl	240048a4 <I2C_WaitOnSTOPFlagUntilTimeout>
24004fea:	6823      	ldr	r3, [r4, #0]
24004fec:	2800      	cmp	r0, #0
24004fee:	d1bd      	bne.n	24004f6c <HAL_I2C_Slave_Receive+0x72>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
24004ff0:	2720      	movs	r7, #32
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, Timeout, tickstart) != HAL_OK)
24004ff2:	2201      	movs	r2, #1
24004ff4:	f44f 4100 	mov.w	r1, #32768	@ 0x8000
24004ff8:	4620      	mov	r0, r4
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
24004ffa:	61df      	str	r7, [r3, #28]
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, Timeout, tickstart) != HAL_OK)
24004ffc:	462b      	mov	r3, r5
24004ffe:	9600      	str	r6, [sp, #0]
24005000:	f7ff fcb4 	bl	2400496c <I2C_WaitOnFlagUntilTimeout>
24005004:	6823      	ldr	r3, [r4, #0]
24005006:	2800      	cmp	r0, #0
24005008:	d1b0      	bne.n	24004f6c <HAL_I2C_Slave_Receive+0x72>
    hi2c->Instance->CR2 |= I2C_CR2_NACK;
2400500a:	685a      	ldr	r2, [r3, #4]
2400500c:	f442 4200 	orr.w	r2, r2, #32768	@ 0x8000
24005010:	605a      	str	r2, [r3, #4]
    hi2c->State = HAL_I2C_STATE_READY;
24005012:	f884 7041 	strb.w	r7, [r4, #65]	@ 0x41
    __HAL_UNLOCK(hi2c);
24005016:	f884 0040 	strb.w	r0, [r4, #64]	@ 0x40
    hi2c->Mode  = HAL_I2C_MODE_NONE;
2400501a:	f884 0042 	strb.w	r0, [r4, #66]	@ 0x42
    return HAL_OK;
2400501e:	e77f      	b.n	24004f20 <HAL_I2C_Slave_Receive+0x26>
    __HAL_LOCK(hi2c);
24005020:	2002      	movs	r0, #2
24005022:	e77d      	b.n	24004f20 <HAL_I2C_Slave_Receive+0x26>

24005024 <HAL_I2C_Master_Transmit_IT>:
{
24005024:	b537      	push	{r0, r1, r2, r4, r5, lr}
24005026:	4604      	mov	r4, r0
  if (hi2c->State == HAL_I2C_STATE_READY)
24005028:	f890 0041 	ldrb.w	r0, [r0, #65]	@ 0x41
2400502c:	2820      	cmp	r0, #32
2400502e:	d132      	bne.n	24005096 <HAL_I2C_Master_Transmit_IT+0x72>
    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
24005030:	6820      	ldr	r0, [r4, #0]
24005032:	6980      	ldr	r0, [r0, #24]
24005034:	f410 4000 	ands.w	r0, r0, #32768	@ 0x8000
24005038:	d12d      	bne.n	24005096 <HAL_I2C_Master_Transmit_IT+0x72>
    __HAL_LOCK(hi2c);
2400503a:	f894 5040 	ldrb.w	r5, [r4, #64]	@ 0x40
2400503e:	2d01      	cmp	r5, #1
24005040:	d029      	beq.n	24005096 <HAL_I2C_Master_Transmit_IT+0x72>
    hi2c->State       = HAL_I2C_STATE_BUSY_TX;
24005042:	2521      	movs	r5, #33	@ 0x21
    hi2c->pBuffPtr    = pData;
24005044:	6262      	str	r2, [r4, #36]	@ 0x24
    hi2c->State       = HAL_I2C_STATE_BUSY_TX;
24005046:	f884 5041 	strb.w	r5, [r4, #65]	@ 0x41
    hi2c->Mode        = HAL_I2C_MODE_MASTER;
2400504a:	2510      	movs	r5, #16
2400504c:	f884 5042 	strb.w	r5, [r4, #66]	@ 0x42
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
24005050:	6460      	str	r0, [r4, #68]	@ 0x44
    hi2c->XferCount   = Size;
24005052:	8563      	strh	r3, [r4, #42]	@ 0x2a
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
24005054:	4b11      	ldr	r3, [pc, #68]	@ (2400509c <HAL_I2C_Master_Transmit_IT+0x78>)
24005056:	62e3      	str	r3, [r4, #44]	@ 0x2c
    hi2c->XferISR     = I2C_Master_ISR_IT;
24005058:	4b11      	ldr	r3, [pc, #68]	@ (240050a0 <HAL_I2C_Master_Transmit_IT+0x7c>)
2400505a:	6363      	str	r3, [r4, #52]	@ 0x34
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
2400505c:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
2400505e:	b29b      	uxth	r3, r3
24005060:	2bff      	cmp	r3, #255	@ 0xff
24005062:	d814      	bhi.n	2400508e <HAL_I2C_Master_Transmit_IT+0x6a>
      hi2c->XferSize = hi2c->XferCount;
24005064:	8d62      	ldrh	r2, [r4, #42]	@ 0x2a
      xfermode = I2C_AUTOEND_MODE;
24005066:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
      hi2c->XferSize = hi2c->XferCount;
2400506a:	b292      	uxth	r2, r2
    I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, I2C_GENERATE_START_WRITE);
2400506c:	480d      	ldr	r0, [pc, #52]	@ (240050a4 <HAL_I2C_Master_Transmit_IT+0x80>)
    __HAL_UNLOCK(hi2c);
2400506e:	2500      	movs	r5, #0
24005070:	8522      	strh	r2, [r4, #40]	@ 0x28
    I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, I2C_GENERATE_START_WRITE);
24005072:	b2d2      	uxtb	r2, r2
24005074:	9000      	str	r0, [sp, #0]
24005076:	4620      	mov	r0, r4
24005078:	f7ff fb38 	bl	240046ec <I2C_TransferConfig>
    I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT);
2400507c:	4620      	mov	r0, r4
2400507e:	2101      	movs	r1, #1
    __HAL_UNLOCK(hi2c);
24005080:	f884 5040 	strb.w	r5, [r4, #64]	@ 0x40
    I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT);
24005084:	f7ff fb46 	bl	24004714 <I2C_Enable_IRQ>
    return HAL_OK;
24005088:	4628      	mov	r0, r5
}
2400508a:	b003      	add	sp, #12
2400508c:	bd30      	pop	{r4, r5, pc}
      hi2c->XferSize = MAX_NBYTE_SIZE;
2400508e:	22ff      	movs	r2, #255	@ 0xff
      xfermode = I2C_RELOAD_MODE;
24005090:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
24005094:	e7ea      	b.n	2400506c <HAL_I2C_Master_Transmit_IT+0x48>
      return HAL_BUSY;
24005096:	2002      	movs	r0, #2
24005098:	e7f7      	b.n	2400508a <HAL_I2C_Master_Transmit_IT+0x66>
2400509a:	bf00      	nop
2400509c:	ffff0000 	.word	0xffff0000
240050a0:	24006b4f 	.word	0x24006b4f
240050a4:	80002000 	.word	0x80002000

240050a8 <HAL_I2C_Master_Receive_IT>:
{
240050a8:	b537      	push	{r0, r1, r2, r4, r5, lr}
240050aa:	4604      	mov	r4, r0
  if (hi2c->State == HAL_I2C_STATE_READY)
240050ac:	f890 0041 	ldrb.w	r0, [r0, #65]	@ 0x41
240050b0:	2820      	cmp	r0, #32
240050b2:	d132      	bne.n	2400511a <HAL_I2C_Master_Receive_IT+0x72>
    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
240050b4:	6820      	ldr	r0, [r4, #0]
240050b6:	6980      	ldr	r0, [r0, #24]
240050b8:	f410 4000 	ands.w	r0, r0, #32768	@ 0x8000
240050bc:	d12d      	bne.n	2400511a <HAL_I2C_Master_Receive_IT+0x72>
    __HAL_LOCK(hi2c);
240050be:	f894 5040 	ldrb.w	r5, [r4, #64]	@ 0x40
240050c2:	2d01      	cmp	r5, #1
240050c4:	d029      	beq.n	2400511a <HAL_I2C_Master_Receive_IT+0x72>
    hi2c->State       = HAL_I2C_STATE_BUSY_RX;
240050c6:	2522      	movs	r5, #34	@ 0x22
    hi2c->pBuffPtr    = pData;
240050c8:	6262      	str	r2, [r4, #36]	@ 0x24
    hi2c->State       = HAL_I2C_STATE_BUSY_RX;
240050ca:	f884 5041 	strb.w	r5, [r4, #65]	@ 0x41
    hi2c->Mode        = HAL_I2C_MODE_MASTER;
240050ce:	2510      	movs	r5, #16
240050d0:	f884 5042 	strb.w	r5, [r4, #66]	@ 0x42
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
240050d4:	6460      	str	r0, [r4, #68]	@ 0x44
    hi2c->XferCount   = Size;
240050d6:	8563      	strh	r3, [r4, #42]	@ 0x2a
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
240050d8:	4b11      	ldr	r3, [pc, #68]	@ (24005120 <HAL_I2C_Master_Receive_IT+0x78>)
240050da:	62e3      	str	r3, [r4, #44]	@ 0x2c
    hi2c->XferISR     = I2C_Master_ISR_IT;
240050dc:	4b11      	ldr	r3, [pc, #68]	@ (24005124 <HAL_I2C_Master_Receive_IT+0x7c>)
240050de:	6363      	str	r3, [r4, #52]	@ 0x34
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
240050e0:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
240050e2:	b29b      	uxth	r3, r3
240050e4:	2bff      	cmp	r3, #255	@ 0xff
240050e6:	d814      	bhi.n	24005112 <HAL_I2C_Master_Receive_IT+0x6a>
      hi2c->XferSize = hi2c->XferCount;
240050e8:	8d62      	ldrh	r2, [r4, #42]	@ 0x2a
      xfermode = I2C_AUTOEND_MODE;
240050ea:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
      hi2c->XferSize = hi2c->XferCount;
240050ee:	b292      	uxth	r2, r2
    I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, I2C_GENERATE_START_READ);
240050f0:	480d      	ldr	r0, [pc, #52]	@ (24005128 <HAL_I2C_Master_Receive_IT+0x80>)
    __HAL_UNLOCK(hi2c);
240050f2:	2500      	movs	r5, #0
240050f4:	8522      	strh	r2, [r4, #40]	@ 0x28
    I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, I2C_GENERATE_START_READ);
240050f6:	b2d2      	uxtb	r2, r2
240050f8:	9000      	str	r0, [sp, #0]
240050fa:	4620      	mov	r0, r4
240050fc:	f7ff faf6 	bl	240046ec <I2C_TransferConfig>
    I2C_Enable_IRQ(hi2c, I2C_XFER_RX_IT);
24005100:	4620      	mov	r0, r4
24005102:	2102      	movs	r1, #2
    __HAL_UNLOCK(hi2c);
24005104:	f884 5040 	strb.w	r5, [r4, #64]	@ 0x40
    I2C_Enable_IRQ(hi2c, I2C_XFER_RX_IT);
24005108:	f7ff fb04 	bl	24004714 <I2C_Enable_IRQ>
    return HAL_OK;
2400510c:	4628      	mov	r0, r5
}
2400510e:	b003      	add	sp, #12
24005110:	bd30      	pop	{r4, r5, pc}
      hi2c->XferSize = MAX_NBYTE_SIZE;
24005112:	22ff      	movs	r2, #255	@ 0xff
      xfermode = I2C_RELOAD_MODE;
24005114:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
24005118:	e7ea      	b.n	240050f0 <HAL_I2C_Master_Receive_IT+0x48>
      return HAL_BUSY;
2400511a:	2002      	movs	r0, #2
2400511c:	e7f7      	b.n	2400510e <HAL_I2C_Master_Receive_IT+0x66>
2400511e:	bf00      	nop
24005120:	ffff0000 	.word	0xffff0000
24005124:	24006b4f 	.word	0x24006b4f
24005128:	80002400 	.word	0x80002400

2400512c <HAL_I2C_Slave_Transmit_IT>:
{
2400512c:	b570      	push	{r4, r5, r6, lr}
  if (hi2c->State == HAL_I2C_STATE_READY)
2400512e:	f890 4041 	ldrb.w	r4, [r0, #65]	@ 0x41
24005132:	2c20      	cmp	r4, #32
24005134:	b2e5      	uxtb	r5, r4
24005136:	d11f      	bne.n	24005178 <HAL_I2C_Slave_Transmit_IT+0x4c>
    __HAL_LOCK(hi2c);
24005138:	f890 4040 	ldrb.w	r4, [r0, #64]	@ 0x40
2400513c:	2c01      	cmp	r4, #1
2400513e:	d01b      	beq.n	24005178 <HAL_I2C_Slave_Transmit_IT+0x4c>
    hi2c->State       = HAL_I2C_STATE_BUSY_TX;
24005140:	2421      	movs	r4, #33	@ 0x21
    hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
24005142:	6806      	ldr	r6, [r0, #0]
    hi2c->State       = HAL_I2C_STATE_BUSY_TX;
24005144:	f880 4041 	strb.w	r4, [r0, #65]	@ 0x41
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
24005148:	2400      	movs	r4, #0
    hi2c->Mode        = HAL_I2C_MODE_SLAVE;
2400514a:	f880 5042 	strb.w	r5, [r0, #66]	@ 0x42
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
2400514e:	6444      	str	r4, [r0, #68]	@ 0x44
    hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
24005150:	6875      	ldr	r5, [r6, #4]
24005152:	f425 4500 	bic.w	r5, r5, #32768	@ 0x8000
24005156:	6075      	str	r5, [r6, #4]
    hi2c->XferCount   = Size;
24005158:	8542      	strh	r2, [r0, #42]	@ 0x2a
    hi2c->XferSize    = hi2c->XferCount;
2400515a:	8d42      	ldrh	r2, [r0, #42]	@ 0x2a
    hi2c->pBuffPtr    = pData;
2400515c:	6241      	str	r1, [r0, #36]	@ 0x24
    I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT | I2C_XFER_LISTEN_IT);
2400515e:	f248 0101 	movw	r1, #32769	@ 0x8001
    hi2c->XferSize    = hi2c->XferCount;
24005162:	8502      	strh	r2, [r0, #40]	@ 0x28
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
24005164:	4a05      	ldr	r2, [pc, #20]	@ (2400517c <HAL_I2C_Slave_Transmit_IT+0x50>)
    __HAL_UNLOCK(hi2c);
24005166:	f880 4040 	strb.w	r4, [r0, #64]	@ 0x40
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
2400516a:	62c2      	str	r2, [r0, #44]	@ 0x2c
    hi2c->XferISR     = I2C_Slave_ISR_IT;
2400516c:	4a04      	ldr	r2, [pc, #16]	@ (24005180 <HAL_I2C_Slave_Transmit_IT+0x54>)
2400516e:	6342      	str	r2, [r0, #52]	@ 0x34
    I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT | I2C_XFER_LISTEN_IT);
24005170:	f7ff fad0 	bl	24004714 <I2C_Enable_IRQ>
    return HAL_OK;
24005174:	4620      	mov	r0, r4
}
24005176:	bd70      	pop	{r4, r5, r6, pc}
    __HAL_LOCK(hi2c);
24005178:	2002      	movs	r0, #2
2400517a:	e7fc      	b.n	24005176 <HAL_I2C_Slave_Transmit_IT+0x4a>
2400517c:	ffff0000 	.word	0xffff0000
24005180:	24007259 	.word	0x24007259

24005184 <HAL_I2C_Slave_Receive_IT>:
{
24005184:	b570      	push	{r4, r5, r6, lr}
  if (hi2c->State == HAL_I2C_STATE_READY)
24005186:	f890 4041 	ldrb.w	r4, [r0, #65]	@ 0x41
2400518a:	2c20      	cmp	r4, #32
2400518c:	b2e5      	uxtb	r5, r4
2400518e:	d11f      	bne.n	240051d0 <HAL_I2C_Slave_Receive_IT+0x4c>
    __HAL_LOCK(hi2c);
24005190:	f890 4040 	ldrb.w	r4, [r0, #64]	@ 0x40
24005194:	2c01      	cmp	r4, #1
24005196:	d01b      	beq.n	240051d0 <HAL_I2C_Slave_Receive_IT+0x4c>
    hi2c->State       = HAL_I2C_STATE_BUSY_RX;
24005198:	2422      	movs	r4, #34	@ 0x22
    hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
2400519a:	6806      	ldr	r6, [r0, #0]
    hi2c->State       = HAL_I2C_STATE_BUSY_RX;
2400519c:	f880 4041 	strb.w	r4, [r0, #65]	@ 0x41
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
240051a0:	2400      	movs	r4, #0
    hi2c->Mode        = HAL_I2C_MODE_SLAVE;
240051a2:	f880 5042 	strb.w	r5, [r0, #66]	@ 0x42
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
240051a6:	6444      	str	r4, [r0, #68]	@ 0x44
    hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
240051a8:	6875      	ldr	r5, [r6, #4]
240051aa:	f425 4500 	bic.w	r5, r5, #32768	@ 0x8000
240051ae:	6075      	str	r5, [r6, #4]
    hi2c->XferCount   = Size;
240051b0:	8542      	strh	r2, [r0, #42]	@ 0x2a
    hi2c->XferSize    = hi2c->XferCount;
240051b2:	8d42      	ldrh	r2, [r0, #42]	@ 0x2a
    hi2c->pBuffPtr    = pData;
240051b4:	6241      	str	r1, [r0, #36]	@ 0x24
    I2C_Enable_IRQ(hi2c, I2C_XFER_RX_IT | I2C_XFER_LISTEN_IT);
240051b6:	f248 0102 	movw	r1, #32770	@ 0x8002
    hi2c->XferSize    = hi2c->XferCount;
240051ba:	8502      	strh	r2, [r0, #40]	@ 0x28
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
240051bc:	4a05      	ldr	r2, [pc, #20]	@ (240051d4 <HAL_I2C_Slave_Receive_IT+0x50>)
    __HAL_UNLOCK(hi2c);
240051be:	f880 4040 	strb.w	r4, [r0, #64]	@ 0x40
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
240051c2:	62c2      	str	r2, [r0, #44]	@ 0x2c
    hi2c->XferISR     = I2C_Slave_ISR_IT;
240051c4:	4a04      	ldr	r2, [pc, #16]	@ (240051d8 <HAL_I2C_Slave_Receive_IT+0x54>)
240051c6:	6342      	str	r2, [r0, #52]	@ 0x34
    I2C_Enable_IRQ(hi2c, I2C_XFER_RX_IT | I2C_XFER_LISTEN_IT);
240051c8:	f7ff faa4 	bl	24004714 <I2C_Enable_IRQ>
    return HAL_OK;
240051cc:	4620      	mov	r0, r4
}
240051ce:	bd70      	pop	{r4, r5, r6, pc}
    __HAL_LOCK(hi2c);
240051d0:	2002      	movs	r0, #2
240051d2:	e7fc      	b.n	240051ce <HAL_I2C_Slave_Receive_IT+0x4a>
240051d4:	ffff0000 	.word	0xffff0000
240051d8:	24007259 	.word	0x24007259

240051dc <HAL_I2C_Master_Transmit_DMA>:
{
240051dc:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
240051e0:	460e      	mov	r6, r1
240051e2:	4611      	mov	r1, r2
  if (hi2c->State == HAL_I2C_STATE_READY)
240051e4:	f890 2041 	ldrb.w	r2, [r0, #65]	@ 0x41
{
240051e8:	4604      	mov	r4, r0
  if (hi2c->State == HAL_I2C_STATE_READY)
240051ea:	2a20      	cmp	r2, #32
240051ec:	d17c      	bne.n	240052e8 <HAL_I2C_Master_Transmit_DMA+0x10c>
    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
240051ee:	6802      	ldr	r2, [r0, #0]
240051f0:	6990      	ldr	r0, [r2, #24]
240051f2:	f410 4000 	ands.w	r0, r0, #32768	@ 0x8000
240051f6:	d177      	bne.n	240052e8 <HAL_I2C_Master_Transmit_DMA+0x10c>
    __HAL_LOCK(hi2c);
240051f8:	f894 5040 	ldrb.w	r5, [r4, #64]	@ 0x40
240051fc:	2d01      	cmp	r5, #1
240051fe:	d073      	beq.n	240052e8 <HAL_I2C_Master_Transmit_DMA+0x10c>
24005200:	2501      	movs	r5, #1
    hi2c->pBuffPtr    = pData;
24005202:	6261      	str	r1, [r4, #36]	@ 0x24
    __HAL_LOCK(hi2c);
24005204:	f884 5040 	strb.w	r5, [r4, #64]	@ 0x40
    hi2c->State       = HAL_I2C_STATE_BUSY_TX;
24005208:	2521      	movs	r5, #33	@ 0x21
2400520a:	f884 5041 	strb.w	r5, [r4, #65]	@ 0x41
    hi2c->Mode        = HAL_I2C_MODE_MASTER;
2400520e:	2510      	movs	r5, #16
24005210:	f884 5042 	strb.w	r5, [r4, #66]	@ 0x42
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
24005214:	6460      	str	r0, [r4, #68]	@ 0x44
    hi2c->XferCount   = Size;
24005216:	8563      	strh	r3, [r4, #42]	@ 0x2a
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
24005218:	4b34      	ldr	r3, [pc, #208]	@ (240052ec <HAL_I2C_Master_Transmit_DMA+0x110>)
2400521a:	62e3      	str	r3, [r4, #44]	@ 0x2c
    hi2c->XferISR     = I2C_Master_ISR_DMA;
2400521c:	4b34      	ldr	r3, [pc, #208]	@ (240052f0 <HAL_I2C_Master_Transmit_DMA+0x114>)
2400521e:	6363      	str	r3, [r4, #52]	@ 0x34
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
24005220:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
24005222:	b29b      	uxth	r3, r3
24005224:	2bff      	cmp	r3, #255	@ 0xff
24005226:	d832      	bhi.n	2400528e <HAL_I2C_Master_Transmit_DMA+0xb2>
      hi2c->XferSize = hi2c->XferCount;
24005228:	8d65      	ldrh	r5, [r4, #42]	@ 0x2a
      xfermode = I2C_AUTOEND_MODE;
2400522a:	f04f 7800 	mov.w	r8, #33554432	@ 0x2000000
      hi2c->XferSize = hi2c->XferCount;
2400522e:	b2ad      	uxth	r5, r5
      xfermode = I2C_AUTOEND_MODE;
24005230:	8525      	strh	r5, [r4, #40]	@ 0x28
    if (hi2c->XferSize > 0U)
24005232:	2d00      	cmp	r5, #0
24005234:	d046      	beq.n	240052c4 <HAL_I2C_Master_Transmit_DMA+0xe8>
      if (hi2c->hdmatx != NULL)
24005236:	6ba0      	ldr	r0, [r4, #56]	@ 0x38
24005238:	b368      	cbz	r0, 24005296 <HAL_I2C_Master_Transmit_DMA+0xba>
        hi2c->hdmatx->XferCpltCallback = I2C_DMAMasterTransmitCplt;
2400523a:	4b2e      	ldr	r3, [pc, #184]	@ (240052f4 <HAL_I2C_Master_Transmit_DMA+0x118>)
        hi2c->hdmatx->XferHalfCpltCallback = NULL;
2400523c:	2700      	movs	r7, #0
        dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->TXDR, hi2c->XferSize);
2400523e:	3228      	adds	r2, #40	@ 0x28
        hi2c->hdmatx->XferCpltCallback = I2C_DMAMasterTransmitCplt;
24005240:	63c3      	str	r3, [r0, #60]	@ 0x3c
        hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
24005242:	4b2d      	ldr	r3, [pc, #180]	@ (240052f8 <HAL_I2C_Master_Transmit_DMA+0x11c>)
        hi2c->hdmatx->XferHalfCpltCallback = NULL;
24005244:	6407      	str	r7, [r0, #64]	@ 0x40
        hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
24005246:	64c3      	str	r3, [r0, #76]	@ 0x4c
        dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->TXDR, hi2c->XferSize);
24005248:	462b      	mov	r3, r5
        hi2c->hdmatx->XferAbortCallback = NULL;
2400524a:	6507      	str	r7, [r0, #80]	@ 0x50
        dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->TXDR, hi2c->XferSize);
2400524c:	f7fc fbc8 	bl	240019e0 <HAL_DMA_Start_IT>
      if (dmaxferstatus == HAL_OK)
24005250:	4605      	mov	r5, r0
24005252:	bb70      	cbnz	r0, 240052b2 <HAL_I2C_Master_Transmit_DMA+0xd6>
        I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, I2C_GENERATE_START_WRITE);
24005254:	4b29      	ldr	r3, [pc, #164]	@ (240052fc <HAL_I2C_Master_Transmit_DMA+0x120>)
24005256:	4631      	mov	r1, r6
24005258:	8d27      	ldrh	r7, [r4, #40]	@ 0x28
2400525a:	4620      	mov	r0, r4
2400525c:	9300      	str	r3, [sp, #0]
2400525e:	4643      	mov	r3, r8
24005260:	f894 2028 	ldrb.w	r2, [r4, #40]	@ 0x28
24005264:	f7ff fa42 	bl	240046ec <I2C_TransferConfig>
        hi2c->XferCount -= hi2c->XferSize;
24005268:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
        I2C_Enable_IRQ(hi2c, I2C_XFER_ERROR_IT);
2400526a:	2110      	movs	r1, #16
2400526c:	4620      	mov	r0, r4
        hi2c->XferCount -= hi2c->XferSize;
2400526e:	1bdb      	subs	r3, r3, r7
        __HAL_UNLOCK(hi2c);
24005270:	f884 5040 	strb.w	r5, [r4, #64]	@ 0x40
        hi2c->XferCount -= hi2c->XferSize;
24005274:	b29b      	uxth	r3, r3
24005276:	8563      	strh	r3, [r4, #42]	@ 0x2a
        I2C_Enable_IRQ(hi2c, I2C_XFER_ERROR_IT);
24005278:	f7ff fa4c 	bl	24004714 <I2C_Enable_IRQ>
        hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN;
2400527c:	6822      	ldr	r2, [r4, #0]
2400527e:	6813      	ldr	r3, [r2, #0]
24005280:	f443 4380 	orr.w	r3, r3, #16384	@ 0x4000
24005284:	6013      	str	r3, [r2, #0]
    return HAL_OK;
24005286:	2000      	movs	r0, #0
}
24005288:	b002      	add	sp, #8
2400528a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      hi2c->XferSize = MAX_NBYTE_SIZE;
2400528e:	25ff      	movs	r5, #255	@ 0xff
      xfermode = I2C_RELOAD_MODE;
24005290:	f04f 7880 	mov.w	r8, #16777216	@ 0x1000000
24005294:	e7cc      	b.n	24005230 <HAL_I2C_Master_Transmit_DMA+0x54>
        hi2c->State     = HAL_I2C_STATE_READY;
24005296:	2320      	movs	r3, #32
24005298:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
        hi2c->Mode      = HAL_I2C_MODE_NONE;
2400529c:	f884 0042 	strb.w	r0, [r4, #66]	@ 0x42
        hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
240052a0:	6c63      	ldr	r3, [r4, #68]	@ 0x44
240052a2:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
        hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
240052a6:	6463      	str	r3, [r4, #68]	@ 0x44
        __HAL_UNLOCK(hi2c);
240052a8:	2300      	movs	r3, #0
        return HAL_ERROR;
240052aa:	2001      	movs	r0, #1
        __HAL_UNLOCK(hi2c);
240052ac:	f884 3040 	strb.w	r3, [r4, #64]	@ 0x40
240052b0:	e7ea      	b.n	24005288 <HAL_I2C_Master_Transmit_DMA+0xac>
        hi2c->State     = HAL_I2C_STATE_READY;
240052b2:	2320      	movs	r3, #32
240052b4:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
        hi2c->Mode      = HAL_I2C_MODE_NONE;
240052b8:	f884 7042 	strb.w	r7, [r4, #66]	@ 0x42
        hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
240052bc:	6c63      	ldr	r3, [r4, #68]	@ 0x44
240052be:	f043 0310 	orr.w	r3, r3, #16
240052c2:	e7f0      	b.n	240052a6 <HAL_I2C_Master_Transmit_DMA+0xca>
      hi2c->XferISR = I2C_Master_ISR_IT;
240052c4:	4b0e      	ldr	r3, [pc, #56]	@ (24005300 <HAL_I2C_Master_Transmit_DMA+0x124>)
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_WRITE);
240052c6:	4631      	mov	r1, r6
240052c8:	4620      	mov	r0, r4
240052ca:	462a      	mov	r2, r5
      hi2c->XferISR = I2C_Master_ISR_IT;
240052cc:	6363      	str	r3, [r4, #52]	@ 0x34
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_WRITE);
240052ce:	4b0b      	ldr	r3, [pc, #44]	@ (240052fc <HAL_I2C_Master_Transmit_DMA+0x120>)
240052d0:	9300      	str	r3, [sp, #0]
240052d2:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
240052d6:	f7ff fa09 	bl	240046ec <I2C_TransferConfig>
      I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT);
240052da:	2101      	movs	r1, #1
240052dc:	4620      	mov	r0, r4
      __HAL_UNLOCK(hi2c);
240052de:	f884 5040 	strb.w	r5, [r4, #64]	@ 0x40
      I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT);
240052e2:	f7ff fa17 	bl	24004714 <I2C_Enable_IRQ>
240052e6:	e7ce      	b.n	24005286 <HAL_I2C_Master_Transmit_DMA+0xaa>
      return HAL_BUSY;
240052e8:	2002      	movs	r0, #2
240052ea:	e7cd      	b.n	24005288 <HAL_I2C_Master_Transmit_DMA+0xac>
240052ec:	ffff0000 	.word	0xffff0000
240052f0:	24006c71 	.word	0x24006c71
240052f4:	24006e55 	.word	0x24006e55
240052f8:	24006d75 	.word	0x24006d75
240052fc:	80002000 	.word	0x80002000
24005300:	24006b4f 	.word	0x24006b4f

24005304 <HAL_I2C_Master_Receive_DMA>:
{
24005304:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
24005308:	460e      	mov	r6, r1
  if (hi2c->State == HAL_I2C_STATE_READY)
2400530a:	f890 1041 	ldrb.w	r1, [r0, #65]	@ 0x41
{
2400530e:	4604      	mov	r4, r0
  if (hi2c->State == HAL_I2C_STATE_READY)
24005310:	2920      	cmp	r1, #32
24005312:	d17c      	bne.n	2400540e <HAL_I2C_Master_Receive_DMA+0x10a>
    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
24005314:	6801      	ldr	r1, [r0, #0]
24005316:	6988      	ldr	r0, [r1, #24]
24005318:	f410 4000 	ands.w	r0, r0, #32768	@ 0x8000
2400531c:	d177      	bne.n	2400540e <HAL_I2C_Master_Receive_DMA+0x10a>
    __HAL_LOCK(hi2c);
2400531e:	f894 5040 	ldrb.w	r5, [r4, #64]	@ 0x40
24005322:	2d01      	cmp	r5, #1
24005324:	d073      	beq.n	2400540e <HAL_I2C_Master_Receive_DMA+0x10a>
24005326:	2501      	movs	r5, #1
    hi2c->pBuffPtr    = pData;
24005328:	6262      	str	r2, [r4, #36]	@ 0x24
    __HAL_LOCK(hi2c);
2400532a:	f884 5040 	strb.w	r5, [r4, #64]	@ 0x40
    hi2c->State       = HAL_I2C_STATE_BUSY_RX;
2400532e:	2522      	movs	r5, #34	@ 0x22
24005330:	f884 5041 	strb.w	r5, [r4, #65]	@ 0x41
    hi2c->Mode        = HAL_I2C_MODE_MASTER;
24005334:	2510      	movs	r5, #16
24005336:	f884 5042 	strb.w	r5, [r4, #66]	@ 0x42
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
2400533a:	6460      	str	r0, [r4, #68]	@ 0x44
    hi2c->XferCount   = Size;
2400533c:	8563      	strh	r3, [r4, #42]	@ 0x2a
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
2400533e:	4b35      	ldr	r3, [pc, #212]	@ (24005414 <HAL_I2C_Master_Receive_DMA+0x110>)
24005340:	62e3      	str	r3, [r4, #44]	@ 0x2c
    hi2c->XferISR     = I2C_Master_ISR_DMA;
24005342:	4b35      	ldr	r3, [pc, #212]	@ (24005418 <HAL_I2C_Master_Receive_DMA+0x114>)
24005344:	6363      	str	r3, [r4, #52]	@ 0x34
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
24005346:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
24005348:	b29b      	uxth	r3, r3
2400534a:	2bff      	cmp	r3, #255	@ 0xff
2400534c:	d832      	bhi.n	240053b4 <HAL_I2C_Master_Receive_DMA+0xb0>
      hi2c->XferSize = hi2c->XferCount;
2400534e:	8d65      	ldrh	r5, [r4, #42]	@ 0x2a
      xfermode = I2C_AUTOEND_MODE;
24005350:	f04f 7800 	mov.w	r8, #33554432	@ 0x2000000
      hi2c->XferSize = hi2c->XferCount;
24005354:	b2ad      	uxth	r5, r5
      xfermode = I2C_AUTOEND_MODE;
24005356:	8525      	strh	r5, [r4, #40]	@ 0x28
    if (hi2c->XferSize > 0U)
24005358:	2d00      	cmp	r5, #0
2400535a:	d046      	beq.n	240053ea <HAL_I2C_Master_Receive_DMA+0xe6>
      if (hi2c->hdmarx != NULL)
2400535c:	6be0      	ldr	r0, [r4, #60]	@ 0x3c
2400535e:	b368      	cbz	r0, 240053bc <HAL_I2C_Master_Receive_DMA+0xb8>
        hi2c->hdmarx->XferCpltCallback = I2C_DMAMasterReceiveCplt;
24005360:	4b2e      	ldr	r3, [pc, #184]	@ (2400541c <HAL_I2C_Master_Receive_DMA+0x118>)
        hi2c->hdmarx->XferHalfCpltCallback = NULL;
24005362:	2700      	movs	r7, #0
        dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)pData, hi2c->XferSize);
24005364:	3124      	adds	r1, #36	@ 0x24
        hi2c->hdmarx->XferCpltCallback = I2C_DMAMasterReceiveCplt;
24005366:	63c3      	str	r3, [r0, #60]	@ 0x3c
        hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
24005368:	4b2d      	ldr	r3, [pc, #180]	@ (24005420 <HAL_I2C_Master_Receive_DMA+0x11c>)
        hi2c->hdmarx->XferHalfCpltCallback = NULL;
2400536a:	6407      	str	r7, [r0, #64]	@ 0x40
        hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
2400536c:	64c3      	str	r3, [r0, #76]	@ 0x4c
        dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)pData, hi2c->XferSize);
2400536e:	462b      	mov	r3, r5
        hi2c->hdmarx->XferAbortCallback = NULL;
24005370:	6507      	str	r7, [r0, #80]	@ 0x50
        dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)pData, hi2c->XferSize);
24005372:	f7fc fb35 	bl	240019e0 <HAL_DMA_Start_IT>
      if (dmaxferstatus == HAL_OK)
24005376:	4605      	mov	r5, r0
24005378:	bb70      	cbnz	r0, 240053d8 <HAL_I2C_Master_Receive_DMA+0xd4>
        I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, I2C_GENERATE_START_READ);
2400537a:	4b2a      	ldr	r3, [pc, #168]	@ (24005424 <HAL_I2C_Master_Receive_DMA+0x120>)
2400537c:	4631      	mov	r1, r6
2400537e:	8d27      	ldrh	r7, [r4, #40]	@ 0x28
24005380:	4620      	mov	r0, r4
24005382:	9300      	str	r3, [sp, #0]
24005384:	4643      	mov	r3, r8
24005386:	f894 2028 	ldrb.w	r2, [r4, #40]	@ 0x28
2400538a:	f7ff f9af 	bl	240046ec <I2C_TransferConfig>
        hi2c->XferCount -= hi2c->XferSize;
2400538e:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
        I2C_Enable_IRQ(hi2c, I2C_XFER_ERROR_IT);
24005390:	2110      	movs	r1, #16
24005392:	4620      	mov	r0, r4
        hi2c->XferCount -= hi2c->XferSize;
24005394:	1bdb      	subs	r3, r3, r7
        __HAL_UNLOCK(hi2c);
24005396:	f884 5040 	strb.w	r5, [r4, #64]	@ 0x40
        hi2c->XferCount -= hi2c->XferSize;
2400539a:	b29b      	uxth	r3, r3
2400539c:	8563      	strh	r3, [r4, #42]	@ 0x2a
        I2C_Enable_IRQ(hi2c, I2C_XFER_ERROR_IT);
2400539e:	f7ff f9b9 	bl	24004714 <I2C_Enable_IRQ>
        hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;
240053a2:	6822      	ldr	r2, [r4, #0]
240053a4:	6813      	ldr	r3, [r2, #0]
240053a6:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
240053aa:	6013      	str	r3, [r2, #0]
    return HAL_OK;
240053ac:	2000      	movs	r0, #0
}
240053ae:	b002      	add	sp, #8
240053b0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      hi2c->XferSize = MAX_NBYTE_SIZE;
240053b4:	25ff      	movs	r5, #255	@ 0xff
      xfermode = I2C_RELOAD_MODE;
240053b6:	f04f 7880 	mov.w	r8, #16777216	@ 0x1000000
240053ba:	e7cc      	b.n	24005356 <HAL_I2C_Master_Receive_DMA+0x52>
        hi2c->State     = HAL_I2C_STATE_READY;
240053bc:	2320      	movs	r3, #32
240053be:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
        hi2c->Mode      = HAL_I2C_MODE_NONE;
240053c2:	f884 0042 	strb.w	r0, [r4, #66]	@ 0x42
        hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
240053c6:	6c63      	ldr	r3, [r4, #68]	@ 0x44
240053c8:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
        hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
240053cc:	6463      	str	r3, [r4, #68]	@ 0x44
        __HAL_UNLOCK(hi2c);
240053ce:	2300      	movs	r3, #0
        return HAL_ERROR;
240053d0:	2001      	movs	r0, #1
        __HAL_UNLOCK(hi2c);
240053d2:	f884 3040 	strb.w	r3, [r4, #64]	@ 0x40
240053d6:	e7ea      	b.n	240053ae <HAL_I2C_Master_Receive_DMA+0xaa>
        hi2c->State     = HAL_I2C_STATE_READY;
240053d8:	2320      	movs	r3, #32
240053da:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
        hi2c->Mode      = HAL_I2C_MODE_NONE;
240053de:	f884 7042 	strb.w	r7, [r4, #66]	@ 0x42
        hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
240053e2:	6c63      	ldr	r3, [r4, #68]	@ 0x44
240053e4:	f043 0310 	orr.w	r3, r3, #16
240053e8:	e7f0      	b.n	240053cc <HAL_I2C_Master_Receive_DMA+0xc8>
      hi2c->XferISR = I2C_Master_ISR_IT;
240053ea:	4b0f      	ldr	r3, [pc, #60]	@ (24005428 <HAL_I2C_Master_Receive_DMA+0x124>)
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_READ);
240053ec:	4631      	mov	r1, r6
240053ee:	4620      	mov	r0, r4
240053f0:	462a      	mov	r2, r5
      hi2c->XferISR = I2C_Master_ISR_IT;
240053f2:	6363      	str	r3, [r4, #52]	@ 0x34
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_READ);
240053f4:	4b0b      	ldr	r3, [pc, #44]	@ (24005424 <HAL_I2C_Master_Receive_DMA+0x120>)
240053f6:	9300      	str	r3, [sp, #0]
240053f8:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
240053fc:	f7ff f976 	bl	240046ec <I2C_TransferConfig>
      I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT);
24005400:	2101      	movs	r1, #1
24005402:	4620      	mov	r0, r4
      __HAL_UNLOCK(hi2c);
24005404:	f884 5040 	strb.w	r5, [r4, #64]	@ 0x40
      I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT);
24005408:	f7ff f984 	bl	24004714 <I2C_Enable_IRQ>
2400540c:	e7ce      	b.n	240053ac <HAL_I2C_Master_Receive_DMA+0xa8>
      return HAL_BUSY;
2400540e:	2002      	movs	r0, #2
24005410:	e7cd      	b.n	240053ae <HAL_I2C_Master_Receive_DMA+0xaa>
24005412:	bf00      	nop
24005414:	ffff0000 	.word	0xffff0000
24005418:	24006c71 	.word	0x24006c71
2400541c:	24006ea7 	.word	0x24006ea7
24005420:	24006d75 	.word	0x24006d75
24005424:	80002400 	.word	0x80002400
24005428:	24006b4f 	.word	0x24006b4f

2400542c <HAL_I2C_Slave_Transmit_DMA>:
{
2400542c:	b570      	push	{r4, r5, r6, lr}
2400542e:	4604      	mov	r4, r0
  if (hi2c->State == HAL_I2C_STATE_READY)
24005430:	f890 0041 	ldrb.w	r0, [r0, #65]	@ 0x41
24005434:	2820      	cmp	r0, #32
24005436:	b2c5      	uxtb	r5, r0
24005438:	d155      	bne.n	240054e6 <HAL_I2C_Slave_Transmit_DMA+0xba>
    if ((pData == NULL) || (Size == 0U))
2400543a:	b101      	cbz	r1, 2400543e <HAL_I2C_Slave_Transmit_DMA+0x12>
2400543c:	b92a      	cbnz	r2, 2400544a <HAL_I2C_Slave_Transmit_DMA+0x1e>
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
2400543e:	f44f 7300 	mov.w	r3, #512	@ 0x200
24005442:	6463      	str	r3, [r4, #68]	@ 0x44
      return  HAL_ERROR;
24005444:	2501      	movs	r5, #1
}
24005446:	4628      	mov	r0, r5
24005448:	bd70      	pop	{r4, r5, r6, pc}
    __HAL_LOCK(hi2c);
2400544a:	f894 0040 	ldrb.w	r0, [r4, #64]	@ 0x40
2400544e:	2801      	cmp	r0, #1
24005450:	d049      	beq.n	240054e6 <HAL_I2C_Slave_Transmit_DMA+0xba>
24005452:	2001      	movs	r0, #1
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
24005454:	2600      	movs	r6, #0
    hi2c->pBuffPtr    = pData;
24005456:	6261      	str	r1, [r4, #36]	@ 0x24
    __HAL_LOCK(hi2c);
24005458:	f884 0040 	strb.w	r0, [r4, #64]	@ 0x40
    hi2c->State       = HAL_I2C_STATE_BUSY_TX;
2400545c:	2021      	movs	r0, #33	@ 0x21
2400545e:	f884 0041 	strb.w	r0, [r4, #65]	@ 0x41
    hi2c->Mode        = HAL_I2C_MODE_SLAVE;
24005462:	f884 5042 	strb.w	r5, [r4, #66]	@ 0x42
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
24005466:	6466      	str	r6, [r4, #68]	@ 0x44
    hi2c->XferCount   = Size;
24005468:	8562      	strh	r2, [r4, #42]	@ 0x2a
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
2400546a:	4a20      	ldr	r2, [pc, #128]	@ (240054ec <HAL_I2C_Slave_Transmit_DMA+0xc0>)
    hi2c->XferSize    = hi2c->XferCount;
2400546c:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
    if (hi2c->hdmatx != NULL)
2400546e:	6ba0      	ldr	r0, [r4, #56]	@ 0x38
    hi2c->XferSize    = hi2c->XferCount;
24005470:	b29b      	uxth	r3, r3
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
24005472:	62e2      	str	r2, [r4, #44]	@ 0x2c
    hi2c->XferISR     = I2C_Slave_ISR_DMA;
24005474:	4a1e      	ldr	r2, [pc, #120]	@ (240054f0 <HAL_I2C_Slave_Transmit_DMA+0xc4>)
    hi2c->XferSize    = hi2c->XferCount;
24005476:	8523      	strh	r3, [r4, #40]	@ 0x28
    hi2c->XferISR     = I2C_Slave_ISR_DMA;
24005478:	6362      	str	r2, [r4, #52]	@ 0x34
    if (hi2c->hdmatx != NULL)
2400547a:	b1e0      	cbz	r0, 240054b6 <HAL_I2C_Slave_Transmit_DMA+0x8a>
      hi2c->hdmatx->XferCpltCallback = I2C_DMASlaveTransmitCplt;
2400547c:	4a1d      	ldr	r2, [pc, #116]	@ (240054f4 <HAL_I2C_Slave_Transmit_DMA+0xc8>)
      hi2c->hdmatx->XferHalfCpltCallback = NULL;
2400547e:	6406      	str	r6, [r0, #64]	@ 0x40
      hi2c->hdmatx->XferCpltCallback = I2C_DMASlaveTransmitCplt;
24005480:	63c2      	str	r2, [r0, #60]	@ 0x3c
      hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
24005482:	4a1d      	ldr	r2, [pc, #116]	@ (240054f8 <HAL_I2C_Slave_Transmit_DMA+0xcc>)
      hi2c->hdmatx->XferAbortCallback = NULL;
24005484:	6506      	str	r6, [r0, #80]	@ 0x50
      hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
24005486:	64c2      	str	r2, [r0, #76]	@ 0x4c
      dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->TXDR, hi2c->XferSize);
24005488:	6822      	ldr	r2, [r4, #0]
2400548a:	3228      	adds	r2, #40	@ 0x28
2400548c:	f7fc faa8 	bl	240019e0 <HAL_DMA_Start_IT>
    if (dmaxferstatus == HAL_OK)
24005490:	4605      	mov	r5, r0
24005492:	b9e0      	cbnz	r0, 240054ce <HAL_I2C_Slave_Transmit_DMA+0xa2>
      hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
24005494:	6826      	ldr	r6, [r4, #0]
      I2C_Enable_IRQ(hi2c, I2C_XFER_LISTEN_IT);
24005496:	f44f 4100 	mov.w	r1, #32768	@ 0x8000
      hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
2400549a:	6873      	ldr	r3, [r6, #4]
2400549c:	f423 4300 	bic.w	r3, r3, #32768	@ 0x8000
240054a0:	6073      	str	r3, [r6, #4]
      __HAL_UNLOCK(hi2c);
240054a2:	f884 0040 	strb.w	r0, [r4, #64]	@ 0x40
      I2C_Enable_IRQ(hi2c, I2C_XFER_LISTEN_IT);
240054a6:	4620      	mov	r0, r4
240054a8:	f7ff f934 	bl	24004714 <I2C_Enable_IRQ>
      hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN;
240054ac:	6833      	ldr	r3, [r6, #0]
240054ae:	f443 4380 	orr.w	r3, r3, #16384	@ 0x4000
240054b2:	6033      	str	r3, [r6, #0]
    return HAL_OK;
240054b4:	e7c7      	b.n	24005446 <HAL_I2C_Slave_Transmit_DMA+0x1a>
      hi2c->State     = HAL_I2C_STATE_LISTEN;
240054b6:	2328      	movs	r3, #40	@ 0x28
      __HAL_UNLOCK(hi2c);
240054b8:	f884 0040 	strb.w	r0, [r4, #64]	@ 0x40
      hi2c->State     = HAL_I2C_STATE_LISTEN;
240054bc:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
      hi2c->Mode      = HAL_I2C_MODE_NONE;
240054c0:	f884 0042 	strb.w	r0, [r4, #66]	@ 0x42
      hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
240054c4:	6c63      	ldr	r3, [r4, #68]	@ 0x44
240054c6:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
240054ca:	6463      	str	r3, [r4, #68]	@ 0x44
      return HAL_ERROR;
240054cc:	e7ba      	b.n	24005444 <HAL_I2C_Slave_Transmit_DMA+0x18>
      hi2c->State     = HAL_I2C_STATE_LISTEN;
240054ce:	2328      	movs	r3, #40	@ 0x28
      __HAL_UNLOCK(hi2c);
240054d0:	f884 6040 	strb.w	r6, [r4, #64]	@ 0x40
      hi2c->State     = HAL_I2C_STATE_LISTEN;
240054d4:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
      hi2c->Mode      = HAL_I2C_MODE_NONE;
240054d8:	f884 6042 	strb.w	r6, [r4, #66]	@ 0x42
      hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
240054dc:	6c63      	ldr	r3, [r4, #68]	@ 0x44
240054de:	f043 0310 	orr.w	r3, r3, #16
240054e2:	6463      	str	r3, [r4, #68]	@ 0x44
      return HAL_ERROR;
240054e4:	e7ae      	b.n	24005444 <HAL_I2C_Slave_Transmit_DMA+0x18>
    __HAL_LOCK(hi2c);
240054e6:	2502      	movs	r5, #2
240054e8:	e7ad      	b.n	24005446 <HAL_I2C_Slave_Transmit_DMA+0x1a>
240054ea:	bf00      	nop
240054ec:	ffff0000 	.word	0xffff0000
240054f0:	240070c9 	.word	0x240070c9
240054f4:	240067c3 	.word	0x240067c3
240054f8:	24006d75 	.word	0x24006d75

240054fc <HAL_I2C_Slave_Receive_DMA>:
{
240054fc:	b570      	push	{r4, r5, r6, lr}
  if (hi2c->State == HAL_I2C_STATE_READY)
240054fe:	f890 3041 	ldrb.w	r3, [r0, #65]	@ 0x41
{
24005502:	4604      	mov	r4, r0
  if (hi2c->State == HAL_I2C_STATE_READY)
24005504:	2b20      	cmp	r3, #32
24005506:	b2d8      	uxtb	r0, r3
24005508:	d157      	bne.n	240055ba <HAL_I2C_Slave_Receive_DMA+0xbe>
    if ((pData == NULL) || (Size == 0U))
2400550a:	b101      	cbz	r1, 2400550e <HAL_I2C_Slave_Receive_DMA+0x12>
2400550c:	b92a      	cbnz	r2, 2400551a <HAL_I2C_Slave_Receive_DMA+0x1e>
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
2400550e:	f44f 7300 	mov.w	r3, #512	@ 0x200
24005512:	6463      	str	r3, [r4, #68]	@ 0x44
      return  HAL_ERROR;
24005514:	2501      	movs	r5, #1
}
24005516:	4628      	mov	r0, r5
24005518:	bd70      	pop	{r4, r5, r6, pc}
    __HAL_LOCK(hi2c);
2400551a:	f894 3040 	ldrb.w	r3, [r4, #64]	@ 0x40
2400551e:	2b01      	cmp	r3, #1
24005520:	d04b      	beq.n	240055ba <HAL_I2C_Slave_Receive_DMA+0xbe>
24005522:	2301      	movs	r3, #1
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
24005524:	2600      	movs	r6, #0
    hi2c->pBuffPtr    = pData;
24005526:	6261      	str	r1, [r4, #36]	@ 0x24
    __HAL_LOCK(hi2c);
24005528:	f884 3040 	strb.w	r3, [r4, #64]	@ 0x40
    hi2c->State       = HAL_I2C_STATE_BUSY_RX;
2400552c:	2322      	movs	r3, #34	@ 0x22
2400552e:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
    hi2c->Mode        = HAL_I2C_MODE_SLAVE;
24005532:	f884 0042 	strb.w	r0, [r4, #66]	@ 0x42
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
24005536:	6466      	str	r6, [r4, #68]	@ 0x44
    hi2c->XferCount   = Size;
24005538:	8562      	strh	r2, [r4, #42]	@ 0x2a
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
2400553a:	4a21      	ldr	r2, [pc, #132]	@ (240055c0 <HAL_I2C_Slave_Receive_DMA+0xc4>)
    hi2c->XferSize    = hi2c->XferCount;
2400553c:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
    if (hi2c->hdmarx != NULL)
2400553e:	6be0      	ldr	r0, [r4, #60]	@ 0x3c
    hi2c->XferSize    = hi2c->XferCount;
24005540:	b29b      	uxth	r3, r3
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
24005542:	62e2      	str	r2, [r4, #44]	@ 0x2c
    hi2c->XferISR     = I2C_Slave_ISR_DMA;
24005544:	4a1f      	ldr	r2, [pc, #124]	@ (240055c4 <HAL_I2C_Slave_Receive_DMA+0xc8>)
    hi2c->XferSize    = hi2c->XferCount;
24005546:	8523      	strh	r3, [r4, #40]	@ 0x28
    hi2c->XferISR     = I2C_Slave_ISR_DMA;
24005548:	6362      	str	r2, [r4, #52]	@ 0x34
    if (hi2c->hdmarx != NULL)
2400554a:	b1f0      	cbz	r0, 2400558a <HAL_I2C_Slave_Receive_DMA+0x8e>
      hi2c->hdmarx->XferCpltCallback = I2C_DMASlaveReceiveCplt;
2400554c:	4a1e      	ldr	r2, [pc, #120]	@ (240055c8 <HAL_I2C_Slave_Receive_DMA+0xcc>)
      dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)pData, hi2c->XferSize);
2400554e:	6825      	ldr	r5, [r4, #0]
      hi2c->hdmarx->XferCpltCallback = I2C_DMASlaveReceiveCplt;
24005550:	63c2      	str	r2, [r0, #60]	@ 0x3c
      hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
24005552:	4a1e      	ldr	r2, [pc, #120]	@ (240055cc <HAL_I2C_Slave_Receive_DMA+0xd0>)
      hi2c->hdmarx->XferHalfCpltCallback = NULL;
24005554:	6406      	str	r6, [r0, #64]	@ 0x40
      hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
24005556:	64c2      	str	r2, [r0, #76]	@ 0x4c
      dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)pData, hi2c->XferSize);
24005558:	460a      	mov	r2, r1
      hi2c->hdmarx->XferAbortCallback = NULL;
2400555a:	6506      	str	r6, [r0, #80]	@ 0x50
      dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)pData, hi2c->XferSize);
2400555c:	f105 0124 	add.w	r1, r5, #36	@ 0x24
24005560:	f7fc fa3e 	bl	240019e0 <HAL_DMA_Start_IT>
    if (dmaxferstatus == HAL_OK)
24005564:	4605      	mov	r5, r0
24005566:	b9e0      	cbnz	r0, 240055a2 <HAL_I2C_Slave_Receive_DMA+0xa6>
      hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
24005568:	6826      	ldr	r6, [r4, #0]
      I2C_Enable_IRQ(hi2c, I2C_XFER_LISTEN_IT);
2400556a:	f44f 4100 	mov.w	r1, #32768	@ 0x8000
      hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
2400556e:	6873      	ldr	r3, [r6, #4]
24005570:	f423 4300 	bic.w	r3, r3, #32768	@ 0x8000
24005574:	6073      	str	r3, [r6, #4]
      __HAL_UNLOCK(hi2c);
24005576:	f884 0040 	strb.w	r0, [r4, #64]	@ 0x40
      I2C_Enable_IRQ(hi2c, I2C_XFER_LISTEN_IT);
2400557a:	4620      	mov	r0, r4
2400557c:	f7ff f8ca 	bl	24004714 <I2C_Enable_IRQ>
      hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;
24005580:	6833      	ldr	r3, [r6, #0]
24005582:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
24005586:	6033      	str	r3, [r6, #0]
    return HAL_OK;
24005588:	e7c5      	b.n	24005516 <HAL_I2C_Slave_Receive_DMA+0x1a>
      hi2c->State     = HAL_I2C_STATE_LISTEN;
2400558a:	2328      	movs	r3, #40	@ 0x28
      __HAL_UNLOCK(hi2c);
2400558c:	f884 0040 	strb.w	r0, [r4, #64]	@ 0x40
      hi2c->State     = HAL_I2C_STATE_LISTEN;
24005590:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
      hi2c->Mode      = HAL_I2C_MODE_NONE;
24005594:	f884 0042 	strb.w	r0, [r4, #66]	@ 0x42
      hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
24005598:	6c63      	ldr	r3, [r4, #68]	@ 0x44
2400559a:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
2400559e:	6463      	str	r3, [r4, #68]	@ 0x44
      return HAL_ERROR;
240055a0:	e7b8      	b.n	24005514 <HAL_I2C_Slave_Receive_DMA+0x18>
      hi2c->State     = HAL_I2C_STATE_LISTEN;
240055a2:	2328      	movs	r3, #40	@ 0x28
      __HAL_UNLOCK(hi2c);
240055a4:	f884 6040 	strb.w	r6, [r4, #64]	@ 0x40
      hi2c->State     = HAL_I2C_STATE_LISTEN;
240055a8:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
      hi2c->Mode      = HAL_I2C_MODE_NONE;
240055ac:	f884 6042 	strb.w	r6, [r4, #66]	@ 0x42
      hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
240055b0:	6c63      	ldr	r3, [r4, #68]	@ 0x44
240055b2:	f043 0310 	orr.w	r3, r3, #16
240055b6:	6463      	str	r3, [r4, #68]	@ 0x44
      return HAL_ERROR;
240055b8:	e7ac      	b.n	24005514 <HAL_I2C_Slave_Receive_DMA+0x18>
    __HAL_LOCK(hi2c);
240055ba:	2502      	movs	r5, #2
240055bc:	e7ab      	b.n	24005516 <HAL_I2C_Slave_Receive_DMA+0x1a>
240055be:	bf00      	nop
240055c0:	ffff0000 	.word	0xffff0000
240055c4:	240070c9 	.word	0x240070c9
240055c8:	240067db 	.word	0x240067db
240055cc:	24006d75 	.word	0x24006d75

240055d0 <HAL_I2C_Mem_Write>:
{
240055d0:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
240055d4:	469a      	mov	sl, r3
  if (hi2c->State == HAL_I2C_STATE_READY)
240055d6:	f890 3041 	ldrb.w	r3, [r0, #65]	@ 0x41
{
240055da:	4604      	mov	r4, r0
240055dc:	460e      	mov	r6, r1
  if (hi2c->State == HAL_I2C_STATE_READY)
240055de:	2b20      	cmp	r3, #32
{
240055e0:	4691      	mov	r9, r2
240055e2:	f8bd b034 	ldrh.w	fp, [sp, #52]	@ 0x34
240055e6:	f8dd 8038 	ldr.w	r8, [sp, #56]	@ 0x38
  if (hi2c->State == HAL_I2C_STATE_READY)
240055ea:	f040 80a4 	bne.w	24005736 <HAL_I2C_Mem_Write+0x166>
    if ((pData == NULL) || (Size == 0U))
240055ee:	9b0c      	ldr	r3, [sp, #48]	@ 0x30
240055f0:	b113      	cbz	r3, 240055f8 <HAL_I2C_Mem_Write+0x28>
240055f2:	f1bb 0f00 	cmp.w	fp, #0
240055f6:	d106      	bne.n	24005606 <HAL_I2C_Mem_Write+0x36>
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
240055f8:	f44f 7300 	mov.w	r3, #512	@ 0x200
240055fc:	6463      	str	r3, [r4, #68]	@ 0x44
      return  HAL_ERROR;
240055fe:	2001      	movs	r0, #1
}
24005600:	b003      	add	sp, #12
24005602:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    __HAL_LOCK(hi2c);
24005606:	f890 3040 	ldrb.w	r3, [r0, #64]	@ 0x40
2400560a:	2b01      	cmp	r3, #1
2400560c:	f000 8093 	beq.w	24005736 <HAL_I2C_Mem_Write+0x166>
24005610:	2701      	movs	r7, #1
24005612:	f880 7040 	strb.w	r7, [r0, #64]	@ 0x40
    tickstart = HAL_GetTick();
24005616:	f00c fbf7 	bl	24011e08 <HAL_GetTick>
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
2400561a:	463a      	mov	r2, r7
2400561c:	9000      	str	r0, [sp, #0]
    tickstart = HAL_GetTick();
2400561e:	4605      	mov	r5, r0
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
24005620:	2319      	movs	r3, #25
24005622:	f44f 4100 	mov.w	r1, #32768	@ 0x8000
24005626:	4620      	mov	r0, r4
24005628:	f7ff f9a0 	bl	2400496c <I2C_WaitOnFlagUntilTimeout>
2400562c:	4607      	mov	r7, r0
2400562e:	2800      	cmp	r0, #0
24005630:	d1e5      	bne.n	240055fe <HAL_I2C_Mem_Write+0x2e>
    hi2c->State     = HAL_I2C_STATE_BUSY_TX;
24005632:	2321      	movs	r3, #33	@ 0x21
    hi2c->XferISR   = NULL;
24005634:	6360      	str	r0, [r4, #52]	@ 0x34
    if (I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
24005636:	464a      	mov	r2, r9
24005638:	4631      	mov	r1, r6
    hi2c->State     = HAL_I2C_STATE_BUSY_TX;
2400563a:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
    hi2c->Mode      = HAL_I2C_MODE_MEM;
2400563e:	2340      	movs	r3, #64	@ 0x40
24005640:	f884 3042 	strb.w	r3, [r4, #66]	@ 0x42
    hi2c->pBuffPtr  = pData;
24005644:	9b0c      	ldr	r3, [sp, #48]	@ 0x30
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
24005646:	6460      	str	r0, [r4, #68]	@ 0x44
    if (I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
24005648:	4620      	mov	r0, r4
    hi2c->pBuffPtr  = pData;
2400564a:	6263      	str	r3, [r4, #36]	@ 0x24
    if (I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
2400564c:	4653      	mov	r3, sl
    hi2c->XferCount = Size;
2400564e:	f8a4 b02a 	strh.w	fp, [r4, #42]	@ 0x2a
    if (I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
24005652:	e9cd 8500 	strd	r8, r5, [sp]
24005656:	f7ff f9b3 	bl	240049c0 <I2C_RequestMemoryWrite>
2400565a:	b110      	cbz	r0, 24005662 <HAL_I2C_Mem_Write+0x92>
      __HAL_UNLOCK(hi2c);
2400565c:	f884 7040 	strb.w	r7, [r4, #64]	@ 0x40
      return HAL_ERROR;
24005660:	e7cd      	b.n	240055fe <HAL_I2C_Mem_Write+0x2e>
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
24005662:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
24005664:	b29b      	uxth	r3, r3
24005666:	2bff      	cmp	r3, #255	@ 0xff
24005668:	d955      	bls.n	24005716 <HAL_I2C_Mem_Write+0x146>
      hi2c->XferSize = MAX_NBYTE_SIZE;
2400566a:	22ff      	movs	r2, #255	@ 0xff
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
2400566c:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
      hi2c->XferSize = MAX_NBYTE_SIZE;
24005670:	8522      	strh	r2, [r4, #40]	@ 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
24005672:	9000      	str	r0, [sp, #0]
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
24005674:	4631      	mov	r1, r6
24005676:	4620      	mov	r0, r4
24005678:	f7ff f838 	bl	240046ec <I2C_TransferConfig>
      if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
2400567c:	462a      	mov	r2, r5
2400567e:	4641      	mov	r1, r8
24005680:	4620      	mov	r0, r4
24005682:	f7ff f8e8 	bl	24004856 <I2C_WaitOnTXISFlagUntilTimeout>
24005686:	2800      	cmp	r0, #0
24005688:	d1b9      	bne.n	240055fe <HAL_I2C_Mem_Write+0x2e>
      hi2c->Instance->TXDR = *hi2c->pBuffPtr;
2400568a:	6a63      	ldr	r3, [r4, #36]	@ 0x24
2400568c:	6822      	ldr	r2, [r4, #0]
2400568e:	f813 1b01 	ldrb.w	r1, [r3], #1
24005692:	6291      	str	r1, [r2, #40]	@ 0x28
      hi2c->pBuffPtr++;
24005694:	6263      	str	r3, [r4, #36]	@ 0x24
      hi2c->XferCount--;
24005696:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
      hi2c->XferSize--;
24005698:	8d22      	ldrh	r2, [r4, #40]	@ 0x28
      hi2c->XferCount--;
2400569a:	3b01      	subs	r3, #1
      hi2c->XferSize--;
2400569c:	3a01      	subs	r2, #1
      hi2c->XferCount--;
2400569e:	b29b      	uxth	r3, r3
      hi2c->XferSize--;
240056a0:	b292      	uxth	r2, r2
      hi2c->XferCount--;
240056a2:	8563      	strh	r3, [r4, #42]	@ 0x2a
      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
240056a4:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
      hi2c->XferSize--;
240056a6:	8522      	strh	r2, [r4, #40]	@ 0x28
      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
240056a8:	b29b      	uxth	r3, r3
240056aa:	b1ab      	cbz	r3, 240056d8 <HAL_I2C_Mem_Write+0x108>
240056ac:	b9a2      	cbnz	r2, 240056d8 <HAL_I2C_Mem_Write+0x108>
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
240056ae:	4643      	mov	r3, r8
240056b0:	2180      	movs	r1, #128	@ 0x80
240056b2:	4620      	mov	r0, r4
240056b4:	9500      	str	r5, [sp, #0]
240056b6:	f7ff f959 	bl	2400496c <I2C_WaitOnFlagUntilTimeout>
240056ba:	2800      	cmp	r0, #0
240056bc:	d19f      	bne.n	240055fe <HAL_I2C_Mem_Write+0x2e>
        if (hi2c->XferCount > MAX_NBYTE_SIZE)
240056be:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
240056c0:	b29b      	uxth	r3, r3
240056c2:	2bff      	cmp	r3, #255	@ 0xff
240056c4:	d92f      	bls.n	24005726 <HAL_I2C_Mem_Write+0x156>
          hi2c->XferSize = MAX_NBYTE_SIZE;
240056c6:	22ff      	movs	r2, #255	@ 0xff
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
240056c8:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
          hi2c->XferSize = MAX_NBYTE_SIZE;
240056cc:	8522      	strh	r2, [r4, #40]	@ 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
240056ce:	9000      	str	r0, [sp, #0]
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
240056d0:	4631      	mov	r1, r6
240056d2:	4620      	mov	r0, r4
240056d4:	f7ff f80a 	bl	240046ec <I2C_TransferConfig>
    while (hi2c->XferCount > 0U);
240056d8:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
240056da:	b29b      	uxth	r3, r3
240056dc:	2b00      	cmp	r3, #0
240056de:	d1cd      	bne.n	2400567c <HAL_I2C_Mem_Write+0xac>
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
240056e0:	462a      	mov	r2, r5
240056e2:	4641      	mov	r1, r8
240056e4:	4620      	mov	r0, r4
240056e6:	f7ff f8dd 	bl	240048a4 <I2C_WaitOnSTOPFlagUntilTimeout>
240056ea:	2800      	cmp	r0, #0
240056ec:	d187      	bne.n	240055fe <HAL_I2C_Mem_Write+0x2e>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
240056ee:	6823      	ldr	r3, [r4, #0]
240056f0:	2120      	movs	r1, #32
240056f2:	61d9      	str	r1, [r3, #28]
    I2C_RESET_CR2(hi2c);
240056f4:	685a      	ldr	r2, [r3, #4]
240056f6:	f022 72ff 	bic.w	r2, r2, #33423360	@ 0x1fe0000
240056fa:	f422 328b 	bic.w	r2, r2, #71168	@ 0x11600
240056fe:	f422 72ff 	bic.w	r2, r2, #510	@ 0x1fe
24005702:	f022 0201 	bic.w	r2, r2, #1
24005706:	605a      	str	r2, [r3, #4]
    hi2c->State = HAL_I2C_STATE_READY;
24005708:	f884 1041 	strb.w	r1, [r4, #65]	@ 0x41
    __HAL_UNLOCK(hi2c);
2400570c:	f884 0040 	strb.w	r0, [r4, #64]	@ 0x40
    hi2c->Mode  = HAL_I2C_MODE_NONE;
24005710:	f884 0042 	strb.w	r0, [r4, #66]	@ 0x42
    return HAL_OK;
24005714:	e774      	b.n	24005600 <HAL_I2C_Mem_Write+0x30>
      hi2c->XferSize = hi2c->XferCount;
24005716:	8d62      	ldrh	r2, [r4, #42]	@ 0x2a
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
24005718:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
      hi2c->XferSize = hi2c->XferCount;
2400571c:	b292      	uxth	r2, r2
2400571e:	8522      	strh	r2, [r4, #40]	@ 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
24005720:	b2d2      	uxtb	r2, r2
24005722:	9000      	str	r0, [sp, #0]
24005724:	e7a6      	b.n	24005674 <HAL_I2C_Mem_Write+0xa4>
          hi2c->XferSize = hi2c->XferCount;
24005726:	8d62      	ldrh	r2, [r4, #42]	@ 0x2a
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
24005728:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
          hi2c->XferSize = hi2c->XferCount;
2400572c:	b292      	uxth	r2, r2
2400572e:	8522      	strh	r2, [r4, #40]	@ 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
24005730:	b2d2      	uxtb	r2, r2
24005732:	9000      	str	r0, [sp, #0]
24005734:	e7cc      	b.n	240056d0 <HAL_I2C_Mem_Write+0x100>
    __HAL_LOCK(hi2c);
24005736:	2002      	movs	r0, #2
24005738:	e762      	b.n	24005600 <HAL_I2C_Mem_Write+0x30>

2400573a <HAL_I2C_Mem_Read>:
{
2400573a:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
2400573e:	469a      	mov	sl, r3
  if (hi2c->State == HAL_I2C_STATE_READY)
24005740:	f890 3041 	ldrb.w	r3, [r0, #65]	@ 0x41
{
24005744:	4604      	mov	r4, r0
24005746:	460e      	mov	r6, r1
  if (hi2c->State == HAL_I2C_STATE_READY)
24005748:	2b20      	cmp	r3, #32
{
2400574a:	4691      	mov	r9, r2
2400574c:	f8bd b034 	ldrh.w	fp, [sp, #52]	@ 0x34
24005750:	f8dd 8038 	ldr.w	r8, [sp, #56]	@ 0x38
  if (hi2c->State == HAL_I2C_STATE_READY)
24005754:	f040 80a8 	bne.w	240058a8 <HAL_I2C_Mem_Read+0x16e>
    if ((pData == NULL) || (Size == 0U))
24005758:	9b0c      	ldr	r3, [sp, #48]	@ 0x30
2400575a:	b113      	cbz	r3, 24005762 <HAL_I2C_Mem_Read+0x28>
2400575c:	f1bb 0f00 	cmp.w	fp, #0
24005760:	d106      	bne.n	24005770 <HAL_I2C_Mem_Read+0x36>
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
24005762:	f44f 7300 	mov.w	r3, #512	@ 0x200
24005766:	6463      	str	r3, [r4, #68]	@ 0x44
      return  HAL_ERROR;
24005768:	2001      	movs	r0, #1
}
2400576a:	b003      	add	sp, #12
2400576c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    __HAL_LOCK(hi2c);
24005770:	f890 3040 	ldrb.w	r3, [r0, #64]	@ 0x40
24005774:	2b01      	cmp	r3, #1
24005776:	f000 8097 	beq.w	240058a8 <HAL_I2C_Mem_Read+0x16e>
2400577a:	2701      	movs	r7, #1
2400577c:	f880 7040 	strb.w	r7, [r0, #64]	@ 0x40
    tickstart = HAL_GetTick();
24005780:	f00c fb42 	bl	24011e08 <HAL_GetTick>
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
24005784:	463a      	mov	r2, r7
24005786:	9000      	str	r0, [sp, #0]
    tickstart = HAL_GetTick();
24005788:	4605      	mov	r5, r0
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
2400578a:	2319      	movs	r3, #25
2400578c:	f44f 4100 	mov.w	r1, #32768	@ 0x8000
24005790:	4620      	mov	r0, r4
24005792:	f7ff f8eb 	bl	2400496c <I2C_WaitOnFlagUntilTimeout>
24005796:	4607      	mov	r7, r0
24005798:	2800      	cmp	r0, #0
2400579a:	d1e5      	bne.n	24005768 <HAL_I2C_Mem_Read+0x2e>
    hi2c->State     = HAL_I2C_STATE_BUSY_RX;
2400579c:	2322      	movs	r3, #34	@ 0x22
    hi2c->XferISR   = NULL;
2400579e:	6360      	str	r0, [r4, #52]	@ 0x34
    if (I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
240057a0:	464a      	mov	r2, r9
240057a2:	4631      	mov	r1, r6
    hi2c->State     = HAL_I2C_STATE_BUSY_RX;
240057a4:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
    hi2c->Mode      = HAL_I2C_MODE_MEM;
240057a8:	2340      	movs	r3, #64	@ 0x40
240057aa:	f884 3042 	strb.w	r3, [r4, #66]	@ 0x42
    hi2c->pBuffPtr  = pData;
240057ae:	9b0c      	ldr	r3, [sp, #48]	@ 0x30
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
240057b0:	6460      	str	r0, [r4, #68]	@ 0x44
    if (I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
240057b2:	4620      	mov	r0, r4
    hi2c->pBuffPtr  = pData;
240057b4:	6263      	str	r3, [r4, #36]	@ 0x24
    if (I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
240057b6:	4653      	mov	r3, sl
    hi2c->XferCount = Size;
240057b8:	f8a4 b02a 	strh.w	fp, [r4, #42]	@ 0x2a
    if (I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
240057bc:	e9cd 8500 	strd	r8, r5, [sp]
240057c0:	f7ff f934 	bl	24004a2c <I2C_RequestMemoryRead>
240057c4:	b110      	cbz	r0, 240057cc <HAL_I2C_Mem_Read+0x92>
      __HAL_UNLOCK(hi2c);
240057c6:	f884 7040 	strb.w	r7, [r4, #64]	@ 0x40
      return HAL_ERROR;
240057ca:	e7cd      	b.n	24005768 <HAL_I2C_Mem_Read+0x2e>
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
240057cc:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
240057ce:	b29b      	uxth	r3, r3
240057d0:	2bff      	cmp	r3, #255	@ 0xff
240057d2:	4b36      	ldr	r3, [pc, #216]	@ (240058ac <HAL_I2C_Mem_Read+0x172>)
240057d4:	d958      	bls.n	24005888 <HAL_I2C_Mem_Read+0x14e>
      hi2c->XferSize = MAX_NBYTE_SIZE;
240057d6:	22ff      	movs	r2, #255	@ 0xff
240057d8:	8522      	strh	r2, [r4, #40]	@ 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_GENERATE_START_READ);
240057da:	9300      	str	r3, [sp, #0]
240057dc:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_READ);
240057e0:	4631      	mov	r1, r6
240057e2:	4620      	mov	r0, r4
240057e4:	f7fe ff82 	bl	240046ec <I2C_TransferConfig>
      if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_RXNE, RESET, Timeout, tickstart) != HAL_OK)
240057e8:	4643      	mov	r3, r8
240057ea:	2200      	movs	r2, #0
240057ec:	2104      	movs	r1, #4
240057ee:	4620      	mov	r0, r4
240057f0:	9500      	str	r5, [sp, #0]
240057f2:	f7ff f8bb 	bl	2400496c <I2C_WaitOnFlagUntilTimeout>
240057f6:	2800      	cmp	r0, #0
240057f8:	d1b6      	bne.n	24005768 <HAL_I2C_Mem_Read+0x2e>
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
240057fa:	6823      	ldr	r3, [r4, #0]
240057fc:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
240057fe:	6a63      	ldr	r3, [r4, #36]	@ 0x24
24005800:	701a      	strb	r2, [r3, #0]
      hi2c->pBuffPtr++;
24005802:	6a63      	ldr	r3, [r4, #36]	@ 0x24
      hi2c->XferSize--;
24005804:	8d22      	ldrh	r2, [r4, #40]	@ 0x28
      hi2c->pBuffPtr++;
24005806:	3301      	adds	r3, #1
      hi2c->XferSize--;
24005808:	3a01      	subs	r2, #1
      hi2c->pBuffPtr++;
2400580a:	6263      	str	r3, [r4, #36]	@ 0x24
      hi2c->XferCount--;
2400580c:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
      hi2c->XferSize--;
2400580e:	b292      	uxth	r2, r2
      hi2c->XferCount--;
24005810:	3b01      	subs	r3, #1
      hi2c->XferSize--;
24005812:	8522      	strh	r2, [r4, #40]	@ 0x28
      hi2c->XferCount--;
24005814:	b29b      	uxth	r3, r3
24005816:	8563      	strh	r3, [r4, #42]	@ 0x2a
      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
24005818:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
2400581a:	b29b      	uxth	r3, r3
2400581c:	b1ab      	cbz	r3, 2400584a <HAL_I2C_Mem_Read+0x110>
2400581e:	b9a2      	cbnz	r2, 2400584a <HAL_I2C_Mem_Read+0x110>
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
24005820:	4643      	mov	r3, r8
24005822:	2180      	movs	r1, #128	@ 0x80
24005824:	4620      	mov	r0, r4
24005826:	9500      	str	r5, [sp, #0]
24005828:	f7ff f8a0 	bl	2400496c <I2C_WaitOnFlagUntilTimeout>
2400582c:	2800      	cmp	r0, #0
2400582e:	d19b      	bne.n	24005768 <HAL_I2C_Mem_Read+0x2e>
        if (hi2c->XferCount > MAX_NBYTE_SIZE)
24005830:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
24005832:	b29b      	uxth	r3, r3
24005834:	2bff      	cmp	r3, #255	@ 0xff
24005836:	d92f      	bls.n	24005898 <HAL_I2C_Mem_Read+0x15e>
          hi2c->XferSize = MAX_NBYTE_SIZE;
24005838:	22ff      	movs	r2, #255	@ 0xff
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t) hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
2400583a:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
          hi2c->XferSize = MAX_NBYTE_SIZE;
2400583e:	8522      	strh	r2, [r4, #40]	@ 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t) hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
24005840:	9000      	str	r0, [sp, #0]
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
24005842:	4631      	mov	r1, r6
24005844:	4620      	mov	r0, r4
24005846:	f7fe ff51 	bl	240046ec <I2C_TransferConfig>
    while (hi2c->XferCount > 0U);
2400584a:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
2400584c:	b29b      	uxth	r3, r3
2400584e:	2b00      	cmp	r3, #0
24005850:	d1ca      	bne.n	240057e8 <HAL_I2C_Mem_Read+0xae>
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
24005852:	462a      	mov	r2, r5
24005854:	4641      	mov	r1, r8
24005856:	4620      	mov	r0, r4
24005858:	f7ff f824 	bl	240048a4 <I2C_WaitOnSTOPFlagUntilTimeout>
2400585c:	2800      	cmp	r0, #0
2400585e:	d183      	bne.n	24005768 <HAL_I2C_Mem_Read+0x2e>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
24005860:	6823      	ldr	r3, [r4, #0]
24005862:	2120      	movs	r1, #32
24005864:	61d9      	str	r1, [r3, #28]
    I2C_RESET_CR2(hi2c);
24005866:	685a      	ldr	r2, [r3, #4]
24005868:	f022 72ff 	bic.w	r2, r2, #33423360	@ 0x1fe0000
2400586c:	f422 328b 	bic.w	r2, r2, #71168	@ 0x11600
24005870:	f422 72ff 	bic.w	r2, r2, #510	@ 0x1fe
24005874:	f022 0201 	bic.w	r2, r2, #1
24005878:	605a      	str	r2, [r3, #4]
    hi2c->State = HAL_I2C_STATE_READY;
2400587a:	f884 1041 	strb.w	r1, [r4, #65]	@ 0x41
    __HAL_UNLOCK(hi2c);
2400587e:	f884 0040 	strb.w	r0, [r4, #64]	@ 0x40
    hi2c->Mode  = HAL_I2C_MODE_NONE;
24005882:	f884 0042 	strb.w	r0, [r4, #66]	@ 0x42
    return HAL_OK;
24005886:	e770      	b.n	2400576a <HAL_I2C_Mem_Read+0x30>
      hi2c->XferSize = hi2c->XferCount;
24005888:	8d62      	ldrh	r2, [r4, #42]	@ 0x2a
2400588a:	b292      	uxth	r2, r2
2400588c:	8522      	strh	r2, [r4, #40]	@ 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_READ);
2400588e:	b2d2      	uxtb	r2, r2
24005890:	9300      	str	r3, [sp, #0]
24005892:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
24005896:	e7a3      	b.n	240057e0 <HAL_I2C_Mem_Read+0xa6>
          hi2c->XferSize = hi2c->XferCount;
24005898:	8d62      	ldrh	r2, [r4, #42]	@ 0x2a
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
2400589a:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
          hi2c->XferSize = hi2c->XferCount;
2400589e:	b292      	uxth	r2, r2
240058a0:	8522      	strh	r2, [r4, #40]	@ 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
240058a2:	b2d2      	uxtb	r2, r2
240058a4:	9000      	str	r0, [sp, #0]
240058a6:	e7cc      	b.n	24005842 <HAL_I2C_Mem_Read+0x108>
    __HAL_LOCK(hi2c);
240058a8:	2002      	movs	r0, #2
240058aa:	e75e      	b.n	2400576a <HAL_I2C_Mem_Read+0x30>
240058ac:	80002400 	.word	0x80002400

240058b0 <HAL_I2C_Mem_Write_IT>:
{
240058b0:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
240058b4:	461f      	mov	r7, r3
  if (hi2c->State == HAL_I2C_STATE_READY)
240058b6:	f890 3041 	ldrb.w	r3, [r0, #65]	@ 0x41
{
240058ba:	4604      	mov	r4, r0
240058bc:	460e      	mov	r6, r1
  if (hi2c->State == HAL_I2C_STATE_READY)
240058be:	2b20      	cmp	r3, #32
{
240058c0:	4615      	mov	r5, r2
240058c2:	f8dd 9028 	ldr.w	r9, [sp, #40]	@ 0x28
240058c6:	f8bd a02c 	ldrh.w	sl, [sp, #44]	@ 0x2c
  if (hi2c->State == HAL_I2C_STATE_READY)
240058ca:	d156      	bne.n	2400597a <HAL_I2C_Mem_Write_IT+0xca>
    if ((pData == NULL) || (Size == 0U))
240058cc:	f1b9 0f00 	cmp.w	r9, #0
240058d0:	d002      	beq.n	240058d8 <HAL_I2C_Mem_Write_IT+0x28>
240058d2:	f1ba 0f00 	cmp.w	sl, #0
240058d6:	d107      	bne.n	240058e8 <HAL_I2C_Mem_Write_IT+0x38>
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
240058d8:	f44f 7300 	mov.w	r3, #512	@ 0x200
240058dc:	6463      	str	r3, [r4, #68]	@ 0x44
      return  HAL_ERROR;
240058de:	2501      	movs	r5, #1
}
240058e0:	4628      	mov	r0, r5
240058e2:	b002      	add	sp, #8
240058e4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
240058e8:	6803      	ldr	r3, [r0, #0]
240058ea:	6999      	ldr	r1, [r3, #24]
240058ec:	f411 4800 	ands.w	r8, r1, #32768	@ 0x8000
240058f0:	d143      	bne.n	2400597a <HAL_I2C_Mem_Write_IT+0xca>
    __HAL_LOCK(hi2c);
240058f2:	f890 3040 	ldrb.w	r3, [r0, #64]	@ 0x40
240058f6:	2b01      	cmp	r3, #1
240058f8:	d03f      	beq.n	2400597a <HAL_I2C_Mem_Write_IT+0xca>
240058fa:	2301      	movs	r3, #1
240058fc:	f880 3040 	strb.w	r3, [r0, #64]	@ 0x40
    tickstart = HAL_GetTick();
24005900:	f00c fa82 	bl	24011e08 <HAL_GetTick>
    hi2c->State       = HAL_I2C_STATE_BUSY_TX;
24005904:	2321      	movs	r3, #33	@ 0x21
    hi2c->pBuffPtr    = pData;
24005906:	f8c4 9024 	str.w	r9, [r4, #36]	@ 0x24
    hi2c->State       = HAL_I2C_STATE_BUSY_TX;
2400590a:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
    hi2c->Mode        = HAL_I2C_MODE_MEM;
2400590e:	2340      	movs	r3, #64	@ 0x40
24005910:	f884 3042 	strb.w	r3, [r4, #66]	@ 0x42
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
24005914:	4b1a      	ldr	r3, [pc, #104]	@ (24005980 <HAL_I2C_Mem_Write_IT+0xd0>)
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
24005916:	f8c4 8044 	str.w	r8, [r4, #68]	@ 0x44
    hi2c->XferCount   = Size;
2400591a:	f8a4 a02a 	strh.w	sl, [r4, #42]	@ 0x2a
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
2400591e:	62e3      	str	r3, [r4, #44]	@ 0x2c
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
24005920:	8d61      	ldrh	r1, [r4, #42]	@ 0x2a
    hi2c->XferISR     = I2C_Master_ISR_IT;
24005922:	4b18      	ldr	r3, [pc, #96]	@ (24005984 <HAL_I2C_Mem_Write_IT+0xd4>)
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
24005924:	b289      	uxth	r1, r1
    hi2c->XferISR     = I2C_Master_ISR_IT;
24005926:	6363      	str	r3, [r4, #52]	@ 0x34
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
24005928:	29ff      	cmp	r1, #255	@ 0xff
2400592a:	d813      	bhi.n	24005954 <HAL_I2C_Mem_Write_IT+0xa4>
      hi2c->XferSize = hi2c->XferCount;
2400592c:	8d61      	ldrh	r1, [r4, #42]	@ 0x2a
      xfermode = I2C_AUTOEND_MODE;
2400592e:	f04f 7800 	mov.w	r8, #33554432	@ 0x2000000
      hi2c->XferSize = hi2c->XferCount;
24005932:	b289      	uxth	r1, r1
    if (I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, I2C_TIMEOUT_FLAG, tickstart) != HAL_OK)
24005934:	2319      	movs	r3, #25
24005936:	8521      	strh	r1, [r4, #40]	@ 0x28
24005938:	462a      	mov	r2, r5
2400593a:	9001      	str	r0, [sp, #4]
2400593c:	9300      	str	r3, [sp, #0]
2400593e:	4631      	mov	r1, r6
24005940:	463b      	mov	r3, r7
24005942:	4620      	mov	r0, r4
24005944:	f7ff f83c 	bl	240049c0 <I2C_RequestMemoryWrite>
24005948:	4605      	mov	r5, r0
2400594a:	b138      	cbz	r0, 2400595c <HAL_I2C_Mem_Write_IT+0xac>
      __HAL_UNLOCK(hi2c);
2400594c:	2300      	movs	r3, #0
2400594e:	f884 3040 	strb.w	r3, [r4, #64]	@ 0x40
      return HAL_ERROR;
24005952:	e7c4      	b.n	240058de <HAL_I2C_Mem_Write_IT+0x2e>
      hi2c->XferSize = MAX_NBYTE_SIZE;
24005954:	21ff      	movs	r1, #255	@ 0xff
      xfermode = I2C_RELOAD_MODE;
24005956:	f04f 7880 	mov.w	r8, #16777216	@ 0x1000000
2400595a:	e7eb      	b.n	24005934 <HAL_I2C_Mem_Write_IT+0x84>
    I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, I2C_NO_STARTSTOP);
2400595c:	9000      	str	r0, [sp, #0]
2400595e:	4631      	mov	r1, r6
24005960:	4620      	mov	r0, r4
24005962:	4643      	mov	r3, r8
24005964:	f894 2028 	ldrb.w	r2, [r4, #40]	@ 0x28
24005968:	f7fe fec0 	bl	240046ec <I2C_TransferConfig>
    I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT);
2400596c:	2101      	movs	r1, #1
2400596e:	4620      	mov	r0, r4
    __HAL_UNLOCK(hi2c);
24005970:	f884 5040 	strb.w	r5, [r4, #64]	@ 0x40
    I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT);
24005974:	f7fe fece 	bl	24004714 <I2C_Enable_IRQ>
    return HAL_OK;
24005978:	e7b2      	b.n	240058e0 <HAL_I2C_Mem_Write_IT+0x30>
      return HAL_BUSY;
2400597a:	2502      	movs	r5, #2
2400597c:	e7b0      	b.n	240058e0 <HAL_I2C_Mem_Write_IT+0x30>
2400597e:	bf00      	nop
24005980:	ffff0000 	.word	0xffff0000
24005984:	24006b4f 	.word	0x24006b4f

24005988 <HAL_I2C_Mem_Read_IT>:
{
24005988:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
2400598c:	461f      	mov	r7, r3
  if (hi2c->State == HAL_I2C_STATE_READY)
2400598e:	f890 3041 	ldrb.w	r3, [r0, #65]	@ 0x41
{
24005992:	4604      	mov	r4, r0
24005994:	460e      	mov	r6, r1
  if (hi2c->State == HAL_I2C_STATE_READY)
24005996:	2b20      	cmp	r3, #32
{
24005998:	4615      	mov	r5, r2
2400599a:	f8dd 9028 	ldr.w	r9, [sp, #40]	@ 0x28
2400599e:	f8bd a02c 	ldrh.w	sl, [sp, #44]	@ 0x2c
  if (hi2c->State == HAL_I2C_STATE_READY)
240059a2:	d157      	bne.n	24005a54 <HAL_I2C_Mem_Read_IT+0xcc>
    if ((pData == NULL) || (Size == 0U))
240059a4:	f1b9 0f00 	cmp.w	r9, #0
240059a8:	d002      	beq.n	240059b0 <HAL_I2C_Mem_Read_IT+0x28>
240059aa:	f1ba 0f00 	cmp.w	sl, #0
240059ae:	d107      	bne.n	240059c0 <HAL_I2C_Mem_Read_IT+0x38>
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
240059b0:	f44f 7300 	mov.w	r3, #512	@ 0x200
240059b4:	6463      	str	r3, [r4, #68]	@ 0x44
      return  HAL_ERROR;
240059b6:	2501      	movs	r5, #1
}
240059b8:	4628      	mov	r0, r5
240059ba:	b002      	add	sp, #8
240059bc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
240059c0:	6803      	ldr	r3, [r0, #0]
240059c2:	6999      	ldr	r1, [r3, #24]
240059c4:	f411 4800 	ands.w	r8, r1, #32768	@ 0x8000
240059c8:	d144      	bne.n	24005a54 <HAL_I2C_Mem_Read_IT+0xcc>
    __HAL_LOCK(hi2c);
240059ca:	f890 3040 	ldrb.w	r3, [r0, #64]	@ 0x40
240059ce:	2b01      	cmp	r3, #1
240059d0:	d040      	beq.n	24005a54 <HAL_I2C_Mem_Read_IT+0xcc>
240059d2:	2301      	movs	r3, #1
240059d4:	f880 3040 	strb.w	r3, [r0, #64]	@ 0x40
    tickstart = HAL_GetTick();
240059d8:	f00c fa16 	bl	24011e08 <HAL_GetTick>
    hi2c->State       = HAL_I2C_STATE_BUSY_RX;
240059dc:	2322      	movs	r3, #34	@ 0x22
    hi2c->pBuffPtr    = pData;
240059de:	f8c4 9024 	str.w	r9, [r4, #36]	@ 0x24
    hi2c->State       = HAL_I2C_STATE_BUSY_RX;
240059e2:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
    hi2c->Mode        = HAL_I2C_MODE_MEM;
240059e6:	2340      	movs	r3, #64	@ 0x40
240059e8:	f884 3042 	strb.w	r3, [r4, #66]	@ 0x42
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
240059ec:	4b1a      	ldr	r3, [pc, #104]	@ (24005a58 <HAL_I2C_Mem_Read_IT+0xd0>)
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
240059ee:	f8c4 8044 	str.w	r8, [r4, #68]	@ 0x44
    hi2c->XferCount   = Size;
240059f2:	f8a4 a02a 	strh.w	sl, [r4, #42]	@ 0x2a
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
240059f6:	62e3      	str	r3, [r4, #44]	@ 0x2c
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
240059f8:	8d61      	ldrh	r1, [r4, #42]	@ 0x2a
    hi2c->XferISR     = I2C_Master_ISR_IT;
240059fa:	4b18      	ldr	r3, [pc, #96]	@ (24005a5c <HAL_I2C_Mem_Read_IT+0xd4>)
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
240059fc:	b289      	uxth	r1, r1
    hi2c->XferISR     = I2C_Master_ISR_IT;
240059fe:	6363      	str	r3, [r4, #52]	@ 0x34
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
24005a00:	29ff      	cmp	r1, #255	@ 0xff
24005a02:	d813      	bhi.n	24005a2c <HAL_I2C_Mem_Read_IT+0xa4>
      hi2c->XferSize = hi2c->XferCount;
24005a04:	8d61      	ldrh	r1, [r4, #42]	@ 0x2a
      xfermode = I2C_AUTOEND_MODE;
24005a06:	f04f 7800 	mov.w	r8, #33554432	@ 0x2000000
      hi2c->XferSize = hi2c->XferCount;
24005a0a:	b289      	uxth	r1, r1
    if (I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, I2C_TIMEOUT_FLAG, tickstart) != HAL_OK)
24005a0c:	2319      	movs	r3, #25
24005a0e:	8521      	strh	r1, [r4, #40]	@ 0x28
24005a10:	462a      	mov	r2, r5
24005a12:	9001      	str	r0, [sp, #4]
24005a14:	9300      	str	r3, [sp, #0]
24005a16:	4631      	mov	r1, r6
24005a18:	463b      	mov	r3, r7
24005a1a:	4620      	mov	r0, r4
24005a1c:	f7ff f806 	bl	24004a2c <I2C_RequestMemoryRead>
24005a20:	4605      	mov	r5, r0
24005a22:	b138      	cbz	r0, 24005a34 <HAL_I2C_Mem_Read_IT+0xac>
      __HAL_UNLOCK(hi2c);
24005a24:	2300      	movs	r3, #0
24005a26:	f884 3040 	strb.w	r3, [r4, #64]	@ 0x40
      return HAL_ERROR;
24005a2a:	e7c4      	b.n	240059b6 <HAL_I2C_Mem_Read_IT+0x2e>
      hi2c->XferSize = MAX_NBYTE_SIZE;
24005a2c:	21ff      	movs	r1, #255	@ 0xff
      xfermode = I2C_RELOAD_MODE;
24005a2e:	f04f 7880 	mov.w	r8, #16777216	@ 0x1000000
24005a32:	e7eb      	b.n	24005a0c <HAL_I2C_Mem_Read_IT+0x84>
    I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, I2C_GENERATE_START_READ);
24005a34:	4b0a      	ldr	r3, [pc, #40]	@ (24005a60 <HAL_I2C_Mem_Read_IT+0xd8>)
24005a36:	4631      	mov	r1, r6
24005a38:	4620      	mov	r0, r4
24005a3a:	9300      	str	r3, [sp, #0]
24005a3c:	4643      	mov	r3, r8
24005a3e:	f894 2028 	ldrb.w	r2, [r4, #40]	@ 0x28
24005a42:	f7fe fe53 	bl	240046ec <I2C_TransferConfig>
    I2C_Enable_IRQ(hi2c, I2C_XFER_RX_IT);
24005a46:	2102      	movs	r1, #2
24005a48:	4620      	mov	r0, r4
    __HAL_UNLOCK(hi2c);
24005a4a:	f884 5040 	strb.w	r5, [r4, #64]	@ 0x40
    I2C_Enable_IRQ(hi2c, I2C_XFER_RX_IT);
24005a4e:	f7fe fe61 	bl	24004714 <I2C_Enable_IRQ>
    return HAL_OK;
24005a52:	e7b1      	b.n	240059b8 <HAL_I2C_Mem_Read_IT+0x30>
      return HAL_BUSY;
24005a54:	2502      	movs	r5, #2
24005a56:	e7af      	b.n	240059b8 <HAL_I2C_Mem_Read_IT+0x30>
24005a58:	ffff0000 	.word	0xffff0000
24005a5c:	24006b4f 	.word	0x24006b4f
24005a60:	80002400 	.word	0x80002400

24005a64 <HAL_I2C_Mem_Write_DMA>:
{
24005a64:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
24005a68:	4699      	mov	r9, r3
  if (hi2c->State == HAL_I2C_STATE_READY)
24005a6a:	f890 3041 	ldrb.w	r3, [r0, #65]	@ 0x41
{
24005a6e:	4604      	mov	r4, r0
24005a70:	460f      	mov	r7, r1
  if (hi2c->State == HAL_I2C_STATE_READY)
24005a72:	2b20      	cmp	r3, #32
{
24005a74:	4616      	mov	r6, r2
24005a76:	9d0a      	ldr	r5, [sp, #40]	@ 0x28
24005a78:	f8bd a02c 	ldrh.w	sl, [sp, #44]	@ 0x2c
  if (hi2c->State == HAL_I2C_STATE_READY)
24005a7c:	f040 8086 	bne.w	24005b8c <HAL_I2C_Mem_Write_DMA+0x128>
    if ((pData == NULL) || (Size == 0U))
24005a80:	b115      	cbz	r5, 24005a88 <HAL_I2C_Mem_Write_DMA+0x24>
24005a82:	f1ba 0f00 	cmp.w	sl, #0
24005a86:	d107      	bne.n	24005a98 <HAL_I2C_Mem_Write_DMA+0x34>
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
24005a88:	f44f 7300 	mov.w	r3, #512	@ 0x200
24005a8c:	6463      	str	r3, [r4, #68]	@ 0x44
      return  HAL_ERROR;
24005a8e:	2501      	movs	r5, #1
}
24005a90:	4628      	mov	r0, r5
24005a92:	b002      	add	sp, #8
24005a94:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
24005a98:	6803      	ldr	r3, [r0, #0]
24005a9a:	699b      	ldr	r3, [r3, #24]
24005a9c:	f413 4800 	ands.w	r8, r3, #32768	@ 0x8000
24005aa0:	d174      	bne.n	24005b8c <HAL_I2C_Mem_Write_DMA+0x128>
    __HAL_LOCK(hi2c);
24005aa2:	f890 3040 	ldrb.w	r3, [r0, #64]	@ 0x40
24005aa6:	2b01      	cmp	r3, #1
24005aa8:	d070      	beq.n	24005b8c <HAL_I2C_Mem_Write_DMA+0x128>
24005aaa:	2301      	movs	r3, #1
24005aac:	f880 3040 	strb.w	r3, [r0, #64]	@ 0x40
    tickstart = HAL_GetTick();
24005ab0:	f00c f9aa 	bl	24011e08 <HAL_GetTick>
    hi2c->State       = HAL_I2C_STATE_BUSY_TX;
24005ab4:	2321      	movs	r3, #33	@ 0x21
    hi2c->pBuffPtr    = pData;
24005ab6:	6265      	str	r5, [r4, #36]	@ 0x24
    hi2c->State       = HAL_I2C_STATE_BUSY_TX;
24005ab8:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
    hi2c->Mode        = HAL_I2C_MODE_MEM;
24005abc:	2340      	movs	r3, #64	@ 0x40
24005abe:	f884 3042 	strb.w	r3, [r4, #66]	@ 0x42
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
24005ac2:	4b33      	ldr	r3, [pc, #204]	@ (24005b90 <HAL_I2C_Mem_Write_DMA+0x12c>)
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
24005ac4:	f8c4 8044 	str.w	r8, [r4, #68]	@ 0x44
    hi2c->XferCount   = Size;
24005ac8:	f8a4 a02a 	strh.w	sl, [r4, #42]	@ 0x2a
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
24005acc:	62e3      	str	r3, [r4, #44]	@ 0x2c
    hi2c->XferISR     = I2C_Master_ISR_DMA;
24005ace:	4b31      	ldr	r3, [pc, #196]	@ (24005b94 <HAL_I2C_Mem_Write_DMA+0x130>)
24005ad0:	6363      	str	r3, [r4, #52]	@ 0x34
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
24005ad2:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
24005ad4:	b29b      	uxth	r3, r3
24005ad6:	2bff      	cmp	r3, #255	@ 0xff
24005ad8:	d813      	bhi.n	24005b02 <HAL_I2C_Mem_Write_DMA+0x9e>
      hi2c->XferSize = hi2c->XferCount;
24005ada:	8d61      	ldrh	r1, [r4, #42]	@ 0x2a
      xfermode = I2C_AUTOEND_MODE;
24005adc:	f04f 7800 	mov.w	r8, #33554432	@ 0x2000000
      hi2c->XferSize = hi2c->XferCount;
24005ae0:	b289      	uxth	r1, r1
    if (I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, I2C_TIMEOUT_FLAG, tickstart) != HAL_OK)
24005ae2:	2319      	movs	r3, #25
24005ae4:	8521      	strh	r1, [r4, #40]	@ 0x28
24005ae6:	4632      	mov	r2, r6
24005ae8:	9001      	str	r0, [sp, #4]
24005aea:	9300      	str	r3, [sp, #0]
24005aec:	4639      	mov	r1, r7
24005aee:	464b      	mov	r3, r9
24005af0:	4620      	mov	r0, r4
24005af2:	f7fe ff65 	bl	240049c0 <I2C_RequestMemoryWrite>
24005af6:	4606      	mov	r6, r0
24005af8:	b138      	cbz	r0, 24005b0a <HAL_I2C_Mem_Write_DMA+0xa6>
      __HAL_UNLOCK(hi2c);
24005afa:	2300      	movs	r3, #0
24005afc:	f884 3040 	strb.w	r3, [r4, #64]	@ 0x40
      return HAL_ERROR;
24005b00:	e7c5      	b.n	24005a8e <HAL_I2C_Mem_Write_DMA+0x2a>
      hi2c->XferSize = MAX_NBYTE_SIZE;
24005b02:	21ff      	movs	r1, #255	@ 0xff
      xfermode = I2C_RELOAD_MODE;
24005b04:	f04f 7880 	mov.w	r8, #16777216	@ 0x1000000
24005b08:	e7eb      	b.n	24005ae2 <HAL_I2C_Mem_Write_DMA+0x7e>
    if (hi2c->hdmatx != NULL)
24005b0a:	6ba0      	ldr	r0, [r4, #56]	@ 0x38
24005b0c:	b330      	cbz	r0, 24005b5c <HAL_I2C_Mem_Write_DMA+0xf8>
      hi2c->hdmatx->XferCpltCallback = I2C_DMAMasterTransmitCplt;
24005b0e:	4b22      	ldr	r3, [pc, #136]	@ (24005b98 <HAL_I2C_Mem_Write_DMA+0x134>)
      dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->TXDR, hi2c->XferSize);
24005b10:	4629      	mov	r1, r5
24005b12:	6822      	ldr	r2, [r4, #0]
      hi2c->hdmatx->XferCpltCallback = I2C_DMAMasterTransmitCplt;
24005b14:	63c3      	str	r3, [r0, #60]	@ 0x3c
      hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
24005b16:	4b21      	ldr	r3, [pc, #132]	@ (24005b9c <HAL_I2C_Mem_Write_DMA+0x138>)
      dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->TXDR, hi2c->XferSize);
24005b18:	3228      	adds	r2, #40	@ 0x28
      hi2c->hdmatx->XferHalfCpltCallback = NULL;
24005b1a:	6406      	str	r6, [r0, #64]	@ 0x40
      hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
24005b1c:	64c3      	str	r3, [r0, #76]	@ 0x4c
      hi2c->hdmatx->XferAbortCallback = NULL;
24005b1e:	6506      	str	r6, [r0, #80]	@ 0x50
      dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->TXDR, hi2c->XferSize);
24005b20:	8d23      	ldrh	r3, [r4, #40]	@ 0x28
24005b22:	f7fb ff5d 	bl	240019e0 <HAL_DMA_Start_IT>
    if (dmaxferstatus == HAL_OK)
24005b26:	4605      	mov	r5, r0
24005b28:	bb20      	cbnz	r0, 24005b74 <HAL_I2C_Mem_Write_DMA+0x110>
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, I2C_NO_STARTSTOP);
24005b2a:	8d26      	ldrh	r6, [r4, #40]	@ 0x28
24005b2c:	4643      	mov	r3, r8
24005b2e:	9000      	str	r0, [sp, #0]
24005b30:	4639      	mov	r1, r7
24005b32:	f894 2028 	ldrb.w	r2, [r4, #40]	@ 0x28
24005b36:	4620      	mov	r0, r4
24005b38:	f7fe fdd8 	bl	240046ec <I2C_TransferConfig>
      hi2c->XferCount -= hi2c->XferSize;
24005b3c:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
      I2C_Enable_IRQ(hi2c, I2C_XFER_ERROR_IT);
24005b3e:	2110      	movs	r1, #16
24005b40:	4620      	mov	r0, r4
      hi2c->XferCount -= hi2c->XferSize;
24005b42:	1b9b      	subs	r3, r3, r6
      __HAL_UNLOCK(hi2c);
24005b44:	f884 5040 	strb.w	r5, [r4, #64]	@ 0x40
      hi2c->XferCount -= hi2c->XferSize;
24005b48:	b29b      	uxth	r3, r3
24005b4a:	8563      	strh	r3, [r4, #42]	@ 0x2a
      I2C_Enable_IRQ(hi2c, I2C_XFER_ERROR_IT);
24005b4c:	f7fe fde2 	bl	24004714 <I2C_Enable_IRQ>
      hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN;
24005b50:	6822      	ldr	r2, [r4, #0]
24005b52:	6813      	ldr	r3, [r2, #0]
24005b54:	f443 4380 	orr.w	r3, r3, #16384	@ 0x4000
24005b58:	6013      	str	r3, [r2, #0]
    return HAL_OK;
24005b5a:	e799      	b.n	24005a90 <HAL_I2C_Mem_Write_DMA+0x2c>
      hi2c->State     = HAL_I2C_STATE_READY;
24005b5c:	2320      	movs	r3, #32
      __HAL_UNLOCK(hi2c);
24005b5e:	f884 0040 	strb.w	r0, [r4, #64]	@ 0x40
      hi2c->State     = HAL_I2C_STATE_READY;
24005b62:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
      hi2c->Mode      = HAL_I2C_MODE_NONE;
24005b66:	f884 0042 	strb.w	r0, [r4, #66]	@ 0x42
      hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
24005b6a:	6c63      	ldr	r3, [r4, #68]	@ 0x44
24005b6c:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
24005b70:	6463      	str	r3, [r4, #68]	@ 0x44
      return HAL_ERROR;
24005b72:	e78c      	b.n	24005a8e <HAL_I2C_Mem_Write_DMA+0x2a>
      hi2c->State     = HAL_I2C_STATE_READY;
24005b74:	2320      	movs	r3, #32
      __HAL_UNLOCK(hi2c);
24005b76:	f884 6040 	strb.w	r6, [r4, #64]	@ 0x40
      hi2c->State     = HAL_I2C_STATE_READY;
24005b7a:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
      hi2c->Mode      = HAL_I2C_MODE_NONE;
24005b7e:	f884 6042 	strb.w	r6, [r4, #66]	@ 0x42
      hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
24005b82:	6c63      	ldr	r3, [r4, #68]	@ 0x44
24005b84:	f043 0310 	orr.w	r3, r3, #16
24005b88:	6463      	str	r3, [r4, #68]	@ 0x44
      return HAL_ERROR;
24005b8a:	e780      	b.n	24005a8e <HAL_I2C_Mem_Write_DMA+0x2a>
      return HAL_BUSY;
24005b8c:	2502      	movs	r5, #2
24005b8e:	e77f      	b.n	24005a90 <HAL_I2C_Mem_Write_DMA+0x2c>
24005b90:	ffff0000 	.word	0xffff0000
24005b94:	24006c71 	.word	0x24006c71
24005b98:	24006e55 	.word	0x24006e55
24005b9c:	24006d75 	.word	0x24006d75

24005ba0 <HAL_I2C_Mem_Read_DMA>:
{
24005ba0:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
24005ba4:	4699      	mov	r9, r3
  if (hi2c->State == HAL_I2C_STATE_READY)
24005ba6:	f890 3041 	ldrb.w	r3, [r0, #65]	@ 0x41
{
24005baa:	4604      	mov	r4, r0
24005bac:	460f      	mov	r7, r1
  if (hi2c->State == HAL_I2C_STATE_READY)
24005bae:	2b20      	cmp	r3, #32
{
24005bb0:	4616      	mov	r6, r2
24005bb2:	9d0a      	ldr	r5, [sp, #40]	@ 0x28
24005bb4:	f8bd a02c 	ldrh.w	sl, [sp, #44]	@ 0x2c
  if (hi2c->State == HAL_I2C_STATE_READY)
24005bb8:	f040 8087 	bne.w	24005cca <HAL_I2C_Mem_Read_DMA+0x12a>
    if ((pData == NULL) || (Size == 0U))
24005bbc:	b115      	cbz	r5, 24005bc4 <HAL_I2C_Mem_Read_DMA+0x24>
24005bbe:	f1ba 0f00 	cmp.w	sl, #0
24005bc2:	d107      	bne.n	24005bd4 <HAL_I2C_Mem_Read_DMA+0x34>
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
24005bc4:	f44f 7300 	mov.w	r3, #512	@ 0x200
24005bc8:	6463      	str	r3, [r4, #68]	@ 0x44
      return  HAL_ERROR;
24005bca:	2501      	movs	r5, #1
}
24005bcc:	4628      	mov	r0, r5
24005bce:	b002      	add	sp, #8
24005bd0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
24005bd4:	6803      	ldr	r3, [r0, #0]
24005bd6:	699b      	ldr	r3, [r3, #24]
24005bd8:	f413 4800 	ands.w	r8, r3, #32768	@ 0x8000
24005bdc:	d175      	bne.n	24005cca <HAL_I2C_Mem_Read_DMA+0x12a>
    __HAL_LOCK(hi2c);
24005bde:	f890 3040 	ldrb.w	r3, [r0, #64]	@ 0x40
24005be2:	2b01      	cmp	r3, #1
24005be4:	d071      	beq.n	24005cca <HAL_I2C_Mem_Read_DMA+0x12a>
24005be6:	2301      	movs	r3, #1
24005be8:	f880 3040 	strb.w	r3, [r0, #64]	@ 0x40
    tickstart = HAL_GetTick();
24005bec:	f00c f90c 	bl	24011e08 <HAL_GetTick>
    hi2c->State       = HAL_I2C_STATE_BUSY_RX;
24005bf0:	2322      	movs	r3, #34	@ 0x22
    hi2c->pBuffPtr    = pData;
24005bf2:	6265      	str	r5, [r4, #36]	@ 0x24
    hi2c->State       = HAL_I2C_STATE_BUSY_RX;
24005bf4:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
    hi2c->Mode        = HAL_I2C_MODE_MEM;
24005bf8:	2340      	movs	r3, #64	@ 0x40
24005bfa:	f884 3042 	strb.w	r3, [r4, #66]	@ 0x42
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
24005bfe:	4b34      	ldr	r3, [pc, #208]	@ (24005cd0 <HAL_I2C_Mem_Read_DMA+0x130>)
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
24005c00:	f8c4 8044 	str.w	r8, [r4, #68]	@ 0x44
    hi2c->XferCount   = Size;
24005c04:	f8a4 a02a 	strh.w	sl, [r4, #42]	@ 0x2a
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
24005c08:	62e3      	str	r3, [r4, #44]	@ 0x2c
    hi2c->XferISR     = I2C_Master_ISR_DMA;
24005c0a:	4b32      	ldr	r3, [pc, #200]	@ (24005cd4 <HAL_I2C_Mem_Read_DMA+0x134>)
24005c0c:	6363      	str	r3, [r4, #52]	@ 0x34
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
24005c0e:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
24005c10:	b29b      	uxth	r3, r3
24005c12:	2bff      	cmp	r3, #255	@ 0xff
24005c14:	d813      	bhi.n	24005c3e <HAL_I2C_Mem_Read_DMA+0x9e>
      hi2c->XferSize = hi2c->XferCount;
24005c16:	8d61      	ldrh	r1, [r4, #42]	@ 0x2a
      xfermode = I2C_AUTOEND_MODE;
24005c18:	f04f 7800 	mov.w	r8, #33554432	@ 0x2000000
      hi2c->XferSize = hi2c->XferCount;
24005c1c:	b289      	uxth	r1, r1
    if (I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, I2C_TIMEOUT_FLAG, tickstart) != HAL_OK)
24005c1e:	2319      	movs	r3, #25
24005c20:	8521      	strh	r1, [r4, #40]	@ 0x28
24005c22:	4632      	mov	r2, r6
24005c24:	9001      	str	r0, [sp, #4]
24005c26:	9300      	str	r3, [sp, #0]
24005c28:	4639      	mov	r1, r7
24005c2a:	464b      	mov	r3, r9
24005c2c:	4620      	mov	r0, r4
24005c2e:	f7fe fefd 	bl	24004a2c <I2C_RequestMemoryRead>
24005c32:	4606      	mov	r6, r0
24005c34:	b138      	cbz	r0, 24005c46 <HAL_I2C_Mem_Read_DMA+0xa6>
      __HAL_UNLOCK(hi2c);
24005c36:	2300      	movs	r3, #0
24005c38:	f884 3040 	strb.w	r3, [r4, #64]	@ 0x40
      return HAL_ERROR;
24005c3c:	e7c5      	b.n	24005bca <HAL_I2C_Mem_Read_DMA+0x2a>
      hi2c->XferSize = MAX_NBYTE_SIZE;
24005c3e:	21ff      	movs	r1, #255	@ 0xff
      xfermode = I2C_RELOAD_MODE;
24005c40:	f04f 7880 	mov.w	r8, #16777216	@ 0x1000000
24005c44:	e7eb      	b.n	24005c1e <HAL_I2C_Mem_Read_DMA+0x7e>
    if (hi2c->hdmarx != NULL)
24005c46:	6be0      	ldr	r0, [r4, #60]	@ 0x3c
24005c48:	b338      	cbz	r0, 24005c9a <HAL_I2C_Mem_Read_DMA+0xfa>
      hi2c->hdmarx->XferCpltCallback = I2C_DMAMasterReceiveCplt;
24005c4a:	4b23      	ldr	r3, [pc, #140]	@ (24005cd8 <HAL_I2C_Mem_Read_DMA+0x138>)
      dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)pData, hi2c->XferSize);
24005c4c:	462a      	mov	r2, r5
24005c4e:	6821      	ldr	r1, [r4, #0]
      hi2c->hdmarx->XferCpltCallback = I2C_DMAMasterReceiveCplt;
24005c50:	63c3      	str	r3, [r0, #60]	@ 0x3c
      hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
24005c52:	4b22      	ldr	r3, [pc, #136]	@ (24005cdc <HAL_I2C_Mem_Read_DMA+0x13c>)
      dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)pData, hi2c->XferSize);
24005c54:	3124      	adds	r1, #36	@ 0x24
      hi2c->hdmarx->XferHalfCpltCallback = NULL;
24005c56:	6406      	str	r6, [r0, #64]	@ 0x40
      hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
24005c58:	64c3      	str	r3, [r0, #76]	@ 0x4c
      hi2c->hdmarx->XferAbortCallback = NULL;
24005c5a:	6506      	str	r6, [r0, #80]	@ 0x50
      dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)pData, hi2c->XferSize);
24005c5c:	8d23      	ldrh	r3, [r4, #40]	@ 0x28
24005c5e:	f7fb febf 	bl	240019e0 <HAL_DMA_Start_IT>
    if (dmaxferstatus == HAL_OK)
24005c62:	4605      	mov	r5, r0
24005c64:	bb28      	cbnz	r0, 24005cb2 <HAL_I2C_Mem_Read_DMA+0x112>
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, I2C_GENERATE_START_READ);
24005c66:	4b1e      	ldr	r3, [pc, #120]	@ (24005ce0 <HAL_I2C_Mem_Read_DMA+0x140>)
24005c68:	4639      	mov	r1, r7
24005c6a:	8d26      	ldrh	r6, [r4, #40]	@ 0x28
24005c6c:	4620      	mov	r0, r4
24005c6e:	9300      	str	r3, [sp, #0]
24005c70:	4643      	mov	r3, r8
24005c72:	f894 2028 	ldrb.w	r2, [r4, #40]	@ 0x28
24005c76:	f7fe fd39 	bl	240046ec <I2C_TransferConfig>
      hi2c->XferCount -= hi2c->XferSize;
24005c7a:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
      I2C_Enable_IRQ(hi2c, I2C_XFER_ERROR_IT);
24005c7c:	2110      	movs	r1, #16
24005c7e:	4620      	mov	r0, r4
      hi2c->XferCount -= hi2c->XferSize;
24005c80:	1b9b      	subs	r3, r3, r6
      __HAL_UNLOCK(hi2c);
24005c82:	f884 5040 	strb.w	r5, [r4, #64]	@ 0x40
      hi2c->XferCount -= hi2c->XferSize;
24005c86:	b29b      	uxth	r3, r3
24005c88:	8563      	strh	r3, [r4, #42]	@ 0x2a
      I2C_Enable_IRQ(hi2c, I2C_XFER_ERROR_IT);
24005c8a:	f7fe fd43 	bl	24004714 <I2C_Enable_IRQ>
      hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;
24005c8e:	6822      	ldr	r2, [r4, #0]
24005c90:	6813      	ldr	r3, [r2, #0]
24005c92:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
24005c96:	6013      	str	r3, [r2, #0]
    return HAL_OK;
24005c98:	e798      	b.n	24005bcc <HAL_I2C_Mem_Read_DMA+0x2c>
      hi2c->State     = HAL_I2C_STATE_READY;
24005c9a:	2320      	movs	r3, #32
      __HAL_UNLOCK(hi2c);
24005c9c:	f884 0040 	strb.w	r0, [r4, #64]	@ 0x40
      hi2c->State     = HAL_I2C_STATE_READY;
24005ca0:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
      hi2c->Mode      = HAL_I2C_MODE_NONE;
24005ca4:	f884 0042 	strb.w	r0, [r4, #66]	@ 0x42
      hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
24005ca8:	6c63      	ldr	r3, [r4, #68]	@ 0x44
24005caa:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
24005cae:	6463      	str	r3, [r4, #68]	@ 0x44
      return HAL_ERROR;
24005cb0:	e78b      	b.n	24005bca <HAL_I2C_Mem_Read_DMA+0x2a>
      hi2c->State     = HAL_I2C_STATE_READY;
24005cb2:	2320      	movs	r3, #32
      __HAL_UNLOCK(hi2c);
24005cb4:	f884 6040 	strb.w	r6, [r4, #64]	@ 0x40
      hi2c->State     = HAL_I2C_STATE_READY;
24005cb8:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
      hi2c->Mode      = HAL_I2C_MODE_NONE;
24005cbc:	f884 6042 	strb.w	r6, [r4, #66]	@ 0x42
      hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
24005cc0:	6c63      	ldr	r3, [r4, #68]	@ 0x44
24005cc2:	f043 0310 	orr.w	r3, r3, #16
24005cc6:	6463      	str	r3, [r4, #68]	@ 0x44
      return HAL_ERROR;
24005cc8:	e77f      	b.n	24005bca <HAL_I2C_Mem_Read_DMA+0x2a>
      return HAL_BUSY;
24005cca:	2502      	movs	r5, #2
24005ccc:	e77e      	b.n	24005bcc <HAL_I2C_Mem_Read_DMA+0x2c>
24005cce:	bf00      	nop
24005cd0:	ffff0000 	.word	0xffff0000
24005cd4:	24006c71 	.word	0x24006c71
24005cd8:	24006ea7 	.word	0x24006ea7
24005cdc:	24006d75 	.word	0x24006d75
24005ce0:	80002400 	.word	0x80002400

24005ce4 <HAL_I2C_IsDeviceReady>:
{
24005ce4:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
24005ce8:	461d      	mov	r5, r3
  __IO uint32_t I2C_Trials = 0UL;
24005cea:	2300      	movs	r3, #0
{
24005cec:	4604      	mov	r4, r0
24005cee:	4690      	mov	r8, r2
  __IO uint32_t I2C_Trials = 0UL;
24005cf0:	9303      	str	r3, [sp, #12]
  if (hi2c->State == HAL_I2C_STATE_READY)
24005cf2:	f890 3041 	ldrb.w	r3, [r0, #65]	@ 0x41
24005cf6:	2b20      	cmp	r3, #32
24005cf8:	d17c      	bne.n	24005df4 <HAL_I2C_IsDeviceReady+0x110>
    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
24005cfa:	6803      	ldr	r3, [r0, #0]
24005cfc:	699b      	ldr	r3, [r3, #24]
24005cfe:	f413 4300 	ands.w	r3, r3, #32768	@ 0x8000
24005d02:	d177      	bne.n	24005df4 <HAL_I2C_IsDeviceReady+0x110>
    __HAL_LOCK(hi2c);
24005d04:	f890 2040 	ldrb.w	r2, [r0, #64]	@ 0x40
24005d08:	2a01      	cmp	r2, #1
24005d0a:	d073      	beq.n	24005df4 <HAL_I2C_IsDeviceReady+0x110>
24005d0c:	2201      	movs	r2, #1
24005d0e:	f3c1 0609 	ubfx	r6, r1, #0, #10
24005d12:	f880 2040 	strb.w	r2, [r0, #64]	@ 0x40
      hi2c->Instance->CR2 = I2C_GENERATE_START(hi2c->Init.AddressingMode, DevAddress);
24005d16:	f446 5920 	orr.w	r9, r6, #10240	@ 0x2800
    hi2c->State = HAL_I2C_STATE_BUSY;
24005d1a:	2224      	movs	r2, #36	@ 0x24
24005d1c:	f880 2041 	strb.w	r2, [r0, #65]	@ 0x41
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
24005d20:	6443      	str	r3, [r0, #68]	@ 0x44
      hi2c->Instance->CR2 = I2C_GENERATE_START(hi2c->Init.AddressingMode, DevAddress);
24005d22:	68e3      	ldr	r3, [r4, #12]
24005d24:	6822      	ldr	r2, [r4, #0]
24005d26:	2b01      	cmp	r3, #1
24005d28:	bf0a      	itet	eq
24005d2a:	f046 7300 	orreq.w	r3, r6, #33554432	@ 0x2000000
24005d2e:	464b      	movne	r3, r9
24005d30:	f443 5300 	orreq.w	r3, r3, #8192	@ 0x2000
24005d34:	6053      	str	r3, [r2, #4]
      tickstart = HAL_GetTick();
24005d36:	f00c f867 	bl	24011e08 <HAL_GetTick>
24005d3a:	4607      	mov	r7, r0
        tmp1 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF);
24005d3c:	6822      	ldr	r2, [r4, #0]
24005d3e:	6993      	ldr	r3, [r2, #24]
        tmp2 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF);
24005d40:	6992      	ldr	r2, [r2, #24]
        tmp1 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF);
24005d42:	f3c3 1340 	ubfx	r3, r3, #5, #1
        tmp2 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF);
24005d46:	f3c2 1200 	ubfx	r2, r2, #4, #1
      while ((tmp1 == RESET) && (tmp2 == RESET))
24005d4a:	4313      	orrs	r3, r2
24005d4c:	d013      	beq.n	24005d76 <HAL_I2C_IsDeviceReady+0x92>
      if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == RESET)
24005d4e:	6823      	ldr	r3, [r4, #0]
24005d50:	699a      	ldr	r2, [r3, #24]
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_STOPF, RESET, Timeout, tickstart) != HAL_OK)
24005d52:	462b      	mov	r3, r5
24005d54:	9700      	str	r7, [sp, #0]
      if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == RESET)
24005d56:	f012 0210 	ands.w	r2, r2, #16
24005d5a:	d123      	bne.n	24005da4 <HAL_I2C_IsDeviceReady+0xc0>
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_STOPF, RESET, Timeout, tickstart) != HAL_OK)
24005d5c:	2120      	movs	r1, #32
24005d5e:	4620      	mov	r0, r4
24005d60:	f7fe fe04 	bl	2400496c <I2C_WaitOnFlagUntilTimeout>
24005d64:	b9d0      	cbnz	r0, 24005d9c <HAL_I2C_IsDeviceReady+0xb8>
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
24005d66:	2320      	movs	r3, #32
24005d68:	6822      	ldr	r2, [r4, #0]
24005d6a:	61d3      	str	r3, [r2, #28]
        hi2c->State = HAL_I2C_STATE_READY;
24005d6c:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
        __HAL_UNLOCK(hi2c);
24005d70:	f884 0040 	strb.w	r0, [r4, #64]	@ 0x40
        return HAL_OK;
24005d74:	e013      	b.n	24005d9e <HAL_I2C_IsDeviceReady+0xba>
        if (Timeout != HAL_MAX_DELAY)
24005d76:	1c6b      	adds	r3, r5, #1
24005d78:	d0e0      	beq.n	24005d3c <HAL_I2C_IsDeviceReady+0x58>
          if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
24005d7a:	f00c f845 	bl	24011e08 <HAL_GetTick>
24005d7e:	1bc0      	subs	r0, r0, r7
24005d80:	42a8      	cmp	r0, r5
24005d82:	d801      	bhi.n	24005d88 <HAL_I2C_IsDeviceReady+0xa4>
24005d84:	2d00      	cmp	r5, #0
24005d86:	d1d9      	bne.n	24005d3c <HAL_I2C_IsDeviceReady+0x58>
            hi2c->State = HAL_I2C_STATE_READY;
24005d88:	2320      	movs	r3, #32
24005d8a:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
            hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
24005d8e:	6c63      	ldr	r3, [r4, #68]	@ 0x44
24005d90:	f043 0320 	orr.w	r3, r3, #32
24005d94:	6463      	str	r3, [r4, #68]	@ 0x44
            __HAL_UNLOCK(hi2c);
24005d96:	2300      	movs	r3, #0
24005d98:	f884 3040 	strb.w	r3, [r4, #64]	@ 0x40
            return HAL_ERROR;
24005d9c:	2001      	movs	r0, #1
}
24005d9e:	b004      	add	sp, #16
24005da0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_STOPF, RESET, Timeout, tickstart) != HAL_OK)
24005da4:	2200      	movs	r2, #0
24005da6:	2120      	movs	r1, #32
24005da8:	4620      	mov	r0, r4
24005daa:	f7fe fddf 	bl	2400496c <I2C_WaitOnFlagUntilTimeout>
24005dae:	4602      	mov	r2, r0
24005db0:	2800      	cmp	r0, #0
24005db2:	d1f3      	bne.n	24005d9c <HAL_I2C_IsDeviceReady+0xb8>
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
24005db4:	6823      	ldr	r3, [r4, #0]
24005db6:	2110      	movs	r1, #16
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
24005db8:	f04f 0a20 	mov.w	sl, #32
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
24005dbc:	61d9      	str	r1, [r3, #28]
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
24005dbe:	f8c3 a01c 	str.w	sl, [r3, #28]
      if (I2C_Trials == Trials)
24005dc2:	9903      	ldr	r1, [sp, #12]
24005dc4:	4541      	cmp	r1, r8
24005dc6:	d10e      	bne.n	24005de6 <HAL_I2C_IsDeviceReady+0x102>
        hi2c->Instance->CR2 |= I2C_CR2_STOP;
24005dc8:	6859      	ldr	r1, [r3, #4]
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_STOPF, RESET, Timeout, tickstart) != HAL_OK)
24005dca:	4620      	mov	r0, r4
        hi2c->Instance->CR2 |= I2C_CR2_STOP;
24005dcc:	f441 4180 	orr.w	r1, r1, #16384	@ 0x4000
24005dd0:	6059      	str	r1, [r3, #4]
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_STOPF, RESET, Timeout, tickstart) != HAL_OK)
24005dd2:	462b      	mov	r3, r5
24005dd4:	4651      	mov	r1, sl
24005dd6:	9700      	str	r7, [sp, #0]
24005dd8:	f7fe fdc8 	bl	2400496c <I2C_WaitOnFlagUntilTimeout>
24005ddc:	2800      	cmp	r0, #0
24005dde:	d1dd      	bne.n	24005d9c <HAL_I2C_IsDeviceReady+0xb8>
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
24005de0:	6823      	ldr	r3, [r4, #0]
24005de2:	f8c3 a01c 	str.w	sl, [r3, #28]
      I2C_Trials++;
24005de6:	9b03      	ldr	r3, [sp, #12]
24005de8:	3301      	adds	r3, #1
24005dea:	9303      	str	r3, [sp, #12]
    while (I2C_Trials < Trials);
24005dec:	9b03      	ldr	r3, [sp, #12]
24005dee:	4543      	cmp	r3, r8
24005df0:	d397      	bcc.n	24005d22 <HAL_I2C_IsDeviceReady+0x3e>
24005df2:	e7c9      	b.n	24005d88 <HAL_I2C_IsDeviceReady+0xa4>
      return HAL_BUSY;
24005df4:	2002      	movs	r0, #2
24005df6:	e7d2      	b.n	24005d9e <HAL_I2C_IsDeviceReady+0xba>

24005df8 <HAL_I2C_Master_Seq_Transmit_IT>:
{
24005df8:	b537      	push	{r0, r1, r2, r4, r5, lr}
24005dfa:	4604      	mov	r4, r0
24005dfc:	9806      	ldr	r0, [sp, #24]
  if (hi2c->State == HAL_I2C_STATE_READY)
24005dfe:	f894 5041 	ldrb.w	r5, [r4, #65]	@ 0x41
24005e02:	2d20      	cmp	r5, #32
24005e04:	d143      	bne.n	24005e8e <HAL_I2C_Master_Seq_Transmit_IT+0x96>
    __HAL_LOCK(hi2c);
24005e06:	f894 5040 	ldrb.w	r5, [r4, #64]	@ 0x40
24005e0a:	2d01      	cmp	r5, #1
24005e0c:	d03f      	beq.n	24005e8e <HAL_I2C_Master_Seq_Transmit_IT+0x96>
24005e0e:	2501      	movs	r5, #1
    hi2c->pBuffPtr    = pData;
24005e10:	6262      	str	r2, [r4, #36]	@ 0x24
    __HAL_LOCK(hi2c);
24005e12:	f884 5040 	strb.w	r5, [r4, #64]	@ 0x40
    hi2c->State     = HAL_I2C_STATE_BUSY_TX;
24005e16:	2521      	movs	r5, #33	@ 0x21
24005e18:	f884 5041 	strb.w	r5, [r4, #65]	@ 0x41
    hi2c->Mode      = HAL_I2C_MODE_MASTER;
24005e1c:	2510      	movs	r5, #16
24005e1e:	f884 5042 	strb.w	r5, [r4, #66]	@ 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
24005e22:	2500      	movs	r5, #0
24005e24:	6465      	str	r5, [r4, #68]	@ 0x44
    hi2c->XferCount   = Size;
24005e26:	8563      	strh	r3, [r4, #42]	@ 0x2a
    hi2c->XferISR     = I2C_Master_ISR_IT;
24005e28:	4b1a      	ldr	r3, [pc, #104]	@ (24005e94 <HAL_I2C_Master_Seq_Transmit_IT+0x9c>)
    hi2c->XferOptions = XferOptions;
24005e2a:	62e0      	str	r0, [r4, #44]	@ 0x2c
    hi2c->XferISR     = I2C_Master_ISR_IT;
24005e2c:	6363      	str	r3, [r4, #52]	@ 0x34
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
24005e2e:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
24005e30:	b29b      	uxth	r3, r3
24005e32:	2bff      	cmp	r3, #255	@ 0xff
24005e34:	d915      	bls.n	24005e62 <HAL_I2C_Master_Seq_Transmit_IT+0x6a>
      hi2c->XferSize = MAX_NBYTE_SIZE;
24005e36:	23ff      	movs	r3, #255	@ 0xff
      xfermode = I2C_RELOAD_MODE;
24005e38:	f04f 7280 	mov.w	r2, #16777216	@ 0x1000000
      hi2c->XferSize = MAX_NBYTE_SIZE;
24005e3c:	8523      	strh	r3, [r4, #40]	@ 0x28
    if ((hi2c->PreviousState == I2C_STATE_MASTER_BUSY_TX) && (IS_I2C_TRANSFER_OTHER_OPTIONS_REQUEST(XferOptions) == 0))
24005e3e:	6b23      	ldr	r3, [r4, #48]	@ 0x30
24005e40:	2b11      	cmp	r3, #17
24005e42:	d104      	bne.n	24005e4e <HAL_I2C_Master_Seq_Transmit_IT+0x56>
24005e44:	28aa      	cmp	r0, #170	@ 0xaa
24005e46:	d002      	beq.n	24005e4e <HAL_I2C_Master_Seq_Transmit_IT+0x56>
24005e48:	f5b0 4f2a 	cmp.w	r0, #43520	@ 0xaa00
24005e4c:	d10d      	bne.n	24005e6a <HAL_I2C_Master_Seq_Transmit_IT+0x72>
      I2C_ConvertOtherXferOptions(hi2c);
24005e4e:	4620      	mov	r0, r4
24005e50:	f7fe fcb7 	bl	240047c2 <I2C_ConvertOtherXferOptions>
      if (hi2c->XferCount < MAX_NBYTE_SIZE)
24005e54:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
24005e56:	b29b      	uxth	r3, r3
24005e58:	2bfe      	cmp	r3, #254	@ 0xfe
24005e5a:	d800      	bhi.n	24005e5e <HAL_I2C_Master_Seq_Transmit_IT+0x66>
        xfermode = hi2c->XferOptions;
24005e5c:	6ae2      	ldr	r2, [r4, #44]	@ 0x2c
  uint32_t xferrequest = I2C_GENERATE_START_WRITE;
24005e5e:	4b0e      	ldr	r3, [pc, #56]	@ (24005e98 <HAL_I2C_Master_Seq_Transmit_IT+0xa0>)
24005e60:	e004      	b.n	24005e6c <HAL_I2C_Master_Seq_Transmit_IT+0x74>
      hi2c->XferSize = hi2c->XferCount;
24005e62:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
      xfermode = hi2c->XferOptions;
24005e64:	6ae2      	ldr	r2, [r4, #44]	@ 0x2c
      hi2c->XferSize = hi2c->XferCount;
24005e66:	8523      	strh	r3, [r4, #40]	@ 0x28
      xfermode = hi2c->XferOptions;
24005e68:	e7e9      	b.n	24005e3e <HAL_I2C_Master_Seq_Transmit_IT+0x46>
      xferrequest = I2C_NO_STARTSTOP;
24005e6a:	2300      	movs	r3, #0
    __HAL_UNLOCK(hi2c);
24005e6c:	2500      	movs	r5, #0
    I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, xferrequest);
24005e6e:	9300      	str	r3, [sp, #0]
24005e70:	4620      	mov	r0, r4
24005e72:	4613      	mov	r3, r2
24005e74:	f894 2028 	ldrb.w	r2, [r4, #40]	@ 0x28
24005e78:	f7fe fc38 	bl	240046ec <I2C_TransferConfig>
    I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT);
24005e7c:	4620      	mov	r0, r4
24005e7e:	2101      	movs	r1, #1
    __HAL_UNLOCK(hi2c);
24005e80:	f884 5040 	strb.w	r5, [r4, #64]	@ 0x40
    I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT);
24005e84:	f7fe fc46 	bl	24004714 <I2C_Enable_IRQ>
    return HAL_OK;
24005e88:	4628      	mov	r0, r5
}
24005e8a:	b003      	add	sp, #12
24005e8c:	bd30      	pop	{r4, r5, pc}
    __HAL_LOCK(hi2c);
24005e8e:	2002      	movs	r0, #2
24005e90:	e7fb      	b.n	24005e8a <HAL_I2C_Master_Seq_Transmit_IT+0x92>
24005e92:	bf00      	nop
24005e94:	24006b4f 	.word	0x24006b4f
24005e98:	80002000 	.word	0x80002000

24005e9c <HAL_I2C_Master_Seq_Transmit_DMA>:
{
24005e9c:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
24005ea0:	4604      	mov	r4, r0
  if (hi2c->State == HAL_I2C_STATE_READY)
24005ea2:	f890 0041 	ldrb.w	r0, [r0, #65]	@ 0x41
{
24005ea6:	460e      	mov	r6, r1
24005ea8:	4611      	mov	r1, r2
  if (hi2c->State == HAL_I2C_STATE_READY)
24005eaa:	2820      	cmp	r0, #32
{
24005eac:	9a0a      	ldr	r2, [sp, #40]	@ 0x28
  if (hi2c->State == HAL_I2C_STATE_READY)
24005eae:	f040 8091 	bne.w	24005fd4 <HAL_I2C_Master_Seq_Transmit_DMA+0x138>
    __HAL_LOCK(hi2c);
24005eb2:	f894 0040 	ldrb.w	r0, [r4, #64]	@ 0x40
24005eb6:	2801      	cmp	r0, #1
24005eb8:	f000 808c 	beq.w	24005fd4 <HAL_I2C_Master_Seq_Transmit_DMA+0x138>
24005ebc:	2001      	movs	r0, #1
    hi2c->pBuffPtr    = pData;
24005ebe:	6261      	str	r1, [r4, #36]	@ 0x24
    __HAL_LOCK(hi2c);
24005ec0:	f884 0040 	strb.w	r0, [r4, #64]	@ 0x40
    hi2c->State     = HAL_I2C_STATE_BUSY_TX;
24005ec4:	2021      	movs	r0, #33	@ 0x21
24005ec6:	f884 0041 	strb.w	r0, [r4, #65]	@ 0x41
    hi2c->Mode      = HAL_I2C_MODE_MASTER;
24005eca:	2010      	movs	r0, #16
24005ecc:	f884 0042 	strb.w	r0, [r4, #66]	@ 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
24005ed0:	2000      	movs	r0, #0
24005ed2:	6460      	str	r0, [r4, #68]	@ 0x44
    hi2c->XferCount   = Size;
24005ed4:	8563      	strh	r3, [r4, #42]	@ 0x2a
    hi2c->XferISR     = I2C_Master_ISR_DMA;
24005ed6:	4b40      	ldr	r3, [pc, #256]	@ (24005fd8 <HAL_I2C_Master_Seq_Transmit_DMA+0x13c>)
    hi2c->XferOptions = XferOptions;
24005ed8:	62e2      	str	r2, [r4, #44]	@ 0x2c
    hi2c->XferISR     = I2C_Master_ISR_DMA;
24005eda:	6363      	str	r3, [r4, #52]	@ 0x34
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
24005edc:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
24005ede:	b29b      	uxth	r3, r3
24005ee0:	2bff      	cmp	r3, #255	@ 0xff
24005ee2:	d917      	bls.n	24005f14 <HAL_I2C_Master_Seq_Transmit_DMA+0x78>
      hi2c->XferSize = MAX_NBYTE_SIZE;
24005ee4:	23ff      	movs	r3, #255	@ 0xff
      xfermode = I2C_RELOAD_MODE;
24005ee6:	f04f 7880 	mov.w	r8, #16777216	@ 0x1000000
      hi2c->XferSize = MAX_NBYTE_SIZE;
24005eea:	8523      	strh	r3, [r4, #40]	@ 0x28
    if ((hi2c->PreviousState == I2C_STATE_MASTER_BUSY_TX) && (IS_I2C_TRANSFER_OTHER_OPTIONS_REQUEST(XferOptions) == 0))
24005eec:	6b23      	ldr	r3, [r4, #48]	@ 0x30
24005eee:	2b11      	cmp	r3, #17
24005ef0:	d104      	bne.n	24005efc <HAL_I2C_Master_Seq_Transmit_DMA+0x60>
24005ef2:	2aaa      	cmp	r2, #170	@ 0xaa
24005ef4:	d002      	beq.n	24005efc <HAL_I2C_Master_Seq_Transmit_DMA+0x60>
24005ef6:	f5b2 4f2a 	cmp.w	r2, #43520	@ 0xaa00
24005efa:	d110      	bne.n	24005f1e <HAL_I2C_Master_Seq_Transmit_DMA+0x82>
      I2C_ConvertOtherXferOptions(hi2c);
24005efc:	4620      	mov	r0, r4
24005efe:	f7fe fc60 	bl	240047c2 <I2C_ConvertOtherXferOptions>
      if (hi2c->XferCount < MAX_NBYTE_SIZE)
24005f02:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
24005f04:	b29b      	uxth	r3, r3
24005f06:	2bfe      	cmp	r3, #254	@ 0xfe
24005f08:	d801      	bhi.n	24005f0e <HAL_I2C_Master_Seq_Transmit_DMA+0x72>
        xfermode = hi2c->XferOptions;
24005f0a:	f8d4 802c 	ldr.w	r8, [r4, #44]	@ 0x2c
  uint32_t xferrequest = I2C_GENERATE_START_WRITE;
24005f0e:	f8df 90d8 	ldr.w	r9, [pc, #216]	@ 24005fe8 <HAL_I2C_Master_Seq_Transmit_DMA+0x14c>
24005f12:	e006      	b.n	24005f22 <HAL_I2C_Master_Seq_Transmit_DMA+0x86>
      hi2c->XferSize = hi2c->XferCount;
24005f14:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
      xfermode = hi2c->XferOptions;
24005f16:	f8d4 802c 	ldr.w	r8, [r4, #44]	@ 0x2c
      hi2c->XferSize = hi2c->XferCount;
24005f1a:	8523      	strh	r3, [r4, #40]	@ 0x28
      xfermode = hi2c->XferOptions;
24005f1c:	e7e6      	b.n	24005eec <HAL_I2C_Master_Seq_Transmit_DMA+0x50>
      xferrequest = I2C_NO_STARTSTOP;
24005f1e:	f04f 0900 	mov.w	r9, #0
    if (hi2c->XferSize > 0U)
24005f22:	8d25      	ldrh	r5, [r4, #40]	@ 0x28
24005f24:	2d00      	cmp	r5, #0
24005f26:	d043      	beq.n	24005fb0 <HAL_I2C_Master_Seq_Transmit_DMA+0x114>
      if (hi2c->hdmatx != NULL)
24005f28:	6ba0      	ldr	r0, [r4, #56]	@ 0x38
24005f2a:	b340      	cbz	r0, 24005f7e <HAL_I2C_Master_Seq_Transmit_DMA+0xe2>
        hi2c->hdmatx->XferCpltCallback = I2C_DMAMasterTransmitCplt;
24005f2c:	4b2b      	ldr	r3, [pc, #172]	@ (24005fdc <HAL_I2C_Master_Seq_Transmit_DMA+0x140>)
        hi2c->hdmatx->XferHalfCpltCallback = NULL;
24005f2e:	2700      	movs	r7, #0
        dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->TXDR, hi2c->XferSize);
24005f30:	6822      	ldr	r2, [r4, #0]
        hi2c->hdmatx->XferCpltCallback = I2C_DMAMasterTransmitCplt;
24005f32:	63c3      	str	r3, [r0, #60]	@ 0x3c
        hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
24005f34:	4b2a      	ldr	r3, [pc, #168]	@ (24005fe0 <HAL_I2C_Master_Seq_Transmit_DMA+0x144>)
        dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->TXDR, hi2c->XferSize);
24005f36:	3228      	adds	r2, #40	@ 0x28
        hi2c->hdmatx->XferHalfCpltCallback = NULL;
24005f38:	6407      	str	r7, [r0, #64]	@ 0x40
        hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
24005f3a:	64c3      	str	r3, [r0, #76]	@ 0x4c
        dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->TXDR, hi2c->XferSize);
24005f3c:	462b      	mov	r3, r5
        hi2c->hdmatx->XferAbortCallback = NULL;
24005f3e:	6507      	str	r7, [r0, #80]	@ 0x50
        dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->TXDR, hi2c->XferSize);
24005f40:	f7fb fd4e 	bl	240019e0 <HAL_DMA_Start_IT>
      if (dmaxferstatus == HAL_OK)
24005f44:	4605      	mov	r5, r0
24005f46:	bb50      	cbnz	r0, 24005f9e <HAL_I2C_Master_Seq_Transmit_DMA+0x102>
        I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, xferrequest);
24005f48:	8d27      	ldrh	r7, [r4, #40]	@ 0x28
24005f4a:	4643      	mov	r3, r8
24005f4c:	4631      	mov	r1, r6
24005f4e:	4620      	mov	r0, r4
24005f50:	f8cd 9000 	str.w	r9, [sp]
24005f54:	f894 2028 	ldrb.w	r2, [r4, #40]	@ 0x28
24005f58:	f7fe fbc8 	bl	240046ec <I2C_TransferConfig>
        hi2c->XferCount -= hi2c->XferSize;
24005f5c:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
        I2C_Enable_IRQ(hi2c, I2C_XFER_ERROR_IT);
24005f5e:	2110      	movs	r1, #16
24005f60:	4620      	mov	r0, r4
        hi2c->XferCount -= hi2c->XferSize;
24005f62:	1bdb      	subs	r3, r3, r7
        __HAL_UNLOCK(hi2c);
24005f64:	f884 5040 	strb.w	r5, [r4, #64]	@ 0x40
        hi2c->XferCount -= hi2c->XferSize;
24005f68:	b29b      	uxth	r3, r3
24005f6a:	8563      	strh	r3, [r4, #42]	@ 0x2a
        I2C_Enable_IRQ(hi2c, I2C_XFER_ERROR_IT);
24005f6c:	f7fe fbd2 	bl	24004714 <I2C_Enable_IRQ>
        hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN;
24005f70:	6822      	ldr	r2, [r4, #0]
24005f72:	6813      	ldr	r3, [r2, #0]
24005f74:	f443 4380 	orr.w	r3, r3, #16384	@ 0x4000
24005f78:	6013      	str	r3, [r2, #0]
    return HAL_OK;
24005f7a:	2000      	movs	r0, #0
24005f7c:	e00c      	b.n	24005f98 <HAL_I2C_Master_Seq_Transmit_DMA+0xfc>
        hi2c->State     = HAL_I2C_STATE_READY;
24005f7e:	2320      	movs	r3, #32
24005f80:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
        hi2c->Mode      = HAL_I2C_MODE_NONE;
24005f84:	f884 0042 	strb.w	r0, [r4, #66]	@ 0x42
        hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
24005f88:	6c63      	ldr	r3, [r4, #68]	@ 0x44
24005f8a:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
        hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
24005f8e:	6463      	str	r3, [r4, #68]	@ 0x44
        return HAL_ERROR;
24005f90:	2001      	movs	r0, #1
        __HAL_UNLOCK(hi2c);
24005f92:	2300      	movs	r3, #0
24005f94:	f884 3040 	strb.w	r3, [r4, #64]	@ 0x40
}
24005f98:	b003      	add	sp, #12
24005f9a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        hi2c->State     = HAL_I2C_STATE_READY;
24005f9e:	2320      	movs	r3, #32
24005fa0:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
        hi2c->Mode      = HAL_I2C_MODE_NONE;
24005fa4:	f884 7042 	strb.w	r7, [r4, #66]	@ 0x42
        hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
24005fa8:	6c63      	ldr	r3, [r4, #68]	@ 0x44
24005faa:	f043 0310 	orr.w	r3, r3, #16
24005fae:	e7ee      	b.n	24005f8e <HAL_I2C_Master_Seq_Transmit_DMA+0xf2>
      hi2c->XferISR = I2C_Master_ISR_IT;
24005fb0:	4b0c      	ldr	r3, [pc, #48]	@ (24005fe4 <HAL_I2C_Master_Seq_Transmit_DMA+0x148>)
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_WRITE);
24005fb2:	4631      	mov	r1, r6
24005fb4:	4620      	mov	r0, r4
24005fb6:	462a      	mov	r2, r5
      hi2c->XferISR = I2C_Master_ISR_IT;
24005fb8:	6363      	str	r3, [r4, #52]	@ 0x34
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_WRITE);
24005fba:	4b0b      	ldr	r3, [pc, #44]	@ (24005fe8 <HAL_I2C_Master_Seq_Transmit_DMA+0x14c>)
24005fbc:	9300      	str	r3, [sp, #0]
24005fbe:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
24005fc2:	f7fe fb93 	bl	240046ec <I2C_TransferConfig>
      I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT);
24005fc6:	2101      	movs	r1, #1
24005fc8:	4620      	mov	r0, r4
      __HAL_UNLOCK(hi2c);
24005fca:	f884 5040 	strb.w	r5, [r4, #64]	@ 0x40
      I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT);
24005fce:	f7fe fba1 	bl	24004714 <I2C_Enable_IRQ>
24005fd2:	e7d2      	b.n	24005f7a <HAL_I2C_Master_Seq_Transmit_DMA+0xde>
    __HAL_LOCK(hi2c);
24005fd4:	2002      	movs	r0, #2
24005fd6:	e7df      	b.n	24005f98 <HAL_I2C_Master_Seq_Transmit_DMA+0xfc>
24005fd8:	24006c71 	.word	0x24006c71
24005fdc:	24006e55 	.word	0x24006e55
24005fe0:	24006d75 	.word	0x24006d75
24005fe4:	24006b4f 	.word	0x24006b4f
24005fe8:	80002000 	.word	0x80002000

24005fec <HAL_I2C_Master_Seq_Receive_IT>:
{
24005fec:	b537      	push	{r0, r1, r2, r4, r5, lr}
24005fee:	4604      	mov	r4, r0
24005ff0:	9806      	ldr	r0, [sp, #24]
  if (hi2c->State == HAL_I2C_STATE_READY)
24005ff2:	f894 5041 	ldrb.w	r5, [r4, #65]	@ 0x41
24005ff6:	2d20      	cmp	r5, #32
24005ff8:	d143      	bne.n	24006082 <HAL_I2C_Master_Seq_Receive_IT+0x96>
    __HAL_LOCK(hi2c);
24005ffa:	f894 5040 	ldrb.w	r5, [r4, #64]	@ 0x40
24005ffe:	2d01      	cmp	r5, #1
24006000:	d03f      	beq.n	24006082 <HAL_I2C_Master_Seq_Receive_IT+0x96>
24006002:	2501      	movs	r5, #1
    hi2c->pBuffPtr    = pData;
24006004:	6262      	str	r2, [r4, #36]	@ 0x24
    __HAL_LOCK(hi2c);
24006006:	f884 5040 	strb.w	r5, [r4, #64]	@ 0x40
    hi2c->State     = HAL_I2C_STATE_BUSY_RX;
2400600a:	2522      	movs	r5, #34	@ 0x22
2400600c:	f884 5041 	strb.w	r5, [r4, #65]	@ 0x41
    hi2c->Mode      = HAL_I2C_MODE_MASTER;
24006010:	2510      	movs	r5, #16
24006012:	f884 5042 	strb.w	r5, [r4, #66]	@ 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
24006016:	2500      	movs	r5, #0
24006018:	6465      	str	r5, [r4, #68]	@ 0x44
    hi2c->XferCount   = Size;
2400601a:	8563      	strh	r3, [r4, #42]	@ 0x2a
    hi2c->XferISR     = I2C_Master_ISR_IT;
2400601c:	4b1a      	ldr	r3, [pc, #104]	@ (24006088 <HAL_I2C_Master_Seq_Receive_IT+0x9c>)
    hi2c->XferOptions = XferOptions;
2400601e:	62e0      	str	r0, [r4, #44]	@ 0x2c
    hi2c->XferISR     = I2C_Master_ISR_IT;
24006020:	6363      	str	r3, [r4, #52]	@ 0x34
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
24006022:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
24006024:	b29b      	uxth	r3, r3
24006026:	2bff      	cmp	r3, #255	@ 0xff
24006028:	d915      	bls.n	24006056 <HAL_I2C_Master_Seq_Receive_IT+0x6a>
      hi2c->XferSize = MAX_NBYTE_SIZE;
2400602a:	23ff      	movs	r3, #255	@ 0xff
      xfermode = I2C_RELOAD_MODE;
2400602c:	f04f 7280 	mov.w	r2, #16777216	@ 0x1000000
      hi2c->XferSize = MAX_NBYTE_SIZE;
24006030:	8523      	strh	r3, [r4, #40]	@ 0x28
    if ((hi2c->PreviousState == I2C_STATE_MASTER_BUSY_RX) && (IS_I2C_TRANSFER_OTHER_OPTIONS_REQUEST(XferOptions) == 0))
24006032:	6b23      	ldr	r3, [r4, #48]	@ 0x30
24006034:	2b12      	cmp	r3, #18
24006036:	d104      	bne.n	24006042 <HAL_I2C_Master_Seq_Receive_IT+0x56>
24006038:	28aa      	cmp	r0, #170	@ 0xaa
2400603a:	d002      	beq.n	24006042 <HAL_I2C_Master_Seq_Receive_IT+0x56>
2400603c:	f5b0 4f2a 	cmp.w	r0, #43520	@ 0xaa00
24006040:	d10d      	bne.n	2400605e <HAL_I2C_Master_Seq_Receive_IT+0x72>
      I2C_ConvertOtherXferOptions(hi2c);
24006042:	4620      	mov	r0, r4
24006044:	f7fe fbbd 	bl	240047c2 <I2C_ConvertOtherXferOptions>
      if (hi2c->XferCount < MAX_NBYTE_SIZE)
24006048:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
2400604a:	b29b      	uxth	r3, r3
2400604c:	2bfe      	cmp	r3, #254	@ 0xfe
2400604e:	d800      	bhi.n	24006052 <HAL_I2C_Master_Seq_Receive_IT+0x66>
        xfermode = hi2c->XferOptions;
24006050:	6ae2      	ldr	r2, [r4, #44]	@ 0x2c
  uint32_t xferrequest = I2C_GENERATE_START_READ;
24006052:	4b0e      	ldr	r3, [pc, #56]	@ (2400608c <HAL_I2C_Master_Seq_Receive_IT+0xa0>)
24006054:	e004      	b.n	24006060 <HAL_I2C_Master_Seq_Receive_IT+0x74>
      hi2c->XferSize = hi2c->XferCount;
24006056:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
      xfermode = hi2c->XferOptions;
24006058:	6ae2      	ldr	r2, [r4, #44]	@ 0x2c
      hi2c->XferSize = hi2c->XferCount;
2400605a:	8523      	strh	r3, [r4, #40]	@ 0x28
      xfermode = hi2c->XferOptions;
2400605c:	e7e9      	b.n	24006032 <HAL_I2C_Master_Seq_Receive_IT+0x46>
      xferrequest = I2C_NO_STARTSTOP;
2400605e:	2300      	movs	r3, #0
    __HAL_UNLOCK(hi2c);
24006060:	2500      	movs	r5, #0
    I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, xferrequest);
24006062:	9300      	str	r3, [sp, #0]
24006064:	4620      	mov	r0, r4
24006066:	4613      	mov	r3, r2
24006068:	f894 2028 	ldrb.w	r2, [r4, #40]	@ 0x28
2400606c:	f7fe fb3e 	bl	240046ec <I2C_TransferConfig>
    I2C_Enable_IRQ(hi2c, I2C_XFER_RX_IT);
24006070:	4620      	mov	r0, r4
24006072:	2102      	movs	r1, #2
    __HAL_UNLOCK(hi2c);
24006074:	f884 5040 	strb.w	r5, [r4, #64]	@ 0x40
    I2C_Enable_IRQ(hi2c, I2C_XFER_RX_IT);
24006078:	f7fe fb4c 	bl	24004714 <I2C_Enable_IRQ>
    return HAL_OK;
2400607c:	4628      	mov	r0, r5
}
2400607e:	b003      	add	sp, #12
24006080:	bd30      	pop	{r4, r5, pc}
    __HAL_LOCK(hi2c);
24006082:	2002      	movs	r0, #2
24006084:	e7fb      	b.n	2400607e <HAL_I2C_Master_Seq_Receive_IT+0x92>
24006086:	bf00      	nop
24006088:	24006b4f 	.word	0x24006b4f
2400608c:	80002400 	.word	0x80002400

24006090 <HAL_I2C_Master_Seq_Receive_DMA>:
{
24006090:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
24006094:	4604      	mov	r4, r0
  if (hi2c->State == HAL_I2C_STATE_READY)
24006096:	f890 0041 	ldrb.w	r0, [r0, #65]	@ 0x41
{
2400609a:	460d      	mov	r5, r1
2400609c:	990a      	ldr	r1, [sp, #40]	@ 0x28
  if (hi2c->State == HAL_I2C_STATE_READY)
2400609e:	2820      	cmp	r0, #32
240060a0:	f040 8091 	bne.w	240061c6 <HAL_I2C_Master_Seq_Receive_DMA+0x136>
    __HAL_LOCK(hi2c);
240060a4:	f894 0040 	ldrb.w	r0, [r4, #64]	@ 0x40
240060a8:	2801      	cmp	r0, #1
240060aa:	f000 808c 	beq.w	240061c6 <HAL_I2C_Master_Seq_Receive_DMA+0x136>
240060ae:	2001      	movs	r0, #1
    hi2c->pBuffPtr    = pData;
240060b0:	6262      	str	r2, [r4, #36]	@ 0x24
    __HAL_LOCK(hi2c);
240060b2:	f884 0040 	strb.w	r0, [r4, #64]	@ 0x40
    hi2c->State     = HAL_I2C_STATE_BUSY_RX;
240060b6:	2022      	movs	r0, #34	@ 0x22
240060b8:	f884 0041 	strb.w	r0, [r4, #65]	@ 0x41
    hi2c->Mode      = HAL_I2C_MODE_MASTER;
240060bc:	2010      	movs	r0, #16
240060be:	f884 0042 	strb.w	r0, [r4, #66]	@ 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
240060c2:	2000      	movs	r0, #0
240060c4:	6460      	str	r0, [r4, #68]	@ 0x44
    hi2c->XferCount   = Size;
240060c6:	8563      	strh	r3, [r4, #42]	@ 0x2a
    hi2c->XferISR     = I2C_Master_ISR_DMA;
240060c8:	4b40      	ldr	r3, [pc, #256]	@ (240061cc <HAL_I2C_Master_Seq_Receive_DMA+0x13c>)
    hi2c->XferOptions = XferOptions;
240060ca:	62e1      	str	r1, [r4, #44]	@ 0x2c
    hi2c->XferISR     = I2C_Master_ISR_DMA;
240060cc:	6363      	str	r3, [r4, #52]	@ 0x34
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
240060ce:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
240060d0:	b29b      	uxth	r3, r3
240060d2:	2bff      	cmp	r3, #255	@ 0xff
240060d4:	d917      	bls.n	24006106 <HAL_I2C_Master_Seq_Receive_DMA+0x76>
      hi2c->XferSize = MAX_NBYTE_SIZE;
240060d6:	23ff      	movs	r3, #255	@ 0xff
      xfermode = I2C_RELOAD_MODE;
240060d8:	f04f 7880 	mov.w	r8, #16777216	@ 0x1000000
      hi2c->XferSize = MAX_NBYTE_SIZE;
240060dc:	8523      	strh	r3, [r4, #40]	@ 0x28
    if ((hi2c->PreviousState == I2C_STATE_MASTER_BUSY_RX) && (IS_I2C_TRANSFER_OTHER_OPTIONS_REQUEST(XferOptions) == 0))
240060de:	6b23      	ldr	r3, [r4, #48]	@ 0x30
240060e0:	2b12      	cmp	r3, #18
240060e2:	d104      	bne.n	240060ee <HAL_I2C_Master_Seq_Receive_DMA+0x5e>
240060e4:	29aa      	cmp	r1, #170	@ 0xaa
240060e6:	d002      	beq.n	240060ee <HAL_I2C_Master_Seq_Receive_DMA+0x5e>
240060e8:	f5b1 4f2a 	cmp.w	r1, #43520	@ 0xaa00
240060ec:	d110      	bne.n	24006110 <HAL_I2C_Master_Seq_Receive_DMA+0x80>
      I2C_ConvertOtherXferOptions(hi2c);
240060ee:	4620      	mov	r0, r4
240060f0:	f7fe fb67 	bl	240047c2 <I2C_ConvertOtherXferOptions>
      if (hi2c->XferCount < MAX_NBYTE_SIZE)
240060f4:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
240060f6:	b29b      	uxth	r3, r3
240060f8:	2bfe      	cmp	r3, #254	@ 0xfe
240060fa:	d801      	bhi.n	24006100 <HAL_I2C_Master_Seq_Receive_DMA+0x70>
        xfermode = hi2c->XferOptions;
240060fc:	f8d4 802c 	ldr.w	r8, [r4, #44]	@ 0x2c
  uint32_t xferrequest = I2C_GENERATE_START_READ;
24006100:	f8df 90d8 	ldr.w	r9, [pc, #216]	@ 240061dc <HAL_I2C_Master_Seq_Receive_DMA+0x14c>
24006104:	e006      	b.n	24006114 <HAL_I2C_Master_Seq_Receive_DMA+0x84>
      hi2c->XferSize = hi2c->XferCount;
24006106:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
      xfermode = hi2c->XferOptions;
24006108:	f8d4 802c 	ldr.w	r8, [r4, #44]	@ 0x2c
      hi2c->XferSize = hi2c->XferCount;
2400610c:	8523      	strh	r3, [r4, #40]	@ 0x28
      xfermode = hi2c->XferOptions;
2400610e:	e7e6      	b.n	240060de <HAL_I2C_Master_Seq_Receive_DMA+0x4e>
      xferrequest = I2C_NO_STARTSTOP;
24006110:	f04f 0900 	mov.w	r9, #0
    if (hi2c->XferSize > 0U)
24006114:	8d26      	ldrh	r6, [r4, #40]	@ 0x28
24006116:	2e00      	cmp	r6, #0
24006118:	d043      	beq.n	240061a2 <HAL_I2C_Master_Seq_Receive_DMA+0x112>
      if (hi2c->hdmarx != NULL)
2400611a:	6be0      	ldr	r0, [r4, #60]	@ 0x3c
2400611c:	b340      	cbz	r0, 24006170 <HAL_I2C_Master_Seq_Receive_DMA+0xe0>
        hi2c->hdmarx->XferCpltCallback = I2C_DMAMasterReceiveCplt;
2400611e:	4b2c      	ldr	r3, [pc, #176]	@ (240061d0 <HAL_I2C_Master_Seq_Receive_DMA+0x140>)
        hi2c->hdmarx->XferHalfCpltCallback = NULL;
24006120:	2700      	movs	r7, #0
        dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)pData, hi2c->XferSize);
24006122:	6821      	ldr	r1, [r4, #0]
        hi2c->hdmarx->XferCpltCallback = I2C_DMAMasterReceiveCplt;
24006124:	63c3      	str	r3, [r0, #60]	@ 0x3c
        hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
24006126:	4b2b      	ldr	r3, [pc, #172]	@ (240061d4 <HAL_I2C_Master_Seq_Receive_DMA+0x144>)
        dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)pData, hi2c->XferSize);
24006128:	3124      	adds	r1, #36	@ 0x24
        hi2c->hdmarx->XferHalfCpltCallback = NULL;
2400612a:	6407      	str	r7, [r0, #64]	@ 0x40
        hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
2400612c:	64c3      	str	r3, [r0, #76]	@ 0x4c
        dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)pData, hi2c->XferSize);
2400612e:	4633      	mov	r3, r6
        hi2c->hdmarx->XferAbortCallback = NULL;
24006130:	6507      	str	r7, [r0, #80]	@ 0x50
        dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)pData, hi2c->XferSize);
24006132:	f7fb fc55 	bl	240019e0 <HAL_DMA_Start_IT>
      if (dmaxferstatus == HAL_OK)
24006136:	4606      	mov	r6, r0
24006138:	bb50      	cbnz	r0, 24006190 <HAL_I2C_Master_Seq_Receive_DMA+0x100>
        I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, xferrequest);
2400613a:	8d27      	ldrh	r7, [r4, #40]	@ 0x28
2400613c:	4643      	mov	r3, r8
2400613e:	4629      	mov	r1, r5
24006140:	4620      	mov	r0, r4
24006142:	f8cd 9000 	str.w	r9, [sp]
24006146:	f894 2028 	ldrb.w	r2, [r4, #40]	@ 0x28
2400614a:	f7fe facf 	bl	240046ec <I2C_TransferConfig>
        hi2c->XferCount -= hi2c->XferSize;
2400614e:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
        I2C_Enable_IRQ(hi2c, I2C_XFER_ERROR_IT);
24006150:	2110      	movs	r1, #16
24006152:	4620      	mov	r0, r4
        hi2c->XferCount -= hi2c->XferSize;
24006154:	1bdb      	subs	r3, r3, r7
        __HAL_UNLOCK(hi2c);
24006156:	f884 6040 	strb.w	r6, [r4, #64]	@ 0x40
        hi2c->XferCount -= hi2c->XferSize;
2400615a:	b29b      	uxth	r3, r3
2400615c:	8563      	strh	r3, [r4, #42]	@ 0x2a
        I2C_Enable_IRQ(hi2c, I2C_XFER_ERROR_IT);
2400615e:	f7fe fad9 	bl	24004714 <I2C_Enable_IRQ>
        hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;
24006162:	6822      	ldr	r2, [r4, #0]
24006164:	6813      	ldr	r3, [r2, #0]
24006166:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
2400616a:	6013      	str	r3, [r2, #0]
    return HAL_OK;
2400616c:	2000      	movs	r0, #0
2400616e:	e00c      	b.n	2400618a <HAL_I2C_Master_Seq_Receive_DMA+0xfa>
        hi2c->State     = HAL_I2C_STATE_READY;
24006170:	2320      	movs	r3, #32
24006172:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
        hi2c->Mode      = HAL_I2C_MODE_NONE;
24006176:	f884 0042 	strb.w	r0, [r4, #66]	@ 0x42
        hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
2400617a:	6c63      	ldr	r3, [r4, #68]	@ 0x44
2400617c:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
        hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
24006180:	6463      	str	r3, [r4, #68]	@ 0x44
        return HAL_ERROR;
24006182:	2001      	movs	r0, #1
        __HAL_UNLOCK(hi2c);
24006184:	2300      	movs	r3, #0
24006186:	f884 3040 	strb.w	r3, [r4, #64]	@ 0x40
}
2400618a:	b003      	add	sp, #12
2400618c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        hi2c->State     = HAL_I2C_STATE_READY;
24006190:	2320      	movs	r3, #32
24006192:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
        hi2c->Mode      = HAL_I2C_MODE_NONE;
24006196:	f884 7042 	strb.w	r7, [r4, #66]	@ 0x42
        hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
2400619a:	6c63      	ldr	r3, [r4, #68]	@ 0x44
2400619c:	f043 0310 	orr.w	r3, r3, #16
240061a0:	e7ee      	b.n	24006180 <HAL_I2C_Master_Seq_Receive_DMA+0xf0>
      hi2c->XferISR = I2C_Master_ISR_IT;
240061a2:	4b0d      	ldr	r3, [pc, #52]	@ (240061d8 <HAL_I2C_Master_Seq_Receive_DMA+0x148>)
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_READ);
240061a4:	4629      	mov	r1, r5
240061a6:	4620      	mov	r0, r4
240061a8:	4632      	mov	r2, r6
      hi2c->XferISR = I2C_Master_ISR_IT;
240061aa:	6363      	str	r3, [r4, #52]	@ 0x34
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_READ);
240061ac:	4b0b      	ldr	r3, [pc, #44]	@ (240061dc <HAL_I2C_Master_Seq_Receive_DMA+0x14c>)
240061ae:	9300      	str	r3, [sp, #0]
240061b0:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
240061b4:	f7fe fa9a 	bl	240046ec <I2C_TransferConfig>
      I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT);
240061b8:	2101      	movs	r1, #1
240061ba:	4620      	mov	r0, r4
      __HAL_UNLOCK(hi2c);
240061bc:	f884 6040 	strb.w	r6, [r4, #64]	@ 0x40
      I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT);
240061c0:	f7fe faa8 	bl	24004714 <I2C_Enable_IRQ>
240061c4:	e7d2      	b.n	2400616c <HAL_I2C_Master_Seq_Receive_DMA+0xdc>
    __HAL_LOCK(hi2c);
240061c6:	2002      	movs	r0, #2
240061c8:	e7df      	b.n	2400618a <HAL_I2C_Master_Seq_Receive_DMA+0xfa>
240061ca:	bf00      	nop
240061cc:	24006c71 	.word	0x24006c71
240061d0:	24006ea7 	.word	0x24006ea7
240061d4:	24006d75 	.word	0x24006d75
240061d8:	24006b4f 	.word	0x24006b4f
240061dc:	80002400 	.word	0x80002400

240061e0 <HAL_I2C_Slave_Seq_Transmit_IT>:
{
240061e0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
240061e2:	461f      	mov	r7, r3
  if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
240061e4:	f890 3041 	ldrb.w	r3, [r0, #65]	@ 0x41
{
240061e8:	4604      	mov	r4, r0
240061ea:	460e      	mov	r6, r1
  if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
240061ec:	f003 0328 	and.w	r3, r3, #40	@ 0x28
{
240061f0:	4615      	mov	r5, r2
  if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
240061f2:	2b28      	cmp	r3, #40	@ 0x28
240061f4:	d001      	beq.n	240061fa <HAL_I2C_Slave_Seq_Transmit_IT+0x1a>
      return  HAL_ERROR;
240061f6:	2001      	movs	r0, #1
}
240061f8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if ((pData == NULL) || (Size == 0U))
240061fa:	b101      	cbz	r1, 240061fe <HAL_I2C_Slave_Seq_Transmit_IT+0x1e>
240061fc:	b91a      	cbnz	r2, 24006206 <HAL_I2C_Slave_Seq_Transmit_IT+0x26>
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
240061fe:	f44f 7300 	mov.w	r3, #512	@ 0x200
24006202:	6463      	str	r3, [r4, #68]	@ 0x44
      return  HAL_ERROR;
24006204:	e7f7      	b.n	240061f6 <HAL_I2C_Slave_Seq_Transmit_IT+0x16>
    I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_TX_IT);
24006206:	f248 0101 	movw	r1, #32769	@ 0x8001
2400620a:	f7fe fab9 	bl	24004780 <I2C_Disable_IRQ>
    __HAL_LOCK(hi2c);
2400620e:	f890 3040 	ldrb.w	r3, [r0, #64]	@ 0x40
24006212:	2b01      	cmp	r3, #1
24006214:	d03d      	beq.n	24006292 <HAL_I2C_Slave_Seq_Transmit_IT+0xb2>
24006216:	2301      	movs	r3, #1
24006218:	f880 3040 	strb.w	r3, [r0, #64]	@ 0x40
    if (hi2c->State == HAL_I2C_STATE_BUSY_RX_LISTEN)
2400621c:	f890 3041 	ldrb.w	r3, [r0, #65]	@ 0x41
24006220:	2b2a      	cmp	r3, #42	@ 0x2a
24006222:	d114      	bne.n	2400624e <HAL_I2C_Slave_Seq_Transmit_IT+0x6e>
      I2C_Disable_IRQ(hi2c, I2C_XFER_RX_IT);
24006224:	2102      	movs	r1, #2
24006226:	f7fe faab 	bl	24004780 <I2C_Disable_IRQ>
      if ((hi2c->Instance->CR1 & I2C_CR1_RXDMAEN) == I2C_CR1_RXDMAEN)
2400622a:	6803      	ldr	r3, [r0, #0]
2400622c:	681a      	ldr	r2, [r3, #0]
2400622e:	0412      	lsls	r2, r2, #16
24006230:	d50d      	bpl.n	2400624e <HAL_I2C_Slave_Seq_Transmit_IT+0x6e>
        hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
24006232:	681a      	ldr	r2, [r3, #0]
        if (hi2c->hdmarx != NULL)
24006234:	6bc0      	ldr	r0, [r0, #60]	@ 0x3c
        hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
24006236:	f422 4200 	bic.w	r2, r2, #32768	@ 0x8000
2400623a:	601a      	str	r2, [r3, #0]
        if (hi2c->hdmarx != NULL)
2400623c:	b138      	cbz	r0, 2400624e <HAL_I2C_Slave_Seq_Transmit_IT+0x6e>
          hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
2400623e:	4b16      	ldr	r3, [pc, #88]	@ (24006298 <HAL_I2C_Slave_Seq_Transmit_IT+0xb8>)
24006240:	6503      	str	r3, [r0, #80]	@ 0x50
          if (HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)
24006242:	f7fb fe93 	bl	24001f6c <HAL_DMA_Abort_IT>
24006246:	b110      	cbz	r0, 2400624e <HAL_I2C_Slave_Seq_Transmit_IT+0x6e>
            hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
24006248:	6be0      	ldr	r0, [r4, #60]	@ 0x3c
2400624a:	6d03      	ldr	r3, [r0, #80]	@ 0x50
2400624c:	4798      	blx	r3
    hi2c->State     = HAL_I2C_STATE_BUSY_TX_LISTEN;
2400624e:	2329      	movs	r3, #41	@ 0x29
    hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
24006250:	6820      	ldr	r0, [r4, #0]
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
24006252:	2200      	movs	r2, #0
    hi2c->State     = HAL_I2C_STATE_BUSY_TX_LISTEN;
24006254:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
    hi2c->Mode      = HAL_I2C_MODE_SLAVE;
24006258:	2320      	movs	r3, #32
2400625a:	f884 3042 	strb.w	r3, [r4, #66]	@ 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
2400625e:	6462      	str	r2, [r4, #68]	@ 0x44
    hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
24006260:	6843      	ldr	r3, [r0, #4]
24006262:	f423 4300 	bic.w	r3, r3, #32768	@ 0x8000
24006266:	6043      	str	r3, [r0, #4]
    hi2c->XferCount   = Size;
24006268:	8565      	strh	r5, [r4, #42]	@ 0x2a
    hi2c->XferSize    = hi2c->XferCount;
2400626a:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
    hi2c->XferOptions = XferOptions;
2400626c:	62e7      	str	r7, [r4, #44]	@ 0x2c
    hi2c->XferSize    = hi2c->XferCount;
2400626e:	8523      	strh	r3, [r4, #40]	@ 0x28
    hi2c->XferISR     = I2C_Slave_ISR_IT;
24006270:	4b0a      	ldr	r3, [pc, #40]	@ (2400629c <HAL_I2C_Slave_Seq_Transmit_IT+0xbc>)
    hi2c->pBuffPtr    = pData;
24006272:	6266      	str	r6, [r4, #36]	@ 0x24
    hi2c->XferISR     = I2C_Slave_ISR_IT;
24006274:	6363      	str	r3, [r4, #52]	@ 0x34
    if (I2C_GET_DIR(hi2c) == I2C_DIRECTION_RECEIVE)
24006276:	6983      	ldr	r3, [r0, #24]
24006278:	03db      	lsls	r3, r3, #15
2400627a:	d501      	bpl.n	24006280 <HAL_I2C_Slave_Seq_Transmit_IT+0xa0>
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
2400627c:	2308      	movs	r3, #8
2400627e:	61c3      	str	r3, [r0, #28]
    I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT | I2C_XFER_LISTEN_IT);
24006280:	4620      	mov	r0, r4
24006282:	f248 0101 	movw	r1, #32769	@ 0x8001
    __HAL_UNLOCK(hi2c);
24006286:	f884 2040 	strb.w	r2, [r4, #64]	@ 0x40
    I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT | I2C_XFER_LISTEN_IT);
2400628a:	f7fe fa43 	bl	24004714 <I2C_Enable_IRQ>
    return HAL_OK;
2400628e:	2000      	movs	r0, #0
24006290:	e7b2      	b.n	240061f8 <HAL_I2C_Slave_Seq_Transmit_IT+0x18>
    __HAL_LOCK(hi2c);
24006292:	2002      	movs	r0, #2
24006294:	e7b0      	b.n	240061f8 <HAL_I2C_Slave_Seq_Transmit_IT+0x18>
24006296:	bf00      	nop
24006298:	2400736b 	.word	0x2400736b
2400629c:	24007259 	.word	0x24007259

240062a0 <HAL_I2C_Slave_Seq_Transmit_DMA>:
{
240062a0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
240062a4:	4698      	mov	r8, r3
  if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
240062a6:	f890 3041 	ldrb.w	r3, [r0, #65]	@ 0x41
{
240062aa:	4604      	mov	r4, r0
240062ac:	460d      	mov	r5, r1
  if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
240062ae:	f003 0328 	and.w	r3, r3, #40	@ 0x28
{
240062b2:	4617      	mov	r7, r2
  if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
240062b4:	2b28      	cmp	r3, #40	@ 0x28
240062b6:	d104      	bne.n	240062c2 <HAL_I2C_Slave_Seq_Transmit_DMA+0x22>
    if ((pData == NULL) || (Size == 0U))
240062b8:	b101      	cbz	r1, 240062bc <HAL_I2C_Slave_Seq_Transmit_DMA+0x1c>
240062ba:	b932      	cbnz	r2, 240062ca <HAL_I2C_Slave_Seq_Transmit_DMA+0x2a>
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
240062bc:	f44f 7300 	mov.w	r3, #512	@ 0x200
240062c0:	6463      	str	r3, [r4, #68]	@ 0x44
      return  HAL_ERROR;
240062c2:	2501      	movs	r5, #1
}
240062c4:	4628      	mov	r0, r5
240062c6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    __HAL_LOCK(hi2c);
240062ca:	f890 3040 	ldrb.w	r3, [r0, #64]	@ 0x40
240062ce:	2b01      	cmp	r3, #1
240062d0:	f000 808e 	beq.w	240063f0 <HAL_I2C_Slave_Seq_Transmit_DMA+0x150>
240062d4:	2301      	movs	r3, #1
    I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_TX_IT);
240062d6:	f248 0101 	movw	r1, #32769	@ 0x8001
    __HAL_LOCK(hi2c);
240062da:	f880 3040 	strb.w	r3, [r0, #64]	@ 0x40
    I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_TX_IT);
240062de:	f7fe fa4f 	bl	24004780 <I2C_Disable_IRQ>
    if (hi2c->State == HAL_I2C_STATE_BUSY_RX_LISTEN)
240062e2:	f890 3041 	ldrb.w	r3, [r0, #65]	@ 0x41
240062e6:	2b2a      	cmp	r3, #42	@ 0x2a
240062e8:	d145      	bne.n	24006376 <HAL_I2C_Slave_Seq_Transmit_DMA+0xd6>
      I2C_Disable_IRQ(hi2c, I2C_XFER_RX_IT);
240062ea:	2102      	movs	r1, #2
240062ec:	f7fe fa48 	bl	24004780 <I2C_Disable_IRQ>
      if ((hi2c->Instance->CR1 & I2C_CR1_RXDMAEN) == I2C_CR1_RXDMAEN)
240062f0:	6803      	ldr	r3, [r0, #0]
240062f2:	681a      	ldr	r2, [r3, #0]
240062f4:	0411      	lsls	r1, r2, #16
240062f6:	d50d      	bpl.n	24006314 <HAL_I2C_Slave_Seq_Transmit_DMA+0x74>
        if (hi2c->hdmarx != NULL)
240062f8:	6bc0      	ldr	r0, [r0, #60]	@ 0x3c
240062fa:	b158      	cbz	r0, 24006314 <HAL_I2C_Slave_Seq_Transmit_DMA+0x74>
          hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
240062fc:	681a      	ldr	r2, [r3, #0]
240062fe:	f422 4200 	bic.w	r2, r2, #32768	@ 0x8000
24006302:	601a      	str	r2, [r3, #0]
          hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
24006304:	4b3b      	ldr	r3, [pc, #236]	@ (240063f4 <HAL_I2C_Slave_Seq_Transmit_DMA+0x154>)
24006306:	6503      	str	r3, [r0, #80]	@ 0x50
          if (HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)
24006308:	f7fb fe30 	bl	24001f6c <HAL_DMA_Abort_IT>
2400630c:	b110      	cbz	r0, 24006314 <HAL_I2C_Slave_Seq_Transmit_DMA+0x74>
            hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
2400630e:	6be0      	ldr	r0, [r4, #60]	@ 0x3c
            hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
24006310:	6d03      	ldr	r3, [r0, #80]	@ 0x50
24006312:	4798      	blx	r3
    hi2c->State     = HAL_I2C_STATE_BUSY_TX_LISTEN;
24006314:	2329      	movs	r3, #41	@ 0x29
    hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
24006316:	6822      	ldr	r2, [r4, #0]
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
24006318:	2600      	movs	r6, #0
    if (hi2c->hdmatx != NULL)
2400631a:	6ba0      	ldr	r0, [r4, #56]	@ 0x38
    hi2c->State     = HAL_I2C_STATE_BUSY_TX_LISTEN;
2400631c:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
    hi2c->Mode      = HAL_I2C_MODE_SLAVE;
24006320:	2320      	movs	r3, #32
24006322:	f884 3042 	strb.w	r3, [r4, #66]	@ 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
24006326:	6466      	str	r6, [r4, #68]	@ 0x44
    hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
24006328:	6853      	ldr	r3, [r2, #4]
2400632a:	f423 4300 	bic.w	r3, r3, #32768	@ 0x8000
2400632e:	6053      	str	r3, [r2, #4]
    hi2c->XferCount   = Size;
24006330:	8567      	strh	r7, [r4, #42]	@ 0x2a
    hi2c->XferSize    = hi2c->XferCount;
24006332:	8d61      	ldrh	r1, [r4, #42]	@ 0x2a
    hi2c->pBuffPtr    = pData;
24006334:	6265      	str	r5, [r4, #36]	@ 0x24
    hi2c->XferSize    = hi2c->XferCount;
24006336:	b28b      	uxth	r3, r1
    hi2c->XferISR     = I2C_Slave_ISR_DMA;
24006338:	492f      	ldr	r1, [pc, #188]	@ (240063f8 <HAL_I2C_Slave_Seq_Transmit_DMA+0x158>)
    hi2c->XferOptions = XferOptions;
2400633a:	f8c4 802c 	str.w	r8, [r4, #44]	@ 0x2c
    hi2c->XferSize    = hi2c->XferCount;
2400633e:	8523      	strh	r3, [r4, #40]	@ 0x28
    hi2c->XferISR     = I2C_Slave_ISR_DMA;
24006340:	6361      	str	r1, [r4, #52]	@ 0x34
    if (hi2c->hdmatx != NULL)
24006342:	2800      	cmp	r0, #0
24006344:	d02e      	beq.n	240063a4 <HAL_I2C_Slave_Seq_Transmit_DMA+0x104>
      hi2c->hdmatx->XferCpltCallback = I2C_DMASlaveTransmitCplt;
24006346:	492d      	ldr	r1, [pc, #180]	@ (240063fc <HAL_I2C_Slave_Seq_Transmit_DMA+0x15c>)
      dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->TXDR, hi2c->XferSize);
24006348:	3228      	adds	r2, #40	@ 0x28
      hi2c->hdmatx->XferHalfCpltCallback = NULL;
2400634a:	6406      	str	r6, [r0, #64]	@ 0x40
      hi2c->hdmatx->XferCpltCallback = I2C_DMASlaveTransmitCplt;
2400634c:	63c1      	str	r1, [r0, #60]	@ 0x3c
      hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
2400634e:	492c      	ldr	r1, [pc, #176]	@ (24006400 <HAL_I2C_Slave_Seq_Transmit_DMA+0x160>)
      hi2c->hdmatx->XferAbortCallback = NULL;
24006350:	6506      	str	r6, [r0, #80]	@ 0x50
      hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
24006352:	64c1      	str	r1, [r0, #76]	@ 0x4c
      dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->TXDR, hi2c->XferSize);
24006354:	4629      	mov	r1, r5
24006356:	f7fb fb43 	bl	240019e0 <HAL_DMA_Start_IT>
    if (dmaxferstatus == HAL_OK)
2400635a:	4605      	mov	r5, r0
2400635c:	b370      	cbz	r0, 240063bc <HAL_I2C_Slave_Seq_Transmit_DMA+0x11c>
      hi2c->State     = HAL_I2C_STATE_LISTEN;
2400635e:	2328      	movs	r3, #40	@ 0x28
      __HAL_UNLOCK(hi2c);
24006360:	f884 6040 	strb.w	r6, [r4, #64]	@ 0x40
      hi2c->State     = HAL_I2C_STATE_LISTEN;
24006364:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
      hi2c->Mode      = HAL_I2C_MODE_NONE;
24006368:	f884 6042 	strb.w	r6, [r4, #66]	@ 0x42
      hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
2400636c:	6c63      	ldr	r3, [r4, #68]	@ 0x44
2400636e:	f043 0310 	orr.w	r3, r3, #16
24006372:	6463      	str	r3, [r4, #68]	@ 0x44
      return HAL_ERROR;
24006374:	e7a5      	b.n	240062c2 <HAL_I2C_Slave_Seq_Transmit_DMA+0x22>
    else if (hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN)
24006376:	f890 2041 	ldrb.w	r2, [r0, #65]	@ 0x41
      if ((hi2c->Instance->CR1 & I2C_CR1_TXDMAEN) == I2C_CR1_TXDMAEN)
2400637a:	6803      	ldr	r3, [r0, #0]
    else if (hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN)
2400637c:	2a29      	cmp	r2, #41	@ 0x29
        if (hi2c->hdmatx != NULL)
2400637e:	6b80      	ldr	r0, [r0, #56]	@ 0x38
    else if (hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN)
24006380:	d1c8      	bne.n	24006314 <HAL_I2C_Slave_Seq_Transmit_DMA+0x74>
      if ((hi2c->Instance->CR1 & I2C_CR1_TXDMAEN) == I2C_CR1_TXDMAEN)
24006382:	681a      	ldr	r2, [r3, #0]
24006384:	0452      	lsls	r2, r2, #17
24006386:	d5c5      	bpl.n	24006314 <HAL_I2C_Slave_Seq_Transmit_DMA+0x74>
        hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
24006388:	681a      	ldr	r2, [r3, #0]
2400638a:	f422 4280 	bic.w	r2, r2, #16384	@ 0x4000
2400638e:	601a      	str	r2, [r3, #0]
        if (hi2c->hdmatx != NULL)
24006390:	2800      	cmp	r0, #0
24006392:	d0bf      	beq.n	24006314 <HAL_I2C_Slave_Seq_Transmit_DMA+0x74>
          hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
24006394:	4b17      	ldr	r3, [pc, #92]	@ (240063f4 <HAL_I2C_Slave_Seq_Transmit_DMA+0x154>)
24006396:	6503      	str	r3, [r0, #80]	@ 0x50
          if (HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)
24006398:	f7fb fde8 	bl	24001f6c <HAL_DMA_Abort_IT>
2400639c:	2800      	cmp	r0, #0
2400639e:	d0b9      	beq.n	24006314 <HAL_I2C_Slave_Seq_Transmit_DMA+0x74>
            hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
240063a0:	6ba0      	ldr	r0, [r4, #56]	@ 0x38
240063a2:	e7b5      	b.n	24006310 <HAL_I2C_Slave_Seq_Transmit_DMA+0x70>
      hi2c->State     = HAL_I2C_STATE_LISTEN;
240063a4:	2328      	movs	r3, #40	@ 0x28
      __HAL_UNLOCK(hi2c);
240063a6:	f884 0040 	strb.w	r0, [r4, #64]	@ 0x40
      hi2c->State     = HAL_I2C_STATE_LISTEN;
240063aa:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
      hi2c->Mode      = HAL_I2C_MODE_NONE;
240063ae:	f884 0042 	strb.w	r0, [r4, #66]	@ 0x42
      hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
240063b2:	6c63      	ldr	r3, [r4, #68]	@ 0x44
240063b4:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
240063b8:	6463      	str	r3, [r4, #68]	@ 0x44
      return HAL_ERROR;
240063ba:	e782      	b.n	240062c2 <HAL_I2C_Slave_Seq_Transmit_DMA+0x22>
      hi2c->XferCount -= hi2c->XferSize;
240063bc:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
240063be:	8d22      	ldrh	r2, [r4, #40]	@ 0x28
    if (I2C_GET_DIR(hi2c) == I2C_DIRECTION_RECEIVE)
240063c0:	6826      	ldr	r6, [r4, #0]
      hi2c->XferCount -= hi2c->XferSize;
240063c2:	1a9b      	subs	r3, r3, r2
      hi2c->XferSize = 0;
240063c4:	8520      	strh	r0, [r4, #40]	@ 0x28
      hi2c->XferCount -= hi2c->XferSize;
240063c6:	b29b      	uxth	r3, r3
240063c8:	8563      	strh	r3, [r4, #42]	@ 0x2a
    if (I2C_GET_DIR(hi2c) == I2C_DIRECTION_RECEIVE)
240063ca:	69b3      	ldr	r3, [r6, #24]
240063cc:	03db      	lsls	r3, r3, #15
240063ce:	d40c      	bmi.n	240063ea <HAL_I2C_Slave_Seq_Transmit_DMA+0x14a>
    __HAL_UNLOCK(hi2c);
240063d0:	2300      	movs	r3, #0
    I2C_Enable_IRQ(hi2c, I2C_XFER_LISTEN_IT);
240063d2:	f44f 4100 	mov.w	r1, #32768	@ 0x8000
240063d6:	4620      	mov	r0, r4
    __HAL_UNLOCK(hi2c);
240063d8:	f884 3040 	strb.w	r3, [r4, #64]	@ 0x40
    I2C_Enable_IRQ(hi2c, I2C_XFER_LISTEN_IT);
240063dc:	f7fe f99a 	bl	24004714 <I2C_Enable_IRQ>
    hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN;
240063e0:	6833      	ldr	r3, [r6, #0]
240063e2:	f443 4380 	orr.w	r3, r3, #16384	@ 0x4000
240063e6:	6033      	str	r3, [r6, #0]
    return HAL_OK;
240063e8:	e76c      	b.n	240062c4 <HAL_I2C_Slave_Seq_Transmit_DMA+0x24>
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
240063ea:	2308      	movs	r3, #8
240063ec:	61f3      	str	r3, [r6, #28]
240063ee:	e7ef      	b.n	240063d0 <HAL_I2C_Slave_Seq_Transmit_DMA+0x130>
    __HAL_LOCK(hi2c);
240063f0:	2502      	movs	r5, #2
240063f2:	e767      	b.n	240062c4 <HAL_I2C_Slave_Seq_Transmit_DMA+0x24>
240063f4:	2400736b 	.word	0x2400736b
240063f8:	240070c9 	.word	0x240070c9
240063fc:	240067c3 	.word	0x240067c3
24006400:	24006d75 	.word	0x24006d75

24006404 <HAL_I2C_Slave_Seq_Receive_IT>:
{
24006404:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
24006406:	461f      	mov	r7, r3
  if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
24006408:	f890 3041 	ldrb.w	r3, [r0, #65]	@ 0x41
{
2400640c:	4604      	mov	r4, r0
2400640e:	460e      	mov	r6, r1
  if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
24006410:	f003 0328 	and.w	r3, r3, #40	@ 0x28
{
24006414:	4615      	mov	r5, r2
  if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
24006416:	2b28      	cmp	r3, #40	@ 0x28
24006418:	d001      	beq.n	2400641e <HAL_I2C_Slave_Seq_Receive_IT+0x1a>
      return  HAL_ERROR;
2400641a:	2001      	movs	r0, #1
}
2400641c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if ((pData == NULL) || (Size == 0U))
2400641e:	b101      	cbz	r1, 24006422 <HAL_I2C_Slave_Seq_Receive_IT+0x1e>
24006420:	b91a      	cbnz	r2, 2400642a <HAL_I2C_Slave_Seq_Receive_IT+0x26>
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
24006422:	f44f 7300 	mov.w	r3, #512	@ 0x200
24006426:	6463      	str	r3, [r4, #68]	@ 0x44
      return  HAL_ERROR;
24006428:	e7f7      	b.n	2400641a <HAL_I2C_Slave_Seq_Receive_IT+0x16>
    I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_RX_IT);
2400642a:	f248 0102 	movw	r1, #32770	@ 0x8002
2400642e:	f7fe f9a7 	bl	24004780 <I2C_Disable_IRQ>
    __HAL_LOCK(hi2c);
24006432:	f890 3040 	ldrb.w	r3, [r0, #64]	@ 0x40
24006436:	2b01      	cmp	r3, #1
24006438:	d03c      	beq.n	240064b4 <HAL_I2C_Slave_Seq_Receive_IT+0xb0>
    if (hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN)
2400643a:	f890 3041 	ldrb.w	r3, [r0, #65]	@ 0x41
    __HAL_LOCK(hi2c);
2400643e:	2101      	movs	r1, #1
    if (hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN)
24006440:	2b29      	cmp	r3, #41	@ 0x29
    __HAL_LOCK(hi2c);
24006442:	f880 1040 	strb.w	r1, [r0, #64]	@ 0x40
    if (hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN)
24006446:	d113      	bne.n	24006470 <HAL_I2C_Slave_Seq_Receive_IT+0x6c>
      I2C_Disable_IRQ(hi2c, I2C_XFER_TX_IT);
24006448:	f7fe f99a 	bl	24004780 <I2C_Disable_IRQ>
      if ((hi2c->Instance->CR1 & I2C_CR1_TXDMAEN) == I2C_CR1_TXDMAEN)
2400644c:	6803      	ldr	r3, [r0, #0]
2400644e:	681a      	ldr	r2, [r3, #0]
24006450:	0452      	lsls	r2, r2, #17
24006452:	d50d      	bpl.n	24006470 <HAL_I2C_Slave_Seq_Receive_IT+0x6c>
        hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
24006454:	681a      	ldr	r2, [r3, #0]
        if (hi2c->hdmatx != NULL)
24006456:	6b80      	ldr	r0, [r0, #56]	@ 0x38
        hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
24006458:	f422 4280 	bic.w	r2, r2, #16384	@ 0x4000
2400645c:	601a      	str	r2, [r3, #0]
        if (hi2c->hdmatx != NULL)
2400645e:	b138      	cbz	r0, 24006470 <HAL_I2C_Slave_Seq_Receive_IT+0x6c>
          hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
24006460:	4b15      	ldr	r3, [pc, #84]	@ (240064b8 <HAL_I2C_Slave_Seq_Receive_IT+0xb4>)
24006462:	6503      	str	r3, [r0, #80]	@ 0x50
          if (HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)
24006464:	f7fb fd82 	bl	24001f6c <HAL_DMA_Abort_IT>
24006468:	b110      	cbz	r0, 24006470 <HAL_I2C_Slave_Seq_Receive_IT+0x6c>
            hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
2400646a:	6ba0      	ldr	r0, [r4, #56]	@ 0x38
2400646c:	6d03      	ldr	r3, [r0, #80]	@ 0x50
2400646e:	4798      	blx	r3
    hi2c->State     = HAL_I2C_STATE_BUSY_RX_LISTEN;
24006470:	232a      	movs	r3, #42	@ 0x2a
    hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
24006472:	6820      	ldr	r0, [r4, #0]
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
24006474:	2200      	movs	r2, #0
    hi2c->State     = HAL_I2C_STATE_BUSY_RX_LISTEN;
24006476:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
    hi2c->Mode      = HAL_I2C_MODE_SLAVE;
2400647a:	2320      	movs	r3, #32
2400647c:	f884 3042 	strb.w	r3, [r4, #66]	@ 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
24006480:	6462      	str	r2, [r4, #68]	@ 0x44
    hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
24006482:	6843      	ldr	r3, [r0, #4]
24006484:	f423 4300 	bic.w	r3, r3, #32768	@ 0x8000
24006488:	6043      	str	r3, [r0, #4]
    hi2c->XferCount   = Size;
2400648a:	8565      	strh	r5, [r4, #42]	@ 0x2a
    hi2c->XferSize    = hi2c->XferCount;
2400648c:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
    hi2c->XferOptions = XferOptions;
2400648e:	62e7      	str	r7, [r4, #44]	@ 0x2c
    hi2c->XferSize    = hi2c->XferCount;
24006490:	8523      	strh	r3, [r4, #40]	@ 0x28
    hi2c->XferISR     = I2C_Slave_ISR_IT;
24006492:	4b0a      	ldr	r3, [pc, #40]	@ (240064bc <HAL_I2C_Slave_Seq_Receive_IT+0xb8>)
    hi2c->pBuffPtr    = pData;
24006494:	6266      	str	r6, [r4, #36]	@ 0x24
    hi2c->XferISR     = I2C_Slave_ISR_IT;
24006496:	6363      	str	r3, [r4, #52]	@ 0x34
    if (I2C_GET_DIR(hi2c) == I2C_DIRECTION_TRANSMIT)
24006498:	6983      	ldr	r3, [r0, #24]
2400649a:	03db      	lsls	r3, r3, #15
2400649c:	d401      	bmi.n	240064a2 <HAL_I2C_Slave_Seq_Receive_IT+0x9e>
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
2400649e:	2308      	movs	r3, #8
240064a0:	61c3      	str	r3, [r0, #28]
    I2C_Enable_IRQ(hi2c, I2C_XFER_RX_IT | I2C_XFER_LISTEN_IT);
240064a2:	4620      	mov	r0, r4
240064a4:	f248 0102 	movw	r1, #32770	@ 0x8002
    __HAL_UNLOCK(hi2c);
240064a8:	f884 2040 	strb.w	r2, [r4, #64]	@ 0x40
    I2C_Enable_IRQ(hi2c, I2C_XFER_RX_IT | I2C_XFER_LISTEN_IT);
240064ac:	f7fe f932 	bl	24004714 <I2C_Enable_IRQ>
    return HAL_OK;
240064b0:	2000      	movs	r0, #0
240064b2:	e7b3      	b.n	2400641c <HAL_I2C_Slave_Seq_Receive_IT+0x18>
    __HAL_LOCK(hi2c);
240064b4:	2002      	movs	r0, #2
240064b6:	e7b1      	b.n	2400641c <HAL_I2C_Slave_Seq_Receive_IT+0x18>
240064b8:	2400736b 	.word	0x2400736b
240064bc:	24007259 	.word	0x24007259

240064c0 <HAL_I2C_Slave_Seq_Receive_DMA>:
{
240064c0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
240064c4:	4698      	mov	r8, r3
  if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
240064c6:	f890 3041 	ldrb.w	r3, [r0, #65]	@ 0x41
{
240064ca:	4604      	mov	r4, r0
240064cc:	460d      	mov	r5, r1
  if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
240064ce:	f003 0328 	and.w	r3, r3, #40	@ 0x28
{
240064d2:	4617      	mov	r7, r2
  if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
240064d4:	2b28      	cmp	r3, #40	@ 0x28
240064d6:	d104      	bne.n	240064e2 <HAL_I2C_Slave_Seq_Receive_DMA+0x22>
    if ((pData == NULL) || (Size == 0U))
240064d8:	b101      	cbz	r1, 240064dc <HAL_I2C_Slave_Seq_Receive_DMA+0x1c>
240064da:	b932      	cbnz	r2, 240064ea <HAL_I2C_Slave_Seq_Receive_DMA+0x2a>
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
240064dc:	f44f 7300 	mov.w	r3, #512	@ 0x200
240064e0:	6463      	str	r3, [r4, #68]	@ 0x44
      return  HAL_ERROR;
240064e2:	2501      	movs	r5, #1
}
240064e4:	4628      	mov	r0, r5
240064e6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_RX_IT);
240064ea:	f248 0102 	movw	r1, #32770	@ 0x8002
240064ee:	f7fe f947 	bl	24004780 <I2C_Disable_IRQ>
    __HAL_LOCK(hi2c);
240064f2:	f890 3040 	ldrb.w	r3, [r0, #64]	@ 0x40
240064f6:	2b01      	cmp	r3, #1
240064f8:	f000 8089 	beq.w	2400660e <HAL_I2C_Slave_Seq_Receive_DMA+0x14e>
    if (hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN)
240064fc:	f890 3041 	ldrb.w	r3, [r0, #65]	@ 0x41
    __HAL_LOCK(hi2c);
24006500:	2101      	movs	r1, #1
    if (hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN)
24006502:	2b29      	cmp	r3, #41	@ 0x29
    __HAL_LOCK(hi2c);
24006504:	f880 1040 	strb.w	r1, [r0, #64]	@ 0x40
    if (hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN)
24006508:	d144      	bne.n	24006594 <HAL_I2C_Slave_Seq_Receive_DMA+0xd4>
      I2C_Disable_IRQ(hi2c, I2C_XFER_TX_IT);
2400650a:	f7fe f939 	bl	24004780 <I2C_Disable_IRQ>
      if ((hi2c->Instance->CR1 & I2C_CR1_TXDMAEN) == I2C_CR1_TXDMAEN)
2400650e:	6803      	ldr	r3, [r0, #0]
24006510:	681a      	ldr	r2, [r3, #0]
24006512:	0451      	lsls	r1, r2, #17
24006514:	d50d      	bpl.n	24006532 <HAL_I2C_Slave_Seq_Receive_DMA+0x72>
        if (hi2c->hdmatx != NULL)
24006516:	6b80      	ldr	r0, [r0, #56]	@ 0x38
24006518:	b158      	cbz	r0, 24006532 <HAL_I2C_Slave_Seq_Receive_DMA+0x72>
          hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
2400651a:	681a      	ldr	r2, [r3, #0]
2400651c:	f422 4280 	bic.w	r2, r2, #16384	@ 0x4000
24006520:	601a      	str	r2, [r3, #0]
          hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
24006522:	4b3c      	ldr	r3, [pc, #240]	@ (24006614 <HAL_I2C_Slave_Seq_Receive_DMA+0x154>)
24006524:	6503      	str	r3, [r0, #80]	@ 0x50
          if (HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)
24006526:	f7fb fd21 	bl	24001f6c <HAL_DMA_Abort_IT>
2400652a:	b110      	cbz	r0, 24006532 <HAL_I2C_Slave_Seq_Receive_DMA+0x72>
            hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
2400652c:	6ba0      	ldr	r0, [r4, #56]	@ 0x38
            hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
2400652e:	6d03      	ldr	r3, [r0, #80]	@ 0x50
24006530:	4798      	blx	r3
    hi2c->State     = HAL_I2C_STATE_BUSY_RX_LISTEN;
24006532:	232a      	movs	r3, #42	@ 0x2a
    hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
24006534:	6821      	ldr	r1, [r4, #0]
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
24006536:	2600      	movs	r6, #0
    if (hi2c->hdmarx != NULL)
24006538:	6be0      	ldr	r0, [r4, #60]	@ 0x3c
    hi2c->State     = HAL_I2C_STATE_BUSY_RX_LISTEN;
2400653a:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
    hi2c->Mode      = HAL_I2C_MODE_SLAVE;
2400653e:	2320      	movs	r3, #32
24006540:	f884 3042 	strb.w	r3, [r4, #66]	@ 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
24006544:	6466      	str	r6, [r4, #68]	@ 0x44
    hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
24006546:	684b      	ldr	r3, [r1, #4]
24006548:	f423 4300 	bic.w	r3, r3, #32768	@ 0x8000
2400654c:	604b      	str	r3, [r1, #4]
    hi2c->XferCount   = Size;
2400654e:	8567      	strh	r7, [r4, #42]	@ 0x2a
    hi2c->XferSize    = hi2c->XferCount;
24006550:	8d62      	ldrh	r2, [r4, #42]	@ 0x2a
    hi2c->pBuffPtr    = pData;
24006552:	6265      	str	r5, [r4, #36]	@ 0x24
    hi2c->XferSize    = hi2c->XferCount;
24006554:	b293      	uxth	r3, r2
    hi2c->XferISR     = I2C_Slave_ISR_DMA;
24006556:	4a30      	ldr	r2, [pc, #192]	@ (24006618 <HAL_I2C_Slave_Seq_Receive_DMA+0x158>)
    hi2c->XferOptions = XferOptions;
24006558:	f8c4 802c 	str.w	r8, [r4, #44]	@ 0x2c
    hi2c->XferSize    = hi2c->XferCount;
2400655c:	8523      	strh	r3, [r4, #40]	@ 0x28
    hi2c->XferISR     = I2C_Slave_ISR_DMA;
2400655e:	6362      	str	r2, [r4, #52]	@ 0x34
    if (hi2c->hdmarx != NULL)
24006560:	2800      	cmp	r0, #0
24006562:	d02e      	beq.n	240065c2 <HAL_I2C_Slave_Seq_Receive_DMA+0x102>
      hi2c->hdmarx->XferCpltCallback = I2C_DMASlaveReceiveCplt;
24006564:	4a2d      	ldr	r2, [pc, #180]	@ (2400661c <HAL_I2C_Slave_Seq_Receive_DMA+0x15c>)
      dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)pData, hi2c->XferSize);
24006566:	3124      	adds	r1, #36	@ 0x24
      hi2c->hdmarx->XferHalfCpltCallback = NULL;
24006568:	6406      	str	r6, [r0, #64]	@ 0x40
      hi2c->hdmarx->XferCpltCallback = I2C_DMASlaveReceiveCplt;
2400656a:	63c2      	str	r2, [r0, #60]	@ 0x3c
      hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
2400656c:	4a2c      	ldr	r2, [pc, #176]	@ (24006620 <HAL_I2C_Slave_Seq_Receive_DMA+0x160>)
      hi2c->hdmarx->XferAbortCallback = NULL;
2400656e:	6506      	str	r6, [r0, #80]	@ 0x50
      hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
24006570:	64c2      	str	r2, [r0, #76]	@ 0x4c
      dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)pData, hi2c->XferSize);
24006572:	462a      	mov	r2, r5
24006574:	f7fb fa34 	bl	240019e0 <HAL_DMA_Start_IT>
    if (dmaxferstatus == HAL_OK)
24006578:	4605      	mov	r5, r0
2400657a:	b370      	cbz	r0, 240065da <HAL_I2C_Slave_Seq_Receive_DMA+0x11a>
      hi2c->State     = HAL_I2C_STATE_LISTEN;
2400657c:	2328      	movs	r3, #40	@ 0x28
      __HAL_UNLOCK(hi2c);
2400657e:	f884 6040 	strb.w	r6, [r4, #64]	@ 0x40
      hi2c->State     = HAL_I2C_STATE_LISTEN;
24006582:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
      hi2c->Mode      = HAL_I2C_MODE_NONE;
24006586:	f884 6042 	strb.w	r6, [r4, #66]	@ 0x42
      hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
2400658a:	6c63      	ldr	r3, [r4, #68]	@ 0x44
2400658c:	f043 0310 	orr.w	r3, r3, #16
24006590:	6463      	str	r3, [r4, #68]	@ 0x44
      return HAL_ERROR;
24006592:	e7a6      	b.n	240064e2 <HAL_I2C_Slave_Seq_Receive_DMA+0x22>
    else if (hi2c->State == HAL_I2C_STATE_BUSY_RX_LISTEN)
24006594:	f890 2041 	ldrb.w	r2, [r0, #65]	@ 0x41
      if ((hi2c->Instance->CR1 & I2C_CR1_RXDMAEN) == I2C_CR1_RXDMAEN)
24006598:	6803      	ldr	r3, [r0, #0]
    else if (hi2c->State == HAL_I2C_STATE_BUSY_RX_LISTEN)
2400659a:	2a2a      	cmp	r2, #42	@ 0x2a
        if (hi2c->hdmarx != NULL)
2400659c:	6bc0      	ldr	r0, [r0, #60]	@ 0x3c
    else if (hi2c->State == HAL_I2C_STATE_BUSY_RX_LISTEN)
2400659e:	d1c8      	bne.n	24006532 <HAL_I2C_Slave_Seq_Receive_DMA+0x72>
      if ((hi2c->Instance->CR1 & I2C_CR1_RXDMAEN) == I2C_CR1_RXDMAEN)
240065a0:	681a      	ldr	r2, [r3, #0]
240065a2:	0412      	lsls	r2, r2, #16
240065a4:	d5c5      	bpl.n	24006532 <HAL_I2C_Slave_Seq_Receive_DMA+0x72>
        hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
240065a6:	681a      	ldr	r2, [r3, #0]
240065a8:	f422 4200 	bic.w	r2, r2, #32768	@ 0x8000
240065ac:	601a      	str	r2, [r3, #0]
        if (hi2c->hdmarx != NULL)
240065ae:	2800      	cmp	r0, #0
240065b0:	d0bf      	beq.n	24006532 <HAL_I2C_Slave_Seq_Receive_DMA+0x72>
          hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
240065b2:	4b18      	ldr	r3, [pc, #96]	@ (24006614 <HAL_I2C_Slave_Seq_Receive_DMA+0x154>)
240065b4:	6503      	str	r3, [r0, #80]	@ 0x50
          if (HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)
240065b6:	f7fb fcd9 	bl	24001f6c <HAL_DMA_Abort_IT>
240065ba:	2800      	cmp	r0, #0
240065bc:	d0b9      	beq.n	24006532 <HAL_I2C_Slave_Seq_Receive_DMA+0x72>
            hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
240065be:	6be0      	ldr	r0, [r4, #60]	@ 0x3c
240065c0:	e7b5      	b.n	2400652e <HAL_I2C_Slave_Seq_Receive_DMA+0x6e>
      hi2c->State     = HAL_I2C_STATE_LISTEN;
240065c2:	2328      	movs	r3, #40	@ 0x28
      __HAL_UNLOCK(hi2c);
240065c4:	f884 0040 	strb.w	r0, [r4, #64]	@ 0x40
      hi2c->State     = HAL_I2C_STATE_LISTEN;
240065c8:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
      hi2c->Mode      = HAL_I2C_MODE_NONE;
240065cc:	f884 0042 	strb.w	r0, [r4, #66]	@ 0x42
      hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
240065d0:	6c63      	ldr	r3, [r4, #68]	@ 0x44
240065d2:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
240065d6:	6463      	str	r3, [r4, #68]	@ 0x44
      return HAL_ERROR;
240065d8:	e783      	b.n	240064e2 <HAL_I2C_Slave_Seq_Receive_DMA+0x22>
      hi2c->XferCount -= hi2c->XferSize;
240065da:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
240065dc:	8d22      	ldrh	r2, [r4, #40]	@ 0x28
    if (I2C_GET_DIR(hi2c) == I2C_DIRECTION_TRANSMIT)
240065de:	6826      	ldr	r6, [r4, #0]
      hi2c->XferCount -= hi2c->XferSize;
240065e0:	1a9b      	subs	r3, r3, r2
      hi2c->XferSize = 0;
240065e2:	8520      	strh	r0, [r4, #40]	@ 0x28
      hi2c->XferCount -= hi2c->XferSize;
240065e4:	b29b      	uxth	r3, r3
240065e6:	8563      	strh	r3, [r4, #42]	@ 0x2a
    if (I2C_GET_DIR(hi2c) == I2C_DIRECTION_TRANSMIT)
240065e8:	69b3      	ldr	r3, [r6, #24]
240065ea:	03db      	lsls	r3, r3, #15
240065ec:	d50c      	bpl.n	24006608 <HAL_I2C_Slave_Seq_Receive_DMA+0x148>
    __HAL_UNLOCK(hi2c);
240065ee:	2300      	movs	r3, #0
    I2C_Enable_IRQ(hi2c, I2C_XFER_RX_IT | I2C_XFER_LISTEN_IT);
240065f0:	f248 0102 	movw	r1, #32770	@ 0x8002
240065f4:	4620      	mov	r0, r4
    __HAL_UNLOCK(hi2c);
240065f6:	f884 3040 	strb.w	r3, [r4, #64]	@ 0x40
    I2C_Enable_IRQ(hi2c, I2C_XFER_RX_IT | I2C_XFER_LISTEN_IT);
240065fa:	f7fe f88b 	bl	24004714 <I2C_Enable_IRQ>
    hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;
240065fe:	6833      	ldr	r3, [r6, #0]
24006600:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
24006604:	6033      	str	r3, [r6, #0]
    return HAL_OK;
24006606:	e76d      	b.n	240064e4 <HAL_I2C_Slave_Seq_Receive_DMA+0x24>
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
24006608:	2308      	movs	r3, #8
2400660a:	61f3      	str	r3, [r6, #28]
2400660c:	e7ef      	b.n	240065ee <HAL_I2C_Slave_Seq_Receive_DMA+0x12e>
    __HAL_LOCK(hi2c);
2400660e:	2502      	movs	r5, #2
24006610:	e768      	b.n	240064e4 <HAL_I2C_Slave_Seq_Receive_DMA+0x24>
24006612:	bf00      	nop
24006614:	2400736b 	.word	0x2400736b
24006618:	240070c9 	.word	0x240070c9
2400661c:	240067db 	.word	0x240067db
24006620:	24006d75 	.word	0x24006d75

24006624 <HAL_I2C_EnableListen_IT>:
{
24006624:	b508      	push	{r3, lr}
  if (hi2c->State == HAL_I2C_STATE_READY)
24006626:	f890 2041 	ldrb.w	r2, [r0, #65]	@ 0x41
2400662a:	2a20      	cmp	r2, #32
2400662c:	d10a      	bne.n	24006644 <HAL_I2C_EnableListen_IT+0x20>
    hi2c->State = HAL_I2C_STATE_LISTEN;
2400662e:	2228      	movs	r2, #40	@ 0x28
    I2C_Enable_IRQ(hi2c, I2C_XFER_LISTEN_IT);
24006630:	f44f 4100 	mov.w	r1, #32768	@ 0x8000
    hi2c->State = HAL_I2C_STATE_LISTEN;
24006634:	f880 2041 	strb.w	r2, [r0, #65]	@ 0x41
    hi2c->XferISR = I2C_Slave_ISR_IT;
24006638:	4a03      	ldr	r2, [pc, #12]	@ (24006648 <HAL_I2C_EnableListen_IT+0x24>)
2400663a:	6342      	str	r2, [r0, #52]	@ 0x34
    I2C_Enable_IRQ(hi2c, I2C_XFER_LISTEN_IT);
2400663c:	f7fe f86a 	bl	24004714 <I2C_Enable_IRQ>
    return HAL_OK;
24006640:	2000      	movs	r0, #0
}
24006642:	bd08      	pop	{r3, pc}
    return HAL_BUSY;
24006644:	2002      	movs	r0, #2
24006646:	e7fc      	b.n	24006642 <HAL_I2C_EnableListen_IT+0x1e>
24006648:	24007259 	.word	0x24007259

2400664c <HAL_I2C_DisableListen_IT>:
{
2400664c:	b510      	push	{r4, lr}
  if (hi2c->State == HAL_I2C_STATE_LISTEN)
2400664e:	f890 2041 	ldrb.w	r2, [r0, #65]	@ 0x41
24006652:	2a28      	cmp	r2, #40	@ 0x28
24006654:	d114      	bne.n	24006680 <HAL_I2C_DisableListen_IT+0x34>
    tmp = (uint32_t)(hi2c->State) & I2C_STATE_MSK;
24006656:	f890 1041 	ldrb.w	r1, [r0, #65]	@ 0x41
    hi2c->Mode = HAL_I2C_MODE_NONE;
2400665a:	2400      	movs	r4, #0
    hi2c->PreviousState = tmp | (uint32_t)(hi2c->Mode);
2400665c:	f890 2042 	ldrb.w	r2, [r0, #66]	@ 0x42
24006660:	f001 0103 	and.w	r1, r1, #3
    hi2c->XferISR = NULL;
24006664:	6344      	str	r4, [r0, #52]	@ 0x34
    hi2c->PreviousState = tmp | (uint32_t)(hi2c->Mode);
24006666:	430a      	orrs	r2, r1
    I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT);
24006668:	f44f 4100 	mov.w	r1, #32768	@ 0x8000
    hi2c->PreviousState = tmp | (uint32_t)(hi2c->Mode);
2400666c:	6302      	str	r2, [r0, #48]	@ 0x30
    hi2c->State = HAL_I2C_STATE_READY;
2400666e:	2220      	movs	r2, #32
24006670:	f880 2041 	strb.w	r2, [r0, #65]	@ 0x41
    hi2c->Mode = HAL_I2C_MODE_NONE;
24006674:	f880 4042 	strb.w	r4, [r0, #66]	@ 0x42
    I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT);
24006678:	f7fe f882 	bl	24004780 <I2C_Disable_IRQ>
    return HAL_OK;
2400667c:	4620      	mov	r0, r4
}
2400667e:	bd10      	pop	{r4, pc}
    return HAL_BUSY;
24006680:	2002      	movs	r0, #2
24006682:	e7fc      	b.n	2400667e <HAL_I2C_DisableListen_IT+0x32>

24006684 <HAL_I2C_Master_Abort_IT>:
{
24006684:	b537      	push	{r0, r1, r2, r4, r5, lr}
  if (hi2c->Mode == HAL_I2C_MODE_MASTER)
24006686:	f890 3042 	ldrb.w	r3, [r0, #66]	@ 0x42
{
2400668a:	4604      	mov	r4, r0
2400668c:	460d      	mov	r5, r1
  if (hi2c->Mode == HAL_I2C_MODE_MASTER)
2400668e:	2b10      	cmp	r3, #16
24006690:	d12d      	bne.n	240066ee <HAL_I2C_Master_Abort_IT+0x6a>
    __HAL_LOCK(hi2c);
24006692:	f890 3040 	ldrb.w	r3, [r0, #64]	@ 0x40
24006696:	2b01      	cmp	r3, #1
24006698:	d02b      	beq.n	240066f2 <HAL_I2C_Master_Abort_IT+0x6e>
    if (hi2c->State == HAL_I2C_STATE_BUSY_TX)
2400669a:	f890 3041 	ldrb.w	r3, [r0, #65]	@ 0x41
    __HAL_LOCK(hi2c);
2400669e:	2101      	movs	r1, #1
    if (hi2c->State == HAL_I2C_STATE_BUSY_TX)
240066a0:	2b21      	cmp	r3, #33	@ 0x21
    __HAL_LOCK(hi2c);
240066a2:	f880 1040 	strb.w	r1, [r0, #64]	@ 0x40
    if (hi2c->State == HAL_I2C_STATE_BUSY_TX)
240066a6:	d119      	bne.n	240066dc <HAL_I2C_Master_Abort_IT+0x58>
      I2C_Disable_IRQ(hi2c, I2C_XFER_TX_IT);
240066a8:	f7fe f86a 	bl	24004780 <I2C_Disable_IRQ>
      hi2c->PreviousState = I2C_STATE_MASTER_BUSY_TX;
240066ac:	2311      	movs	r3, #17
      hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
240066ae:	6323      	str	r3, [r4, #48]	@ 0x30
    hi2c->State = HAL_I2C_STATE_ABORT;
240066b0:	2360      	movs	r3, #96	@ 0x60
    I2C_TransferConfig(hi2c, DevAddress, 1, I2C_AUTOEND_MODE, I2C_GENERATE_STOP);
240066b2:	4629      	mov	r1, r5
    __HAL_UNLOCK(hi2c);
240066b4:	2500      	movs	r5, #0
    I2C_TransferConfig(hi2c, DevAddress, 1, I2C_AUTOEND_MODE, I2C_GENERATE_STOP);
240066b6:	2201      	movs	r2, #1
    hi2c->State = HAL_I2C_STATE_ABORT;
240066b8:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
    I2C_TransferConfig(hi2c, DevAddress, 1, I2C_AUTOEND_MODE, I2C_GENERATE_STOP);
240066bc:	4620      	mov	r0, r4
240066be:	4b0e      	ldr	r3, [pc, #56]	@ (240066f8 <HAL_I2C_Master_Abort_IT+0x74>)
240066c0:	9300      	str	r3, [sp, #0]
240066c2:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
240066c6:	f7fe f811 	bl	240046ec <I2C_TransferConfig>
    I2C_Enable_IRQ(hi2c, I2C_XFER_CPLT_IT);
240066ca:	4620      	mov	r0, r4
240066cc:	2120      	movs	r1, #32
    __HAL_UNLOCK(hi2c);
240066ce:	f884 5040 	strb.w	r5, [r4, #64]	@ 0x40
    I2C_Enable_IRQ(hi2c, I2C_XFER_CPLT_IT);
240066d2:	f7fe f81f 	bl	24004714 <I2C_Enable_IRQ>
    return HAL_OK;
240066d6:	4628      	mov	r0, r5
}
240066d8:	b003      	add	sp, #12
240066da:	bd30      	pop	{r4, r5, pc}
    else if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
240066dc:	f890 3041 	ldrb.w	r3, [r0, #65]	@ 0x41
240066e0:	2b22      	cmp	r3, #34	@ 0x22
240066e2:	d1e5      	bne.n	240066b0 <HAL_I2C_Master_Abort_IT+0x2c>
      I2C_Disable_IRQ(hi2c, I2C_XFER_RX_IT);
240066e4:	2102      	movs	r1, #2
240066e6:	f7fe f84b 	bl	24004780 <I2C_Disable_IRQ>
      hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
240066ea:	2312      	movs	r3, #18
240066ec:	e7df      	b.n	240066ae <HAL_I2C_Master_Abort_IT+0x2a>
    return HAL_ERROR;
240066ee:	2001      	movs	r0, #1
240066f0:	e7f2      	b.n	240066d8 <HAL_I2C_Master_Abort_IT+0x54>
    __HAL_LOCK(hi2c);
240066f2:	2002      	movs	r0, #2
240066f4:	e7f0      	b.n	240066d8 <HAL_I2C_Master_Abort_IT+0x54>
240066f6:	bf00      	nop
240066f8:	80004000 	.word	0x80004000

240066fc <HAL_I2C_EV_IRQHandler>:
  uint32_t itflags   = READ_REG(hi2c->Instance->ISR);
240066fc:	6802      	ldr	r2, [r0, #0]
  if (hi2c->XferISR != NULL)
240066fe:	6b43      	ldr	r3, [r0, #52]	@ 0x34
  uint32_t itflags   = READ_REG(hi2c->Instance->ISR);
24006700:	6991      	ldr	r1, [r2, #24]
  uint32_t itsources = READ_REG(hi2c->Instance->CR1);
24006702:	6812      	ldr	r2, [r2, #0]
  if (hi2c->XferISR != NULL)
24006704:	b103      	cbz	r3, 24006708 <HAL_I2C_EV_IRQHandler+0xc>
    hi2c->XferISR(hi2c, itflags, itsources);
24006706:	4718      	bx	r3
}
24006708:	4770      	bx	lr

2400670a <HAL_I2C_MasterTxCpltCallback>:
__weak void HAL_I2C_MasterTxCpltCallback(I2C_HandleTypeDef *hi2c)
2400670a:	4770      	bx	lr

2400670c <HAL_I2C_MasterRxCpltCallback>:
__weak void HAL_I2C_MasterRxCpltCallback(I2C_HandleTypeDef *hi2c)
2400670c:	4770      	bx	lr

2400670e <I2C_ITMasterSeqCplt>:
{
2400670e:	b538      	push	{r3, r4, r5, lr}
  hi2c->Mode = HAL_I2C_MODE_NONE;
24006710:	2500      	movs	r5, #0
24006712:	f880 5042 	strb.w	r5, [r0, #66]	@ 0x42
  if (hi2c->State == HAL_I2C_STATE_BUSY_TX)
24006716:	f890 3041 	ldrb.w	r3, [r0, #65]	@ 0x41
2400671a:	2b21      	cmp	r3, #33	@ 0x21
2400671c:	f04f 0320 	mov.w	r3, #32
    hi2c->State         = HAL_I2C_STATE_READY;
24006720:	f880 3041 	strb.w	r3, [r0, #65]	@ 0x41
  if (hi2c->State == HAL_I2C_STATE_BUSY_TX)
24006724:	d10a      	bne.n	2400673c <I2C_ITMasterSeqCplt+0x2e>
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_TX;
24006726:	2311      	movs	r3, #17
    I2C_Disable_IRQ(hi2c, I2C_XFER_TX_IT);
24006728:	2101      	movs	r1, #1
    hi2c->XferISR       = NULL;
2400672a:	6345      	str	r5, [r0, #52]	@ 0x34
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_TX;
2400672c:	6303      	str	r3, [r0, #48]	@ 0x30
    I2C_Disable_IRQ(hi2c, I2C_XFER_TX_IT);
2400672e:	f7fe f827 	bl	24004780 <I2C_Disable_IRQ>
    __HAL_UNLOCK(hi2c);
24006732:	f880 5040 	strb.w	r5, [r0, #64]	@ 0x40
    HAL_I2C_MasterTxCpltCallback(hi2c);
24006736:	f7ff ffe8 	bl	2400670a <HAL_I2C_MasterTxCpltCallback>
}
2400673a:	bd38      	pop	{r3, r4, r5, pc}
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
2400673c:	2312      	movs	r3, #18
    I2C_Disable_IRQ(hi2c, I2C_XFER_RX_IT);
2400673e:	2102      	movs	r1, #2
    hi2c->XferISR       = NULL;
24006740:	6345      	str	r5, [r0, #52]	@ 0x34
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
24006742:	6303      	str	r3, [r0, #48]	@ 0x30
    I2C_Disable_IRQ(hi2c, I2C_XFER_RX_IT);
24006744:	f7fe f81c 	bl	24004780 <I2C_Disable_IRQ>
    __HAL_UNLOCK(hi2c);
24006748:	f880 5040 	strb.w	r5, [r0, #64]	@ 0x40
    HAL_I2C_MasterRxCpltCallback(hi2c);
2400674c:	f7ff ffde 	bl	2400670c <HAL_I2C_MasterRxCpltCallback>
}
24006750:	e7f3      	b.n	2400673a <I2C_ITMasterSeqCplt+0x2c>

24006752 <HAL_I2C_SlaveTxCpltCallback>:
__weak void HAL_I2C_SlaveTxCpltCallback(I2C_HandleTypeDef *hi2c)
24006752:	4770      	bx	lr

24006754 <HAL_I2C_SlaveRxCpltCallback>:
__weak void HAL_I2C_SlaveRxCpltCallback(I2C_HandleTypeDef *hi2c)
24006754:	4770      	bx	lr

24006756 <I2C_ITSlaveSeqCplt>:
{
24006756:	b508      	push	{r3, lr}
  uint32_t tmpcr1value = READ_REG(hi2c->Instance->CR1);
24006758:	6803      	ldr	r3, [r0, #0]
  hi2c->Mode = HAL_I2C_MODE_NONE;
2400675a:	2100      	movs	r1, #0
  uint32_t tmpcr1value = READ_REG(hi2c->Instance->CR1);
2400675c:	681a      	ldr	r2, [r3, #0]
  hi2c->Mode = HAL_I2C_MODE_NONE;
2400675e:	f880 1042 	strb.w	r1, [r0, #66]	@ 0x42
  if (I2C_CHECK_IT_SOURCE(tmpcr1value, I2C_CR1_TXDMAEN) != RESET)
24006762:	0451      	lsls	r1, r2, #17
24006764:	d515      	bpl.n	24006792 <I2C_ITSlaveSeqCplt+0x3c>
    hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
24006766:	681a      	ldr	r2, [r3, #0]
24006768:	f422 4280 	bic.w	r2, r2, #16384	@ 0x4000
    hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
2400676c:	601a      	str	r2, [r3, #0]
  if (hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN)
2400676e:	f890 3041 	ldrb.w	r3, [r0, #65]	@ 0x41
24006772:	2b29      	cmp	r3, #41	@ 0x29
24006774:	d113      	bne.n	2400679e <I2C_ITSlaveSeqCplt+0x48>
    hi2c->State         = HAL_I2C_STATE_LISTEN;
24006776:	2328      	movs	r3, #40	@ 0x28
    I2C_Disable_IRQ(hi2c, I2C_XFER_TX_IT);
24006778:	2101      	movs	r1, #1
    hi2c->State         = HAL_I2C_STATE_LISTEN;
2400677a:	f880 3041 	strb.w	r3, [r0, #65]	@ 0x41
    hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_TX;
2400677e:	2321      	movs	r3, #33	@ 0x21
24006780:	6303      	str	r3, [r0, #48]	@ 0x30
    I2C_Disable_IRQ(hi2c, I2C_XFER_TX_IT);
24006782:	f7fd fffd 	bl	24004780 <I2C_Disable_IRQ>
    __HAL_UNLOCK(hi2c);
24006786:	2300      	movs	r3, #0
24006788:	f880 3040 	strb.w	r3, [r0, #64]	@ 0x40
    HAL_I2C_SlaveTxCpltCallback(hi2c);
2400678c:	f7ff ffe1 	bl	24006752 <HAL_I2C_SlaveTxCpltCallback>
}
24006790:	bd08      	pop	{r3, pc}
  else if (I2C_CHECK_IT_SOURCE(tmpcr1value, I2C_CR1_RXDMAEN) != RESET)
24006792:	0412      	lsls	r2, r2, #16
24006794:	d5eb      	bpl.n	2400676e <I2C_ITSlaveSeqCplt+0x18>
    hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
24006796:	681a      	ldr	r2, [r3, #0]
24006798:	f422 4200 	bic.w	r2, r2, #32768	@ 0x8000
2400679c:	e7e6      	b.n	2400676c <I2C_ITSlaveSeqCplt+0x16>
  else if (hi2c->State == HAL_I2C_STATE_BUSY_RX_LISTEN)
2400679e:	f890 3041 	ldrb.w	r3, [r0, #65]	@ 0x41
240067a2:	2b2a      	cmp	r3, #42	@ 0x2a
240067a4:	d1f4      	bne.n	24006790 <I2C_ITSlaveSeqCplt+0x3a>
    hi2c->State         = HAL_I2C_STATE_LISTEN;
240067a6:	2328      	movs	r3, #40	@ 0x28
    I2C_Disable_IRQ(hi2c, I2C_XFER_RX_IT);
240067a8:	2102      	movs	r1, #2
    hi2c->State         = HAL_I2C_STATE_LISTEN;
240067aa:	f880 3041 	strb.w	r3, [r0, #65]	@ 0x41
    hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_RX;
240067ae:	2322      	movs	r3, #34	@ 0x22
240067b0:	6303      	str	r3, [r0, #48]	@ 0x30
    I2C_Disable_IRQ(hi2c, I2C_XFER_RX_IT);
240067b2:	f7fd ffe5 	bl	24004780 <I2C_Disable_IRQ>
    __HAL_UNLOCK(hi2c);
240067b6:	2300      	movs	r3, #0
240067b8:	f880 3040 	strb.w	r3, [r0, #64]	@ 0x40
    HAL_I2C_SlaveRxCpltCallback(hi2c);
240067bc:	f7ff ffca 	bl	24006754 <HAL_I2C_SlaveRxCpltCallback>
}
240067c0:	e7e6      	b.n	24006790 <I2C_ITSlaveSeqCplt+0x3a>

240067c2 <I2C_DMASlaveTransmitCplt>:
  I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
240067c2:	6b80      	ldr	r0, [r0, #56]	@ 0x38
  uint32_t tmpoptions = hi2c->XferOptions;
240067c4:	6ac3      	ldr	r3, [r0, #44]	@ 0x2c
  if ((tmpoptions == I2C_NEXT_FRAME) || (tmpoptions == I2C_FIRST_FRAME))
240067c6:	f033 7380 	bics.w	r3, r3, #16777216	@ 0x1000000
240067ca:	d105      	bne.n	240067d8 <I2C_DMASlaveTransmitCplt+0x16>
    hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
240067cc:	6802      	ldr	r2, [r0, #0]
240067ce:	6813      	ldr	r3, [r2, #0]
240067d0:	f423 4380 	bic.w	r3, r3, #16384	@ 0x4000
240067d4:	6013      	str	r3, [r2, #0]
    I2C_ITSlaveSeqCplt(hi2c);
240067d6:	e7be      	b.n	24006756 <I2C_ITSlaveSeqCplt>
}
240067d8:	4770      	bx	lr

240067da <I2C_DMASlaveReceiveCplt>:
  I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
240067da:	6b80      	ldr	r0, [r0, #56]	@ 0x38
  if ((__HAL_DMA_GET_COUNTER(hi2c->hdmarx) == 0U) && \
240067dc:	4921      	ldr	r1, [pc, #132]	@ (24006864 <I2C_DMASlaveReceiveCplt+0x8a>)
240067de:	6bc3      	ldr	r3, [r0, #60]	@ 0x3c
  uint32_t tmpoptions = hi2c->XferOptions;
240067e0:	6ac2      	ldr	r2, [r0, #44]	@ 0x2c
  if ((__HAL_DMA_GET_COUNTER(hi2c->hdmarx) == 0U) && \
240067e2:	681b      	ldr	r3, [r3, #0]
240067e4:	428b      	cmp	r3, r1
240067e6:	d02d      	beq.n	24006844 <I2C_DMASlaveReceiveCplt+0x6a>
240067e8:	3118      	adds	r1, #24
240067ea:	428b      	cmp	r3, r1
240067ec:	d02a      	beq.n	24006844 <I2C_DMASlaveReceiveCplt+0x6a>
240067ee:	3118      	adds	r1, #24
240067f0:	428b      	cmp	r3, r1
240067f2:	d027      	beq.n	24006844 <I2C_DMASlaveReceiveCplt+0x6a>
240067f4:	3118      	adds	r1, #24
240067f6:	428b      	cmp	r3, r1
240067f8:	d024      	beq.n	24006844 <I2C_DMASlaveReceiveCplt+0x6a>
240067fa:	3118      	adds	r1, #24
240067fc:	428b      	cmp	r3, r1
240067fe:	d021      	beq.n	24006844 <I2C_DMASlaveReceiveCplt+0x6a>
24006800:	3118      	adds	r1, #24
24006802:	428b      	cmp	r3, r1
24006804:	d01e      	beq.n	24006844 <I2C_DMASlaveReceiveCplt+0x6a>
24006806:	3118      	adds	r1, #24
24006808:	428b      	cmp	r3, r1
2400680a:	d01b      	beq.n	24006844 <I2C_DMASlaveReceiveCplt+0x6a>
2400680c:	3118      	adds	r1, #24
2400680e:	428b      	cmp	r3, r1
24006810:	d018      	beq.n	24006844 <I2C_DMASlaveReceiveCplt+0x6a>
24006812:	f501 7156 	add.w	r1, r1, #856	@ 0x358
24006816:	428b      	cmp	r3, r1
24006818:	d014      	beq.n	24006844 <I2C_DMASlaveReceiveCplt+0x6a>
2400681a:	3118      	adds	r1, #24
2400681c:	428b      	cmp	r3, r1
2400681e:	d011      	beq.n	24006844 <I2C_DMASlaveReceiveCplt+0x6a>
24006820:	3118      	adds	r1, #24
24006822:	428b      	cmp	r3, r1
24006824:	d00e      	beq.n	24006844 <I2C_DMASlaveReceiveCplt+0x6a>
24006826:	3118      	adds	r1, #24
24006828:	428b      	cmp	r3, r1
2400682a:	d00b      	beq.n	24006844 <I2C_DMASlaveReceiveCplt+0x6a>
2400682c:	3118      	adds	r1, #24
2400682e:	428b      	cmp	r3, r1
24006830:	d008      	beq.n	24006844 <I2C_DMASlaveReceiveCplt+0x6a>
24006832:	3118      	adds	r1, #24
24006834:	428b      	cmp	r3, r1
24006836:	d005      	beq.n	24006844 <I2C_DMASlaveReceiveCplt+0x6a>
24006838:	3118      	adds	r1, #24
2400683a:	428b      	cmp	r3, r1
2400683c:	d002      	beq.n	24006844 <I2C_DMASlaveReceiveCplt+0x6a>
2400683e:	3118      	adds	r1, #24
24006840:	428b      	cmp	r3, r1
24006842:	d102      	bne.n	2400684a <I2C_DMASlaveReceiveCplt+0x70>
24006844:	685b      	ldr	r3, [r3, #4]
24006846:	b113      	cbz	r3, 2400684e <I2C_DMASlaveReceiveCplt+0x74>
24006848:	4770      	bx	lr
2400684a:	685b      	ldr	r3, [r3, #4]
2400684c:	b943      	cbnz	r3, 24006860 <I2C_DMASlaveReceiveCplt+0x86>
2400684e:	f512 3f80 	cmn.w	r2, #65536	@ 0x10000
24006852:	d005      	beq.n	24006860 <I2C_DMASlaveReceiveCplt+0x86>
    hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
24006854:	6802      	ldr	r2, [r0, #0]
24006856:	6813      	ldr	r3, [r2, #0]
24006858:	f423 4300 	bic.w	r3, r3, #32768	@ 0x8000
2400685c:	6013      	str	r3, [r2, #0]
    I2C_ITSlaveSeqCplt(hi2c);
2400685e:	e77a      	b.n	24006756 <I2C_ITSlaveSeqCplt>
}
24006860:	4770      	bx	lr
24006862:	bf00      	nop
24006864:	40020010 	.word	0x40020010

24006868 <HAL_I2C_AddrCallback>:
}
24006868:	4770      	bx	lr

2400686a <I2C_ITAddrCplt.constprop.0>:
  if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
2400686a:	f890 2041 	ldrb.w	r2, [r0, #65]	@ 0x41
2400686e:	f002 0228 	and.w	r2, r2, #40	@ 0x28
24006872:	2a28      	cmp	r2, #40	@ 0x28
static void I2C_ITAddrCplt(I2C_HandleTypeDef *hi2c, uint32_t ITFlags)
24006874:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    transferdirection = I2C_GET_DIR(hi2c);
24006876:	6803      	ldr	r3, [r0, #0]
  if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
24006878:	d135      	bne.n	240068e6 <I2C_ITAddrCplt.constprop.0+0x7c>
    transferdirection = I2C_GET_DIR(hi2c);
2400687a:	699e      	ldr	r6, [r3, #24]
    if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
2400687c:	68c2      	ldr	r2, [r0, #12]
    slaveaddrcode     = I2C_GET_ADDR_MATCH(hi2c);
2400687e:	699d      	ldr	r5, [r3, #24]
    transferdirection = I2C_GET_DIR(hi2c);
24006880:	f3c6 4600 	ubfx	r6, r6, #16, #1
    if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
24006884:	2a02      	cmp	r2, #2
    ownadd1code       = I2C_GET_OWN_ADDRESS1(hi2c);
24006886:	6899      	ldr	r1, [r3, #8]
    slaveaddrcode     = I2C_GET_ADDR_MATCH(hi2c);
24006888:	ea4f 4515 	mov.w	r5, r5, lsr #16
    ownadd2code       = I2C_GET_OWN_ADDRESS2(hi2c);
2400688c:	68df      	ldr	r7, [r3, #12]
    slaveaddrcode     = I2C_GET_ADDR_MATCH(hi2c);
2400688e:	f005 05fe 	and.w	r5, r5, #254	@ 0xfe
    if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
24006892:	d11f      	bne.n	240068d4 <I2C_ITAddrCplt.constprop.0+0x6a>
      if ((slaveaddrcode & SlaveAddr_MSK) == ((ownadd1code >> SlaveAddr_SHIFT) & SlaveAddr_MSK))
24006894:	ea85 15d1 	eor.w	r5, r5, r1, lsr #7
    ownadd1code       = I2C_GET_OWN_ADDRESS1(hi2c);
24006898:	f3c1 0209 	ubfx	r2, r1, #0, #10
      if ((slaveaddrcode & SlaveAddr_MSK) == ((ownadd1code >> SlaveAddr_SHIFT) & SlaveAddr_MSK))
2400689c:	f015 0506 	ands.w	r5, r5, #6
240068a0:	d10e      	bne.n	240068c0 <I2C_ITAddrCplt.constprop.0+0x56>
        hi2c->AddrEventCount++;
240068a2:	6c81      	ldr	r1, [r0, #72]	@ 0x48
240068a4:	3101      	adds	r1, #1
240068a6:	6481      	str	r1, [r0, #72]	@ 0x48
        if (hi2c->AddrEventCount == 2U)
240068a8:	6c81      	ldr	r1, [r0, #72]	@ 0x48
240068aa:	2902      	cmp	r1, #2
240068ac:	d107      	bne.n	240068be <I2C_ITAddrCplt.constprop.0+0x54>
          __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
240068ae:	2108      	movs	r1, #8
          hi2c->AddrEventCount = 0U;
240068b0:	6485      	str	r5, [r0, #72]	@ 0x48
          __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
240068b2:	61d9      	str	r1, [r3, #28]
          __HAL_UNLOCK(hi2c);
240068b4:	f880 5040 	strb.w	r5, [r0, #64]	@ 0x40
      HAL_I2C_AddrCallback(hi2c, transferdirection, slaveaddrcode);
240068b8:	4631      	mov	r1, r6
240068ba:	f7ff ffd5 	bl	24006868 <HAL_I2C_AddrCallback>
}
240068be:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT);
240068c0:	f44f 4100 	mov.w	r1, #32768	@ 0x8000
240068c4:	f7fd ff5c 	bl	24004780 <I2C_Disable_IRQ>
        __HAL_UNLOCK(hi2c);
240068c8:	2300      	movs	r3, #0
        HAL_I2C_AddrCallback(hi2c, transferdirection, slaveaddrcode);
240068ca:	f007 02fe 	and.w	r2, r7, #254	@ 0xfe
        __HAL_UNLOCK(hi2c);
240068ce:	f880 3040 	strb.w	r3, [r0, #64]	@ 0x40
        HAL_I2C_AddrCallback(hi2c, transferdirection, slaveaddrcode);
240068d2:	e7f1      	b.n	240068b8 <I2C_ITAddrCplt.constprop.0+0x4e>
      I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT);
240068d4:	f44f 4100 	mov.w	r1, #32768	@ 0x8000
240068d8:	f7fd ff52 	bl	24004780 <I2C_Disable_IRQ>
      __HAL_UNLOCK(hi2c);
240068dc:	2300      	movs	r3, #0
      HAL_I2C_AddrCallback(hi2c, transferdirection, slaveaddrcode);
240068de:	462a      	mov	r2, r5
      __HAL_UNLOCK(hi2c);
240068e0:	f880 3040 	strb.w	r3, [r0, #64]	@ 0x40
      HAL_I2C_AddrCallback(hi2c, transferdirection, slaveaddrcode);
240068e4:	e7e8      	b.n	240068b8 <I2C_ITAddrCplt.constprop.0+0x4e>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
240068e6:	2208      	movs	r2, #8
240068e8:	61da      	str	r2, [r3, #28]
    __HAL_UNLOCK(hi2c);
240068ea:	2300      	movs	r3, #0
240068ec:	f880 3040 	strb.w	r3, [r0, #64]	@ 0x40
}
240068f0:	e7e5      	b.n	240068be <I2C_ITAddrCplt.constprop.0+0x54>

240068f2 <HAL_I2C_ListenCpltCallback>:
__weak void HAL_I2C_ListenCpltCallback(I2C_HandleTypeDef *hi2c)
240068f2:	4770      	bx	lr

240068f4 <I2C_ITListenCplt>:
{
240068f4:	b508      	push	{r3, lr}
  hi2c->XferOptions = I2C_NO_OPTION_FRAME;
240068f6:	4b16      	ldr	r3, [pc, #88]	@ (24006950 <I2C_ITListenCplt+0x5c>)
  hi2c->State = HAL_I2C_STATE_READY;
240068f8:	2220      	movs	r2, #32
  hi2c->XferOptions = I2C_NO_OPTION_FRAME;
240068fa:	62c3      	str	r3, [r0, #44]	@ 0x2c
  hi2c->PreviousState = I2C_STATE_NONE;
240068fc:	2300      	movs	r3, #0
240068fe:	6303      	str	r3, [r0, #48]	@ 0x30
  hi2c->XferISR = NULL;
24006900:	6343      	str	r3, [r0, #52]	@ 0x34
  hi2c->State = HAL_I2C_STATE_READY;
24006902:	f880 2041 	strb.w	r2, [r0, #65]	@ 0x41
  hi2c->Mode = HAL_I2C_MODE_NONE;
24006906:	f880 3042 	strb.w	r3, [r0, #66]	@ 0x42
  if (I2C_CHECK_FLAG(ITFlags, I2C_FLAG_RXNE) != RESET)
2400690a:	074b      	lsls	r3, r1, #29
2400690c:	d512      	bpl.n	24006934 <I2C_ITListenCplt+0x40>
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
2400690e:	6803      	ldr	r3, [r0, #0]
24006910:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
24006912:	6a43      	ldr	r3, [r0, #36]	@ 0x24
24006914:	701a      	strb	r2, [r3, #0]
    hi2c->pBuffPtr++;
24006916:	6a43      	ldr	r3, [r0, #36]	@ 0x24
24006918:	3301      	adds	r3, #1
2400691a:	6243      	str	r3, [r0, #36]	@ 0x24
    if ((hi2c->XferSize > 0U))
2400691c:	8d03      	ldrh	r3, [r0, #40]	@ 0x28
2400691e:	b14b      	cbz	r3, 24006934 <I2C_ITListenCplt+0x40>
      hi2c->XferSize--;
24006920:	3b01      	subs	r3, #1
24006922:	8503      	strh	r3, [r0, #40]	@ 0x28
      hi2c->XferCount--;
24006924:	8d43      	ldrh	r3, [r0, #42]	@ 0x2a
24006926:	3b01      	subs	r3, #1
24006928:	b29b      	uxth	r3, r3
2400692a:	8543      	strh	r3, [r0, #42]	@ 0x2a
      hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
2400692c:	6c43      	ldr	r3, [r0, #68]	@ 0x44
2400692e:	f043 0304 	orr.w	r3, r3, #4
24006932:	6443      	str	r3, [r0, #68]	@ 0x44
  I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_RX_IT | I2C_XFER_TX_IT);
24006934:	f248 0103 	movw	r1, #32771	@ 0x8003
24006938:	f7fd ff22 	bl	24004780 <I2C_Disable_IRQ>
  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
2400693c:	6803      	ldr	r3, [r0, #0]
2400693e:	2210      	movs	r2, #16
24006940:	61da      	str	r2, [r3, #28]
  __HAL_UNLOCK(hi2c);
24006942:	2300      	movs	r3, #0
24006944:	f880 3040 	strb.w	r3, [r0, #64]	@ 0x40
  HAL_I2C_ListenCpltCallback(hi2c);
24006948:	f7ff ffd3 	bl	240068f2 <HAL_I2C_ListenCpltCallback>
}
2400694c:	bd08      	pop	{r3, pc}
2400694e:	bf00      	nop
24006950:	ffff0000 	.word	0xffff0000

24006954 <HAL_I2C_MemTxCpltCallback>:
__weak void HAL_I2C_MemTxCpltCallback(I2C_HandleTypeDef *hi2c)
24006954:	4770      	bx	lr

24006956 <HAL_I2C_MemRxCpltCallback>:
__weak void HAL_I2C_MemRxCpltCallback(I2C_HandleTypeDef *hi2c)
24006956:	4770      	bx	lr

24006958 <HAL_I2C_ErrorCallback>:
__weak void HAL_I2C_ErrorCallback(I2C_HandleTypeDef *hi2c)
24006958:	4770      	bx	lr

2400695a <HAL_I2C_AbortCpltCallback>:
__weak void HAL_I2C_AbortCpltCallback(I2C_HandleTypeDef *hi2c)
2400695a:	4770      	bx	lr

2400695c <I2C_TreatErrorCallback>:
  if (hi2c->State == HAL_I2C_STATE_ABORT)
2400695c:	f890 2041 	ldrb.w	r2, [r0, #65]	@ 0x41
24006960:	2a60      	cmp	r2, #96	@ 0x60
24006962:	f04f 0200 	mov.w	r2, #0
{
24006966:	b508      	push	{r3, lr}
  if (hi2c->State == HAL_I2C_STATE_ABORT)
24006968:	d108      	bne.n	2400697c <I2C_TreatErrorCallback+0x20>
    hi2c->State = HAL_I2C_STATE_READY;
2400696a:	2120      	movs	r1, #32
    __HAL_UNLOCK(hi2c);
2400696c:	f880 2040 	strb.w	r2, [r0, #64]	@ 0x40
    hi2c->State = HAL_I2C_STATE_READY;
24006970:	f880 1041 	strb.w	r1, [r0, #65]	@ 0x41
    hi2c->PreviousState = I2C_STATE_NONE;
24006974:	6302      	str	r2, [r0, #48]	@ 0x30
    HAL_I2C_AbortCpltCallback(hi2c);
24006976:	f7ff fff0 	bl	2400695a <HAL_I2C_AbortCpltCallback>
}
2400697a:	bd08      	pop	{r3, pc}
    hi2c->PreviousState = I2C_STATE_NONE;
2400697c:	6302      	str	r2, [r0, #48]	@ 0x30
    __HAL_UNLOCK(hi2c);
2400697e:	f880 2040 	strb.w	r2, [r0, #64]	@ 0x40
    HAL_I2C_ErrorCallback(hi2c);
24006982:	f7ff ffe9 	bl	24006958 <HAL_I2C_ErrorCallback>
}
24006986:	e7f8      	b.n	2400697a <I2C_TreatErrorCallback+0x1e>

24006988 <I2C_ITError>:
{
24006988:	b570      	push	{r4, r5, r6, lr}
  hi2c->Mode          = HAL_I2C_MODE_NONE;
2400698a:	2200      	movs	r2, #0
  HAL_I2C_StateTypeDef tmpstate = hi2c->State;
2400698c:	f890 3041 	ldrb.w	r3, [r0, #65]	@ 0x41
  hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
24006990:	4d33      	ldr	r5, [pc, #204]	@ (24006a60 <I2C_ITError+0xd8>)
{
24006992:	4604      	mov	r4, r0
  hi2c->Mode          = HAL_I2C_MODE_NONE;
24006994:	f880 2042 	strb.w	r2, [r0, #66]	@ 0x42
  if ((tmpstate == HAL_I2C_STATE_LISTEN)         ||
24006998:	3b28      	subs	r3, #40	@ 0x28
  hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
2400699a:	62c5      	str	r5, [r0, #44]	@ 0x2c
  hi2c->XferCount     = 0U;
2400699c:	8542      	strh	r2, [r0, #42]	@ 0x2a
  if ((tmpstate == HAL_I2C_STATE_LISTEN)         ||
2400699e:	2b02      	cmp	r3, #2
  hi2c->ErrorCode |= ErrorCode;
240069a0:	6c42      	ldr	r2, [r0, #68]	@ 0x44
240069a2:	ea42 0201 	orr.w	r2, r2, r1
240069a6:	6442      	str	r2, [r0, #68]	@ 0x44
  if ((tmpstate == HAL_I2C_STATE_LISTEN)         ||
240069a8:	d829      	bhi.n	240069fe <I2C_ITError+0x76>
    I2C_Disable_IRQ(hi2c, I2C_XFER_RX_IT | I2C_XFER_TX_IT);
240069aa:	2103      	movs	r1, #3
240069ac:	f7fd fee8 	bl	24004780 <I2C_Disable_IRQ>
    hi2c->State         = HAL_I2C_STATE_LISTEN;
240069b0:	2328      	movs	r3, #40	@ 0x28
240069b2:	f880 3041 	strb.w	r3, [r0, #65]	@ 0x41
    hi2c->XferISR       = I2C_Slave_ISR_IT;
240069b6:	4b2b      	ldr	r3, [pc, #172]	@ (24006a64 <I2C_ITError+0xdc>)
  if ((hi2c->hdmatx != NULL) && ((tmppreviousstate == I2C_STATE_MASTER_BUSY_TX) || (tmppreviousstate == I2C_STATE_SLAVE_BUSY_TX)))
240069b8:	6ba0      	ldr	r0, [r4, #56]	@ 0x38
    hi2c->XferISR       = I2C_Slave_ISR_IT;
240069ba:	6363      	str	r3, [r4, #52]	@ 0x34
  tmppreviousstate = hi2c->PreviousState;
240069bc:	6b23      	ldr	r3, [r4, #48]	@ 0x30
  if ((hi2c->hdmatx != NULL) && ((tmppreviousstate == I2C_STATE_MASTER_BUSY_TX) || (tmppreviousstate == I2C_STATE_SLAVE_BUSY_TX)))
240069be:	b378      	cbz	r0, 24006a20 <I2C_ITError+0x98>
240069c0:	2b11      	cmp	r3, #17
240069c2:	d001      	beq.n	240069c8 <I2C_ITError+0x40>
240069c4:	2b21      	cmp	r3, #33	@ 0x21
240069c6:	d12b      	bne.n	24006a20 <I2C_ITError+0x98>
    if ((hi2c->Instance->CR1 & I2C_CR1_TXDMAEN) == I2C_CR1_TXDMAEN)
240069c8:	6823      	ldr	r3, [r4, #0]
240069ca:	681a      	ldr	r2, [r3, #0]
240069cc:	0451      	lsls	r1, r2, #17
240069ce:	d503      	bpl.n	240069d8 <I2C_ITError+0x50>
      hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
240069d0:	681a      	ldr	r2, [r3, #0]
240069d2:	f422 4280 	bic.w	r2, r2, #16384	@ 0x4000
240069d6:	601a      	str	r2, [r3, #0]
    if (HAL_DMA_GetState(hi2c->hdmatx) != HAL_DMA_STATE_READY)
240069d8:	f7fc f86a 	bl	24002ab0 <HAL_DMA_GetState>
240069dc:	2801      	cmp	r0, #1
240069de:	d01b      	beq.n	24006a18 <I2C_ITError+0x90>
      hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
240069e0:	4b21      	ldr	r3, [pc, #132]	@ (24006a68 <I2C_ITError+0xe0>)
240069e2:	6ba0      	ldr	r0, [r4, #56]	@ 0x38
240069e4:	6503      	str	r3, [r0, #80]	@ 0x50
      __HAL_UNLOCK(hi2c);
240069e6:	2300      	movs	r3, #0
240069e8:	f884 3040 	strb.w	r3, [r4, #64]	@ 0x40
      if (HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)
240069ec:	f7fb fabe 	bl	24001f6c <HAL_DMA_Abort_IT>
240069f0:	2800      	cmp	r0, #0
240069f2:	d033      	beq.n	24006a5c <I2C_ITError+0xd4>
        hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
240069f4:	6ba0      	ldr	r0, [r4, #56]	@ 0x38
        hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
240069f6:	6d03      	ldr	r3, [r0, #80]	@ 0x50
}
240069f8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
240069fc:	4718      	bx	r3
    I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_RX_IT | I2C_XFER_TX_IT);
240069fe:	f248 0103 	movw	r1, #32771	@ 0x8003
24006a02:	f7fd febd 	bl	24004780 <I2C_Disable_IRQ>
    if (hi2c->State != HAL_I2C_STATE_ABORT)
24006a06:	f890 3041 	ldrb.w	r3, [r0, #65]	@ 0x41
24006a0a:	2b60      	cmp	r3, #96	@ 0x60
24006a0c:	d002      	beq.n	24006a14 <I2C_ITError+0x8c>
      hi2c->State         = HAL_I2C_STATE_READY;
24006a0e:	2320      	movs	r3, #32
24006a10:	f880 3041 	strb.w	r3, [r0, #65]	@ 0x41
    hi2c->XferISR       = NULL;
24006a14:	2300      	movs	r3, #0
24006a16:	e7cf      	b.n	240069b8 <I2C_ITError+0x30>
      I2C_TreatErrorCallback(hi2c);
24006a18:	4620      	mov	r0, r4
}
24006a1a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
      I2C_TreatErrorCallback(hi2c);
24006a1e:	e79d      	b.n	2400695c <I2C_TreatErrorCallback>
  else if ((hi2c->hdmarx != NULL) && ((tmppreviousstate == I2C_STATE_MASTER_BUSY_RX) || (tmppreviousstate == I2C_STATE_SLAVE_BUSY_RX)))
24006a20:	6be0      	ldr	r0, [r4, #60]	@ 0x3c
24006a22:	2800      	cmp	r0, #0
24006a24:	d0f8      	beq.n	24006a18 <I2C_ITError+0x90>
24006a26:	2b12      	cmp	r3, #18
24006a28:	d001      	beq.n	24006a2e <I2C_ITError+0xa6>
24006a2a:	2b22      	cmp	r3, #34	@ 0x22
24006a2c:	d1f4      	bne.n	24006a18 <I2C_ITError+0x90>
    if ((hi2c->Instance->CR1 & I2C_CR1_RXDMAEN) == I2C_CR1_RXDMAEN)
24006a2e:	6823      	ldr	r3, [r4, #0]
24006a30:	681a      	ldr	r2, [r3, #0]
24006a32:	0412      	lsls	r2, r2, #16
24006a34:	d503      	bpl.n	24006a3e <I2C_ITError+0xb6>
      hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
24006a36:	681a      	ldr	r2, [r3, #0]
24006a38:	f422 4200 	bic.w	r2, r2, #32768	@ 0x8000
24006a3c:	601a      	str	r2, [r3, #0]
    if (HAL_DMA_GetState(hi2c->hdmarx) != HAL_DMA_STATE_READY)
24006a3e:	f7fc f837 	bl	24002ab0 <HAL_DMA_GetState>
24006a42:	2801      	cmp	r0, #1
24006a44:	d0e8      	beq.n	24006a18 <I2C_ITError+0x90>
      hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
24006a46:	4b08      	ldr	r3, [pc, #32]	@ (24006a68 <I2C_ITError+0xe0>)
24006a48:	6be0      	ldr	r0, [r4, #60]	@ 0x3c
24006a4a:	6503      	str	r3, [r0, #80]	@ 0x50
      __HAL_UNLOCK(hi2c);
24006a4c:	2300      	movs	r3, #0
24006a4e:	f884 3040 	strb.w	r3, [r4, #64]	@ 0x40
      if (HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)
24006a52:	f7fb fa8b 	bl	24001f6c <HAL_DMA_Abort_IT>
24006a56:	b108      	cbz	r0, 24006a5c <I2C_ITError+0xd4>
        hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
24006a58:	6be0      	ldr	r0, [r4, #60]	@ 0x3c
24006a5a:	e7cc      	b.n	240069f6 <I2C_ITError+0x6e>
}
24006a5c:	bd70      	pop	{r4, r5, r6, pc}
24006a5e:	bf00      	nop
24006a60:	ffff0000 	.word	0xffff0000
24006a64:	24007259 	.word	0x24007259
24006a68:	2400736b 	.word	0x2400736b

24006a6c <I2C_ITMasterCplt>:
{
24006a6c:	b570      	push	{r4, r5, r6, lr}
  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
24006a6e:	2320      	movs	r3, #32
24006a70:	6805      	ldr	r5, [r0, #0]
{
24006a72:	4604      	mov	r4, r0
24006a74:	460e      	mov	r6, r1
  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
24006a76:	61eb      	str	r3, [r5, #28]
  if (hi2c->State == HAL_I2C_STATE_BUSY_TX)
24006a78:	f890 3041 	ldrb.w	r3, [r0, #65]	@ 0x41
24006a7c:	2b21      	cmp	r3, #33	@ 0x21
24006a7e:	d131      	bne.n	24006ae4 <I2C_ITMasterCplt+0x78>
    I2C_Disable_IRQ(hi2c, I2C_XFER_TX_IT);
24006a80:	2101      	movs	r1, #1
24006a82:	f7fd fe7d 	bl	24004780 <I2C_Disable_IRQ>
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_TX;
24006a86:	2311      	movs	r3, #17
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
24006a88:	6323      	str	r3, [r4, #48]	@ 0x30
  I2C_RESET_CR2(hi2c);
24006a8a:	686b      	ldr	r3, [r5, #4]
  if (I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_AF) != RESET)
24006a8c:	06f2      	lsls	r2, r6, #27
  I2C_RESET_CR2(hi2c);
24006a8e:	f023 73ff 	bic.w	r3, r3, #33423360	@ 0x1fe0000
24006a92:	f423 338b 	bic.w	r3, r3, #71168	@ 0x11600
24006a96:	f423 73ff 	bic.w	r3, r3, #510	@ 0x1fe
24006a9a:	f023 0301 	bic.w	r3, r3, #1
24006a9e:	606b      	str	r3, [r5, #4]
  hi2c->XferISR       = NULL;
24006aa0:	f04f 0300 	mov.w	r3, #0
24006aa4:	6363      	str	r3, [r4, #52]	@ 0x34
  hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
24006aa6:	f5a3 3380 	sub.w	r3, r3, #65536	@ 0x10000
24006aaa:	62e3      	str	r3, [r4, #44]	@ 0x2c
  if (I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_AF) != RESET)
24006aac:	d505      	bpl.n	24006aba <I2C_ITMasterCplt+0x4e>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
24006aae:	2310      	movs	r3, #16
24006ab0:	61eb      	str	r3, [r5, #28]
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
24006ab2:	6c63      	ldr	r3, [r4, #68]	@ 0x44
24006ab4:	f043 0304 	orr.w	r3, r3, #4
24006ab8:	6463      	str	r3, [r4, #68]	@ 0x44
  if ((hi2c->State == HAL_I2C_STATE_ABORT) && (I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET))
24006aba:	f894 3041 	ldrb.w	r3, [r4, #65]	@ 0x41
24006abe:	2b60      	cmp	r3, #96	@ 0x60
24006ac0:	d102      	bne.n	24006ac8 <I2C_ITMasterCplt+0x5c>
24006ac2:	0773      	lsls	r3, r6, #29
24006ac4:	d500      	bpl.n	24006ac8 <I2C_ITMasterCplt+0x5c>
    tmp = (uint8_t)hi2c->Instance->RXDR;
24006ac6:	6a6b      	ldr	r3, [r5, #36]	@ 0x24
  I2C_Flush_TXDR(hi2c);
24006ac8:	4620      	mov	r0, r4
24006aca:	f7fd fe01 	bl	240046d0 <I2C_Flush_TXDR>
  tmperror = hi2c->ErrorCode;
24006ace:	6c63      	ldr	r3, [r4, #68]	@ 0x44
  if ((hi2c->State == HAL_I2C_STATE_ABORT) || (tmperror != HAL_I2C_ERROR_NONE))
24006ad0:	f894 2041 	ldrb.w	r2, [r4, #65]	@ 0x41
24006ad4:	2a60      	cmp	r2, #96	@ 0x60
24006ad6:	d000      	beq.n	24006ada <I2C_ITMasterCplt+0x6e>
24006ad8:	b16b      	cbz	r3, 24006af6 <I2C_ITMasterCplt+0x8a>
    I2C_ITError(hi2c, hi2c->ErrorCode);
24006ada:	6c61      	ldr	r1, [r4, #68]	@ 0x44
24006adc:	4620      	mov	r0, r4
}
24006ade:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    I2C_ITError(hi2c, hi2c->ErrorCode);
24006ae2:	e751      	b.n	24006988 <I2C_ITError>
  else if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
24006ae4:	f890 3041 	ldrb.w	r3, [r0, #65]	@ 0x41
24006ae8:	2b22      	cmp	r3, #34	@ 0x22
24006aea:	d1ce      	bne.n	24006a8a <I2C_ITMasterCplt+0x1e>
    I2C_Disable_IRQ(hi2c, I2C_XFER_RX_IT);
24006aec:	2102      	movs	r1, #2
24006aee:	f7fd fe47 	bl	24004780 <I2C_Disable_IRQ>
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
24006af2:	2312      	movs	r3, #18
24006af4:	e7c8      	b.n	24006a88 <I2C_ITMasterCplt+0x1c>
  else if (hi2c->State == HAL_I2C_STATE_BUSY_TX)
24006af6:	f894 2041 	ldrb.w	r2, [r4, #65]	@ 0x41
24006afa:	2a21      	cmp	r2, #33	@ 0x21
24006afc:	d111      	bne.n	24006b22 <I2C_ITMasterCplt+0xb6>
    hi2c->State = HAL_I2C_STATE_READY;
24006afe:	2220      	movs	r2, #32
      __HAL_UNLOCK(hi2c);
24006b00:	f884 3040 	strb.w	r3, [r4, #64]	@ 0x40
    hi2c->State = HAL_I2C_STATE_READY;
24006b04:	f884 2041 	strb.w	r2, [r4, #65]	@ 0x41
    hi2c->PreviousState = I2C_STATE_NONE;
24006b08:	6323      	str	r3, [r4, #48]	@ 0x30
    if (hi2c->Mode == HAL_I2C_MODE_MEM)
24006b0a:	f894 2042 	ldrb.w	r2, [r4, #66]	@ 0x42
      hi2c->Mode = HAL_I2C_MODE_NONE;
24006b0e:	f884 3042 	strb.w	r3, [r4, #66]	@ 0x42
    if (hi2c->Mode == HAL_I2C_MODE_MEM)
24006b12:	2a40      	cmp	r2, #64	@ 0x40
24006b14:	d102      	bne.n	24006b1c <I2C_ITMasterCplt+0xb0>
      HAL_I2C_MemTxCpltCallback(hi2c);
24006b16:	f7ff ff1d 	bl	24006954 <HAL_I2C_MemTxCpltCallback>
}
24006b1a:	bd70      	pop	{r4, r5, r6, pc}
      HAL_I2C_MasterTxCpltCallback(hi2c);
24006b1c:	f7ff fdf5 	bl	2400670a <HAL_I2C_MasterTxCpltCallback>
24006b20:	e7fb      	b.n	24006b1a <I2C_ITMasterCplt+0xae>
  else if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
24006b22:	f894 2041 	ldrb.w	r2, [r4, #65]	@ 0x41
24006b26:	2a22      	cmp	r2, #34	@ 0x22
24006b28:	d1f7      	bne.n	24006b1a <I2C_ITMasterCplt+0xae>
    hi2c->State = HAL_I2C_STATE_READY;
24006b2a:	2220      	movs	r2, #32
      __HAL_UNLOCK(hi2c);
24006b2c:	f884 3040 	strb.w	r3, [r4, #64]	@ 0x40
    hi2c->State = HAL_I2C_STATE_READY;
24006b30:	f884 2041 	strb.w	r2, [r4, #65]	@ 0x41
    hi2c->PreviousState = I2C_STATE_NONE;
24006b34:	6323      	str	r3, [r4, #48]	@ 0x30
    if (hi2c->Mode == HAL_I2C_MODE_MEM)
24006b36:	f894 2042 	ldrb.w	r2, [r4, #66]	@ 0x42
      hi2c->Mode = HAL_I2C_MODE_NONE;
24006b3a:	f884 3042 	strb.w	r3, [r4, #66]	@ 0x42
    if (hi2c->Mode == HAL_I2C_MODE_MEM)
24006b3e:	2a40      	cmp	r2, #64	@ 0x40
24006b40:	d102      	bne.n	24006b48 <I2C_ITMasterCplt+0xdc>
      HAL_I2C_MemRxCpltCallback(hi2c);
24006b42:	f7ff ff08 	bl	24006956 <HAL_I2C_MemRxCpltCallback>
24006b46:	e7e8      	b.n	24006b1a <I2C_ITMasterCplt+0xae>
      HAL_I2C_MasterRxCpltCallback(hi2c);
24006b48:	f7ff fde0 	bl	2400670c <HAL_I2C_MasterRxCpltCallback>
}
24006b4c:	e7e5      	b.n	24006b1a <I2C_ITMasterCplt+0xae>

24006b4e <I2C_Master_ISR_IT>:
{
24006b4e:	b573      	push	{r0, r1, r4, r5, r6, lr}
  __HAL_LOCK(hi2c);
24006b50:	f890 3040 	ldrb.w	r3, [r0, #64]	@ 0x40
{
24006b54:	4604      	mov	r4, r0
24006b56:	460d      	mov	r5, r1
24006b58:	4616      	mov	r6, r2
  __HAL_LOCK(hi2c);
24006b5a:	2b01      	cmp	r3, #1
24006b5c:	f000 8086 	beq.w	24006c6c <I2C_Master_ISR_IT+0x11e>
24006b60:	2301      	movs	r3, #1
  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_AF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))
24006b62:	06ca      	lsls	r2, r1, #27
  __HAL_LOCK(hi2c);
24006b64:	f880 3040 	strb.w	r3, [r0, #64]	@ 0x40
  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_AF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))
24006b68:	d517      	bpl.n	24006b9a <I2C_Master_ISR_IT+0x4c>
24006b6a:	06f3      	lsls	r3, r6, #27
24006b6c:	d515      	bpl.n	24006b9a <I2C_Master_ISR_IT+0x4c>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
24006b6e:	6803      	ldr	r3, [r0, #0]
24006b70:	2210      	movs	r2, #16
24006b72:	61da      	str	r2, [r3, #28]
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
24006b74:	6c43      	ldr	r3, [r0, #68]	@ 0x44
24006b76:	f043 0304 	orr.w	r3, r3, #4
24006b7a:	6443      	str	r3, [r0, #68]	@ 0x44
    I2C_Flush_TXDR(hi2c);
24006b7c:	f7fd fda8 	bl	240046d0 <I2C_Flush_TXDR>
  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_STOPF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_STOPI) != RESET))
24006b80:	06aa      	lsls	r2, r5, #26
24006b82:	d505      	bpl.n	24006b90 <I2C_Master_ISR_IT+0x42>
24006b84:	06b3      	lsls	r3, r6, #26
24006b86:	d503      	bpl.n	24006b90 <I2C_Master_ISR_IT+0x42>
    I2C_ITMasterCplt(hi2c, tmpITFlags);
24006b88:	4629      	mov	r1, r5
24006b8a:	4620      	mov	r0, r4
24006b8c:	f7ff ff6e 	bl	24006a6c <I2C_ITMasterCplt>
  __HAL_UNLOCK(hi2c);
24006b90:	2000      	movs	r0, #0
24006b92:	f884 0040 	strb.w	r0, [r4, #64]	@ 0x40
}
24006b96:	b002      	add	sp, #8
24006b98:	bd70      	pop	{r4, r5, r6, pc}
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_RXI) != RESET))
24006b9a:	0768      	lsls	r0, r5, #29
24006b9c:	d512      	bpl.n	24006bc4 <I2C_Master_ISR_IT+0x76>
24006b9e:	0771      	lsls	r1, r6, #29
24006ba0:	d510      	bpl.n	24006bc4 <I2C_Master_ISR_IT+0x76>
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
24006ba2:	6823      	ldr	r3, [r4, #0]
    tmpITFlags &= ~I2C_FLAG_RXNE;
24006ba4:	f025 0504 	bic.w	r5, r5, #4
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
24006ba8:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
24006baa:	6a63      	ldr	r3, [r4, #36]	@ 0x24
24006bac:	701a      	strb	r2, [r3, #0]
    hi2c->pBuffPtr++;
24006bae:	6a63      	ldr	r3, [r4, #36]	@ 0x24
24006bb0:	3301      	adds	r3, #1
    hi2c->pBuffPtr++;
24006bb2:	6263      	str	r3, [r4, #36]	@ 0x24
    hi2c->XferSize--;
24006bb4:	8d23      	ldrh	r3, [r4, #40]	@ 0x28
24006bb6:	3b01      	subs	r3, #1
24006bb8:	8523      	strh	r3, [r4, #40]	@ 0x28
    hi2c->XferCount--;
24006bba:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
24006bbc:	3b01      	subs	r3, #1
24006bbe:	b29b      	uxth	r3, r3
24006bc0:	8563      	strh	r3, [r4, #42]	@ 0x2a
24006bc2:	e7dd      	b.n	24006b80 <I2C_Master_ISR_IT+0x32>
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TXIS) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TXI) != RESET))
24006bc4:	07aa      	lsls	r2, r5, #30
24006bc6:	d507      	bpl.n	24006bd8 <I2C_Master_ISR_IT+0x8a>
24006bc8:	07b3      	lsls	r3, r6, #30
24006bca:	d505      	bpl.n	24006bd8 <I2C_Master_ISR_IT+0x8a>
    hi2c->Instance->TXDR = *hi2c->pBuffPtr;
24006bcc:	6a63      	ldr	r3, [r4, #36]	@ 0x24
24006bce:	6822      	ldr	r2, [r4, #0]
24006bd0:	f813 1b01 	ldrb.w	r1, [r3], #1
24006bd4:	6291      	str	r1, [r2, #40]	@ 0x28
24006bd6:	e7ec      	b.n	24006bb2 <I2C_Master_ISR_IT+0x64>
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TCR) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TCI) != RESET))
24006bd8:	0628      	lsls	r0, r5, #24
24006bda:	d532      	bpl.n	24006c42 <I2C_Master_ISR_IT+0xf4>
24006bdc:	0671      	lsls	r1, r6, #25
24006bde:	d530      	bpl.n	24006c42 <I2C_Master_ISR_IT+0xf4>
    if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
24006be0:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
24006be2:	6822      	ldr	r2, [r4, #0]
    if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
24006be4:	b29b      	uxth	r3, r3
24006be6:	b303      	cbz	r3, 24006c2a <I2C_Master_ISR_IT+0xdc>
24006be8:	8d20      	ldrh	r0, [r4, #40]	@ 0x28
24006bea:	b9f0      	cbnz	r0, 24006c2a <I2C_Master_ISR_IT+0xdc>
      devaddress = (uint16_t)(hi2c->Instance->CR2 & I2C_CR2_SADD);
24006bec:	6851      	ldr	r1, [r2, #4]
      if (hi2c->XferCount > MAX_NBYTE_SIZE)
24006bee:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
      devaddress = (uint16_t)(hi2c->Instance->CR2 & I2C_CR2_SADD);
24006bf0:	f3c1 0109 	ubfx	r1, r1, #0, #10
      if (hi2c->XferCount > MAX_NBYTE_SIZE)
24006bf4:	b29b      	uxth	r3, r3
24006bf6:	2bff      	cmp	r3, #255	@ 0xff
24006bf8:	d908      	bls.n	24006c0c <I2C_Master_ISR_IT+0xbe>
        hi2c->XferSize = MAX_NBYTE_SIZE;
24006bfa:	22ff      	movs	r2, #255	@ 0xff
        I2C_TransferConfig(hi2c, devaddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
24006bfc:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
        hi2c->XferSize = MAX_NBYTE_SIZE;
24006c00:	8522      	strh	r2, [r4, #40]	@ 0x28
        I2C_TransferConfig(hi2c, devaddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
24006c02:	9000      	str	r0, [sp, #0]
          I2C_TransferConfig(hi2c, devaddress, (uint8_t)hi2c->XferSize, hi2c->XferOptions, I2C_NO_STARTSTOP);
24006c04:	4620      	mov	r0, r4
24006c06:	f7fd fd71 	bl	240046ec <I2C_TransferConfig>
24006c0a:	e7b9      	b.n	24006b80 <I2C_Master_ISR_IT+0x32>
        hi2c->XferSize = hi2c->XferCount;
24006c0c:	8d62      	ldrh	r2, [r4, #42]	@ 0x2a
        if (hi2c->XferOptions != I2C_NO_OPTION_FRAME)
24006c0e:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
        hi2c->XferSize = hi2c->XferCount;
24006c10:	b292      	uxth	r2, r2
        if (hi2c->XferOptions != I2C_NO_OPTION_FRAME)
24006c12:	f513 3f80 	cmn.w	r3, #65536	@ 0x10000
        hi2c->XferSize = hi2c->XferCount;
24006c16:	8522      	strh	r2, [r4, #40]	@ 0x28
        if (hi2c->XferOptions != I2C_NO_OPTION_FRAME)
24006c18:	b2d2      	uxtb	r2, r2
24006c1a:	d002      	beq.n	24006c22 <I2C_Master_ISR_IT+0xd4>
          I2C_TransferConfig(hi2c, devaddress, (uint8_t)hi2c->XferSize, hi2c->XferOptions, I2C_NO_STARTSTOP);
24006c1c:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
24006c1e:	9000      	str	r0, [sp, #0]
24006c20:	e7f0      	b.n	24006c04 <I2C_Master_ISR_IT+0xb6>
          I2C_TransferConfig(hi2c, devaddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
24006c22:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
24006c26:	9000      	str	r0, [sp, #0]
24006c28:	e7ec      	b.n	24006c04 <I2C_Master_ISR_IT+0xb6>
      if (I2C_GET_STOP_MODE(hi2c) != I2C_AUTOEND_MODE)
24006c2a:	6853      	ldr	r3, [r2, #4]
24006c2c:	019a      	lsls	r2, r3, #6
24006c2e:	d403      	bmi.n	24006c38 <I2C_Master_ISR_IT+0xea>
        I2C_ITMasterSeqCplt(hi2c);
24006c30:	4620      	mov	r0, r4
24006c32:	f7ff fd6c 	bl	2400670e <I2C_ITMasterSeqCplt>
24006c36:	e7a3      	b.n	24006b80 <I2C_Master_ISR_IT+0x32>
        I2C_ITError(hi2c, HAL_I2C_ERROR_SIZE);
24006c38:	2140      	movs	r1, #64	@ 0x40
24006c3a:	4620      	mov	r0, r4
24006c3c:	f7ff fea4 	bl	24006988 <I2C_ITError>
24006c40:	e79e      	b.n	24006b80 <I2C_Master_ISR_IT+0x32>
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TC) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TCI) != RESET))
24006c42:	066b      	lsls	r3, r5, #25
24006c44:	d59c      	bpl.n	24006b80 <I2C_Master_ISR_IT+0x32>
24006c46:	0670      	lsls	r0, r6, #25
24006c48:	d59a      	bpl.n	24006b80 <I2C_Master_ISR_IT+0x32>
    if (hi2c->XferCount == 0U)
24006c4a:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
24006c4c:	b29b      	uxth	r3, r3
24006c4e:	2b00      	cmp	r3, #0
24006c50:	d1f2      	bne.n	24006c38 <I2C_Master_ISR_IT+0xea>
      if (I2C_GET_STOP_MODE(hi2c) != I2C_AUTOEND_MODE)
24006c52:	6823      	ldr	r3, [r4, #0]
24006c54:	685a      	ldr	r2, [r3, #4]
24006c56:	0191      	lsls	r1, r2, #6
24006c58:	d492      	bmi.n	24006b80 <I2C_Master_ISR_IT+0x32>
        if (hi2c->XferOptions == I2C_NO_OPTION_FRAME)
24006c5a:	6ae2      	ldr	r2, [r4, #44]	@ 0x2c
24006c5c:	f512 3f80 	cmn.w	r2, #65536	@ 0x10000
24006c60:	d1e6      	bne.n	24006c30 <I2C_Master_ISR_IT+0xe2>
          hi2c->Instance->CR2 |= I2C_CR2_STOP;
24006c62:	685a      	ldr	r2, [r3, #4]
24006c64:	f442 4280 	orr.w	r2, r2, #16384	@ 0x4000
24006c68:	605a      	str	r2, [r3, #4]
24006c6a:	e789      	b.n	24006b80 <I2C_Master_ISR_IT+0x32>
  __HAL_LOCK(hi2c);
24006c6c:	2002      	movs	r0, #2
24006c6e:	e792      	b.n	24006b96 <I2C_Master_ISR_IT+0x48>

24006c70 <I2C_Master_ISR_DMA>:
{
24006c70:	b573      	push	{r0, r1, r4, r5, r6, lr}
  __HAL_LOCK(hi2c);
24006c72:	f890 3040 	ldrb.w	r3, [r0, #64]	@ 0x40
{
24006c76:	4604      	mov	r4, r0
  __HAL_LOCK(hi2c);
24006c78:	2b01      	cmp	r3, #1
24006c7a:	d079      	beq.n	24006d70 <I2C_Master_ISR_DMA+0x100>
24006c7c:	2301      	movs	r3, #1
24006c7e:	f880 3040 	strb.w	r3, [r0, #64]	@ 0x40
  if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_AF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))
24006c82:	06cb      	lsls	r3, r1, #27
24006c84:	d512      	bpl.n	24006cac <I2C_Master_ISR_DMA+0x3c>
24006c86:	06d6      	lsls	r6, r2, #27
24006c88:	d510      	bpl.n	24006cac <I2C_Master_ISR_DMA+0x3c>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
24006c8a:	6803      	ldr	r3, [r0, #0]
24006c8c:	2210      	movs	r2, #16
    I2C_Enable_IRQ(hi2c, I2C_XFER_CPLT_IT);
24006c8e:	2120      	movs	r1, #32
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
24006c90:	61da      	str	r2, [r3, #28]
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
24006c92:	6c43      	ldr	r3, [r0, #68]	@ 0x44
24006c94:	f043 0304 	orr.w	r3, r3, #4
24006c98:	6443      	str	r3, [r0, #68]	@ 0x44
    I2C_Enable_IRQ(hi2c, I2C_XFER_CPLT_IT);
24006c9a:	f7fd fd3b 	bl	24004714 <I2C_Enable_IRQ>
    I2C_Flush_TXDR(hi2c);
24006c9e:	f7fd fd17 	bl	240046d0 <I2C_Flush_TXDR>
  __HAL_UNLOCK(hi2c);
24006ca2:	2000      	movs	r0, #0
24006ca4:	f884 0040 	strb.w	r0, [r4, #64]	@ 0x40
}
24006ca8:	b002      	add	sp, #8
24006caa:	bd70      	pop	{r4, r5, r6, pc}
  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_TCR) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TCI) != RESET))
24006cac:	060d      	lsls	r5, r1, #24
24006cae:	d542      	bpl.n	24006d36 <I2C_Master_ISR_DMA+0xc6>
24006cb0:	0650      	lsls	r0, r2, #25
24006cb2:	d540      	bpl.n	24006d36 <I2C_Master_ISR_DMA+0xc6>
    __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_TCI);
24006cb4:	6825      	ldr	r5, [r4, #0]
24006cb6:	682b      	ldr	r3, [r5, #0]
24006cb8:	f023 0340 	bic.w	r3, r3, #64	@ 0x40
24006cbc:	602b      	str	r3, [r5, #0]
    if (hi2c->XferCount != 0U)
24006cbe:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
24006cc0:	b29b      	uxth	r3, r3
24006cc2:	b363      	cbz	r3, 24006d1e <I2C_Master_ISR_DMA+0xae>
      devaddress = (uint16_t)(hi2c->Instance->CR2 & I2C_CR2_SADD);
24006cc4:	6869      	ldr	r1, [r5, #4]
      if (hi2c->XferCount > MAX_NBYTE_SIZE)
24006cc6:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
      devaddress = (uint16_t)(hi2c->Instance->CR2 & I2C_CR2_SADD);
24006cc8:	f3c1 0109 	ubfx	r1, r1, #0, #10
      if (hi2c->XferCount > MAX_NBYTE_SIZE)
24006ccc:	b29b      	uxth	r3, r3
24006cce:	2bff      	cmp	r3, #255	@ 0xff
24006cd0:	d91a      	bls.n	24006d08 <I2C_Master_ISR_DMA+0x98>
        hi2c->XferSize = MAX_NBYTE_SIZE;
24006cd2:	23ff      	movs	r3, #255	@ 0xff
24006cd4:	8523      	strh	r3, [r4, #40]	@ 0x28
        xfermode = I2C_RELOAD_MODE;
24006cd6:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
      I2C_TransferConfig(hi2c, devaddress, (uint8_t)hi2c->XferSize, xfermode, I2C_NO_STARTSTOP);
24006cda:	2200      	movs	r2, #0
24006cdc:	8d26      	ldrh	r6, [r4, #40]	@ 0x28
24006cde:	4620      	mov	r0, r4
24006ce0:	9200      	str	r2, [sp, #0]
24006ce2:	f894 2028 	ldrb.w	r2, [r4, #40]	@ 0x28
24006ce6:	f7fd fd01 	bl	240046ec <I2C_TransferConfig>
      hi2c->XferCount -= hi2c->XferSize;
24006cea:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
24006cec:	1b9b      	subs	r3, r3, r6
24006cee:	b29b      	uxth	r3, r3
24006cf0:	8563      	strh	r3, [r4, #42]	@ 0x2a
      if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
24006cf2:	f894 3041 	ldrb.w	r3, [r4, #65]	@ 0x41
24006cf6:	2b22      	cmp	r3, #34	@ 0x22
        hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;
24006cf8:	682b      	ldr	r3, [r5, #0]
24006cfa:	bf0c      	ite	eq
24006cfc:	f443 4300 	orreq.w	r3, r3, #32768	@ 0x8000
        hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN;
24006d00:	f443 4380 	orrne.w	r3, r3, #16384	@ 0x4000
24006d04:	602b      	str	r3, [r5, #0]
24006d06:	e7cc      	b.n	24006ca2 <I2C_Master_ISR_DMA+0x32>
        hi2c->XferSize = hi2c->XferCount;
24006d08:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
24006d0a:	8523      	strh	r3, [r4, #40]	@ 0x28
        if (hi2c->XferOptions != I2C_NO_OPTION_FRAME)
24006d0c:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
24006d0e:	f513 3f80 	cmn.w	r3, #65536	@ 0x10000
24006d12:	d001      	beq.n	24006d18 <I2C_Master_ISR_DMA+0xa8>
          xfermode = hi2c->XferOptions;
24006d14:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
24006d16:	e7e0      	b.n	24006cda <I2C_Master_ISR_DMA+0x6a>
          xfermode = I2C_AUTOEND_MODE;
24006d18:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
24006d1c:	e7dd      	b.n	24006cda <I2C_Master_ISR_DMA+0x6a>
      if (I2C_GET_STOP_MODE(hi2c) != I2C_AUTOEND_MODE)
24006d1e:	686b      	ldr	r3, [r5, #4]
24006d20:	019a      	lsls	r2, r3, #6
24006d22:	d403      	bmi.n	24006d2c <I2C_Master_ISR_DMA+0xbc>
        I2C_ITMasterSeqCplt(hi2c);
24006d24:	4620      	mov	r0, r4
24006d26:	f7ff fcf2 	bl	2400670e <I2C_ITMasterSeqCplt>
24006d2a:	e7ba      	b.n	24006ca2 <I2C_Master_ISR_DMA+0x32>
        I2C_ITError(hi2c, HAL_I2C_ERROR_SIZE);
24006d2c:	2140      	movs	r1, #64	@ 0x40
24006d2e:	4620      	mov	r0, r4
24006d30:	f7ff fe2a 	bl	24006988 <I2C_ITError>
24006d34:	e7b5      	b.n	24006ca2 <I2C_Master_ISR_DMA+0x32>
  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_TC) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TCI) != RESET))
24006d36:	064b      	lsls	r3, r1, #25
24006d38:	d512      	bpl.n	24006d60 <I2C_Master_ISR_DMA+0xf0>
24006d3a:	0656      	lsls	r6, r2, #25
24006d3c:	d510      	bpl.n	24006d60 <I2C_Master_ISR_DMA+0xf0>
    if (hi2c->XferCount == 0U)
24006d3e:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
24006d40:	b29b      	uxth	r3, r3
24006d42:	2b00      	cmp	r3, #0
24006d44:	d1f2      	bne.n	24006d2c <I2C_Master_ISR_DMA+0xbc>
      if (I2C_GET_STOP_MODE(hi2c) != I2C_AUTOEND_MODE)
24006d46:	6823      	ldr	r3, [r4, #0]
24006d48:	685a      	ldr	r2, [r3, #4]
24006d4a:	0195      	lsls	r5, r2, #6
24006d4c:	d4a9      	bmi.n	24006ca2 <I2C_Master_ISR_DMA+0x32>
        if (hi2c->XferOptions == I2C_NO_OPTION_FRAME)
24006d4e:	6ae2      	ldr	r2, [r4, #44]	@ 0x2c
24006d50:	f512 3f80 	cmn.w	r2, #65536	@ 0x10000
24006d54:	d1e6      	bne.n	24006d24 <I2C_Master_ISR_DMA+0xb4>
          hi2c->Instance->CR2 |= I2C_CR2_STOP;
24006d56:	685a      	ldr	r2, [r3, #4]
24006d58:	f442 4280 	orr.w	r2, r2, #16384	@ 0x4000
24006d5c:	605a      	str	r2, [r3, #4]
24006d5e:	e7a0      	b.n	24006ca2 <I2C_Master_ISR_DMA+0x32>
  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_STOPF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_STOPI) != RESET))
24006d60:	0688      	lsls	r0, r1, #26
24006d62:	d59e      	bpl.n	24006ca2 <I2C_Master_ISR_DMA+0x32>
24006d64:	0693      	lsls	r3, r2, #26
24006d66:	d59c      	bpl.n	24006ca2 <I2C_Master_ISR_DMA+0x32>
    I2C_ITMasterCplt(hi2c, ITFlags);
24006d68:	4620      	mov	r0, r4
24006d6a:	f7ff fe7f 	bl	24006a6c <I2C_ITMasterCplt>
24006d6e:	e798      	b.n	24006ca2 <I2C_Master_ISR_DMA+0x32>
  __HAL_LOCK(hi2c);
24006d70:	2002      	movs	r0, #2
24006d72:	e799      	b.n	24006ca8 <I2C_Master_ISR_DMA+0x38>

24006d74 <I2C_DMAError>:
{
24006d74:	b538      	push	{r3, r4, r5, lr}
  I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
24006d76:	6b85      	ldr	r5, [r0, #56]	@ 0x38
  if (hi2c->hdmatx != NULL)
24006d78:	6bac      	ldr	r4, [r5, #56]	@ 0x38
24006d7a:	b354      	cbz	r4, 24006dd2 <I2C_DMAError+0x5e>
    if (__HAL_DMA_GET_COUNTER(hi2c->hdmatx) == 0U)
24006d7c:	6823      	ldr	r3, [r4, #0]
24006d7e:	4a34      	ldr	r2, [pc, #208]	@ (24006e50 <I2C_DMAError+0xdc>)
24006d80:	4293      	cmp	r3, r2
24006d82:	d021      	beq.n	24006dc8 <I2C_DMAError+0x54>
24006d84:	3218      	adds	r2, #24
24006d86:	4293      	cmp	r3, r2
24006d88:	d01e      	beq.n	24006dc8 <I2C_DMAError+0x54>
24006d8a:	3218      	adds	r2, #24
24006d8c:	4293      	cmp	r3, r2
24006d8e:	d01b      	beq.n	24006dc8 <I2C_DMAError+0x54>
24006d90:	3218      	adds	r2, #24
24006d92:	4293      	cmp	r3, r2
24006d94:	d018      	beq.n	24006dc8 <I2C_DMAError+0x54>
24006d96:	3218      	adds	r2, #24
24006d98:	4293      	cmp	r3, r2
24006d9a:	d015      	beq.n	24006dc8 <I2C_DMAError+0x54>
24006d9c:	3218      	adds	r2, #24
24006d9e:	4293      	cmp	r3, r2
24006da0:	d012      	beq.n	24006dc8 <I2C_DMAError+0x54>
24006da2:	3218      	adds	r2, #24
24006da4:	4293      	cmp	r3, r2
24006da6:	d00f      	beq.n	24006dc8 <I2C_DMAError+0x54>
24006da8:	3218      	adds	r2, #24
24006daa:	4293      	cmp	r3, r2
24006dac:	d00c      	beq.n	24006dc8 <I2C_DMAError+0x54>
24006dae:	f502 7256 	add.w	r2, r2, #856	@ 0x358
24006db2:	4293      	cmp	r3, r2
24006db4:	d008      	beq.n	24006dc8 <I2C_DMAError+0x54>
24006db6:	3218      	adds	r2, #24
24006db8:	4293      	cmp	r3, r2
24006dba:	d005      	beq.n	24006dc8 <I2C_DMAError+0x54>
24006dbc:	3218      	adds	r2, #24
24006dbe:	4293      	cmp	r3, r2
24006dc0:	d002      	beq.n	24006dc8 <I2C_DMAError+0x54>
24006dc2:	3218      	adds	r2, #24
24006dc4:	4293      	cmp	r3, r2
24006dc6:	d0ff      	beq.n	24006dc8 <I2C_DMAError+0x54>
24006dc8:	685b      	ldr	r3, [r3, #4]
24006dca:	fab3 f383 	clz	r3, r3
24006dce:	095b      	lsrs	r3, r3, #5
24006dd0:	461c      	mov	r4, r3
  if (hi2c->hdmarx != NULL)
24006dd2:	6beb      	ldr	r3, [r5, #60]	@ 0x3c
24006dd4:	b363      	cbz	r3, 24006e30 <I2C_DMAError+0xbc>
    if (__HAL_DMA_GET_COUNTER(hi2c->hdmarx) == 0U)
24006dd6:	681b      	ldr	r3, [r3, #0]
24006dd8:	4a1d      	ldr	r2, [pc, #116]	@ (24006e50 <I2C_DMAError+0xdc>)
24006dda:	4293      	cmp	r3, r2
24006ddc:	d021      	beq.n	24006e22 <I2C_DMAError+0xae>
24006dde:	3218      	adds	r2, #24
24006de0:	4293      	cmp	r3, r2
24006de2:	d01e      	beq.n	24006e22 <I2C_DMAError+0xae>
24006de4:	3218      	adds	r2, #24
24006de6:	4293      	cmp	r3, r2
24006de8:	d01b      	beq.n	24006e22 <I2C_DMAError+0xae>
24006dea:	3218      	adds	r2, #24
24006dec:	4293      	cmp	r3, r2
24006dee:	d018      	beq.n	24006e22 <I2C_DMAError+0xae>
24006df0:	3218      	adds	r2, #24
24006df2:	4293      	cmp	r3, r2
24006df4:	d015      	beq.n	24006e22 <I2C_DMAError+0xae>
24006df6:	3218      	adds	r2, #24
24006df8:	4293      	cmp	r3, r2
24006dfa:	d012      	beq.n	24006e22 <I2C_DMAError+0xae>
24006dfc:	3218      	adds	r2, #24
24006dfe:	4293      	cmp	r3, r2
24006e00:	d00f      	beq.n	24006e22 <I2C_DMAError+0xae>
24006e02:	3218      	adds	r2, #24
24006e04:	4293      	cmp	r3, r2
24006e06:	d00c      	beq.n	24006e22 <I2C_DMAError+0xae>
24006e08:	f502 7256 	add.w	r2, r2, #856	@ 0x358
24006e0c:	4293      	cmp	r3, r2
24006e0e:	d008      	beq.n	24006e22 <I2C_DMAError+0xae>
24006e10:	3218      	adds	r2, #24
24006e12:	4293      	cmp	r3, r2
24006e14:	d005      	beq.n	24006e22 <I2C_DMAError+0xae>
24006e16:	3218      	adds	r2, #24
24006e18:	4293      	cmp	r3, r2
24006e1a:	d002      	beq.n	24006e22 <I2C_DMAError+0xae>
24006e1c:	3218      	adds	r2, #24
24006e1e:	4293      	cmp	r3, r2
24006e20:	d0ff      	beq.n	24006e22 <I2C_DMAError+0xae>
24006e22:	685b      	ldr	r3, [r3, #4]
24006e24:	fab3 f383 	clz	r3, r3
24006e28:	095b      	lsrs	r3, r3, #5
      treatdmaerror = 1U;
24006e2a:	2b00      	cmp	r3, #0
24006e2c:	bf18      	it	ne
24006e2e:	2401      	movne	r4, #1
  if (!((HAL_DMA_GetError(hdma) == HAL_DMA_ERROR_FE)) && (treatdmaerror != 0U))
24006e30:	f7fb fe41 	bl	24002ab6 <HAL_DMA_GetError>
24006e34:	2802      	cmp	r0, #2
24006e36:	d00a      	beq.n	24006e4e <I2C_DMAError+0xda>
24006e38:	b14c      	cbz	r4, 24006e4e <I2C_DMAError+0xda>
    hi2c->Instance->CR2 |= I2C_CR2_NACK;
24006e3a:	682a      	ldr	r2, [r5, #0]
    I2C_ITError(hi2c, HAL_I2C_ERROR_DMA);
24006e3c:	4628      	mov	r0, r5
24006e3e:	2110      	movs	r1, #16
    hi2c->Instance->CR2 |= I2C_CR2_NACK;
24006e40:	6853      	ldr	r3, [r2, #4]
24006e42:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
24006e46:	6053      	str	r3, [r2, #4]
}
24006e48:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    I2C_ITError(hi2c, HAL_I2C_ERROR_DMA);
24006e4c:	e59c      	b.n	24006988 <I2C_ITError>
}
24006e4e:	bd38      	pop	{r3, r4, r5, pc}
24006e50:	40020010 	.word	0x40020010

24006e54 <I2C_DMAMasterTransmitCplt>:
{
24006e54:	b510      	push	{r4, lr}
  I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
24006e56:	6b84      	ldr	r4, [r0, #56]	@ 0x38
  hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
24006e58:	6822      	ldr	r2, [r4, #0]
24006e5a:	6813      	ldr	r3, [r2, #0]
24006e5c:	f423 4380 	bic.w	r3, r3, #16384	@ 0x4000
24006e60:	6013      	str	r3, [r2, #0]
  if (hi2c->XferCount == 0U)
24006e62:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
24006e64:	b29b      	uxth	r3, r3
24006e66:	b92b      	cbnz	r3, 24006e74 <I2C_DMAMasterTransmitCplt+0x20>
    I2C_Enable_IRQ(hi2c, I2C_XFER_CPLT_IT);
24006e68:	2120      	movs	r1, #32
      I2C_Enable_IRQ(hi2c, I2C_XFER_RELOAD_IT);
24006e6a:	4620      	mov	r0, r4
}
24006e6c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      I2C_Enable_IRQ(hi2c, I2C_XFER_RELOAD_IT);
24006e70:	f7fd bc50 	b.w	24004714 <I2C_Enable_IRQ>
    hi2c->pBuffPtr += hi2c->XferSize;
24006e74:	8d23      	ldrh	r3, [r4, #40]	@ 0x28
24006e76:	6a61      	ldr	r1, [r4, #36]	@ 0x24
24006e78:	4419      	add	r1, r3
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
24006e7a:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
24006e7c:	b29b      	uxth	r3, r3
    hi2c->pBuffPtr += hi2c->XferSize;
24006e7e:	6261      	str	r1, [r4, #36]	@ 0x24
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
24006e80:	2bff      	cmp	r3, #255	@ 0xff
24006e82:	d80c      	bhi.n	24006e9e <I2C_DMAMasterTransmitCplt+0x4a>
      hi2c->XferSize = hi2c->XferCount;
24006e84:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
24006e86:	b29b      	uxth	r3, r3
    if (HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)hi2c->pBuffPtr, (uint32_t)&hi2c->Instance->TXDR, hi2c->XferSize) != HAL_OK)
24006e88:	3228      	adds	r2, #40	@ 0x28
24006e8a:	6ba0      	ldr	r0, [r4, #56]	@ 0x38
24006e8c:	8523      	strh	r3, [r4, #40]	@ 0x28
24006e8e:	f7fa fda7 	bl	240019e0 <HAL_DMA_Start_IT>
24006e92:	b130      	cbz	r0, 24006ea2 <I2C_DMAMasterTransmitCplt+0x4e>
      I2C_ITError(hi2c, HAL_I2C_ERROR_DMA);
24006e94:	4620      	mov	r0, r4
24006e96:	2110      	movs	r1, #16
}
24006e98:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      I2C_ITError(hi2c, HAL_I2C_ERROR_DMA);
24006e9c:	e574      	b.n	24006988 <I2C_ITError>
      hi2c->XferSize = MAX_NBYTE_SIZE;
24006e9e:	23ff      	movs	r3, #255	@ 0xff
24006ea0:	e7f2      	b.n	24006e88 <I2C_DMAMasterTransmitCplt+0x34>
      I2C_Enable_IRQ(hi2c, I2C_XFER_RELOAD_IT);
24006ea2:	2140      	movs	r1, #64	@ 0x40
24006ea4:	e7e1      	b.n	24006e6a <I2C_DMAMasterTransmitCplt+0x16>

24006ea6 <I2C_DMAMasterReceiveCplt>:
{
24006ea6:	b510      	push	{r4, lr}
  I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
24006ea8:	6b84      	ldr	r4, [r0, #56]	@ 0x38
  hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
24006eaa:	6821      	ldr	r1, [r4, #0]
24006eac:	680b      	ldr	r3, [r1, #0]
24006eae:	f423 4300 	bic.w	r3, r3, #32768	@ 0x8000
24006eb2:	600b      	str	r3, [r1, #0]
  if (hi2c->XferCount == 0U)
24006eb4:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
24006eb6:	b29b      	uxth	r3, r3
24006eb8:	b92b      	cbnz	r3, 24006ec6 <I2C_DMAMasterReceiveCplt+0x20>
    I2C_Enable_IRQ(hi2c, I2C_XFER_CPLT_IT);
24006eba:	2120      	movs	r1, #32
      I2C_Enable_IRQ(hi2c, I2C_XFER_RELOAD_IT);
24006ebc:	4620      	mov	r0, r4
}
24006ebe:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      I2C_Enable_IRQ(hi2c, I2C_XFER_RELOAD_IT);
24006ec2:	f7fd bc27 	b.w	24004714 <I2C_Enable_IRQ>
    hi2c->pBuffPtr += hi2c->XferSize;
24006ec6:	8d23      	ldrh	r3, [r4, #40]	@ 0x28
24006ec8:	6a62      	ldr	r2, [r4, #36]	@ 0x24
24006eca:	441a      	add	r2, r3
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
24006ecc:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
24006ece:	b29b      	uxth	r3, r3
    hi2c->pBuffPtr += hi2c->XferSize;
24006ed0:	6262      	str	r2, [r4, #36]	@ 0x24
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
24006ed2:	2bff      	cmp	r3, #255	@ 0xff
24006ed4:	d80c      	bhi.n	24006ef0 <I2C_DMAMasterReceiveCplt+0x4a>
      hi2c->XferSize = hi2c->XferCount;
24006ed6:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
24006ed8:	b29b      	uxth	r3, r3
    if (HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)hi2c->pBuffPtr, hi2c->XferSize) != HAL_OK)
24006eda:	3124      	adds	r1, #36	@ 0x24
24006edc:	6be0      	ldr	r0, [r4, #60]	@ 0x3c
24006ede:	8523      	strh	r3, [r4, #40]	@ 0x28
24006ee0:	f7fa fd7e 	bl	240019e0 <HAL_DMA_Start_IT>
24006ee4:	b130      	cbz	r0, 24006ef4 <I2C_DMAMasterReceiveCplt+0x4e>
      I2C_ITError(hi2c, HAL_I2C_ERROR_DMA);
24006ee6:	4620      	mov	r0, r4
24006ee8:	2110      	movs	r1, #16
}
24006eea:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      I2C_ITError(hi2c, HAL_I2C_ERROR_DMA);
24006eee:	e54b      	b.n	24006988 <I2C_ITError>
      hi2c->XferSize = MAX_NBYTE_SIZE;
24006ef0:	23ff      	movs	r3, #255	@ 0xff
24006ef2:	e7f2      	b.n	24006eda <I2C_DMAMasterReceiveCplt+0x34>
      I2C_Enable_IRQ(hi2c, I2C_XFER_RELOAD_IT);
24006ef4:	2140      	movs	r1, #64	@ 0x40
24006ef6:	e7e1      	b.n	24006ebc <I2C_DMAMasterReceiveCplt+0x16>

24006ef8 <HAL_I2C_ER_IRQHandler>:
  uint32_t itflags   = READ_REG(hi2c->Instance->ISR);
24006ef8:	6803      	ldr	r3, [r0, #0]
24006efa:	6999      	ldr	r1, [r3, #24]
  uint32_t itsources = READ_REG(hi2c->Instance->CR1);
24006efc:	681a      	ldr	r2, [r3, #0]
{
24006efe:	b410      	push	{r4}
  if ((I2C_CHECK_FLAG(itflags, I2C_FLAG_BERR) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERRI) != RESET))
24006f00:	05cc      	lsls	r4, r1, #23
24006f02:	d508      	bpl.n	24006f16 <HAL_I2C_ER_IRQHandler+0x1e>
24006f04:	0614      	lsls	r4, r2, #24
24006f06:	d506      	bpl.n	24006f16 <HAL_I2C_ER_IRQHandler+0x1e>
    hi2c->ErrorCode |= HAL_I2C_ERROR_BERR;
24006f08:	6c44      	ldr	r4, [r0, #68]	@ 0x44
24006f0a:	f044 0401 	orr.w	r4, r4, #1
24006f0e:	6444      	str	r4, [r0, #68]	@ 0x44
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_BERR);
24006f10:	f44f 7480 	mov.w	r4, #256	@ 0x100
24006f14:	61dc      	str	r4, [r3, #28]
  if ((I2C_CHECK_FLAG(itflags, I2C_FLAG_OVR) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERRI) != RESET))
24006f16:	054c      	lsls	r4, r1, #21
24006f18:	d508      	bpl.n	24006f2c <HAL_I2C_ER_IRQHandler+0x34>
24006f1a:	0614      	lsls	r4, r2, #24
24006f1c:	d506      	bpl.n	24006f2c <HAL_I2C_ER_IRQHandler+0x34>
    hi2c->ErrorCode |= HAL_I2C_ERROR_OVR;
24006f1e:	6c44      	ldr	r4, [r0, #68]	@ 0x44
24006f20:	f044 0408 	orr.w	r4, r4, #8
24006f24:	6444      	str	r4, [r0, #68]	@ 0x44
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_OVR);
24006f26:	f44f 6480 	mov.w	r4, #1024	@ 0x400
24006f2a:	61dc      	str	r4, [r3, #28]
  if ((I2C_CHECK_FLAG(itflags, I2C_FLAG_ARLO) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERRI) != RESET))
24006f2c:	0589      	lsls	r1, r1, #22
24006f2e:	d508      	bpl.n	24006f42 <HAL_I2C_ER_IRQHandler+0x4a>
24006f30:	0612      	lsls	r2, r2, #24
24006f32:	d506      	bpl.n	24006f42 <HAL_I2C_ER_IRQHandler+0x4a>
    hi2c->ErrorCode |= HAL_I2C_ERROR_ARLO;
24006f34:	6c42      	ldr	r2, [r0, #68]	@ 0x44
24006f36:	f042 0202 	orr.w	r2, r2, #2
24006f3a:	6442      	str	r2, [r0, #68]	@ 0x44
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ARLO);
24006f3c:	f44f 7200 	mov.w	r2, #512	@ 0x200
24006f40:	61da      	str	r2, [r3, #28]
  tmperror = hi2c->ErrorCode;
24006f42:	6c41      	ldr	r1, [r0, #68]	@ 0x44
  if ((tmperror & (HAL_I2C_ERROR_BERR | HAL_I2C_ERROR_OVR | HAL_I2C_ERROR_ARLO)) !=  HAL_I2C_ERROR_NONE)
24006f44:	f011 0f0b 	tst.w	r1, #11
24006f48:	d002      	beq.n	24006f50 <HAL_I2C_ER_IRQHandler+0x58>
}
24006f4a:	f85d 4b04 	ldr.w	r4, [sp], #4
    I2C_ITError(hi2c, tmperror);
24006f4e:	e51b      	b.n	24006988 <I2C_ITError>
}
24006f50:	f85d 4b04 	ldr.w	r4, [sp], #4
24006f54:	4770      	bx	lr

24006f56 <I2C_ITSlaveCplt.constprop.0>:
static void I2C_ITSlaveCplt(I2C_HandleTypeDef *hi2c, uint32_t ITFlags)
24006f56:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint32_t tmpcr1value = READ_REG(hi2c->Instance->CR1);
24006f5a:	6805      	ldr	r5, [r0, #0]
  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
24006f5c:	2320      	movs	r3, #32
static void I2C_ITSlaveCplt(I2C_HandleTypeDef *hi2c, uint32_t ITFlags)
24006f5e:	4604      	mov	r4, r0
24006f60:	460e      	mov	r6, r1
  uint32_t tmpcr1value = READ_REG(hi2c->Instance->CR1);
24006f62:	f8d5 8000 	ldr.w	r8, [r5]
  HAL_I2C_StateTypeDef tmpstate = hi2c->State;
24006f66:	f890 7041 	ldrb.w	r7, [r0, #65]	@ 0x41
  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
24006f6a:	61eb      	str	r3, [r5, #28]
  if ((tmpstate == HAL_I2C_STATE_BUSY_TX) || (tmpstate == HAL_I2C_STATE_BUSY_TX_LISTEN))
24006f6c:	f007 07f7 	and.w	r7, r7, #247	@ 0xf7
24006f70:	2f21      	cmp	r7, #33	@ 0x21
24006f72:	d170      	bne.n	24007056 <I2C_ITSlaveCplt.constprop.0+0x100>
    I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_TX_IT);
24006f74:	f248 0101 	movw	r1, #32769	@ 0x8001
    I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_RX_IT);
24006f78:	f7fd fc02 	bl	24004780 <I2C_Disable_IRQ>
    hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_RX;
24006f7c:	6327      	str	r7, [r4, #48]	@ 0x30
  hi2c->Instance->CR2 |= I2C_CR2_NACK;
24006f7e:	686b      	ldr	r3, [r5, #4]
  I2C_Flush_TXDR(hi2c);
24006f80:	4620      	mov	r0, r4
  hi2c->Instance->CR2 |= I2C_CR2_NACK;
24006f82:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
24006f86:	606b      	str	r3, [r5, #4]
  I2C_RESET_CR2(hi2c);
24006f88:	686b      	ldr	r3, [r5, #4]
24006f8a:	f023 73ff 	bic.w	r3, r3, #33423360	@ 0x1fe0000
24006f8e:	f423 338b 	bic.w	r3, r3, #71168	@ 0x11600
24006f92:	f423 73ff 	bic.w	r3, r3, #510	@ 0x1fe
24006f96:	f023 0301 	bic.w	r3, r3, #1
24006f9a:	606b      	str	r3, [r5, #4]
  I2C_Flush_TXDR(hi2c);
24006f9c:	f7fd fb98 	bl	240046d0 <I2C_Flush_TXDR>
  if (I2C_CHECK_IT_SOURCE(tmpcr1value, I2C_CR1_TXDMAEN) != RESET)
24006fa0:	f418 4f80 	tst.w	r8, #16384	@ 0x4000
24006fa4:	d05c      	beq.n	24007060 <I2C_ITSlaveCplt.constprop.0+0x10a>
    hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
24006fa6:	682b      	ldr	r3, [r5, #0]
24006fa8:	f423 4380 	bic.w	r3, r3, #16384	@ 0x4000
24006fac:	602b      	str	r3, [r5, #0]
    if (hi2c->hdmatx != NULL)
24006fae:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
    if (hi2c->hdmarx != NULL)
24006fb0:	b32b      	cbz	r3, 24006ffe <I2C_ITSlaveCplt.constprop.0+0xa8>
      hi2c->XferCount = (uint16_t)__HAL_DMA_GET_COUNTER(hi2c->hdmarx);
24006fb2:	681b      	ldr	r3, [r3, #0]
24006fb4:	4a42      	ldr	r2, [pc, #264]	@ (240070c0 <I2C_ITSlaveCplt.constprop.0+0x16a>)
24006fb6:	4293      	cmp	r3, r2
24006fb8:	d01e      	beq.n	24006ff8 <I2C_ITSlaveCplt.constprop.0+0xa2>
24006fba:	3218      	adds	r2, #24
24006fbc:	4293      	cmp	r3, r2
24006fbe:	d01b      	beq.n	24006ff8 <I2C_ITSlaveCplt.constprop.0+0xa2>
24006fc0:	3218      	adds	r2, #24
24006fc2:	4293      	cmp	r3, r2
24006fc4:	d018      	beq.n	24006ff8 <I2C_ITSlaveCplt.constprop.0+0xa2>
24006fc6:	3218      	adds	r2, #24
24006fc8:	4293      	cmp	r3, r2
24006fca:	d015      	beq.n	24006ff8 <I2C_ITSlaveCplt.constprop.0+0xa2>
24006fcc:	3218      	adds	r2, #24
24006fce:	4293      	cmp	r3, r2
24006fd0:	d012      	beq.n	24006ff8 <I2C_ITSlaveCplt.constprop.0+0xa2>
24006fd2:	3218      	adds	r2, #24
24006fd4:	4293      	cmp	r3, r2
24006fd6:	d00f      	beq.n	24006ff8 <I2C_ITSlaveCplt.constprop.0+0xa2>
24006fd8:	3218      	adds	r2, #24
24006fda:	4293      	cmp	r3, r2
24006fdc:	d00c      	beq.n	24006ff8 <I2C_ITSlaveCplt.constprop.0+0xa2>
24006fde:	3218      	adds	r2, #24
24006fe0:	4293      	cmp	r3, r2
24006fe2:	d009      	beq.n	24006ff8 <I2C_ITSlaveCplt.constprop.0+0xa2>
24006fe4:	f502 7256 	add.w	r2, r2, #856	@ 0x358
24006fe8:	4293      	cmp	r3, r2
24006fea:	d005      	beq.n	24006ff8 <I2C_ITSlaveCplt.constprop.0+0xa2>
24006fec:	3218      	adds	r2, #24
24006fee:	4293      	cmp	r3, r2
24006ff0:	d002      	beq.n	24006ff8 <I2C_ITSlaveCplt.constprop.0+0xa2>
24006ff2:	3218      	adds	r2, #24
24006ff4:	4293      	cmp	r3, r2
24006ff6:	d0ff      	beq.n	24006ff8 <I2C_ITSlaveCplt.constprop.0+0xa2>
24006ff8:	685b      	ldr	r3, [r3, #4]
24006ffa:	b29b      	uxth	r3, r3
24006ffc:	8563      	strh	r3, [r4, #42]	@ 0x2a
  if (I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET)
24006ffe:	0773      	lsls	r3, r6, #29
24007000:	d50f      	bpl.n	24007022 <I2C_ITSlaveCplt.constprop.0+0xcc>
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
24007002:	6a63      	ldr	r3, [r4, #36]	@ 0x24
24007004:	6a6a      	ldr	r2, [r5, #36]	@ 0x24
24007006:	701a      	strb	r2, [r3, #0]
    hi2c->pBuffPtr++;
24007008:	6a63      	ldr	r3, [r4, #36]	@ 0x24
2400700a:	3301      	adds	r3, #1
2400700c:	6263      	str	r3, [r4, #36]	@ 0x24
    if ((hi2c->XferSize > 0U))
2400700e:	8d23      	ldrh	r3, [r4, #40]	@ 0x28
24007010:	b12b      	cbz	r3, 2400701e <I2C_ITSlaveCplt.constprop.0+0xc8>
      hi2c->XferSize--;
24007012:	3b01      	subs	r3, #1
24007014:	8523      	strh	r3, [r4, #40]	@ 0x28
      hi2c->XferCount--;
24007016:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
24007018:	3b01      	subs	r3, #1
2400701a:	b29b      	uxth	r3, r3
2400701c:	8563      	strh	r3, [r4, #42]	@ 0x2a
    tmpITFlags &= ~I2C_FLAG_RXNE;
2400701e:	f026 0604 	bic.w	r6, r6, #4
  if (hi2c->XferCount != 0U)
24007022:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
24007024:	b29b      	uxth	r3, r3
24007026:	b11b      	cbz	r3, 24007030 <I2C_ITSlaveCplt.constprop.0+0xda>
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
24007028:	6c63      	ldr	r3, [r4, #68]	@ 0x44
2400702a:	f043 0304 	orr.w	r3, r3, #4
2400702e:	6463      	str	r3, [r4, #68]	@ 0x44
  hi2c->Mode = HAL_I2C_MODE_NONE;
24007030:	2300      	movs	r3, #0
24007032:	f884 3042 	strb.w	r3, [r4, #66]	@ 0x42
  if (hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
24007036:	6c65      	ldr	r5, [r4, #68]	@ 0x44
  hi2c->XferISR = NULL;
24007038:	6363      	str	r3, [r4, #52]	@ 0x34
  if (hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
2400703a:	b1d5      	cbz	r5, 24007072 <I2C_ITSlaveCplt.constprop.0+0x11c>
    I2C_ITError(hi2c, hi2c->ErrorCode);
2400703c:	6c61      	ldr	r1, [r4, #68]	@ 0x44
2400703e:	4620      	mov	r0, r4
24007040:	f7ff fca2 	bl	24006988 <I2C_ITError>
    if (hi2c->State == HAL_I2C_STATE_LISTEN)
24007044:	f894 3041 	ldrb.w	r3, [r4, #65]	@ 0x41
24007048:	2b28      	cmp	r3, #40	@ 0x28
2400704a:	d124      	bne.n	24007096 <I2C_ITSlaveCplt.constprop.0+0x140>
      I2C_ITListenCplt(hi2c, tmpITFlags);
2400704c:	4631      	mov	r1, r6
2400704e:	4620      	mov	r0, r4
}
24007050:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
      I2C_ITListenCplt(hi2c, tmpITFlags);
24007054:	e44e      	b.n	240068f4 <I2C_ITListenCplt>
  else if ((tmpstate == HAL_I2C_STATE_BUSY_RX) || (tmpstate == HAL_I2C_STATE_BUSY_RX_LISTEN))
24007056:	2f22      	cmp	r7, #34	@ 0x22
24007058:	d191      	bne.n	24006f7e <I2C_ITSlaveCplt.constprop.0+0x28>
    I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_RX_IT);
2400705a:	f248 0102 	movw	r1, #32770	@ 0x8002
2400705e:	e78b      	b.n	24006f78 <I2C_ITSlaveCplt.constprop.0+0x22>
  else if (I2C_CHECK_IT_SOURCE(tmpcr1value, I2C_CR1_RXDMAEN) != RESET)
24007060:	f418 4f00 	tst.w	r8, #32768	@ 0x8000
24007064:	d0cb      	beq.n	24006ffe <I2C_ITSlaveCplt.constprop.0+0xa8>
    hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
24007066:	682b      	ldr	r3, [r5, #0]
24007068:	f423 4300 	bic.w	r3, r3, #32768	@ 0x8000
2400706c:	602b      	str	r3, [r5, #0]
    if (hi2c->hdmarx != NULL)
2400706e:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
24007070:	e79e      	b.n	24006fb0 <I2C_ITSlaveCplt.constprop.0+0x5a>
  else if (hi2c->XferOptions != I2C_NO_OPTION_FRAME)
24007072:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
24007074:	f513 3f80 	cmn.w	r3, #65536	@ 0x10000
24007078:	d00f      	beq.n	2400709a <I2C_ITSlaveCplt.constprop.0+0x144>
    I2C_ITSlaveSeqCplt(hi2c);
2400707a:	4620      	mov	r0, r4
2400707c:	f7ff fb6b 	bl	24006756 <I2C_ITSlaveSeqCplt>
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
24007080:	4b10      	ldr	r3, [pc, #64]	@ (240070c4 <I2C_ITSlaveCplt.constprop.0+0x16e>)
    HAL_I2C_ListenCpltCallback(hi2c);
24007082:	4620      	mov	r0, r4
    __HAL_UNLOCK(hi2c);
24007084:	f884 5040 	strb.w	r5, [r4, #64]	@ 0x40
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
24007088:	62e3      	str	r3, [r4, #44]	@ 0x2c
    hi2c->State = HAL_I2C_STATE_READY;
2400708a:	2320      	movs	r3, #32
2400708c:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
    hi2c->PreviousState = I2C_STATE_NONE;
24007090:	6325      	str	r5, [r4, #48]	@ 0x30
    HAL_I2C_ListenCpltCallback(hi2c);
24007092:	f7ff fc2e 	bl	240068f2 <HAL_I2C_ListenCpltCallback>
}
24007096:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  else if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
2400709a:	f894 3041 	ldrb.w	r3, [r4, #65]	@ 0x41
    HAL_I2C_SlaveRxCpltCallback(hi2c);
2400709e:	4620      	mov	r0, r4
    __HAL_UNLOCK(hi2c);
240070a0:	f884 5040 	strb.w	r5, [r4, #64]	@ 0x40
  else if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
240070a4:	2b22      	cmp	r3, #34	@ 0x22
240070a6:	f04f 0320 	mov.w	r3, #32
    hi2c->State = HAL_I2C_STATE_READY;
240070aa:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
    hi2c->PreviousState = I2C_STATE_NONE;
240070ae:	6325      	str	r5, [r4, #48]	@ 0x30
  else if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
240070b0:	d102      	bne.n	240070b8 <I2C_ITSlaveCplt.constprop.0+0x162>
    HAL_I2C_SlaveRxCpltCallback(hi2c);
240070b2:	f7ff fb4f 	bl	24006754 <HAL_I2C_SlaveRxCpltCallback>
240070b6:	e7ee      	b.n	24007096 <I2C_ITSlaveCplt.constprop.0+0x140>
    HAL_I2C_SlaveTxCpltCallback(hi2c);
240070b8:	f7ff fb4b 	bl	24006752 <HAL_I2C_SlaveTxCpltCallback>
}
240070bc:	e7eb      	b.n	24007096 <I2C_ITSlaveCplt.constprop.0+0x140>
240070be:	bf00      	nop
240070c0:	40020010 	.word	0x40020010
240070c4:	ffff0000 	.word	0xffff0000

240070c8 <I2C_Slave_ISR_DMA>:
{
240070c8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  __HAL_LOCK(hi2c);
240070ca:	f890 3040 	ldrb.w	r3, [r0, #64]	@ 0x40
{
240070ce:	4604      	mov	r4, r0
240070d0:	460d      	mov	r5, r1
240070d2:	4617      	mov	r7, r2
  __HAL_LOCK(hi2c);
240070d4:	2b01      	cmp	r3, #1
  uint32_t tmpoptions = hi2c->XferOptions;
240070d6:	6ac6      	ldr	r6, [r0, #44]	@ 0x2c
  __HAL_LOCK(hi2c);
240070d8:	f000 80ba 	beq.w	24007250 <I2C_Slave_ISR_DMA+0x188>
240070dc:	2301      	movs	r3, #1
240070de:	f880 3040 	strb.w	r3, [r0, #64]	@ 0x40
  if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_STOPF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_STOPI) != RESET))
240070e2:	068b      	lsls	r3, r1, #26
240070e4:	d503      	bpl.n	240070ee <I2C_Slave_ISR_DMA+0x26>
240070e6:	06ba      	lsls	r2, r7, #26
240070e8:	d501      	bpl.n	240070ee <I2C_Slave_ISR_DMA+0x26>
    I2C_ITSlaveCplt(hi2c, ITFlags);
240070ea:	f7ff ff34 	bl	24006f56 <I2C_ITSlaveCplt.constprop.0>
  if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_AF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))
240070ee:	06eb      	lsls	r3, r5, #27
240070f0:	f140 80a6 	bpl.w	24007240 <I2C_Slave_ISR_DMA+0x178>
240070f4:	06f8      	lsls	r0, r7, #27
240070f6:	f140 80a3 	bpl.w	24007240 <I2C_Slave_ISR_DMA+0x178>
    if ((I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_TXDMAEN) != RESET) ||
240070fa:	f417 4f40 	tst.w	r7, #49152	@ 0xc000
240070fe:	f000 809b 	beq.w	24007238 <I2C_Slave_ISR_DMA+0x170>
      if (hi2c->hdmarx != NULL)
24007102:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
24007104:	b34b      	cbz	r3, 2400715a <I2C_Slave_ISR_DMA+0x92>
        if (I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_RXDMAEN) != RESET)
24007106:	f417 4000 	ands.w	r0, r7, #32768	@ 0x8000
2400710a:	d027      	beq.n	2400715c <I2C_Slave_ISR_DMA+0x94>
          if (__HAL_DMA_GET_COUNTER(hi2c->hdmarx) == 0U)
2400710c:	681b      	ldr	r3, [r3, #0]
2400710e:	4a51      	ldr	r2, [pc, #324]	@ (24007254 <I2C_Slave_ISR_DMA+0x18c>)
24007110:	4293      	cmp	r3, r2
24007112:	d01e      	beq.n	24007152 <I2C_Slave_ISR_DMA+0x8a>
24007114:	3218      	adds	r2, #24
24007116:	4293      	cmp	r3, r2
24007118:	d01b      	beq.n	24007152 <I2C_Slave_ISR_DMA+0x8a>
2400711a:	3218      	adds	r2, #24
2400711c:	4293      	cmp	r3, r2
2400711e:	d018      	beq.n	24007152 <I2C_Slave_ISR_DMA+0x8a>
24007120:	3218      	adds	r2, #24
24007122:	4293      	cmp	r3, r2
24007124:	d015      	beq.n	24007152 <I2C_Slave_ISR_DMA+0x8a>
24007126:	3218      	adds	r2, #24
24007128:	4293      	cmp	r3, r2
2400712a:	d012      	beq.n	24007152 <I2C_Slave_ISR_DMA+0x8a>
2400712c:	3218      	adds	r2, #24
2400712e:	4293      	cmp	r3, r2
24007130:	d00f      	beq.n	24007152 <I2C_Slave_ISR_DMA+0x8a>
24007132:	3218      	adds	r2, #24
24007134:	4293      	cmp	r3, r2
24007136:	d00c      	beq.n	24007152 <I2C_Slave_ISR_DMA+0x8a>
24007138:	3218      	adds	r2, #24
2400713a:	4293      	cmp	r3, r2
2400713c:	d009      	beq.n	24007152 <I2C_Slave_ISR_DMA+0x8a>
2400713e:	f502 7256 	add.w	r2, r2, #856	@ 0x358
24007142:	4293      	cmp	r3, r2
24007144:	d005      	beq.n	24007152 <I2C_Slave_ISR_DMA+0x8a>
24007146:	3218      	adds	r2, #24
24007148:	4293      	cmp	r3, r2
2400714a:	d002      	beq.n	24007152 <I2C_Slave_ISR_DMA+0x8a>
2400714c:	3218      	adds	r2, #24
2400714e:	4293      	cmp	r3, r2
24007150:	d0ff      	beq.n	24007152 <I2C_Slave_ISR_DMA+0x8a>
24007152:	685b      	ldr	r3, [r3, #4]
24007154:	fab3 f383 	clz	r3, r3
24007158:	095b      	lsrs	r3, r3, #5
  uint32_t treatdmanack = 0U;
2400715a:	4618      	mov	r0, r3
      if (hi2c->hdmatx != NULL)
2400715c:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
2400715e:	b34b      	cbz	r3, 240071b4 <I2C_Slave_ISR_DMA+0xec>
        if (I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_TXDMAEN) != RESET)
24007160:	0479      	lsls	r1, r7, #17
24007162:	d527      	bpl.n	240071b4 <I2C_Slave_ISR_DMA+0xec>
          if (__HAL_DMA_GET_COUNTER(hi2c->hdmatx) == 0U)
24007164:	681b      	ldr	r3, [r3, #0]
24007166:	4a3b      	ldr	r2, [pc, #236]	@ (24007254 <I2C_Slave_ISR_DMA+0x18c>)
24007168:	4293      	cmp	r3, r2
2400716a:	d01e      	beq.n	240071aa <I2C_Slave_ISR_DMA+0xe2>
2400716c:	3218      	adds	r2, #24
2400716e:	4293      	cmp	r3, r2
24007170:	d01b      	beq.n	240071aa <I2C_Slave_ISR_DMA+0xe2>
24007172:	3218      	adds	r2, #24
24007174:	4293      	cmp	r3, r2
24007176:	d018      	beq.n	240071aa <I2C_Slave_ISR_DMA+0xe2>
24007178:	3218      	adds	r2, #24
2400717a:	4293      	cmp	r3, r2
2400717c:	d015      	beq.n	240071aa <I2C_Slave_ISR_DMA+0xe2>
2400717e:	3218      	adds	r2, #24
24007180:	4293      	cmp	r3, r2
24007182:	d012      	beq.n	240071aa <I2C_Slave_ISR_DMA+0xe2>
24007184:	3218      	adds	r2, #24
24007186:	4293      	cmp	r3, r2
24007188:	d00f      	beq.n	240071aa <I2C_Slave_ISR_DMA+0xe2>
2400718a:	3218      	adds	r2, #24
2400718c:	4293      	cmp	r3, r2
2400718e:	d00c      	beq.n	240071aa <I2C_Slave_ISR_DMA+0xe2>
24007190:	3218      	adds	r2, #24
24007192:	4293      	cmp	r3, r2
24007194:	d009      	beq.n	240071aa <I2C_Slave_ISR_DMA+0xe2>
24007196:	f502 7256 	add.w	r2, r2, #856	@ 0x358
2400719a:	4293      	cmp	r3, r2
2400719c:	d005      	beq.n	240071aa <I2C_Slave_ISR_DMA+0xe2>
2400719e:	3218      	adds	r2, #24
240071a0:	4293      	cmp	r3, r2
240071a2:	d002      	beq.n	240071aa <I2C_Slave_ISR_DMA+0xe2>
240071a4:	3218      	adds	r2, #24
240071a6:	4293      	cmp	r3, r2
240071a8:	d0ff      	beq.n	240071aa <I2C_Slave_ISR_DMA+0xe2>
240071aa:	685b      	ldr	r3, [r3, #4]
240071ac:	fab3 f383 	clz	r3, r3
240071b0:	095b      	lsrs	r3, r3, #5
240071b2:	b90b      	cbnz	r3, 240071b8 <I2C_Slave_ISR_DMA+0xf0>
      if (treatdmanack == 1U)
240071b4:	2801      	cmp	r0, #1
240071b6:	d11f      	bne.n	240071f8 <I2C_Slave_ISR_DMA+0x130>
        if ((hi2c->State == HAL_I2C_STATE_LISTEN) && (tmpoptions == I2C_FIRST_AND_LAST_FRAME)) /* Same action must be done for (tmpoptions == I2C_LAST_FRAME) which removed for Warning[Pa134]: left and right operands are identical */
240071b8:	f894 3041 	ldrb.w	r3, [r4, #65]	@ 0x41
240071bc:	2b28      	cmp	r3, #40	@ 0x28
240071be:	d10a      	bne.n	240071d6 <I2C_Slave_ISR_DMA+0x10e>
240071c0:	f1b6 7f00 	cmp.w	r6, #33554432	@ 0x2000000
240071c4:	d107      	bne.n	240071d6 <I2C_Slave_ISR_DMA+0x10e>
          I2C_ITListenCplt(hi2c, ITFlags);
240071c6:	4629      	mov	r1, r5
240071c8:	4620      	mov	r0, r4
240071ca:	f7ff fb93 	bl	240068f4 <I2C_ITListenCplt>
  __HAL_UNLOCK(hi2c);
240071ce:	2000      	movs	r0, #0
240071d0:	f884 0040 	strb.w	r0, [r4, #64]	@ 0x40
}
240071d4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        else if ((hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN) && (tmpoptions != I2C_NO_OPTION_FRAME))
240071d6:	f894 2041 	ldrb.w	r2, [r4, #65]	@ 0x41
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
240071da:	6823      	ldr	r3, [r4, #0]
        else if ((hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN) && (tmpoptions != I2C_NO_OPTION_FRAME))
240071dc:	2a29      	cmp	r2, #41	@ 0x29
240071de:	f04f 0210 	mov.w	r2, #16
          __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
240071e2:	61da      	str	r2, [r3, #28]
        else if ((hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN) && (tmpoptions != I2C_NO_OPTION_FRAME))
240071e4:	d1f3      	bne.n	240071ce <I2C_Slave_ISR_DMA+0x106>
240071e6:	f516 3f80 	cmn.w	r6, #65536	@ 0x10000
240071ea:	d0f0      	beq.n	240071ce <I2C_Slave_ISR_DMA+0x106>
          I2C_Flush_TXDR(hi2c);
240071ec:	4620      	mov	r0, r4
240071ee:	f7fd fa6f 	bl	240046d0 <I2C_Flush_TXDR>
          I2C_ITSlaveSeqCplt(hi2c);
240071f2:	f7ff fab0 	bl	24006756 <I2C_ITSlaveSeqCplt>
240071f6:	e7ea      	b.n	240071ce <I2C_Slave_ISR_DMA+0x106>
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
240071f8:	6823      	ldr	r3, [r4, #0]
240071fa:	2210      	movs	r2, #16
240071fc:	61da      	str	r2, [r3, #28]
        if ((tmpoptions == I2C_FIRST_FRAME) || (tmpoptions == I2C_NEXT_FRAME))
240071fe:	f036 7280 	bics.w	r2, r6, #16777216	@ 0x1000000
        hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
24007202:	6c63      	ldr	r3, [r4, #68]	@ 0x44
24007204:	f043 0304 	orr.w	r3, r3, #4
24007208:	6463      	str	r3, [r4, #68]	@ 0x44
        tmpstate = hi2c->State;
2400720a:	f894 3041 	ldrb.w	r3, [r4, #65]	@ 0x41
2400720e:	b2db      	uxtb	r3, r3
        if ((tmpoptions == I2C_FIRST_FRAME) || (tmpoptions == I2C_NEXT_FRAME))
24007210:	d1dd      	bne.n	240071ce <I2C_Slave_ISR_DMA+0x106>
          if ((tmpstate == HAL_I2C_STATE_BUSY_TX) || (tmpstate == HAL_I2C_STATE_BUSY_TX_LISTEN))
24007212:	3b21      	subs	r3, #33	@ 0x21
24007214:	2b09      	cmp	r3, #9
24007216:	d808      	bhi.n	2400722a <I2C_Slave_ISR_DMA+0x162>
24007218:	e8df f003 	tbb	[pc, r3]
2400721c:	07070c05 	.word	0x07070c05
24007220:	07070707 	.word	0x07070707
24007224:	0c05      	.short	0x0c05
            hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_TX;
24007226:	2321      	movs	r3, #33	@ 0x21
            hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_RX;
24007228:	6323      	str	r3, [r4, #48]	@ 0x30
          I2C_ITError(hi2c, hi2c->ErrorCode);
2400722a:	6c61      	ldr	r1, [r4, #68]	@ 0x44
2400722c:	4620      	mov	r0, r4
2400722e:	f7ff fbab 	bl	24006988 <I2C_ITError>
24007232:	e7cc      	b.n	240071ce <I2C_Slave_ISR_DMA+0x106>
            hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_RX;
24007234:	2322      	movs	r3, #34	@ 0x22
24007236:	e7f7      	b.n	24007228 <I2C_Slave_ISR_DMA+0x160>
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
24007238:	6823      	ldr	r3, [r4, #0]
2400723a:	2210      	movs	r2, #16
2400723c:	61da      	str	r2, [r3, #28]
2400723e:	e7c6      	b.n	240071ce <I2C_Slave_ISR_DMA+0x106>
  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_ADDR) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_ADDRI) != RESET))
24007240:	072a      	lsls	r2, r5, #28
24007242:	d5c4      	bpl.n	240071ce <I2C_Slave_ISR_DMA+0x106>
24007244:	073b      	lsls	r3, r7, #28
24007246:	d5c2      	bpl.n	240071ce <I2C_Slave_ISR_DMA+0x106>
    I2C_ITAddrCplt(hi2c, ITFlags);
24007248:	4620      	mov	r0, r4
2400724a:	f7ff fb0e 	bl	2400686a <I2C_ITAddrCplt.constprop.0>
2400724e:	e7be      	b.n	240071ce <I2C_Slave_ISR_DMA+0x106>
  __HAL_LOCK(hi2c);
24007250:	2002      	movs	r0, #2
24007252:	e7bf      	b.n	240071d4 <I2C_Slave_ISR_DMA+0x10c>
24007254:	40020010 	.word	0x40020010

24007258 <I2C_Slave_ISR_IT>:
{
24007258:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  __HAL_LOCK(hi2c);
2400725a:	f890 3040 	ldrb.w	r3, [r0, #64]	@ 0x40
{
2400725e:	4604      	mov	r4, r0
24007260:	460d      	mov	r5, r1
24007262:	4616      	mov	r6, r2
  __HAL_LOCK(hi2c);
24007264:	2b01      	cmp	r3, #1
  uint32_t tmpoptions = hi2c->XferOptions;
24007266:	6ac7      	ldr	r7, [r0, #44]	@ 0x2c
  __HAL_LOCK(hi2c);
24007268:	d07d      	beq.n	24007366 <I2C_Slave_ISR_IT+0x10e>
2400726a:	2301      	movs	r3, #1
  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_STOPF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_STOPI) != RESET))
2400726c:	068a      	lsls	r2, r1, #26
  __HAL_LOCK(hi2c);
2400726e:	f880 3040 	strb.w	r3, [r0, #64]	@ 0x40
  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_STOPF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_STOPI) != RESET))
24007272:	d503      	bpl.n	2400727c <I2C_Slave_ISR_IT+0x24>
24007274:	06b3      	lsls	r3, r6, #26
24007276:	d501      	bpl.n	2400727c <I2C_Slave_ISR_IT+0x24>
    I2C_ITSlaveCplt(hi2c, tmpITFlags);
24007278:	f7ff fe6d 	bl	24006f56 <I2C_ITSlaveCplt.constprop.0>
  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_AF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))
2400727c:	06e8      	lsls	r0, r5, #27
2400727e:	d533      	bpl.n	240072e8 <I2C_Slave_ISR_IT+0x90>
24007280:	06f1      	lsls	r1, r6, #27
24007282:	d531      	bpl.n	240072e8 <I2C_Slave_ISR_IT+0x90>
    if (hi2c->XferCount == 0U)
24007284:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
24007286:	b29b      	uxth	r3, r3
24007288:	b9fb      	cbnz	r3, 240072ca <I2C_Slave_ISR_IT+0x72>
      if ((hi2c->State == HAL_I2C_STATE_LISTEN) && (tmpoptions == I2C_FIRST_AND_LAST_FRAME)) /* Same action must be done for (tmpoptions == I2C_LAST_FRAME) which removed for Warning[Pa134]: left and right operands are identical */
2400728a:	f894 3041 	ldrb.w	r3, [r4, #65]	@ 0x41
2400728e:	2b28      	cmp	r3, #40	@ 0x28
24007290:	d10a      	bne.n	240072a8 <I2C_Slave_ISR_IT+0x50>
24007292:	f1b7 7f00 	cmp.w	r7, #33554432	@ 0x2000000
24007296:	d107      	bne.n	240072a8 <I2C_Slave_ISR_IT+0x50>
        I2C_ITListenCplt(hi2c, tmpITFlags);
24007298:	4629      	mov	r1, r5
2400729a:	4620      	mov	r0, r4
2400729c:	f7ff fb2a 	bl	240068f4 <I2C_ITListenCplt>
  __HAL_UNLOCK(hi2c);
240072a0:	2000      	movs	r0, #0
240072a2:	f884 0040 	strb.w	r0, [r4, #64]	@ 0x40
}
240072a6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      else if ((hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN) && (tmpoptions != I2C_NO_OPTION_FRAME))
240072a8:	f894 2041 	ldrb.w	r2, [r4, #65]	@ 0x41
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
240072ac:	6823      	ldr	r3, [r4, #0]
      else if ((hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN) && (tmpoptions != I2C_NO_OPTION_FRAME))
240072ae:	2a29      	cmp	r2, #41	@ 0x29
240072b0:	f04f 0210 	mov.w	r2, #16
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
240072b4:	61da      	str	r2, [r3, #28]
      else if ((hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN) && (tmpoptions != I2C_NO_OPTION_FRAME))
240072b6:	d1f3      	bne.n	240072a0 <I2C_Slave_ISR_IT+0x48>
240072b8:	f517 3f80 	cmn.w	r7, #65536	@ 0x10000
240072bc:	d0f0      	beq.n	240072a0 <I2C_Slave_ISR_IT+0x48>
        I2C_Flush_TXDR(hi2c);
240072be:	4620      	mov	r0, r4
240072c0:	f7fd fa06 	bl	240046d0 <I2C_Flush_TXDR>
      I2C_ITSlaveSeqCplt(hi2c);
240072c4:	f7ff fa47 	bl	24006756 <I2C_ITSlaveSeqCplt>
240072c8:	e7ea      	b.n	240072a0 <I2C_Slave_ISR_IT+0x48>
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
240072ca:	6823      	ldr	r3, [r4, #0]
240072cc:	2210      	movs	r2, #16
240072ce:	61da      	str	r2, [r3, #28]
      hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
240072d0:	6c63      	ldr	r3, [r4, #68]	@ 0x44
240072d2:	f043 0304 	orr.w	r3, r3, #4
240072d6:	6463      	str	r3, [r4, #68]	@ 0x44
      if ((tmpoptions == I2C_FIRST_FRAME) || (tmpoptions == I2C_NEXT_FRAME))
240072d8:	f037 7380 	bics.w	r3, r7, #16777216	@ 0x1000000
240072dc:	d1e0      	bne.n	240072a0 <I2C_Slave_ISR_IT+0x48>
        I2C_ITError(hi2c, hi2c->ErrorCode);
240072de:	6c61      	ldr	r1, [r4, #68]	@ 0x44
240072e0:	4620      	mov	r0, r4
240072e2:	f7ff fb51 	bl	24006988 <I2C_ITError>
240072e6:	e7db      	b.n	240072a0 <I2C_Slave_ISR_IT+0x48>
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_RXI) != RESET))
240072e8:	076a      	lsls	r2, r5, #29
240072ea:	d51b      	bpl.n	24007324 <I2C_Slave_ISR_IT+0xcc>
240072ec:	0773      	lsls	r3, r6, #29
240072ee:	d519      	bpl.n	24007324 <I2C_Slave_ISR_IT+0xcc>
    if (hi2c->XferCount > 0U)
240072f0:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
240072f2:	b29b      	uxth	r3, r3
240072f4:	b16b      	cbz	r3, 24007312 <I2C_Slave_ISR_IT+0xba>
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
240072f6:	6823      	ldr	r3, [r4, #0]
240072f8:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
240072fa:	6a63      	ldr	r3, [r4, #36]	@ 0x24
240072fc:	701a      	strb	r2, [r3, #0]
      hi2c->pBuffPtr++;
240072fe:	6a63      	ldr	r3, [r4, #36]	@ 0x24
24007300:	3301      	adds	r3, #1
24007302:	6263      	str	r3, [r4, #36]	@ 0x24
      hi2c->XferSize--;
24007304:	8d23      	ldrh	r3, [r4, #40]	@ 0x28
24007306:	3b01      	subs	r3, #1
24007308:	8523      	strh	r3, [r4, #40]	@ 0x28
      hi2c->XferCount--;
2400730a:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
2400730c:	3b01      	subs	r3, #1
2400730e:	b29b      	uxth	r3, r3
24007310:	8563      	strh	r3, [r4, #42]	@ 0x2a
    if ((hi2c->XferCount == 0U) && \
24007312:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
24007314:	b29b      	uxth	r3, r3
24007316:	2b00      	cmp	r3, #0
24007318:	d1c2      	bne.n	240072a0 <I2C_Slave_ISR_IT+0x48>
2400731a:	f517 3f80 	cmn.w	r7, #65536	@ 0x10000
2400731e:	d0bf      	beq.n	240072a0 <I2C_Slave_ISR_IT+0x48>
      I2C_ITSlaveSeqCplt(hi2c);
24007320:	4620      	mov	r0, r4
24007322:	e7cf      	b.n	240072c4 <I2C_Slave_ISR_IT+0x6c>
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_ADDR) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_ADDRI) != RESET))
24007324:	0728      	lsls	r0, r5, #28
24007326:	d505      	bpl.n	24007334 <I2C_Slave_ISR_IT+0xdc>
24007328:	0731      	lsls	r1, r6, #28
2400732a:	d503      	bpl.n	24007334 <I2C_Slave_ISR_IT+0xdc>
    I2C_ITAddrCplt(hi2c, tmpITFlags);
2400732c:	4620      	mov	r0, r4
2400732e:	f7ff fa9c 	bl	2400686a <I2C_ITAddrCplt.constprop.0>
24007332:	e7b5      	b.n	240072a0 <I2C_Slave_ISR_IT+0x48>
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TXIS) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TXI) != RESET))
24007334:	07aa      	lsls	r2, r5, #30
24007336:	d5b3      	bpl.n	240072a0 <I2C_Slave_ISR_IT+0x48>
24007338:	07b3      	lsls	r3, r6, #30
2400733a:	d5b1      	bpl.n	240072a0 <I2C_Slave_ISR_IT+0x48>
    if (hi2c->XferCount > 0U)
2400733c:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
2400733e:	b29b      	uxth	r3, r3
24007340:	b16b      	cbz	r3, 2400735e <I2C_Slave_ISR_IT+0x106>
      hi2c->Instance->TXDR = *hi2c->pBuffPtr;
24007342:	6a63      	ldr	r3, [r4, #36]	@ 0x24
24007344:	6822      	ldr	r2, [r4, #0]
24007346:	f813 1b01 	ldrb.w	r1, [r3], #1
2400734a:	6291      	str	r1, [r2, #40]	@ 0x28
      hi2c->pBuffPtr++;
2400734c:	6263      	str	r3, [r4, #36]	@ 0x24
      hi2c->XferCount--;
2400734e:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
24007350:	3b01      	subs	r3, #1
24007352:	b29b      	uxth	r3, r3
24007354:	8563      	strh	r3, [r4, #42]	@ 0x2a
      hi2c->XferSize--;
24007356:	8d23      	ldrh	r3, [r4, #40]	@ 0x28
24007358:	3b01      	subs	r3, #1
2400735a:	8523      	strh	r3, [r4, #40]	@ 0x28
2400735c:	e7a0      	b.n	240072a0 <I2C_Slave_ISR_IT+0x48>
      if ((tmpoptions == I2C_NEXT_FRAME) || (tmpoptions == I2C_FIRST_FRAME))
2400735e:	f037 7380 	bics.w	r3, r7, #16777216	@ 0x1000000
24007362:	d19d      	bne.n	240072a0 <I2C_Slave_ISR_IT+0x48>
24007364:	e7dc      	b.n	24007320 <I2C_Slave_ISR_IT+0xc8>
  __HAL_LOCK(hi2c);
24007366:	2002      	movs	r0, #2
24007368:	e79d      	b.n	240072a6 <I2C_Slave_ISR_IT+0x4e>

2400736a <I2C_DMAAbort>:
  I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
2400736a:	6b80      	ldr	r0, [r0, #56]	@ 0x38
  if (hi2c->hdmatx != NULL)
2400736c:	6b83      	ldr	r3, [r0, #56]	@ 0x38
2400736e:	b10b      	cbz	r3, 24007374 <I2C_DMAAbort+0xa>
    hi2c->hdmatx->XferAbortCallback = NULL;
24007370:	2200      	movs	r2, #0
24007372:	651a      	str	r2, [r3, #80]	@ 0x50
  if (hi2c->hdmarx != NULL)
24007374:	6bc3      	ldr	r3, [r0, #60]	@ 0x3c
24007376:	b10b      	cbz	r3, 2400737c <I2C_DMAAbort+0x12>
    hi2c->hdmarx->XferAbortCallback = NULL;
24007378:	2200      	movs	r2, #0
2400737a:	651a      	str	r2, [r3, #80]	@ 0x50
  I2C_TreatErrorCallback(hi2c);
2400737c:	f7ff baee 	b.w	2400695c <I2C_TreatErrorCallback>

24007380 <HAL_I2C_GetState>:
  return hi2c->State;
24007380:	f890 0041 	ldrb.w	r0, [r0, #65]	@ 0x41
}
24007384:	4770      	bx	lr

24007386 <HAL_I2C_GetMode>:
  return hi2c->Mode;
24007386:	f890 0042 	ldrb.w	r0, [r0, #66]	@ 0x42
}
2400738a:	4770      	bx	lr

2400738c <HAL_I2C_GetError>:
  return hi2c->ErrorCode;
2400738c:	6c40      	ldr	r0, [r0, #68]	@ 0x44
}
2400738e:	4770      	bx	lr

24007390 <HAL_I2CEx_ConfigAnalogFilter>:
  *                the configuration information for the specified I2Cx peripheral.
  * @param  AnalogFilter New state of the Analog filter.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2CEx_ConfigAnalogFilter(I2C_HandleTypeDef *hi2c, uint32_t AnalogFilter)
{
24007390:	b510      	push	{r4, lr}
  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_I2C_ANALOG_FILTER(AnalogFilter));

  if (hi2c->State == HAL_I2C_STATE_READY)
24007392:	f890 2041 	ldrb.w	r2, [r0, #65]	@ 0x41
{
24007396:	4603      	mov	r3, r0
  if (hi2c->State == HAL_I2C_STATE_READY)
24007398:	2a20      	cmp	r2, #32
2400739a:	b2d4      	uxtb	r4, r2
2400739c:	d11c      	bne.n	240073d8 <HAL_I2CEx_ConfigAnalogFilter+0x48>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
2400739e:	f890 2040 	ldrb.w	r2, [r0, #64]	@ 0x40
240073a2:	2a01      	cmp	r2, #1
240073a4:	d018      	beq.n	240073d8 <HAL_I2CEx_ConfigAnalogFilter+0x48>

    hi2c->State = HAL_I2C_STATE_BUSY;
240073a6:	2224      	movs	r2, #36	@ 0x24
240073a8:	f880 2041 	strb.w	r2, [r0, #65]	@ 0x41

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
240073ac:	6802      	ldr	r2, [r0, #0]
240073ae:	6810      	ldr	r0, [r2, #0]
240073b0:	f020 0001 	bic.w	r0, r0, #1
240073b4:	6010      	str	r0, [r2, #0]

    /* Reset I2Cx ANOFF bit */
    hi2c->Instance->CR1 &= ~(I2C_CR1_ANFOFF);
240073b6:	6810      	ldr	r0, [r2, #0]
240073b8:	f420 5080 	bic.w	r0, r0, #4096	@ 0x1000
240073bc:	6010      	str	r0, [r2, #0]

    /* Set analog filter bit*/
    hi2c->Instance->CR1 |= AnalogFilter;
240073be:	6810      	ldr	r0, [r2, #0]
240073c0:	4301      	orrs	r1, r0
    __HAL_I2C_ENABLE(hi2c);

    hi2c->State = HAL_I2C_STATE_READY;

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
240073c2:	2000      	movs	r0, #0
    hi2c->Instance->CR1 |= AnalogFilter;
240073c4:	6011      	str	r1, [r2, #0]
    __HAL_I2C_ENABLE(hi2c);
240073c6:	6811      	ldr	r1, [r2, #0]
240073c8:	f041 0101 	orr.w	r1, r1, #1
240073cc:	6011      	str	r1, [r2, #0]
    hi2c->State = HAL_I2C_STATE_READY;
240073ce:	f883 4041 	strb.w	r4, [r3, #65]	@ 0x41
    __HAL_UNLOCK(hi2c);
240073d2:	f883 0040 	strb.w	r0, [r3, #64]	@ 0x40
  }
  else
  {
    return HAL_BUSY;
  }
}
240073d6:	bd10      	pop	{r4, pc}
    __HAL_LOCK(hi2c);
240073d8:	2002      	movs	r0, #2
240073da:	e7fc      	b.n	240073d6 <HAL_I2CEx_ConfigAnalogFilter+0x46>

240073dc <HAL_I2CEx_ConfigDigitalFilter>:
  *                the configuration information for the specified I2Cx peripheral.
  * @param  DigitalFilter Coefficient of digital noise filter between Min_Data=0x00 and Max_Data=0x0F.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2CEx_ConfigDigitalFilter(I2C_HandleTypeDef *hi2c, uint32_t DigitalFilter)
{
240073dc:	b510      	push	{r4, lr}

  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_I2C_DIGITAL_FILTER(DigitalFilter));

  if (hi2c->State == HAL_I2C_STATE_READY)
240073de:	f890 2041 	ldrb.w	r2, [r0, #65]	@ 0x41
{
240073e2:	4603      	mov	r3, r0
  if (hi2c->State == HAL_I2C_STATE_READY)
240073e4:	2a20      	cmp	r2, #32
240073e6:	b2d4      	uxtb	r4, r2
240073e8:	d11b      	bne.n	24007422 <HAL_I2CEx_ConfigDigitalFilter+0x46>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
240073ea:	f890 2040 	ldrb.w	r2, [r0, #64]	@ 0x40
240073ee:	2a01      	cmp	r2, #1
240073f0:	d017      	beq.n	24007422 <HAL_I2CEx_ConfigDigitalFilter+0x46>

    hi2c->State = HAL_I2C_STATE_BUSY;
240073f2:	2224      	movs	r2, #36	@ 0x24
240073f4:	f880 2041 	strb.w	r2, [r0, #65]	@ 0x41

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
240073f8:	6802      	ldr	r2, [r0, #0]
240073fa:	6810      	ldr	r0, [r2, #0]
240073fc:	f020 0001 	bic.w	r0, r0, #1
24007400:	6010      	str	r0, [r2, #0]

    /* Get the old register value */
    tmpreg = hi2c->Instance->CR1;
24007402:	6810      	ldr	r0, [r2, #0]

    /* Reset I2Cx DNF bits [11:8] */
    tmpreg &= ~(I2C_CR1_DNF);
24007404:	f420 6070 	bic.w	r0, r0, #3840	@ 0xf00

    /* Set I2Cx DNF coefficient */
    tmpreg |= DigitalFilter << 8U;
24007408:	ea40 2101 	orr.w	r1, r0, r1, lsl #8
    __HAL_I2C_ENABLE(hi2c);

    hi2c->State = HAL_I2C_STATE_READY;

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2400740c:	2000      	movs	r0, #0
    hi2c->Instance->CR1 = tmpreg;
2400740e:	6011      	str	r1, [r2, #0]
    __HAL_I2C_ENABLE(hi2c);
24007410:	6811      	ldr	r1, [r2, #0]
24007412:	f041 0101 	orr.w	r1, r1, #1
24007416:	6011      	str	r1, [r2, #0]
    hi2c->State = HAL_I2C_STATE_READY;
24007418:	f883 4041 	strb.w	r4, [r3, #65]	@ 0x41
    __HAL_UNLOCK(hi2c);
2400741c:	f883 0040 	strb.w	r0, [r3, #64]	@ 0x40
  }
  else
  {
    return HAL_BUSY;
  }
}
24007420:	bd10      	pop	{r4, pc}
    __HAL_LOCK(hi2c);
24007422:	2002      	movs	r0, #2
24007424:	e7fc      	b.n	24007420 <HAL_I2CEx_ConfigDigitalFilter+0x44>

24007426 <HAL_I2CEx_EnableWakeUp>:
HAL_StatusTypeDef HAL_I2CEx_EnableWakeUp(I2C_HandleTypeDef *hi2c)
{
  /* Check the parameters */
  assert_param(IS_I2C_WAKEUP_FROMSTOP_INSTANCE(hi2c->Instance));

  if (hi2c->State == HAL_I2C_STATE_READY)
24007426:	f890 3041 	ldrb.w	r3, [r0, #65]	@ 0x41
2400742a:	2b20      	cmp	r3, #32
2400742c:	b2d9      	uxtb	r1, r3
2400742e:	d11a      	bne.n	24007466 <HAL_I2CEx_EnableWakeUp+0x40>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
24007430:	f890 3040 	ldrb.w	r3, [r0, #64]	@ 0x40
24007434:	2b01      	cmp	r3, #1
24007436:	d016      	beq.n	24007466 <HAL_I2CEx_EnableWakeUp+0x40>

    hi2c->State = HAL_I2C_STATE_BUSY;
24007438:	2324      	movs	r3, #36	@ 0x24
2400743a:	f880 3041 	strb.w	r3, [r0, #65]	@ 0x41

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
2400743e:	6803      	ldr	r3, [r0, #0]
24007440:	681a      	ldr	r2, [r3, #0]
24007442:	f022 0201 	bic.w	r2, r2, #1
24007446:	601a      	str	r2, [r3, #0]

    /* Enable wakeup from stop mode */
    hi2c->Instance->CR1 |= I2C_CR1_WUPEN;
24007448:	681a      	ldr	r2, [r3, #0]
2400744a:	f442 2280 	orr.w	r2, r2, #262144	@ 0x40000
2400744e:	601a      	str	r2, [r3, #0]

    __HAL_I2C_ENABLE(hi2c);
24007450:	681a      	ldr	r2, [r3, #0]
24007452:	f042 0201 	orr.w	r2, r2, #1
24007456:	601a      	str	r2, [r3, #0]

    hi2c->State = HAL_I2C_STATE_READY;

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
24007458:	2300      	movs	r3, #0
    hi2c->State = HAL_I2C_STATE_READY;
2400745a:	f880 1041 	strb.w	r1, [r0, #65]	@ 0x41
    __HAL_UNLOCK(hi2c);
2400745e:	f880 3040 	strb.w	r3, [r0, #64]	@ 0x40

    return HAL_OK;
24007462:	4618      	mov	r0, r3
24007464:	4770      	bx	lr
    __HAL_LOCK(hi2c);
24007466:	2002      	movs	r0, #2
  }
  else
  {
    return HAL_BUSY;
  }
}
24007468:	4770      	bx	lr

2400746a <HAL_I2CEx_DisableWakeUp>:
HAL_StatusTypeDef HAL_I2CEx_DisableWakeUp(I2C_HandleTypeDef *hi2c)
{
  /* Check the parameters */
  assert_param(IS_I2C_WAKEUP_FROMSTOP_INSTANCE(hi2c->Instance));

  if (hi2c->State == HAL_I2C_STATE_READY)
2400746a:	f890 3041 	ldrb.w	r3, [r0, #65]	@ 0x41
2400746e:	2b20      	cmp	r3, #32
24007470:	b2d9      	uxtb	r1, r3
24007472:	d11a      	bne.n	240074aa <HAL_I2CEx_DisableWakeUp+0x40>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
24007474:	f890 3040 	ldrb.w	r3, [r0, #64]	@ 0x40
24007478:	2b01      	cmp	r3, #1
2400747a:	d016      	beq.n	240074aa <HAL_I2CEx_DisableWakeUp+0x40>

    hi2c->State = HAL_I2C_STATE_BUSY;
2400747c:	2324      	movs	r3, #36	@ 0x24
2400747e:	f880 3041 	strb.w	r3, [r0, #65]	@ 0x41

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
24007482:	6803      	ldr	r3, [r0, #0]
24007484:	681a      	ldr	r2, [r3, #0]
24007486:	f022 0201 	bic.w	r2, r2, #1
2400748a:	601a      	str	r2, [r3, #0]

    /* Enable wakeup from stop mode */
    hi2c->Instance->CR1 &= ~(I2C_CR1_WUPEN);
2400748c:	681a      	ldr	r2, [r3, #0]
2400748e:	f422 2280 	bic.w	r2, r2, #262144	@ 0x40000
24007492:	601a      	str	r2, [r3, #0]

    __HAL_I2C_ENABLE(hi2c);
24007494:	681a      	ldr	r2, [r3, #0]
24007496:	f042 0201 	orr.w	r2, r2, #1
2400749a:	601a      	str	r2, [r3, #0]

    hi2c->State = HAL_I2C_STATE_READY;

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2400749c:	2300      	movs	r3, #0
    hi2c->State = HAL_I2C_STATE_READY;
2400749e:	f880 1041 	strb.w	r1, [r0, #65]	@ 0x41
    __HAL_UNLOCK(hi2c);
240074a2:	f880 3040 	strb.w	r3, [r0, #64]	@ 0x40

    return HAL_OK;
240074a6:	4618      	mov	r0, r3
240074a8:	4770      	bx	lr
    __HAL_LOCK(hi2c);
240074aa:	2002      	movs	r0, #2
  }
  else
  {
    return HAL_BUSY;
  }
}
240074ac:	4770      	bx	lr

240074ae <HAL_I2CEx_EnableFastModePlus>:
{
  /* Check the parameter */
  assert_param(IS_I2C_FASTMODEPLUS(ConfigFastModePlus));

  /* Enable SYSCFG clock */
  __HAL_RCC_SYSCFG_CLK_ENABLE();
240074ae:	4b0a      	ldr	r3, [pc, #40]	@ (240074d8 <HAL_I2CEx_EnableFastModePlus+0x2a>)
{
240074b0:	b082      	sub	sp, #8
  __HAL_RCC_SYSCFG_CLK_ENABLE();
240074b2:	f8d3 20f4 	ldr.w	r2, [r3, #244]	@ 0xf4
240074b6:	f042 0202 	orr.w	r2, r2, #2
240074ba:	f8c3 20f4 	str.w	r2, [r3, #244]	@ 0xf4
240074be:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4

  /* Enable fast mode plus driving capability for selected pin */
  SET_BIT(SYSCFG->PMCR, (uint32_t)ConfigFastModePlus);
240074c2:	4a06      	ldr	r2, [pc, #24]	@ (240074dc <HAL_I2CEx_EnableFastModePlus+0x2e>)
  __HAL_RCC_SYSCFG_CLK_ENABLE();
240074c4:	f003 0302 	and.w	r3, r3, #2
240074c8:	9301      	str	r3, [sp, #4]
240074ca:	9b01      	ldr	r3, [sp, #4]
  SET_BIT(SYSCFG->PMCR, (uint32_t)ConfigFastModePlus);
240074cc:	6853      	ldr	r3, [r2, #4]
240074ce:	4303      	orrs	r3, r0
240074d0:	6053      	str	r3, [r2, #4]
}
240074d2:	b002      	add	sp, #8
240074d4:	4770      	bx	lr
240074d6:	bf00      	nop
240074d8:	58024400 	.word	0x58024400
240074dc:	58000400 	.word	0x58000400

240074e0 <HAL_I2CEx_DisableFastModePlus>:
{
  /* Check the parameter */
  assert_param(IS_I2C_FASTMODEPLUS(ConfigFastModePlus));

  /* Enable SYSCFG clock */
  __HAL_RCC_SYSCFG_CLK_ENABLE();
240074e0:	4b0a      	ldr	r3, [pc, #40]	@ (2400750c <HAL_I2CEx_DisableFastModePlus+0x2c>)
{
240074e2:	b082      	sub	sp, #8
  __HAL_RCC_SYSCFG_CLK_ENABLE();
240074e4:	f8d3 20f4 	ldr.w	r2, [r3, #244]	@ 0xf4
240074e8:	f042 0202 	orr.w	r2, r2, #2
240074ec:	f8c3 20f4 	str.w	r2, [r3, #244]	@ 0xf4
240074f0:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4

  /* Disable fast mode plus driving capability for selected pin */
  CLEAR_BIT(SYSCFG->PMCR, (uint32_t)ConfigFastModePlus);
240074f4:	4a06      	ldr	r2, [pc, #24]	@ (24007510 <HAL_I2CEx_DisableFastModePlus+0x30>)
  __HAL_RCC_SYSCFG_CLK_ENABLE();
240074f6:	f003 0302 	and.w	r3, r3, #2
240074fa:	9301      	str	r3, [sp, #4]
240074fc:	9b01      	ldr	r3, [sp, #4]
  CLEAR_BIT(SYSCFG->PMCR, (uint32_t)ConfigFastModePlus);
240074fe:	6853      	ldr	r3, [r2, #4]
24007500:	ea23 0300 	bic.w	r3, r3, r0
24007504:	6053      	str	r3, [r2, #4]
}
24007506:	b002      	add	sp, #8
24007508:	4770      	bx	lr
2400750a:	bf00      	nop
2400750c:	58024400 	.word	0x58024400
24007510:	58000400 	.word	0x58000400

24007514 <MDMA_SetConfig>:
  * @param  BlockDataLength : The length of a block transfer in bytes
  * @param  BlockCount: The number of blocks to be transfered
  * @retval HAL status
  */
static void MDMA_SetConfig(MDMA_HandleTypeDef *hmdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t BlockDataLength, uint32_t BlockCount)
{
24007514:	b530      	push	{r4, r5, lr}
  uint32_t addressMask;

  /* Configure the MDMA Channel data length */
  MODIFY_REG(hmdma->Instance->CBNDTR ,MDMA_CBNDTR_BNDT, (BlockDataLength & MDMA_CBNDTR_BNDT));
24007516:	6804      	ldr	r4, [r0, #0]
24007518:	f3c3 0310 	ubfx	r3, r3, #0, #17

  /* Configure MDMA Channel Source address */
  hmdma->Instance->CSAR = SrcAddress;

  addressMask = SrcAddress & 0xFF000000U;
  if((addressMask == 0x20000000U) || (addressMask == 0x00000000U))
2400751c:	f011 4f5f 	tst.w	r1, #3741319168	@ 0xdf000000
  MODIFY_REG(hmdma->Instance->CBNDTR ,MDMA_CBNDTR_BNDT, (BlockDataLength & MDMA_CBNDTR_BNDT));
24007520:	6965      	ldr	r5, [r4, #20]
24007522:	ea4f 4555 	mov.w	r5, r5, lsr #17
24007526:	ea4f 4545 	mov.w	r5, r5, lsl #17
2400752a:	ea45 0503 	orr.w	r5, r5, r3
2400752e:	6165      	str	r5, [r4, #20]
  MODIFY_REG(hmdma->Instance->CBNDTR , MDMA_CBNDTR_BRC , ((BlockCount - 1U) << MDMA_CBNDTR_BRC_Pos) & MDMA_CBNDTR_BRC);
24007530:	9d03      	ldr	r5, [sp, #12]
24007532:	6963      	ldr	r3, [r4, #20]
24007534:	f105 35ff 	add.w	r5, r5, #4294967295
24007538:	f3c3 0313 	ubfx	r3, r3, #0, #20
2400753c:	ea43 5305 	orr.w	r3, r3, r5, lsl #20
24007540:	6163      	str	r3, [r4, #20]
  __HAL_MDMA_CLEAR_FLAG(hmdma, MDMA_FLAG_TE | MDMA_FLAG_CTC | MDMA_CISR_BRTIF | MDMA_CISR_BTIF | MDMA_CISR_TCIF);
24007542:	f04f 031f 	mov.w	r3, #31
24007546:	6063      	str	r3, [r4, #4]
  hmdma->Instance->CDAR = DstAddress;
24007548:	61e2      	str	r2, [r4, #28]
  hmdma->Instance->CSAR = SrcAddress;
2400754a:	61a1      	str	r1, [r4, #24]
  {
    /*The AHBSbus is used as source (read operation) on channel x */
    hmdma->Instance->CTBR |= MDMA_CTBR_SBUS;
2400754c:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
2400754e:	bf0c      	ite	eq
24007550:	f443 3380 	orreq.w	r3, r3, #65536	@ 0x10000
  }
  else
  {
    /*The AXI bus is used as source (read operation) on channel x */
    hmdma->Instance->CTBR &= (~MDMA_CTBR_SBUS);
24007554:	f423 3380 	bicne.w	r3, r3, #65536	@ 0x10000
  }

  addressMask = DstAddress & 0xFF000000U;
  if((addressMask == 0x20000000U) || (addressMask == 0x00000000U))
24007558:	f012 4f5f 	tst.w	r2, #3741319168	@ 0xdf000000
    hmdma->Instance->CTBR &= (~MDMA_CTBR_SBUS);
2400755c:	62a3      	str	r3, [r4, #40]	@ 0x28
  {
    /*The AHB bus is used as destination (write operation) on channel x */
    hmdma->Instance->CTBR |= MDMA_CTBR_DBUS;
2400755e:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
24007560:	bf0c      	ite	eq
24007562:	f443 3300 	orreq.w	r3, r3, #131072	@ 0x20000
  }
  else
  {
    /*The AXI bus is used as destination (write operation) on channel x */
    hmdma->Instance->CTBR &= (~MDMA_CTBR_DBUS);
24007566:	f423 3300 	bicne.w	r3, r3, #131072	@ 0x20000
2400756a:	62a3      	str	r3, [r4, #40]	@ 0x28
  }

  /* Set the linked list register to the first node of the list */
  hmdma->Instance->CLAR = (uint32_t)hmdma->FirstLinkedListNodeAddress;
2400756c:	6dc3      	ldr	r3, [r0, #92]	@ 0x5c
2400756e:	6263      	str	r3, [r4, #36]	@ 0x24
}
24007570:	bd30      	pop	{r4, r5, pc}

24007572 <HAL_MDMA_Init>:
{
24007572:	b538      	push	{r3, r4, r5, lr}
24007574:	4604      	mov	r4, r0
  uint32_t tickstart = HAL_GetTick();
24007576:	f00a fc47 	bl	24011e08 <HAL_GetTick>
2400757a:	4605      	mov	r5, r0
  if(hmdma == NULL)
2400757c:	2c00      	cmp	r4, #0
2400757e:	d061      	beq.n	24007644 <HAL_MDMA_Init+0xd2>
  __HAL_UNLOCK(hmdma);
24007580:	2300      	movs	r3, #0
  __HAL_MDMA_DISABLE(hmdma);
24007582:	6822      	ldr	r2, [r4, #0]
  __HAL_UNLOCK(hmdma);
24007584:	f884 303c 	strb.w	r3, [r4, #60]	@ 0x3c
  hmdma->State = HAL_MDMA_STATE_BUSY;
24007588:	2302      	movs	r3, #2
2400758a:	f884 303d 	strb.w	r3, [r4, #61]	@ 0x3d
  __HAL_MDMA_DISABLE(hmdma);
2400758e:	68d3      	ldr	r3, [r2, #12]
24007590:	f023 0301 	bic.w	r3, r3, #1
24007594:	60d3      	str	r3, [r2, #12]
  while((hmdma->Instance->CCR & MDMA_CCR_EN) != 0U)
24007596:	6823      	ldr	r3, [r4, #0]
24007598:	68da      	ldr	r2, [r3, #12]
2400759a:	07d2      	lsls	r2, r2, #31
2400759c:	d448      	bmi.n	24007630 <HAL_MDMA_Init+0xbe>
static void MDMA_Init(MDMA_HandleTypeDef *hmdma)
{
  uint32_t blockoffset;

  /* Prepare the MDMA Channel configuration */
  hmdma->Instance->CCR = hmdma->Init.Priority  | hmdma->Init.Endianness;
2400759e:	e9d4 2103 	ldrd	r2, r1, [r4, #12]
240075a2:	430a      	orrs	r2, r1
240075a4:	60da      	str	r2, [r3, #12]
  /* Write new CTCR Register value */
  hmdma->Instance->CTCR =  hmdma->Init.SourceInc      | hmdma->Init.DestinationInc | \
                           hmdma->Init.SourceDataSize | hmdma->Init.DestDataSize   | \
                           hmdma->Init.DataAlignment  | hmdma->Init.SourceBurst    | \
                           hmdma->Init.DestBurst                                   | \
                           ((hmdma->Init.BufferTransferLength - 1U) << MDMA_CTCR_TLEN_Pos) | \
240075a6:	e9d4 2105 	ldrd	r2, r1, [r4, #20]
240075aa:	430a      	orrs	r2, r1
240075ac:	69e1      	ldr	r1, [r4, #28]
240075ae:	430a      	orrs	r2, r1
240075b0:	6a21      	ldr	r1, [r4, #32]
240075b2:	430a      	orrs	r2, r1
240075b4:	6a61      	ldr	r1, [r4, #36]	@ 0x24
240075b6:	430a      	orrs	r2, r1
240075b8:	6ae1      	ldr	r1, [r4, #44]	@ 0x2c
240075ba:	430a      	orrs	r2, r1
240075bc:	6b21      	ldr	r1, [r4, #48]	@ 0x30
240075be:	430a      	orrs	r2, r1
240075c0:	68a1      	ldr	r1, [r4, #8]
240075c2:	430a      	orrs	r2, r1
240075c4:	6aa1      	ldr	r1, [r4, #40]	@ 0x28
240075c6:	3901      	subs	r1, #1
240075c8:	ea42 4281 	orr.w	r2, r2, r1, lsl #18
                           hmdma->Init.TransferTriggerMode;

  /* If SW request set the CTCR register to SW Request Mode */
  if(hmdma->Init.Request == MDMA_REQUEST_SW)
240075cc:	6861      	ldr	r1, [r4, #4]
240075ce:	f1b1 4f80 	cmp.w	r1, #1073741824	@ 0x40000000
  hmdma->Instance->CTCR =  hmdma->Init.SourceInc      | hmdma->Init.DestinationInc | \
240075d2:	611a      	str	r2, [r3, #16]
  if(hmdma->Init.Request == MDMA_REQUEST_SW)
240075d4:	d103      	bne.n	240075de <HAL_MDMA_Init+0x6c>
    -If the request is done by SW : BWM could be set to 1 or 0.
    -If the request is done by a peripheral :
    If mask address not set (0) => BWM must be set to 0
    If mask address set (different than 0) => BWM could be set to 1 or 0
    */
    hmdma->Instance->CTCR |= (MDMA_CTCR_SWRM | MDMA_CTCR_BWM);
240075d6:	691a      	ldr	r2, [r3, #16]
240075d8:	f042 4240 	orr.w	r2, r2, #3221225472	@ 0xc0000000
240075dc:	611a      	str	r2, [r3, #16]
  }

  /* Reset CBNDTR Register */
  hmdma->Instance->CBNDTR = 0;
240075de:	2200      	movs	r2, #0
240075e0:	615a      	str	r2, [r3, #20]

  /* if block source address offset is negative set the Block Repeat Source address Update Mode to decrement */
  if(hmdma->Init.SourceBlockAddressOffset < 0)
240075e2:	6b62      	ldr	r2, [r4, #52]	@ 0x34
240075e4:	2a00      	cmp	r2, #0
240075e6:	da04      	bge.n	240075f2 <HAL_MDMA_Init+0x80>
  {
    hmdma->Instance->CBNDTR |= MDMA_CBNDTR_BRSUM;
240075e8:	6958      	ldr	r0, [r3, #20]
    /* Write new CBRUR Register value : source repeat block offset */
    blockoffset = (uint32_t)(- hmdma->Init.SourceBlockAddressOffset);
240075ea:	4252      	negs	r2, r2
    hmdma->Instance->CBNDTR |= MDMA_CBNDTR_BRSUM;
240075ec:	f440 2080 	orr.w	r0, r0, #262144	@ 0x40000
240075f0:	6158      	str	r0, [r3, #20]
    hmdma->Instance->CBRUR = (blockoffset & 0x0000FFFFU);
  }
  else
  {
    /* Write new CBRUR Register value : source repeat block offset */
    hmdma->Instance->CBRUR = (((uint32_t)hmdma->Init.SourceBlockAddressOffset) & 0x0000FFFFU);
240075f2:	b292      	uxth	r2, r2
240075f4:	621a      	str	r2, [r3, #32]
  }

  /* If block destination address offset is negative set the Block Repeat destination address Update Mode to decrement */
  if(hmdma->Init.DestBlockAddressOffset < 0)
240075f6:	6ba2      	ldr	r2, [r4, #56]	@ 0x38
240075f8:	2a00      	cmp	r2, #0
240075fa:	da25      	bge.n	24007648 <HAL_MDMA_Init+0xd6>
  {
    hmdma->Instance->CBNDTR |= MDMA_CBNDTR_BRDUM;
240075fc:	6958      	ldr	r0, [r3, #20]
    /* Write new CBRUR Register value : destination repeat block offset */
    blockoffset = (uint32_t)(- hmdma->Init.DestBlockAddressOffset);
240075fe:	4252      	negs	r2, r2
    hmdma->Instance->CBNDTR |= MDMA_CBNDTR_BRDUM;
24007600:	f440 2000 	orr.w	r0, r0, #524288	@ 0x80000
24007604:	6158      	str	r0, [r3, #20]
    hmdma->Instance->CBRUR |= ((blockoffset & 0x0000FFFFU) << MDMA_CBRUR_DUV_Pos);
24007606:	6a18      	ldr	r0, [r3, #32]
  }
  else
  {
    /*write new CBRUR Register value : destination repeat block offset */
    hmdma->Instance->CBRUR |= ((((uint32_t)hmdma->Init.DestBlockAddressOffset) & 0x0000FFFFU) << MDMA_CBRUR_DUV_Pos);
24007608:	ea40 4202 	orr.w	r2, r0, r2, lsl #16
  }

  /* if HW request set the HW request and the requet CleraMask and ClearData MaskData, */
  if(hmdma->Init.Request != MDMA_REQUEST_SW)
2400760c:	f1b1 4f80 	cmp.w	r1, #1073741824	@ 0x40000000
    hmdma->Instance->CBRUR |= ((((uint32_t)hmdma->Init.DestBlockAddressOffset) & 0x0000FFFFU) << MDMA_CBRUR_DUV_Pos);
24007610:	621a      	str	r2, [r3, #32]
  if(hmdma->Init.Request != MDMA_REQUEST_SW)
24007612:	f04f 0200 	mov.w	r2, #0
24007616:	d019      	beq.n	2400764c <HAL_MDMA_Init+0xda>
  {
    /* Set the HW request in CTRB register  */
    hmdma->Instance->CTBR = hmdma->Init.Request & MDMA_CTBR_TSEL;
24007618:	b2c9      	uxtb	r1, r1
2400761a:	6299      	str	r1, [r3, #40]	@ 0x28
  {
    hmdma->Instance->CTBR = 0;
  }

  /* Write Link Address Register */
  hmdma->Instance->CLAR =  0;
2400761c:	625a      	str	r2, [r3, #36]	@ 0x24
  hmdma->State = HAL_MDMA_STATE_READY;
2400761e:	2301      	movs	r3, #1
  hmdma->ErrorCode = HAL_MDMA_ERROR_NONE;
24007620:	66a2      	str	r2, [r4, #104]	@ 0x68
  return HAL_OK;
24007622:	2000      	movs	r0, #0
  hmdma->LinkedListNodeCounter  = 0;
24007624:	6662      	str	r2, [r4, #100]	@ 0x64
  hmdma->State = HAL_MDMA_STATE_READY;
24007626:	f884 303d 	strb.w	r3, [r4, #61]	@ 0x3d
  hmdma->LastLinkedListNodeAddress   = 0;
2400762a:	e9c4 2217 	strd	r2, r2, [r4, #92]	@ 0x5c
  return HAL_OK;
2400762e:	e00a      	b.n	24007646 <HAL_MDMA_Init+0xd4>
    if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_MDMA_ABORT)
24007630:	f00a fbea 	bl	24011e08 <HAL_GetTick>
24007634:	1b40      	subs	r0, r0, r5
24007636:	2805      	cmp	r0, #5
24007638:	d9ad      	bls.n	24007596 <HAL_MDMA_Init+0x24>
      hmdma->ErrorCode = HAL_MDMA_ERROR_TIMEOUT;
2400763a:	2340      	movs	r3, #64	@ 0x40
2400763c:	66a3      	str	r3, [r4, #104]	@ 0x68
      hmdma->State = HAL_MDMA_STATE_ERROR;
2400763e:	2303      	movs	r3, #3
24007640:	f884 303d 	strb.w	r3, [r4, #61]	@ 0x3d
    return HAL_ERROR;
24007644:	2001      	movs	r0, #1
}
24007646:	bd38      	pop	{r3, r4, r5, pc}
    hmdma->Instance->CBRUR |= ((((uint32_t)hmdma->Init.DestBlockAddressOffset) & 0x0000FFFFU) << MDMA_CBRUR_DUV_Pos);
24007648:	6a18      	ldr	r0, [r3, #32]
2400764a:	e7dd      	b.n	24007608 <HAL_MDMA_Init+0x96>
    hmdma->Instance->CTBR = 0;
2400764c:	629a      	str	r2, [r3, #40]	@ 0x28
2400764e:	e7e5      	b.n	2400761c <HAL_MDMA_Init+0xaa>

24007650 <HAL_MDMA_DeInit>:
  if(hmdma == NULL)
24007650:	b1d8      	cbz	r0, 2400768a <HAL_MDMA_DeInit+0x3a>
  __HAL_MDMA_DISABLE(hmdma);
24007652:	6802      	ldr	r2, [r0, #0]
  __HAL_MDMA_CLEAR_FLAG(hmdma,(MDMA_FLAG_TE | MDMA_FLAG_CTC | MDMA_FLAG_BRT | MDMA_FLAG_BT | MDMA_FLAG_BFTC));
24007654:	211f      	movs	r1, #31
  __HAL_MDMA_DISABLE(hmdma);
24007656:	68d3      	ldr	r3, [r2, #12]
24007658:	f023 0301 	bic.w	r3, r3, #1
2400765c:	60d3      	str	r3, [r2, #12]
  hmdma->Instance->CCR  = 0;
2400765e:	2300      	movs	r3, #0
24007660:	60d3      	str	r3, [r2, #12]
  hmdma->Instance->CTCR = 0;
24007662:	6113      	str	r3, [r2, #16]
  hmdma->Instance->CBNDTR = 0;
24007664:	6153      	str	r3, [r2, #20]
  hmdma->Instance->CSAR = 0;
24007666:	6193      	str	r3, [r2, #24]
  hmdma->Instance->CDAR = 0;
24007668:	61d3      	str	r3, [r2, #28]
  hmdma->Instance->CBRUR = 0;
2400766a:	6213      	str	r3, [r2, #32]
  hmdma->Instance->CLAR = 0;
2400766c:	6253      	str	r3, [r2, #36]	@ 0x24
  hmdma->Instance->CTBR = 0;
2400766e:	6293      	str	r3, [r2, #40]	@ 0x28
  hmdma->Instance->CMAR = 0;
24007670:	6313      	str	r3, [r2, #48]	@ 0x30
  hmdma->Instance->CMDR = 0;
24007672:	6353      	str	r3, [r2, #52]	@ 0x34
  __HAL_MDMA_CLEAR_FLAG(hmdma,(MDMA_FLAG_TE | MDMA_FLAG_CTC | MDMA_FLAG_BRT | MDMA_FLAG_BT | MDMA_FLAG_BFTC));
24007674:	6051      	str	r1, [r2, #4]
  hmdma->ErrorCode = HAL_MDMA_ERROR_NONE;
24007676:	6683      	str	r3, [r0, #104]	@ 0x68
  hmdma->LinkedListNodeCounter  = 0;
24007678:	6643      	str	r3, [r0, #100]	@ 0x64
  hmdma->State = HAL_MDMA_STATE_RESET;
2400767a:	f880 303d 	strb.w	r3, [r0, #61]	@ 0x3d
  __HAL_UNLOCK(hmdma);
2400767e:	f880 303c 	strb.w	r3, [r0, #60]	@ 0x3c
  hmdma->LastLinkedListNodeAddress   = 0;
24007682:	e9c0 3317 	strd	r3, r3, [r0, #92]	@ 0x5c
  return HAL_OK;
24007686:	4618      	mov	r0, r3
24007688:	4770      	bx	lr
    return HAL_ERROR;
2400768a:	2001      	movs	r0, #1
}
2400768c:	4770      	bx	lr

2400768e <HAL_MDMA_ConfigPostRequestMask>:
  if(hmdma == NULL)
2400768e:	4603      	mov	r3, r0
{
24007690:	b530      	push	{r4, r5, lr}
  if(hmdma == NULL)
24007692:	b300      	cbz	r0, 240076d6 <HAL_MDMA_ConfigPostRequestMask+0x48>
  __HAL_LOCK(hmdma);
24007694:	f890 003c 	ldrb.w	r0, [r0, #60]	@ 0x3c
24007698:	2801      	cmp	r0, #1
2400769a:	d01e      	beq.n	240076da <HAL_MDMA_ConfigPostRequestMask+0x4c>
2400769c:	2401      	movs	r4, #1
  if(HAL_MDMA_STATE_READY == hmdma->State)
2400769e:	f893 503d 	ldrb.w	r5, [r3, #61]	@ 0x3d
240076a2:	42a5      	cmp	r5, r4
240076a4:	b2e8      	uxtb	r0, r5
  __HAL_LOCK(hmdma);
240076a6:	f883 403c 	strb.w	r4, [r3, #60]	@ 0x3c
  if(HAL_MDMA_STATE_READY == hmdma->State)
240076aa:	d112      	bne.n	240076d2 <HAL_MDMA_ConfigPostRequestMask+0x44>
    if((hmdma->Instance->CTCR & MDMA_CTCR_SWRM) == 0U)
240076ac:	681c      	ldr	r4, [r3, #0]
240076ae:	6925      	ldr	r5, [r4, #16]
240076b0:	006d      	lsls	r5, r5, #1
240076b2:	d407      	bmi.n	240076c4 <HAL_MDMA_ConfigPostRequestMask+0x36>
      hmdma->Instance->CMAR = MaskAddress;
240076b4:	6321      	str	r1, [r4, #48]	@ 0x30
      hmdma->Instance->CMDR = MaskData;
240076b6:	6362      	str	r2, [r4, #52]	@ 0x34
        hmdma->Instance->CTCR &=  ~MDMA_CTCR_BWM;
240076b8:	6922      	ldr	r2, [r4, #16]
      if(MaskAddress == 0U)
240076ba:	b939      	cbnz	r1, 240076cc <HAL_MDMA_ConfigPostRequestMask+0x3e>
        hmdma->Instance->CTCR &=  ~MDMA_CTCR_BWM;
240076bc:	f022 4200 	bic.w	r2, r2, #2147483648	@ 0x80000000
  HAL_StatusTypeDef  status = HAL_OK;
240076c0:	2000      	movs	r0, #0
        hmdma->Instance->CTCR &=  ~MDMA_CTCR_BWM;
240076c2:	6122      	str	r2, [r4, #16]
  __HAL_UNLOCK(hmdma);
240076c4:	2200      	movs	r2, #0
240076c6:	f883 203c 	strb.w	r2, [r3, #60]	@ 0x3c
}
240076ca:	bd30      	pop	{r4, r5, pc}
        hmdma->Instance->CTCR |=  MDMA_CTCR_BWM;
240076cc:	f042 4200 	orr.w	r2, r2, #2147483648	@ 0x80000000
240076d0:	e7f6      	b.n	240076c0 <HAL_MDMA_ConfigPostRequestMask+0x32>
      status =  HAL_ERROR;
240076d2:	4620      	mov	r0, r4
240076d4:	e7f6      	b.n	240076c4 <HAL_MDMA_ConfigPostRequestMask+0x36>
    return HAL_ERROR;
240076d6:	2001      	movs	r0, #1
240076d8:	e7f7      	b.n	240076ca <HAL_MDMA_ConfigPostRequestMask+0x3c>
  __HAL_LOCK(hmdma);
240076da:	2002      	movs	r0, #2
240076dc:	e7f5      	b.n	240076ca <HAL_MDMA_ConfigPostRequestMask+0x3c>

240076de <HAL_MDMA_RegisterCallback>:
  if(hmdma == NULL)
240076de:	4603      	mov	r3, r0
240076e0:	b300      	cbz	r0, 24007724 <HAL_MDMA_RegisterCallback+0x46>
  __HAL_LOCK(hmdma);
240076e2:	f890 003c 	ldrb.w	r0, [r0, #60]	@ 0x3c
240076e6:	2801      	cmp	r0, #1
240076e8:	d01e      	beq.n	24007728 <HAL_MDMA_RegisterCallback+0x4a>
  if(HAL_MDMA_STATE_READY == hmdma->State)
240076ea:	f893 003d 	ldrb.w	r0, [r3, #61]	@ 0x3d
240076ee:	2801      	cmp	r0, #1
240076f0:	d116      	bne.n	24007720 <HAL_MDMA_RegisterCallback+0x42>
    switch (CallbackID)
240076f2:	2905      	cmp	r1, #5
240076f4:	d805      	bhi.n	24007702 <HAL_MDMA_RegisterCallback+0x24>
240076f6:	e8df f001 	tbb	[pc, r1]
240076fa:	0903      	.short	0x0903
240076fc:	110f0d0b 	.word	0x110f0d0b
      hmdma->XferCpltCallback = pCallback;
24007700:	645a      	str	r2, [r3, #68]	@ 0x44
  HAL_StatusTypeDef status = HAL_OK;
24007702:	2000      	movs	r0, #0
  __HAL_UNLOCK(hmdma);
24007704:	2200      	movs	r2, #0
24007706:	f883 203c 	strb.w	r2, [r3, #60]	@ 0x3c
  return status;
2400770a:	4770      	bx	lr
      hmdma->XferBufferCpltCallback = pCallback;
2400770c:	649a      	str	r2, [r3, #72]	@ 0x48
      break;
2400770e:	e7f8      	b.n	24007702 <HAL_MDMA_RegisterCallback+0x24>
      hmdma->XferBlockCpltCallback = pCallback;
24007710:	64da      	str	r2, [r3, #76]	@ 0x4c
      break;
24007712:	e7f6      	b.n	24007702 <HAL_MDMA_RegisterCallback+0x24>
      hmdma->XferRepeatBlockCpltCallback = pCallback;
24007714:	651a      	str	r2, [r3, #80]	@ 0x50
      break;
24007716:	e7f4      	b.n	24007702 <HAL_MDMA_RegisterCallback+0x24>
      hmdma->XferErrorCallback = pCallback;
24007718:	655a      	str	r2, [r3, #84]	@ 0x54
      break;
2400771a:	e7f2      	b.n	24007702 <HAL_MDMA_RegisterCallback+0x24>
      hmdma->XferAbortCallback = pCallback;
2400771c:	659a      	str	r2, [r3, #88]	@ 0x58
      break;
2400771e:	e7f0      	b.n	24007702 <HAL_MDMA_RegisterCallback+0x24>
    status =  HAL_ERROR;
24007720:	2001      	movs	r0, #1
24007722:	e7ef      	b.n	24007704 <HAL_MDMA_RegisterCallback+0x26>
    return HAL_ERROR;
24007724:	2001      	movs	r0, #1
24007726:	4770      	bx	lr
  __HAL_LOCK(hmdma);
24007728:	2002      	movs	r0, #2
}
2400772a:	4770      	bx	lr

2400772c <HAL_MDMA_UnRegisterCallback>:
  if(hmdma == NULL)
2400772c:	4603      	mov	r3, r0
{
2400772e:	b510      	push	{r4, lr}
  if(hmdma == NULL)
24007730:	b358      	cbz	r0, 2400778a <HAL_MDMA_UnRegisterCallback+0x5e>
  __HAL_LOCK(hmdma);
24007732:	f890 203c 	ldrb.w	r2, [r0, #60]	@ 0x3c
24007736:	2a01      	cmp	r2, #1
24007738:	d029      	beq.n	2400778e <HAL_MDMA_UnRegisterCallback+0x62>
2400773a:	2201      	movs	r2, #1
  if(HAL_MDMA_STATE_READY == hmdma->State)
2400773c:	f890 403d 	ldrb.w	r4, [r0, #61]	@ 0x3d
24007740:	4294      	cmp	r4, r2
  __HAL_LOCK(hmdma);
24007742:	f880 203c 	strb.w	r2, [r0, #60]	@ 0x3c
  if(HAL_MDMA_STATE_READY == hmdma->State)
24007746:	b2e0      	uxtb	r0, r4
24007748:	d11d      	bne.n	24007786 <HAL_MDMA_UnRegisterCallback+0x5a>
    switch (CallbackID)
2400774a:	2200      	movs	r2, #0
2400774c:	2906      	cmp	r1, #6
2400774e:	d807      	bhi.n	24007760 <HAL_MDMA_UnRegisterCallback+0x34>
24007750:	e8df f001 	tbb	[pc, r1]
24007754:	0e0c0a04 	.word	0x0e0c0a04
24007758:	1710      	.short	0x1710
2400775a:	12          	.byte	0x12
2400775b:	00          	.byte	0x00
      hmdma->XferCpltCallback = NULL;
2400775c:	645a      	str	r2, [r3, #68]	@ 0x44
  HAL_StatusTypeDef status = HAL_OK;
2400775e:	2000      	movs	r0, #0
  __HAL_UNLOCK(hmdma);
24007760:	2200      	movs	r2, #0
24007762:	f883 203c 	strb.w	r2, [r3, #60]	@ 0x3c
}
24007766:	bd10      	pop	{r4, pc}
      hmdma->XferBufferCpltCallback = NULL;
24007768:	649a      	str	r2, [r3, #72]	@ 0x48
      break;
2400776a:	e7f8      	b.n	2400775e <HAL_MDMA_UnRegisterCallback+0x32>
      hmdma->XferBlockCpltCallback = NULL;
2400776c:	64da      	str	r2, [r3, #76]	@ 0x4c
      break;
2400776e:	e7f6      	b.n	2400775e <HAL_MDMA_UnRegisterCallback+0x32>
      hmdma->XferRepeatBlockCpltCallback = NULL;
24007770:	651a      	str	r2, [r3, #80]	@ 0x50
      break;
24007772:	e7f4      	b.n	2400775e <HAL_MDMA_UnRegisterCallback+0x32>
      hmdma->XferErrorCallback = NULL;
24007774:	655a      	str	r2, [r3, #84]	@ 0x54
      break;
24007776:	e7f2      	b.n	2400775e <HAL_MDMA_UnRegisterCallback+0x32>
      hmdma->XferBufferCpltCallback = NULL;
24007778:	e9c3 2211 	strd	r2, r2, [r3, #68]	@ 0x44
      hmdma->XferRepeatBlockCpltCallback = NULL;
2400777c:	e9c3 2213 	strd	r2, r2, [r3, #76]	@ 0x4c
      hmdma->XferErrorCallback = NULL;
24007780:	655a      	str	r2, [r3, #84]	@ 0x54
      hmdma->XferAbortCallback = NULL;
24007782:	659a      	str	r2, [r3, #88]	@ 0x58
      break;
24007784:	e7eb      	b.n	2400775e <HAL_MDMA_UnRegisterCallback+0x32>
24007786:	4610      	mov	r0, r2
24007788:	e7ea      	b.n	24007760 <HAL_MDMA_UnRegisterCallback+0x34>
    return HAL_ERROR;
2400778a:	2001      	movs	r0, #1
2400778c:	e7eb      	b.n	24007766 <HAL_MDMA_UnRegisterCallback+0x3a>
  __HAL_LOCK(hmdma);
2400778e:	2002      	movs	r0, #2
24007790:	e7e9      	b.n	24007766 <HAL_MDMA_UnRegisterCallback+0x3a>

24007792 <HAL_MDMA_LinkedList_CreateNode>:
{
24007792:	b510      	push	{r4, lr}
  if((pNode == NULL) || (pNodeConfig == NULL))
24007794:	2800      	cmp	r0, #0
24007796:	d069      	beq.n	2400786c <HAL_MDMA_LinkedList_CreateNode+0xda>
24007798:	2900      	cmp	r1, #0
2400779a:	d067      	beq.n	2400786c <HAL_MDMA_LinkedList_CreateNode+0xda>
  pNode->CLAR =  0;
2400779c:	2300      	movs	r3, #0
2400779e:	6143      	str	r3, [r0, #20]
  pNode->CTBR   = 0;
240077a0:	6183      	str	r3, [r0, #24]
  pNode->CMAR   = 0;
240077a2:	6203      	str	r3, [r0, #32]
  pNode->CMDR   = 0;
240077a4:	6243      	str	r3, [r0, #36]	@ 0x24
  pNode->Reserved = 0;
240077a6:	61c3      	str	r3, [r0, #28]
          ((pNodeConfig->Init.BufferTransferLength - 1U) << MDMA_CTCR_TLEN_Pos) | \
240077a8:	e9d1 3204 	ldrd	r3, r2, [r1, #16]
240077ac:	4313      	orrs	r3, r2
240077ae:	698a      	ldr	r2, [r1, #24]
240077b0:	4313      	orrs	r3, r2
240077b2:	69ca      	ldr	r2, [r1, #28]
240077b4:	4313      	orrs	r3, r2
240077b6:	6a0a      	ldr	r2, [r1, #32]
240077b8:	4313      	orrs	r3, r2
240077ba:	6a8a      	ldr	r2, [r1, #40]	@ 0x28
240077bc:	4313      	orrs	r3, r2
240077be:	6aca      	ldr	r2, [r1, #44]	@ 0x2c
240077c0:	4313      	orrs	r3, r2
240077c2:	684a      	ldr	r2, [r1, #4]
240077c4:	4313      	orrs	r3, r2
240077c6:	6a4a      	ldr	r2, [r1, #36]	@ 0x24
240077c8:	3a01      	subs	r2, #1
240077ca:	ea43 4382 	orr.w	r3, r3, r2, lsl #18
  if(pNodeConfig->Init.Request == MDMA_REQUEST_SW)
240077ce:	680a      	ldr	r2, [r1, #0]
240077d0:	f1b2 4f80 	cmp.w	r2, #1073741824	@ 0x40000000
  pNode->CTCR =  pNodeConfig->Init.SourceInc | pNodeConfig->Init.DestinationInc | \
240077d4:	6003      	str	r3, [r0, #0]
  if(pNodeConfig->Init.Request == MDMA_REQUEST_SW)
240077d6:	d03e      	beq.n	24007856 <HAL_MDMA_LinkedList_CreateNode+0xc4>
  if((pNodeConfig->Init.Request == MDMA_REQUEST_SW) || (pNodeConfig->PostRequestMaskAddress != 0U))
240077d8:	6c8b      	ldr	r3, [r1, #72]	@ 0x48
240077da:	2b00      	cmp	r3, #0
240077dc:	d13f      	bne.n	2400785e <HAL_MDMA_LinkedList_CreateNode+0xcc>
  pNode->CBNDTR = ((pNodeConfig->BlockCount - 1U) << MDMA_CBNDTR_BRC_Pos) & MDMA_CBNDTR_BRC;
240077de:	6c4b      	ldr	r3, [r1, #68]	@ 0x44
240077e0:	3b01      	subs	r3, #1
240077e2:	051b      	lsls	r3, r3, #20
240077e4:	6043      	str	r3, [r0, #4]
  if(pNodeConfig->Init.SourceBlockAddressOffset < 0)
240077e6:	6b0b      	ldr	r3, [r1, #48]	@ 0x30
240077e8:	2b00      	cmp	r3, #0
240077ea:	da04      	bge.n	240077f6 <HAL_MDMA_LinkedList_CreateNode+0x64>
    pNode->CBNDTR |= MDMA_CBNDTR_BRSUM;
240077ec:	6844      	ldr	r4, [r0, #4]
    blockoffset = (uint32_t)(- pNodeConfig->Init.SourceBlockAddressOffset);
240077ee:	425b      	negs	r3, r3
    pNode->CBNDTR |= MDMA_CBNDTR_BRSUM;
240077f0:	f444 2480 	orr.w	r4, r4, #262144	@ 0x40000
240077f4:	6044      	str	r4, [r0, #4]
    pNode->CBRUR = (((uint32_t) pNodeConfig->Init.SourceBlockAddressOffset) & 0x0000FFFFU);
240077f6:	b29b      	uxth	r3, r3
240077f8:	6103      	str	r3, [r0, #16]
  if(pNodeConfig->Init.DestBlockAddressOffset < 0)
240077fa:	6b4b      	ldr	r3, [r1, #52]	@ 0x34
240077fc:	2b00      	cmp	r3, #0
240077fe:	da33      	bge.n	24007868 <HAL_MDMA_LinkedList_CreateNode+0xd6>
    pNode->CBNDTR |= MDMA_CBNDTR_BRDUM;
24007800:	6844      	ldr	r4, [r0, #4]
    blockoffset = (uint32_t)(- pNodeConfig->Init.DestBlockAddressOffset);
24007802:	425b      	negs	r3, r3
    pNode->CBNDTR |= MDMA_CBNDTR_BRDUM;
24007804:	f444 2400 	orr.w	r4, r4, #524288	@ 0x80000
24007808:	6044      	str	r4, [r0, #4]
    pNode->CBRUR |= ((blockoffset & 0x0000FFFFU) << MDMA_CBRUR_DUV_Pos);
2400780a:	6904      	ldr	r4, [r0, #16]
    pNode->CBRUR |= ((((uint32_t)pNodeConfig->Init.DestBlockAddressOffset) & 0x0000FFFFU) << MDMA_CBRUR_DUV_Pos);
2400780c:	ea44 4303 	orr.w	r3, r4, r3, lsl #16
  if(pNodeConfig->Init.Request != MDMA_REQUEST_SW)
24007810:	f1b2 4f80 	cmp.w	r2, #1073741824	@ 0x40000000
    pNode->CBRUR |= ((((uint32_t)pNodeConfig->Init.DestBlockAddressOffset) & 0x0000FFFFU) << MDMA_CBRUR_DUV_Pos);
24007814:	6103      	str	r3, [r0, #16]
  pNode->CBNDTR |=  pNodeConfig->BlockDataLength;
24007816:	6c0c      	ldr	r4, [r1, #64]	@ 0x40
24007818:	6843      	ldr	r3, [r0, #4]
2400781a:	ea43 0304 	orr.w	r3, r3, r4
  pNode->CDAR = pNodeConfig->DstAddress;
2400781e:	6bcc      	ldr	r4, [r1, #60]	@ 0x3c
  pNode->CBNDTR |=  pNodeConfig->BlockDataLength;
24007820:	6043      	str	r3, [r0, #4]
  pNode->CSAR = pNodeConfig->SrcAddress;
24007822:	6b8b      	ldr	r3, [r1, #56]	@ 0x38
  pNode->CDAR = pNodeConfig->DstAddress;
24007824:	60c4      	str	r4, [r0, #12]
  pNode->CSAR = pNodeConfig->SrcAddress;
24007826:	6083      	str	r3, [r0, #8]
  if(pNodeConfig->Init.Request != MDMA_REQUEST_SW)
24007828:	d005      	beq.n	24007836 <HAL_MDMA_LinkedList_CreateNode+0xa4>
    pNode->CTBR = pNodeConfig->Init.Request & MDMA_CTBR_TSEL;
2400782a:	b2d2      	uxtb	r2, r2
2400782c:	6182      	str	r2, [r0, #24]
    pNode->CMAR = pNodeConfig->PostRequestMaskAddress;
2400782e:	6c8a      	ldr	r2, [r1, #72]	@ 0x48
24007830:	6202      	str	r2, [r0, #32]
    pNode->CMDR = pNodeConfig->PostRequestMaskData;
24007832:	6cca      	ldr	r2, [r1, #76]	@ 0x4c
24007834:	6242      	str	r2, [r0, #36]	@ 0x24
  if((addressMask == 0x20000000U) || (addressMask == 0x00000000U))
24007836:	f013 4f5f 	tst.w	r3, #3741319168	@ 0xdf000000
2400783a:	d103      	bne.n	24007844 <HAL_MDMA_LinkedList_CreateNode+0xb2>
    pNode->CTBR |= MDMA_CTBR_SBUS;
2400783c:	6983      	ldr	r3, [r0, #24]
2400783e:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
24007842:	6183      	str	r3, [r0, #24]
  if((addressMask == 0x20000000U) || (addressMask == 0x00000000U))
24007844:	f014 4f5f 	tst.w	r4, #3741319168	@ 0xdf000000
24007848:	d103      	bne.n	24007852 <HAL_MDMA_LinkedList_CreateNode+0xc0>
    pNode->CTBR |= MDMA_CTBR_DBUS;
2400784a:	6983      	ldr	r3, [r0, #24]
2400784c:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
24007850:	6183      	str	r3, [r0, #24]
  return HAL_OK;
24007852:	2000      	movs	r0, #0
}
24007854:	bd10      	pop	{r4, pc}
    pNode->CTCR |= MDMA_CTCR_SWRM;
24007856:	6803      	ldr	r3, [r0, #0]
24007858:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
2400785c:	6003      	str	r3, [r0, #0]
    pNode->CTCR |=  MDMA_CTCR_BWM;
2400785e:	6803      	ldr	r3, [r0, #0]
24007860:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
24007864:	6003      	str	r3, [r0, #0]
24007866:	e7ba      	b.n	240077de <HAL_MDMA_LinkedList_CreateNode+0x4c>
    pNode->CBRUR |= ((((uint32_t)pNodeConfig->Init.DestBlockAddressOffset) & 0x0000FFFFU) << MDMA_CBRUR_DUV_Pos);
24007868:	6904      	ldr	r4, [r0, #16]
2400786a:	e7cf      	b.n	2400780c <HAL_MDMA_LinkedList_CreateNode+0x7a>
    return HAL_ERROR;
2400786c:	2001      	movs	r0, #1
2400786e:	e7f1      	b.n	24007854 <HAL_MDMA_LinkedList_CreateNode+0xc2>

24007870 <HAL_MDMA_LinkedList_AddNode>:
{
24007870:	b5f0      	push	{r4, r5, r6, r7, lr}
  if((hmdma == NULL) || (pNewNode == NULL))
24007872:	4604      	mov	r4, r0
24007874:	2800      	cmp	r0, #0
24007876:	d05b      	beq.n	24007930 <HAL_MDMA_LinkedList_AddNode+0xc0>
24007878:	2900      	cmp	r1, #0
2400787a:	d059      	beq.n	24007930 <HAL_MDMA_LinkedList_AddNode+0xc0>
  __HAL_LOCK(hmdma);
2400787c:	f890 303c 	ldrb.w	r3, [r0, #60]	@ 0x3c
24007880:	2b01      	cmp	r3, #1
24007882:	d101      	bne.n	24007888 <HAL_MDMA_LinkedList_AddNode+0x18>
24007884:	2002      	movs	r0, #2
}
24007886:	bdf0      	pop	{r4, r5, r6, r7, pc}
  __HAL_LOCK(hmdma);
24007888:	2301      	movs	r3, #1
2400788a:	f880 303c 	strb.w	r3, [r0, #60]	@ 0x3c
  if(HAL_MDMA_STATE_READY == hmdma->State)
2400788e:	f890 303d 	ldrb.w	r3, [r0, #61]	@ 0x3d
24007892:	2b01      	cmp	r3, #1
24007894:	b2d8      	uxtb	r0, r3
24007896:	d147      	bne.n	24007928 <HAL_MDMA_LinkedList_AddNode+0xb8>
    hmdma->State = HAL_MDMA_STATE_BUSY;
24007898:	2302      	movs	r3, #2
    if((uint32_t)hmdma->FirstLinkedListNodeAddress == 0U)
2400789a:	6de5      	ldr	r5, [r4, #92]	@ 0x5c
    hmdma->State = HAL_MDMA_STATE_BUSY;
2400789c:	f884 303d 	strb.w	r3, [r4, #61]	@ 0x3d
    if((uint32_t)hmdma->FirstLinkedListNodeAddress == 0U)
240078a0:	b975      	cbnz	r5, 240078c0 <HAL_MDMA_LinkedList_AddNode+0x50>
      if(pPrevNode == NULL)
240078a2:	b932      	cbnz	r2, 240078b2 <HAL_MDMA_LinkedList_AddNode+0x42>
        hmdma->Instance->CLAR = (uint32_t)pNewNode;
240078a4:	6823      	ldr	r3, [r4, #0]
240078a6:	6259      	str	r1, [r3, #36]	@ 0x24
        hmdma->FirstLinkedListNodeAddress = pNewNode;
240078a8:	65e1      	str	r1, [r4, #92]	@ 0x5c
        pNewNode->CLAR = 0;
240078aa:	614a      	str	r2, [r1, #20]
        hmdma->LinkedListNodeCounter = 1;
240078ac:	e9c4 1018 	strd	r1, r0, [r4, #96]	@ 0x60
240078b0:	2000      	movs	r0, #0
    __HAL_UNLOCK(hmdma);
240078b2:	2300      	movs	r3, #0
240078b4:	f884 303c 	strb.w	r3, [r4, #60]	@ 0x3c
    hmdma->State = HAL_MDMA_STATE_READY;
240078b8:	2301      	movs	r3, #1
240078ba:	f884 303d 	strb.w	r3, [r4, #61]	@ 0x3d
    return hal_status;
240078be:	e7e2      	b.n	24007886 <HAL_MDMA_LinkedList_AddNode+0x16>
    else if(hmdma->FirstLinkedListNodeAddress != pNewNode)
240078c0:	428d      	cmp	r5, r1
240078c2:	d0f6      	beq.n	240078b2 <HAL_MDMA_LinkedList_AddNode+0x42>
  HAL_StatusTypeDef hal_status = HAL_OK;
240078c4:	2000      	movs	r0, #0
      while((counter < hmdma->LinkedListNodeCounter) && (hal_status == HAL_OK))
240078c6:	f8d4 c064 	ldr.w	ip, [r4, #100]	@ 0x64
240078ca:	462e      	mov	r6, r5
  uint32_t counter = 0, nodeInserted = 0;
240078cc:	4607      	mov	r7, r0
      while((counter < hmdma->LinkedListNodeCounter) && (hal_status == HAL_OK))
240078ce:	45bc      	cmp	ip, r7
240078d0:	d008      	beq.n	240078e4 <HAL_MDMA_LinkedList_AddNode+0x74>
240078d2:	2800      	cmp	r0, #0
240078d4:	d1ed      	bne.n	240078b2 <HAL_MDMA_LinkedList_AddNode+0x42>
        if(pNode->CLAR == (uint32_t)pNewNode)
240078d6:	6970      	ldr	r0, [r6, #20]
        counter++;
240078d8:	3701      	adds	r7, #1
        pNode = (MDMA_LinkNodeTypeDef *)pNode->CLAR;
240078da:	6976      	ldr	r6, [r6, #20]
        if(pNode->CLAR == (uint32_t)pNewNode)
240078dc:	1a0b      	subs	r3, r1, r0
240078de:	4258      	negs	r0, r3
240078e0:	4158      	adcs	r0, r3
        counter++;
240078e2:	e7f4      	b.n	240078ce <HAL_MDMA_LinkedList_AddNode+0x5e>
      if(hal_status == HAL_OK)
240078e4:	2800      	cmp	r0, #0
240078e6:	d1e4      	bne.n	240078b2 <HAL_MDMA_LinkedList_AddNode+0x42>
        if((pPrevNode == hmdma->LastLinkedListNodeAddress) || (pPrevNode == NULL))
240078e8:	6e23      	ldr	r3, [r4, #96]	@ 0x60
240078ea:	4293      	cmp	r3, r2
240078ec:	d000      	beq.n	240078f0 <HAL_MDMA_LinkedList_AddNode+0x80>
240078ee:	b9ca      	cbnz	r2, 24007924 <HAL_MDMA_LinkedList_AddNode+0xb4>
          pNewNode->CLAR = hmdma->LastLinkedListNodeAddress->CLAR;
240078f0:	695a      	ldr	r2, [r3, #20]
          hmdma->LinkedListNodeCounter++;
240078f2:	f10c 0001 	add.w	r0, ip, #1
          pNewNode->CLAR = hmdma->LastLinkedListNodeAddress->CLAR;
240078f6:	614a      	str	r2, [r1, #20]
          hmdma->LastLinkedListNodeAddress->CLAR = (uint32_t)pNewNode;
240078f8:	6159      	str	r1, [r3, #20]
          hmdma->LinkedListNodeCounter++;
240078fa:	e7d7      	b.n	240078ac <HAL_MDMA_LinkedList_AddNode+0x3c>
            if(pNode == pPrevNode)
240078fc:	4295      	cmp	r5, r2
            counter++;
240078fe:	f106 0601 	add.w	r6, r6, #1
            if(pNode == pPrevNode)
24007902:	d10d      	bne.n	24007920 <HAL_MDMA_LinkedList_AddNode+0xb0>
              pNewNode->CLAR = pNode->CLAR;
24007904:	6968      	ldr	r0, [r5, #20]
              hmdma->LinkedListNodeCounter++;
24007906:	3301      	adds	r3, #1
              pNewNode->CLAR = pNode->CLAR;
24007908:	6148      	str	r0, [r1, #20]
              nodeInserted = 1;
2400790a:	2001      	movs	r0, #1
              pNode->CLAR = (uint32_t)pNewNode;
2400790c:	6169      	str	r1, [r5, #20]
              hmdma->LinkedListNodeCounter++;
2400790e:	6663      	str	r3, [r4, #100]	@ 0x64
          while((counter < hmdma->LinkedListNodeCounter) && (nodeInserted == 0U))
24007910:	6e63      	ldr	r3, [r4, #100]	@ 0x64
24007912:	42b3      	cmp	r3, r6
24007914:	d901      	bls.n	2400791a <HAL_MDMA_LinkedList_AddNode+0xaa>
24007916:	2800      	cmp	r0, #0
24007918:	d0f0      	beq.n	240078fc <HAL_MDMA_LinkedList_AddNode+0x8c>
          if(nodeInserted == 0U)
2400791a:	f080 0001 	eor.w	r0, r0, #1
2400791e:	e7c8      	b.n	240078b2 <HAL_MDMA_LinkedList_AddNode+0x42>
              pNode = (MDMA_LinkNodeTypeDef *)pNode->CLAR;
24007920:	696d      	ldr	r5, [r5, #20]
24007922:	e7f5      	b.n	24007910 <HAL_MDMA_LinkedList_AddNode+0xa0>
          counter = 0;
24007924:	4606      	mov	r6, r0
24007926:	e7f3      	b.n	24007910 <HAL_MDMA_LinkedList_AddNode+0xa0>
    __HAL_UNLOCK(hmdma);
24007928:	2300      	movs	r3, #0
2400792a:	f884 303c 	strb.w	r3, [r4, #60]	@ 0x3c
    return HAL_BUSY;
2400792e:	e7a9      	b.n	24007884 <HAL_MDMA_LinkedList_AddNode+0x14>
    return HAL_ERROR;
24007930:	2001      	movs	r0, #1
24007932:	e7a8      	b.n	24007886 <HAL_MDMA_LinkedList_AddNode+0x16>

24007934 <HAL_MDMA_LinkedList_RemoveNode>:
  if((hmdma == NULL) || (pNode == NULL))
24007934:	4603      	mov	r3, r0
{
24007936:	b570      	push	{r4, r5, r6, lr}
  if((hmdma == NULL) || (pNode == NULL))
24007938:	2800      	cmp	r0, #0
2400793a:	d054      	beq.n	240079e6 <HAL_MDMA_LinkedList_RemoveNode+0xb2>
2400793c:	2900      	cmp	r1, #0
2400793e:	d052      	beq.n	240079e6 <HAL_MDMA_LinkedList_RemoveNode+0xb2>
  __HAL_LOCK(hmdma);
24007940:	f890 203c 	ldrb.w	r2, [r0, #60]	@ 0x3c
24007944:	2a01      	cmp	r2, #1
24007946:	d101      	bne.n	2400794c <HAL_MDMA_LinkedList_RemoveNode+0x18>
24007948:	2002      	movs	r0, #2
}
2400794a:	bd70      	pop	{r4, r5, r6, pc}
  __HAL_LOCK(hmdma);
2400794c:	2201      	movs	r2, #1
2400794e:	f880 203c 	strb.w	r2, [r0, #60]	@ 0x3c
  if(HAL_MDMA_STATE_READY == hmdma->State)
24007952:	f890 203d 	ldrb.w	r2, [r0, #61]	@ 0x3d
24007956:	2a01      	cmp	r2, #1
24007958:	b2d0      	uxtb	r0, r2
2400795a:	d140      	bne.n	240079de <HAL_MDMA_LinkedList_RemoveNode+0xaa>
    hmdma->State = HAL_MDMA_STATE_BUSY;
2400795c:	2202      	movs	r2, #2
2400795e:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d
    if(((uint32_t)hmdma->FirstLinkedListNodeAddress == 0U) || ((uint32_t)hmdma->LastLinkedListNodeAddress == 0U) || (hmdma->LinkedListNodeCounter == 0U))
24007962:	6dda      	ldr	r2, [r3, #92]	@ 0x5c
24007964:	b17a      	cbz	r2, 24007986 <HAL_MDMA_LinkedList_RemoveNode+0x52>
24007966:	6e1d      	ldr	r5, [r3, #96]	@ 0x60
24007968:	b16d      	cbz	r5, 24007986 <HAL_MDMA_LinkedList_RemoveNode+0x52>
2400796a:	6e5c      	ldr	r4, [r3, #100]	@ 0x64
2400796c:	b15c      	cbz	r4, 24007986 <HAL_MDMA_LinkedList_RemoveNode+0x52>
    else if(hmdma->FirstLinkedListNodeAddress == pNode) /* Deleting first node */
2400796e:	428a      	cmp	r2, r1
24007970:	f04f 0000 	mov.w	r0, #0
24007974:	d131      	bne.n	240079da <HAL_MDMA_LinkedList_RemoveNode+0xa6>
      if(hmdma->LastLinkedListNodeAddress == pNode)
24007976:	4295      	cmp	r5, r2
        hmdma->Instance->CLAR = 0;
24007978:	681e      	ldr	r6, [r3, #0]
      if(hmdma->LastLinkedListNodeAddress == pNode)
2400797a:	d10b      	bne.n	24007994 <HAL_MDMA_LinkedList_RemoveNode+0x60>
        hmdma->LinkedListNodeCounter = 0;
2400797c:	6658      	str	r0, [r3, #100]	@ 0x64
        hmdma->LastLinkedListNodeAddress  = 0;
2400797e:	e9c3 0017 	strd	r0, r0, [r3, #92]	@ 0x5c
        hmdma->Instance->CLAR = 0;
24007982:	6270      	str	r0, [r6, #36]	@ 0x24
  HAL_StatusTypeDef hal_status = HAL_OK;
24007984:	2000      	movs	r0, #0
    __HAL_UNLOCK(hmdma);
24007986:	2200      	movs	r2, #0
24007988:	f883 203c 	strb.w	r2, [r3, #60]	@ 0x3c
    hmdma->State = HAL_MDMA_STATE_READY;
2400798c:	2201      	movs	r2, #1
2400798e:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d
    return hal_status;
24007992:	e7da      	b.n	2400794a <HAL_MDMA_LinkedList_RemoveNode+0x16>
        if((uint32_t)hmdma->FirstLinkedListNodeAddress == hmdma->LastLinkedListNodeAddress->CLAR)
24007994:	696a      	ldr	r2, [r5, #20]
24007996:	4291      	cmp	r1, r2
24007998:	d101      	bne.n	2400799e <HAL_MDMA_LinkedList_RemoveNode+0x6a>
          hmdma->LastLinkedListNodeAddress->CLAR = pNode->CLAR;
2400799a:	694a      	ldr	r2, [r1, #20]
2400799c:	616a      	str	r2, [r5, #20]
        hmdma->Instance->CLAR = pNode->CLAR;
2400799e:	694a      	ldr	r2, [r1, #20]
        hmdma->LinkedListNodeCounter--;
240079a0:	3c01      	subs	r4, #1
        hmdma->Instance->CLAR = pNode->CLAR;
240079a2:	6272      	str	r2, [r6, #36]	@ 0x24
        hmdma->FirstLinkedListNodeAddress = (MDMA_LinkNodeTypeDef *)hmdma->Instance->CLAR;
240079a4:	6a72      	ldr	r2, [r6, #36]	@ 0x24
        hmdma->LinkedListNodeCounter--;
240079a6:	665c      	str	r4, [r3, #100]	@ 0x64
        hmdma->FirstLinkedListNodeAddress = (MDMA_LinkNodeTypeDef *)hmdma->Instance->CLAR;
240079a8:	65da      	str	r2, [r3, #92]	@ 0x5c
        hmdma->LinkedListNodeCounter--;
240079aa:	e7eb      	b.n	24007984 <HAL_MDMA_LinkedList_RemoveNode+0x50>
        if(ptmpNode->CLAR == ((uint32_t)pNode))
240079ac:	6956      	ldr	r6, [r2, #20]
        counter++;
240079ae:	3501      	adds	r5, #1
        if(ptmpNode->CLAR == ((uint32_t)pNode))
240079b0:	42b1      	cmp	r1, r6
240079b2:	d110      	bne.n	240079d6 <HAL_MDMA_LinkedList_RemoveNode+0xa2>
          if(pNode == hmdma->LastLinkedListNodeAddress)
240079b4:	6e18      	ldr	r0, [r3, #96]	@ 0x60
          hmdma->LinkedListNodeCounter--;
240079b6:	3c01      	subs	r4, #1
          if(pNode == hmdma->LastLinkedListNodeAddress)
240079b8:	4288      	cmp	r0, r1
          ptmpNode->CLAR = pNode->CLAR;
240079ba:	6948      	ldr	r0, [r1, #20]
            hmdma->LastLinkedListNodeAddress = ptmpNode;
240079bc:	bf08      	it	eq
240079be:	661a      	streq	r2, [r3, #96]	@ 0x60
          ptmpNode->CLAR = pNode->CLAR;
240079c0:	6150      	str	r0, [r2, #20]
          nodeDeleted = 1;
240079c2:	2001      	movs	r0, #1
          hmdma->LinkedListNodeCounter--;
240079c4:	665c      	str	r4, [r3, #100]	@ 0x64
      while((counter < hmdma->LinkedListNodeCounter) && (nodeDeleted == 0U))
240079c6:	6e5c      	ldr	r4, [r3, #100]	@ 0x64
240079c8:	42ac      	cmp	r4, r5
240079ca:	d901      	bls.n	240079d0 <HAL_MDMA_LinkedList_RemoveNode+0x9c>
240079cc:	2800      	cmp	r0, #0
240079ce:	d0ed      	beq.n	240079ac <HAL_MDMA_LinkedList_RemoveNode+0x78>
      if(nodeDeleted == 0U)
240079d0:	f080 0001 	eor.w	r0, r0, #1
240079d4:	e7d7      	b.n	24007986 <HAL_MDMA_LinkedList_RemoveNode+0x52>
          ptmpNode = (MDMA_LinkNodeTypeDef *)ptmpNode->CLAR;
240079d6:	6952      	ldr	r2, [r2, #20]
240079d8:	e7f5      	b.n	240079c6 <HAL_MDMA_LinkedList_RemoveNode+0x92>
  uint32_t counter = 0, nodeDeleted = 0;
240079da:	4605      	mov	r5, r0
240079dc:	e7f3      	b.n	240079c6 <HAL_MDMA_LinkedList_RemoveNode+0x92>
    __HAL_UNLOCK(hmdma);
240079de:	2200      	movs	r2, #0
240079e0:	f883 203c 	strb.w	r2, [r3, #60]	@ 0x3c
    return HAL_BUSY;
240079e4:	e7b0      	b.n	24007948 <HAL_MDMA_LinkedList_RemoveNode+0x14>
    return HAL_ERROR;
240079e6:	2001      	movs	r0, #1
240079e8:	e7af      	b.n	2400794a <HAL_MDMA_LinkedList_RemoveNode+0x16>

240079ea <HAL_MDMA_LinkedList_EnableCircularMode>:
  if(hmdma == NULL)
240079ea:	4603      	mov	r3, r0
{
240079ec:	b510      	push	{r4, lr}
  if(hmdma == NULL)
240079ee:	b1e8      	cbz	r0, 24007a2c <HAL_MDMA_LinkedList_EnableCircularMode+0x42>
  __HAL_LOCK(hmdma);
240079f0:	f890 203c 	ldrb.w	r2, [r0, #60]	@ 0x3c
240079f4:	2a01      	cmp	r2, #1
240079f6:	d01b      	beq.n	24007a30 <HAL_MDMA_LinkedList_EnableCircularMode+0x46>
240079f8:	2201      	movs	r2, #1
240079fa:	f880 203c 	strb.w	r2, [r0, #60]	@ 0x3c
  if(HAL_MDMA_STATE_READY == hmdma->State)
240079fe:	f890 203d 	ldrb.w	r2, [r0, #61]	@ 0x3d
24007a02:	2a01      	cmp	r2, #1
24007a04:	b2d0      	uxtb	r0, r2
24007a06:	d109      	bne.n	24007a1c <HAL_MDMA_LinkedList_EnableCircularMode+0x32>
    hmdma->State = HAL_MDMA_STATE_BUSY;
24007a08:	2202      	movs	r2, #2
    if(((uint32_t)hmdma->FirstLinkedListNodeAddress == 0U) || ((uint32_t)hmdma->LastLinkedListNodeAddress == 0U) || (hmdma->LinkedListNodeCounter == 0U))
24007a0a:	6dd9      	ldr	r1, [r3, #92]	@ 0x5c
    hmdma->State = HAL_MDMA_STATE_BUSY;
24007a0c:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d
    if(((uint32_t)hmdma->FirstLinkedListNodeAddress == 0U) || ((uint32_t)hmdma->LastLinkedListNodeAddress == 0U) || (hmdma->LinkedListNodeCounter == 0U))
24007a10:	b129      	cbz	r1, 24007a1e <HAL_MDMA_LinkedList_EnableCircularMode+0x34>
24007a12:	6e1a      	ldr	r2, [r3, #96]	@ 0x60
24007a14:	b11a      	cbz	r2, 24007a1e <HAL_MDMA_LinkedList_EnableCircularMode+0x34>
24007a16:	6e5c      	ldr	r4, [r3, #100]	@ 0x64
24007a18:	b10c      	cbz	r4, 24007a1e <HAL_MDMA_LinkedList_EnableCircularMode+0x34>
      hmdma->LastLinkedListNodeAddress->CLAR = (uint32_t)hmdma->FirstLinkedListNodeAddress;
24007a1a:	6151      	str	r1, [r2, #20]
  HAL_StatusTypeDef hal_status = HAL_OK;
24007a1c:	2000      	movs	r0, #0
  __HAL_UNLOCK(hmdma);
24007a1e:	2200      	movs	r2, #0
24007a20:	f883 203c 	strb.w	r2, [r3, #60]	@ 0x3c
  hmdma->State = HAL_MDMA_STATE_READY;
24007a24:	2201      	movs	r2, #1
24007a26:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d
}
24007a2a:	bd10      	pop	{r4, pc}
    return HAL_ERROR;
24007a2c:	2001      	movs	r0, #1
24007a2e:	e7fc      	b.n	24007a2a <HAL_MDMA_LinkedList_EnableCircularMode+0x40>
  __HAL_LOCK(hmdma);
24007a30:	2002      	movs	r0, #2
24007a32:	e7fa      	b.n	24007a2a <HAL_MDMA_LinkedList_EnableCircularMode+0x40>

24007a34 <HAL_MDMA_LinkedList_DisableCircularMode>:
  if(hmdma == NULL)
24007a34:	4603      	mov	r3, r0
24007a36:	b1f0      	cbz	r0, 24007a76 <HAL_MDMA_LinkedList_DisableCircularMode+0x42>
  __HAL_LOCK(hmdma);
24007a38:	f890 203c 	ldrb.w	r2, [r0, #60]	@ 0x3c
24007a3c:	2a01      	cmp	r2, #1
24007a3e:	d01c      	beq.n	24007a7a <HAL_MDMA_LinkedList_DisableCircularMode+0x46>
24007a40:	2201      	movs	r2, #1
24007a42:	f880 203c 	strb.w	r2, [r0, #60]	@ 0x3c
  if(HAL_MDMA_STATE_READY == hmdma->State)
24007a46:	f890 203d 	ldrb.w	r2, [r0, #61]	@ 0x3d
24007a4a:	2a01      	cmp	r2, #1
24007a4c:	b2d0      	uxtb	r0, r2
24007a4e:	d10a      	bne.n	24007a66 <HAL_MDMA_LinkedList_DisableCircularMode+0x32>
    hmdma->State = HAL_MDMA_STATE_BUSY;
24007a50:	2202      	movs	r2, #2
24007a52:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d
    if(((uint32_t)hmdma->FirstLinkedListNodeAddress == 0U) || ((uint32_t)hmdma->LastLinkedListNodeAddress == 0U) || (hmdma->LinkedListNodeCounter == 0U))
24007a56:	6dda      	ldr	r2, [r3, #92]	@ 0x5c
24007a58:	b132      	cbz	r2, 24007a68 <HAL_MDMA_LinkedList_DisableCircularMode+0x34>
24007a5a:	6e1a      	ldr	r2, [r3, #96]	@ 0x60
24007a5c:	b122      	cbz	r2, 24007a68 <HAL_MDMA_LinkedList_DisableCircularMode+0x34>
24007a5e:	6e59      	ldr	r1, [r3, #100]	@ 0x64
24007a60:	b111      	cbz	r1, 24007a68 <HAL_MDMA_LinkedList_DisableCircularMode+0x34>
      hmdma->LastLinkedListNodeAddress->CLAR = 0;
24007a62:	2100      	movs	r1, #0
24007a64:	6151      	str	r1, [r2, #20]
  HAL_StatusTypeDef hal_status = HAL_OK;
24007a66:	2000      	movs	r0, #0
  __HAL_UNLOCK(hmdma);
24007a68:	2200      	movs	r2, #0
24007a6a:	f883 203c 	strb.w	r2, [r3, #60]	@ 0x3c
  hmdma->State = HAL_MDMA_STATE_READY;
24007a6e:	2201      	movs	r2, #1
24007a70:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d
  return hal_status;
24007a74:	4770      	bx	lr
    return HAL_ERROR;
24007a76:	2001      	movs	r0, #1
24007a78:	4770      	bx	lr
  __HAL_LOCK(hmdma);
24007a7a:	2002      	movs	r0, #2
}
24007a7c:	4770      	bx	lr

24007a7e <HAL_MDMA_Start>:
{
24007a7e:	b573      	push	{r0, r1, r4, r5, r6, lr}
  if(hmdma == NULL)
24007a80:	b360      	cbz	r0, 24007adc <HAL_MDMA_Start+0x5e>
  __HAL_LOCK(hmdma);
24007a82:	f890 503c 	ldrb.w	r5, [r0, #60]	@ 0x3c
24007a86:	2d01      	cmp	r5, #1
24007a88:	d026      	beq.n	24007ad8 <HAL_MDMA_Start+0x5a>
24007a8a:	2501      	movs	r5, #1
24007a8c:	f880 503c 	strb.w	r5, [r0, #60]	@ 0x3c
  if(HAL_MDMA_STATE_READY == hmdma->State)
24007a90:	f890 503d 	ldrb.w	r5, [r0, #61]	@ 0x3d
24007a94:	2d01      	cmp	r5, #1
24007a96:	f04f 0500 	mov.w	r5, #0
24007a9a:	d11b      	bne.n	24007ad4 <HAL_MDMA_Start+0x56>
    hmdma->State = HAL_MDMA_STATE_BUSY;
24007a9c:	2602      	movs	r6, #2
24007a9e:	f880 603d 	strb.w	r6, [r0, #61]	@ 0x3d
    hmdma->ErrorCode = HAL_MDMA_ERROR_NONE;
24007aa2:	6685      	str	r5, [r0, #104]	@ 0x68
    __HAL_MDMA_DISABLE(hmdma);
24007aa4:	6805      	ldr	r5, [r0, #0]
24007aa6:	68ee      	ldr	r6, [r5, #12]
24007aa8:	f026 0601 	bic.w	r6, r6, #1
24007aac:	60ee      	str	r6, [r5, #12]
    MDMA_SetConfig(hmdma, SrcAddress, DstAddress, BlockDataLength, BlockCount);
24007aae:	9e06      	ldr	r6, [sp, #24]
24007ab0:	9600      	str	r6, [sp, #0]
24007ab2:	f7ff fd2f 	bl	24007514 <MDMA_SetConfig>
    __HAL_MDMA_ENABLE(hmdma);
24007ab6:	68eb      	ldr	r3, [r5, #12]
24007ab8:	f043 0301 	orr.w	r3, r3, #1
24007abc:	60eb      	str	r3, [r5, #12]
    if(hmdma->Init.Request == MDMA_REQUEST_SW)
24007abe:	6843      	ldr	r3, [r0, #4]
24007ac0:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
24007ac4:	d103      	bne.n	24007ace <HAL_MDMA_Start+0x50>
      hmdma->Instance->CCR |=  MDMA_CCR_SWRQ;
24007ac6:	68eb      	ldr	r3, [r5, #12]
24007ac8:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
24007acc:	60eb      	str	r3, [r5, #12]
  return HAL_OK;
24007ace:	2000      	movs	r0, #0
}
24007ad0:	b002      	add	sp, #8
24007ad2:	bd70      	pop	{r4, r5, r6, pc}
    __HAL_UNLOCK(hmdma);
24007ad4:	f880 503c 	strb.w	r5, [r0, #60]	@ 0x3c
  __HAL_LOCK(hmdma);
24007ad8:	2002      	movs	r0, #2
24007ada:	e7f9      	b.n	24007ad0 <HAL_MDMA_Start+0x52>
    return HAL_ERROR;
24007adc:	2001      	movs	r0, #1
24007ade:	e7f7      	b.n	24007ad0 <HAL_MDMA_Start+0x52>

24007ae0 <HAL_MDMA_Start_IT>:
{
24007ae0:	b573      	push	{r0, r1, r4, r5, r6, lr}
  if(hmdma == NULL)
24007ae2:	4604      	mov	r4, r0
24007ae4:	2800      	cmp	r0, #0
24007ae6:	d042      	beq.n	24007b6e <HAL_MDMA_Start_IT+0x8e>
  __HAL_LOCK(hmdma);
24007ae8:	f890 503c 	ldrb.w	r5, [r0, #60]	@ 0x3c
24007aec:	2d01      	cmp	r5, #1
24007aee:	d03c      	beq.n	24007b6a <HAL_MDMA_Start_IT+0x8a>
24007af0:	2501      	movs	r5, #1
24007af2:	f880 503c 	strb.w	r5, [r0, #60]	@ 0x3c
  if(HAL_MDMA_STATE_READY == hmdma->State)
24007af6:	f890 503d 	ldrb.w	r5, [r0, #61]	@ 0x3d
24007afa:	2d01      	cmp	r5, #1
24007afc:	f04f 0500 	mov.w	r5, #0
24007b00:	d131      	bne.n	24007b66 <HAL_MDMA_Start_IT+0x86>
    hmdma->State = HAL_MDMA_STATE_BUSY;
24007b02:	2602      	movs	r6, #2
24007b04:	f880 603d 	strb.w	r6, [r0, #61]	@ 0x3d
    hmdma->ErrorCode = HAL_MDMA_ERROR_NONE;
24007b08:	6685      	str	r5, [r0, #104]	@ 0x68
    __HAL_MDMA_DISABLE(hmdma);
24007b0a:	6805      	ldr	r5, [r0, #0]
24007b0c:	68ee      	ldr	r6, [r5, #12]
24007b0e:	f026 0601 	bic.w	r6, r6, #1
24007b12:	60ee      	str	r6, [r5, #12]
    MDMA_SetConfig(hmdma, SrcAddress, DstAddress, BlockDataLength, BlockCount);
24007b14:	9e06      	ldr	r6, [sp, #24]
24007b16:	9600      	str	r6, [sp, #0]
24007b18:	f7ff fcfc 	bl	24007514 <MDMA_SetConfig>
    __HAL_MDMA_ENABLE_IT(hmdma, (MDMA_IT_TE | MDMA_IT_CTC));
24007b1c:	68eb      	ldr	r3, [r5, #12]
24007b1e:	f043 0306 	orr.w	r3, r3, #6
24007b22:	60eb      	str	r3, [r5, #12]
    if(hmdma->XferBlockCpltCallback != NULL)
24007b24:	6cc3      	ldr	r3, [r0, #76]	@ 0x4c
24007b26:	b11b      	cbz	r3, 24007b30 <HAL_MDMA_Start_IT+0x50>
      __HAL_MDMA_ENABLE_IT(hmdma, MDMA_IT_BT);
24007b28:	68eb      	ldr	r3, [r5, #12]
24007b2a:	f043 0310 	orr.w	r3, r3, #16
24007b2e:	60eb      	str	r3, [r5, #12]
    if(hmdma->XferRepeatBlockCpltCallback != NULL)
24007b30:	6d23      	ldr	r3, [r4, #80]	@ 0x50
24007b32:	b11b      	cbz	r3, 24007b3c <HAL_MDMA_Start_IT+0x5c>
      __HAL_MDMA_ENABLE_IT(hmdma, MDMA_IT_BRT);
24007b34:	68eb      	ldr	r3, [r5, #12]
24007b36:	f043 0308 	orr.w	r3, r3, #8
24007b3a:	60eb      	str	r3, [r5, #12]
    if(hmdma->XferBufferCpltCallback != NULL)
24007b3c:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
24007b3e:	b11b      	cbz	r3, 24007b48 <HAL_MDMA_Start_IT+0x68>
      __HAL_MDMA_ENABLE_IT(hmdma, MDMA_IT_BFTC);
24007b40:	68eb      	ldr	r3, [r5, #12]
24007b42:	f043 0320 	orr.w	r3, r3, #32
24007b46:	60eb      	str	r3, [r5, #12]
    __HAL_MDMA_ENABLE(hmdma);
24007b48:	68eb      	ldr	r3, [r5, #12]
24007b4a:	f043 0301 	orr.w	r3, r3, #1
24007b4e:	60eb      	str	r3, [r5, #12]
    if(hmdma->Init.Request == MDMA_REQUEST_SW)
24007b50:	6863      	ldr	r3, [r4, #4]
24007b52:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
24007b56:	d103      	bne.n	24007b60 <HAL_MDMA_Start_IT+0x80>
      hmdma->Instance->CCR |=  MDMA_CCR_SWRQ;
24007b58:	68eb      	ldr	r3, [r5, #12]
24007b5a:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
24007b5e:	60eb      	str	r3, [r5, #12]
  return HAL_OK;
24007b60:	2000      	movs	r0, #0
}
24007b62:	b002      	add	sp, #8
24007b64:	bd70      	pop	{r4, r5, r6, pc}
    __HAL_UNLOCK(hmdma);
24007b66:	f880 503c 	strb.w	r5, [r0, #60]	@ 0x3c
  __HAL_LOCK(hmdma);
24007b6a:	2002      	movs	r0, #2
24007b6c:	e7f9      	b.n	24007b62 <HAL_MDMA_Start_IT+0x82>
    return HAL_ERROR;
24007b6e:	2001      	movs	r0, #1
24007b70:	e7f7      	b.n	24007b62 <HAL_MDMA_Start_IT+0x82>

24007b72 <HAL_MDMA_Abort>:
{
24007b72:	b538      	push	{r3, r4, r5, lr}
24007b74:	4604      	mov	r4, r0
  uint32_t tickstart =  HAL_GetTick();
24007b76:	f00a f947 	bl	24011e08 <HAL_GetTick>
24007b7a:	4605      	mov	r5, r0
  if(hmdma == NULL)
24007b7c:	b144      	cbz	r4, 24007b90 <HAL_MDMA_Abort+0x1e>
  if(HAL_MDMA_STATE_BUSY != hmdma->State)
24007b7e:	f894 303d 	ldrb.w	r3, [r4, #61]	@ 0x3d
24007b82:	2b02      	cmp	r3, #2
24007b84:	d006      	beq.n	24007b94 <HAL_MDMA_Abort+0x22>
    hmdma->ErrorCode = HAL_MDMA_ERROR_NO_XFER;
24007b86:	2380      	movs	r3, #128	@ 0x80
24007b88:	66a3      	str	r3, [r4, #104]	@ 0x68
    __HAL_UNLOCK(hmdma);
24007b8a:	2300      	movs	r3, #0
24007b8c:	f884 303c 	strb.w	r3, [r4, #60]	@ 0x3c
    return HAL_ERROR;
24007b90:	2001      	movs	r0, #1
}
24007b92:	bd38      	pop	{r3, r4, r5, pc}
    __HAL_MDMA_DISABLE_IT(hmdma, (MDMA_IT_TE | MDMA_IT_CTC | MDMA_IT_BT | MDMA_IT_BRT | MDMA_IT_BFTC));
24007b94:	6823      	ldr	r3, [r4, #0]
24007b96:	68da      	ldr	r2, [r3, #12]
24007b98:	f022 023e 	bic.w	r2, r2, #62	@ 0x3e
24007b9c:	60da      	str	r2, [r3, #12]
    __HAL_MDMA_DISABLE(hmdma);
24007b9e:	68da      	ldr	r2, [r3, #12]
24007ba0:	f022 0201 	bic.w	r2, r2, #1
24007ba4:	60da      	str	r2, [r3, #12]
    while((hmdma->Instance->CCR & MDMA_CCR_EN) != 0U)
24007ba6:	6823      	ldr	r3, [r4, #0]
24007ba8:	68d8      	ldr	r0, [r3, #12]
24007baa:	f010 0001 	ands.w	r0, r0, #1
24007bae:	d107      	bne.n	24007bc0 <HAL_MDMA_Abort+0x4e>
    __HAL_MDMA_CLEAR_FLAG(hmdma, (MDMA_FLAG_TE | MDMA_FLAG_CTC | MDMA_FLAG_BT | MDMA_FLAG_BRT | MDMA_FLAG_BFTC));
24007bb0:	221f      	movs	r2, #31
24007bb2:	605a      	str	r2, [r3, #4]
    hmdma->State = HAL_MDMA_STATE_READY;
24007bb4:	2301      	movs	r3, #1
    __HAL_UNLOCK(hmdma);
24007bb6:	f884 003c 	strb.w	r0, [r4, #60]	@ 0x3c
    hmdma->State = HAL_MDMA_STATE_READY;
24007bba:	f884 303d 	strb.w	r3, [r4, #61]	@ 0x3d
  return HAL_OK;
24007bbe:	e7e8      	b.n	24007b92 <HAL_MDMA_Abort+0x20>
      if( (HAL_GetTick()  - tickstart ) > HAL_TIMEOUT_MDMA_ABORT)
24007bc0:	f00a f922 	bl	24011e08 <HAL_GetTick>
24007bc4:	1b40      	subs	r0, r0, r5
24007bc6:	2805      	cmp	r0, #5
24007bc8:	d9ed      	bls.n	24007ba6 <HAL_MDMA_Abort+0x34>
        hmdma->ErrorCode |= HAL_MDMA_ERROR_TIMEOUT;
24007bca:	6ea3      	ldr	r3, [r4, #104]	@ 0x68
24007bcc:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
24007bd0:	66a3      	str	r3, [r4, #104]	@ 0x68
        __HAL_UNLOCK(hmdma);
24007bd2:	2300      	movs	r3, #0
24007bd4:	f884 303c 	strb.w	r3, [r4, #60]	@ 0x3c
        hmdma->State = HAL_MDMA_STATE_ERROR;
24007bd8:	2303      	movs	r3, #3
24007bda:	f884 303d 	strb.w	r3, [r4, #61]	@ 0x3d
        return HAL_ERROR;
24007bde:	e7d7      	b.n	24007b90 <HAL_MDMA_Abort+0x1e>

24007be0 <HAL_MDMA_Abort_IT>:
  if(hmdma == NULL)
24007be0:	b128      	cbz	r0, 24007bee <HAL_MDMA_Abort_IT+0xe>
  if(HAL_MDMA_STATE_BUSY != hmdma->State)
24007be2:	f890 303d 	ldrb.w	r3, [r0, #61]	@ 0x3d
24007be6:	2b02      	cmp	r3, #2
24007be8:	d003      	beq.n	24007bf2 <HAL_MDMA_Abort_IT+0x12>
    hmdma->ErrorCode = HAL_MDMA_ERROR_NO_XFER;
24007bea:	2380      	movs	r3, #128	@ 0x80
24007bec:	6683      	str	r3, [r0, #104]	@ 0x68
    return HAL_ERROR;
24007bee:	2001      	movs	r0, #1
24007bf0:	4770      	bx	lr
    __HAL_MDMA_DISABLE(hmdma);
24007bf2:	6802      	ldr	r2, [r0, #0]
    hmdma->State = HAL_MDMA_STATE_ABORT;
24007bf4:	2304      	movs	r3, #4
24007bf6:	f880 303d 	strb.w	r3, [r0, #61]	@ 0x3d
  return HAL_OK;
24007bfa:	2000      	movs	r0, #0
    __HAL_MDMA_DISABLE(hmdma);
24007bfc:	68d3      	ldr	r3, [r2, #12]
24007bfe:	f023 0301 	bic.w	r3, r3, #1
24007c02:	60d3      	str	r3, [r2, #12]
}
24007c04:	4770      	bx	lr

24007c06 <HAL_MDMA_PollForTransfer>:
{
24007c06:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
24007c0a:	460d      	mov	r5, r1
24007c0c:	4616      	mov	r6, r2
  if(hmdma == NULL)
24007c0e:	4604      	mov	r4, r0
24007c10:	b128      	cbz	r0, 24007c1e <HAL_MDMA_PollForTransfer+0x18>
  if(HAL_MDMA_STATE_BUSY != hmdma->State)
24007c12:	f890 303d 	ldrb.w	r3, [r0, #61]	@ 0x3d
24007c16:	2b02      	cmp	r3, #2
24007c18:	d003      	beq.n	24007c22 <HAL_MDMA_PollForTransfer+0x1c>
    hmdma->ErrorCode = HAL_MDMA_ERROR_NO_XFER;
24007c1a:	2380      	movs	r3, #128	@ 0x80
24007c1c:	6683      	str	r3, [r0, #104]	@ 0x68
    return HAL_ERROR;
24007c1e:	2001      	movs	r0, #1
24007c20:	e013      	b.n	24007c4a <HAL_MDMA_PollForTransfer+0x44>
  levelFlag = ((CompleteLevel == HAL_MDMA_FULL_TRANSFER)  ? MDMA_FLAG_CTC  : \
24007c22:	2902      	cmp	r1, #2
24007c24:	bf96      	itet	ls
24007c26:	4b2d      	ldrls	r3, [pc, #180]	@ (24007cdc <HAL_MDMA_PollForTransfer+0xd6>)
  if(HAL_MDMA_STATE_BUSY != hmdma->State)
24007c28:	f04f 0804 	movhi.w	r8, #4
24007c2c:	f813 8001 	ldrbls.w	r8, [r3, r1]
  tickstart = HAL_GetTick();
24007c30:	f00a f8ea 	bl	24011e08 <HAL_GetTick>
24007c34:	4607      	mov	r7, r0
  while(__HAL_MDMA_GET_FLAG(hmdma, levelFlag) == 0U)
24007c36:	6823      	ldr	r3, [r4, #0]
24007c38:	681a      	ldr	r2, [r3, #0]
24007c3a:	ea12 0f08 	tst.w	r2, r8
24007c3e:	d006      	beq.n	24007c4e <HAL_MDMA_PollForTransfer+0x48>
  if(CompleteLevel == HAL_MDMA_BUFFER_TRANSFER)
24007c40:	2d01      	cmp	r5, #1
24007c42:	d139      	bne.n	24007cb8 <HAL_MDMA_PollForTransfer+0xb2>
    __HAL_MDMA_CLEAR_FLAG(hmdma, MDMA_FLAG_BFTC);
24007c44:	2210      	movs	r2, #16
24007c46:	605a      	str	r2, [r3, #4]
  return HAL_OK;
24007c48:	2000      	movs	r0, #0
}
24007c4a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if((__HAL_MDMA_GET_FLAG(hmdma, MDMA_FLAG_TE) != 0U))
24007c4e:	681a      	ldr	r2, [r3, #0]
24007c50:	07d2      	lsls	r2, r2, #31
24007c52:	d524      	bpl.n	24007c9e <HAL_MDMA_PollForTransfer+0x98>
      errorFlag = hmdma->Instance->CESR;
24007c54:	689b      	ldr	r3, [r3, #8]
        hmdma->ErrorCode |= HAL_MDMA_ERROR_READ_XFER;
24007c56:	6ea2      	ldr	r2, [r4, #104]	@ 0x68
      if((errorFlag & MDMA_CESR_TED) == 0U)
24007c58:	061f      	lsls	r7, r3, #24
        hmdma->ErrorCode |= HAL_MDMA_ERROR_READ_XFER;
24007c5a:	bf54      	ite	pl
24007c5c:	f042 0201 	orrpl.w	r2, r2, #1
        hmdma->ErrorCode |= HAL_MDMA_ERROR_WRITE_XFER;
24007c60:	f042 0202 	orrmi.w	r2, r2, #2
      if((errorFlag & MDMA_CESR_TEMD) != 0U)
24007c64:	059e      	lsls	r6, r3, #22
        hmdma->ErrorCode |= HAL_MDMA_ERROR_WRITE_XFER;
24007c66:	66a2      	str	r2, [r4, #104]	@ 0x68
      if((errorFlag & MDMA_CESR_TEMD) != 0U)
24007c68:	d503      	bpl.n	24007c72 <HAL_MDMA_PollForTransfer+0x6c>
        hmdma->ErrorCode |= HAL_MDMA_ERROR_MASK_DATA;
24007c6a:	6ea2      	ldr	r2, [r4, #104]	@ 0x68
24007c6c:	f042 0204 	orr.w	r2, r2, #4
24007c70:	66a2      	str	r2, [r4, #104]	@ 0x68
      if((errorFlag & MDMA_CESR_TELD) != 0U)
24007c72:	05dd      	lsls	r5, r3, #23
24007c74:	d503      	bpl.n	24007c7e <HAL_MDMA_PollForTransfer+0x78>
        hmdma->ErrorCode |= HAL_MDMA_ERROR_LINKED_LIST;
24007c76:	6ea2      	ldr	r2, [r4, #104]	@ 0x68
24007c78:	f042 0208 	orr.w	r2, r2, #8
24007c7c:	66a2      	str	r2, [r4, #104]	@ 0x68
      if((errorFlag & MDMA_CESR_ASE) != 0U)
24007c7e:	0558      	lsls	r0, r3, #21
24007c80:	d503      	bpl.n	24007c8a <HAL_MDMA_PollForTransfer+0x84>
        hmdma->ErrorCode |= HAL_MDMA_ERROR_ALIGNMENT;
24007c82:	6ea2      	ldr	r2, [r4, #104]	@ 0x68
24007c84:	f042 0210 	orr.w	r2, r2, #16
24007c88:	66a2      	str	r2, [r4, #104]	@ 0x68
      if((errorFlag & MDMA_CESR_BSE) != 0U)
24007c8a:	0519      	lsls	r1, r3, #20
24007c8c:	d503      	bpl.n	24007c96 <HAL_MDMA_PollForTransfer+0x90>
        hmdma->ErrorCode |= HAL_MDMA_ERROR_BLOCK_SIZE;
24007c8e:	6ea3      	ldr	r3, [r4, #104]	@ 0x68
24007c90:	f043 0320 	orr.w	r3, r3, #32
24007c94:	66a3      	str	r3, [r4, #104]	@ 0x68
      (void) HAL_MDMA_Abort(hmdma); /* if error then abort the current transfer */
24007c96:	4620      	mov	r0, r4
24007c98:	f7ff ff6b 	bl	24007b72 <HAL_MDMA_Abort>
      return HAL_ERROR;
24007c9c:	e7bf      	b.n	24007c1e <HAL_MDMA_PollForTransfer+0x18>
    if(Timeout != HAL_MAX_DELAY)
24007c9e:	1c72      	adds	r2, r6, #1
24007ca0:	d0ca      	beq.n	24007c38 <HAL_MDMA_PollForTransfer+0x32>
      if(((HAL_GetTick() - tickstart ) > Timeout) || (Timeout == 0U))
24007ca2:	f00a f8b1 	bl	24011e08 <HAL_GetTick>
24007ca6:	1bc0      	subs	r0, r0, r7
24007ca8:	42b0      	cmp	r0, r6
24007caa:	d801      	bhi.n	24007cb0 <HAL_MDMA_PollForTransfer+0xaa>
24007cac:	2e00      	cmp	r6, #0
24007cae:	d1c2      	bne.n	24007c36 <HAL_MDMA_PollForTransfer+0x30>
        hmdma->ErrorCode |= HAL_MDMA_ERROR_TIMEOUT;
24007cb0:	6ea3      	ldr	r3, [r4, #104]	@ 0x68
24007cb2:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
24007cb6:	e7ed      	b.n	24007c94 <HAL_MDMA_PollForTransfer+0x8e>
  else if(CompleteLevel == HAL_MDMA_BLOCK_TRANSFER)
24007cb8:	2d02      	cmp	r5, #2
24007cba:	d101      	bne.n	24007cc0 <HAL_MDMA_PollForTransfer+0xba>
    __HAL_MDMA_CLEAR_FLAG(hmdma, (MDMA_FLAG_BFTC | MDMA_FLAG_BT));
24007cbc:	2218      	movs	r2, #24
24007cbe:	e7c2      	b.n	24007c46 <HAL_MDMA_PollForTransfer+0x40>
  else if(CompleteLevel == HAL_MDMA_REPEAT_BLOCK_TRANSFER)
24007cc0:	2d03      	cmp	r5, #3
24007cc2:	d101      	bne.n	24007cc8 <HAL_MDMA_PollForTransfer+0xc2>
    __HAL_MDMA_CLEAR_FLAG(hmdma, (MDMA_FLAG_BFTC | MDMA_FLAG_BT | MDMA_FLAG_BRT));
24007cc4:	221c      	movs	r2, #28
24007cc6:	e7be      	b.n	24007c46 <HAL_MDMA_PollForTransfer+0x40>
  else if(CompleteLevel == HAL_MDMA_FULL_TRANSFER)
24007cc8:	2d00      	cmp	r5, #0
24007cca:	d1a8      	bne.n	24007c1e <HAL_MDMA_PollForTransfer+0x18>
    __HAL_MDMA_CLEAR_FLAG(hmdma, (MDMA_FLAG_BRT | MDMA_FLAG_BT | MDMA_FLAG_BFTC | MDMA_FLAG_CTC));
24007ccc:	221e      	movs	r2, #30
24007cce:	605a      	str	r2, [r3, #4]
    hmdma->State = HAL_MDMA_STATE_READY;
24007cd0:	2301      	movs	r3, #1
    __HAL_UNLOCK(hmdma);
24007cd2:	f884 503c 	strb.w	r5, [r4, #60]	@ 0x3c
    hmdma->State = HAL_MDMA_STATE_READY;
24007cd6:	f884 303d 	strb.w	r3, [r4, #61]	@ 0x3d
24007cda:	e7b5      	b.n	24007c48 <HAL_MDMA_PollForTransfer+0x42>
24007cdc:	24014178 	.word	0x24014178

24007ce0 <HAL_MDMA_GenerateSWRequest>:
  if(hmdma == NULL)
24007ce0:	4602      	mov	r2, r0
{
24007ce2:	b510      	push	{r4, lr}
  if(hmdma == NULL)
24007ce4:	b130      	cbz	r0, 24007cf4 <HAL_MDMA_GenerateSWRequest+0x14>
  request_mode = hmdma->Instance->CTCR & MDMA_CTCR_SWRM;
24007ce6:	6801      	ldr	r1, [r0, #0]
24007ce8:	690c      	ldr	r4, [r1, #16]
  if((hmdma->Instance->CCR &  MDMA_CCR_EN) == 0U)
24007cea:	68cb      	ldr	r3, [r1, #12]
24007cec:	07d8      	lsls	r0, r3, #31
24007cee:	d403      	bmi.n	24007cf8 <HAL_MDMA_GenerateSWRequest+0x18>
    hmdma->ErrorCode = HAL_MDMA_ERROR_NO_XFER;
24007cf0:	2380      	movs	r3, #128	@ 0x80
24007cf2:	6693      	str	r3, [r2, #104]	@ 0x68
    return HAL_ERROR;
24007cf4:	2001      	movs	r0, #1
}
24007cf6:	bd10      	pop	{r4, pc}
  else if(((hmdma->Instance->CISR &  MDMA_CISR_CRQA) != 0U) || (request_mode == 0U))
24007cf8:	6808      	ldr	r0, [r1, #0]
24007cfa:	f410 3080 	ands.w	r0, r0, #65536	@ 0x10000
24007cfe:	d101      	bne.n	24007d04 <HAL_MDMA_GenerateSWRequest+0x24>
24007d00:	0063      	lsls	r3, r4, #1
24007d02:	d402      	bmi.n	24007d0a <HAL_MDMA_GenerateSWRequest+0x2a>
    hmdma->ErrorCode = HAL_MDMA_ERROR_BUSY;
24007d04:	f44f 7380 	mov.w	r3, #256	@ 0x100
24007d08:	e7f3      	b.n	24007cf2 <HAL_MDMA_GenerateSWRequest+0x12>
    hmdma->Instance->CCR |= MDMA_CCR_SWRQ;
24007d0a:	68cb      	ldr	r3, [r1, #12]
24007d0c:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
24007d10:	60cb      	str	r3, [r1, #12]
    return HAL_OK;
24007d12:	e7f0      	b.n	24007cf6 <HAL_MDMA_GenerateSWRequest+0x16>

24007d14 <HAL_MDMA_IRQHandler>:
  __IO uint32_t count = 0;
24007d14:	2300      	movs	r3, #0
{
24007d16:	b537      	push	{r0, r1, r2, r4, r5, lr}
  __IO uint32_t count = 0;
24007d18:	9301      	str	r3, [sp, #4]
  if((MDMA->GISR0 & generalIntFlag) == 0U)
24007d1a:	f04f 42a4 	mov.w	r2, #1375731712	@ 0x52000000
  uint32_t timeout = SystemCoreClock / 9600U;
24007d1e:	4b58      	ldr	r3, [pc, #352]	@ (24007e80 <HAL_MDMA_IRQHandler+0x16c>)
{
24007d20:	4604      	mov	r4, r0
  generalIntFlag =  1UL << ((((uint32_t)hmdma->Instance - (uint32_t)(MDMA_Channel0))/HAL_MDMA_CHANNEL_SIZE) & 0x1FU);
24007d22:	2101      	movs	r1, #1
  uint32_t timeout = SystemCoreClock / 9600U;
24007d24:	681d      	ldr	r5, [r3, #0]
  generalIntFlag =  1UL << ((((uint32_t)hmdma->Instance - (uint32_t)(MDMA_Channel0))/HAL_MDMA_CHANNEL_SIZE) & 0x1FU);
24007d26:	6803      	ldr	r3, [r0, #0]
  if((MDMA->GISR0 & generalIntFlag) == 0U)
24007d28:	6810      	ldr	r0, [r2, #0]
  generalIntFlag =  1UL << ((((uint32_t)hmdma->Instance - (uint32_t)(MDMA_Channel0))/HAL_MDMA_CHANNEL_SIZE) & 0x1FU);
24007d2a:	f103 422e 	add.w	r2, r3, #2919235584	@ 0xae000000
24007d2e:	3a40      	subs	r2, #64	@ 0x40
24007d30:	f3c2 1284 	ubfx	r2, r2, #6, #5
24007d34:	fa01 f202 	lsl.w	r2, r1, r2
  if((MDMA->GISR0 & generalIntFlag) == 0U)
24007d38:	4202      	tst	r2, r0
24007d3a:	f000 809e 	beq.w	24007e7a <HAL_MDMA_IRQHandler+0x166>
  if((__HAL_MDMA_GET_FLAG(hmdma, MDMA_FLAG_TE) != 0U))
24007d3e:	681a      	ldr	r2, [r3, #0]
24007d40:	07d1      	lsls	r1, r2, #31
24007d42:	d529      	bpl.n	24007d98 <HAL_MDMA_IRQHandler+0x84>
    if(__HAL_MDMA_GET_IT_SOURCE(hmdma, MDMA_IT_TE) != 0U)
24007d44:	68da      	ldr	r2, [r3, #12]
24007d46:	0792      	lsls	r2, r2, #30
24007d48:	d526      	bpl.n	24007d98 <HAL_MDMA_IRQHandler+0x84>
      __HAL_MDMA_DISABLE_IT(hmdma, MDMA_IT_TE);
24007d4a:	68da      	ldr	r2, [r3, #12]
24007d4c:	f022 0202 	bic.w	r2, r2, #2
24007d50:	60da      	str	r2, [r3, #12]
      errorFlag = hmdma->Instance->CESR;
24007d52:	689a      	ldr	r2, [r3, #8]
        hmdma->ErrorCode |= HAL_MDMA_ERROR_READ_XFER;
24007d54:	6ea1      	ldr	r1, [r4, #104]	@ 0x68
      if((errorFlag & MDMA_CESR_TED) == 0U)
24007d56:	0610      	lsls	r0, r2, #24
        hmdma->ErrorCode |= HAL_MDMA_ERROR_READ_XFER;
24007d58:	bf54      	ite	pl
24007d5a:	f041 0101 	orrpl.w	r1, r1, #1
        hmdma->ErrorCode |= HAL_MDMA_ERROR_WRITE_XFER;
24007d5e:	f041 0102 	orrmi.w	r1, r1, #2
24007d62:	66a1      	str	r1, [r4, #104]	@ 0x68
      if((errorFlag & MDMA_CESR_TEMD) != 0U)
24007d64:	0591      	lsls	r1, r2, #22
24007d66:	d503      	bpl.n	24007d70 <HAL_MDMA_IRQHandler+0x5c>
        hmdma->ErrorCode |= HAL_MDMA_ERROR_MASK_DATA;
24007d68:	6ea1      	ldr	r1, [r4, #104]	@ 0x68
24007d6a:	f041 0104 	orr.w	r1, r1, #4
24007d6e:	66a1      	str	r1, [r4, #104]	@ 0x68
      if((errorFlag & MDMA_CESR_TELD) != 0U)
24007d70:	05d0      	lsls	r0, r2, #23
24007d72:	d503      	bpl.n	24007d7c <HAL_MDMA_IRQHandler+0x68>
        hmdma->ErrorCode |= HAL_MDMA_ERROR_LINKED_LIST;
24007d74:	6ea1      	ldr	r1, [r4, #104]	@ 0x68
24007d76:	f041 0108 	orr.w	r1, r1, #8
24007d7a:	66a1      	str	r1, [r4, #104]	@ 0x68
      if((errorFlag & MDMA_CESR_ASE) != 0U)
24007d7c:	0551      	lsls	r1, r2, #21
24007d7e:	d503      	bpl.n	24007d88 <HAL_MDMA_IRQHandler+0x74>
        hmdma->ErrorCode |= HAL_MDMA_ERROR_ALIGNMENT;
24007d80:	6ea1      	ldr	r1, [r4, #104]	@ 0x68
24007d82:	f041 0110 	orr.w	r1, r1, #16
24007d86:	66a1      	str	r1, [r4, #104]	@ 0x68
      if((errorFlag & MDMA_CESR_BSE) != 0U)
24007d88:	0512      	lsls	r2, r2, #20
24007d8a:	d503      	bpl.n	24007d94 <HAL_MDMA_IRQHandler+0x80>
        hmdma->ErrorCode |= HAL_MDMA_ERROR_BLOCK_SIZE;
24007d8c:	6ea2      	ldr	r2, [r4, #104]	@ 0x68
24007d8e:	f042 0220 	orr.w	r2, r2, #32
24007d92:	66a2      	str	r2, [r4, #104]	@ 0x68
      __HAL_MDMA_CLEAR_FLAG(hmdma, MDMA_FLAG_TE);
24007d94:	2201      	movs	r2, #1
24007d96:	605a      	str	r2, [r3, #4]
  if((__HAL_MDMA_GET_FLAG(hmdma, MDMA_FLAG_BFTC) != 0U))
24007d98:	681a      	ldr	r2, [r3, #0]
24007d9a:	06d0      	lsls	r0, r2, #27
24007d9c:	d508      	bpl.n	24007db0 <HAL_MDMA_IRQHandler+0x9c>
    if(__HAL_MDMA_GET_IT_SOURCE(hmdma, MDMA_IT_BFTC) != 0U)
24007d9e:	68da      	ldr	r2, [r3, #12]
24007da0:	0691      	lsls	r1, r2, #26
24007da2:	d505      	bpl.n	24007db0 <HAL_MDMA_IRQHandler+0x9c>
      __HAL_MDMA_CLEAR_FLAG(hmdma, MDMA_FLAG_BFTC);
24007da4:	2210      	movs	r2, #16
24007da6:	605a      	str	r2, [r3, #4]
      if(hmdma->XferBufferCpltCallback != NULL)
24007da8:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
24007daa:	b10b      	cbz	r3, 24007db0 <HAL_MDMA_IRQHandler+0x9c>
        hmdma->XferBufferCpltCallback(hmdma);
24007dac:	4620      	mov	r0, r4
24007dae:	4798      	blx	r3
  if((__HAL_MDMA_GET_FLAG(hmdma, MDMA_FLAG_BT) != 0U))
24007db0:	6823      	ldr	r3, [r4, #0]
24007db2:	681a      	ldr	r2, [r3, #0]
24007db4:	0712      	lsls	r2, r2, #28
24007db6:	d508      	bpl.n	24007dca <HAL_MDMA_IRQHandler+0xb6>
    if(__HAL_MDMA_GET_IT_SOURCE(hmdma, MDMA_IT_BT) != 0U)
24007db8:	68da      	ldr	r2, [r3, #12]
24007dba:	06d0      	lsls	r0, r2, #27
24007dbc:	d505      	bpl.n	24007dca <HAL_MDMA_IRQHandler+0xb6>
      __HAL_MDMA_CLEAR_FLAG(hmdma, MDMA_FLAG_BT);
24007dbe:	2208      	movs	r2, #8
24007dc0:	605a      	str	r2, [r3, #4]
      if(hmdma->XferBlockCpltCallback != NULL)
24007dc2:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
24007dc4:	b10b      	cbz	r3, 24007dca <HAL_MDMA_IRQHandler+0xb6>
        hmdma->XferBlockCpltCallback(hmdma);
24007dc6:	4620      	mov	r0, r4
24007dc8:	4798      	blx	r3
  if((__HAL_MDMA_GET_FLAG(hmdma, MDMA_FLAG_BRT) != 0U))
24007dca:	6823      	ldr	r3, [r4, #0]
24007dcc:	681a      	ldr	r2, [r3, #0]
24007dce:	0751      	lsls	r1, r2, #29
24007dd0:	d508      	bpl.n	24007de4 <HAL_MDMA_IRQHandler+0xd0>
    if(__HAL_MDMA_GET_IT_SOURCE(hmdma, MDMA_IT_BRT) != 0U)
24007dd2:	68da      	ldr	r2, [r3, #12]
24007dd4:	0712      	lsls	r2, r2, #28
24007dd6:	d505      	bpl.n	24007de4 <HAL_MDMA_IRQHandler+0xd0>
      __HAL_MDMA_CLEAR_FLAG(hmdma, MDMA_FLAG_BRT);
24007dd8:	2204      	movs	r2, #4
24007dda:	605a      	str	r2, [r3, #4]
      if(hmdma->XferRepeatBlockCpltCallback != NULL)
24007ddc:	6d23      	ldr	r3, [r4, #80]	@ 0x50
24007dde:	b10b      	cbz	r3, 24007de4 <HAL_MDMA_IRQHandler+0xd0>
        hmdma->XferRepeatBlockCpltCallback(hmdma);
24007de0:	4620      	mov	r0, r4
24007de2:	4798      	blx	r3
  if((__HAL_MDMA_GET_FLAG(hmdma, MDMA_FLAG_CTC) != 0U))
24007de4:	6823      	ldr	r3, [r4, #0]
24007de6:	681a      	ldr	r2, [r3, #0]
24007de8:	0790      	lsls	r0, r2, #30
24007dea:	d524      	bpl.n	24007e36 <HAL_MDMA_IRQHandler+0x122>
    if(__HAL_MDMA_GET_IT_SOURCE(hmdma, MDMA_IT_CTC) != 0U)
24007dec:	68da      	ldr	r2, [r3, #12]
24007dee:	0751      	lsls	r1, r2, #29
24007df0:	d521      	bpl.n	24007e36 <HAL_MDMA_IRQHandler+0x122>
      __HAL_MDMA_DISABLE_IT(hmdma, (MDMA_IT_TE | MDMA_IT_CTC | MDMA_IT_BT | MDMA_IT_BRT | MDMA_IT_BFTC));
24007df2:	68da      	ldr	r2, [r3, #12]
24007df4:	f022 023e 	bic.w	r2, r2, #62	@ 0x3e
24007df8:	60da      	str	r2, [r3, #12]
      if(HAL_MDMA_STATE_ABORT == hmdma->State)
24007dfa:	f894 203d 	ldrb.w	r2, [r4, #61]	@ 0x3d
24007dfe:	2a04      	cmp	r2, #4
24007e00:	f04f 0200 	mov.w	r2, #0
24007e04:	d10c      	bne.n	24007e20 <HAL_MDMA_IRQHandler+0x10c>
        hmdma->State = HAL_MDMA_STATE_READY;
24007e06:	2301      	movs	r3, #1
        __HAL_UNLOCK(hmdma);
24007e08:	f884 203c 	strb.w	r2, [r4, #60]	@ 0x3c
        hmdma->State = HAL_MDMA_STATE_READY;
24007e0c:	f884 303d 	strb.w	r3, [r4, #61]	@ 0x3d
        if(hmdma->XferAbortCallback != NULL)
24007e10:	6da3      	ldr	r3, [r4, #88]	@ 0x58
    if (hmdma->XferErrorCallback != NULL)
24007e12:	2b00      	cmp	r3, #0
24007e14:	d031      	beq.n	24007e7a <HAL_MDMA_IRQHandler+0x166>
      hmdma->XferErrorCallback(hmdma);
24007e16:	4620      	mov	r0, r4
}
24007e18:	b003      	add	sp, #12
24007e1a:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
      hmdma->XferErrorCallback(hmdma);
24007e1e:	4718      	bx	r3
      __HAL_MDMA_CLEAR_FLAG(hmdma, MDMA_FLAG_CTC);
24007e20:	2102      	movs	r1, #2
24007e22:	6059      	str	r1, [r3, #4]
      hmdma->State = HAL_MDMA_STATE_READY;
24007e24:	2301      	movs	r3, #1
      __HAL_UNLOCK(hmdma);
24007e26:	f884 203c 	strb.w	r2, [r4, #60]	@ 0x3c
      hmdma->State = HAL_MDMA_STATE_READY;
24007e2a:	f884 303d 	strb.w	r3, [r4, #61]	@ 0x3d
      if(hmdma->XferCpltCallback != NULL)
24007e2e:	6c63      	ldr	r3, [r4, #68]	@ 0x44
24007e30:	b10b      	cbz	r3, 24007e36 <HAL_MDMA_IRQHandler+0x122>
        hmdma->XferCpltCallback(hmdma);
24007e32:	4620      	mov	r0, r4
24007e34:	4798      	blx	r3
  if(hmdma->ErrorCode != HAL_MDMA_ERROR_NONE)
24007e36:	6ea3      	ldr	r3, [r4, #104]	@ 0x68
24007e38:	b1fb      	cbz	r3, 24007e7a <HAL_MDMA_IRQHandler+0x166>
  uint32_t timeout = SystemCoreClock / 9600U;
24007e3a:	f44f 5316 	mov.w	r3, #9600	@ 0x2580
24007e3e:	fbb5 f5f3 	udiv	r5, r5, r3
    hmdma->State = HAL_MDMA_STATE_ABORT;
24007e42:	2304      	movs	r3, #4
24007e44:	f884 303d 	strb.w	r3, [r4, #61]	@ 0x3d
    __HAL_MDMA_DISABLE(hmdma);
24007e48:	6823      	ldr	r3, [r4, #0]
24007e4a:	68da      	ldr	r2, [r3, #12]
24007e4c:	f022 0201 	bic.w	r2, r2, #1
24007e50:	60da      	str	r2, [r3, #12]
      if (++count > timeout)
24007e52:	9a01      	ldr	r2, [sp, #4]
24007e54:	3201      	adds	r2, #1
24007e56:	42aa      	cmp	r2, r5
24007e58:	9201      	str	r2, [sp, #4]
24007e5a:	d802      	bhi.n	24007e62 <HAL_MDMA_IRQHandler+0x14e>
    while((hmdma->Instance->CCR & MDMA_CCR_EN) != 0U);
24007e5c:	68da      	ldr	r2, [r3, #12]
24007e5e:	07d2      	lsls	r2, r2, #31
24007e60:	d4f7      	bmi.n	24007e52 <HAL_MDMA_IRQHandler+0x13e>
    __HAL_UNLOCK(hmdma);
24007e62:	2200      	movs	r2, #0
24007e64:	f884 203c 	strb.w	r2, [r4, #60]	@ 0x3c
    if((hmdma->Instance->CCR & MDMA_CCR_EN) != 0U)
24007e68:	68db      	ldr	r3, [r3, #12]
24007e6a:	07db      	lsls	r3, r3, #31
      hmdma->State = HAL_MDMA_STATE_ERROR;
24007e6c:	bf4c      	ite	mi
24007e6e:	2303      	movmi	r3, #3
      hmdma->State = HAL_MDMA_STATE_READY;
24007e70:	2301      	movpl	r3, #1
24007e72:	f884 303d 	strb.w	r3, [r4, #61]	@ 0x3d
    if (hmdma->XferErrorCallback != NULL)
24007e76:	6d63      	ldr	r3, [r4, #84]	@ 0x54
24007e78:	e7cb      	b.n	24007e12 <HAL_MDMA_IRQHandler+0xfe>
}
24007e7a:	b003      	add	sp, #12
24007e7c:	bd30      	pop	{r4, r5, pc}
24007e7e:	bf00      	nop
24007e80:	24000518 	.word	0x24000518

24007e84 <HAL_MDMA_GetState>:
  return hmdma->State;
24007e84:	f890 003d 	ldrb.w	r0, [r0, #61]	@ 0x3d
}
24007e88:	4770      	bx	lr

24007e8a <HAL_MDMA_GetError>:
  return hmdma->ErrorCode;
24007e8a:	6e80      	ldr	r0, [r0, #104]	@ 0x68
}
24007e8c:	4770      	bx	lr
24007e8e:	bf00      	nop

24007e90 <HAL_PWR_DeInit>:
  *         products.
  * @retval None.
  */
void HAL_PWR_DeInit (void)
{
}
24007e90:	4770      	bx	lr

24007e92 <HAL_PWR_EnableBkUpAccess>:
  * @retval None.
  */
void HAL_PWR_EnableBkUpAccess (void)
{
  /* Enable access to RTC and backup registers */
  SET_BIT (PWR->CR1, PWR_CR1_DBP);
24007e92:	4a03      	ldr	r2, [pc, #12]	@ (24007ea0 <HAL_PWR_EnableBkUpAccess+0xe>)
24007e94:	6813      	ldr	r3, [r2, #0]
24007e96:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
24007e9a:	6013      	str	r3, [r2, #0]
}
24007e9c:	4770      	bx	lr
24007e9e:	bf00      	nop
24007ea0:	58024800 	.word	0x58024800

24007ea4 <HAL_PWR_DisableBkUpAccess>:
  * @retval None.
  */
void HAL_PWR_DisableBkUpAccess (void)
{
  /* Disable access to RTC and backup registers */
  CLEAR_BIT (PWR->CR1, PWR_CR1_DBP);
24007ea4:	4a02      	ldr	r2, [pc, #8]	@ (24007eb0 <HAL_PWR_DisableBkUpAccess+0xc>)
24007ea6:	6813      	ldr	r3, [r2, #0]
24007ea8:	f423 7380 	bic.w	r3, r3, #256	@ 0x100
24007eac:	6013      	str	r3, [r2, #0]
}
24007eae:	4770      	bx	lr
24007eb0:	58024800 	.word	0x58024800

24007eb4 <HAL_PWR_ConfigPVD>:
  * @retval None.
  */
void HAL_PWR_ConfigPVD (PWR_PVDTypeDef *sConfigPVD)
{
  /* Check the PVD configuration parameter */
  if (sConfigPVD == NULL)
24007eb4:	2800      	cmp	r0, #0
24007eb6:	d03f      	beq.n	24007f38 <HAL_PWR_ConfigPVD+0x84>
  /* Check the parameters */
  assert_param (IS_PWR_PVD_LEVEL (sConfigPVD->PVDLevel));
  assert_param (IS_PWR_PVD_MODE (sConfigPVD->Mode));

  /* Set PLS[7:5] bits according to PVDLevel value */
  MODIFY_REG (PWR->CR1, PWR_CR1_PLS, sConfigPVD->PVDLevel);
24007eb8:	4a20      	ldr	r2, [pc, #128]	@ (24007f3c <HAL_PWR_ConfigPVD+0x88>)
24007eba:	6801      	ldr	r1, [r0, #0]
24007ebc:	6813      	ldr	r3, [r2, #0]
24007ebe:	f023 03e0 	bic.w	r3, r3, #224	@ 0xe0
24007ec2:	430b      	orrs	r3, r1
24007ec4:	6013      	str	r3, [r2, #0]

  /* Clear previous config */
#if !defined (DUAL_CORE)
  __HAL_PWR_PVD_EXTI_DISABLE_EVENT ();
24007ec6:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
24007eca:	f8d3 2084 	ldr.w	r2, [r3, #132]	@ 0x84
24007ece:	f422 3280 	bic.w	r2, r2, #65536	@ 0x10000
24007ed2:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84
  __HAL_PWR_PVD_EXTI_DISABLE_IT ();
24007ed6:	f8d3 2080 	ldr.w	r2, [r3, #128]	@ 0x80
24007eda:	f422 3280 	bic.w	r2, r2, #65536	@ 0x10000
24007ede:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
#endif /* !defined (DUAL_CORE) */

  __HAL_PWR_PVD_EXTI_DISABLE_RISING_EDGE ();
24007ee2:	681a      	ldr	r2, [r3, #0]
24007ee4:	f422 3280 	bic.w	r2, r2, #65536	@ 0x10000
24007ee8:	601a      	str	r2, [r3, #0]
  __HAL_PWR_PVD_EXTI_DISABLE_FALLING_EDGE ();
24007eea:	685a      	ldr	r2, [r3, #4]
24007eec:	f422 3280 	bic.w	r2, r2, #65536	@ 0x10000
24007ef0:	605a      	str	r2, [r3, #4]

#if !defined (DUAL_CORE)
  /* Interrupt mode configuration */
  if ((sConfigPVD->Mode & PVD_MODE_IT) == PVD_MODE_IT)
24007ef2:	6842      	ldr	r2, [r0, #4]
24007ef4:	03d1      	lsls	r1, r2, #15
24007ef6:	d505      	bpl.n	24007f04 <HAL_PWR_ConfigPVD+0x50>
  {
    __HAL_PWR_PVD_EXTI_ENABLE_IT ();
24007ef8:	f8d3 1080 	ldr.w	r1, [r3, #128]	@ 0x80
24007efc:	f441 3180 	orr.w	r1, r1, #65536	@ 0x10000
24007f00:	f8c3 1080 	str.w	r1, [r3, #128]	@ 0x80
  }

  /* Event mode configuration */
  if ((sConfigPVD->Mode & PVD_MODE_EVT) == PVD_MODE_EVT)
24007f04:	0390      	lsls	r0, r2, #14
24007f06:	d507      	bpl.n	24007f18 <HAL_PWR_ConfigPVD+0x64>
  {
    __HAL_PWR_PVD_EXTI_ENABLE_EVENT ();
24007f08:	f04f 41b0 	mov.w	r1, #1476395008	@ 0x58000000
24007f0c:	f8d1 3084 	ldr.w	r3, [r1, #132]	@ 0x84
24007f10:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
24007f14:	f8c1 3084 	str.w	r3, [r1, #132]	@ 0x84
  }
#endif /* !defined (DUAL_CORE) */

  /* Rising edge configuration */
  if ((sConfigPVD->Mode & PVD_RISING_EDGE) == PVD_RISING_EDGE)
24007f18:	07d1      	lsls	r1, r2, #31
24007f1a:	d505      	bpl.n	24007f28 <HAL_PWR_ConfigPVD+0x74>
  {
    __HAL_PWR_PVD_EXTI_ENABLE_RISING_EDGE ();
24007f1c:	f04f 41b0 	mov.w	r1, #1476395008	@ 0x58000000
24007f20:	680b      	ldr	r3, [r1, #0]
24007f22:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
24007f26:	600b      	str	r3, [r1, #0]
  }

  /* Falling edge configuration */
  if ((sConfigPVD->Mode & PVD_FALLING_EDGE) == PVD_FALLING_EDGE)
24007f28:	0793      	lsls	r3, r2, #30
24007f2a:	d505      	bpl.n	24007f38 <HAL_PWR_ConfigPVD+0x84>
  {
    __HAL_PWR_PVD_EXTI_ENABLE_FALLING_EDGE ();
24007f2c:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
24007f30:	6853      	ldr	r3, [r2, #4]
24007f32:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
24007f36:	6053      	str	r3, [r2, #4]
  }
}
24007f38:	4770      	bx	lr
24007f3a:	bf00      	nop
24007f3c:	58024800 	.word	0x58024800

24007f40 <HAL_PWR_EnablePVD>:
  * @retval None.
  */
void HAL_PWR_EnablePVD (void)
{
  /* Enable the power voltage detector */
  SET_BIT (PWR->CR1, PWR_CR1_PVDEN);
24007f40:	4a02      	ldr	r2, [pc, #8]	@ (24007f4c <HAL_PWR_EnablePVD+0xc>)
24007f42:	6813      	ldr	r3, [r2, #0]
24007f44:	f043 0310 	orr.w	r3, r3, #16
24007f48:	6013      	str	r3, [r2, #0]
}
24007f4a:	4770      	bx	lr
24007f4c:	58024800 	.word	0x58024800

24007f50 <HAL_PWR_DisablePVD>:
  * @retval None.
  */
void HAL_PWR_DisablePVD (void)
{
  /* Disable the power voltage detector */
  CLEAR_BIT (PWR->CR1, PWR_CR1_PVDEN);
24007f50:	4a02      	ldr	r2, [pc, #8]	@ (24007f5c <HAL_PWR_DisablePVD+0xc>)
24007f52:	6813      	ldr	r3, [r2, #0]
24007f54:	f023 0310 	bic.w	r3, r3, #16
24007f58:	6013      	str	r3, [r2, #0]
}
24007f5a:	4770      	bx	lr
24007f5c:	58024800 	.word	0x58024800

24007f60 <HAL_PWR_EnableWakeUpPin>:

  /*
     Enable and Specify the Wake-Up pin polarity and the pull configuration
     for the event detection (rising or falling edge).
  */
  MODIFY_REG (PWR->WKUPEPR, PWR_EWUP_MASK, WakeUpPinPolarity);
24007f60:	4a03      	ldr	r2, [pc, #12]	@ (24007f70 <HAL_PWR_EnableWakeUpPin+0x10>)
24007f62:	4b04      	ldr	r3, [pc, #16]	@ (24007f74 <HAL_PWR_EnableWakeUpPin+0x14>)
24007f64:	6a91      	ldr	r1, [r2, #40]	@ 0x28
24007f66:	400b      	ands	r3, r1
24007f68:	4303      	orrs	r3, r0
24007f6a:	6293      	str	r3, [r2, #40]	@ 0x28
}
24007f6c:	4770      	bx	lr
24007f6e:	bf00      	nop
24007f70:	58024800 	.word	0x58024800
24007f74:	f000c0c0 	.word	0xf000c0c0

24007f78 <HAL_PWR_DisableWakeUpPin>:
{
  /* Check the parameters */
  assert_param (IS_PWR_WAKEUP_PIN (WakeUpPinx));

  /* Disable the wake up pin selected */
  CLEAR_BIT (PWR->WKUPEPR, (PWR_WKUPEPR_WKUPEN & WakeUpPinx));
24007f78:	4a03      	ldr	r2, [pc, #12]	@ (24007f88 <HAL_PWR_DisableWakeUpPin+0x10>)
24007f7a:	f000 003f 	and.w	r0, r0, #63	@ 0x3f
24007f7e:	6a93      	ldr	r3, [r2, #40]	@ 0x28
24007f80:	ea23 0300 	bic.w	r3, r3, r0
24007f84:	6293      	str	r3, [r2, #40]	@ 0x28
}
24007f86:	4770      	bx	lr
24007f88:	58024800 	.word	0x58024800

24007f8c <HAL_PWR_EnterSLEEPMode>:
  /* Check the parameters */
  assert_param (IS_PWR_REGULATOR (Regulator));
  assert_param (IS_PWR_SLEEP_ENTRY (SLEEPEntry));

  /* Clear SLEEPDEEP bit of Cortex System Control Register */
  CLEAR_BIT (SCB->SCR, SCB_SCR_SLEEPDEEP_Msk);
24007f8c:	4a05      	ldr	r2, [pc, #20]	@ (24007fa4 <HAL_PWR_EnterSLEEPMode+0x18>)

  /* Select SLEEP mode entry */
  if (SLEEPEntry == PWR_SLEEPENTRY_WFI)
24007f8e:	2901      	cmp	r1, #1
  CLEAR_BIT (SCB->SCR, SCB_SCR_SLEEPDEEP_Msk);
24007f90:	6913      	ldr	r3, [r2, #16]
24007f92:	f023 0304 	bic.w	r3, r3, #4
24007f96:	6113      	str	r3, [r2, #16]
  if (SLEEPEntry == PWR_SLEEPENTRY_WFI)
24007f98:	d101      	bne.n	24007f9e <HAL_PWR_EnterSLEEPMode+0x12>
  {
    /* Request Wait For Interrupt */
    __WFI ();
24007f9a:	bf30      	wfi
24007f9c:	4770      	bx	lr
  }
  else
  {
    /* Request Wait For Event */
    __WFE ();
24007f9e:	bf20      	wfe
  }
}
24007fa0:	4770      	bx	lr
24007fa2:	bf00      	nop
24007fa4:	e000ed00 	.word	0xe000ed00

24007fa8 <HAL_PWR_EnterSTOPMode>:
  /* Check the parameters */
  assert_param (IS_PWR_REGULATOR (Regulator));
  assert_param (IS_PWR_STOP_ENTRY (STOPEntry));

  /* Select the regulator state in STOP mode */
  MODIFY_REG (PWR->CR1, PWR_CR1_LPDS, Regulator);
24007fa8:	4b10      	ldr	r3, [pc, #64]	@ (24007fec <HAL_PWR_EnterSTOPMode+0x44>)
24007faa:	681a      	ldr	r2, [r3, #0]
24007fac:	f022 0201 	bic.w	r2, r2, #1
24007fb0:	4302      	orrs	r2, r0
24007fb2:	601a      	str	r2, [r3, #0]
    /* Keep DSTOP mode when Cortex-M4 enters DEEP-SLEEP */
    CLEAR_BIT (PWR->CPUCR, (PWR_CPUCR_PDDS_D2 | PWR_CPUCR_PDDS_D3));
  }
#else /* Single core devices */
  /* Keep DSTOP mode when Cortex-M7 enter in DEEP-SLEEP */
  CLEAR_BIT (PWR->CPUCR, (PWR_CPUCR_PDDS_D1 | PWR_CPUCR_PDDS_D3));
24007fb4:	691a      	ldr	r2, [r3, #16]
24007fb6:	f022 0205 	bic.w	r2, r2, #5
24007fba:	611a      	str	r2, [r3, #16]

#if defined (PWR_CPUCR_PDDS_D2)
  /* Keep DSTOP mode when Cortex-M7 enter in DEEP-SLEEP */
  CLEAR_BIT (PWR->CPUCR, PWR_CPUCR_PDDS_D2);
24007fbc:	691a      	ldr	r2, [r3, #16]
24007fbe:	f022 0202 	bic.w	r2, r2, #2
24007fc2:	611a      	str	r2, [r3, #16]
#endif /* PWR_CPUCR_PDDS_D2 */
#endif /* defined (DUAL_CORE) */

  /* Set SLEEPDEEP bit of Cortex System Control Register */
  SET_BIT (SCB->SCR, SCB_SCR_SLEEPDEEP_Msk);
24007fc4:	4b0a      	ldr	r3, [pc, #40]	@ (24007ff0 <HAL_PWR_EnterSTOPMode+0x48>)
24007fc6:	691a      	ldr	r2, [r3, #16]
24007fc8:	f042 0204 	orr.w	r2, r2, #4
24007fcc:	611a      	str	r2, [r3, #16]
  __ASM volatile ("dsb 0xF":::"memory");
24007fce:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
24007fd2:	f3bf 8f6f 	isb	sy
  /* Ensure that all instructions are done before entering STOP mode */
  __DSB ();
  __ISB ();

  /* Select STOP mode entry */
  if (STOPEntry == PWR_STOPENTRY_WFI)
24007fd6:	2901      	cmp	r1, #1
24007fd8:	d105      	bne.n	24007fe6 <HAL_PWR_EnterSTOPMode+0x3e>
  {
    /* Request Wait For Interrupt */
    __WFI ();
24007fda:	bf30      	wfi
    /* Request Wait For Event */
    __WFE ();
  }

  /* Clear SLEEPDEEP bit of Cortex-Mx in the System Control Register */
  CLEAR_BIT (SCB->SCR, SCB_SCR_SLEEPDEEP_Msk);
24007fdc:	691a      	ldr	r2, [r3, #16]
24007fde:	f022 0204 	bic.w	r2, r2, #4
24007fe2:	611a      	str	r2, [r3, #16]
}
24007fe4:	4770      	bx	lr
    __WFE ();
24007fe6:	bf20      	wfe
24007fe8:	e7f8      	b.n	24007fdc <HAL_PWR_EnterSTOPMode+0x34>
24007fea:	bf00      	nop
24007fec:	58024800 	.word	0x58024800
24007ff0:	e000ed00 	.word	0xe000ed00

24007ff4 <HAL_PWR_EnterSTANDBYMode>:
    SET_BIT (PWR->CPUCR, (PWR_CPUCR_PDDS_D2 | PWR_CPUCR_PDDS_D3));
    SET_BIT (PWR->CPU2CR, (PWR_CPU2CR_PDDS_D2 | PWR_CPU2CR_PDDS_D3));
  }
#else /* Single core devices */
  /* Enter DSTANDBY mode when Cortex-M7 enters DEEP-SLEEP */
  SET_BIT (PWR->CPUCR, (PWR_CPUCR_PDDS_D1 | PWR_CPUCR_PDDS_D3));
24007ff4:	4b09      	ldr	r3, [pc, #36]	@ (2400801c <HAL_PWR_EnterSTANDBYMode+0x28>)
24007ff6:	691a      	ldr	r2, [r3, #16]
24007ff8:	f042 0205 	orr.w	r2, r2, #5
24007ffc:	611a      	str	r2, [r3, #16]

#if defined (PWR_CPUCR_PDDS_D2)
  /* Enter DSTANDBY mode when Cortex-M7 enters DEEP-SLEEP */
  SET_BIT (PWR->CPUCR, PWR_CPUCR_PDDS_D2);
24007ffe:	691a      	ldr	r2, [r3, #16]
24008000:	f042 0202 	orr.w	r2, r2, #2
24008004:	611a      	str	r2, [r3, #16]
#endif /* PWR_CPUCR_PDDS_D2 */
#endif /* defined (DUAL_CORE) */

  /* Set SLEEPDEEP bit of Cortex System Control Register */
  SET_BIT (SCB->SCR, SCB_SCR_SLEEPDEEP_Msk);
24008006:	4a06      	ldr	r2, [pc, #24]	@ (24008020 <HAL_PWR_EnterSTANDBYMode+0x2c>)
24008008:	6913      	ldr	r3, [r2, #16]
2400800a:	f043 0304 	orr.w	r3, r3, #4
2400800e:	6113      	str	r3, [r2, #16]
  __ASM volatile ("dsb 0xF":::"memory");
24008010:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
24008014:	f3bf 8f6f 	isb	sy
#if defined (__CC_ARM)
  __force_stores();
#endif /* defined (__CC_ARM) */

  /* Request Wait For Interrupt */
  __WFI ();
24008018:	bf30      	wfi
}
2400801a:	4770      	bx	lr
2400801c:	58024800 	.word	0x58024800
24008020:	e000ed00 	.word	0xe000ed00

24008024 <HAL_PWR_EnableSleepOnExit>:
  * @retval None.
  */
void HAL_PWR_EnableSleepOnExit (void)
{
  /* Set SLEEPONEXIT bit of Cortex-Mx System Control Register */
  SET_BIT (SCB->SCR, SCB_SCR_SLEEPONEXIT_Msk);
24008024:	4a02      	ldr	r2, [pc, #8]	@ (24008030 <HAL_PWR_EnableSleepOnExit+0xc>)
24008026:	6913      	ldr	r3, [r2, #16]
24008028:	f043 0302 	orr.w	r3, r3, #2
2400802c:	6113      	str	r3, [r2, #16]
}
2400802e:	4770      	bx	lr
24008030:	e000ed00 	.word	0xe000ed00

24008034 <HAL_PWR_DisableSleepOnExit>:
  * @retval None
  */
void HAL_PWR_DisableSleepOnExit (void)
{
  /* Clear SLEEPONEXIT bit of Cortex-Mx System Control Register */
  CLEAR_BIT (SCB->SCR, SCB_SCR_SLEEPONEXIT_Msk);
24008034:	4a02      	ldr	r2, [pc, #8]	@ (24008040 <HAL_PWR_DisableSleepOnExit+0xc>)
24008036:	6913      	ldr	r3, [r2, #16]
24008038:	f023 0302 	bic.w	r3, r3, #2
2400803c:	6113      	str	r3, [r2, #16]
}
2400803e:	4770      	bx	lr
24008040:	e000ed00 	.word	0xe000ed00

24008044 <HAL_PWR_EnableSEVOnPend>:
  * @retval None.
  */
void HAL_PWR_EnableSEVOnPend (void)
{
  /* Set SEVONPEND bit of Cortex-Mx System Control Register */
  SET_BIT (SCB->SCR, SCB_SCR_SEVONPEND_Msk);
24008044:	4a02      	ldr	r2, [pc, #8]	@ (24008050 <HAL_PWR_EnableSEVOnPend+0xc>)
24008046:	6913      	ldr	r3, [r2, #16]
24008048:	f043 0310 	orr.w	r3, r3, #16
2400804c:	6113      	str	r3, [r2, #16]
}
2400804e:	4770      	bx	lr
24008050:	e000ed00 	.word	0xe000ed00

24008054 <HAL_PWR_DisableSEVOnPend>:
  * @retval None.
  */
void HAL_PWR_DisableSEVOnPend (void)
{
  /* Clear SEVONPEND bit of Cortex System Control Register */
  CLEAR_BIT (SCB->SCR, SCB_SCR_SEVONPEND_Msk);
24008054:	4a02      	ldr	r2, [pc, #8]	@ (24008060 <HAL_PWR_DisableSEVOnPend+0xc>)
24008056:	6913      	ldr	r3, [r2, #16]
24008058:	f023 0310 	bic.w	r3, r3, #16
2400805c:	6113      	str	r3, [r2, #16]
}
2400805e:	4770      	bx	lr
24008060:	e000ed00 	.word	0xe000ed00

24008064 <HAL_PWR_PVDCallback>:
__weak void HAL_PWR_PVDCallback (void)
{
  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_PWR_PVDCallback can be implemented in the user file
  */
}
24008064:	4770      	bx	lr

24008066 <HAL_PWR_PVD_IRQHandler>:
{
24008066:	b508      	push	{r3, lr}
  if (__HAL_PWR_PVD_EXTI_GET_FLAG () != 0U)
24008068:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
2400806c:	f8d3 2088 	ldr.w	r2, [r3, #136]	@ 0x88
24008070:	03d2      	lsls	r2, r2, #15
24008072:	d507      	bpl.n	24008084 <HAL_PWR_PVD_IRQHandler+0x1e>
    __HAL_PWR_PVD_EXTI_CLEAR_FLAG ();
24008074:	f8d3 2088 	ldr.w	r2, [r3, #136]	@ 0x88
24008078:	f442 3280 	orr.w	r2, r2, #65536	@ 0x10000
2400807c:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88
    HAL_PWR_PVDCallback ();
24008080:	f7ff fff0 	bl	24008064 <HAL_PWR_PVDCallback>
}
24008084:	bd08      	pop	{r3, pc}
24008086:	bf00      	nop

24008088 <HAL_PWREx_ConfigSupply>:
  *         PWR_SMPS_2V5_SUPPLIES_EXT are used only for lines that supports SMPS
  *         regulator.
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_PWREx_ConfigSupply (uint32_t SupplySource)
{
24008088:	b538      	push	{r3, r4, r5, lr}
  /* Check the parameters */
  assert_param (IS_PWR_SUPPLY (SupplySource));

  /* Check if supply source was configured */
#if defined (PWR_FLAG_SCUEN)
  if (__HAL_PWR_GET_FLAG (PWR_FLAG_SCUEN) == 0U)
2400808a:	4c10      	ldr	r4, [pc, #64]	@ (240080cc <HAL_PWREx_ConfigSupply+0x44>)
2400808c:	68e3      	ldr	r3, [r4, #12]
2400808e:	f013 0f04 	tst.w	r3, #4
#else
  if ((PWR->CR3 & (PWR_CR3_SMPSEN | PWR_CR3_LDOEN | PWR_CR3_BYPASS)) != (PWR_CR3_SMPSEN | PWR_CR3_LDOEN))
#endif /* defined (PWR_FLAG_SCUEN) */
  {
    /* Check supply configuration */
    if ((PWR->CR3 & PWR_SUPPLY_CONFIG_MASK) != SupplySource)
24008092:	68e3      	ldr	r3, [r4, #12]
  if (__HAL_PWR_GET_FLAG (PWR_FLAG_SCUEN) == 0U)
24008094:	d105      	bne.n	240080a2 <HAL_PWREx_ConfigSupply+0x1a>
    if ((PWR->CR3 & PWR_SUPPLY_CONFIG_MASK) != SupplySource)
24008096:	f003 0307 	and.w	r3, r3, #7
2400809a:	1a18      	subs	r0, r3, r0
2400809c:	bf18      	it	ne
2400809e:	2001      	movne	r0, #1
    }
  }
#endif /* defined (SMPS) */

  return HAL_OK;
}
240080a0:	bd38      	pop	{r3, r4, r5, pc}
  MODIFY_REG (PWR->CR3, PWR_SUPPLY_CONFIG_MASK, SupplySource);
240080a2:	f023 0307 	bic.w	r3, r3, #7
240080a6:	4318      	orrs	r0, r3
240080a8:	60e0      	str	r0, [r4, #12]
  tickstart = HAL_GetTick ();
240080aa:	f009 fead 	bl	24011e08 <HAL_GetTick>
240080ae:	4605      	mov	r5, r0
  while (__HAL_PWR_GET_FLAG (PWR_FLAG_ACTVOSRDY) == 0U)
240080b0:	6863      	ldr	r3, [r4, #4]
240080b2:	049b      	lsls	r3, r3, #18
240080b4:	d501      	bpl.n	240080ba <HAL_PWREx_ConfigSupply+0x32>
      return HAL_OK;
240080b6:	2000      	movs	r0, #0
240080b8:	e7f2      	b.n	240080a0 <HAL_PWREx_ConfigSupply+0x18>
    if ((HAL_GetTick () - tickstart) > PWR_FLAG_SETTING_DELAY)
240080ba:	f009 fea5 	bl	24011e08 <HAL_GetTick>
240080be:	1b40      	subs	r0, r0, r5
240080c0:	f5b0 7f7a 	cmp.w	r0, #1000	@ 0x3e8
240080c4:	d9f4      	bls.n	240080b0 <HAL_PWREx_ConfigSupply+0x28>
      return HAL_ERROR;
240080c6:	2001      	movs	r0, #1
240080c8:	e7ea      	b.n	240080a0 <HAL_PWREx_ConfigSupply+0x18>
240080ca:	bf00      	nop
240080cc:	58024800 	.word	0x58024800

240080d0 <HAL_PWREx_GetSupplyConfig>:
  * @brief Get the power supply configuration.
  * @retval The supply configuration.
  */
uint32_t HAL_PWREx_GetSupplyConfig (void)
{
  return (PWR->CR3 & PWR_SUPPLY_CONFIG_MASK);
240080d0:	4b02      	ldr	r3, [pc, #8]	@ (240080dc <HAL_PWREx_GetSupplyConfig+0xc>)
240080d2:	68d8      	ldr	r0, [r3, #12]
}
240080d4:	f000 0007 	and.w	r0, r0, #7
240080d8:	4770      	bx	lr
240080da:	bf00      	nop
240080dc:	58024800 	.word	0x58024800

240080e0 <HAL_PWREx_ControlVoltageScaling>:
  *            @arg PWR_REGULATOR_VOLTAGE_SCALE3 : Regulator voltage output
  *                                                range 3 mode.
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_PWREx_ControlVoltageScaling (uint32_t VoltageScaling)
{
240080e0:	b570      	push	{r4, r5, r6, lr}

  /* Check the parameters */
  assert_param (IS_PWR_REGULATOR_VOLTAGE (VoltageScaling));

  /* Get the voltage scaling  */
  if ((PWR->CSR1 & PWR_CSR1_ACTVOS) == VoltageScaling)
240080e2:	4c2a      	ldr	r4, [pc, #168]	@ (2400818c <HAL_PWREx_ControlVoltageScaling+0xac>)
{
240080e4:	4605      	mov	r5, r0
  if ((PWR->CSR1 & PWR_CSR1_ACTVOS) == VoltageScaling)
240080e6:	6863      	ldr	r3, [r4, #4]
240080e8:	f403 4340 	and.w	r3, r3, #49152	@ 0xc000
240080ec:	4283      	cmp	r3, r0
240080ee:	d101      	bne.n	240080f4 <HAL_PWREx_ControlVoltageScaling+0x14>
  {
    /* Old and new voltage scaling configuration match : nothing to do */
    return HAL_OK;
240080f0:	2000      	movs	r0, #0
      return HAL_ERROR;
    }
  }

  return HAL_OK;
}
240080f2:	bd70      	pop	{r4, r5, r6, pc}
  if (VoltageScaling == PWR_REGULATOR_VOLTAGE_SCALE0)
240080f4:	bb40      	cbnz	r0, 24008148 <HAL_PWREx_ControlVoltageScaling+0x68>
    if ((PWR->CR3 & PWR_CR3_LDOEN) == PWR_CR3_LDOEN)
240080f6:	68e3      	ldr	r3, [r4, #12]
240080f8:	079d      	lsls	r5, r3, #30
240080fa:	d401      	bmi.n	24008100 <HAL_PWREx_ControlVoltageScaling+0x20>
          return HAL_ERROR;
240080fc:	2001      	movs	r0, #1
240080fe:	e7f8      	b.n	240080f2 <HAL_PWREx_ControlVoltageScaling+0x12>
      MODIFY_REG (PWR->D3CR, PWR_D3CR_VOS, PWR_REGULATOR_VOLTAGE_SCALE1);
24008100:	69a3      	ldr	r3, [r4, #24]
24008102:	f443 4340 	orr.w	r3, r3, #49152	@ 0xc000
24008106:	61a3      	str	r3, [r4, #24]
      tickstart = HAL_GetTick ();
24008108:	f009 fe7e 	bl	24011e08 <HAL_GetTick>
2400810c:	4605      	mov	r5, r0
      while (__HAL_PWR_GET_FLAG (PWR_FLAG_ACTVOSRDY) == 0U)
2400810e:	6863      	ldr	r3, [r4, #4]
24008110:	0498      	lsls	r0, r3, #18
24008112:	d512      	bpl.n	2400813a <HAL_PWREx_ControlVoltageScaling+0x5a>
      SET_BIT (SYSCFG->PWRCR, SYSCFG_PWRCR_ODEN);
24008114:	4a1e      	ldr	r2, [pc, #120]	@ (24008190 <HAL_PWREx_ControlVoltageScaling+0xb0>)
24008116:	6ad3      	ldr	r3, [r2, #44]	@ 0x2c
24008118:	f043 0301 	orr.w	r3, r3, #1
2400811c:	62d3      	str	r3, [r2, #44]	@ 0x2c
  tickstart = HAL_GetTick ();
2400811e:	f009 fe73 	bl	24011e08 <HAL_GetTick>
  while (__HAL_PWR_GET_FLAG (PWR_FLAG_ACTVOSRDY) == 0U)
24008122:	4d1a      	ldr	r5, [pc, #104]	@ (2400818c <HAL_PWREx_ControlVoltageScaling+0xac>)
  tickstart = HAL_GetTick ();
24008124:	4604      	mov	r4, r0
  while (__HAL_PWR_GET_FLAG (PWR_FLAG_ACTVOSRDY) == 0U)
24008126:	686b      	ldr	r3, [r5, #4]
24008128:	049b      	lsls	r3, r3, #18
2400812a:	d4e1      	bmi.n	240080f0 <HAL_PWREx_ControlVoltageScaling+0x10>
    if ((HAL_GetTick() - tickstart) > PWR_FLAG_SETTING_DELAY)
2400812c:	f009 fe6c 	bl	24011e08 <HAL_GetTick>
24008130:	1b00      	subs	r0, r0, r4
24008132:	f5b0 7f7a 	cmp.w	r0, #1000	@ 0x3e8
24008136:	d9f6      	bls.n	24008126 <HAL_PWREx_ControlVoltageScaling+0x46>
24008138:	e7e0      	b.n	240080fc <HAL_PWREx_ControlVoltageScaling+0x1c>
        if ((HAL_GetTick () - tickstart) > PWR_FLAG_SETTING_DELAY)
2400813a:	f009 fe65 	bl	24011e08 <HAL_GetTick>
2400813e:	1b40      	subs	r0, r0, r5
24008140:	f5b0 7f7a 	cmp.w	r0, #1000	@ 0x3e8
24008144:	d9e3      	bls.n	2400810e <HAL_PWREx_ControlVoltageScaling+0x2e>
24008146:	e7d9      	b.n	240080fc <HAL_PWREx_ControlVoltageScaling+0x1c>
    if ((PWR->CSR1 & PWR_CSR1_ACTVOS) == PWR_REGULATOR_VOLTAGE_SCALE1)
24008148:	6863      	ldr	r3, [r4, #4]
2400814a:	f403 4340 	and.w	r3, r3, #49152	@ 0xc000
2400814e:	f5b3 4f40 	cmp.w	r3, #49152	@ 0xc000
24008152:	d006      	beq.n	24008162 <HAL_PWREx_ControlVoltageScaling+0x82>
    MODIFY_REG (PWR->D3CR, PWR_D3CR_VOS, VoltageScaling);
24008154:	4a0d      	ldr	r2, [pc, #52]	@ (2400818c <HAL_PWREx_ControlVoltageScaling+0xac>)
24008156:	6993      	ldr	r3, [r2, #24]
24008158:	f423 4340 	bic.w	r3, r3, #49152	@ 0xc000
2400815c:	432b      	orrs	r3, r5
2400815e:	6193      	str	r3, [r2, #24]
24008160:	e7dd      	b.n	2400811e <HAL_PWREx_ControlVoltageScaling+0x3e>
      if ((SYSCFG->PWRCR & SYSCFG_PWRCR_ODEN) != 0U)
24008162:	4b0b      	ldr	r3, [pc, #44]	@ (24008190 <HAL_PWREx_ControlVoltageScaling+0xb0>)
24008164:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
24008166:	07d1      	lsls	r1, r2, #31
24008168:	d5f4      	bpl.n	24008154 <HAL_PWREx_ControlVoltageScaling+0x74>
        CLEAR_BIT(SYSCFG->PWRCR, SYSCFG_PWRCR_ODEN);
2400816a:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
2400816c:	f022 0201 	bic.w	r2, r2, #1
24008170:	62da      	str	r2, [r3, #44]	@ 0x2c
        tickstart = HAL_GetTick ();
24008172:	f009 fe49 	bl	24011e08 <HAL_GetTick>
24008176:	4606      	mov	r6, r0
        while (__HAL_PWR_GET_FLAG (PWR_FLAG_ACTVOSRDY) == 0U)
24008178:	6863      	ldr	r3, [r4, #4]
2400817a:	049a      	lsls	r2, r3, #18
2400817c:	d4ea      	bmi.n	24008154 <HAL_PWREx_ControlVoltageScaling+0x74>
          if ((HAL_GetTick () - tickstart) > PWR_FLAG_SETTING_DELAY)
2400817e:	f009 fe43 	bl	24011e08 <HAL_GetTick>
24008182:	1b80      	subs	r0, r0, r6
24008184:	f5b0 7f7a 	cmp.w	r0, #1000	@ 0x3e8
24008188:	d9f6      	bls.n	24008178 <HAL_PWREx_ControlVoltageScaling+0x98>
2400818a:	e7b7      	b.n	240080fc <HAL_PWREx_ControlVoltageScaling+0x1c>
2400818c:	58024800 	.word	0x58024800
24008190:	58000400 	.word	0x58000400

24008194 <HAL_PWREx_GetVoltageRange>:
  * @retval The current applied VOS selection.
  */
uint32_t HAL_PWREx_GetVoltageRange (void)
{
  /* Get the active voltage scaling */
  return (PWR->CSR1 & PWR_CSR1_ACTVOS);
24008194:	4b02      	ldr	r3, [pc, #8]	@ (240081a0 <HAL_PWREx_GetVoltageRange+0xc>)
24008196:	6858      	ldr	r0, [r3, #4]
}
24008198:	f400 4040 	and.w	r0, r0, #49152	@ 0xc000
2400819c:	4770      	bx	lr
2400819e:	bf00      	nop
240081a0:	58024800 	.word	0x58024800

240081a4 <HAL_PWREx_ControlStopModeVoltageScaling>:
{
  /* Check the parameters */
  assert_param (IS_PWR_STOP_MODE_REGULATOR_VOLTAGE (VoltageScaling));

  /* Return the stop mode voltage range */
  MODIFY_REG (PWR->CR1, PWR_CR1_SVOS, VoltageScaling);
240081a4:	4a03      	ldr	r2, [pc, #12]	@ (240081b4 <HAL_PWREx_ControlStopModeVoltageScaling+0x10>)
240081a6:	6813      	ldr	r3, [r2, #0]
240081a8:	f423 4340 	bic.w	r3, r3, #49152	@ 0xc000
240081ac:	4303      	orrs	r3, r0

  return HAL_OK;
}
240081ae:	2000      	movs	r0, #0
  MODIFY_REG (PWR->CR1, PWR_CR1_SVOS, VoltageScaling);
240081b0:	6013      	str	r3, [r2, #0]
}
240081b2:	4770      	bx	lr
240081b4:	58024800 	.word	0x58024800

240081b8 <HAL_PWREx_GetStopModeVoltageRange>:
  * @retval The actual applied VOS selection.
  */
uint32_t HAL_PWREx_GetStopModeVoltageRange (void)
{
  /* Return the stop voltage scaling */
  return (PWR->CR1 & PWR_CR1_SVOS);
240081b8:	4b02      	ldr	r3, [pc, #8]	@ (240081c4 <HAL_PWREx_GetStopModeVoltageRange+0xc>)
240081ba:	6818      	ldr	r0, [r3, #0]
}
240081bc:	f400 4040 	and.w	r0, r0, #49152	@ 0xc000
240081c0:	4770      	bx	lr
240081c2:	bf00      	nop
240081c4:	58024800 	.word	0x58024800

240081c8 <HAL_PWREx_EnterSTOPMode>:
  assert_param (IS_PWR_REGULATOR (Regulator));
  assert_param (IS_PWR_STOP_ENTRY (STOPEntry));
  assert_param (IS_PWR_DOMAIN (Domain));

  /* Select the regulator state in Stop mode */
  MODIFY_REG (PWR->CR1, PWR_CR1_LPDS, Regulator);
240081c8:	4b12      	ldr	r3, [pc, #72]	@ (24008214 <HAL_PWREx_EnterSTOPMode+0x4c>)
{
240081ca:	b510      	push	{r4, lr}
  MODIFY_REG (PWR->CR1, PWR_CR1_LPDS, Regulator);
240081cc:	681c      	ldr	r4, [r3, #0]
240081ce:	f024 0401 	bic.w	r4, r4, #1
240081d2:	4304      	orrs	r4, r0
240081d4:	601c      	str	r4, [r3, #0]

  /* Select the domain Power Down DeepSleep */
  if (Domain == PWR_D1_DOMAIN)
240081d6:	b9aa      	cbnz	r2, 24008204 <HAL_PWREx_EnterSTOPMode+0x3c>
      return;
    }
#endif /* defined (DUAL_CORE) */

    /* Keep DSTOP mode when D1/CD domain enters Deepsleep */
    CLEAR_BIT (PWR->CPUCR, PWR_CPUCR_PDDS_D1);
240081d8:	691a      	ldr	r2, [r3, #16]
240081da:	f022 0201 	bic.w	r2, r2, #1
240081de:	611a      	str	r2, [r3, #16]

    /* Set SLEEPDEEP bit of Cortex System Control Register */
    SET_BIT (SCB->SCR, SCB_SCR_SLEEPDEEP_Msk);
240081e0:	4b0d      	ldr	r3, [pc, #52]	@ (24008218 <HAL_PWREx_EnterSTOPMode+0x50>)
240081e2:	691a      	ldr	r2, [r3, #16]
240081e4:	f042 0204 	orr.w	r2, r2, #4
240081e8:	611a      	str	r2, [r3, #16]
  __ASM volatile ("dsb 0xF":::"memory");
240081ea:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
240081ee:	f3bf 8f6f 	isb	sy
    /* Ensure that all instructions are done before entering STOP mode */
    __DSB ();
    __ISB ();

    /* Select Stop mode entry */
    if (STOPEntry == PWR_STOPENTRY_WFI)
240081f2:	2901      	cmp	r1, #1
240081f4:	d104      	bne.n	24008200 <HAL_PWREx_EnterSTOPMode+0x38>
    {
      /* Request Wait For Interrupt */
      __WFI ();
240081f6:	bf30      	wfi
      /* Request Wait For Event */
      __WFE ();
    }

    /* Clear SLEEPDEEP bit of Cortex-Mx in the System Control Register */
    CLEAR_BIT (SCB->SCR, SCB_SCR_SLEEPDEEP_Msk);
240081f8:	691a      	ldr	r2, [r3, #16]
  }
#endif /* defined (PWR_CPUCR_PDDS_D2) */
  else
  {
    /* Keep DSTOP mode when D3/SRD domain enters Deepsleep */
    CLEAR_BIT (PWR->CPUCR, PWR_CPUCR_PDDS_D3);
240081fa:	f022 0204 	bic.w	r2, r2, #4
240081fe:	e006      	b.n	2400820e <HAL_PWREx_EnterSTOPMode+0x46>
      __WFE ();
24008200:	bf20      	wfe
24008202:	e7f9      	b.n	240081f8 <HAL_PWREx_EnterSTOPMode+0x30>
  else if (Domain == PWR_D2_DOMAIN)
24008204:	2a01      	cmp	r2, #1
    CLEAR_BIT (PWR->CPUCR, PWR_CPUCR_PDDS_D2);
24008206:	691a      	ldr	r2, [r3, #16]
  else if (Domain == PWR_D2_DOMAIN)
24008208:	d1f7      	bne.n	240081fa <HAL_PWREx_EnterSTOPMode+0x32>
    CLEAR_BIT (PWR->CPUCR, PWR_CPUCR_PDDS_D2);
2400820a:	f022 0202 	bic.w	r2, r2, #2
    CLEAR_BIT (PWR->CPUCR, PWR_CPUCR_PDDS_D3);
2400820e:	611a      	str	r2, [r3, #16]
  }
}
24008210:	bd10      	pop	{r4, pc}
24008212:	bf00      	nop
24008214:	58024800 	.word	0x58024800
24008218:	e000ed00 	.word	0xe000ed00

2400821c <HAL_PWREx_ClearPendingEvent>:
  {
    __SEV ();
    __WFE ();
  }
#else
  __WFE ();
2400821c:	bf20      	wfe
#endif /* defined (DUAL_CORE) */
}
2400821e:	4770      	bx	lr

24008220 <HAL_PWREx_EnterSTANDBYMode>:
{
  /* Check the parameters */
  assert_param (IS_PWR_DOMAIN (Domain));

  /* Select the domain Power Down DeepSleep */
  if (Domain == PWR_D1_DOMAIN)
24008220:	4b0a      	ldr	r3, [pc, #40]	@ (2400824c <HAL_PWREx_EnterSTANDBYMode+0x2c>)
      return;
    }
#endif /* defined (DUAL_CORE) */

    /* Allow DSTANDBY mode when D1/CD domain enters Deepsleep */
    SET_BIT (PWR-> CPUCR, PWR_CPUCR_PDDS_D1);
24008222:	691a      	ldr	r2, [r3, #16]
  if (Domain == PWR_D1_DOMAIN)
24008224:	b948      	cbnz	r0, 2400823a <HAL_PWREx_EnterSTANDBYMode+0x1a>
    SET_BIT (PWR-> CPUCR, PWR_CPUCR_PDDS_D1);
24008226:	f042 0201 	orr.w	r2, r2, #1
2400822a:	611a      	str	r2, [r3, #16]
    /* Allow DSTANDBY mode when D1/CD domain enters Deepsleep */
    SET_BIT (PWR-> CPU2CR, PWR_CPU2CR_PDDS_D1);
#endif /*DUAL_CORE*/

    /* Set SLEEPDEEP bit of Cortex System Control Register */
    SET_BIT (SCB->SCR, SCB_SCR_SLEEPDEEP_Msk);
2400822c:	4a08      	ldr	r2, [pc, #32]	@ (24008250 <HAL_PWREx_EnterSTANDBYMode+0x30>)
2400822e:	6913      	ldr	r3, [r2, #16]
24008230:	f043 0304 	orr.w	r3, r3, #4
24008234:	6113      	str	r3, [r2, #16]
#if defined (__CC_ARM)
    __force_stores ();
#endif /* defined (__CC_ARM) */

    /* Request Wait For Interrupt */
    __WFI ();
24008236:	bf30      	wfi
24008238:	4770      	bx	lr
  }
#if defined (PWR_CPUCR_PDDS_D2)
  else if (Domain == PWR_D2_DOMAIN)
2400823a:	2801      	cmp	r0, #1
  {
    /* Allow DSTANDBY mode when D2 domain enters Deepsleep */
    SET_BIT (PWR-> CPUCR, PWR_CPUCR_PDDS_D2);
2400823c:	bf0c      	ite	eq
2400823e:	f042 0202 	orreq.w	r2, r2, #2
  }
#endif /* defined (PWR_CPUCR_PDDS_D2) */
  else
  {
    /* Allow DSTANDBY mode when D3/SRD domain enters Deepsleep */
    SET_BIT (PWR-> CPUCR, PWR_CPUCR_PDDS_D3);
24008242:	f042 0204 	orrne.w	r2, r2, #4
24008246:	611a      	str	r2, [r3, #16]
#if defined (DUAL_CORE)
    /* Allow DSTANDBY mode when D3/SRD domain enters Deepsleep */
    SET_BIT (PWR-> CPU2CR, PWR_CPU2CR_PDDS_D3);
#endif /* defined (DUAL_CORE) */
  }
}
24008248:	4770      	bx	lr
2400824a:	bf00      	nop
2400824c:	58024800 	.word	0x58024800
24008250:	e000ed00 	.word	0xe000ed00

24008254 <HAL_PWREx_ConfigD3Domain>:
{
  /* Check the parameter */
  assert_param (IS_D3_STATE (D3State));

  /* Keep D3/SRD in run mode */
  MODIFY_REG (PWR->CPUCR, PWR_CPUCR_RUN_D3, D3State);
24008254:	4a03      	ldr	r2, [pc, #12]	@ (24008264 <HAL_PWREx_ConfigD3Domain+0x10>)
24008256:	6913      	ldr	r3, [r2, #16]
24008258:	f423 6300 	bic.w	r3, r3, #2048	@ 0x800
2400825c:	4303      	orrs	r3, r0
2400825e:	6113      	str	r3, [r2, #16]
}
24008260:	4770      	bx	lr
24008262:	bf00      	nop
24008264:	58024800 	.word	0x58024800

24008268 <HAL_PWREx_EnableFlashPowerDown>:
  * @retval None.
  */
void HAL_PWREx_EnableFlashPowerDown (void)
{
  /* Enable the Flash Power Down */
  SET_BIT (PWR->CR1, PWR_CR1_FLPS);
24008268:	4a02      	ldr	r2, [pc, #8]	@ (24008274 <HAL_PWREx_EnableFlashPowerDown+0xc>)
2400826a:	6813      	ldr	r3, [r2, #0]
2400826c:	f443 7300 	orr.w	r3, r3, #512	@ 0x200
24008270:	6013      	str	r3, [r2, #0]
}
24008272:	4770      	bx	lr
24008274:	58024800 	.word	0x58024800

24008278 <HAL_PWREx_DisableFlashPowerDown>:
  * @retval None.
  */
void HAL_PWREx_DisableFlashPowerDown (void)
{
  /* Disable the Flash Power Down */
  CLEAR_BIT (PWR->CR1, PWR_CR1_FLPS);
24008278:	4a02      	ldr	r2, [pc, #8]	@ (24008284 <HAL_PWREx_DisableFlashPowerDown+0xc>)
2400827a:	6813      	ldr	r3, [r2, #0]
2400827c:	f423 7300 	bic.w	r3, r3, #512	@ 0x200
24008280:	6013      	str	r3, [r2, #0]
}
24008282:	4770      	bx	lr
24008284:	58024800 	.word	0x58024800

24008288 <HAL_PWREx_EnableWakeUpPin>:
  *         Cortex-M7, wake up only Cortex-M4 and wake up Cortex-M7 and
  *         Cortex-M4.
  * @retval None.
  */
void HAL_PWREx_EnableWakeUpPin (PWREx_WakeupPinTypeDef *sPinParams)
{
24008288:	4684      	mov	ip, r0
  /* Check the parameters */
  assert_param (IS_PWR_WAKEUP_PIN (sPinParams->WakeUpPin));
  assert_param (IS_PWR_WAKEUP_PIN_POLARITY (sPinParams->PinPolarity));
  assert_param (IS_PWR_WAKEUP_PIN_PULL (sPinParams->PinPull));

  pinConfig = sPinParams->WakeUpPin | \
2400828a:	6801      	ldr	r1, [r0, #0]
{
2400828c:	b5f0      	push	{r4, r5, r6, r7, lr}
  uint32_t result;

#if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
     (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
     (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
2400828e:	fa91 f4a1 	rbit	r4, r1
              (sPinParams->PinPolarity << ((POSITION_VAL(sPinParams->WakeUpPin) + PWR_WKUPEPR_WKUPP1_Pos) & 0x1FU)) | \
24008292:	fab4 f484 	clz	r4, r4
24008296:	fa91 f2a1 	rbit	r2, r1
              (sPinParams->PinPull << (((POSITION_VAL(sPinParams->WakeUpPin) * PWR_WAKEUP_PINS_PULL_SHIFT_OFFSET) + PWR_WKUPEPR_WKUPPUPD1_Pos) & 0x1FU));
2400829a:	fab2 f282 	clz	r2, r2
2400829e:	fa91 f7a1 	rbit	r7, r1

  regMask   = sPinParams->WakeUpPin | \
              (PWR_WKUPEPR_WKUPP1 << (POSITION_VAL(sPinParams->WakeUpPin) & 0x1FU)) | \
240082a2:	fab7 f787 	clz	r7, r7
240082a6:	fa91 f0a1 	rbit	r0, r1
              (sPinParams->PinPolarity << ((POSITION_VAL(sPinParams->WakeUpPin) + PWR_WKUPEPR_WKUPP1_Pos) & 0x1FU)) | \
240082aa:	3408      	adds	r4, #8
              (sPinParams->PinPull << (((POSITION_VAL(sPinParams->WakeUpPin) * PWR_WAKEUP_PINS_PULL_SHIFT_OFFSET) + PWR_WKUPEPR_WKUPPUPD1_Pos) & 0x1FU));
240082ac:	3208      	adds	r2, #8
              (sPinParams->PinPolarity << ((POSITION_VAL(sPinParams->WakeUpPin) + PWR_WKUPEPR_WKUPP1_Pos) & 0x1FU)) | \
240082ae:	f8dc 3004 	ldr.w	r3, [ip, #4]
              (pullMask << ((POSITION_VAL(sPinParams->WakeUpPin) * PWR_WAKEUP_PINS_PULL_SHIFT_OFFSET) & 0x1FU));
240082b2:	fab0 f080 	clz	r0, r0
              (sPinParams->PinPolarity << ((POSITION_VAL(sPinParams->WakeUpPin) + PWR_WKUPEPR_WKUPP1_Pos) & 0x1FU)) | \
240082b6:	f004 041f 	and.w	r4, r4, #31
              (sPinParams->PinPull << (((POSITION_VAL(sPinParams->WakeUpPin) * PWR_WAKEUP_PINS_PULL_SHIFT_OFFSET) + PWR_WKUPEPR_WKUPPUPD1_Pos) & 0x1FU));
240082ba:	0052      	lsls	r2, r2, #1
              (pullMask << ((POSITION_VAL(sPinParams->WakeUpPin) * PWR_WAKEUP_PINS_PULL_SHIFT_OFFSET) & 0x1FU));
240082bc:	0040      	lsls	r0, r0, #1

  /* Enable and Specify the Wake-Up pin polarity and the pull configuration
     for the event detection (rising or falling edge) */
  MODIFY_REG (PWR->WKUPEPR, regMask, pinConfig);
240082be:	4e12      	ldr	r6, [pc, #72]	@ (24008308 <HAL_PWREx_EnableWakeUpPin+0x80>)
              (sPinParams->PinPolarity << ((POSITION_VAL(sPinParams->WakeUpPin) + PWR_WKUPEPR_WKUPP1_Pos) & 0x1FU)) | \
240082c0:	40a3      	lsls	r3, r4
              (sPinParams->PinPull << (((POSITION_VAL(sPinParams->WakeUpPin) * PWR_WAKEUP_PINS_PULL_SHIFT_OFFSET) + PWR_WKUPEPR_WKUPPUPD1_Pos) & 0x1FU));
240082c2:	f002 021e 	and.w	r2, r2, #30
240082c6:	f8dc 4008 	ldr.w	r4, [ip, #8]
              (pullMask << ((POSITION_VAL(sPinParams->WakeUpPin) * PWR_WAKEUP_PINS_PULL_SHIFT_OFFSET) & 0x1FU));
240082ca:	f000 001e 	and.w	r0, r0, #30
  pinConfig = sPinParams->WakeUpPin | \
240082ce:	430b      	orrs	r3, r1
  MODIFY_REG (PWR->WKUPEPR, regMask, pinConfig);
240082d0:	6ab5      	ldr	r5, [r6, #40]	@ 0x28
              (sPinParams->PinPull << (((POSITION_VAL(sPinParams->WakeUpPin) * PWR_WAKEUP_PINS_PULL_SHIFT_OFFSET) + PWR_WKUPEPR_WKUPPUPD1_Pos) & 0x1FU));
240082d2:	fa04 f202 	lsl.w	r2, r4, r2
  pinConfig = sPinParams->WakeUpPin | \
240082d6:	4313      	orrs	r3, r2
              (pullMask << ((POSITION_VAL(sPinParams->WakeUpPin) * PWR_WAKEUP_PINS_PULL_SHIFT_OFFSET) & 0x1FU));
240082d8:	f44f 3240 	mov.w	r2, #196608	@ 0x30000
240082dc:	4082      	lsls	r2, r0
              (PWR_WKUPEPR_WKUPP1 << (POSITION_VAL(sPinParams->WakeUpPin) & 0x1FU)) | \
240082de:	f44f 7080 	mov.w	r0, #256	@ 0x100
240082e2:	40b8      	lsls	r0, r7
  regMask   = sPinParams->WakeUpPin | \
240082e4:	4308      	orrs	r0, r1
240082e6:	4302      	orrs	r2, r0
  MODIFY_REG (PWR->WKUPEPR, regMask, pinConfig);
240082e8:	ea25 0502 	bic.w	r5, r5, r2
#ifndef DUAL_CORE
  /* Configure the Wakeup Pin EXTI Line */
  MODIFY_REG (EXTI->IMR2, PWR_EXTI_WAKEUP_PINS_MASK, (sPinParams->WakeUpPin << EXTI_IMR2_IM55_Pos));
240082ec:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
  MODIFY_REG (PWR->WKUPEPR, regMask, pinConfig);
240082f0:	432b      	orrs	r3, r5
240082f2:	62b3      	str	r3, [r6, #40]	@ 0x28
  MODIFY_REG (EXTI->IMR2, PWR_EXTI_WAKEUP_PINS_MASK, (sPinParams->WakeUpPin << EXTI_IMR2_IM55_Pos));
240082f4:	f8d2 3090 	ldr.w	r3, [r2, #144]	@ 0x90
240082f8:	f023 53fc 	bic.w	r3, r3, #528482304	@ 0x1f800000
240082fc:	ea43 53c1 	orr.w	r3, r3, r1, lsl #23
24008300:	f8c2 3090 	str.w	r3, [r2, #144]	@ 0x90
#endif /* !DUAL_CORE */
}
24008304:	bdf0      	pop	{r4, r5, r6, r7, pc}
24008306:	bf00      	nop
24008308:	58024800 	.word	0x58024800

2400830c <HAL_PWREx_DisableWakeUpPin>:
{
  /* Check the parameter */
  assert_param (IS_PWR_WAKEUP_PIN (WakeUpPin));

  /* Disable the WakeUpPin */
  CLEAR_BIT (PWR->WKUPEPR, WakeUpPin);
2400830c:	4a02      	ldr	r2, [pc, #8]	@ (24008318 <HAL_PWREx_DisableWakeUpPin+0xc>)
2400830e:	6a93      	ldr	r3, [r2, #40]	@ 0x28
24008310:	ea23 0300 	bic.w	r3, r3, r0
24008314:	6293      	str	r3, [r2, #40]	@ 0x28
}
24008316:	4770      	bx	lr
24008318:	58024800 	.word	0x58024800

2400831c <HAL_PWREx_GetWakeupFlag>:
{
  /* Check the parameters */
  assert_param (IS_PWR_WAKEUP_FLAG (WakeUpFlag));

  /* Return the wake up pin flag */
  return (PWR->WKUPFR & WakeUpFlag);
2400831c:	4b01      	ldr	r3, [pc, #4]	@ (24008324 <HAL_PWREx_GetWakeupFlag+0x8>)
2400831e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
}
24008320:	4018      	ands	r0, r3
24008322:	4770      	bx	lr
24008324:	58024800 	.word	0x58024800

24008328 <HAL_PWREx_ClearWakeupFlag>:
{
  /* Check the parameter */
  assert_param (IS_PWR_WAKEUP_FLAG (WakeUpFlag));

  /* Clear the wake up event received from wake up pin x */
  SET_BIT (PWR->WKUPCR, WakeUpFlag);
24008328:	4b04      	ldr	r3, [pc, #16]	@ (2400833c <HAL_PWREx_ClearWakeupFlag+0x14>)
2400832a:	6a1a      	ldr	r2, [r3, #32]
2400832c:	4302      	orrs	r2, r0
2400832e:	621a      	str	r2, [r3, #32]

  /* Check if the wake up event is well cleared */
  if ((PWR->WKUPFR & WakeUpFlag) != 0U)
24008330:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
24008332:	4203      	tst	r3, r0
  {
    return HAL_ERROR;
  }

  return HAL_OK;
}
24008334:	bf14      	ite	ne
24008336:	2001      	movne	r0, #1
24008338:	2000      	moveq	r0, #0
2400833a:	4770      	bx	lr
2400833c:	58024800 	.word	0x58024800

24008340 <HAL_PWREx_WKUP1_Callback>:
__weak void HAL_PWREx_WKUP1_Callback (void)
{
  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_PWREx_WKUP1Callback can be implemented in the user file
  */
}
24008340:	4770      	bx	lr

24008342 <HAL_PWREx_WKUP2_Callback>:

/**
  * @brief PWR WKUP2 interrupt callback.
  * @retval None.
  */
__weak void HAL_PWREx_WKUP2_Callback (void)
24008342:	4770      	bx	lr

24008344 <HAL_PWREx_WKUP3_Callback>:

/**
  * @brief PWR WKUP3 interrupt callback.
  * @retval None.
  */
__weak void HAL_PWREx_WKUP3_Callback (void)
24008344:	4770      	bx	lr

24008346 <HAL_PWREx_WKUP4_Callback>:

/**
  * @brief PWR WKUP4 interrupt callback.
  * @retval None.
  */
__weak void HAL_PWREx_WKUP4_Callback (void)
24008346:	4770      	bx	lr

24008348 <HAL_PWREx_WKUP5_Callback>:

/**
  * @brief PWR WKUP5 interrupt callback.
  * @retval None.
  */
__weak void HAL_PWREx_WKUP5_Callback (void)
24008348:	4770      	bx	lr

2400834a <HAL_PWREx_WKUP6_Callback>:

/**
  * @brief PWR WKUP6 interrupt callback.
  * @retval None.
  */
__weak void HAL_PWREx_WKUP6_Callback (void)
2400834a:	4770      	bx	lr

2400834c <HAL_PWREx_WAKEUP_PIN_IRQHandler>:
{
2400834c:	b508      	push	{r3, lr}
  if (READ_BIT(PWR->WKUPFR, PWR_WKUPFR_WKUPF1) != 0U)
2400834e:	4b1d      	ldr	r3, [pc, #116]	@ (240083c4 <HAL_PWREx_WAKEUP_PIN_IRQHandler+0x78>)
24008350:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
24008352:	07d2      	lsls	r2, r2, #31
24008354:	d506      	bpl.n	24008364 <HAL_PWREx_WAKEUP_PIN_IRQHandler+0x18>
    __HAL_PWR_CLEAR_WAKEUPFLAG (PWR_FLAG_WKUP1);
24008356:	6a1a      	ldr	r2, [r3, #32]
24008358:	f042 0201 	orr.w	r2, r2, #1
2400835c:	621a      	str	r2, [r3, #32]
    HAL_PWREx_WKUP1_Callback ();
2400835e:	f7ff ffef 	bl	24008340 <HAL_PWREx_WKUP1_Callback>
}
24008362:	bd08      	pop	{r3, pc}
  else if (READ_BIT (PWR->WKUPFR, PWR_WKUPFR_WKUPF2) != 0U)
24008364:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
24008366:	0790      	lsls	r0, r2, #30
24008368:	d506      	bpl.n	24008378 <HAL_PWREx_WAKEUP_PIN_IRQHandler+0x2c>
    __HAL_PWR_CLEAR_WAKEUPFLAG (PWR_FLAG_WKUP2);
2400836a:	6a1a      	ldr	r2, [r3, #32]
2400836c:	f042 0202 	orr.w	r2, r2, #2
24008370:	621a      	str	r2, [r3, #32]
    HAL_PWREx_WKUP2_Callback ();
24008372:	f7ff ffe6 	bl	24008342 <HAL_PWREx_WKUP2_Callback>
24008376:	e7f4      	b.n	24008362 <HAL_PWREx_WAKEUP_PIN_IRQHandler+0x16>
  else if (READ_BIT (PWR->WKUPFR, PWR_WKUPFR_WKUPF3) != 0U)
24008378:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
2400837a:	0751      	lsls	r1, r2, #29
2400837c:	d506      	bpl.n	2400838c <HAL_PWREx_WAKEUP_PIN_IRQHandler+0x40>
    __HAL_PWR_CLEAR_WAKEUPFLAG (PWR_FLAG_WKUP3);
2400837e:	6a1a      	ldr	r2, [r3, #32]
24008380:	f042 0204 	orr.w	r2, r2, #4
24008384:	621a      	str	r2, [r3, #32]
    HAL_PWREx_WKUP3_Callback ();
24008386:	f7ff ffdd 	bl	24008344 <HAL_PWREx_WKUP3_Callback>
2400838a:	e7ea      	b.n	24008362 <HAL_PWREx_WAKEUP_PIN_IRQHandler+0x16>
  else if (READ_BIT (PWR->WKUPFR, PWR_WKUPFR_WKUPF4) != 0U)
2400838c:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
2400838e:	0712      	lsls	r2, r2, #28
24008390:	d506      	bpl.n	240083a0 <HAL_PWREx_WAKEUP_PIN_IRQHandler+0x54>
    __HAL_PWR_CLEAR_WAKEUPFLAG (PWR_FLAG_WKUP4);
24008392:	6a1a      	ldr	r2, [r3, #32]
24008394:	f042 0208 	orr.w	r2, r2, #8
24008398:	621a      	str	r2, [r3, #32]
    HAL_PWREx_WKUP4_Callback ();
2400839a:	f7ff ffd4 	bl	24008346 <HAL_PWREx_WKUP4_Callback>
2400839e:	e7e0      	b.n	24008362 <HAL_PWREx_WAKEUP_PIN_IRQHandler+0x16>
  else if (READ_BIT (PWR->WKUPFR, PWR_WKUPFR_WKUPF5) != 0U)
240083a0:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
240083a2:	f012 0f10 	tst.w	r2, #16
    __HAL_PWR_CLEAR_WAKEUPFLAG (PWR_FLAG_WKUP5);
240083a6:	6a1a      	ldr	r2, [r3, #32]
  else if (READ_BIT (PWR->WKUPFR, PWR_WKUPFR_WKUPF5) != 0U)
240083a8:	d005      	beq.n	240083b6 <HAL_PWREx_WAKEUP_PIN_IRQHandler+0x6a>
    __HAL_PWR_CLEAR_WAKEUPFLAG (PWR_FLAG_WKUP5);
240083aa:	f042 0210 	orr.w	r2, r2, #16
240083ae:	621a      	str	r2, [r3, #32]
    HAL_PWREx_WKUP5_Callback ();
240083b0:	f7ff ffca 	bl	24008348 <HAL_PWREx_WKUP5_Callback>
240083b4:	e7d5      	b.n	24008362 <HAL_PWREx_WAKEUP_PIN_IRQHandler+0x16>
    __HAL_PWR_CLEAR_WAKEUPFLAG (PWR_FLAG_WKUP6);
240083b6:	f042 0220 	orr.w	r2, r2, #32
240083ba:	621a      	str	r2, [r3, #32]
    HAL_PWREx_WKUP6_Callback ();
240083bc:	f7ff ffc5 	bl	2400834a <HAL_PWREx_WKUP6_Callback>
}
240083c0:	e7cf      	b.n	24008362 <HAL_PWREx_WAKEUP_PIN_IRQHandler+0x16>
240083c2:	bf00      	nop
240083c4:	58024800 	.word	0x58024800

240083c8 <HAL_PWREx_EnableBkUpReg>:
/**
  * @brief Enable the Backup Regulator.
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_PWREx_EnableBkUpReg (void)
{
240083c8:	b538      	push	{r3, r4, r5, lr}
  uint32_t tickstart;

  /* Enable the Backup regulator */
  SET_BIT (PWR->CR2, PWR_CR2_BREN);
240083ca:	4c0a      	ldr	r4, [pc, #40]	@ (240083f4 <HAL_PWREx_EnableBkUpReg+0x2c>)
240083cc:	68a3      	ldr	r3, [r4, #8]
240083ce:	f043 0301 	orr.w	r3, r3, #1
240083d2:	60a3      	str	r3, [r4, #8]

  /* Get tick */
  tickstart = HAL_GetTick ();
240083d4:	f009 fd18 	bl	24011e08 <HAL_GetTick>
240083d8:	4605      	mov	r5, r0

  /* Wait till Backup regulator ready flag is set */
  while (__HAL_PWR_GET_FLAG (PWR_FLAG_BRR) == 0U)
240083da:	68a3      	ldr	r3, [r4, #8]
240083dc:	03db      	lsls	r3, r3, #15
240083de:	d501      	bpl.n	240083e4 <HAL_PWREx_EnableBkUpReg+0x1c>
    {
      return HAL_ERROR;
    }
  }

  return HAL_OK;
240083e0:	2000      	movs	r0, #0
}
240083e2:	bd38      	pop	{r3, r4, r5, pc}
    if ((HAL_GetTick() - tickstart ) > PWR_FLAG_SETTING_DELAY)
240083e4:	f009 fd10 	bl	24011e08 <HAL_GetTick>
240083e8:	1b40      	subs	r0, r0, r5
240083ea:	f5b0 7f7a 	cmp.w	r0, #1000	@ 0x3e8
240083ee:	d9f4      	bls.n	240083da <HAL_PWREx_EnableBkUpReg+0x12>
      return HAL_ERROR;
240083f0:	2001      	movs	r0, #1
240083f2:	e7f6      	b.n	240083e2 <HAL_PWREx_EnableBkUpReg+0x1a>
240083f4:	58024800 	.word	0x58024800

240083f8 <HAL_PWREx_DisableBkUpReg>:
/**
  * @brief Disable the Backup Regulator.
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_PWREx_DisableBkUpReg (void)
{
240083f8:	b538      	push	{r3, r4, r5, lr}
  uint32_t tickstart;

  /* Disable the Backup regulator */
  CLEAR_BIT (PWR->CR2, PWR_CR2_BREN);
240083fa:	4c0a      	ldr	r4, [pc, #40]	@ (24008424 <HAL_PWREx_DisableBkUpReg+0x2c>)
240083fc:	68a3      	ldr	r3, [r4, #8]
240083fe:	f023 0301 	bic.w	r3, r3, #1
24008402:	60a3      	str	r3, [r4, #8]

  /* Get tick */
  tickstart = HAL_GetTick ();
24008404:	f009 fd00 	bl	24011e08 <HAL_GetTick>
24008408:	4605      	mov	r5, r0

  /* Wait till Backup regulator ready flag is reset */
  while (__HAL_PWR_GET_FLAG (PWR_FLAG_BRR) != 0U)
2400840a:	68a0      	ldr	r0, [r4, #8]
2400840c:	f410 3080 	ands.w	r0, r0, #65536	@ 0x10000
24008410:	d100      	bne.n	24008414 <HAL_PWREx_DisableBkUpReg+0x1c>
      return HAL_ERROR;
    }
  }

  return HAL_OK;
}
24008412:	bd38      	pop	{r3, r4, r5, pc}
    if ((HAL_GetTick() - tickstart ) > PWR_FLAG_SETTING_DELAY)
24008414:	f009 fcf8 	bl	24011e08 <HAL_GetTick>
24008418:	1b40      	subs	r0, r0, r5
2400841a:	f5b0 7f7a 	cmp.w	r0, #1000	@ 0x3e8
2400841e:	d9f4      	bls.n	2400840a <HAL_PWREx_DisableBkUpReg+0x12>
      return HAL_ERROR;
24008420:	2001      	movs	r0, #1
24008422:	e7f6      	b.n	24008412 <HAL_PWREx_DisableBkUpReg+0x1a>
24008424:	58024800 	.word	0x58024800

24008428 <HAL_PWREx_EnableUSBReg>:
/**
  * @brief Enable the USB Regulator.
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_PWREx_EnableUSBReg (void)
{
24008428:	b538      	push	{r3, r4, r5, lr}
  uint32_t tickstart;

  /* Enable the USB regulator */
  SET_BIT (PWR->CR3, PWR_CR3_USBREGEN);
2400842a:	4c0a      	ldr	r4, [pc, #40]	@ (24008454 <HAL_PWREx_EnableUSBReg+0x2c>)
2400842c:	68e3      	ldr	r3, [r4, #12]
2400842e:	f043 7300 	orr.w	r3, r3, #33554432	@ 0x2000000
24008432:	60e3      	str	r3, [r4, #12]

  /* Get tick */
  tickstart = HAL_GetTick ();
24008434:	f009 fce8 	bl	24011e08 <HAL_GetTick>
24008438:	4605      	mov	r5, r0

  /* Wait till the USB regulator ready flag is set */
  while (__HAL_PWR_GET_FLAG (PWR_FLAG_USB33RDY) == 0U)
2400843a:	68e3      	ldr	r3, [r4, #12]
2400843c:	015b      	lsls	r3, r3, #5
2400843e:	d501      	bpl.n	24008444 <HAL_PWREx_EnableUSBReg+0x1c>
    {
      return HAL_ERROR;
    }
  }

  return HAL_OK;
24008440:	2000      	movs	r0, #0
}
24008442:	bd38      	pop	{r3, r4, r5, pc}
    if ((HAL_GetTick() - tickstart ) > PWR_FLAG_SETTING_DELAY)
24008444:	f009 fce0 	bl	24011e08 <HAL_GetTick>
24008448:	1b40      	subs	r0, r0, r5
2400844a:	f5b0 7f7a 	cmp.w	r0, #1000	@ 0x3e8
2400844e:	d9f4      	bls.n	2400843a <HAL_PWREx_EnableUSBReg+0x12>
      return HAL_ERROR;
24008450:	2001      	movs	r0, #1
24008452:	e7f6      	b.n	24008442 <HAL_PWREx_EnableUSBReg+0x1a>
24008454:	58024800 	.word	0x58024800

24008458 <HAL_PWREx_DisableUSBReg>:
/**
  * @brief Disable the USB Regulator.
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_PWREx_DisableUSBReg (void)
{
24008458:	b538      	push	{r3, r4, r5, lr}
  uint32_t tickstart;

  /* Disable the USB regulator */
  CLEAR_BIT (PWR->CR3, PWR_CR3_USBREGEN);
2400845a:	4c0a      	ldr	r4, [pc, #40]	@ (24008484 <HAL_PWREx_DisableUSBReg+0x2c>)
2400845c:	68e3      	ldr	r3, [r4, #12]
2400845e:	f023 7300 	bic.w	r3, r3, #33554432	@ 0x2000000
24008462:	60e3      	str	r3, [r4, #12]

  /* Get tick */
  tickstart = HAL_GetTick ();
24008464:	f009 fcd0 	bl	24011e08 <HAL_GetTick>
24008468:	4605      	mov	r5, r0

  /* Wait till the USB regulator ready flag is reset */
  while(__HAL_PWR_GET_FLAG (PWR_FLAG_USB33RDY) != 0U)
2400846a:	68e0      	ldr	r0, [r4, #12]
2400846c:	f010 6080 	ands.w	r0, r0, #67108864	@ 0x4000000
24008470:	d100      	bne.n	24008474 <HAL_PWREx_DisableUSBReg+0x1c>
      return HAL_ERROR;
    }
  }

  return HAL_OK;
}
24008472:	bd38      	pop	{r3, r4, r5, pc}
    if ((HAL_GetTick() - tickstart ) > PWR_FLAG_SETTING_DELAY)
24008474:	f009 fcc8 	bl	24011e08 <HAL_GetTick>
24008478:	1b40      	subs	r0, r0, r5
2400847a:	f5b0 7f7a 	cmp.w	r0, #1000	@ 0x3e8
2400847e:	d9f4      	bls.n	2400846a <HAL_PWREx_DisableUSBReg+0x12>
      return HAL_ERROR;
24008480:	2001      	movs	r0, #1
24008482:	e7f6      	b.n	24008472 <HAL_PWREx_DisableUSBReg+0x1a>
24008484:	58024800 	.word	0x58024800

24008488 <HAL_PWREx_EnableUSBVoltageDetector>:
  * @retval None.
  */
void HAL_PWREx_EnableUSBVoltageDetector (void)
{
  /* Enable the USB voltage detector */
  SET_BIT (PWR->CR3, PWR_CR3_USB33DEN);
24008488:	4a02      	ldr	r2, [pc, #8]	@ (24008494 <HAL_PWREx_EnableUSBVoltageDetector+0xc>)
2400848a:	68d3      	ldr	r3, [r2, #12]
2400848c:	f043 7380 	orr.w	r3, r3, #16777216	@ 0x1000000
24008490:	60d3      	str	r3, [r2, #12]
}
24008492:	4770      	bx	lr
24008494:	58024800 	.word	0x58024800

24008498 <HAL_PWREx_DisableUSBVoltageDetector>:
  * @retval None.
  */
void HAL_PWREx_DisableUSBVoltageDetector (void)
{
  /* Disable the USB voltage detector */
  CLEAR_BIT (PWR->CR3, PWR_CR3_USB33DEN);
24008498:	4a02      	ldr	r2, [pc, #8]	@ (240084a4 <HAL_PWREx_DisableUSBVoltageDetector+0xc>)
2400849a:	68d3      	ldr	r3, [r2, #12]
2400849c:	f023 7380 	bic.w	r3, r3, #16777216	@ 0x1000000
240084a0:	60d3      	str	r3, [r2, #12]
}
240084a2:	4770      	bx	lr
240084a4:	58024800 	.word	0x58024800

240084a8 <HAL_PWREx_EnableBatteryCharging>:
{
  /* Check the parameter */
  assert_param (IS_PWR_BATTERY_RESISTOR_SELECT (ResistorValue));

  /* Specify the charging resistor */
  MODIFY_REG (PWR->CR3, PWR_CR3_VBRS, ResistorValue);
240084a8:	4a05      	ldr	r2, [pc, #20]	@ (240084c0 <HAL_PWREx_EnableBatteryCharging+0x18>)
240084aa:	68d3      	ldr	r3, [r2, #12]
240084ac:	f423 7300 	bic.w	r3, r3, #512	@ 0x200
240084b0:	4303      	orrs	r3, r0
240084b2:	60d3      	str	r3, [r2, #12]

  /* Enable the Battery charging */
  SET_BIT (PWR->CR3, PWR_CR3_VBE);
240084b4:	68d3      	ldr	r3, [r2, #12]
240084b6:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
240084ba:	60d3      	str	r3, [r2, #12]
}
240084bc:	4770      	bx	lr
240084be:	bf00      	nop
240084c0:	58024800 	.word	0x58024800

240084c4 <HAL_PWREx_DisableBatteryCharging>:
  * @retval None.
  */
void HAL_PWREx_DisableBatteryCharging (void)
{
  /* Disable the Battery charging */
  CLEAR_BIT (PWR->CR3, PWR_CR3_VBE);
240084c4:	4a02      	ldr	r2, [pc, #8]	@ (240084d0 <HAL_PWREx_DisableBatteryCharging+0xc>)
240084c6:	68d3      	ldr	r3, [r2, #12]
240084c8:	f423 7380 	bic.w	r3, r3, #256	@ 0x100
240084cc:	60d3      	str	r3, [r2, #12]
}
240084ce:	4770      	bx	lr
240084d0:	58024800 	.word	0x58024800

240084d4 <HAL_PWREx_EnableMonitoring>:
  * @retval HAL status.
  */
void HAL_PWREx_EnableMonitoring (void)
{
  /* Enable the VBAT and Temperature monitoring */
  SET_BIT (PWR->CR2, PWR_CR2_MONEN);
240084d4:	4a02      	ldr	r2, [pc, #8]	@ (240084e0 <HAL_PWREx_EnableMonitoring+0xc>)
240084d6:	6893      	ldr	r3, [r2, #8]
240084d8:	f043 0310 	orr.w	r3, r3, #16
240084dc:	6093      	str	r3, [r2, #8]
}
240084de:	4770      	bx	lr
240084e0:	58024800 	.word	0x58024800

240084e4 <HAL_PWREx_DisableMonitoring>:
  * @retval HAL status.
  */
void HAL_PWREx_DisableMonitoring (void)
{
  /* Disable the VBAT and Temperature monitoring */
  CLEAR_BIT (PWR->CR2, PWR_CR2_MONEN);
240084e4:	4a02      	ldr	r2, [pc, #8]	@ (240084f0 <HAL_PWREx_DisableMonitoring+0xc>)
240084e6:	6893      	ldr	r3, [r2, #8]
240084e8:	f023 0310 	bic.w	r3, r3, #16
240084ec:	6093      	str	r3, [r2, #8]
}
240084ee:	4770      	bx	lr
240084f0:	58024800 	.word	0x58024800

240084f4 <HAL_PWREx_GetTemperatureLevel>:
uint32_t HAL_PWREx_GetTemperatureLevel (void)
{
  uint32_t tempLevel, regValue;

  /* Read the temperature flags */
  regValue = READ_BIT (PWR->CR2, (PWR_CR2_TEMPH | PWR_CR2_TEMPL));
240084f4:	4b06      	ldr	r3, [pc, #24]	@ (24008510 <HAL_PWREx_GetTemperatureLevel+0x1c>)
240084f6:	6898      	ldr	r0, [r3, #8]
240084f8:	f400 0040 	and.w	r0, r0, #12582912	@ 0xc00000

  /* Check if the temperature is below the threshold */
  if (regValue == PWR_CR2_TEMPL)
240084fc:	f5b0 0f80 	cmp.w	r0, #4194304	@ 0x400000
24008500:	d004      	beq.n	2400850c <HAL_PWREx_GetTemperatureLevel+0x18>
  {
    tempLevel = PWR_TEMP_BELOW_LOW_THRESHOLD;
  }
  /* Check if the temperature is above the threshold */
  else if (regValue == PWR_CR2_TEMPH)
24008502:	f5a0 0300 	sub.w	r3, r0, #8388608	@ 0x800000
24008506:	4258      	negs	r0, r3
24008508:	4158      	adcs	r0, r3
2400850a:	05c0      	lsls	r0, r0, #23
  {
    tempLevel = PWR_TEMP_BETWEEN_HIGH_LOW_THRESHOLD;
  }

  return tempLevel;
}
2400850c:	4770      	bx	lr
2400850e:	bf00      	nop
24008510:	58024800 	.word	0x58024800

24008514 <HAL_PWREx_GetVBATLevel>:
uint32_t HAL_PWREx_GetVBATLevel (void)
{
  uint32_t VBATLevel, regValue;

  /* Read the VBAT flags */
  regValue = READ_BIT (PWR->CR2, (PWR_CR2_VBATH | PWR_CR2_VBATL));
24008514:	4b06      	ldr	r3, [pc, #24]	@ (24008530 <HAL_PWREx_GetVBATLevel+0x1c>)
24008516:	6898      	ldr	r0, [r3, #8]
24008518:	f400 1040 	and.w	r0, r0, #3145728	@ 0x300000

  /* Check if the VBAT is below the threshold */
  if (regValue == PWR_CR2_VBATL)
2400851c:	f5b0 1f80 	cmp.w	r0, #1048576	@ 0x100000
24008520:	d004      	beq.n	2400852c <HAL_PWREx_GetVBATLevel+0x18>
  {
    VBATLevel = PWR_VBAT_BELOW_LOW_THRESHOLD;
  }
  /* Check if the VBAT is above the threshold */
  else if (regValue == PWR_CR2_VBATH)
24008522:	f5a0 1300 	sub.w	r3, r0, #2097152	@ 0x200000
24008526:	4258      	negs	r0, r3
24008528:	4158      	adcs	r0, r3
2400852a:	0540      	lsls	r0, r0, #21
  {
    VBATLevel = PWR_VBAT_BETWEEN_HIGH_LOW_THRESHOLD;
  }

  return VBATLevel;
}
2400852c:	4770      	bx	lr
2400852e:	bf00      	nop
24008530:	58024800 	.word	0x58024800

24008534 <HAL_PWREx_ConfigAVD>:
  /* Check the parameters */
  assert_param (IS_PWR_AVD_LEVEL (sConfigAVD->AVDLevel));
  assert_param (IS_PWR_AVD_MODE (sConfigAVD->Mode));

  /* Set the ALS[18:17] bits according to AVDLevel value */
  MODIFY_REG (PWR->CR1, PWR_CR1_ALS, sConfigAVD->AVDLevel);
24008534:	4a20      	ldr	r2, [pc, #128]	@ (240085b8 <HAL_PWREx_ConfigAVD+0x84>)
24008536:	6801      	ldr	r1, [r0, #0]
24008538:	6813      	ldr	r3, [r2, #0]
2400853a:	f423 23c0 	bic.w	r3, r3, #393216	@ 0x60000
2400853e:	430b      	orrs	r3, r1
24008540:	6013      	str	r3, [r2, #0]

  /* Clear any previous config */
#if !defined (DUAL_CORE)
  __HAL_PWR_AVD_EXTI_DISABLE_EVENT ();
24008542:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
24008546:	f8d3 2084 	ldr.w	r2, [r3, #132]	@ 0x84
2400854a:	f422 3280 	bic.w	r2, r2, #65536	@ 0x10000
2400854e:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84
  __HAL_PWR_AVD_EXTI_DISABLE_IT ();
24008552:	f8d3 2080 	ldr.w	r2, [r3, #128]	@ 0x80
24008556:	f422 3280 	bic.w	r2, r2, #65536	@ 0x10000
2400855a:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
#endif /* !defined (DUAL_CORE) */

  __HAL_PWR_AVD_EXTI_DISABLE_RISING_EDGE ();
2400855e:	681a      	ldr	r2, [r3, #0]
24008560:	f422 3280 	bic.w	r2, r2, #65536	@ 0x10000
24008564:	601a      	str	r2, [r3, #0]
  __HAL_PWR_AVD_EXTI_DISABLE_FALLING_EDGE ();
24008566:	685a      	ldr	r2, [r3, #4]
24008568:	f422 3280 	bic.w	r2, r2, #65536	@ 0x10000
2400856c:	605a      	str	r2, [r3, #4]

#if !defined (DUAL_CORE)
  /* Configure the interrupt mode */
  if ((sConfigAVD->Mode & AVD_MODE_IT) == AVD_MODE_IT)
2400856e:	6842      	ldr	r2, [r0, #4]
24008570:	03d1      	lsls	r1, r2, #15
24008572:	d505      	bpl.n	24008580 <HAL_PWREx_ConfigAVD+0x4c>
  {
    __HAL_PWR_AVD_EXTI_ENABLE_IT ();
24008574:	f8d3 1080 	ldr.w	r1, [r3, #128]	@ 0x80
24008578:	f441 3180 	orr.w	r1, r1, #65536	@ 0x10000
2400857c:	f8c3 1080 	str.w	r1, [r3, #128]	@ 0x80
  }

  /* Configure the event mode */
  if ((sConfigAVD->Mode & AVD_MODE_EVT) == AVD_MODE_EVT)
24008580:	0390      	lsls	r0, r2, #14
24008582:	d507      	bpl.n	24008594 <HAL_PWREx_ConfigAVD+0x60>
  {
    __HAL_PWR_AVD_EXTI_ENABLE_EVENT ();
24008584:	f04f 41b0 	mov.w	r1, #1476395008	@ 0x58000000
24008588:	f8d1 3084 	ldr.w	r3, [r1, #132]	@ 0x84
2400858c:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
24008590:	f8c1 3084 	str.w	r3, [r1, #132]	@ 0x84
  }
#endif /* !defined (DUAL_CORE) */

  /* Rising edge configuration */
  if ((sConfigAVD->Mode & AVD_RISING_EDGE) == AVD_RISING_EDGE)
24008594:	07d1      	lsls	r1, r2, #31
24008596:	d505      	bpl.n	240085a4 <HAL_PWREx_ConfigAVD+0x70>
  {
    __HAL_PWR_AVD_EXTI_ENABLE_RISING_EDGE ();
24008598:	f04f 41b0 	mov.w	r1, #1476395008	@ 0x58000000
2400859c:	680b      	ldr	r3, [r1, #0]
2400859e:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
240085a2:	600b      	str	r3, [r1, #0]
  }

  /* Falling edge configuration */
  if ((sConfigAVD->Mode & AVD_FALLING_EDGE) == AVD_FALLING_EDGE)
240085a4:	0793      	lsls	r3, r2, #30
240085a6:	d505      	bpl.n	240085b4 <HAL_PWREx_ConfigAVD+0x80>
  {
    __HAL_PWR_AVD_EXTI_ENABLE_FALLING_EDGE ();
240085a8:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
240085ac:	6853      	ldr	r3, [r2, #4]
240085ae:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
240085b2:	6053      	str	r3, [r2, #4]
  }
}
240085b4:	4770      	bx	lr
240085b6:	bf00      	nop
240085b8:	58024800 	.word	0x58024800

240085bc <HAL_PWREx_EnableAVD>:
  * @retval None.
  */
void HAL_PWREx_EnableAVD (void)
{
  /* Enable the Analog Voltage Detector */
  SET_BIT (PWR->CR1, PWR_CR1_AVDEN);
240085bc:	4a02      	ldr	r2, [pc, #8]	@ (240085c8 <HAL_PWREx_EnableAVD+0xc>)
240085be:	6813      	ldr	r3, [r2, #0]
240085c0:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
240085c4:	6013      	str	r3, [r2, #0]
}
240085c6:	4770      	bx	lr
240085c8:	58024800 	.word	0x58024800

240085cc <HAL_PWREx_DisableAVD>:
  * @retval None.
  */
void HAL_PWREx_DisableAVD (void)
{
  /* Disable the Analog Voltage Detector */
  CLEAR_BIT (PWR->CR1, PWR_CR1_AVDEN);
240085cc:	4a02      	ldr	r2, [pc, #8]	@ (240085d8 <HAL_PWREx_DisableAVD+0xc>)
240085ce:	6813      	ldr	r3, [r2, #0]
240085d0:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
240085d4:	6013      	str	r3, [r2, #0]
}
240085d6:	4770      	bx	lr
240085d8:	58024800 	.word	0x58024800

240085dc <HAL_PWREx_AVDCallback>:

/**
  * @brief PWR AVD interrupt callback.
  * @retval None.
  */
__weak void HAL_PWREx_AVDCallback (void)
240085dc:	4770      	bx	lr

240085de <HAL_PWREx_PVD_AVD_IRQHandler>:
{
240085de:	b538      	push	{r3, r4, r5, lr}
  if(READ_BIT (PWR->CR1, PWR_CR1_PVDEN) != 0U)
240085e0:	4d11      	ldr	r5, [pc, #68]	@ (24008628 <HAL_PWREx_PVD_AVD_IRQHandler+0x4a>)
240085e2:	682b      	ldr	r3, [r5, #0]
240085e4:	06d8      	lsls	r0, r3, #27
240085e6:	d50d      	bpl.n	24008604 <HAL_PWREx_PVD_AVD_IRQHandler+0x26>
      if(__HAL_PWR_PVD_EXTI_GET_FLAG () != 0U)
240085e8:	f04f 44b0 	mov.w	r4, #1476395008	@ 0x58000000
240085ec:	f8d4 3088 	ldr.w	r3, [r4, #136]	@ 0x88
240085f0:	03d9      	lsls	r1, r3, #15
240085f2:	d507      	bpl.n	24008604 <HAL_PWREx_PVD_AVD_IRQHandler+0x26>
        HAL_PWR_PVDCallback ();
240085f4:	f7ff fd36 	bl	24008064 <HAL_PWR_PVDCallback>
        __HAL_PWR_PVD_EXTI_CLEAR_FLAG ();
240085f8:	f8d4 3088 	ldr.w	r3, [r4, #136]	@ 0x88
240085fc:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
24008600:	f8c4 3088 	str.w	r3, [r4, #136]	@ 0x88
  if (READ_BIT (PWR->CR1, PWR_CR1_AVDEN) != 0U)
24008604:	682b      	ldr	r3, [r5, #0]
24008606:	03da      	lsls	r2, r3, #15
24008608:	d50d      	bpl.n	24008626 <HAL_PWREx_PVD_AVD_IRQHandler+0x48>
      if (__HAL_PWR_AVD_EXTI_GET_FLAG () != 0U)
2400860a:	f04f 44b0 	mov.w	r4, #1476395008	@ 0x58000000
2400860e:	f8d4 3088 	ldr.w	r3, [r4, #136]	@ 0x88
24008612:	03db      	lsls	r3, r3, #15
24008614:	d507      	bpl.n	24008626 <HAL_PWREx_PVD_AVD_IRQHandler+0x48>
        HAL_PWREx_AVDCallback ();
24008616:	f7ff ffe1 	bl	240085dc <HAL_PWREx_AVDCallback>
        __HAL_PWR_AVD_EXTI_CLEAR_FLAG ();
2400861a:	f8d4 3088 	ldr.w	r3, [r4, #136]	@ 0x88
2400861e:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
24008622:	f8c4 3088 	str.w	r3, [r4, #136]	@ 0x88
}
24008626:	bd38      	pop	{r3, r4, r5, pc}
24008628:	58024800 	.word	0x58024800

2400862c <QSPI_DMARxCplt>:
  * @param  hmdma : MDMA handle
  * @retval None
  */
static void QSPI_DMARxCplt(MDMA_HandleTypeDef *hmdma)
{
  QSPI_HandleTypeDef* hqspi = (QSPI_HandleTypeDef*)(hmdma->Parent);
2400862c:	6c03      	ldr	r3, [r0, #64]	@ 0x40
  hqspi->RxXferCount = 0U;
2400862e:	2200      	movs	r2, #0
24008630:	639a      	str	r2, [r3, #56]	@ 0x38

  /* Enable the QSPI transfer complete Interrupt */
  __HAL_QSPI_ENABLE_IT(hqspi, QSPI_IT_TC);
24008632:	681a      	ldr	r2, [r3, #0]
24008634:	6813      	ldr	r3, [r2, #0]
24008636:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
2400863a:	6013      	str	r3, [r2, #0]
}
2400863c:	4770      	bx	lr

2400863e <QSPI_DMATxCplt>:
  * @param  hmdma : MDMA handle
  * @retval None
  */
static void QSPI_DMATxCplt(MDMA_HandleTypeDef *hmdma)
{
  QSPI_HandleTypeDef* hqspi = (QSPI_HandleTypeDef*)(hmdma->Parent);
2400863e:	6c03      	ldr	r3, [r0, #64]	@ 0x40
  hqspi->TxXferCount = 0U;
24008640:	2200      	movs	r2, #0
24008642:	62da      	str	r2, [r3, #44]	@ 0x2c

  /* Enable the QSPI transfer complete Interrupt */
  __HAL_QSPI_ENABLE_IT(hqspi, QSPI_IT_TC);
24008644:	681a      	ldr	r2, [r3, #0]
24008646:	6813      	ldr	r3, [r2, #0]
24008648:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
2400864c:	6013      	str	r3, [r2, #0]
}
2400864e:	4770      	bx	lr

24008650 <QSPI_Config>:
  *            @arg QSPI_FUNCTIONAL_MODE_AUTO_POLLING: Automatic polling mode
  *            @arg QSPI_FUNCTIONAL_MODE_MEMORY_MAPPED: Memory-mapped mode
  * @retval None
  */
static void QSPI_Config(QSPI_HandleTypeDef *hqspi, QSPI_CommandTypeDef *cmd, uint32_t FunctionalMode)
{
24008650:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  assert_param(IS_QSPI_FUNCTIONAL_MODE(FunctionalMode));

  if ((cmd->DataMode != QSPI_DATA_NONE) && (FunctionalMode != QSPI_FUNCTIONAL_MODE_MEMORY_MAPPED))
24008654:	6a4e      	ldr	r6, [r1, #36]	@ 0x24
24008656:	b136      	cbz	r6, 24008666 <QSPI_Config+0x16>
24008658:	f1b2 6f40 	cmp.w	r2, #201326592	@ 0xc000000
2400865c:	d003      	beq.n	24008666 <QSPI_Config+0x16>
  {
    /* Configure QSPI: DLR register with the number of data to read or write */
    WRITE_REG(hqspi->Instance->DLR, (cmd->NbData - 1U));
2400865e:	6a8b      	ldr	r3, [r1, #40]	@ 0x28
24008660:	6804      	ldr	r4, [r0, #0]
24008662:	3b01      	subs	r3, #1
24008664:	6123      	str	r3, [r4, #16]
  }

  if (cmd->InstructionMode != QSPI_INSTRUCTION_NONE)
24008666:	f8d1 a018 	ldr.w	sl, [r1, #24]
    if (cmd->AlternateByteMode != QSPI_ALTERNATE_BYTES_NONE)
    {
      /* Configure QSPI: ABR register with alternate bytes value */
      WRITE_REG(hqspi->Instance->ABR, cmd->AlternateBytes);

      if (cmd->AddressMode != QSPI_ADDRESS_NONE)
2400866a:	e9d1 7e07 	ldrd	r7, lr, [r1, #28]
  if (cmd->InstructionMode != QSPI_INSTRUCTION_NONE)
2400866e:	f1ba 0f00 	cmp.w	sl, #0
24008672:	d04c      	beq.n	2400870e <QSPI_Config+0xbe>
      {
        /*---- Command with instruction, address and alternate bytes ----*/
        /* Configure QSPI: CCR register with all communications parameters */
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
24008674:	694c      	ldr	r4, [r1, #20]
    WRITE_REG(hqspi->Instance->DLR, (cmd->NbData - 1U));
24008676:	6805      	ldr	r5, [r0, #0]
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
24008678:	ea4f 4c84 	mov.w	ip, r4, lsl #18
2400867c:	ea4a 0406 	orr.w	r4, sl, r6
24008680:	680b      	ldr	r3, [r1, #0]
24008682:	f8d1 8034 	ldr.w	r8, [r1, #52]	@ 0x34
24008686:	ea44 0a02 	orr.w	sl, r4, r2
2400868a:	e9d1 090b 	ldrd	r0, r9, [r1, #44]	@ 0x2c
    if (cmd->AlternateByteMode != QSPI_ALTERNATE_BYTES_NONE)
2400868e:	f1be 0f00 	cmp.w	lr, #0
24008692:	d024      	beq.n	240086de <QSPI_Config+0x8e>
      WRITE_REG(hqspi->Instance->ABR, cmd->AlternateBytes);
24008694:	688e      	ldr	r6, [r1, #8]
24008696:	ea4a 040e 	orr.w	r4, sl, lr
2400869a:	61ee      	str	r6, [r5, #28]
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
2400869c:	690e      	ldr	r6, [r1, #16]
      if (cmd->AddressMode != QSPI_ADDRESS_NONE)
2400869e:	b19f      	cbz	r7, 240086c8 <QSPI_Config+0x78>
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
240086a0:	433b      	orrs	r3, r7
240086a2:	4303      	orrs	r3, r0
240086a4:	68c8      	ldr	r0, [r1, #12]
240086a6:	ea43 0309 	orr.w	r3, r3, r9
240086aa:	ea43 0308 	orr.w	r3, r3, r8
240086ae:	4333      	orrs	r3, r6
240086b0:	4303      	orrs	r3, r0
240086b2:	ea43 030c 	orr.w	r3, r3, ip
240086b6:	4323      	orrs	r3, r4
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
                                         cmd->DataMode | (cmd->DummyCycles << QUADSPI_CCR_DCYC_Pos) |
                                         cmd->AlternateByteMode | cmd->AddressSize | cmd->AddressMode |
                                         cmd->InstructionMode | cmd->Instruction | FunctionalMode));

        if (FunctionalMode != QSPI_FUNCTIONAL_MODE_MEMORY_MAPPED)
240086b8:	f1b2 6f40 	cmp.w	r2, #201326592	@ 0xc000000
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
240086bc:	616b      	str	r3, [r5, #20]
        if (FunctionalMode != QSPI_FUNCTIONAL_MODE_MEMORY_MAPPED)
240086be:	d001      	beq.n	240086c4 <QSPI_Config+0x74>
        {
          /* Configure QSPI: AR register with address value */
          WRITE_REG(hqspi->Instance->AR, cmd->Address);
240086c0:	684b      	ldr	r3, [r1, #4]
240086c2:	61ab      	str	r3, [r5, #24]
                                           cmd->InstructionMode | FunctionalMode));
        }
      }
    }
  }
}
240086c4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
240086c8:	4303      	orrs	r3, r0
240086ca:	ea43 0309 	orr.w	r3, r3, r9
240086ce:	ea43 0308 	orr.w	r3, r3, r8
240086d2:	4333      	orrs	r3, r6
240086d4:	ea43 030c 	orr.w	r3, r3, ip
240086d8:	4323      	orrs	r3, r4
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
240086da:	616b      	str	r3, [r5, #20]
240086dc:	e7f2      	b.n	240086c4 <QSPI_Config+0x74>
      if (cmd->AddressMode != QSPI_ADDRESS_NONE)
240086de:	b167      	cbz	r7, 240086fa <QSPI_Config+0xaa>
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
240086e0:	433b      	orrs	r3, r7
240086e2:	4303      	orrs	r3, r0
240086e4:	68c8      	ldr	r0, [r1, #12]
240086e6:	ea43 0309 	orr.w	r3, r3, r9
240086ea:	ea43 0308 	orr.w	r3, r3, r8
240086ee:	4303      	orrs	r3, r0
240086f0:	ea43 030c 	orr.w	r3, r3, ip
240086f4:	ea43 030a 	orr.w	r3, r3, sl
240086f8:	e7de      	b.n	240086b8 <QSPI_Config+0x68>
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
240086fa:	4303      	orrs	r3, r0
240086fc:	ea43 0309 	orr.w	r3, r3, r9
24008700:	ea43 0408 	orr.w	r4, r3, r8
24008704:	ea44 030c 	orr.w	r3, r4, ip
24008708:	ea43 030a 	orr.w	r3, r3, sl
2400870c:	e7e5      	b.n	240086da <QSPI_Config+0x8a>
    if (cmd->AlternateByteMode != QSPI_ALTERNATE_BYTES_NONE)
2400870e:	f1be 0f00 	cmp.w	lr, #0
24008712:	d02c      	beq.n	2400876e <QSPI_Config+0x11e>
      WRITE_REG(hqspi->Instance->ABR, cmd->AlternateBytes);
24008714:	ea46 050e 	orr.w	r5, r6, lr
24008718:	688b      	ldr	r3, [r1, #8]
2400871a:	6804      	ldr	r4, [r0, #0]
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
2400871c:	694e      	ldr	r6, [r1, #20]
2400871e:	4315      	orrs	r5, r2
      WRITE_REG(hqspi->Instance->ABR, cmd->AlternateBytes);
24008720:	61e3      	str	r3, [r4, #28]
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
24008722:	f8d1 c034 	ldr.w	ip, [r1, #52]	@ 0x34
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
24008726:	04b6      	lsls	r6, r6, #18
24008728:	690b      	ldr	r3, [r1, #16]
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
2400872a:	e9d1 8e0b 	ldrd	r8, lr, [r1, #44]	@ 0x2c
      if (cmd->AddressMode != QSPI_ADDRESS_NONE)
2400872e:	b1a7      	cbz	r7, 2400875a <QSPI_Config+0x10a>
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
24008730:	433b      	orrs	r3, r7
24008732:	68c8      	ldr	r0, [r1, #12]
        if (FunctionalMode != QSPI_FUNCTIONAL_MODE_MEMORY_MAPPED)
24008734:	f1b2 6f40 	cmp.w	r2, #201326592	@ 0xc000000
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
24008738:	ea43 0308 	orr.w	r3, r3, r8
2400873c:	ea43 030e 	orr.w	r3, r3, lr
24008740:	ea43 030c 	orr.w	r3, r3, ip
24008744:	ea43 0300 	orr.w	r3, r3, r0
24008748:	ea43 0306 	orr.w	r3, r3, r6
2400874c:	ea43 0305 	orr.w	r3, r3, r5
24008750:	6163      	str	r3, [r4, #20]
        if (FunctionalMode != QSPI_FUNCTIONAL_MODE_MEMORY_MAPPED)
24008752:	d0b7      	beq.n	240086c4 <QSPI_Config+0x74>
          WRITE_REG(hqspi->Instance->AR, cmd->Address);
24008754:	684b      	ldr	r3, [r1, #4]
24008756:	61a3      	str	r3, [r4, #24]
24008758:	e7b4      	b.n	240086c4 <QSPI_Config+0x74>
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
2400875a:	ea43 0308 	orr.w	r3, r3, r8
2400875e:	ea43 030e 	orr.w	r3, r3, lr
24008762:	ea43 030c 	orr.w	r3, r3, ip
24008766:	4333      	orrs	r3, r6
24008768:	432b      	orrs	r3, r5
2400876a:	6163      	str	r3, [r4, #20]
2400876c:	e7aa      	b.n	240086c4 <QSPI_Config+0x74>
      if (cmd->AddressMode != QSPI_ADDRESS_NONE)
2400876e:	b1d7      	cbz	r7, 240087a6 <QSPI_Config+0x156>
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
24008770:	ea46 0307 	orr.w	r3, r6, r7
24008774:	6acc      	ldr	r4, [r1, #44]	@ 0x2c
24008776:	6800      	ldr	r0, [r0, #0]
        if (FunctionalMode != QSPI_FUNCTIONAL_MODE_MEMORY_MAPPED)
24008778:	f1b2 6f40 	cmp.w	r2, #201326592	@ 0xc000000
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
2400877c:	ea43 0302 	orr.w	r3, r3, r2
24008780:	ea43 0304 	orr.w	r3, r3, r4
24008784:	6b0c      	ldr	r4, [r1, #48]	@ 0x30
24008786:	ea43 0304 	orr.w	r3, r3, r4
2400878a:	6b4c      	ldr	r4, [r1, #52]	@ 0x34
2400878c:	ea43 0304 	orr.w	r3, r3, r4
24008790:	68cc      	ldr	r4, [r1, #12]
24008792:	ea43 0304 	orr.w	r3, r3, r4
24008796:	694c      	ldr	r4, [r1, #20]
24008798:	ea43 4384 	orr.w	r3, r3, r4, lsl #18
2400879c:	6143      	str	r3, [r0, #20]
        if (FunctionalMode != QSPI_FUNCTIONAL_MODE_MEMORY_MAPPED)
2400879e:	d091      	beq.n	240086c4 <QSPI_Config+0x74>
          WRITE_REG(hqspi->Instance->AR, cmd->Address);
240087a0:	684b      	ldr	r3, [r1, #4]
240087a2:	6183      	str	r3, [r0, #24]
240087a4:	e78e      	b.n	240086c4 <QSPI_Config+0x74>
        if (cmd->DataMode != QSPI_DATA_NONE)
240087a6:	2e00      	cmp	r6, #0
240087a8:	d08c      	beq.n	240086c4 <QSPI_Config+0x74>
          WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
240087aa:	6acb      	ldr	r3, [r1, #44]	@ 0x2c
240087ac:	6800      	ldr	r0, [r0, #0]
240087ae:	4333      	orrs	r3, r6
240087b0:	4313      	orrs	r3, r2
240087b2:	6b0a      	ldr	r2, [r1, #48]	@ 0x30
240087b4:	4313      	orrs	r3, r2
240087b6:	6b4a      	ldr	r2, [r1, #52]	@ 0x34
240087b8:	4313      	orrs	r3, r2
240087ba:	694a      	ldr	r2, [r1, #20]
240087bc:	ea43 4382 	orr.w	r3, r3, r2, lsl #18
240087c0:	6143      	str	r3, [r0, #20]
}
240087c2:	e77f      	b.n	240086c4 <QSPI_Config+0x74>

240087c4 <QSPI_WaitFlagStateUntilTimeout>:
{
240087c4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
240087c8:	f8dd 8018 	ldr.w	r8, [sp, #24]
240087cc:	4604      	mov	r4, r0
240087ce:	460e      	mov	r6, r1
240087d0:	4615      	mov	r5, r2
240087d2:	461f      	mov	r7, r3
  while((__HAL_QSPI_GET_FLAG(hqspi, Flag)) != State)
240087d4:	6822      	ldr	r2, [r4, #0]
240087d6:	6893      	ldr	r3, [r2, #8]
240087d8:	4233      	tst	r3, r6
240087da:	bf14      	ite	ne
240087dc:	2301      	movne	r3, #1
240087de:	2300      	moveq	r3, #0
240087e0:	42ab      	cmp	r3, r5
240087e2:	d101      	bne.n	240087e8 <QSPI_WaitFlagStateUntilTimeout+0x24>
  return HAL_OK;
240087e4:	2000      	movs	r0, #0
240087e6:	e012      	b.n	2400880e <QSPI_WaitFlagStateUntilTimeout+0x4a>
    if (Timeout != HAL_MAX_DELAY)
240087e8:	f1b8 3fff 	cmp.w	r8, #4294967295
240087ec:	d0f3      	beq.n	240087d6 <QSPI_WaitFlagStateUntilTimeout+0x12>
      if(((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
240087ee:	f009 fb0b 	bl	24011e08 <HAL_GetTick>
240087f2:	1bc0      	subs	r0, r0, r7
240087f4:	4540      	cmp	r0, r8
240087f6:	d802      	bhi.n	240087fe <QSPI_WaitFlagStateUntilTimeout+0x3a>
240087f8:	f1b8 0f00 	cmp.w	r8, #0
240087fc:	d1ea      	bne.n	240087d4 <QSPI_WaitFlagStateUntilTimeout+0x10>
        hqspi->State     = HAL_QSPI_STATE_ERROR;
240087fe:	2304      	movs	r3, #4
        hqspi->ErrorCode |= HAL_QSPI_ERROR_TIMEOUT;
24008800:	2001      	movs	r0, #1
        hqspi->State     = HAL_QSPI_STATE_ERROR;
24008802:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
        hqspi->ErrorCode |= HAL_QSPI_ERROR_TIMEOUT;
24008806:	6c63      	ldr	r3, [r4, #68]	@ 0x44
24008808:	f043 0301 	orr.w	r3, r3, #1
2400880c:	6463      	str	r3, [r4, #68]	@ 0x44
}
2400880e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
}
24008812:	4770      	bx	lr

24008814 <HAL_QSPI_Init>:
{
24008814:	b537      	push	{r0, r1, r2, r4, r5, lr}
24008816:	4604      	mov	r4, r0
  uint32_t tickstart = HAL_GetTick();
24008818:	f009 faf6 	bl	24011e08 <HAL_GetTick>
2400881c:	4605      	mov	r5, r0
  if(hqspi == NULL)
2400881e:	2c00      	cmp	r4, #0
24008820:	d03f      	beq.n	240088a2 <HAL_QSPI_Init+0x8e>
  if(hqspi->State == HAL_QSPI_STATE_RESET)
24008822:	f894 3041 	ldrb.w	r3, [r4, #65]	@ 0x41
24008826:	b92b      	cbnz	r3, 24008834 <HAL_QSPI_Init+0x20>
    HAL_QSPI_MspInit(hqspi);
24008828:	4620      	mov	r0, r4
2400882a:	f009 fcfb 	bl	24012224 <HAL_QSPI_MspInit>
  hqspi->Timeout = Timeout;
2400882e:	f241 3388 	movw	r3, #5000	@ 0x1388
24008832:	64a3      	str	r3, [r4, #72]	@ 0x48
  MODIFY_REG(hqspi->Instance->CR, QUADSPI_CR_FTHRES,
24008834:	6821      	ldr	r1, [r4, #0]
  status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, hqspi->Timeout);
24008836:	4620      	mov	r0, r4
  MODIFY_REG(hqspi->Instance->CR, QUADSPI_CR_FTHRES,
24008838:	68a3      	ldr	r3, [r4, #8]
2400883a:	680a      	ldr	r2, [r1, #0]
2400883c:	3b01      	subs	r3, #1
2400883e:	f422 6270 	bic.w	r2, r2, #3840	@ 0xf00
24008842:	ea42 2203 	orr.w	r2, r2, r3, lsl #8
  status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, hqspi->Timeout);
24008846:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
  MODIFY_REG(hqspi->Instance->CR, QUADSPI_CR_FTHRES,
24008848:	600a      	str	r2, [r1, #0]
  status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, hqspi->Timeout);
2400884a:	2200      	movs	r2, #0
2400884c:	9300      	str	r3, [sp, #0]
2400884e:	2120      	movs	r1, #32
24008850:	462b      	mov	r3, r5
24008852:	f7ff ffb7 	bl	240087c4 <QSPI_WaitFlagStateUntilTimeout>
  if(status == HAL_OK)
24008856:	bb10      	cbnz	r0, 2400889e <HAL_QSPI_Init+0x8a>
    MODIFY_REG(hqspi->Instance->CR, (QUADSPI_CR_PRESCALER | QUADSPI_CR_SSHIFT | QUADSPI_CR_FSEL | QUADSPI_CR_DFM),
24008858:	6822      	ldr	r2, [r4, #0]
2400885a:	69e5      	ldr	r5, [r4, #28]
2400885c:	68e3      	ldr	r3, [r4, #12]
2400885e:	6811      	ldr	r1, [r2, #0]
24008860:	432b      	orrs	r3, r5
24008862:	6a25      	ldr	r5, [r4, #32]
24008864:	f021 417f 	bic.w	r1, r1, #4278190080	@ 0xff000000
24008868:	432b      	orrs	r3, r5
2400886a:	6865      	ldr	r5, [r4, #4]
2400886c:	f021 01d0 	bic.w	r1, r1, #208	@ 0xd0
24008870:	ea43 6305 	orr.w	r3, r3, r5, lsl #24
24008874:	430b      	orrs	r3, r1
24008876:	6013      	str	r3, [r2, #0]
    MODIFY_REG(hqspi->Instance->DCR, (QUADSPI_DCR_FSIZE | QUADSPI_DCR_CSHT | QUADSPI_DCR_CKMODE),
24008878:	6855      	ldr	r5, [r2, #4]
2400887a:	e9d4 3105 	ldrd	r3, r1, [r4, #20]
2400887e:	430b      	orrs	r3, r1
24008880:	6921      	ldr	r1, [r4, #16]
24008882:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
24008886:	4908      	ldr	r1, [pc, #32]	@ (240088a8 <HAL_QSPI_Init+0x94>)
24008888:	4029      	ands	r1, r5
2400888a:	430b      	orrs	r3, r1
2400888c:	6053      	str	r3, [r2, #4]
    __HAL_QSPI_ENABLE(hqspi);
2400888e:	6813      	ldr	r3, [r2, #0]
24008890:	f043 0301 	orr.w	r3, r3, #1
24008894:	6013      	str	r3, [r2, #0]
    hqspi->State = HAL_QSPI_STATE_READY;
24008896:	2301      	movs	r3, #1
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
24008898:	6460      	str	r0, [r4, #68]	@ 0x44
    hqspi->State = HAL_QSPI_STATE_READY;
2400889a:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
}
2400889e:	b003      	add	sp, #12
240088a0:	bd30      	pop	{r4, r5, pc}
    return HAL_ERROR;
240088a2:	2001      	movs	r0, #1
240088a4:	e7fb      	b.n	2400889e <HAL_QSPI_Init+0x8a>
240088a6:	bf00      	nop
240088a8:	ffe0f8fe 	.word	0xffe0f8fe
__weak void HAL_QSPI_MspDeInit(QSPI_HandleTypeDef *hqspi)
240088ac:	4770      	bx	lr

240088ae <HAL_QSPI_DeInit>:
{
240088ae:	b510      	push	{r4, lr}
  if(hqspi == NULL)
240088b0:	4604      	mov	r4, r0
240088b2:	b158      	cbz	r0, 240088cc <HAL_QSPI_DeInit+0x1e>
  __HAL_QSPI_DISABLE(hqspi);
240088b4:	6802      	ldr	r2, [r0, #0]
240088b6:	6813      	ldr	r3, [r2, #0]
240088b8:	f023 0301 	bic.w	r3, r3, #1
240088bc:	6013      	str	r3, [r2, #0]
  HAL_QSPI_MspDeInit(hqspi);
240088be:	f009 fd39 	bl	24012334 <HAL_QSPI_MspDeInit>
  hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
240088c2:	2000      	movs	r0, #0
240088c4:	6460      	str	r0, [r4, #68]	@ 0x44
  hqspi->State = HAL_QSPI_STATE_RESET;
240088c6:	f884 0041 	strb.w	r0, [r4, #65]	@ 0x41
}
240088ca:	bd10      	pop	{r4, pc}
    return HAL_ERROR;
240088cc:	2001      	movs	r0, #1
240088ce:	e7fc      	b.n	240088ca <HAL_QSPI_DeInit+0x1c>

240088d0 <HAL_QSPI_Command>:
{
240088d0:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
240088d4:	4604      	mov	r4, r0
240088d6:	468a      	mov	sl, r1
240088d8:	4690      	mov	r8, r2
  uint32_t tickstart = HAL_GetTick();
240088da:	f009 fa95 	bl	24011e08 <HAL_GetTick>
  __HAL_LOCK(hqspi);
240088de:	f894 3040 	ldrb.w	r3, [r4, #64]	@ 0x40
  uint32_t tickstart = HAL_GetTick();
240088e2:	4607      	mov	r7, r0
  __HAL_LOCK(hqspi);
240088e4:	2b01      	cmp	r3, #1
240088e6:	d036      	beq.n	24008956 <HAL_QSPI_Command+0x86>
240088e8:	2301      	movs	r3, #1
240088ea:	2602      	movs	r6, #2
240088ec:	f884 3040 	strb.w	r3, [r4, #64]	@ 0x40
  if(hqspi->State == HAL_QSPI_STATE_READY)
240088f0:	f894 3041 	ldrb.w	r3, [r4, #65]	@ 0x41
240088f4:	2b01      	cmp	r3, #1
240088f6:	fa5f f983 	uxtb.w	r9, r3
240088fa:	d128      	bne.n	2400894e <HAL_QSPI_Command+0x7e>
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
240088fc:	2200      	movs	r2, #0
    status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, Timeout);
240088fe:	4603      	mov	r3, r0
24008900:	2120      	movs	r1, #32
24008902:	4620      	mov	r0, r4
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
24008904:	6462      	str	r2, [r4, #68]	@ 0x44
    hqspi->State = HAL_QSPI_STATE_BUSY;
24008906:	f884 6041 	strb.w	r6, [r4, #65]	@ 0x41
    status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, Timeout);
2400890a:	f8cd 8000 	str.w	r8, [sp]
2400890e:	f7ff ff59 	bl	240087c4 <QSPI_WaitFlagStateUntilTimeout>
    if (status == HAL_OK)
24008912:	4605      	mov	r5, r0
24008914:	b9a0      	cbnz	r0, 24008940 <HAL_QSPI_Command+0x70>
      QSPI_Config(hqspi, cmd, QSPI_FUNCTIONAL_MODE_INDIRECT_WRITE);
24008916:	4602      	mov	r2, r0
24008918:	4651      	mov	r1, sl
2400891a:	4620      	mov	r0, r4
2400891c:	f7ff fe98 	bl	24008650 <QSPI_Config>
      if (cmd->DataMode == QSPI_DATA_NONE)
24008920:	f8da 3024 	ldr.w	r3, [sl, #36]	@ 0x24
24008924:	b953      	cbnz	r3, 2400893c <HAL_QSPI_Command+0x6c>
        status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_TC, SET, tickstart, Timeout);
24008926:	463b      	mov	r3, r7
24008928:	464a      	mov	r2, r9
2400892a:	4631      	mov	r1, r6
2400892c:	4620      	mov	r0, r4
2400892e:	f8cd 8000 	str.w	r8, [sp]
24008932:	f7ff ff47 	bl	240087c4 <QSPI_WaitFlagStateUntilTimeout>
        if (status == HAL_OK)
24008936:	b960      	cbnz	r0, 24008952 <HAL_QSPI_Command+0x82>
          __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TC);
24008938:	6823      	ldr	r3, [r4, #0]
2400893a:	60de      	str	r6, [r3, #12]
        hqspi->State = HAL_QSPI_STATE_READY;
2400893c:	f884 9041 	strb.w	r9, [r4, #65]	@ 0x41
  __HAL_UNLOCK(hqspi);
24008940:	2300      	movs	r3, #0
24008942:	f884 3040 	strb.w	r3, [r4, #64]	@ 0x40
}
24008946:	4628      	mov	r0, r5
24008948:	b002      	add	sp, #8
2400894a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    status = HAL_BUSY;
2400894e:	4635      	mov	r5, r6
24008950:	e7f6      	b.n	24008940 <HAL_QSPI_Command+0x70>
24008952:	4605      	mov	r5, r0
24008954:	e7f4      	b.n	24008940 <HAL_QSPI_Command+0x70>
  __HAL_LOCK(hqspi);
24008956:	2502      	movs	r5, #2
24008958:	e7f5      	b.n	24008946 <HAL_QSPI_Command+0x76>

2400895a <HAL_QSPI_Command_IT>:
{
2400895a:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
2400895c:	4604      	mov	r4, r0
2400895e:	460f      	mov	r7, r1
  uint32_t tickstart = HAL_GetTick();
24008960:	f009 fa52 	bl	24011e08 <HAL_GetTick>
24008964:	4603      	mov	r3, r0
  __HAL_LOCK(hqspi);
24008966:	f894 2040 	ldrb.w	r2, [r4, #64]	@ 0x40
2400896a:	2a01      	cmp	r2, #1
2400896c:	d035      	beq.n	240089da <HAL_QSPI_Command_IT+0x80>
2400896e:	2201      	movs	r2, #1
24008970:	2600      	movs	r6, #0
24008972:	f884 2040 	strb.w	r2, [r4, #64]	@ 0x40
  if(hqspi->State == HAL_QSPI_STATE_READY)
24008976:	f894 2041 	ldrb.w	r2, [r4, #65]	@ 0x41
2400897a:	2a01      	cmp	r2, #1
2400897c:	d12b      	bne.n	240089d6 <HAL_QSPI_Command_IT+0x7c>
    hqspi->State = HAL_QSPI_STATE_BUSY;
2400897e:	2202      	movs	r2, #2
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
24008980:	6466      	str	r6, [r4, #68]	@ 0x44
    status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, hqspi->Timeout);
24008982:	2120      	movs	r1, #32
24008984:	4620      	mov	r0, r4
    hqspi->State = HAL_QSPI_STATE_BUSY;
24008986:	f884 2041 	strb.w	r2, [r4, #65]	@ 0x41
    status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, hqspi->Timeout);
2400898a:	6ca2      	ldr	r2, [r4, #72]	@ 0x48
2400898c:	9200      	str	r2, [sp, #0]
2400898e:	4632      	mov	r2, r6
24008990:	f7ff ff18 	bl	240087c4 <QSPI_WaitFlagStateUntilTimeout>
    if (status == HAL_OK)
24008994:	4605      	mov	r5, r0
24008996:	b9d8      	cbnz	r0, 240089d0 <HAL_QSPI_Command_IT+0x76>
      if (cmd->DataMode == QSPI_DATA_NONE)
24008998:	6a7e      	ldr	r6, [r7, #36]	@ 0x24
2400899a:	b916      	cbnz	r6, 240089a2 <HAL_QSPI_Command_IT+0x48>
        __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TE | QSPI_FLAG_TC);
2400899c:	6823      	ldr	r3, [r4, #0]
2400899e:	2203      	movs	r2, #3
240089a0:	60da      	str	r2, [r3, #12]
      QSPI_Config(hqspi, cmd, QSPI_FUNCTIONAL_MODE_INDIRECT_WRITE);
240089a2:	2200      	movs	r2, #0
240089a4:	4639      	mov	r1, r7
240089a6:	4620      	mov	r0, r4
240089a8:	f7ff fe52 	bl	24008650 <QSPI_Config>
      if (cmd->DataMode == QSPI_DATA_NONE)
240089ac:	b94e      	cbnz	r6, 240089c2 <HAL_QSPI_Command_IT+0x68>
        __HAL_QSPI_ENABLE_IT(hqspi, QSPI_IT_TE | QSPI_IT_TC);
240089ae:	6822      	ldr	r2, [r4, #0]
        __HAL_UNLOCK(hqspi);
240089b0:	f884 6040 	strb.w	r6, [r4, #64]	@ 0x40
        __HAL_QSPI_ENABLE_IT(hqspi, QSPI_IT_TE | QSPI_IT_TC);
240089b4:	6813      	ldr	r3, [r2, #0]
240089b6:	f443 3340 	orr.w	r3, r3, #196608	@ 0x30000
240089ba:	6013      	str	r3, [r2, #0]
}
240089bc:	4628      	mov	r0, r5
240089be:	b003      	add	sp, #12
240089c0:	bdf0      	pop	{r4, r5, r6, r7, pc}
        hqspi->State = HAL_QSPI_STATE_READY;
240089c2:	2301      	movs	r3, #1
240089c4:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
        __HAL_UNLOCK(hqspi);
240089c8:	2300      	movs	r3, #0
240089ca:	f884 3040 	strb.w	r3, [r4, #64]	@ 0x40
240089ce:	e7f5      	b.n	240089bc <HAL_QSPI_Command_IT+0x62>
      __HAL_UNLOCK(hqspi);
240089d0:	f884 6040 	strb.w	r6, [r4, #64]	@ 0x40
240089d4:	e7f2      	b.n	240089bc <HAL_QSPI_Command_IT+0x62>
    __HAL_UNLOCK(hqspi);
240089d6:	f884 6040 	strb.w	r6, [r4, #64]	@ 0x40
  __HAL_LOCK(hqspi);
240089da:	2502      	movs	r5, #2
240089dc:	e7ee      	b.n	240089bc <HAL_QSPI_Command_IT+0x62>

240089de <HAL_QSPI_Transmit>:
{
240089de:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
240089e2:	4604      	mov	r4, r0
240089e4:	4688      	mov	r8, r1
240089e6:	4617      	mov	r7, r2
  uint32_t tickstart = HAL_GetTick();
240089e8:	f009 fa0e 	bl	24011e08 <HAL_GetTick>
  __HAL_LOCK(hqspi);
240089ec:	f894 3040 	ldrb.w	r3, [r4, #64]	@ 0x40
  uint32_t tickstart = HAL_GetTick();
240089f0:	4606      	mov	r6, r0
  __IO uint32_t *data_reg = &hqspi->Instance->DR;
240089f2:	6825      	ldr	r5, [r4, #0]
  __HAL_LOCK(hqspi);
240089f4:	2b01      	cmp	r3, #1
240089f6:	d04c      	beq.n	24008a92 <HAL_QSPI_Transmit+0xb4>
240089f8:	2301      	movs	r3, #1
240089fa:	f884 3040 	strb.w	r3, [r4, #64]	@ 0x40
  if(hqspi->State == HAL_QSPI_STATE_READY)
240089fe:	f894 3041 	ldrb.w	r3, [r4, #65]	@ 0x41
24008a02:	2b01      	cmp	r3, #1
24008a04:	b2d8      	uxtb	r0, r3
24008a06:	d142      	bne.n	24008a8e <HAL_QSPI_Transmit+0xb0>
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
24008a08:	2300      	movs	r3, #0
24008a0a:	6463      	str	r3, [r4, #68]	@ 0x44
    if(pData != NULL )
24008a0c:	f1b8 0f00 	cmp.w	r8, #0
24008a10:	d038      	beq.n	24008a84 <HAL_QSPI_Transmit+0xa6>
      hqspi->State = HAL_QSPI_STATE_BUSY_INDIRECT_TX;
24008a12:	2312      	movs	r3, #18
24008a14:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
      hqspi->TxXferCount = READ_REG(hqspi->Instance->DLR) + 1U;
24008a18:	692b      	ldr	r3, [r5, #16]
24008a1a:	3301      	adds	r3, #1
24008a1c:	62e3      	str	r3, [r4, #44]	@ 0x2c
      hqspi->TxXferSize = READ_REG(hqspi->Instance->DLR) + 1U;
24008a1e:	692b      	ldr	r3, [r5, #16]
      hqspi->pTxBuffPtr = pData;
24008a20:	f8c4 8024 	str.w	r8, [r4, #36]	@ 0x24
      hqspi->TxXferSize = READ_REG(hqspi->Instance->DLR) + 1U;
24008a24:	3301      	adds	r3, #1
24008a26:	62a3      	str	r3, [r4, #40]	@ 0x28
      MODIFY_REG(hqspi->Instance->CCR, QUADSPI_CCR_FMODE, QSPI_FUNCTIONAL_MODE_INDIRECT_WRITE);
24008a28:	696b      	ldr	r3, [r5, #20]
24008a2a:	f023 6340 	bic.w	r3, r3, #201326592	@ 0xc000000
24008a2e:	616b      	str	r3, [r5, #20]
      while(hqspi->TxXferCount > 0U)
24008a30:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
24008a32:	b99b      	cbnz	r3, 24008a5c <HAL_QSPI_Transmit+0x7e>
        status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_TC, SET, tickstart, Timeout);
24008a34:	4633      	mov	r3, r6
24008a36:	2201      	movs	r2, #1
24008a38:	2102      	movs	r1, #2
24008a3a:	4620      	mov	r0, r4
24008a3c:	9700      	str	r7, [sp, #0]
24008a3e:	f7ff fec1 	bl	240087c4 <QSPI_WaitFlagStateUntilTimeout>
        if (status == HAL_OK)
24008a42:	b910      	cbnz	r0, 24008a4a <HAL_QSPI_Transmit+0x6c>
          __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TC);
24008a44:	6823      	ldr	r3, [r4, #0]
24008a46:	2202      	movs	r2, #2
24008a48:	60da      	str	r2, [r3, #12]
      hqspi->State = HAL_QSPI_STATE_READY;
24008a4a:	2301      	movs	r3, #1
24008a4c:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
  __HAL_UNLOCK(hqspi);
24008a50:	2300      	movs	r3, #0
24008a52:	f884 3040 	strb.w	r3, [r4, #64]	@ 0x40
}
24008a56:	b002      	add	sp, #8
24008a58:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_FT, SET, tickstart, Timeout);
24008a5c:	4633      	mov	r3, r6
24008a5e:	2201      	movs	r2, #1
24008a60:	2104      	movs	r1, #4
24008a62:	4620      	mov	r0, r4
24008a64:	9700      	str	r7, [sp, #0]
24008a66:	f7ff fead 	bl	240087c4 <QSPI_WaitFlagStateUntilTimeout>
        if (status != HAL_OK)
24008a6a:	2800      	cmp	r0, #0
24008a6c:	d1ed      	bne.n	24008a4a <HAL_QSPI_Transmit+0x6c>
        *((__IO uint8_t *)data_reg) = *hqspi->pTxBuffPtr;
24008a6e:	6a63      	ldr	r3, [r4, #36]	@ 0x24
24008a70:	781b      	ldrb	r3, [r3, #0]
24008a72:	f885 3020 	strb.w	r3, [r5, #32]
        hqspi->pTxBuffPtr++;
24008a76:	6a63      	ldr	r3, [r4, #36]	@ 0x24
24008a78:	3301      	adds	r3, #1
24008a7a:	6263      	str	r3, [r4, #36]	@ 0x24
        hqspi->TxXferCount--;
24008a7c:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
24008a7e:	3b01      	subs	r3, #1
24008a80:	62e3      	str	r3, [r4, #44]	@ 0x2c
24008a82:	e7d5      	b.n	24008a30 <HAL_QSPI_Transmit+0x52>
      hqspi->ErrorCode |= HAL_QSPI_ERROR_INVALID_PARAM;
24008a84:	6c63      	ldr	r3, [r4, #68]	@ 0x44
24008a86:	f043 0308 	orr.w	r3, r3, #8
24008a8a:	6463      	str	r3, [r4, #68]	@ 0x44
      status = HAL_ERROR;
24008a8c:	e7e0      	b.n	24008a50 <HAL_QSPI_Transmit+0x72>
    status = HAL_BUSY;
24008a8e:	2002      	movs	r0, #2
24008a90:	e7de      	b.n	24008a50 <HAL_QSPI_Transmit+0x72>
  __HAL_LOCK(hqspi);
24008a92:	2002      	movs	r0, #2
24008a94:	e7df      	b.n	24008a56 <HAL_QSPI_Transmit+0x78>

24008a96 <HAL_QSPI_Receive>:
{
24008a96:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
24008a9a:	4604      	mov	r4, r0
24008a9c:	4617      	mov	r7, r2
24008a9e:	4688      	mov	r8, r1
  uint32_t tickstart = HAL_GetTick();
24008aa0:	f009 f9b2 	bl	24011e08 <HAL_GetTick>
  uint32_t addr_reg = READ_REG(hqspi->Instance->AR);
24008aa4:	6825      	ldr	r5, [r4, #0]
  uint32_t tickstart = HAL_GetTick();
24008aa6:	4606      	mov	r6, r0
  uint32_t addr_reg = READ_REG(hqspi->Instance->AR);
24008aa8:	69aa      	ldr	r2, [r5, #24]
  __HAL_LOCK(hqspi);
24008aaa:	f894 3040 	ldrb.w	r3, [r4, #64]	@ 0x40
24008aae:	2b01      	cmp	r3, #1
24008ab0:	d04f      	beq.n	24008b52 <HAL_QSPI_Receive+0xbc>
24008ab2:	2301      	movs	r3, #1
24008ab4:	f884 3040 	strb.w	r3, [r4, #64]	@ 0x40
  if(hqspi->State == HAL_QSPI_STATE_READY)
24008ab8:	f894 3041 	ldrb.w	r3, [r4, #65]	@ 0x41
24008abc:	2b01      	cmp	r3, #1
24008abe:	b2d8      	uxtb	r0, r3
24008ac0:	d145      	bne.n	24008b4e <HAL_QSPI_Receive+0xb8>
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
24008ac2:	2300      	movs	r3, #0
24008ac4:	6463      	str	r3, [r4, #68]	@ 0x44
    if(pData != NULL )
24008ac6:	f1b8 0f00 	cmp.w	r8, #0
24008aca:	d03b      	beq.n	24008b44 <HAL_QSPI_Receive+0xae>
      hqspi->State = HAL_QSPI_STATE_BUSY_INDIRECT_RX;
24008acc:	2322      	movs	r3, #34	@ 0x22
24008ace:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
      hqspi->RxXferCount = READ_REG(hqspi->Instance->DLR) + 1U;
24008ad2:	692b      	ldr	r3, [r5, #16]
24008ad4:	3301      	adds	r3, #1
24008ad6:	63a3      	str	r3, [r4, #56]	@ 0x38
      hqspi->RxXferSize = READ_REG(hqspi->Instance->DLR) + 1U;
24008ad8:	692b      	ldr	r3, [r5, #16]
      hqspi->pRxBuffPtr = pData;
24008ada:	f8c4 8030 	str.w	r8, [r4, #48]	@ 0x30
      hqspi->RxXferSize = READ_REG(hqspi->Instance->DLR) + 1U;
24008ade:	3301      	adds	r3, #1
24008ae0:	6363      	str	r3, [r4, #52]	@ 0x34
      MODIFY_REG(hqspi->Instance->CCR, QUADSPI_CCR_FMODE, QSPI_FUNCTIONAL_MODE_INDIRECT_READ);
24008ae2:	6969      	ldr	r1, [r5, #20]
24008ae4:	f021 6140 	bic.w	r1, r1, #201326592	@ 0xc000000
24008ae8:	f041 6180 	orr.w	r1, r1, #67108864	@ 0x4000000
24008aec:	6169      	str	r1, [r5, #20]
      WRITE_REG(hqspi->Instance->AR, addr_reg);
24008aee:	61aa      	str	r2, [r5, #24]
      while(hqspi->RxXferCount > 0U)
24008af0:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
24008af2:	b99b      	cbnz	r3, 24008b1c <HAL_QSPI_Receive+0x86>
        status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_TC, SET, tickstart, Timeout);
24008af4:	4633      	mov	r3, r6
24008af6:	2201      	movs	r2, #1
24008af8:	2102      	movs	r1, #2
24008afa:	4620      	mov	r0, r4
24008afc:	9700      	str	r7, [sp, #0]
24008afe:	f7ff fe61 	bl	240087c4 <QSPI_WaitFlagStateUntilTimeout>
        if  (status == HAL_OK)
24008b02:	b910      	cbnz	r0, 24008b0a <HAL_QSPI_Receive+0x74>
          __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TC);
24008b04:	6823      	ldr	r3, [r4, #0]
24008b06:	2202      	movs	r2, #2
24008b08:	60da      	str	r2, [r3, #12]
      hqspi->State = HAL_QSPI_STATE_READY;
24008b0a:	2301      	movs	r3, #1
24008b0c:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
  __HAL_UNLOCK(hqspi);
24008b10:	2300      	movs	r3, #0
24008b12:	f884 3040 	strb.w	r3, [r4, #64]	@ 0x40
}
24008b16:	b002      	add	sp, #8
24008b18:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        status = QSPI_WaitFlagStateUntilTimeout(hqspi, (QSPI_FLAG_FT | QSPI_FLAG_TC), SET, tickstart, Timeout);
24008b1c:	4633      	mov	r3, r6
24008b1e:	2201      	movs	r2, #1
24008b20:	2106      	movs	r1, #6
24008b22:	4620      	mov	r0, r4
24008b24:	9700      	str	r7, [sp, #0]
24008b26:	f7ff fe4d 	bl	240087c4 <QSPI_WaitFlagStateUntilTimeout>
        if  (status != HAL_OK)
24008b2a:	2800      	cmp	r0, #0
24008b2c:	d1ed      	bne.n	24008b0a <HAL_QSPI_Receive+0x74>
        *hqspi->pRxBuffPtr = *((__IO uint8_t *)data_reg);
24008b2e:	f895 2020 	ldrb.w	r2, [r5, #32]
24008b32:	6b23      	ldr	r3, [r4, #48]	@ 0x30
24008b34:	701a      	strb	r2, [r3, #0]
        hqspi->pRxBuffPtr++;
24008b36:	6b23      	ldr	r3, [r4, #48]	@ 0x30
24008b38:	3301      	adds	r3, #1
24008b3a:	6323      	str	r3, [r4, #48]	@ 0x30
        hqspi->RxXferCount--;
24008b3c:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
24008b3e:	3b01      	subs	r3, #1
24008b40:	63a3      	str	r3, [r4, #56]	@ 0x38
24008b42:	e7d5      	b.n	24008af0 <HAL_QSPI_Receive+0x5a>
      hqspi->ErrorCode |= HAL_QSPI_ERROR_INVALID_PARAM;
24008b44:	6c63      	ldr	r3, [r4, #68]	@ 0x44
24008b46:	f043 0308 	orr.w	r3, r3, #8
24008b4a:	6463      	str	r3, [r4, #68]	@ 0x44
      status = HAL_ERROR;
24008b4c:	e7e0      	b.n	24008b10 <HAL_QSPI_Receive+0x7a>
    status = HAL_BUSY;
24008b4e:	2002      	movs	r0, #2
24008b50:	e7de      	b.n	24008b10 <HAL_QSPI_Receive+0x7a>
  __HAL_LOCK(hqspi);
24008b52:	2002      	movs	r0, #2
24008b54:	e7df      	b.n	24008b16 <HAL_QSPI_Receive+0x80>

24008b56 <HAL_QSPI_Transmit_IT>:
{
24008b56:	b510      	push	{r4, lr}
  __HAL_LOCK(hqspi);
24008b58:	f890 2040 	ldrb.w	r2, [r0, #64]	@ 0x40
{
24008b5c:	4603      	mov	r3, r0
  __HAL_LOCK(hqspi);
24008b5e:	2a01      	cmp	r2, #1
24008b60:	d02c      	beq.n	24008bbc <HAL_QSPI_Transmit_IT+0x66>
24008b62:	2201      	movs	r2, #1
24008b64:	2400      	movs	r4, #0
24008b66:	f880 2040 	strb.w	r2, [r0, #64]	@ 0x40
  if(hqspi->State == HAL_QSPI_STATE_READY)
24008b6a:	f890 2041 	ldrb.w	r2, [r0, #65]	@ 0x41
24008b6e:	2a01      	cmp	r2, #1
24008b70:	b2d0      	uxtb	r0, r2
24008b72:	d121      	bne.n	24008bb8 <HAL_QSPI_Transmit_IT+0x62>
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
24008b74:	645c      	str	r4, [r3, #68]	@ 0x44
    if(pData != NULL )
24008b76:	b1c1      	cbz	r1, 24008baa <HAL_QSPI_Transmit_IT+0x54>
      hqspi->State = HAL_QSPI_STATE_BUSY_INDIRECT_TX;
24008b78:	2212      	movs	r2, #18
24008b7a:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
      hqspi->TxXferCount = READ_REG(hqspi->Instance->DLR) + 1U;
24008b7e:	681a      	ldr	r2, [r3, #0]
24008b80:	6910      	ldr	r0, [r2, #16]
24008b82:	3001      	adds	r0, #1
24008b84:	62d8      	str	r0, [r3, #44]	@ 0x2c
      hqspi->TxXferSize = READ_REG(hqspi->Instance->DLR) + 1U;
24008b86:	6910      	ldr	r0, [r2, #16]
      hqspi->pTxBuffPtr = pData;
24008b88:	6259      	str	r1, [r3, #36]	@ 0x24
      __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TE | QSPI_FLAG_TC);
24008b8a:	2103      	movs	r1, #3
      hqspi->TxXferSize = READ_REG(hqspi->Instance->DLR) + 1U;
24008b8c:	3001      	adds	r0, #1
24008b8e:	6298      	str	r0, [r3, #40]	@ 0x28
  HAL_StatusTypeDef status = HAL_OK;
24008b90:	4620      	mov	r0, r4
      __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TE | QSPI_FLAG_TC);
24008b92:	60d1      	str	r1, [r2, #12]
      MODIFY_REG(hqspi->Instance->CCR, QUADSPI_CCR_FMODE, QSPI_FUNCTIONAL_MODE_INDIRECT_WRITE);
24008b94:	6951      	ldr	r1, [r2, #20]
24008b96:	f021 6140 	bic.w	r1, r1, #201326592	@ 0xc000000
24008b9a:	6151      	str	r1, [r2, #20]
      __HAL_UNLOCK(hqspi);
24008b9c:	f883 4040 	strb.w	r4, [r3, #64]	@ 0x40
      __HAL_QSPI_ENABLE_IT(hqspi, QSPI_IT_TE | QSPI_IT_FT | QSPI_IT_TC);
24008ba0:	6813      	ldr	r3, [r2, #0]
24008ba2:	f443 23e0 	orr.w	r3, r3, #458752	@ 0x70000
24008ba6:	6013      	str	r3, [r2, #0]
}
24008ba8:	bd10      	pop	{r4, pc}
      hqspi->ErrorCode |= HAL_QSPI_ERROR_INVALID_PARAM;
24008baa:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
24008bac:	f042 0208 	orr.w	r2, r2, #8
24008bb0:	645a      	str	r2, [r3, #68]	@ 0x44
      __HAL_UNLOCK(hqspi);
24008bb2:	f883 1040 	strb.w	r1, [r3, #64]	@ 0x40
24008bb6:	e7f7      	b.n	24008ba8 <HAL_QSPI_Transmit_IT+0x52>
    __HAL_UNLOCK(hqspi);
24008bb8:	f883 4040 	strb.w	r4, [r3, #64]	@ 0x40
  __HAL_LOCK(hqspi);
24008bbc:	2002      	movs	r0, #2
24008bbe:	e7f3      	b.n	24008ba8 <HAL_QSPI_Transmit_IT+0x52>

24008bc0 <HAL_QSPI_Receive_IT>:
  uint32_t addr_reg = READ_REG(hqspi->Instance->AR);
24008bc0:	6802      	ldr	r2, [r0, #0]
{
24008bc2:	4603      	mov	r3, r0
24008bc4:	b530      	push	{r4, r5, lr}
  uint32_t addr_reg = READ_REG(hqspi->Instance->AR);
24008bc6:	6995      	ldr	r5, [r2, #24]
  __HAL_LOCK(hqspi);
24008bc8:	f890 0040 	ldrb.w	r0, [r0, #64]	@ 0x40
24008bcc:	2801      	cmp	r0, #1
24008bce:	d02f      	beq.n	24008c30 <HAL_QSPI_Receive_IT+0x70>
24008bd0:	2001      	movs	r0, #1
24008bd2:	f883 0040 	strb.w	r0, [r3, #64]	@ 0x40
  if(hqspi->State == HAL_QSPI_STATE_READY)
24008bd6:	f893 4041 	ldrb.w	r4, [r3, #65]	@ 0x41
24008bda:	2c01      	cmp	r4, #1
24008bdc:	b2e0      	uxtb	r0, r4
24008bde:	f04f 0400 	mov.w	r4, #0
24008be2:	d123      	bne.n	24008c2c <HAL_QSPI_Receive_IT+0x6c>
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
24008be4:	645c      	str	r4, [r3, #68]	@ 0x44
    if(pData != NULL )
24008be6:	b1d1      	cbz	r1, 24008c1e <HAL_QSPI_Receive_IT+0x5e>
      hqspi->State = HAL_QSPI_STATE_BUSY_INDIRECT_RX;
24008be8:	2022      	movs	r0, #34	@ 0x22
24008bea:	f883 0041 	strb.w	r0, [r3, #65]	@ 0x41
      hqspi->RxXferCount = READ_REG(hqspi->Instance->DLR) + 1U;
24008bee:	6910      	ldr	r0, [r2, #16]
24008bf0:	3001      	adds	r0, #1
24008bf2:	6398      	str	r0, [r3, #56]	@ 0x38
      hqspi->RxXferSize = READ_REG(hqspi->Instance->DLR) + 1U;
24008bf4:	6910      	ldr	r0, [r2, #16]
      hqspi->pRxBuffPtr = pData;
24008bf6:	6319      	str	r1, [r3, #48]	@ 0x30
      __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TE | QSPI_FLAG_TC);
24008bf8:	2103      	movs	r1, #3
      hqspi->RxXferSize = READ_REG(hqspi->Instance->DLR) + 1U;
24008bfa:	3001      	adds	r0, #1
24008bfc:	6358      	str	r0, [r3, #52]	@ 0x34
  HAL_StatusTypeDef status = HAL_OK;
24008bfe:	4620      	mov	r0, r4
      __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TE | QSPI_FLAG_TC);
24008c00:	60d1      	str	r1, [r2, #12]
      MODIFY_REG(hqspi->Instance->CCR, QUADSPI_CCR_FMODE, QSPI_FUNCTIONAL_MODE_INDIRECT_READ);
24008c02:	6951      	ldr	r1, [r2, #20]
24008c04:	f021 6140 	bic.w	r1, r1, #201326592	@ 0xc000000
24008c08:	f041 6180 	orr.w	r1, r1, #67108864	@ 0x4000000
24008c0c:	6151      	str	r1, [r2, #20]
      WRITE_REG(hqspi->Instance->AR, addr_reg);
24008c0e:	6195      	str	r5, [r2, #24]
      __HAL_UNLOCK(hqspi);
24008c10:	f883 4040 	strb.w	r4, [r3, #64]	@ 0x40
      __HAL_QSPI_ENABLE_IT(hqspi, QSPI_IT_TE | QSPI_IT_FT | QSPI_IT_TC);
24008c14:	6813      	ldr	r3, [r2, #0]
24008c16:	f443 23e0 	orr.w	r3, r3, #458752	@ 0x70000
24008c1a:	6013      	str	r3, [r2, #0]
}
24008c1c:	bd30      	pop	{r4, r5, pc}
      hqspi->ErrorCode |= HAL_QSPI_ERROR_INVALID_PARAM;
24008c1e:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
24008c20:	f042 0208 	orr.w	r2, r2, #8
24008c24:	645a      	str	r2, [r3, #68]	@ 0x44
      __HAL_UNLOCK(hqspi);
24008c26:	f883 1040 	strb.w	r1, [r3, #64]	@ 0x40
24008c2a:	e7f7      	b.n	24008c1c <HAL_QSPI_Receive_IT+0x5c>
    __HAL_UNLOCK(hqspi);
24008c2c:	f883 4040 	strb.w	r4, [r3, #64]	@ 0x40
  __HAL_LOCK(hqspi);
24008c30:	2002      	movs	r0, #2
24008c32:	e7f3      	b.n	24008c1c <HAL_QSPI_Receive_IT+0x5c>

24008c34 <HAL_QSPI_Transmit_DMA>:
{
24008c34:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
24008c36:	4604      	mov	r4, r0
  uint32_t data_size = (READ_REG(hqspi->Instance->DLR) + 1U);
24008c38:	6802      	ldr	r2, [r0, #0]
24008c3a:	6910      	ldr	r0, [r2, #16]
  __HAL_LOCK(hqspi);
24008c3c:	f894 3040 	ldrb.w	r3, [r4, #64]	@ 0x40
24008c40:	2b01      	cmp	r3, #1
24008c42:	d075      	beq.n	24008d30 <HAL_QSPI_Transmit_DMA+0xfc>
24008c44:	2301      	movs	r3, #1
24008c46:	f884 3040 	strb.w	r3, [r4, #64]	@ 0x40
  if(hqspi->State == HAL_QSPI_STATE_READY)
24008c4a:	f894 3041 	ldrb.w	r3, [r4, #65]	@ 0x41
24008c4e:	2b01      	cmp	r3, #1
24008c50:	b2de      	uxtb	r6, r3
24008c52:	f04f 0300 	mov.w	r3, #0
24008c56:	d169      	bne.n	24008d2c <HAL_QSPI_Transmit_DMA+0xf8>
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
24008c58:	6463      	str	r3, [r4, #68]	@ 0x44
    if(pData != NULL )
24008c5a:	2900      	cmp	r1, #0
24008c5c:	d05f      	beq.n	24008d1e <HAL_QSPI_Transmit_DMA+0xea>
  uint32_t data_size = (READ_REG(hqspi->Instance->DLR) + 1U);
24008c5e:	3001      	adds	r0, #1
        hqspi->hmdma->XferCpltCallback = QSPI_DMATxCplt;
24008c60:	4d34      	ldr	r5, [pc, #208]	@ (24008d34 <HAL_QSPI_Transmit_DMA+0x100>)
      hqspi->TxXferCount = data_size;
24008c62:	62e0      	str	r0, [r4, #44]	@ 0x2c
        hqspi->State = HAL_QSPI_STATE_BUSY_INDIRECT_TX;
24008c64:	2012      	movs	r0, #18
24008c66:	f884 0041 	strb.w	r0, [r4, #65]	@ 0x41
        __HAL_QSPI_CLEAR_FLAG(hqspi, (QSPI_FLAG_TE | QSPI_FLAG_TC));
24008c6a:	2003      	movs	r0, #3
24008c6c:	60d0      	str	r0, [r2, #12]
        hqspi->TxXferSize = hqspi->TxXferCount;
24008c6e:	6ae0      	ldr	r0, [r4, #44]	@ 0x2c
        hqspi->pTxBuffPtr = pData;
24008c70:	6261      	str	r1, [r4, #36]	@ 0x24
        hqspi->TxXferSize = hqspi->TxXferCount;
24008c72:	62a0      	str	r0, [r4, #40]	@ 0x28
        MODIFY_REG(hqspi->Instance->CCR, QUADSPI_CCR_FMODE, QSPI_FUNCTIONAL_MODE_INDIRECT_WRITE);
24008c74:	6950      	ldr	r0, [r2, #20]
24008c76:	f020 6040 	bic.w	r0, r0, #201326592	@ 0xc000000
24008c7a:	6150      	str	r0, [r2, #20]
        hqspi->hmdma->XferCpltCallback = QSPI_DMATxCplt;
24008c7c:	6be0      	ldr	r0, [r4, #60]	@ 0x3c
24008c7e:	6445      	str	r5, [r0, #68]	@ 0x44
        hqspi->hmdma->XferErrorCallback = QSPI_DMAError;
24008c80:	4d2d      	ldr	r5, [pc, #180]	@ (24008d38 <HAL_QSPI_Transmit_DMA+0x104>)
        hqspi->hmdma->XferAbortCallback = NULL;
24008c82:	e9c0 5315 	strd	r5, r3, [r0, #84]	@ 0x54
        MODIFY_REG(hqspi->hmdma->Instance->CTCR, (MDMA_CTCR_DINC | MDMA_CTCR_DINCOS) ,MDMA_DEST_INC_DISABLE);
24008c86:	6805      	ldr	r5, [r0, #0]
24008c88:	692b      	ldr	r3, [r5, #16]
24008c8a:	f423 6340 	bic.w	r3, r3, #3072	@ 0xc00
24008c8e:	f023 030c 	bic.w	r3, r3, #12
24008c92:	612b      	str	r3, [r5, #16]
        if (hqspi->hmdma->Init.SourceDataSize == MDMA_SRC_DATASIZE_BYTE)
24008c94:	69c3      	ldr	r3, [r0, #28]
24008c96:	b93b      	cbnz	r3, 24008ca8 <HAL_QSPI_Transmit_DMA+0x74>
          MODIFY_REG(hqspi->hmdma->Instance->CTCR, (MDMA_CTCR_SINC | MDMA_CTCR_SINCOS) , MDMA_SRC_INC_BYTE);
24008c98:	692b      	ldr	r3, [r5, #16]
24008c9a:	f423 7340 	bic.w	r3, r3, #768	@ 0x300
24008c9e:	f023 0303 	bic.w	r3, r3, #3
          MODIFY_REG(hqspi->hmdma->Instance->CTCR, (MDMA_CTCR_SINC | MDMA_CTCR_SINCOS) , MDMA_SRC_INC_WORD);
24008ca2:	f043 0302 	orr.w	r3, r3, #2
24008ca6:	e008      	b.n	24008cba <HAL_QSPI_Transmit_DMA+0x86>
        else if (hqspi->hmdma->Init.SourceDataSize == MDMA_SRC_DATASIZE_HALFWORD)
24008ca8:	2b10      	cmp	r3, #16
24008caa:	d11e      	bne.n	24008cea <HAL_QSPI_Transmit_DMA+0xb6>
          MODIFY_REG(hqspi->hmdma->Instance->CTCR, (MDMA_CTCR_SINC | MDMA_CTCR_SINCOS) , MDMA_SRC_INC_HALFWORD);
24008cac:	692b      	ldr	r3, [r5, #16]
24008cae:	f423 7340 	bic.w	r3, r3, #768	@ 0x300
24008cb2:	f023 0303 	bic.w	r3, r3, #3
24008cb6:	f443 7381 	orr.w	r3, r3, #258	@ 0x102
24008cba:	612b      	str	r3, [r5, #16]
  HAL_StatusTypeDef status = HAL_OK;
24008cbc:	2500      	movs	r5, #0
        if (HAL_MDMA_Start_IT(hqspi->hmdma, (uint32_t)pData, (uint32_t)&hqspi->Instance->DR, hqspi->TxXferSize, 1) == HAL_OK)
24008cbe:	2701      	movs	r7, #1
24008cc0:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
24008cc2:	3220      	adds	r2, #32
24008cc4:	9700      	str	r7, [sp, #0]
24008cc6:	f7fe ff0b 	bl	24007ae0 <HAL_MDMA_Start_IT>
24008cca:	b9f0      	cbnz	r0, 24008d0a <HAL_QSPI_Transmit_DMA+0xd6>
          __HAL_QSPI_ENABLE_IT(hqspi, QSPI_IT_TE);
24008ccc:	6823      	ldr	r3, [r4, #0]
24008cce:	462e      	mov	r6, r5
          __HAL_UNLOCK(hqspi);
24008cd0:	f884 0040 	strb.w	r0, [r4, #64]	@ 0x40
          __HAL_QSPI_ENABLE_IT(hqspi, QSPI_IT_TE);
24008cd4:	681a      	ldr	r2, [r3, #0]
24008cd6:	f442 3280 	orr.w	r2, r2, #65536	@ 0x10000
24008cda:	601a      	str	r2, [r3, #0]
          SET_BIT(hqspi->Instance->CR, QUADSPI_CR_DMAEN);
24008cdc:	681a      	ldr	r2, [r3, #0]
24008cde:	f042 0204 	orr.w	r2, r2, #4
24008ce2:	601a      	str	r2, [r3, #0]
}
24008ce4:	4630      	mov	r0, r6
24008ce6:	b003      	add	sp, #12
24008ce8:	bdf0      	pop	{r4, r5, r6, r7, pc}
        else if (hqspi->hmdma->Init.SourceDataSize == MDMA_SRC_DATASIZE_WORD)
24008cea:	2b20      	cmp	r3, #32
24008cec:	d107      	bne.n	24008cfe <HAL_QSPI_Transmit_DMA+0xca>
          MODIFY_REG(hqspi->hmdma->Instance->CTCR, (MDMA_CTCR_SINC | MDMA_CTCR_SINCOS) , MDMA_SRC_INC_WORD);
24008cee:	692b      	ldr	r3, [r5, #16]
24008cf0:	f423 7340 	bic.w	r3, r3, #768	@ 0x300
24008cf4:	f023 0303 	bic.w	r3, r3, #3
24008cf8:	f443 7300 	orr.w	r3, r3, #512	@ 0x200
24008cfc:	e7d1      	b.n	24008ca2 <HAL_QSPI_Transmit_DMA+0x6e>
          hqspi->ErrorCode |= HAL_QSPI_ERROR_DMA;
24008cfe:	6c63      	ldr	r3, [r4, #68]	@ 0x44
          status = HAL_ERROR;
24008d00:	4635      	mov	r5, r6
          hqspi->ErrorCode |= HAL_QSPI_ERROR_DMA;
24008d02:	f043 0304 	orr.w	r3, r3, #4
24008d06:	6463      	str	r3, [r4, #68]	@ 0x44
          status = HAL_ERROR;
24008d08:	e7d9      	b.n	24008cbe <HAL_QSPI_Transmit_DMA+0x8a>
          hqspi->ErrorCode |= HAL_QSPI_ERROR_DMA;
24008d0a:	6c63      	ldr	r3, [r4, #68]	@ 0x44
24008d0c:	f043 0304 	orr.w	r3, r3, #4
24008d10:	6463      	str	r3, [r4, #68]	@ 0x44
          __HAL_UNLOCK(hqspi);
24008d12:	2300      	movs	r3, #0
          hqspi->State = HAL_QSPI_STATE_READY;
24008d14:	f884 7041 	strb.w	r7, [r4, #65]	@ 0x41
          __HAL_UNLOCK(hqspi);
24008d18:	f884 3040 	strb.w	r3, [r4, #64]	@ 0x40
24008d1c:	e7e2      	b.n	24008ce4 <HAL_QSPI_Transmit_DMA+0xb0>
      hqspi->ErrorCode |= HAL_QSPI_ERROR_INVALID_PARAM;
24008d1e:	6c63      	ldr	r3, [r4, #68]	@ 0x44
24008d20:	f043 0308 	orr.w	r3, r3, #8
24008d24:	6463      	str	r3, [r4, #68]	@ 0x44
      __HAL_UNLOCK(hqspi);
24008d26:	f884 1040 	strb.w	r1, [r4, #64]	@ 0x40
24008d2a:	e7db      	b.n	24008ce4 <HAL_QSPI_Transmit_DMA+0xb0>
    __HAL_UNLOCK(hqspi);
24008d2c:	f884 3040 	strb.w	r3, [r4, #64]	@ 0x40
  __HAL_LOCK(hqspi);
24008d30:	2602      	movs	r6, #2
24008d32:	e7d7      	b.n	24008ce4 <HAL_QSPI_Transmit_DMA+0xb0>
24008d34:	2400863f 	.word	0x2400863f
24008d38:	24009331 	.word	0x24009331

24008d3c <HAL_QSPI_Receive_DMA>:
{
24008d3c:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
24008d40:	4604      	mov	r4, r0
  uint32_t addr_reg = READ_REG(hqspi->Instance->AR);
24008d42:	6806      	ldr	r6, [r0, #0]
{
24008d44:	460a      	mov	r2, r1
  uint32_t addr_reg = READ_REG(hqspi->Instance->AR);
24008d46:	69b1      	ldr	r1, [r6, #24]
  uint32_t data_size = (READ_REG(hqspi->Instance->DLR) + 1U);
24008d48:	6930      	ldr	r0, [r6, #16]
  __HAL_LOCK(hqspi);
24008d4a:	f894 3040 	ldrb.w	r3, [r4, #64]	@ 0x40
24008d4e:	2b01      	cmp	r3, #1
24008d50:	d07c      	beq.n	24008e4c <HAL_QSPI_Receive_DMA+0x110>
24008d52:	2301      	movs	r3, #1
24008d54:	f884 3040 	strb.w	r3, [r4, #64]	@ 0x40
  if(hqspi->State == HAL_QSPI_STATE_READY)
24008d58:	f894 3041 	ldrb.w	r3, [r4, #65]	@ 0x41
24008d5c:	2b01      	cmp	r3, #1
24008d5e:	b2df      	uxtb	r7, r3
24008d60:	f04f 0300 	mov.w	r3, #0
24008d64:	d170      	bne.n	24008e48 <HAL_QSPI_Receive_DMA+0x10c>
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
24008d66:	6463      	str	r3, [r4, #68]	@ 0x44
    if(pData != NULL )
24008d68:	2a00      	cmp	r2, #0
24008d6a:	d066      	beq.n	24008e3a <HAL_QSPI_Receive_DMA+0xfe>
  uint32_t data_size = (READ_REG(hqspi->Instance->DLR) + 1U);
24008d6c:	3001      	adds	r0, #1
        hqspi->hmdma->XferCpltCallback = QSPI_DMARxCplt;
24008d6e:	4d38      	ldr	r5, [pc, #224]	@ (24008e50 <HAL_QSPI_Receive_DMA+0x114>)
      hqspi->RxXferCount = data_size;
24008d70:	63a0      	str	r0, [r4, #56]	@ 0x38
        hqspi->State = HAL_QSPI_STATE_BUSY_INDIRECT_RX;
24008d72:	2022      	movs	r0, #34	@ 0x22
24008d74:	f884 0041 	strb.w	r0, [r4, #65]	@ 0x41
        __HAL_QSPI_CLEAR_FLAG(hqspi, (QSPI_FLAG_TE | QSPI_FLAG_TC));
24008d78:	2003      	movs	r0, #3
24008d7a:	60f0      	str	r0, [r6, #12]
        hqspi->RxXferSize = hqspi->RxXferCount;
24008d7c:	6ba0      	ldr	r0, [r4, #56]	@ 0x38
        hqspi->pRxBuffPtr = pData;
24008d7e:	6322      	str	r2, [r4, #48]	@ 0x30
        hqspi->RxXferSize = hqspi->RxXferCount;
24008d80:	6360      	str	r0, [r4, #52]	@ 0x34
        hqspi->hmdma->XferCpltCallback = QSPI_DMARxCplt;
24008d82:	6be0      	ldr	r0, [r4, #60]	@ 0x3c
24008d84:	6445      	str	r5, [r0, #68]	@ 0x44
        hqspi->hmdma->XferErrorCallback = QSPI_DMAError;
24008d86:	4d33      	ldr	r5, [pc, #204]	@ (24008e54 <HAL_QSPI_Receive_DMA+0x118>)
        hqspi->hmdma->XferAbortCallback = NULL;
24008d88:	e9c0 5315 	strd	r5, r3, [r0, #84]	@ 0x54
      MODIFY_REG(hqspi->hmdma->Instance->CTCR, (MDMA_CTCR_SINC | MDMA_CTCR_SINCOS) , MDMA_SRC_INC_DISABLE);
24008d8c:	6805      	ldr	r5, [r0, #0]
24008d8e:	692b      	ldr	r3, [r5, #16]
24008d90:	f423 7340 	bic.w	r3, r3, #768	@ 0x300
24008d94:	f023 0303 	bic.w	r3, r3, #3
24008d98:	612b      	str	r3, [r5, #16]
      if (hqspi->hmdma->Init.DestDataSize == MDMA_DEST_DATASIZE_BYTE)
24008d9a:	6a03      	ldr	r3, [r0, #32]
24008d9c:	b93b      	cbnz	r3, 24008dae <HAL_QSPI_Receive_DMA+0x72>
        MODIFY_REG(hqspi->hmdma->Instance->CTCR, (MDMA_CTCR_DINC | MDMA_CTCR_DINCOS) , MDMA_DEST_INC_BYTE);
24008d9e:	692b      	ldr	r3, [r5, #16]
24008da0:	f423 6340 	bic.w	r3, r3, #3072	@ 0xc00
24008da4:	f023 030c 	bic.w	r3, r3, #12
        MODIFY_REG(hqspi->hmdma->Instance->CTCR, (MDMA_CTCR_DINC | MDMA_CTCR_DINCOS) , MDMA_DEST_INC_WORD);
24008da8:	f043 0308 	orr.w	r3, r3, #8
24008dac:	e008      	b.n	24008dc0 <HAL_QSPI_Receive_DMA+0x84>
      else if (hqspi->hmdma->Init.DestDataSize == MDMA_DEST_DATASIZE_HALFWORD)
24008dae:	2b40      	cmp	r3, #64	@ 0x40
24008db0:	d129      	bne.n	24008e06 <HAL_QSPI_Receive_DMA+0xca>
        MODIFY_REG(hqspi->hmdma->Instance->CTCR, (MDMA_CTCR_DINC | MDMA_CTCR_DINCOS) , MDMA_DEST_INC_HALFWORD);
24008db2:	692b      	ldr	r3, [r5, #16]
24008db4:	f423 6340 	bic.w	r3, r3, #3072	@ 0xc00
24008db8:	f023 030c 	bic.w	r3, r3, #12
24008dbc:	f443 6381 	orr.w	r3, r3, #1032	@ 0x408
24008dc0:	612b      	str	r3, [r5, #16]
  HAL_StatusTypeDef status = HAL_OK;
24008dc2:	2500      	movs	r5, #0
          MODIFY_REG(hqspi->Instance->CCR, QUADSPI_CCR_FMODE, QSPI_FUNCTIONAL_MODE_INDIRECT_READ);
24008dc4:	6973      	ldr	r3, [r6, #20]
        if (HAL_MDMA_Start_IT(hqspi->hmdma, (uint32_t)&hqspi->Instance->DR, (uint32_t)pData, hqspi->RxXferSize, 1) == HAL_OK)
24008dc6:	f04f 0801 	mov.w	r8, #1
          MODIFY_REG(hqspi->Instance->CCR, QUADSPI_CCR_FMODE, QSPI_FUNCTIONAL_MODE_INDIRECT_READ);
24008dca:	f023 6340 	bic.w	r3, r3, #201326592	@ 0xc000000
24008dce:	f043 6380 	orr.w	r3, r3, #67108864	@ 0x4000000
24008dd2:	6173      	str	r3, [r6, #20]
          WRITE_REG(hqspi->Instance->AR, addr_reg);
24008dd4:	61b1      	str	r1, [r6, #24]
        if (HAL_MDMA_Start_IT(hqspi->hmdma, (uint32_t)&hqspi->Instance->DR, (uint32_t)pData, hqspi->RxXferSize, 1) == HAL_OK)
24008dd6:	f106 0120 	add.w	r1, r6, #32
24008dda:	6b63      	ldr	r3, [r4, #52]	@ 0x34
24008ddc:	f8cd 8000 	str.w	r8, [sp]
24008de0:	f7fe fe7e 	bl	24007ae0 <HAL_MDMA_Start_IT>
24008de4:	b9f8      	cbnz	r0, 24008e26 <HAL_QSPI_Receive_DMA+0xea>
          __HAL_QSPI_ENABLE_IT(hqspi, QSPI_IT_TE);
24008de6:	6823      	ldr	r3, [r4, #0]
24008de8:	462f      	mov	r7, r5
          __HAL_UNLOCK(hqspi);
24008dea:	f884 0040 	strb.w	r0, [r4, #64]	@ 0x40
          __HAL_QSPI_ENABLE_IT(hqspi, QSPI_IT_TE);
24008dee:	681a      	ldr	r2, [r3, #0]
24008df0:	f442 3280 	orr.w	r2, r2, #65536	@ 0x10000
24008df4:	601a      	str	r2, [r3, #0]
          SET_BIT(hqspi->Instance->CR, QUADSPI_CR_DMAEN);
24008df6:	681a      	ldr	r2, [r3, #0]
24008df8:	f042 0204 	orr.w	r2, r2, #4
24008dfc:	601a      	str	r2, [r3, #0]
}
24008dfe:	4638      	mov	r0, r7
24008e00:	b002      	add	sp, #8
24008e02:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      else if (hqspi->hmdma->Init.DestDataSize == MDMA_DEST_DATASIZE_WORD)
24008e06:	2b80      	cmp	r3, #128	@ 0x80
24008e08:	d107      	bne.n	24008e1a <HAL_QSPI_Receive_DMA+0xde>
        MODIFY_REG(hqspi->hmdma->Instance->CTCR, (MDMA_CTCR_DINC | MDMA_CTCR_DINCOS) , MDMA_DEST_INC_WORD);
24008e0a:	692b      	ldr	r3, [r5, #16]
24008e0c:	f423 6340 	bic.w	r3, r3, #3072	@ 0xc00
24008e10:	f023 030c 	bic.w	r3, r3, #12
24008e14:	f443 6300 	orr.w	r3, r3, #2048	@ 0x800
24008e18:	e7c6      	b.n	24008da8 <HAL_QSPI_Receive_DMA+0x6c>
        hqspi->ErrorCode |= HAL_QSPI_ERROR_DMA;
24008e1a:	6c63      	ldr	r3, [r4, #68]	@ 0x44
        status = HAL_ERROR;
24008e1c:	463d      	mov	r5, r7
        hqspi->ErrorCode |= HAL_QSPI_ERROR_DMA;
24008e1e:	f043 0304 	orr.w	r3, r3, #4
24008e22:	6463      	str	r3, [r4, #68]	@ 0x44
        status = HAL_ERROR;
24008e24:	e7ce      	b.n	24008dc4 <HAL_QSPI_Receive_DMA+0x88>
          hqspi->ErrorCode |= HAL_QSPI_ERROR_DMA;
24008e26:	6c63      	ldr	r3, [r4, #68]	@ 0x44
24008e28:	f043 0304 	orr.w	r3, r3, #4
24008e2c:	6463      	str	r3, [r4, #68]	@ 0x44
          __HAL_UNLOCK(hqspi);
24008e2e:	2300      	movs	r3, #0
          hqspi->State = HAL_QSPI_STATE_READY;
24008e30:	f884 8041 	strb.w	r8, [r4, #65]	@ 0x41
          __HAL_UNLOCK(hqspi);
24008e34:	f884 3040 	strb.w	r3, [r4, #64]	@ 0x40
24008e38:	e7e1      	b.n	24008dfe <HAL_QSPI_Receive_DMA+0xc2>
      hqspi->ErrorCode |= HAL_QSPI_ERROR_INVALID_PARAM;
24008e3a:	6c63      	ldr	r3, [r4, #68]	@ 0x44
24008e3c:	f043 0308 	orr.w	r3, r3, #8
24008e40:	6463      	str	r3, [r4, #68]	@ 0x44
      __HAL_UNLOCK(hqspi);
24008e42:	f884 2040 	strb.w	r2, [r4, #64]	@ 0x40
24008e46:	e7da      	b.n	24008dfe <HAL_QSPI_Receive_DMA+0xc2>
    __HAL_UNLOCK(hqspi);
24008e48:	f884 3040 	strb.w	r3, [r4, #64]	@ 0x40
  __HAL_LOCK(hqspi);
24008e4c:	2702      	movs	r7, #2
24008e4e:	e7d6      	b.n	24008dfe <HAL_QSPI_Receive_DMA+0xc2>
24008e50:	2400862d 	.word	0x2400862d
24008e54:	24009331 	.word	0x24009331

24008e58 <HAL_QSPI_AutoPolling>:
{
24008e58:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
24008e5c:	4604      	mov	r4, r0
24008e5e:	461f      	mov	r7, r3
24008e60:	4689      	mov	r9, r1
24008e62:	4615      	mov	r5, r2
  uint32_t tickstart = HAL_GetTick();
24008e64:	f008 ffd0 	bl	24011e08 <HAL_GetTick>
  __HAL_LOCK(hqspi);
24008e68:	f894 3040 	ldrb.w	r3, [r4, #64]	@ 0x40
  uint32_t tickstart = HAL_GetTick();
24008e6c:	4606      	mov	r6, r0
  __HAL_LOCK(hqspi);
24008e6e:	2b01      	cmp	r3, #1
24008e70:	d041      	beq.n	24008ef6 <HAL_QSPI_AutoPolling+0x9e>
24008e72:	2301      	movs	r3, #1
24008e74:	f884 3040 	strb.w	r3, [r4, #64]	@ 0x40
  if(hqspi->State == HAL_QSPI_STATE_READY)
24008e78:	f894 3041 	ldrb.w	r3, [r4, #65]	@ 0x41
24008e7c:	2b01      	cmp	r3, #1
24008e7e:	fa5f f883 	uxtb.w	r8, r3
24008e82:	d136      	bne.n	24008ef2 <HAL_QSPI_AutoPolling+0x9a>
    hqspi->State = HAL_QSPI_STATE_BUSY_AUTO_POLLING;
24008e84:	2342      	movs	r3, #66	@ 0x42
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
24008e86:	2200      	movs	r2, #0
    status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, Timeout);
24008e88:	2120      	movs	r1, #32
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
24008e8a:	6462      	str	r2, [r4, #68]	@ 0x44
    hqspi->State = HAL_QSPI_STATE_BUSY_AUTO_POLLING;
24008e8c:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
    status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, Timeout);
24008e90:	4603      	mov	r3, r0
24008e92:	9700      	str	r7, [sp, #0]
24008e94:	4620      	mov	r0, r4
24008e96:	f7ff fc95 	bl	240087c4 <QSPI_WaitFlagStateUntilTimeout>
    if (status == HAL_OK)
24008e9a:	bb20      	cbnz	r0, 24008ee6 <HAL_QSPI_AutoPolling+0x8e>
      WRITE_REG(hqspi->Instance->PSMAR, cfg->Match);
24008e9c:	6822      	ldr	r2, [r4, #0]
      QSPI_Config(hqspi, cmd, QSPI_FUNCTIONAL_MODE_AUTO_POLLING);
24008e9e:	4620      	mov	r0, r4
      WRITE_REG(hqspi->Instance->PSMAR, cfg->Match);
24008ea0:	682b      	ldr	r3, [r5, #0]
      MODIFY_REG(hqspi->Instance->CR, (QUADSPI_CR_PMM | QUADSPI_CR_APMS),
24008ea2:	6929      	ldr	r1, [r5, #16]
      WRITE_REG(hqspi->Instance->PSMAR, cfg->Match);
24008ea4:	6293      	str	r3, [r2, #40]	@ 0x28
      WRITE_REG(hqspi->Instance->PSMKR, cfg->Mask);
24008ea6:	686b      	ldr	r3, [r5, #4]
24008ea8:	6253      	str	r3, [r2, #36]	@ 0x24
      WRITE_REG(hqspi->Instance->PIR, cfg->Interval);
24008eaa:	68ab      	ldr	r3, [r5, #8]
24008eac:	62d3      	str	r3, [r2, #44]	@ 0x2c
      MODIFY_REG(hqspi->Instance->CR, (QUADSPI_CR_PMM | QUADSPI_CR_APMS),
24008eae:	6813      	ldr	r3, [r2, #0]
24008eb0:	f423 0340 	bic.w	r3, r3, #12582912	@ 0xc00000
24008eb4:	430b      	orrs	r3, r1
      QSPI_Config(hqspi, cmd, QSPI_FUNCTIONAL_MODE_AUTO_POLLING);
24008eb6:	4649      	mov	r1, r9
      MODIFY_REG(hqspi->Instance->CR, (QUADSPI_CR_PMM | QUADSPI_CR_APMS),
24008eb8:	f443 0380 	orr.w	r3, r3, #4194304	@ 0x400000
24008ebc:	6013      	str	r3, [r2, #0]
      QSPI_Config(hqspi, cmd, QSPI_FUNCTIONAL_MODE_AUTO_POLLING);
24008ebe:	f04f 6200 	mov.w	r2, #134217728	@ 0x8000000
      cmd->NbData = cfg->StatusBytesSize;
24008ec2:	68eb      	ldr	r3, [r5, #12]
24008ec4:	f8c9 3028 	str.w	r3, [r9, #40]	@ 0x28
      QSPI_Config(hqspi, cmd, QSPI_FUNCTIONAL_MODE_AUTO_POLLING);
24008ec8:	f7ff fbc2 	bl	24008650 <QSPI_Config>
      status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_SM, SET, tickstart, Timeout);
24008ecc:	4633      	mov	r3, r6
24008ece:	4642      	mov	r2, r8
24008ed0:	2108      	movs	r1, #8
24008ed2:	4620      	mov	r0, r4
24008ed4:	9700      	str	r7, [sp, #0]
24008ed6:	f7ff fc75 	bl	240087c4 <QSPI_WaitFlagStateUntilTimeout>
      if (status == HAL_OK)
24008eda:	b920      	cbnz	r0, 24008ee6 <HAL_QSPI_AutoPolling+0x8e>
        __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_SM);
24008edc:	6823      	ldr	r3, [r4, #0]
24008ede:	2208      	movs	r2, #8
24008ee0:	60da      	str	r2, [r3, #12]
        hqspi->State = HAL_QSPI_STATE_READY;
24008ee2:	f884 8041 	strb.w	r8, [r4, #65]	@ 0x41
  __HAL_UNLOCK(hqspi);
24008ee6:	2300      	movs	r3, #0
24008ee8:	f884 3040 	strb.w	r3, [r4, #64]	@ 0x40
}
24008eec:	b003      	add	sp, #12
24008eee:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    status = HAL_BUSY;
24008ef2:	2002      	movs	r0, #2
24008ef4:	e7f7      	b.n	24008ee6 <HAL_QSPI_AutoPolling+0x8e>
  __HAL_LOCK(hqspi);
24008ef6:	2002      	movs	r0, #2
24008ef8:	e7f8      	b.n	24008eec <HAL_QSPI_AutoPolling+0x94>

24008efa <HAL_QSPI_AutoPolling_IT>:
{
24008efa:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
24008efe:	4604      	mov	r4, r0
24008f00:	4616      	mov	r6, r2
24008f02:	4688      	mov	r8, r1
  uint32_t tickstart = HAL_GetTick();
24008f04:	f008 ff80 	bl	24011e08 <HAL_GetTick>
  __HAL_LOCK(hqspi);
24008f08:	f894 2040 	ldrb.w	r2, [r4, #64]	@ 0x40
  uint32_t tickstart = HAL_GetTick();
24008f0c:	4603      	mov	r3, r0
  __HAL_LOCK(hqspi);
24008f0e:	2a01      	cmp	r2, #1
24008f10:	d03d      	beq.n	24008f8e <HAL_QSPI_AutoPolling_IT+0x94>
24008f12:	2201      	movs	r2, #1
24008f14:	2500      	movs	r5, #0
24008f16:	f884 2040 	strb.w	r2, [r4, #64]	@ 0x40
  if(hqspi->State == HAL_QSPI_STATE_READY)
24008f1a:	f894 2041 	ldrb.w	r2, [r4, #65]	@ 0x41
24008f1e:	2a01      	cmp	r2, #1
24008f20:	d133      	bne.n	24008f8a <HAL_QSPI_AutoPolling_IT+0x90>
    hqspi->State = HAL_QSPI_STATE_BUSY_AUTO_POLLING;
24008f22:	2242      	movs	r2, #66	@ 0x42
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
24008f24:	6465      	str	r5, [r4, #68]	@ 0x44
    status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, hqspi->Timeout);
24008f26:	2120      	movs	r1, #32
24008f28:	4620      	mov	r0, r4
    hqspi->State = HAL_QSPI_STATE_BUSY_AUTO_POLLING;
24008f2a:	f884 2041 	strb.w	r2, [r4, #65]	@ 0x41
    status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, hqspi->Timeout);
24008f2e:	6ca2      	ldr	r2, [r4, #72]	@ 0x48
24008f30:	9200      	str	r2, [sp, #0]
24008f32:	462a      	mov	r2, r5
24008f34:	f7ff fc46 	bl	240087c4 <QSPI_WaitFlagStateUntilTimeout>
    if (status == HAL_OK)
24008f38:	4607      	mov	r7, r0
24008f3a:	bb18      	cbnz	r0, 24008f84 <HAL_QSPI_AutoPolling_IT+0x8a>
      WRITE_REG(hqspi->Instance->PSMAR, cfg->Match);
24008f3c:	6825      	ldr	r5, [r4, #0]
      QSPI_Config(hqspi, cmd, QSPI_FUNCTIONAL_MODE_AUTO_POLLING);
24008f3e:	4620      	mov	r0, r4
      WRITE_REG(hqspi->Instance->PSMAR, cfg->Match);
24008f40:	6833      	ldr	r3, [r6, #0]
24008f42:	62ab      	str	r3, [r5, #40]	@ 0x28
      WRITE_REG(hqspi->Instance->PSMKR, cfg->Mask);
24008f44:	6873      	ldr	r3, [r6, #4]
24008f46:	626b      	str	r3, [r5, #36]	@ 0x24
      WRITE_REG(hqspi->Instance->PIR, cfg->Interval);
24008f48:	68b3      	ldr	r3, [r6, #8]
24008f4a:	62eb      	str	r3, [r5, #44]	@ 0x2c
      MODIFY_REG(hqspi->Instance->CR, (QUADSPI_CR_PMM | QUADSPI_CR_APMS),
24008f4c:	682a      	ldr	r2, [r5, #0]
24008f4e:	e9d6 3104 	ldrd	r3, r1, [r6, #16]
24008f52:	f422 0240 	bic.w	r2, r2, #12582912	@ 0xc00000
24008f56:	430b      	orrs	r3, r1
      QSPI_Config(hqspi, cmd, QSPI_FUNCTIONAL_MODE_AUTO_POLLING);
24008f58:	4641      	mov	r1, r8
      MODIFY_REG(hqspi->Instance->CR, (QUADSPI_CR_PMM | QUADSPI_CR_APMS),
24008f5a:	4313      	orrs	r3, r2
      QSPI_Config(hqspi, cmd, QSPI_FUNCTIONAL_MODE_AUTO_POLLING);
24008f5c:	f04f 6200 	mov.w	r2, #134217728	@ 0x8000000
      MODIFY_REG(hqspi->Instance->CR, (QUADSPI_CR_PMM | QUADSPI_CR_APMS),
24008f60:	602b      	str	r3, [r5, #0]
      __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TE | QSPI_FLAG_SM);
24008f62:	2309      	movs	r3, #9
24008f64:	60eb      	str	r3, [r5, #12]
      cmd->NbData = cfg->StatusBytesSize;
24008f66:	68f3      	ldr	r3, [r6, #12]
24008f68:	f8c8 3028 	str.w	r3, [r8, #40]	@ 0x28
      QSPI_Config(hqspi, cmd, QSPI_FUNCTIONAL_MODE_AUTO_POLLING);
24008f6c:	f7ff fb70 	bl	24008650 <QSPI_Config>
      __HAL_UNLOCK(hqspi);
24008f70:	f884 7040 	strb.w	r7, [r4, #64]	@ 0x40
      __HAL_QSPI_ENABLE_IT(hqspi, (QSPI_IT_SM | QSPI_IT_TE));
24008f74:	682b      	ldr	r3, [r5, #0]
24008f76:	f443 2310 	orr.w	r3, r3, #589824	@ 0x90000
24008f7a:	602b      	str	r3, [r5, #0]
}
24008f7c:	4638      	mov	r0, r7
24008f7e:	b002      	add	sp, #8
24008f80:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      __HAL_UNLOCK(hqspi);
24008f84:	f884 5040 	strb.w	r5, [r4, #64]	@ 0x40
24008f88:	e7f8      	b.n	24008f7c <HAL_QSPI_AutoPolling_IT+0x82>
    __HAL_UNLOCK(hqspi);
24008f8a:	f884 5040 	strb.w	r5, [r4, #64]	@ 0x40
  __HAL_LOCK(hqspi);
24008f8e:	2702      	movs	r7, #2
24008f90:	e7f4      	b.n	24008f7c <HAL_QSPI_AutoPolling_IT+0x82>

24008f92 <HAL_QSPI_MemoryMapped>:
{
24008f92:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
24008f94:	4604      	mov	r4, r0
24008f96:	4616      	mov	r6, r2
24008f98:	460f      	mov	r7, r1
  uint32_t tickstart = HAL_GetTick();
24008f9a:	f008 ff35 	bl	24011e08 <HAL_GetTick>
  __HAL_LOCK(hqspi);
24008f9e:	f894 2040 	ldrb.w	r2, [r4, #64]	@ 0x40
  uint32_t tickstart = HAL_GetTick();
24008fa2:	4603      	mov	r3, r0
  __HAL_LOCK(hqspi);
24008fa4:	2a01      	cmp	r2, #1
24008fa6:	d033      	beq.n	24009010 <HAL_QSPI_MemoryMapped+0x7e>
24008fa8:	2201      	movs	r2, #1
24008faa:	f884 2040 	strb.w	r2, [r4, #64]	@ 0x40
  if(hqspi->State == HAL_QSPI_STATE_READY)
24008fae:	f894 2041 	ldrb.w	r2, [r4, #65]	@ 0x41
24008fb2:	2a01      	cmp	r2, #1
24008fb4:	d12a      	bne.n	2400900c <HAL_QSPI_MemoryMapped+0x7a>
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
24008fb6:	2200      	movs	r2, #0
    hqspi->State = HAL_QSPI_STATE_BUSY_MEM_MAPPED;
24008fb8:	2182      	movs	r1, #130	@ 0x82
    status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, hqspi->Timeout);
24008fba:	4620      	mov	r0, r4
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
24008fbc:	6462      	str	r2, [r4, #68]	@ 0x44
    hqspi->State = HAL_QSPI_STATE_BUSY_MEM_MAPPED;
24008fbe:	f884 1041 	strb.w	r1, [r4, #65]	@ 0x41
    status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, hqspi->Timeout);
24008fc2:	6ca1      	ldr	r1, [r4, #72]	@ 0x48
24008fc4:	9100      	str	r1, [sp, #0]
24008fc6:	2120      	movs	r1, #32
24008fc8:	f7ff fbfc 	bl	240087c4 <QSPI_WaitFlagStateUntilTimeout>
    if (status == HAL_OK)
24008fcc:	4605      	mov	r5, r0
24008fce:	b9b8      	cbnz	r0, 24009000 <HAL_QSPI_MemoryMapped+0x6e>
    MODIFY_REG(hqspi->Instance->CR, QUADSPI_CR_TCEN, cfg->TimeOutActivation);
24008fd0:	6823      	ldr	r3, [r4, #0]
24008fd2:	6872      	ldr	r2, [r6, #4]
24008fd4:	6818      	ldr	r0, [r3, #0]
    if (cfg->TimeOutActivation == QSPI_TIMEOUT_COUNTER_ENABLE)
24008fd6:	2a08      	cmp	r2, #8
    MODIFY_REG(hqspi->Instance->CR, QUADSPI_CR_TCEN, cfg->TimeOutActivation);
24008fd8:	f020 0008 	bic.w	r0, r0, #8
24008fdc:	ea40 0002 	orr.w	r0, r0, r2
24008fe0:	6018      	str	r0, [r3, #0]
    if (cfg->TimeOutActivation == QSPI_TIMEOUT_COUNTER_ENABLE)
24008fe2:	d107      	bne.n	24008ff4 <HAL_QSPI_MemoryMapped+0x62>
        WRITE_REG(hqspi->Instance->LPTR, cfg->TimeOutPeriod);
24008fe4:	6832      	ldr	r2, [r6, #0]
24008fe6:	631a      	str	r2, [r3, #48]	@ 0x30
        __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TO);
24008fe8:	2210      	movs	r2, #16
24008fea:	60da      	str	r2, [r3, #12]
        __HAL_QSPI_ENABLE_IT(hqspi, QSPI_IT_TO);
24008fec:	681a      	ldr	r2, [r3, #0]
24008fee:	f442 1280 	orr.w	r2, r2, #1048576	@ 0x100000
24008ff2:	601a      	str	r2, [r3, #0]
      QSPI_Config(hqspi, cmd, QSPI_FUNCTIONAL_MODE_MEMORY_MAPPED);
24008ff4:	f04f 6240 	mov.w	r2, #201326592	@ 0xc000000
24008ff8:	4639      	mov	r1, r7
24008ffa:	4620      	mov	r0, r4
24008ffc:	f7ff fb28 	bl	24008650 <QSPI_Config>
  __HAL_UNLOCK(hqspi);
24009000:	2300      	movs	r3, #0
24009002:	f884 3040 	strb.w	r3, [r4, #64]	@ 0x40
}
24009006:	4628      	mov	r0, r5
24009008:	b003      	add	sp, #12
2400900a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    status = HAL_BUSY;
2400900c:	2502      	movs	r5, #2
2400900e:	e7f7      	b.n	24009000 <HAL_QSPI_MemoryMapped+0x6e>
  __HAL_LOCK(hqspi);
24009010:	2502      	movs	r5, #2
24009012:	e7f8      	b.n	24009006 <HAL_QSPI_MemoryMapped+0x74>

24009014 <HAL_QSPI_ErrorCallback>:
__weak void HAL_QSPI_ErrorCallback(QSPI_HandleTypeDef *hqspi)
24009014:	4770      	bx	lr

24009016 <QSPI_DMAAbortCplt>:
{
24009016:	b508      	push	{r3, lr}
  QSPI_HandleTypeDef* hqspi = ( QSPI_HandleTypeDef* )(hmdma->Parent);
24009018:	6c00      	ldr	r0, [r0, #64]	@ 0x40
  hqspi->RxXferCount = 0U;
2400901a:	2300      	movs	r3, #0
2400901c:	6383      	str	r3, [r0, #56]	@ 0x38
  hqspi->TxXferCount = 0U;
2400901e:	62c3      	str	r3, [r0, #44]	@ 0x2c
  if(hqspi->State == HAL_QSPI_STATE_ABORT)
24009020:	f890 3041 	ldrb.w	r3, [r0, #65]	@ 0x41
24009024:	2b08      	cmp	r3, #8
24009026:	d10b      	bne.n	24009040 <QSPI_DMAAbortCplt+0x2a>
    __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TC);
24009028:	6803      	ldr	r3, [r0, #0]
2400902a:	2202      	movs	r2, #2
2400902c:	60da      	str	r2, [r3, #12]
    __HAL_QSPI_ENABLE_IT(hqspi, QSPI_IT_TC);
2400902e:	681a      	ldr	r2, [r3, #0]
24009030:	f442 3200 	orr.w	r2, r2, #131072	@ 0x20000
24009034:	601a      	str	r2, [r3, #0]
    SET_BIT(hqspi->Instance->CR, QUADSPI_CR_ABORT);
24009036:	681a      	ldr	r2, [r3, #0]
24009038:	f042 0202 	orr.w	r2, r2, #2
2400903c:	601a      	str	r2, [r3, #0]
}
2400903e:	bd08      	pop	{r3, pc}
    hqspi->State = HAL_QSPI_STATE_READY;
24009040:	2301      	movs	r3, #1
24009042:	f880 3041 	strb.w	r3, [r0, #65]	@ 0x41
    HAL_QSPI_ErrorCallback(hqspi);
24009046:	f7ff ffe5 	bl	24009014 <HAL_QSPI_ErrorCallback>
}
2400904a:	e7f8      	b.n	2400903e <QSPI_DMAAbortCplt+0x28>

2400904c <HAL_QSPI_AbortCpltCallback>:
__weak void HAL_QSPI_AbortCpltCallback(QSPI_HandleTypeDef *hqspi)
2400904c:	4770      	bx	lr

2400904e <HAL_QSPI_CmdCpltCallback>:
__weak void HAL_QSPI_CmdCpltCallback(QSPI_HandleTypeDef *hqspi)
2400904e:	4770      	bx	lr

24009050 <HAL_QSPI_RxCpltCallback>:
__weak void HAL_QSPI_RxCpltCallback(QSPI_HandleTypeDef *hqspi)
24009050:	4770      	bx	lr

24009052 <HAL_QSPI_TxCpltCallback>:
__weak void HAL_QSPI_TxCpltCallback(QSPI_HandleTypeDef *hqspi)
24009052:	4770      	bx	lr

24009054 <HAL_QSPI_FifoThresholdCallback>:
__weak void HAL_QSPI_FifoThresholdCallback(QSPI_HandleTypeDef *hqspi)
24009054:	4770      	bx	lr

24009056 <HAL_QSPI_StatusMatchCallback>:
__weak void HAL_QSPI_StatusMatchCallback(QSPI_HandleTypeDef *hqspi)
24009056:	4770      	bx	lr

24009058 <HAL_QSPI_TimeOutCallback>:
__weak void HAL_QSPI_TimeOutCallback(QSPI_HandleTypeDef *hqspi)
24009058:	4770      	bx	lr

2400905a <HAL_QSPI_IRQHandler>:
{
2400905a:	b538      	push	{r3, r4, r5, lr}
  uint32_t flag = READ_REG(hqspi->Instance->SR);
2400905c:	6803      	ldr	r3, [r0, #0]
{
2400905e:	4604      	mov	r4, r0
  uint32_t flag = READ_REG(hqspi->Instance->SR);
24009060:	6899      	ldr	r1, [r3, #8]
  uint32_t itsource = READ_REG(hqspi->Instance->CR);
24009062:	681a      	ldr	r2, [r3, #0]
  if(((flag & QSPI_FLAG_FT) != 0U) && ((itsource & QSPI_IT_FT) != 0U))
24009064:	0748      	lsls	r0, r1, #29
24009066:	d534      	bpl.n	240090d2 <HAL_QSPI_IRQHandler+0x78>
24009068:	0355      	lsls	r5, r2, #13
2400906a:	d532      	bpl.n	240090d2 <HAL_QSPI_IRQHandler+0x78>
    if(hqspi->State == HAL_QSPI_STATE_BUSY_INDIRECT_TX)
2400906c:	f894 2041 	ldrb.w	r2, [r4, #65]	@ 0x41
24009070:	2a12      	cmp	r2, #18
24009072:	d114      	bne.n	2400909e <HAL_QSPI_IRQHandler+0x44>
      while(__HAL_QSPI_GET_FLAG(hqspi, QSPI_FLAG_FT) != RESET)
24009074:	6822      	ldr	r2, [r4, #0]
24009076:	6891      	ldr	r1, [r2, #8]
24009078:	0748      	lsls	r0, r1, #29
2400907a:	d403      	bmi.n	24009084 <HAL_QSPI_IRQHandler+0x2a>
    HAL_QSPI_FifoThresholdCallback(hqspi);
2400907c:	4620      	mov	r0, r4
2400907e:	f7ff ffe9 	bl	24009054 <HAL_QSPI_FifoThresholdCallback>
}
24009082:	bd38      	pop	{r3, r4, r5, pc}
        if (hqspi->TxXferCount > 0U)
24009084:	6ae1      	ldr	r1, [r4, #44]	@ 0x2c
24009086:	b1f9      	cbz	r1, 240090c8 <HAL_QSPI_IRQHandler+0x6e>
          *((__IO uint8_t *)data_reg) = *hqspi->pTxBuffPtr;
24009088:	6a62      	ldr	r2, [r4, #36]	@ 0x24
2400908a:	7812      	ldrb	r2, [r2, #0]
2400908c:	f883 2020 	strb.w	r2, [r3, #32]
          hqspi->pTxBuffPtr++;
24009090:	6a62      	ldr	r2, [r4, #36]	@ 0x24
24009092:	3201      	adds	r2, #1
24009094:	6262      	str	r2, [r4, #36]	@ 0x24
          hqspi->TxXferCount--;
24009096:	6ae2      	ldr	r2, [r4, #44]	@ 0x2c
24009098:	3a01      	subs	r2, #1
2400909a:	62e2      	str	r2, [r4, #44]	@ 0x2c
2400909c:	e7ea      	b.n	24009074 <HAL_QSPI_IRQHandler+0x1a>
    else if(hqspi->State == HAL_QSPI_STATE_BUSY_INDIRECT_RX)
2400909e:	f894 2041 	ldrb.w	r2, [r4, #65]	@ 0x41
240090a2:	2a22      	cmp	r2, #34	@ 0x22
240090a4:	d1ea      	bne.n	2400907c <HAL_QSPI_IRQHandler+0x22>
      while(__HAL_QSPI_GET_FLAG(hqspi, QSPI_FLAG_FT) != RESET)
240090a6:	6822      	ldr	r2, [r4, #0]
240090a8:	6891      	ldr	r1, [r2, #8]
240090aa:	0749      	lsls	r1, r1, #29
240090ac:	d5e6      	bpl.n	2400907c <HAL_QSPI_IRQHandler+0x22>
        if (hqspi->RxXferCount > 0U)
240090ae:	6ba1      	ldr	r1, [r4, #56]	@ 0x38
240090b0:	b151      	cbz	r1, 240090c8 <HAL_QSPI_IRQHandler+0x6e>
          *hqspi->pRxBuffPtr = *((__IO uint8_t *)data_reg);
240090b2:	f893 1020 	ldrb.w	r1, [r3, #32]
240090b6:	6b22      	ldr	r2, [r4, #48]	@ 0x30
240090b8:	7011      	strb	r1, [r2, #0]
          hqspi->pRxBuffPtr++;
240090ba:	6b22      	ldr	r2, [r4, #48]	@ 0x30
240090bc:	3201      	adds	r2, #1
240090be:	6322      	str	r2, [r4, #48]	@ 0x30
          hqspi->RxXferCount--;
240090c0:	6ba2      	ldr	r2, [r4, #56]	@ 0x38
240090c2:	3a01      	subs	r2, #1
240090c4:	63a2      	str	r2, [r4, #56]	@ 0x38
240090c6:	e7ee      	b.n	240090a6 <HAL_QSPI_IRQHandler+0x4c>
          __HAL_QSPI_DISABLE_IT(hqspi, QSPI_IT_FT);
240090c8:	6813      	ldr	r3, [r2, #0]
240090ca:	f423 2380 	bic.w	r3, r3, #262144	@ 0x40000
240090ce:	6013      	str	r3, [r2, #0]
          break;
240090d0:	e7d4      	b.n	2400907c <HAL_QSPI_IRQHandler+0x22>
  else if(((flag & QSPI_FLAG_TC) != 0U) && ((itsource & QSPI_IT_TC) != 0U))
240090d2:	078d      	lsls	r5, r1, #30
240090d4:	d568      	bpl.n	240091a8 <HAL_QSPI_IRQHandler+0x14e>
240090d6:	0390      	lsls	r0, r2, #14
240090d8:	d566      	bpl.n	240091a8 <HAL_QSPI_IRQHandler+0x14e>
    WRITE_REG(hqspi->Instance->FCR, QSPI_FLAG_TC);
240090da:	2202      	movs	r2, #2
240090dc:	60da      	str	r2, [r3, #12]
    __HAL_QSPI_DISABLE_IT(hqspi, QSPI_IT_TC | QSPI_IT_TE | QSPI_IT_FT);
240090de:	681a      	ldr	r2, [r3, #0]
240090e0:	f422 22e0 	bic.w	r2, r2, #458752	@ 0x70000
240090e4:	601a      	str	r2, [r3, #0]
    if(hqspi->State == HAL_QSPI_STATE_BUSY_INDIRECT_TX)
240090e6:	f894 2041 	ldrb.w	r2, [r4, #65]	@ 0x41
240090ea:	2a12      	cmp	r2, #18
240090ec:	d113      	bne.n	24009116 <HAL_QSPI_IRQHandler+0xbc>
      if ((hqspi->Instance->CR & QUADSPI_CR_DMAEN) != 0U)
240090ee:	681a      	ldr	r2, [r3, #0]
240090f0:	0751      	lsls	r1, r2, #29
240090f2:	d509      	bpl.n	24009108 <HAL_QSPI_IRQHandler+0xae>
        CLEAR_BIT(hqspi->Instance->CR, QUADSPI_CR_DMAEN);
240090f4:	681a      	ldr	r2, [r3, #0]
240090f6:	f022 0204 	bic.w	r2, r2, #4
240090fa:	601a      	str	r2, [r3, #0]
        __HAL_MDMA_DISABLE(hqspi->hmdma);
240090fc:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
240090fe:	681a      	ldr	r2, [r3, #0]
24009100:	68d3      	ldr	r3, [r2, #12]
24009102:	f023 0301 	bic.w	r3, r3, #1
24009106:	60d3      	str	r3, [r2, #12]
      hqspi->State = HAL_QSPI_STATE_READY;
24009108:	2301      	movs	r3, #1
      HAL_QSPI_TxCpltCallback(hqspi);
2400910a:	4620      	mov	r0, r4
      hqspi->State = HAL_QSPI_STATE_READY;
2400910c:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
      HAL_QSPI_TxCpltCallback(hqspi);
24009110:	f7ff ff9f 	bl	24009052 <HAL_QSPI_TxCpltCallback>
24009114:	e7b5      	b.n	24009082 <HAL_QSPI_IRQHandler+0x28>
    else if(hqspi->State == HAL_QSPI_STATE_BUSY_INDIRECT_RX)
24009116:	f894 2041 	ldrb.w	r2, [r4, #65]	@ 0x41
2400911a:	2a22      	cmp	r2, #34	@ 0x22
2400911c:	d126      	bne.n	2400916c <HAL_QSPI_IRQHandler+0x112>
      if ((hqspi->Instance->CR & QUADSPI_CR_DMAEN) != 0U)
2400911e:	681a      	ldr	r2, [r3, #0]
24009120:	0752      	lsls	r2, r2, #29
24009122:	d51d      	bpl.n	24009160 <HAL_QSPI_IRQHandler+0x106>
        CLEAR_BIT(hqspi->Instance->CR, QUADSPI_CR_DMAEN);
24009124:	681a      	ldr	r2, [r3, #0]
24009126:	f022 0204 	bic.w	r2, r2, #4
2400912a:	601a      	str	r2, [r3, #0]
        __HAL_MDMA_DISABLE(hqspi->hmdma);
2400912c:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
2400912e:	681a      	ldr	r2, [r3, #0]
24009130:	68d3      	ldr	r3, [r2, #12]
24009132:	f023 0301 	bic.w	r3, r3, #1
24009136:	60d3      	str	r3, [r2, #12]
      hqspi->State = HAL_QSPI_STATE_READY;
24009138:	2301      	movs	r3, #1
      HAL_QSPI_RxCpltCallback(hqspi);
2400913a:	4620      	mov	r0, r4
      hqspi->State = HAL_QSPI_STATE_READY;
2400913c:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
      HAL_QSPI_RxCpltCallback(hqspi);
24009140:	f7ff ff86 	bl	24009050 <HAL_QSPI_RxCpltCallback>
24009144:	e79d      	b.n	24009082 <HAL_QSPI_IRQHandler+0x28>
          if (hqspi->RxXferCount > 0U)
24009146:	6ba2      	ldr	r2, [r4, #56]	@ 0x38
24009148:	2a00      	cmp	r2, #0
2400914a:	d0f5      	beq.n	24009138 <HAL_QSPI_IRQHandler+0xde>
            *hqspi->pRxBuffPtr = *((__IO uint8_t *)data_reg);
2400914c:	f893 1020 	ldrb.w	r1, [r3, #32]
24009150:	6b22      	ldr	r2, [r4, #48]	@ 0x30
24009152:	7011      	strb	r1, [r2, #0]
            hqspi->pRxBuffPtr++;
24009154:	6b22      	ldr	r2, [r4, #48]	@ 0x30
24009156:	3201      	adds	r2, #1
24009158:	6322      	str	r2, [r4, #48]	@ 0x30
            hqspi->RxXferCount--;
2400915a:	6ba2      	ldr	r2, [r4, #56]	@ 0x38
2400915c:	3a01      	subs	r2, #1
2400915e:	63a2      	str	r2, [r4, #56]	@ 0x38
        while(READ_BIT(hqspi->Instance->SR, QUADSPI_SR_FLEVEL) != 0U)
24009160:	6822      	ldr	r2, [r4, #0]
24009162:	6892      	ldr	r2, [r2, #8]
24009164:	f412 5f7c 	tst.w	r2, #16128	@ 0x3f00
24009168:	d1ed      	bne.n	24009146 <HAL_QSPI_IRQHandler+0xec>
2400916a:	e7e5      	b.n	24009138 <HAL_QSPI_IRQHandler+0xde>
    else if(hqspi->State == HAL_QSPI_STATE_BUSY)
2400916c:	f894 2041 	ldrb.w	r2, [r4, #65]	@ 0x41
24009170:	2a02      	cmp	r2, #2
24009172:	d106      	bne.n	24009182 <HAL_QSPI_IRQHandler+0x128>
      hqspi->State = HAL_QSPI_STATE_READY;
24009174:	2301      	movs	r3, #1
      HAL_QSPI_CmdCpltCallback(hqspi);
24009176:	4620      	mov	r0, r4
      hqspi->State = HAL_QSPI_STATE_READY;
24009178:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
      HAL_QSPI_CmdCpltCallback(hqspi);
2400917c:	f7ff ff67 	bl	2400904e <HAL_QSPI_CmdCpltCallback>
24009180:	e77f      	b.n	24009082 <HAL_QSPI_IRQHandler+0x28>
    else if(hqspi->State == HAL_QSPI_STATE_ABORT)
24009182:	f894 2041 	ldrb.w	r2, [r4, #65]	@ 0x41
24009186:	2a08      	cmp	r2, #8
24009188:	f47f af7b 	bne.w	24009082 <HAL_QSPI_IRQHandler+0x28>
      CLEAR_BIT(hqspi->Instance->CCR, QUADSPI_CCR_FMODE);
2400918c:	695a      	ldr	r2, [r3, #20]
        HAL_QSPI_AbortCpltCallback(hqspi);
2400918e:	4620      	mov	r0, r4
      CLEAR_BIT(hqspi->Instance->CCR, QUADSPI_CCR_FMODE);
24009190:	f022 6240 	bic.w	r2, r2, #201326592	@ 0xc000000
24009194:	615a      	str	r2, [r3, #20]
      hqspi->State = HAL_QSPI_STATE_READY;
24009196:	2301      	movs	r3, #1
24009198:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
      if (hqspi->ErrorCode == HAL_QSPI_ERROR_NONE)
2400919c:	6c63      	ldr	r3, [r4, #68]	@ 0x44
2400919e:	2b00      	cmp	r3, #0
240091a0:	d13a      	bne.n	24009218 <HAL_QSPI_IRQHandler+0x1be>
        HAL_QSPI_AbortCpltCallback(hqspi);
240091a2:	f7ff ff53 	bl	2400904c <HAL_QSPI_AbortCpltCallback>
240091a6:	e76c      	b.n	24009082 <HAL_QSPI_IRQHandler+0x28>
  else if(((flag & QSPI_FLAG_SM) != 0U) && ((itsource & QSPI_IT_SM) != 0U))
240091a8:	070d      	lsls	r5, r1, #28
240091aa:	d511      	bpl.n	240091d0 <HAL_QSPI_IRQHandler+0x176>
240091ac:	0310      	lsls	r0, r2, #12
240091ae:	d50f      	bpl.n	240091d0 <HAL_QSPI_IRQHandler+0x176>
    WRITE_REG(hqspi->Instance->FCR, QSPI_FLAG_SM);
240091b0:	2208      	movs	r2, #8
240091b2:	60da      	str	r2, [r3, #12]
    if(READ_BIT(hqspi->Instance->CR, QUADSPI_CR_APMS) != 0U)
240091b4:	681a      	ldr	r2, [r3, #0]
240091b6:	0255      	lsls	r5, r2, #9
240091b8:	d506      	bpl.n	240091c8 <HAL_QSPI_IRQHandler+0x16e>
      __HAL_QSPI_DISABLE_IT(hqspi, (QSPI_IT_SM | QSPI_IT_TE));
240091ba:	681a      	ldr	r2, [r3, #0]
240091bc:	f422 2210 	bic.w	r2, r2, #589824	@ 0x90000
240091c0:	601a      	str	r2, [r3, #0]
      hqspi->State = HAL_QSPI_STATE_READY;
240091c2:	2301      	movs	r3, #1
240091c4:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
    HAL_QSPI_StatusMatchCallback(hqspi);
240091c8:	4620      	mov	r0, r4
240091ca:	f7ff ff44 	bl	24009056 <HAL_QSPI_StatusMatchCallback>
240091ce:	e758      	b.n	24009082 <HAL_QSPI_IRQHandler+0x28>
  else if(((flag & QSPI_FLAG_TE) != 0U) && ((itsource & QSPI_IT_TE) != 0U))
240091d0:	07c8      	lsls	r0, r1, #31
240091d2:	d524      	bpl.n	2400921e <HAL_QSPI_IRQHandler+0x1c4>
240091d4:	03d5      	lsls	r5, r2, #15
240091d6:	d522      	bpl.n	2400921e <HAL_QSPI_IRQHandler+0x1c4>
    WRITE_REG(hqspi->Instance->FCR, QSPI_FLAG_TE);
240091d8:	2501      	movs	r5, #1
240091da:	60dd      	str	r5, [r3, #12]
    __HAL_QSPI_DISABLE_IT(hqspi, QSPI_IT_SM | QSPI_IT_TC | QSPI_IT_TE | QSPI_IT_FT);
240091dc:	681a      	ldr	r2, [r3, #0]
240091de:	f422 2270 	bic.w	r2, r2, #983040	@ 0xf0000
240091e2:	601a      	str	r2, [r3, #0]
    hqspi->ErrorCode |= HAL_QSPI_ERROR_TRANSFER;
240091e4:	6c62      	ldr	r2, [r4, #68]	@ 0x44
240091e6:	f042 0202 	orr.w	r2, r2, #2
240091ea:	6462      	str	r2, [r4, #68]	@ 0x44
    if ((hqspi->Instance->CR & QUADSPI_CR_DMAEN) != 0U)
240091ec:	681a      	ldr	r2, [r3, #0]
240091ee:	0750      	lsls	r0, r2, #29
240091f0:	d50f      	bpl.n	24009212 <HAL_QSPI_IRQHandler+0x1b8>
      CLEAR_BIT(hqspi->Instance->CR, QUADSPI_CR_DMAEN);
240091f2:	681a      	ldr	r2, [r3, #0]
      hqspi->hmdma->XferAbortCallback = QSPI_DMAAbortCplt;
240091f4:	6be0      	ldr	r0, [r4, #60]	@ 0x3c
      CLEAR_BIT(hqspi->Instance->CR, QUADSPI_CR_DMAEN);
240091f6:	f022 0204 	bic.w	r2, r2, #4
240091fa:	601a      	str	r2, [r3, #0]
      hqspi->hmdma->XferAbortCallback = QSPI_DMAAbortCplt;
240091fc:	4b0e      	ldr	r3, [pc, #56]	@ (24009238 <HAL_QSPI_IRQHandler+0x1de>)
240091fe:	6583      	str	r3, [r0, #88]	@ 0x58
      if (HAL_MDMA_Abort_IT(hqspi->hmdma) != HAL_OK)
24009200:	f7fe fcee 	bl	24007be0 <HAL_MDMA_Abort_IT>
24009204:	2800      	cmp	r0, #0
24009206:	f43f af3c 	beq.w	24009082 <HAL_QSPI_IRQHandler+0x28>
        hqspi->ErrorCode |= HAL_QSPI_ERROR_DMA;
2400920a:	6c63      	ldr	r3, [r4, #68]	@ 0x44
2400920c:	f043 0304 	orr.w	r3, r3, #4
24009210:	6463      	str	r3, [r4, #68]	@ 0x44
        HAL_QSPI_ErrorCallback(hqspi);
24009212:	4620      	mov	r0, r4
        hqspi->State = HAL_QSPI_STATE_READY;
24009214:	f884 5041 	strb.w	r5, [r4, #65]	@ 0x41
        HAL_QSPI_ErrorCallback(hqspi);
24009218:	f7ff fefc 	bl	24009014 <HAL_QSPI_ErrorCallback>
2400921c:	e731      	b.n	24009082 <HAL_QSPI_IRQHandler+0x28>
  else if(((flag & QSPI_FLAG_TO) != 0U) && ((itsource & QSPI_IT_TO) != 0U))
2400921e:	06c9      	lsls	r1, r1, #27
24009220:	f57f af2f 	bpl.w	24009082 <HAL_QSPI_IRQHandler+0x28>
24009224:	02d2      	lsls	r2, r2, #11
24009226:	f57f af2c 	bpl.w	24009082 <HAL_QSPI_IRQHandler+0x28>
    WRITE_REG(hqspi->Instance->FCR, QSPI_FLAG_TO);
2400922a:	2210      	movs	r2, #16
    HAL_QSPI_TimeOutCallback(hqspi);
2400922c:	4620      	mov	r0, r4
    WRITE_REG(hqspi->Instance->FCR, QSPI_FLAG_TO);
2400922e:	60da      	str	r2, [r3, #12]
    HAL_QSPI_TimeOutCallback(hqspi);
24009230:	f7ff ff12 	bl	24009058 <HAL_QSPI_TimeOutCallback>
}
24009234:	e725      	b.n	24009082 <HAL_QSPI_IRQHandler+0x28>
24009236:	bf00      	nop
24009238:	24009017 	.word	0x24009017

2400923c <HAL_QSPI_GetState>:
  return hqspi->State;
2400923c:	f890 0041 	ldrb.w	r0, [r0, #65]	@ 0x41
}
24009240:	4770      	bx	lr

24009242 <HAL_QSPI_GetError>:
  return hqspi->ErrorCode;
24009242:	6c40      	ldr	r0, [r0, #68]	@ 0x44
}
24009244:	4770      	bx	lr

24009246 <HAL_QSPI_Abort>:
{
24009246:	b537      	push	{r0, r1, r2, r4, r5, lr}
24009248:	4604      	mov	r4, r0
  uint32_t tickstart = HAL_GetTick();
2400924a:	f008 fddd 	bl	24011e08 <HAL_GetTick>
2400924e:	4605      	mov	r5, r0
  if (((uint32_t)hqspi->State & 0x2U) != 0U)
24009250:	f894 3041 	ldrb.w	r3, [r4, #65]	@ 0x41
24009254:	0799      	lsls	r1, r3, #30
24009256:	d534      	bpl.n	240092c2 <HAL_QSPI_Abort+0x7c>
    __HAL_UNLOCK(hqspi);
24009258:	2300      	movs	r3, #0
2400925a:	f884 3040 	strb.w	r3, [r4, #64]	@ 0x40
    if ((hqspi->Instance->CR & QUADSPI_CR_DMAEN) != 0U)
2400925e:	6823      	ldr	r3, [r4, #0]
24009260:	681a      	ldr	r2, [r3, #0]
24009262:	0752      	lsls	r2, r2, #29
24009264:	d50b      	bpl.n	2400927e <HAL_QSPI_Abort+0x38>
      CLEAR_BIT(hqspi->Instance->CR, QUADSPI_CR_DMAEN);
24009266:	681a      	ldr	r2, [r3, #0]
      status = HAL_MDMA_Abort(hqspi->hmdma);
24009268:	6be0      	ldr	r0, [r4, #60]	@ 0x3c
      CLEAR_BIT(hqspi->Instance->CR, QUADSPI_CR_DMAEN);
2400926a:	f022 0204 	bic.w	r2, r2, #4
2400926e:	601a      	str	r2, [r3, #0]
      status = HAL_MDMA_Abort(hqspi->hmdma);
24009270:	f7fe fc7f 	bl	24007b72 <HAL_MDMA_Abort>
      if(status != HAL_OK)
24009274:	b118      	cbz	r0, 2400927e <HAL_QSPI_Abort+0x38>
        hqspi->ErrorCode |= HAL_QSPI_ERROR_DMA;
24009276:	6c63      	ldr	r3, [r4, #68]	@ 0x44
24009278:	f043 0304 	orr.w	r3, r3, #4
2400927c:	6463      	str	r3, [r4, #68]	@ 0x44
    SET_BIT(hqspi->Instance->CR, QUADSPI_CR_ABORT);
2400927e:	6822      	ldr	r2, [r4, #0]
    status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_TC, SET, tickstart, hqspi->Timeout);
24009280:	2102      	movs	r1, #2
24009282:	4620      	mov	r0, r4
    SET_BIT(hqspi->Instance->CR, QUADSPI_CR_ABORT);
24009284:	6813      	ldr	r3, [r2, #0]
24009286:	f043 0302 	orr.w	r3, r3, #2
2400928a:	6013      	str	r3, [r2, #0]
    status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_TC, SET, tickstart, hqspi->Timeout);
2400928c:	2201      	movs	r2, #1
2400928e:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
24009290:	9300      	str	r3, [sp, #0]
24009292:	462b      	mov	r3, r5
24009294:	f7ff fa96 	bl	240087c4 <QSPI_WaitFlagStateUntilTimeout>
    if (status == HAL_OK)
24009298:	b9a0      	cbnz	r0, 240092c4 <HAL_QSPI_Abort+0x7e>
      __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TC);
2400929a:	6823      	ldr	r3, [r4, #0]
2400929c:	2202      	movs	r2, #2
      status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, hqspi->Timeout);
2400929e:	2120      	movs	r1, #32
      __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TC);
240092a0:	60da      	str	r2, [r3, #12]
      status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, hqspi->Timeout);
240092a2:	4602      	mov	r2, r0
240092a4:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
240092a6:	4620      	mov	r0, r4
240092a8:	9300      	str	r3, [sp, #0]
240092aa:	462b      	mov	r3, r5
240092ac:	f7ff fa8a 	bl	240087c4 <QSPI_WaitFlagStateUntilTimeout>
    if (status == HAL_OK)
240092b0:	b940      	cbnz	r0, 240092c4 <HAL_QSPI_Abort+0x7e>
      CLEAR_BIT(hqspi->Instance->CCR, QUADSPI_CCR_FMODE);
240092b2:	6822      	ldr	r2, [r4, #0]
240092b4:	6953      	ldr	r3, [r2, #20]
240092b6:	f023 6340 	bic.w	r3, r3, #201326592	@ 0xc000000
240092ba:	6153      	str	r3, [r2, #20]
      hqspi->State = HAL_QSPI_STATE_READY;
240092bc:	2301      	movs	r3, #1
240092be:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
  HAL_StatusTypeDef status = HAL_OK;
240092c2:	2000      	movs	r0, #0
}
240092c4:	b003      	add	sp, #12
240092c6:	bd30      	pop	{r4, r5, pc}

240092c8 <HAL_QSPI_Abort_IT>:
{
240092c8:	b510      	push	{r4, lr}
  if (((uint32_t)hqspi->State & 0x2U) != 0U)
240092ca:	f890 3041 	ldrb.w	r3, [r0, #65]	@ 0x41
{
240092ce:	4604      	mov	r4, r0
  if (((uint32_t)hqspi->State & 0x2U) != 0U)
240092d0:	0799      	lsls	r1, r3, #30
240092d2:	d51d      	bpl.n	24009310 <HAL_QSPI_Abort_IT+0x48>
    __HAL_UNLOCK(hqspi);
240092d4:	2300      	movs	r3, #0
240092d6:	f880 3040 	strb.w	r3, [r0, #64]	@ 0x40
    hqspi->State = HAL_QSPI_STATE_ABORT;
240092da:	2308      	movs	r3, #8
240092dc:	f880 3041 	strb.w	r3, [r0, #65]	@ 0x41
    __HAL_QSPI_DISABLE_IT(hqspi, (QSPI_IT_TO | QSPI_IT_SM | QSPI_IT_FT | QSPI_IT_TC | QSPI_IT_TE));
240092e0:	6803      	ldr	r3, [r0, #0]
240092e2:	681a      	ldr	r2, [r3, #0]
240092e4:	f422 12f8 	bic.w	r2, r2, #2031616	@ 0x1f0000
240092e8:	601a      	str	r2, [r3, #0]
    if ((hqspi->Instance->CR & QUADSPI_CR_DMAEN) != 0U)
240092ea:	681a      	ldr	r2, [r3, #0]
240092ec:	0752      	lsls	r2, r2, #29
240092ee:	d511      	bpl.n	24009314 <HAL_QSPI_Abort_IT+0x4c>
      CLEAR_BIT(hqspi->Instance->CR, QUADSPI_CR_DMAEN);
240092f0:	681a      	ldr	r2, [r3, #0]
      hqspi->hmdma->XferAbortCallback = QSPI_DMAAbortCplt;
240092f2:	6bc0      	ldr	r0, [r0, #60]	@ 0x3c
      CLEAR_BIT(hqspi->Instance->CR, QUADSPI_CR_DMAEN);
240092f4:	f022 0204 	bic.w	r2, r2, #4
240092f8:	601a      	str	r2, [r3, #0]
      hqspi->hmdma->XferAbortCallback = QSPI_DMAAbortCplt;
240092fa:	4b0c      	ldr	r3, [pc, #48]	@ (2400932c <HAL_QSPI_Abort_IT+0x64>)
240092fc:	6583      	str	r3, [r0, #88]	@ 0x58
      if (HAL_MDMA_Abort_IT(hqspi->hmdma) != HAL_OK)
240092fe:	f7fe fc6f 	bl	24007be0 <HAL_MDMA_Abort_IT>
24009302:	b128      	cbz	r0, 24009310 <HAL_QSPI_Abort_IT+0x48>
        hqspi->State = HAL_QSPI_STATE_READY;
24009304:	2301      	movs	r3, #1
        HAL_QSPI_AbortCpltCallback(hqspi);
24009306:	4620      	mov	r0, r4
        hqspi->State = HAL_QSPI_STATE_READY;
24009308:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
        HAL_QSPI_AbortCpltCallback(hqspi);
2400930c:	f7ff fe9e 	bl	2400904c <HAL_QSPI_AbortCpltCallback>
}
24009310:	2000      	movs	r0, #0
24009312:	bd10      	pop	{r4, pc}
      __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TC);
24009314:	2202      	movs	r2, #2
24009316:	60da      	str	r2, [r3, #12]
      __HAL_QSPI_ENABLE_IT(hqspi, QSPI_IT_TC);
24009318:	681a      	ldr	r2, [r3, #0]
2400931a:	f442 3200 	orr.w	r2, r2, #131072	@ 0x20000
2400931e:	601a      	str	r2, [r3, #0]
      SET_BIT(hqspi->Instance->CR, QUADSPI_CR_ABORT);
24009320:	681a      	ldr	r2, [r3, #0]
24009322:	f042 0202 	orr.w	r2, r2, #2
24009326:	601a      	str	r2, [r3, #0]
24009328:	e7f2      	b.n	24009310 <HAL_QSPI_Abort_IT+0x48>
2400932a:	bf00      	nop
2400932c:	24009017 	.word	0x24009017

24009330 <QSPI_DMAError>:
  QSPI_HandleTypeDef* hqspi = ( QSPI_HandleTypeDef* )(hmdma->Parent);
24009330:	6c00      	ldr	r0, [r0, #64]	@ 0x40
  hqspi->RxXferCount = 0U;
24009332:	2300      	movs	r3, #0
24009334:	6383      	str	r3, [r0, #56]	@ 0x38
  hqspi->TxXferCount = 0U;
24009336:	62c3      	str	r3, [r0, #44]	@ 0x2c
  hqspi->ErrorCode   |= HAL_QSPI_ERROR_DMA;
24009338:	6c43      	ldr	r3, [r0, #68]	@ 0x44
  CLEAR_BIT(hqspi->Instance->CR, QUADSPI_CR_DMAEN);
2400933a:	6802      	ldr	r2, [r0, #0]
  hqspi->ErrorCode   |= HAL_QSPI_ERROR_DMA;
2400933c:	f043 0304 	orr.w	r3, r3, #4
24009340:	6443      	str	r3, [r0, #68]	@ 0x44
  CLEAR_BIT(hqspi->Instance->CR, QUADSPI_CR_DMAEN);
24009342:	6813      	ldr	r3, [r2, #0]
24009344:	f023 0304 	bic.w	r3, r3, #4
24009348:	6013      	str	r3, [r2, #0]
  (void)HAL_QSPI_Abort_IT(hqspi);
2400934a:	f7ff bfbd 	b.w	240092c8 <HAL_QSPI_Abort_IT>

2400934e <HAL_QSPI_SetTimeout>:
  hqspi->Timeout = Timeout;
2400934e:	6481      	str	r1, [r0, #72]	@ 0x48
}
24009350:	4770      	bx	lr

24009352 <HAL_QSPI_SetFifoThreshold>:
  __HAL_LOCK(hqspi);
24009352:	f890 2040 	ldrb.w	r2, [r0, #64]	@ 0x40
{
24009356:	4603      	mov	r3, r0
  __HAL_LOCK(hqspi);
24009358:	2a01      	cmp	r2, #1
2400935a:	d016      	beq.n	2400938a <HAL_QSPI_SetFifoThreshold+0x38>
2400935c:	2201      	movs	r2, #1
2400935e:	f880 2040 	strb.w	r2, [r0, #64]	@ 0x40
  if(hqspi->State == HAL_QSPI_STATE_READY)
24009362:	f890 2041 	ldrb.w	r2, [r0, #65]	@ 0x41
24009366:	2a01      	cmp	r2, #1
24009368:	d10d      	bne.n	24009386 <HAL_QSPI_SetFifoThreshold+0x34>
    hqspi->Init.FifoThreshold = Threshold;
2400936a:	6081      	str	r1, [r0, #8]
    MODIFY_REG(hqspi->Instance->CR, QUADSPI_CR_FTHRES,
2400936c:	3901      	subs	r1, #1
2400936e:	6800      	ldr	r0, [r0, #0]
24009370:	6802      	ldr	r2, [r0, #0]
24009372:	f422 6270 	bic.w	r2, r2, #3840	@ 0xf00
24009376:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
2400937a:	6002      	str	r2, [r0, #0]
  HAL_StatusTypeDef status = HAL_OK;
2400937c:	2000      	movs	r0, #0
  __HAL_UNLOCK(hqspi);
2400937e:	2200      	movs	r2, #0
24009380:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40
  return status;
24009384:	4770      	bx	lr
    status = HAL_BUSY;
24009386:	2002      	movs	r0, #2
24009388:	e7f9      	b.n	2400937e <HAL_QSPI_SetFifoThreshold+0x2c>
  __HAL_LOCK(hqspi);
2400938a:	2002      	movs	r0, #2
}
2400938c:	4770      	bx	lr

2400938e <HAL_QSPI_GetFifoThreshold>:
  return ((READ_BIT(hqspi->Instance->CR, QUADSPI_CR_FTHRES) >> QUADSPI_CR_FTHRES_Pos) + 1U);
2400938e:	6803      	ldr	r3, [r0, #0]
24009390:	6818      	ldr	r0, [r3, #0]
24009392:	f3c0 2003 	ubfx	r0, r0, #8, #4
}
24009396:	3001      	adds	r0, #1
24009398:	4770      	bx	lr

2400939a <HAL_QSPI_SetFlashID>:
  __HAL_LOCK(hqspi);
2400939a:	f890 2040 	ldrb.w	r2, [r0, #64]	@ 0x40
{
2400939e:	4603      	mov	r3, r0
  __HAL_LOCK(hqspi);
240093a0:	2a01      	cmp	r2, #1
240093a2:	d014      	beq.n	240093ce <HAL_QSPI_SetFlashID+0x34>
240093a4:	2201      	movs	r2, #1
240093a6:	f880 2040 	strb.w	r2, [r0, #64]	@ 0x40
  if(hqspi->State == HAL_QSPI_STATE_READY)
240093aa:	f890 2041 	ldrb.w	r2, [r0, #65]	@ 0x41
240093ae:	2a01      	cmp	r2, #1
240093b0:	d10b      	bne.n	240093ca <HAL_QSPI_SetFlashID+0x30>
    hqspi->Init.FlashID = FlashID;
240093b2:	61c1      	str	r1, [r0, #28]
    MODIFY_REG(hqspi->Instance->CR, QUADSPI_CR_FSEL, FlashID);
240093b4:	6800      	ldr	r0, [r0, #0]
240093b6:	6802      	ldr	r2, [r0, #0]
240093b8:	f022 0280 	bic.w	r2, r2, #128	@ 0x80
240093bc:	4311      	orrs	r1, r2
240093be:	6001      	str	r1, [r0, #0]
  HAL_StatusTypeDef status = HAL_OK;
240093c0:	2000      	movs	r0, #0
  __HAL_UNLOCK(hqspi);
240093c2:	2200      	movs	r2, #0
240093c4:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40
  return status;
240093c8:	4770      	bx	lr
    status = HAL_BUSY;
240093ca:	2002      	movs	r0, #2
240093cc:	e7f9      	b.n	240093c2 <HAL_QSPI_SetFlashID+0x28>
  __HAL_LOCK(hqspi);
240093ce:	2002      	movs	r0, #2
}
240093d0:	4770      	bx	lr
240093d2:	bf00      	nop

240093d4 <HAL_RCC_DeInit>:
HAL_StatusTypeDef HAL_RCC_DeInit(void)
{
  uint32_t tickstart;

        /* Increasing the CPU frequency */
  if(FLASH_LATENCY_DEFAULT  > __HAL_FLASH_GET_LATENCY())
240093d4:	4a5f      	ldr	r2, [pc, #380]	@ (24009554 <HAL_RCC_DeInit+0x180>)
{
240093d6:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if(FLASH_LATENCY_DEFAULT  > __HAL_FLASH_GET_LATENCY())
240093d8:	6813      	ldr	r3, [r2, #0]
240093da:	f003 030f 	and.w	r3, r3, #15
240093de:	2b06      	cmp	r3, #6
240093e0:	f240 8082 	bls.w	240094e8 <HAL_RCC_DeInit+0x114>

  /* Get Start Tick */
  tickstart = HAL_GetTick();

  /* Set HSION bit */
  SET_BIT(RCC->CR, RCC_CR_HSION);
240093e4:	4c5c      	ldr	r4, [pc, #368]	@ (24009558 <HAL_RCC_DeInit+0x184>)
  tickstart = HAL_GetTick();
240093e6:	f008 fd0f 	bl	24011e08 <HAL_GetTick>
240093ea:	4605      	mov	r5, r0
  SET_BIT(RCC->CR, RCC_CR_HSION);
240093ec:	6823      	ldr	r3, [r4, #0]
240093ee:	f043 0301 	orr.w	r3, r3, #1
240093f2:	6023      	str	r3, [r4, #0]

  /* Wait till HSI is ready */
  while (READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
240093f4:	6823      	ldr	r3, [r4, #0]
240093f6:	075e      	lsls	r6, r3, #29
240093f8:	f140 8085 	bpl.w	24009506 <HAL_RCC_DeInit+0x132>
      return HAL_TIMEOUT;
    }
  }

  /* Set HSITRIM[6:0] bits to the reset value */
  SET_BIT(RCC->HSICFGR, RCC_HSICFGR_HSITRIM_6);
240093fc:	6863      	ldr	r3, [r4, #4]

  /* Reset CFGR register */
  CLEAR_REG(RCC->CFGR);

  /* Update the SystemCoreClock and SystemD2Clock global variables */
  SystemCoreClock = HSI_VALUE;
240093fe:	4a57      	ldr	r2, [pc, #348]	@ (2400955c <HAL_RCC_DeInit+0x188>)
  SET_BIT(RCC->HSICFGR, RCC_HSICFGR_HSITRIM_6);
24009400:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
24009404:	6063      	str	r3, [r4, #4]
  CLEAR_REG(RCC->CFGR);
24009406:	2300      	movs	r3, #0
24009408:	6123      	str	r3, [r4, #16]
  SystemCoreClock = HSI_VALUE;
2400940a:	4b55      	ldr	r3, [pc, #340]	@ (24009560 <HAL_RCC_DeInit+0x18c>)
2400940c:	6013      	str	r3, [r2, #0]
  SystemD2Clock = HSI_VALUE;
2400940e:	4a55      	ldr	r2, [pc, #340]	@ (24009564 <HAL_RCC_DeInit+0x190>)
24009410:	6013      	str	r3, [r2, #0]

  /* Adapt Systick interrupt period */
  if(HAL_InitTick(uwTickPrio) != HAL_OK)
24009412:	4b55      	ldr	r3, [pc, #340]	@ (24009568 <HAL_RCC_DeInit+0x194>)
24009414:	6818      	ldr	r0, [r3, #0]
24009416:	f008 fcf5 	bl	24011e04 <HAL_InitTick>
2400941a:	4605      	mov	r5, r0
2400941c:	2800      	cmp	r0, #0
2400941e:	d16f      	bne.n	24009500 <HAL_RCC_DeInit+0x12c>
  {
    return HAL_ERROR;
  }

  /* Get Start Tick */
  tickstart = HAL_GetTick();
24009420:	f008 fcf2 	bl	24011e08 <HAL_GetTick>

  /* Wait till clock switch is ready */
  while (READ_BIT(RCC->CFGR, RCC_CFGR_SWS) != 0U)
24009424:	4c4c      	ldr	r4, [pc, #304]	@ (24009558 <HAL_RCC_DeInit+0x184>)
  tickstart = HAL_GetTick();
24009426:	4606      	mov	r6, r0
  {
    if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
24009428:	f241 3788 	movw	r7, #5000	@ 0x1388
  while (READ_BIT(RCC->CFGR, RCC_CFGR_SWS) != 0U)
2400942c:	6923      	ldr	r3, [r4, #16]
2400942e:	f013 0f38 	tst.w	r3, #56	@ 0x38
24009432:	d170      	bne.n	24009516 <HAL_RCC_DeInit+0x142>
      return HAL_TIMEOUT;
    }
  }

  /* Get Start Tick */
  tickstart = HAL_GetTick();
24009434:	f008 fce8 	bl	24011e08 <HAL_GetTick>

  /* Reset CSION, CSIKERON, HSEON, HSI48ON, HSECSSON, HSIDIV bits */
  CLEAR_BIT(RCC->CR, RCC_CR_HSEON | RCC_CR_HSIKERON| RCC_CR_HSIDIV| RCC_CR_HSIDIVF| RCC_CR_CSION | RCC_CR_CSIKERON  \
24009438:	6822      	ldr	r2, [r4, #0]
2400943a:	4b4c      	ldr	r3, [pc, #304]	@ (2400956c <HAL_RCC_DeInit+0x198>)
  tickstart = HAL_GetTick();
2400943c:	4606      	mov	r6, r0
  CLEAR_BIT(RCC->CR, RCC_CR_HSEON | RCC_CR_HSIKERON| RCC_CR_HSIDIV| RCC_CR_HSIDIVF| RCC_CR_CSION | RCC_CR_CSIKERON  \
2400943e:	4013      	ands	r3, r2
24009440:	6023      	str	r3, [r4, #0]
  | RCC_CR_HSI48ON | RCC_CR_CSSHSEON);

  /* Wait till HSE is disabled */
  while (READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U)
24009442:	4c45      	ldr	r4, [pc, #276]	@ (24009558 <HAL_RCC_DeInit+0x184>)
24009444:	6823      	ldr	r3, [r4, #0]
24009446:	0398      	lsls	r0, r3, #14
24009448:	d46b      	bmi.n	24009522 <HAL_RCC_DeInit+0x14e>
      return HAL_TIMEOUT;
    }
  }

  /* Get Start Tick */
  tickstart = HAL_GetTick();
2400944a:	f008 fcdd 	bl	24011e08 <HAL_GetTick>

  /* Clear PLLON bit */
  CLEAR_BIT(RCC->CR, RCC_CR_PLL1ON);
2400944e:	6823      	ldr	r3, [r4, #0]
  tickstart = HAL_GetTick();
24009450:	4606      	mov	r6, r0
  CLEAR_BIT(RCC->CR, RCC_CR_PLL1ON);
24009452:	f023 7380 	bic.w	r3, r3, #16777216	@ 0x1000000
24009456:	6023      	str	r3, [r4, #0]

  /* Wait till PLL is disabled */
  while (READ_BIT(RCC->CR, RCC_CR_PLL1RDY) != 0U)
24009458:	4c3f      	ldr	r4, [pc, #252]	@ (24009558 <HAL_RCC_DeInit+0x184>)
2400945a:	6823      	ldr	r3, [r4, #0]
2400945c:	0199      	lsls	r1, r3, #6
2400945e:	d466      	bmi.n	2400952e <HAL_RCC_DeInit+0x15a>
      return HAL_TIMEOUT;
    }
  }

  /* Get Start Tick */
  tickstart = HAL_GetTick();
24009460:	f008 fcd2 	bl	24011e08 <HAL_GetTick>

  /* Reset PLL2ON bit */
  CLEAR_BIT(RCC->CR, RCC_CR_PLL2ON);
24009464:	6823      	ldr	r3, [r4, #0]
  tickstart = HAL_GetTick();
24009466:	4606      	mov	r6, r0
  CLEAR_BIT(RCC->CR, RCC_CR_PLL2ON);
24009468:	f023 6380 	bic.w	r3, r3, #67108864	@ 0x4000000
2400946c:	6023      	str	r3, [r4, #0]

  /* Wait till PLL2 is disabled */
  while (READ_BIT(RCC->CR, RCC_CR_PLL2RDY) != 0U)
2400946e:	4c3a      	ldr	r4, [pc, #232]	@ (24009558 <HAL_RCC_DeInit+0x184>)
24009470:	6823      	ldr	r3, [r4, #0]
24009472:	011a      	lsls	r2, r3, #4
24009474:	d461      	bmi.n	2400953a <HAL_RCC_DeInit+0x166>
      return HAL_TIMEOUT;
    }
  }

  /* Get Start Tick */
  tickstart = HAL_GetTick();
24009476:	f008 fcc7 	bl	24011e08 <HAL_GetTick>

  /* Reset PLL3 bit */
  CLEAR_BIT(RCC->CR, RCC_CR_PLL3ON);
2400947a:	6823      	ldr	r3, [r4, #0]
  tickstart = HAL_GetTick();
2400947c:	4606      	mov	r6, r0
  CLEAR_BIT(RCC->CR, RCC_CR_PLL3ON);
2400947e:	f023 5380 	bic.w	r3, r3, #268435456	@ 0x10000000
24009482:	6023      	str	r3, [r4, #0]

  /* Wait till PLL3 is disabled */
  while (READ_BIT(RCC->CR, RCC_CR_PLL3RDY) != 0U)
24009484:	4c34      	ldr	r4, [pc, #208]	@ (24009558 <HAL_RCC_DeInit+0x184>)
24009486:	6823      	ldr	r3, [r4, #0]
24009488:	f013 5300 	ands.w	r3, r3, #536870912	@ 0x20000000
2400948c:	d15b      	bne.n	24009546 <HAL_RCC_DeInit+0x172>
  /* Reset SRDCFGR register */
  CLEAR_REG(RCC->SRDCFGR);
#endif

  /* Reset PLLCKSELR register to default value */
  RCC->PLLCKSELR= RCC_PLLCKSELR_DIVM1_5|RCC_PLLCKSELR_DIVM2_5|RCC_PLLCKSELR_DIVM3_5;
2400948e:	4a38      	ldr	r2, [pc, #224]	@ (24009570 <HAL_RCC_DeInit+0x19c>)
  CLEAR_REG(RCC->D1CFGR);
24009490:	61a3      	str	r3, [r4, #24]
  CLEAR_REG(RCC->D2CFGR);
24009492:	61e3      	str	r3, [r4, #28]
  CLEAR_REG(RCC->D3CFGR);
24009494:	6223      	str	r3, [r4, #32]
  RCC->PLLCKSELR= RCC_PLLCKSELR_DIVM1_5|RCC_PLLCKSELR_DIVM2_5|RCC_PLLCKSELR_DIVM3_5;
24009496:	62a2      	str	r2, [r4, #40]	@ 0x28

  /* Reset PLLCFGR register to default value */
  WRITE_REG(RCC->PLLCFGR, 0x01FF0000U);
24009498:	4a36      	ldr	r2, [pc, #216]	@ (24009574 <HAL_RCC_DeInit+0x1a0>)
2400949a:	62e2      	str	r2, [r4, #44]	@ 0x2c

  /* Reset PLL1DIVR register to default value */
  WRITE_REG(RCC->PLL1DIVR,0x01010280U);
2400949c:	4a36      	ldr	r2, [pc, #216]	@ (24009578 <HAL_RCC_DeInit+0x1a4>)
2400949e:	6322      	str	r2, [r4, #48]	@ 0x30

  /* Reset PLL1FRACR register */
  CLEAR_REG(RCC->PLL1FRACR);
240094a0:	6363      	str	r3, [r4, #52]	@ 0x34

  /* Reset PLL2DIVR register to default value */
  WRITE_REG(RCC->PLL2DIVR,0x01010280U);
240094a2:	63a2      	str	r2, [r4, #56]	@ 0x38

  /* Reset PLL2FRACR register */
  CLEAR_REG(RCC->PLL2FRACR);
240094a4:	63e3      	str	r3, [r4, #60]	@ 0x3c

  /* Reset PLL3DIVR register to default value */
  WRITE_REG(RCC->PLL3DIVR,0x01010280U);
240094a6:	6422      	str	r2, [r4, #64]	@ 0x40

  /* Reset PLL3FRACR register */
  CLEAR_REG(RCC->PLL3FRACR);
240094a8:	6463      	str	r3, [r4, #68]	@ 0x44

  /* Reset HSEBYP bit */
  CLEAR_BIT(RCC->CR, RCC_CR_HSEBYP);
240094aa:	6822      	ldr	r2, [r4, #0]
240094ac:	f422 2280 	bic.w	r2, r2, #262144	@ 0x40000
240094b0:	6022      	str	r2, [r4, #0]

  /* Disable all interrupts */
  CLEAR_REG(RCC->CIER);
240094b2:	6623      	str	r3, [r4, #96]	@ 0x60

  /* Clear all interrupts flags */
  WRITE_REG(RCC->CICR,0xFFFFFFFFU);
240094b4:	f04f 33ff 	mov.w	r3, #4294967295

  /* Reset all RSR flags */
  SET_BIT(RCC->RSR, RCC_RSR_RMVF);

      /* Decreasing the number of wait states because of lower CPU frequency */
  if(FLASH_LATENCY_DEFAULT  < __HAL_FLASH_GET_LATENCY())
240094b8:	4a26      	ldr	r2, [pc, #152]	@ (24009554 <HAL_RCC_DeInit+0x180>)
  WRITE_REG(RCC->CICR,0xFFFFFFFFU);
240094ba:	66a3      	str	r3, [r4, #104]	@ 0x68
  SET_BIT(RCC->RSR, RCC_RSR_RMVF);
240094bc:	f8d4 30d0 	ldr.w	r3, [r4, #208]	@ 0xd0
240094c0:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
240094c4:	f8c4 30d0 	str.w	r3, [r4, #208]	@ 0xd0
  if(FLASH_LATENCY_DEFAULT  < __HAL_FLASH_GET_LATENCY())
240094c8:	6813      	ldr	r3, [r2, #0]
240094ca:	071b      	lsls	r3, r3, #28
240094cc:	d519      	bpl.n	24009502 <HAL_RCC_DeInit+0x12e>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLASH_LATENCY_DEFAULT);
240094ce:	6813      	ldr	r3, [r2, #0]
240094d0:	f023 030f 	bic.w	r3, r3, #15
240094d4:	f043 0307 	orr.w	r3, r3, #7
240094d8:	6013      	str	r3, [r2, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if(__HAL_FLASH_GET_LATENCY() != FLASH_LATENCY_DEFAULT)
240094da:	6815      	ldr	r5, [r2, #0]
240094dc:	f005 050f 	and.w	r5, r5, #15
240094e0:	3d07      	subs	r5, #7
240094e2:	bf18      	it	ne
240094e4:	2501      	movne	r5, #1
240094e6:	e00c      	b.n	24009502 <HAL_RCC_DeInit+0x12e>
    __HAL_FLASH_SET_LATENCY(FLASH_LATENCY_DEFAULT);
240094e8:	6813      	ldr	r3, [r2, #0]
240094ea:	f023 030f 	bic.w	r3, r3, #15
240094ee:	f043 0307 	orr.w	r3, r3, #7
240094f2:	6013      	str	r3, [r2, #0]
    if(__HAL_FLASH_GET_LATENCY() != FLASH_LATENCY_DEFAULT)
240094f4:	6813      	ldr	r3, [r2, #0]
240094f6:	f003 030f 	and.w	r3, r3, #15
240094fa:	2b07      	cmp	r3, #7
240094fc:	f43f af72 	beq.w	240093e4 <HAL_RCC_DeInit+0x10>
      return HAL_ERROR;
24009500:	2501      	movs	r5, #1
    }

}

  return HAL_OK;
}
24009502:	4628      	mov	r0, r5
24009504:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
24009506:	f008 fc7f 	bl	24011e08 <HAL_GetTick>
2400950a:	1b40      	subs	r0, r0, r5
2400950c:	2802      	cmp	r0, #2
2400950e:	f67f af71 	bls.w	240093f4 <HAL_RCC_DeInit+0x20>
      return HAL_TIMEOUT;
24009512:	2503      	movs	r5, #3
24009514:	e7f5      	b.n	24009502 <HAL_RCC_DeInit+0x12e>
    if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
24009516:	f008 fc77 	bl	24011e08 <HAL_GetTick>
2400951a:	1b80      	subs	r0, r0, r6
2400951c:	42b8      	cmp	r0, r7
2400951e:	d985      	bls.n	2400942c <HAL_RCC_DeInit+0x58>
24009520:	e7f7      	b.n	24009512 <HAL_RCC_DeInit+0x13e>
    if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
24009522:	f008 fc71 	bl	24011e08 <HAL_GetTick>
24009526:	1b80      	subs	r0, r0, r6
24009528:	2864      	cmp	r0, #100	@ 0x64
2400952a:	d98b      	bls.n	24009444 <HAL_RCC_DeInit+0x70>
2400952c:	e7f1      	b.n	24009512 <HAL_RCC_DeInit+0x13e>
    if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
2400952e:	f008 fc6b 	bl	24011e08 <HAL_GetTick>
24009532:	1b80      	subs	r0, r0, r6
24009534:	2802      	cmp	r0, #2
24009536:	d990      	bls.n	2400945a <HAL_RCC_DeInit+0x86>
24009538:	e7eb      	b.n	24009512 <HAL_RCC_DeInit+0x13e>
    if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
2400953a:	f008 fc65 	bl	24011e08 <HAL_GetTick>
2400953e:	1b80      	subs	r0, r0, r6
24009540:	2802      	cmp	r0, #2
24009542:	d995      	bls.n	24009470 <HAL_RCC_DeInit+0x9c>
24009544:	e7e5      	b.n	24009512 <HAL_RCC_DeInit+0x13e>
    if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
24009546:	f008 fc5f 	bl	24011e08 <HAL_GetTick>
2400954a:	1b80      	subs	r0, r0, r6
2400954c:	2802      	cmp	r0, #2
2400954e:	d99a      	bls.n	24009486 <HAL_RCC_DeInit+0xb2>
24009550:	e7df      	b.n	24009512 <HAL_RCC_DeInit+0x13e>
24009552:	bf00      	nop
24009554:	52002000 	.word	0x52002000
24009558:	58024400 	.word	0x58024400
2400955c:	24000518 	.word	0x24000518
24009560:	03d09000 	.word	0x03d09000
24009564:	24000514 	.word	0x24000514
24009568:	240004a4 	.word	0x240004a4
2400956c:	fff6ed45 	.word	0xfff6ed45
24009570:	02020200 	.word	0x02020200
24009574:	01ff0000 	.word	0x01ff0000
24009578:	01010280 	.word	0x01010280

2400957c <HAL_RCC_OscConfig>:
  *         supported by this function. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
2400957c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint32_t tickstart;
  uint32_t temp1_pllckcfg, temp2_pllckcfg;

    /* Check Null pointer */
  if(RCC_OscInitStruct == NULL)
2400957e:	4604      	mov	r4, r0
24009580:	2800      	cmp	r0, #0
24009582:	d070      	beq.n	24009666 <HAL_RCC_OscConfig+0xea>
  }

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  /*------------------------------- HSE Configuration ------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
24009584:	6803      	ldr	r3, [r0, #0]
24009586:	07d8      	lsls	r0, r3, #31
24009588:	d45a      	bmi.n	24009640 <HAL_RCC_OscConfig+0xc4>
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
2400958a:	6823      	ldr	r3, [r4, #0]
2400958c:	0799      	lsls	r1, r3, #30
2400958e:	f100 80a9 	bmi.w	240096e4 <HAL_RCC_OscConfig+0x168>
        }
      }
    }
  }
  /*----------------------------- CSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_CSI) == RCC_OSCILLATORTYPE_CSI)
24009592:	6823      	ldr	r3, [r4, #0]
24009594:	06da      	lsls	r2, r3, #27
24009596:	d523      	bpl.n	240095e0 <HAL_RCC_OscConfig+0x64>
    /* Check the parameters */
    assert_param(IS_RCC_CSI(RCC_OscInitStruct->CSIState));
    assert_param(IS_RCC_CSICALIBRATION_VALUE(RCC_OscInitStruct->CSICalibrationValue));

    /* When the CSI is used as system clock it will not disabled */
    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
24009598:	4a9f      	ldr	r2, [pc, #636]	@ (24009818 <HAL_RCC_OscConfig+0x29c>)
2400959a:	6913      	ldr	r3, [r2, #16]
    const uint32_t temp_pllckselr = RCC->PLLCKSELR;
2400959c:	6a91      	ldr	r1, [r2, #40]	@ 0x28
    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
2400959e:	f003 0338 	and.w	r3, r3, #56	@ 0x38
    if((temp_sysclksrc == RCC_CFGR_SWS_CSI) || ((temp_sysclksrc == RCC_CFGR_SWS_PLL1) && ((temp_pllckselr & RCC_PLLCKSELR_PLLSRC) == RCC_PLLCKSELR_PLLSRC_CSI)))
240095a2:	2b08      	cmp	r3, #8
240095a4:	d007      	beq.n	240095b6 <HAL_RCC_OscConfig+0x3a>
240095a6:	2b18      	cmp	r3, #24
240095a8:	f040 80fc 	bne.w	240097a4 <HAL_RCC_OscConfig+0x228>
240095ac:	f001 0303 	and.w	r3, r1, #3
240095b0:	2b01      	cmp	r3, #1
240095b2:	f040 80f7 	bne.w	240097a4 <HAL_RCC_OscConfig+0x228>
    {
      /* When CSI is used as system clock it will not disabled */
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) != 0U) && (RCC_OscInitStruct->CSIState != RCC_CSI_ON))
240095b6:	6813      	ldr	r3, [r2, #0]
240095b8:	05db      	lsls	r3, r3, #23
240095ba:	d502      	bpl.n	240095c2 <HAL_RCC_OscConfig+0x46>
240095bc:	69e3      	ldr	r3, [r4, #28]
240095be:	2b80      	cmp	r3, #128	@ 0x80
240095c0:	d151      	bne.n	24009666 <HAL_RCC_OscConfig+0xea>
      }
      /* Otherwise, just the calibration is allowed */
      else
      {
        /* Adjusts the Internal High Speed oscillator (CSI) calibration value.*/
        __HAL_RCC_CSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->CSICalibrationValue);
240095c2:	f7f7 f9fa 	bl	240009ba <HAL_GetREVID>
240095c6:	f241 0303 	movw	r3, #4099	@ 0x1003
240095ca:	4a93      	ldr	r2, [pc, #588]	@ (24009818 <HAL_RCC_OscConfig+0x29c>)
240095cc:	4298      	cmp	r0, r3
240095ce:	6a21      	ldr	r1, [r4, #32]
240095d0:	f200 80e1 	bhi.w	24009796 <HAL_RCC_OscConfig+0x21a>
240095d4:	6853      	ldr	r3, [r2, #4]
240095d6:	f023 43f8 	bic.w	r3, r3, #2080374784	@ 0x7c000000
240095da:	ea43 6381 	orr.w	r3, r3, r1, lsl #26
240095de:	6053      	str	r3, [r2, #4]
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
240095e0:	6823      	ldr	r3, [r4, #0]
240095e2:	0719      	lsls	r1, r3, #28
240095e4:	f100 811c 	bmi.w	24009820 <HAL_RCC_OscConfig+0x2a4>
      }
    }
  }

  /*------------------------------ HSI48 Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI48) == RCC_OSCILLATORTYPE_HSI48)
240095e8:	6823      	ldr	r3, [r4, #0]
240095ea:	069a      	lsls	r2, r3, #26
240095ec:	f100 813d 	bmi.w	2400986a <HAL_RCC_OscConfig+0x2ee>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
240095f0:	6823      	ldr	r3, [r4, #0]
240095f2:	075d      	lsls	r5, r3, #29
240095f4:	d51e      	bpl.n	24009634 <HAL_RCC_OscConfig+0xb8>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));

    /* Enable write access to Backup domain */
    PWR->CR1 |= PWR_CR1_DBP;
240095f6:	4d89      	ldr	r5, [pc, #548]	@ (2400981c <HAL_RCC_OscConfig+0x2a0>)
240095f8:	682b      	ldr	r3, [r5, #0]
240095fa:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
240095fe:	602b      	str	r3, [r5, #0]

    /* Wait for Backup domain Write protection disable */
    tickstart = HAL_GetTick();
24009600:	f008 fc02 	bl	24011e08 <HAL_GetTick>
24009604:	4606      	mov	r6, r0

    while((PWR->CR1 & PWR_CR1_DBP) == 0U)
24009606:	682b      	ldr	r3, [r5, #0]
24009608:	05da      	lsls	r2, r3, #23
2400960a:	f140 8153 	bpl.w	240098b4 <HAL_RCC_OscConfig+0x338>
        return HAL_TIMEOUT;
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
2400960e:	68a3      	ldr	r3, [r4, #8]
24009610:	4d81      	ldr	r5, [pc, #516]	@ (24009818 <HAL_RCC_OscConfig+0x29c>)
24009612:	2b01      	cmp	r3, #1
24009614:	f040 8155 	bne.w	240098c2 <HAL_RCC_OscConfig+0x346>
24009618:	6f2b      	ldr	r3, [r5, #112]	@ 0x70
2400961a:	f043 0301 	orr.w	r3, r3, #1
2400961e:	672b      	str	r3, [r5, #112]	@ 0x70
      tickstart = HAL_GetTick();

      /* Wait till LSE is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
24009620:	f241 3788 	movw	r7, #5000	@ 0x1388
      tickstart = HAL_GetTick();
24009624:	f008 fbf0 	bl	24011e08 <HAL_GetTick>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
24009628:	4e7b      	ldr	r6, [pc, #492]	@ (24009818 <HAL_RCC_OscConfig+0x29c>)
      tickstart = HAL_GetTick();
2400962a:	4605      	mov	r5, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
2400962c:	6f33      	ldr	r3, [r6, #112]	@ 0x70
2400962e:	079b      	lsls	r3, r3, #30
24009630:	f140 816d 	bpl.w	2400990e <HAL_RCC_OscConfig+0x392>
    }
  }
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
24009634:	6a62      	ldr	r2, [r4, #36]	@ 0x24
24009636:	2a00      	cmp	r2, #0
24009638:	f040 8170 	bne.w	2400991c <HAL_RCC_OscConfig+0x3a0>
      {
        return HAL_ERROR;
      }
    }
  }
  return HAL_OK;
2400963c:	2000      	movs	r0, #0
2400963e:	e02b      	b.n	24009698 <HAL_RCC_OscConfig+0x11c>
    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
24009640:	4a75      	ldr	r2, [pc, #468]	@ (24009818 <HAL_RCC_OscConfig+0x29c>)
24009642:	6913      	ldr	r3, [r2, #16]
    const uint32_t temp_pllckselr = RCC->PLLCKSELR;
24009644:	6a91      	ldr	r1, [r2, #40]	@ 0x28
    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
24009646:	f003 0338 	and.w	r3, r3, #56	@ 0x38
    if((temp_sysclksrc == RCC_CFGR_SWS_HSE) || ((temp_sysclksrc == RCC_CFGR_SWS_PLL1) && ((temp_pllckselr & RCC_PLLCKSELR_PLLSRC) == RCC_PLLCKSELR_PLLSRC_HSE)))
2400964a:	2b10      	cmp	r3, #16
2400964c:	d005      	beq.n	2400965a <HAL_RCC_OscConfig+0xde>
2400964e:	2b18      	cmp	r3, #24
24009650:	d10b      	bne.n	2400966a <HAL_RCC_OscConfig+0xee>
24009652:	f001 0303 	and.w	r3, r1, #3
24009656:	2b02      	cmp	r3, #2
24009658:	d107      	bne.n	2400966a <HAL_RCC_OscConfig+0xee>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
2400965a:	6813      	ldr	r3, [r2, #0]
2400965c:	039a      	lsls	r2, r3, #14
2400965e:	d594      	bpl.n	2400958a <HAL_RCC_OscConfig+0xe>
24009660:	6863      	ldr	r3, [r4, #4]
24009662:	2b00      	cmp	r3, #0
24009664:	d191      	bne.n	2400958a <HAL_RCC_OscConfig+0xe>
    return HAL_ERROR;
24009666:	2001      	movs	r0, #1
24009668:	e016      	b.n	24009698 <HAL_RCC_OscConfig+0x11c>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
2400966a:	6863      	ldr	r3, [r4, #4]
2400966c:	4d6a      	ldr	r5, [pc, #424]	@ (24009818 <HAL_RCC_OscConfig+0x29c>)
2400966e:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
24009672:	d112      	bne.n	2400969a <HAL_RCC_OscConfig+0x11e>
24009674:	682b      	ldr	r3, [r5, #0]
24009676:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
2400967a:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
2400967c:	f008 fbc4 	bl	24011e08 <HAL_GetTick>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
24009680:	4e65      	ldr	r6, [pc, #404]	@ (24009818 <HAL_RCC_OscConfig+0x29c>)
        tickstart = HAL_GetTick();
24009682:	4605      	mov	r5, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
24009684:	6833      	ldr	r3, [r6, #0]
24009686:	039b      	lsls	r3, r3, #14
24009688:	f53f af7f 	bmi.w	2400958a <HAL_RCC_OscConfig+0xe>
          if((uint32_t) (HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
2400968c:	f008 fbbc 	bl	24011e08 <HAL_GetTick>
24009690:	1b40      	subs	r0, r0, r5
24009692:	2864      	cmp	r0, #100	@ 0x64
24009694:	d9f6      	bls.n	24009684 <HAL_RCC_OscConfig+0x108>
            return HAL_TIMEOUT;
24009696:	2003      	movs	r0, #3
}
24009698:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
2400969a:	b9a3      	cbnz	r3, 240096c6 <HAL_RCC_OscConfig+0x14a>
2400969c:	682b      	ldr	r3, [r5, #0]
2400969e:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
240096a2:	602b      	str	r3, [r5, #0]
240096a4:	682b      	ldr	r3, [r5, #0]
240096a6:	f423 2380 	bic.w	r3, r3, #262144	@ 0x40000
240096aa:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
240096ac:	f008 fbac 	bl	24011e08 <HAL_GetTick>
240096b0:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U)
240096b2:	682b      	ldr	r3, [r5, #0]
240096b4:	039f      	lsls	r7, r3, #14
240096b6:	f57f af68 	bpl.w	2400958a <HAL_RCC_OscConfig+0xe>
          if((uint32_t) (HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
240096ba:	f008 fba5 	bl	24011e08 <HAL_GetTick>
240096be:	1b80      	subs	r0, r0, r6
240096c0:	2864      	cmp	r0, #100	@ 0x64
240096c2:	d9f6      	bls.n	240096b2 <HAL_RCC_OscConfig+0x136>
240096c4:	e7e7      	b.n	24009696 <HAL_RCC_OscConfig+0x11a>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
240096c6:	f5b3 2fa0 	cmp.w	r3, #327680	@ 0x50000
240096ca:	682b      	ldr	r3, [r5, #0]
240096cc:	d103      	bne.n	240096d6 <HAL_RCC_OscConfig+0x15a>
240096ce:	f443 2380 	orr.w	r3, r3, #262144	@ 0x40000
240096d2:	602b      	str	r3, [r5, #0]
240096d4:	e7ce      	b.n	24009674 <HAL_RCC_OscConfig+0xf8>
240096d6:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
240096da:	602b      	str	r3, [r5, #0]
240096dc:	682b      	ldr	r3, [r5, #0]
240096de:	f423 2380 	bic.w	r3, r3, #262144	@ 0x40000
240096e2:	e7ca      	b.n	2400967a <HAL_RCC_OscConfig+0xfe>
    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
240096e4:	4a4c      	ldr	r2, [pc, #304]	@ (24009818 <HAL_RCC_OscConfig+0x29c>)
240096e6:	6913      	ldr	r3, [r2, #16]
    const uint32_t temp_pllckselr = RCC->PLLCKSELR;
240096e8:	6a91      	ldr	r1, [r2, #40]	@ 0x28
    if((temp_sysclksrc == RCC_CFGR_SWS_HSI) || ((temp_sysclksrc == RCC_CFGR_SWS_PLL1) && ((temp_pllckselr & RCC_PLLCKSELR_PLLSRC) == RCC_PLLCKSELR_PLLSRC_HSI)))
240096ea:	f013 0338 	ands.w	r3, r3, #56	@ 0x38
240096ee:	d003      	beq.n	240096f8 <HAL_RCC_OscConfig+0x17c>
240096f0:	2b18      	cmp	r3, #24
240096f2:	d11a      	bne.n	2400972a <HAL_RCC_OscConfig+0x1ae>
240096f4:	078e      	lsls	r6, r1, #30
240096f6:	d118      	bne.n	2400972a <HAL_RCC_OscConfig+0x1ae>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
240096f8:	6813      	ldr	r3, [r2, #0]
240096fa:	075d      	lsls	r5, r3, #29
240096fc:	d502      	bpl.n	24009704 <HAL_RCC_OscConfig+0x188>
240096fe:	68e3      	ldr	r3, [r4, #12]
24009700:	2b00      	cmp	r3, #0
24009702:	d0b0      	beq.n	24009666 <HAL_RCC_OscConfig+0xea>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
24009704:	f7f7 f959 	bl	240009ba <HAL_GetREVID>
24009708:	f241 0303 	movw	r3, #4099	@ 0x1003
2400970c:	4a42      	ldr	r2, [pc, #264]	@ (24009818 <HAL_RCC_OscConfig+0x29c>)
2400970e:	4298      	cmp	r0, r3
24009710:	6921      	ldr	r1, [r4, #16]
24009712:	6853      	ldr	r3, [r2, #4]
24009714:	bf95      	itete	ls
24009716:	f423 337c 	bicls.w	r3, r3, #258048	@ 0x3f000
2400971a:	f023 43fe 	bichi.w	r3, r3, #2130706432	@ 0x7f000000
2400971e:	ea43 3301 	orrls.w	r3, r3, r1, lsl #12
24009722:	ea43 6301 	orrhi.w	r3, r3, r1, lsl #24
24009726:	6053      	str	r3, [r2, #4]
24009728:	e733      	b.n	24009592 <HAL_RCC_OscConfig+0x16>
      if((RCC_OscInitStruct->HSIState)!= RCC_HSI_OFF)
2400972a:	4d3b      	ldr	r5, [pc, #236]	@ (24009818 <HAL_RCC_OscConfig+0x29c>)
2400972c:	68e2      	ldr	r2, [r4, #12]
        __HAL_RCC_HSI_CONFIG(RCC_OscInitStruct->HSIState);
2400972e:	682b      	ldr	r3, [r5, #0]
      if((RCC_OscInitStruct->HSIState)!= RCC_HSI_OFF)
24009730:	b30a      	cbz	r2, 24009776 <HAL_RCC_OscConfig+0x1fa>
        __HAL_RCC_HSI_CONFIG(RCC_OscInitStruct->HSIState);
24009732:	f023 0319 	bic.w	r3, r3, #25
24009736:	4313      	orrs	r3, r2
24009738:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
2400973a:	f008 fb65 	bl	24011e08 <HAL_GetTick>
2400973e:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
24009740:	682b      	ldr	r3, [r5, #0]
24009742:	0758      	lsls	r0, r3, #29
24009744:	d511      	bpl.n	2400976a <HAL_RCC_OscConfig+0x1ee>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
24009746:	f7f7 f938 	bl	240009ba <HAL_GetREVID>
2400974a:	f241 0303 	movw	r3, #4099	@ 0x1003
2400974e:	6922      	ldr	r2, [r4, #16]
24009750:	4298      	cmp	r0, r3
24009752:	686b      	ldr	r3, [r5, #4]
24009754:	bf95      	itete	ls
24009756:	f423 337c 	bicls.w	r3, r3, #258048	@ 0x3f000
2400975a:	f023 43fe 	bichi.w	r3, r3, #2130706432	@ 0x7f000000
2400975e:	ea43 3302 	orrls.w	r3, r3, r2, lsl #12
24009762:	ea43 6302 	orrhi.w	r3, r3, r2, lsl #24
24009766:	606b      	str	r3, [r5, #4]
24009768:	e713      	b.n	24009592 <HAL_RCC_OscConfig+0x16>
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
2400976a:	f008 fb4d 	bl	24011e08 <HAL_GetTick>
2400976e:	1b80      	subs	r0, r0, r6
24009770:	2802      	cmp	r0, #2
24009772:	d9e5      	bls.n	24009740 <HAL_RCC_OscConfig+0x1c4>
24009774:	e78f      	b.n	24009696 <HAL_RCC_OscConfig+0x11a>
        __HAL_RCC_HSI_DISABLE();
24009776:	f023 0301 	bic.w	r3, r3, #1
2400977a:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
2400977c:	f008 fb44 	bl	24011e08 <HAL_GetTick>
24009780:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U)
24009782:	682b      	ldr	r3, [r5, #0]
24009784:	0759      	lsls	r1, r3, #29
24009786:	f57f af04 	bpl.w	24009592 <HAL_RCC_OscConfig+0x16>
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
2400978a:	f008 fb3d 	bl	24011e08 <HAL_GetTick>
2400978e:	1b80      	subs	r0, r0, r6
24009790:	2802      	cmp	r0, #2
24009792:	d9f6      	bls.n	24009782 <HAL_RCC_OscConfig+0x206>
24009794:	e77f      	b.n	24009696 <HAL_RCC_OscConfig+0x11a>
        __HAL_RCC_CSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->CSICalibrationValue);
24009796:	68d3      	ldr	r3, [r2, #12]
24009798:	f023 537c 	bic.w	r3, r3, #1056964608	@ 0x3f000000
2400979c:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
240097a0:	60d3      	str	r3, [r2, #12]
240097a2:	e71d      	b.n	240095e0 <HAL_RCC_OscConfig+0x64>
      if((RCC_OscInitStruct->CSIState)!= RCC_CSI_OFF)
240097a4:	69e3      	ldr	r3, [r4, #28]
240097a6:	4d1c      	ldr	r5, [pc, #112]	@ (24009818 <HAL_RCC_OscConfig+0x29c>)
240097a8:	b323      	cbz	r3, 240097f4 <HAL_RCC_OscConfig+0x278>
        __HAL_RCC_CSI_ENABLE();
240097aa:	682b      	ldr	r3, [r5, #0]
240097ac:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
240097b0:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
240097b2:	f008 fb29 	bl	24011e08 <HAL_GetTick>
240097b6:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) == 0U)
240097b8:	682b      	ldr	r3, [r5, #0]
240097ba:	05df      	lsls	r7, r3, #23
240097bc:	d50d      	bpl.n	240097da <HAL_RCC_OscConfig+0x25e>
        __HAL_RCC_CSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->CSICalibrationValue);
240097be:	f7f7 f8fc 	bl	240009ba <HAL_GetREVID>
240097c2:	f241 0303 	movw	r3, #4099	@ 0x1003
240097c6:	6a22      	ldr	r2, [r4, #32]
240097c8:	4298      	cmp	r0, r3
240097ca:	d80c      	bhi.n	240097e6 <HAL_RCC_OscConfig+0x26a>
240097cc:	686b      	ldr	r3, [r5, #4]
240097ce:	f023 43f8 	bic.w	r3, r3, #2080374784	@ 0x7c000000
240097d2:	ea43 6382 	orr.w	r3, r3, r2, lsl #26
240097d6:	606b      	str	r3, [r5, #4]
240097d8:	e702      	b.n	240095e0 <HAL_RCC_OscConfig+0x64>
          if((HAL_GetTick() - tickstart ) > CSI_TIMEOUT_VALUE)
240097da:	f008 fb15 	bl	24011e08 <HAL_GetTick>
240097de:	1b80      	subs	r0, r0, r6
240097e0:	2802      	cmp	r0, #2
240097e2:	d9e9      	bls.n	240097b8 <HAL_RCC_OscConfig+0x23c>
240097e4:	e757      	b.n	24009696 <HAL_RCC_OscConfig+0x11a>
        __HAL_RCC_CSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->CSICalibrationValue);
240097e6:	68eb      	ldr	r3, [r5, #12]
240097e8:	f023 537c 	bic.w	r3, r3, #1056964608	@ 0x3f000000
240097ec:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
240097f0:	60eb      	str	r3, [r5, #12]
240097f2:	e6f5      	b.n	240095e0 <HAL_RCC_OscConfig+0x64>
        __HAL_RCC_CSI_DISABLE();
240097f4:	682b      	ldr	r3, [r5, #0]
240097f6:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
240097fa:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
240097fc:	f008 fb04 	bl	24011e08 <HAL_GetTick>
24009800:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) != 0U)
24009802:	682b      	ldr	r3, [r5, #0]
24009804:	05d8      	lsls	r0, r3, #23
24009806:	f57f aeeb 	bpl.w	240095e0 <HAL_RCC_OscConfig+0x64>
          if((HAL_GetTick() - tickstart ) > CSI_TIMEOUT_VALUE)
2400980a:	f008 fafd 	bl	24011e08 <HAL_GetTick>
2400980e:	1b80      	subs	r0, r0, r6
24009810:	2802      	cmp	r0, #2
24009812:	d9f6      	bls.n	24009802 <HAL_RCC_OscConfig+0x286>
24009814:	e73f      	b.n	24009696 <HAL_RCC_OscConfig+0x11a>
24009816:	bf00      	nop
24009818:	58024400 	.word	0x58024400
2400981c:	58024800 	.word	0x58024800
    if((RCC_OscInitStruct->LSIState)!= RCC_LSI_OFF)
24009820:	6963      	ldr	r3, [r4, #20]
24009822:	4d96      	ldr	r5, [pc, #600]	@ (24009a7c <HAL_RCC_OscConfig+0x500>)
24009824:	b183      	cbz	r3, 24009848 <HAL_RCC_OscConfig+0x2cc>
      __HAL_RCC_LSI_ENABLE();
24009826:	6f6b      	ldr	r3, [r5, #116]	@ 0x74
24009828:	f043 0301 	orr.w	r3, r3, #1
2400982c:	676b      	str	r3, [r5, #116]	@ 0x74
      tickstart = HAL_GetTick();
2400982e:	f008 faeb 	bl	24011e08 <HAL_GetTick>
24009832:	4606      	mov	r6, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == 0U)
24009834:	6f6b      	ldr	r3, [r5, #116]	@ 0x74
24009836:	079b      	lsls	r3, r3, #30
24009838:	f53f aed6 	bmi.w	240095e8 <HAL_RCC_OscConfig+0x6c>
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
2400983c:	f008 fae4 	bl	24011e08 <HAL_GetTick>
24009840:	1b80      	subs	r0, r0, r6
24009842:	2802      	cmp	r0, #2
24009844:	d9f6      	bls.n	24009834 <HAL_RCC_OscConfig+0x2b8>
24009846:	e726      	b.n	24009696 <HAL_RCC_OscConfig+0x11a>
      __HAL_RCC_LSI_DISABLE();
24009848:	6f6b      	ldr	r3, [r5, #116]	@ 0x74
2400984a:	f023 0301 	bic.w	r3, r3, #1
2400984e:	676b      	str	r3, [r5, #116]	@ 0x74
      tickstart = HAL_GetTick();
24009850:	f008 fada 	bl	24011e08 <HAL_GetTick>
24009854:	4606      	mov	r6, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != 0U)
24009856:	6f6b      	ldr	r3, [r5, #116]	@ 0x74
24009858:	079f      	lsls	r7, r3, #30
2400985a:	f57f aec5 	bpl.w	240095e8 <HAL_RCC_OscConfig+0x6c>
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
2400985e:	f008 fad3 	bl	24011e08 <HAL_GetTick>
24009862:	1b80      	subs	r0, r0, r6
24009864:	2802      	cmp	r0, #2
24009866:	d9f6      	bls.n	24009856 <HAL_RCC_OscConfig+0x2da>
24009868:	e715      	b.n	24009696 <HAL_RCC_OscConfig+0x11a>
    if((RCC_OscInitStruct->HSI48State)!= RCC_HSI48_OFF)
2400986a:	69a3      	ldr	r3, [r4, #24]
2400986c:	4d83      	ldr	r5, [pc, #524]	@ (24009a7c <HAL_RCC_OscConfig+0x500>)
2400986e:	b183      	cbz	r3, 24009892 <HAL_RCC_OscConfig+0x316>
      __HAL_RCC_HSI48_ENABLE();
24009870:	682b      	ldr	r3, [r5, #0]
24009872:	f443 5380 	orr.w	r3, r3, #4096	@ 0x1000
24009876:	602b      	str	r3, [r5, #0]
      tickstart = HAL_GetTick();
24009878:	f008 fac6 	bl	24011e08 <HAL_GetTick>
2400987c:	4606      	mov	r6, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) == 0U)
2400987e:	682b      	ldr	r3, [r5, #0]
24009880:	0498      	lsls	r0, r3, #18
24009882:	f53f aeb5 	bmi.w	240095f0 <HAL_RCC_OscConfig+0x74>
        if((HAL_GetTick() - tickstart ) > HSI48_TIMEOUT_VALUE)
24009886:	f008 fabf 	bl	24011e08 <HAL_GetTick>
2400988a:	1b80      	subs	r0, r0, r6
2400988c:	2802      	cmp	r0, #2
2400988e:	d9f6      	bls.n	2400987e <HAL_RCC_OscConfig+0x302>
24009890:	e701      	b.n	24009696 <HAL_RCC_OscConfig+0x11a>
      __HAL_RCC_HSI48_DISABLE();
24009892:	682b      	ldr	r3, [r5, #0]
24009894:	f423 5380 	bic.w	r3, r3, #4096	@ 0x1000
24009898:	602b      	str	r3, [r5, #0]
      tickstart = HAL_GetTick();
2400989a:	f008 fab5 	bl	24011e08 <HAL_GetTick>
2400989e:	4606      	mov	r6, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) != 0U)
240098a0:	682b      	ldr	r3, [r5, #0]
240098a2:	0499      	lsls	r1, r3, #18
240098a4:	f57f aea4 	bpl.w	240095f0 <HAL_RCC_OscConfig+0x74>
        if((HAL_GetTick() - tickstart ) > HSI48_TIMEOUT_VALUE)
240098a8:	f008 faae 	bl	24011e08 <HAL_GetTick>
240098ac:	1b80      	subs	r0, r0, r6
240098ae:	2802      	cmp	r0, #2
240098b0:	d9f6      	bls.n	240098a0 <HAL_RCC_OscConfig+0x324>
240098b2:	e6f0      	b.n	24009696 <HAL_RCC_OscConfig+0x11a>
      if((HAL_GetTick() - tickstart ) > RCC_DBP_TIMEOUT_VALUE)
240098b4:	f008 faa8 	bl	24011e08 <HAL_GetTick>
240098b8:	1b80      	subs	r0, r0, r6
240098ba:	2864      	cmp	r0, #100	@ 0x64
240098bc:	f67f aea3 	bls.w	24009606 <HAL_RCC_OscConfig+0x8a>
240098c0:	e6e9      	b.n	24009696 <HAL_RCC_OscConfig+0x11a>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
240098c2:	b9b3      	cbnz	r3, 240098f2 <HAL_RCC_OscConfig+0x376>
240098c4:	6f2b      	ldr	r3, [r5, #112]	@ 0x70
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
240098c6:	f241 3788 	movw	r7, #5000	@ 0x1388
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
240098ca:	f023 0301 	bic.w	r3, r3, #1
240098ce:	672b      	str	r3, [r5, #112]	@ 0x70
240098d0:	6f2b      	ldr	r3, [r5, #112]	@ 0x70
240098d2:	f023 0304 	bic.w	r3, r3, #4
240098d6:	672b      	str	r3, [r5, #112]	@ 0x70
      tickstart = HAL_GetTick();
240098d8:	f008 fa96 	bl	24011e08 <HAL_GetTick>
240098dc:	4606      	mov	r6, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != 0U)
240098de:	6f2b      	ldr	r3, [r5, #112]	@ 0x70
240098e0:	0798      	lsls	r0, r3, #30
240098e2:	f57f aea7 	bpl.w	24009634 <HAL_RCC_OscConfig+0xb8>
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
240098e6:	f008 fa8f 	bl	24011e08 <HAL_GetTick>
240098ea:	1b80      	subs	r0, r0, r6
240098ec:	42b8      	cmp	r0, r7
240098ee:	d9f6      	bls.n	240098de <HAL_RCC_OscConfig+0x362>
240098f0:	e6d1      	b.n	24009696 <HAL_RCC_OscConfig+0x11a>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
240098f2:	2b05      	cmp	r3, #5
240098f4:	6f2b      	ldr	r3, [r5, #112]	@ 0x70
240098f6:	d103      	bne.n	24009900 <HAL_RCC_OscConfig+0x384>
240098f8:	f043 0304 	orr.w	r3, r3, #4
240098fc:	672b      	str	r3, [r5, #112]	@ 0x70
240098fe:	e68b      	b.n	24009618 <HAL_RCC_OscConfig+0x9c>
24009900:	f023 0301 	bic.w	r3, r3, #1
24009904:	672b      	str	r3, [r5, #112]	@ 0x70
24009906:	6f2b      	ldr	r3, [r5, #112]	@ 0x70
24009908:	f023 0304 	bic.w	r3, r3, #4
2400990c:	e687      	b.n	2400961e <HAL_RCC_OscConfig+0xa2>
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
2400990e:	f008 fa7b 	bl	24011e08 <HAL_GetTick>
24009912:	1b40      	subs	r0, r0, r5
24009914:	42b8      	cmp	r0, r7
24009916:	f67f ae89 	bls.w	2400962c <HAL_RCC_OscConfig+0xb0>
2400991a:	e6bc      	b.n	24009696 <HAL_RCC_OscConfig+0x11a>
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL1)
2400991c:	4d57      	ldr	r5, [pc, #348]	@ (24009a7c <HAL_RCC_OscConfig+0x500>)
2400991e:	692b      	ldr	r3, [r5, #16]
24009920:	f003 0338 	and.w	r3, r3, #56	@ 0x38
24009924:	2b18      	cmp	r3, #24
24009926:	d07a      	beq.n	24009a1e <HAL_RCC_OscConfig+0x4a2>
        __HAL_RCC_PLL_DISABLE();
24009928:	682b      	ldr	r3, [r5, #0]
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
2400992a:	2a02      	cmp	r2, #2
        __HAL_RCC_PLL_DISABLE();
2400992c:	f023 7380 	bic.w	r3, r3, #16777216	@ 0x1000000
24009930:	602b      	str	r3, [r5, #0]
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
24009932:	d167      	bne.n	24009a04 <HAL_RCC_OscConfig+0x488>
        tickstart = HAL_GetTick();
24009934:	f008 fa68 	bl	24011e08 <HAL_GetTick>
24009938:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != 0U)
2400993a:	682b      	ldr	r3, [r5, #0]
2400993c:	0199      	lsls	r1, r3, #6
2400993e:	d45b      	bmi.n	240099f8 <HAL_RCC_OscConfig+0x47c>
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
24009940:	6aab      	ldr	r3, [r5, #40]	@ 0x28
24009942:	6aa2      	ldr	r2, [r4, #40]	@ 0x28
24009944:	f423 737c 	bic.w	r3, r3, #1008	@ 0x3f0
24009948:	f023 0303 	bic.w	r3, r3, #3
2400994c:	4313      	orrs	r3, r2
2400994e:	6ae2      	ldr	r2, [r4, #44]	@ 0x2c
24009950:	ea43 1302 	orr.w	r3, r3, r2, lsl #4
24009954:	62ab      	str	r3, [r5, #40]	@ 0x28
24009956:	6b63      	ldr	r3, [r4, #52]	@ 0x34
24009958:	6ba2      	ldr	r2, [r4, #56]	@ 0x38
2400995a:	3b01      	subs	r3, #1
2400995c:	3a01      	subs	r2, #1
2400995e:	025b      	lsls	r3, r3, #9
24009960:	0412      	lsls	r2, r2, #16
24009962:	b29b      	uxth	r3, r3
24009964:	f402 02fe 	and.w	r2, r2, #8323072	@ 0x7f0000
24009968:	4313      	orrs	r3, r2
2400996a:	6b22      	ldr	r2, [r4, #48]	@ 0x30
2400996c:	3a01      	subs	r2, #1
2400996e:	f3c2 0208 	ubfx	r2, r2, #0, #9
24009972:	4313      	orrs	r3, r2
24009974:	6be2      	ldr	r2, [r4, #60]	@ 0x3c
24009976:	3a01      	subs	r2, #1
24009978:	0612      	lsls	r2, r2, #24
2400997a:	f002 42fe 	and.w	r2, r2, #2130706432	@ 0x7f000000
2400997e:	4313      	orrs	r3, r2
24009980:	632b      	str	r3, [r5, #48]	@ 0x30
         __HAL_RCC_PLLFRACN_DISABLE();
24009982:	6aeb      	ldr	r3, [r5, #44]	@ 0x2c
24009984:	f023 0301 	bic.w	r3, r3, #1
24009988:	62eb      	str	r3, [r5, #44]	@ 0x2c
         __HAL_RCC_PLLFRACN_CONFIG(RCC_OscInitStruct->PLL.PLLFRACN);
2400998a:	6b6b      	ldr	r3, [r5, #52]	@ 0x34
2400998c:	6ca2      	ldr	r2, [r4, #72]	@ 0x48
2400998e:	f423 437f 	bic.w	r3, r3, #65280	@ 0xff00
24009992:	f023 03f8 	bic.w	r3, r3, #248	@ 0xf8
24009996:	ea43 03c2 	orr.w	r3, r3, r2, lsl #3
2400999a:	636b      	str	r3, [r5, #52]	@ 0x34
        __HAL_RCC_PLL_VCIRANGE(RCC_OscInitStruct->PLL.PLLRGE) ;
2400999c:	6aeb      	ldr	r3, [r5, #44]	@ 0x2c
2400999e:	6c22      	ldr	r2, [r4, #64]	@ 0x40
240099a0:	f023 030c 	bic.w	r3, r3, #12
240099a4:	4313      	orrs	r3, r2
240099a6:	62eb      	str	r3, [r5, #44]	@ 0x2c
        __HAL_RCC_PLL_VCORANGE(RCC_OscInitStruct->PLL.PLLVCOSEL) ;
240099a8:	6aeb      	ldr	r3, [r5, #44]	@ 0x2c
240099aa:	6c62      	ldr	r2, [r4, #68]	@ 0x44
240099ac:	f023 0302 	bic.w	r3, r3, #2
240099b0:	4313      	orrs	r3, r2
240099b2:	62eb      	str	r3, [r5, #44]	@ 0x2c
         __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVP);
240099b4:	6aeb      	ldr	r3, [r5, #44]	@ 0x2c
240099b6:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
240099ba:	62eb      	str	r3, [r5, #44]	@ 0x2c
         __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
240099bc:	6aeb      	ldr	r3, [r5, #44]	@ 0x2c
240099be:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
240099c2:	62eb      	str	r3, [r5, #44]	@ 0x2c
         __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVR);
240099c4:	6aeb      	ldr	r3, [r5, #44]	@ 0x2c
240099c6:	f443 2380 	orr.w	r3, r3, #262144	@ 0x40000
240099ca:	62eb      	str	r3, [r5, #44]	@ 0x2c
         __HAL_RCC_PLLFRACN_ENABLE();
240099cc:	6aeb      	ldr	r3, [r5, #44]	@ 0x2c
240099ce:	f043 0301 	orr.w	r3, r3, #1
240099d2:	62eb      	str	r3, [r5, #44]	@ 0x2c
        __HAL_RCC_PLL_ENABLE();
240099d4:	682b      	ldr	r3, [r5, #0]
240099d6:	f043 7380 	orr.w	r3, r3, #16777216	@ 0x1000000
240099da:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
240099dc:	f008 fa14 	bl	24011e08 <HAL_GetTick>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == 0U)
240099e0:	4d26      	ldr	r5, [pc, #152]	@ (24009a7c <HAL_RCC_OscConfig+0x500>)
        tickstart = HAL_GetTick();
240099e2:	4604      	mov	r4, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == 0U)
240099e4:	682b      	ldr	r3, [r5, #0]
240099e6:	019a      	lsls	r2, r3, #6
240099e8:	f53f ae28 	bmi.w	2400963c <HAL_RCC_OscConfig+0xc0>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
240099ec:	f008 fa0c 	bl	24011e08 <HAL_GetTick>
240099f0:	1b00      	subs	r0, r0, r4
240099f2:	2802      	cmp	r0, #2
240099f4:	d9f6      	bls.n	240099e4 <HAL_RCC_OscConfig+0x468>
240099f6:	e64e      	b.n	24009696 <HAL_RCC_OscConfig+0x11a>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
240099f8:	f008 fa06 	bl	24011e08 <HAL_GetTick>
240099fc:	1b80      	subs	r0, r0, r6
240099fe:	2802      	cmp	r0, #2
24009a00:	d99b      	bls.n	2400993a <HAL_RCC_OscConfig+0x3be>
24009a02:	e648      	b.n	24009696 <HAL_RCC_OscConfig+0x11a>
        tickstart = HAL_GetTick();
24009a04:	f008 fa00 	bl	24011e08 <HAL_GetTick>
24009a08:	4604      	mov	r4, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != 0U)
24009a0a:	682b      	ldr	r3, [r5, #0]
24009a0c:	019b      	lsls	r3, r3, #6
24009a0e:	f57f ae15 	bpl.w	2400963c <HAL_RCC_OscConfig+0xc0>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
24009a12:	f008 f9f9 	bl	24011e08 <HAL_GetTick>
24009a16:	1b00      	subs	r0, r0, r4
24009a18:	2802      	cmp	r0, #2
24009a1a:	d9f6      	bls.n	24009a0a <HAL_RCC_OscConfig+0x48e>
24009a1c:	e63b      	b.n	24009696 <HAL_RCC_OscConfig+0x11a>
      if(((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
24009a1e:	2a01      	cmp	r2, #1
      temp1_pllckcfg = RCC->PLLCKSELR;
24009a20:	6aab      	ldr	r3, [r5, #40]	@ 0x28
      temp2_pllckcfg = RCC->PLL1DIVR;
24009a22:	6b28      	ldr	r0, [r5, #48]	@ 0x30
      if(((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
24009a24:	f43f ae1f 	beq.w	24009666 <HAL_RCC_OscConfig+0xea>
	 (READ_BIT(temp1_pllckcfg, RCC_PLLCKSELR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
24009a28:	f003 0203 	and.w	r2, r3, #3
      if(((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
24009a2c:	6aa1      	ldr	r1, [r4, #40]	@ 0x28
24009a2e:	428a      	cmp	r2, r1
24009a30:	f47f ae19 	bne.w	24009666 <HAL_RCC_OscConfig+0xea>
         ((READ_BIT(temp1_pllckcfg, RCC_PLLCKSELR_DIVM1) >> RCC_PLLCKSELR_DIVM1_Pos) != RCC_OscInitStruct->PLL.PLLM) ||
24009a34:	f3c3 1305 	ubfx	r3, r3, #4, #6
	 (READ_BIT(temp1_pllckcfg, RCC_PLLCKSELR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
24009a38:	6ae2      	ldr	r2, [r4, #44]	@ 0x2c
24009a3a:	4293      	cmp	r3, r2
24009a3c:	f47f ae13 	bne.w	24009666 <HAL_RCC_OscConfig+0xea>
         (READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_N1) != (RCC_OscInitStruct->PLL.PLLN - 1U)) ||
24009a40:	6b23      	ldr	r3, [r4, #48]	@ 0x30
24009a42:	f3c0 0208 	ubfx	r2, r0, #0, #9
24009a46:	3b01      	subs	r3, #1
         ((READ_BIT(temp1_pllckcfg, RCC_PLLCKSELR_DIVM1) >> RCC_PLLCKSELR_DIVM1_Pos) != RCC_OscInitStruct->PLL.PLLM) ||
24009a48:	429a      	cmp	r2, r3
24009a4a:	f47f ae0c 	bne.w	24009666 <HAL_RCC_OscConfig+0xea>
         ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_P1) >> RCC_PLL1DIVR_P1_Pos) != (RCC_OscInitStruct->PLL.PLLP - 1U)) ||
24009a4e:	6b63      	ldr	r3, [r4, #52]	@ 0x34
24009a50:	f3c0 2246 	ubfx	r2, r0, #9, #7
24009a54:	3b01      	subs	r3, #1
         (READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_N1) != (RCC_OscInitStruct->PLL.PLLN - 1U)) ||
24009a56:	429a      	cmp	r2, r3
24009a58:	f47f ae05 	bne.w	24009666 <HAL_RCC_OscConfig+0xea>
         ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_Q1) >> RCC_PLL1DIVR_Q1_Pos) != (RCC_OscInitStruct->PLL.PLLQ - 1U)) ||
24009a5c:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
24009a5e:	f3c0 4206 	ubfx	r2, r0, #16, #7
24009a62:	3b01      	subs	r3, #1
         ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_P1) >> RCC_PLL1DIVR_P1_Pos) != (RCC_OscInitStruct->PLL.PLLP - 1U)) ||
24009a64:	429a      	cmp	r2, r3
24009a66:	f47f adfe 	bne.w	24009666 <HAL_RCC_OscConfig+0xea>
         ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_R1) >> RCC_PLL1DIVR_R1_Pos) != (RCC_OscInitStruct->PLL.PLLR - 1U)))
24009a6a:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
24009a6c:	f3c0 6006 	ubfx	r0, r0, #24, #7
24009a70:	3b01      	subs	r3, #1
         ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_Q1) >> RCC_PLL1DIVR_Q1_Pos) != (RCC_OscInitStruct->PLL.PLLQ - 1U)) ||
24009a72:	1ac0      	subs	r0, r0, r3
24009a74:	bf18      	it	ne
24009a76:	2001      	movne	r0, #1
24009a78:	e60e      	b.n	24009698 <HAL_RCC_OscConfig+0x11c>
24009a7a:	bf00      	nop
24009a7c:	58024400 	.word	0x58024400

24009a80 <HAL_RCC_MCOConfig>:
  *          This parameter can be one of the following values:
  *            @arg RCC_MCODIV_1 up to RCC_MCODIV_15  : divider applied to MCOx clock
  * @retval None
  */
void HAL_RCC_MCOConfig(uint32_t RCC_MCOx, uint32_t RCC_MCOSource, uint32_t RCC_MCODiv)
{
24009a80:	b570      	push	{r4, r5, r6, lr}
24009a82:	4c23      	ldr	r4, [pc, #140]	@ (24009b10 <HAL_RCC_MCOConfig+0x90>)
24009a84:	b088      	sub	sp, #32
24009a86:	460e      	mov	r6, r1
24009a88:	4615      	mov	r5, r2
  if(RCC_MCOx == RCC_MCO1)
  {
    assert_param(IS_RCC_MCO1SOURCE(RCC_MCOSource));

    /* MCO1 Clock Enable */
    MCO1_CLK_ENABLE();
24009a8a:	f8d4 30e0 	ldr.w	r3, [r4, #224]	@ 0xe0
  if(RCC_MCOx == RCC_MCO1)
24009a8e:	b9f8      	cbnz	r0, 24009ad0 <HAL_RCC_MCOConfig+0x50>
    MCO1_CLK_ENABLE();
24009a90:	f043 0301 	orr.w	r3, r3, #1

    /* Configure the MCO1 pin in alternate function mode */
    GPIO_InitStruct.Pin = MCO1_PIN;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
24009a94:	f44f 7c80 	mov.w	ip, #256	@ 0x100
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Alternate = GPIO_AF0_MCO;
    HAL_GPIO_Init(MCO1_GPIO_PORT, &GPIO_InitStruct);
24009a98:	a903      	add	r1, sp, #12
    MCO1_CLK_ENABLE();
24009a9a:	f8c4 30e0 	str.w	r3, [r4, #224]	@ 0xe0
24009a9e:	f8d4 30e0 	ldr.w	r3, [r4, #224]	@ 0xe0
    GPIO_InitStruct.Alternate = GPIO_AF0_MCO;
24009aa2:	9007      	str	r0, [sp, #28]
    MCO1_CLK_ENABLE();
24009aa4:	f003 0301 	and.w	r3, r3, #1
24009aa8:	9301      	str	r3, [sp, #4]
24009aaa:	9b01      	ldr	r3, [sp, #4]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
24009aac:	2302      	movs	r3, #2
24009aae:	e9cd c303 	strd	ip, r3, [sp, #12]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
24009ab2:	2303      	movs	r3, #3
    GPIO_InitStruct.Pull = GPIO_NOPULL;
24009ab4:	e9cd 0305 	strd	r0, r3, [sp, #20]
    HAL_GPIO_Init(MCO1_GPIO_PORT, &GPIO_InitStruct);
24009ab8:	4816      	ldr	r0, [pc, #88]	@ (24009b14 <HAL_RCC_MCOConfig+0x94>)
24009aba:	f7fa fbed 	bl	24004298 <HAL_GPIO_Init>

    /* Mask MCO1 and MCO1PRE[3:0] bits then Select MCO1 clock source and pre-scaler */
    MODIFY_REG(RCC->CFGR, (RCC_CFGR_MCO1 | RCC_CFGR_MCO1PRE), (RCC_MCOSource | RCC_MCODiv));
24009abe:	6923      	ldr	r3, [r4, #16]
24009ac0:	f023 73fe 	bic.w	r3, r3, #33292288	@ 0x1fc0000
24009ac4:	ea43 0106 	orr.w	r1, r3, r6
24009ac8:	4329      	orrs	r1, r5
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Alternate = GPIO_AF0_MCO;
    HAL_GPIO_Init(MCO2_GPIO_PORT, &GPIO_InitStruct);

    /* Mask MCO2 and MCO2PRE[3:0] bits then Select MCO2 clock source and pre-scaler */
    MODIFY_REG(RCC->CFGR, (RCC_CFGR_MCO2 | RCC_CFGR_MCO2PRE), (RCC_MCOSource | (RCC_MCODiv << 7U)));
24009aca:	6121      	str	r1, [r4, #16]
  }
}
24009acc:	b008      	add	sp, #32
24009ace:	bd70      	pop	{r4, r5, r6, pc}
    MCO2_CLK_ENABLE();
24009ad0:	f043 0304 	orr.w	r3, r3, #4
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
24009ad4:	f44f 7200 	mov.w	r2, #512	@ 0x200
    GPIO_InitStruct.Pull = GPIO_NOPULL;
24009ad8:	2103      	movs	r1, #3
    HAL_GPIO_Init(MCO2_GPIO_PORT, &GPIO_InitStruct);
24009ada:	480f      	ldr	r0, [pc, #60]	@ (24009b18 <HAL_RCC_MCOConfig+0x98>)
    MCO2_CLK_ENABLE();
24009adc:	f8c4 30e0 	str.w	r3, [r4, #224]	@ 0xe0
24009ae0:	f8d4 30e0 	ldr.w	r3, [r4, #224]	@ 0xe0
24009ae4:	f003 0304 	and.w	r3, r3, #4
24009ae8:	9302      	str	r3, [sp, #8]
24009aea:	9b02      	ldr	r3, [sp, #8]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
24009aec:	2302      	movs	r3, #2
24009aee:	e9cd 2303 	strd	r2, r3, [sp, #12]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
24009af2:	2300      	movs	r3, #0
24009af4:	e9cd 3105 	strd	r3, r1, [sp, #20]
    HAL_GPIO_Init(MCO2_GPIO_PORT, &GPIO_InitStruct);
24009af8:	a903      	add	r1, sp, #12
    GPIO_InitStruct.Alternate = GPIO_AF0_MCO;
24009afa:	9307      	str	r3, [sp, #28]
    HAL_GPIO_Init(MCO2_GPIO_PORT, &GPIO_InitStruct);
24009afc:	f7fa fbcc 	bl	24004298 <HAL_GPIO_Init>
    MODIFY_REG(RCC->CFGR, (RCC_CFGR_MCO2 | RCC_CFGR_MCO2PRE), (RCC_MCOSource | (RCC_MCODiv << 7U)));
24009b00:	6923      	ldr	r3, [r4, #16]
24009b02:	f023 437e 	bic.w	r3, r3, #4261412864	@ 0xfe000000
24009b06:	ea43 0106 	orr.w	r1, r3, r6
24009b0a:	ea41 11c5 	orr.w	r1, r1, r5, lsl #7
24009b0e:	e7dc      	b.n	24009aca <HAL_RCC_MCOConfig+0x4a>
24009b10:	58024400 	.word	0x58024400
24009b14:	58020000 	.word	0x58020000
24009b18:	58020800 	.word	0x58020800

24009b1c <HAL_RCC_EnableCSS>:
  *         the Cortex-M NMI (Non-Mask-able Interrupt) exception vector.
  * @retval None
  */
void HAL_RCC_EnableCSS(void)
{
  SET_BIT(RCC->CR, RCC_CR_CSSHSEON) ;
24009b1c:	4a02      	ldr	r2, [pc, #8]	@ (24009b28 <HAL_RCC_EnableCSS+0xc>)
24009b1e:	6813      	ldr	r3, [r2, #0]
24009b20:	f443 2300 	orr.w	r3, r3, #524288	@ 0x80000
24009b24:	6013      	str	r3, [r2, #0]
}
24009b26:	4770      	bx	lr
24009b28:	58024400 	.word	0x58024400

24009b2c <HAL_RCC_DisableCSS>:
  * @brief  Disables the Clock Security System.
  * @retval None
  */
void HAL_RCC_DisableCSS(void)
{
  CLEAR_BIT(RCC->CR, RCC_CR_CSSHSEON);
24009b2c:	4a02      	ldr	r2, [pc, #8]	@ (24009b38 <HAL_RCC_DisableCSS+0xc>)
24009b2e:	6813      	ldr	r3, [r2, #0]
24009b30:	f423 2300 	bic.w	r3, r3, #524288	@ 0x80000
24009b34:	6013      	str	r3, [r2, #0]
}
24009b36:	4770      	bx	lr
24009b38:	58024400 	.word	0x58024400

24009b3c <HAL_RCC_GetSysClockFreq>:
  float_t fracn1, pllvco;
  uint32_t sysclockfreq;

  /* Get SYSCLK source -------------------------------------------------------*/

  switch (RCC->CFGR & RCC_CFGR_SWS)
24009b3c:	4b49      	ldr	r3, [pc, #292]	@ (24009c64 <HAL_RCC_GetSysClockFreq+0x128>)
24009b3e:	691a      	ldr	r2, [r3, #16]
24009b40:	f002 0238 	and.w	r2, r2, #56	@ 0x38
24009b44:	2a10      	cmp	r2, #16
{
24009b46:	b530      	push	{r4, r5, lr}
  switch (RCC->CFGR & RCC_CFGR_SWS)
24009b48:	f000 8088 	beq.w	24009c5c <HAL_RCC_GetSysClockFreq+0x120>
24009b4c:	2a18      	cmp	r2, #24
24009b4e:	d00c      	beq.n	24009b6a <HAL_RCC_GetSysClockFreq+0x2e>
24009b50:	2a00      	cmp	r2, #0
24009b52:	f040 8085 	bne.w	24009c60 <HAL_RCC_GetSysClockFreq+0x124>
  {
  case RCC_CFGR_SWS_HSI:  /* HSI used as system clock source */

   if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
24009b56:	681a      	ldr	r2, [r3, #0]
24009b58:	4843      	ldr	r0, [pc, #268]	@ (24009c68 <HAL_RCC_GetSysClockFreq+0x12c>)
24009b5a:	f012 0f20 	tst.w	r2, #32
24009b5e:	d003      	beq.n	24009b68 <HAL_RCC_GetSysClockFreq+0x2c>
      {
        sysclockfreq = (uint32_t) (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
24009b60:	681b      	ldr	r3, [r3, #0]
24009b62:	f3c3 03c1 	ubfx	r3, r3, #3, #2
24009b66:	40d8      	lsrs	r0, r3
    sysclockfreq = CSI_VALUE;
    break;
  }

  return sysclockfreq;
}
24009b68:	bd30      	pop	{r4, r5, pc}
    pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
24009b6a:	6a99      	ldr	r1, [r3, #40]	@ 0x28
    pllm = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM1)>> 4)  ;
24009b6c:	6a9d      	ldr	r5, [r3, #40]	@ 0x28
    pllfracen = ((RCC-> PLLCFGR & RCC_PLLCFGR_PLL1FRACEN)>>RCC_PLLCFGR_PLL1FRACEN_Pos);
24009b6e:	6adc      	ldr	r4, [r3, #44]	@ 0x2c
    if (pllm != 0U)
24009b70:	f415 7f7c 	tst.w	r5, #1008	@ 0x3f0
    pllm = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM1)>> 4)  ;
24009b74:	f3c5 1005 	ubfx	r0, r5, #4, #6
    fracn1 = (float_t)(uint32_t)(pllfracen* ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));
24009b78:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
    if (pllm != 0U)
24009b7a:	d0f5      	beq.n	24009b68 <HAL_RCC_GetSysClockFreq+0x2c>
    fracn1 = (float_t)(uint32_t)(pllfracen* ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));
24009b7c:	f3c2 02cc 	ubfx	r2, r2, #3, #13
    pllfracen = ((RCC-> PLLCFGR & RCC_PLLCFGR_PLL1FRACEN)>>RCC_PLLCFGR_PLL1FRACEN_Pos);
24009b80:	f004 0401 	and.w	r4, r4, #1
    pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
24009b84:	f001 0103 	and.w	r1, r1, #3
          pllvco = ( (float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
24009b88:	ee07 0a90 	vmov	s15, r0
    fracn1 = (float_t)(uint32_t)(pllfracen* ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));
24009b8c:	4362      	muls	r2, r4
24009b8e:	eeb7 6a00 	vmov.f32	s12, #112	@ 0x3f800000  1.0
24009b92:	2901      	cmp	r1, #1
          pllvco = ( (float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
24009b94:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
24009b98:	ee06 2a90 	vmov	s13, r2
24009b9c:	eefa 6ae9 	vcvt.f32.s32	s13, s13, #13
24009ba0:	d04e      	beq.n	24009c40 <HAL_RCC_GetSysClockFreq+0x104>
24009ba2:	2902      	cmp	r1, #2
24009ba4:	d03e      	beq.n	24009c24 <HAL_RCC_GetSysClockFreq+0xe8>
24009ba6:	2900      	cmp	r1, #0
24009ba8:	d14a      	bne.n	24009c40 <HAL_RCC_GetSysClockFreq+0x104>
       if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
24009baa:	681a      	ldr	r2, [r3, #0]
24009bac:	0692      	lsls	r2, r2, #26
24009bae:	d527      	bpl.n	24009c00 <HAL_RCC_GetSysClockFreq+0xc4>
          hsivalue= (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
24009bb0:	6819      	ldr	r1, [r3, #0]
24009bb2:	4a2d      	ldr	r2, [pc, #180]	@ (24009c68 <HAL_RCC_GetSysClockFreq+0x12c>)
24009bb4:	f3c1 01c1 	ubfx	r1, r1, #3, #2
          pllvco = ( (float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
24009bb8:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
          hsivalue= (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
24009bba:	40ca      	lsrs	r2, r1
          pllvco = ( (float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
24009bbc:	f3c3 0308 	ubfx	r3, r3, #0, #9
24009bc0:	ee07 2a90 	vmov	s15, r2
24009bc4:	eef8 5ae7 	vcvt.f32.s32	s11, s15
24009bc8:	eec5 7a87 	vdiv.f32	s15, s11, s14
24009bcc:	ee07 3a10 	vmov	s14, r3
24009bd0:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
24009bd4:	ee37 7a26 	vadd.f32	s14, s14, s13
24009bd8:	ee37 7a06 	vadd.f32	s14, s14, s12
24009bdc:	ee67 7a87 	vmul.f32	s15, s15, s14
      pllp = (((RCC->PLL1DIVR & RCC_PLL1DIVR_P1) >>9) + 1U ) ;
24009be0:	4b20      	ldr	r3, [pc, #128]	@ (24009c64 <HAL_RCC_GetSysClockFreq+0x128>)
24009be2:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
24009be4:	f3c3 2346 	ubfx	r3, r3, #9, #7
24009be8:	3301      	adds	r3, #1
      sysclockfreq =  (uint32_t)(float_t)(pllvco/(float_t)pllp);
24009bea:	ee07 3a10 	vmov	s14, r3
24009bee:	eef8 6ac7 	vcvt.f32.s32	s13, s14
24009bf2:	ee87 7aa6 	vdiv.f32	s14, s15, s13
24009bf6:	eefc 7ac7 	vcvt.u32.f32	s15, s14
24009bfa:	ee17 0a90 	vmov	r0, s15
24009bfe:	e7b3      	b.n	24009b68 <HAL_RCC_GetSysClockFreq+0x2c>
          pllvco = ((float_t)HSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
24009c00:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
24009c02:	f3c3 0308 	ubfx	r3, r3, #0, #9
24009c06:	ee07 3a90 	vmov	s15, r3
24009c0a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
24009c0e:	ee77 7aa6 	vadd.f32	s15, s15, s13
24009c12:	ee77 7a86 	vadd.f32	s15, s15, s12
24009c16:	ed9f 6a15 	vldr	s12, [pc, #84]	@ 24009c6c <HAL_RCC_GetSysClockFreq+0x130>
        pllvco = ((float_t)CSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
24009c1a:	eec6 6a07 	vdiv.f32	s13, s12, s14
24009c1e:	ee67 7aa6 	vmul.f32	s15, s15, s13
        break;
24009c22:	e7dd      	b.n	24009be0 <HAL_RCC_GetSysClockFreq+0xa4>
        pllvco = ((float_t)HSE_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
24009c24:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
24009c26:	f3c3 0308 	ubfx	r3, r3, #0, #9
24009c2a:	ee07 3a90 	vmov	s15, r3
24009c2e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
24009c32:	ee77 7aa6 	vadd.f32	s15, s15, s13
24009c36:	ee77 7a86 	vadd.f32	s15, s15, s12
24009c3a:	ed9f 6a0d 	vldr	s12, [pc, #52]	@ 24009c70 <HAL_RCC_GetSysClockFreq+0x134>
24009c3e:	e7ec      	b.n	24009c1a <HAL_RCC_GetSysClockFreq+0xde>
        pllvco = ((float_t)CSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
24009c40:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
24009c42:	f3c3 0308 	ubfx	r3, r3, #0, #9
24009c46:	ee07 3a90 	vmov	s15, r3
24009c4a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
24009c4e:	ee77 7aa6 	vadd.f32	s15, s15, s13
24009c52:	ee77 7a86 	vadd.f32	s15, s15, s12
24009c56:	ed9f 6a07 	vldr	s12, [pc, #28]	@ 24009c74 <HAL_RCC_GetSysClockFreq+0x138>
24009c5a:	e7de      	b.n	24009c1a <HAL_RCC_GetSysClockFreq+0xde>
  switch (RCC->CFGR & RCC_CFGR_SWS)
24009c5c:	4806      	ldr	r0, [pc, #24]	@ (24009c78 <HAL_RCC_GetSysClockFreq+0x13c>)
24009c5e:	e783      	b.n	24009b68 <HAL_RCC_GetSysClockFreq+0x2c>
    sysclockfreq = CSI_VALUE;
24009c60:	4806      	ldr	r0, [pc, #24]	@ (24009c7c <HAL_RCC_GetSysClockFreq+0x140>)
24009c62:	e781      	b.n	24009b68 <HAL_RCC_GetSysClockFreq+0x2c>
24009c64:	58024400 	.word	0x58024400
24009c68:	03d09000 	.word	0x03d09000
24009c6c:	4c742400 	.word	0x4c742400
24009c70:	4bbebc20 	.word	0x4bbebc20
24009c74:	4a742400 	.word	0x4a742400
24009c78:	017d7840 	.word	0x017d7840
24009c7c:	003d0900 	.word	0x003d0900

24009c80 <HAL_RCC_ClockConfig>:
{
24009c80:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
24009c84:	460d      	mov	r5, r1
  if(RCC_ClkInitStruct == NULL)
24009c86:	4604      	mov	r4, r0
24009c88:	b910      	cbnz	r0, 24009c90 <HAL_RCC_ClockConfig+0x10>
    return HAL_ERROR;
24009c8a:	2001      	movs	r0, #1
}
24009c8c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if(FLatency > __HAL_FLASH_GET_LATENCY())
24009c90:	4a88      	ldr	r2, [pc, #544]	@ (24009eb4 <HAL_RCC_ClockConfig+0x234>)
24009c92:	6813      	ldr	r3, [r2, #0]
24009c94:	f003 030f 	and.w	r3, r3, #15
24009c98:	428b      	cmp	r3, r1
24009c9a:	f0c0 8093 	bcc.w	24009dc4 <HAL_RCC_ClockConfig+0x144>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_D1PCLK1) == RCC_CLOCKTYPE_D1PCLK1)
24009c9e:	6823      	ldr	r3, [r4, #0]
24009ca0:	075f      	lsls	r7, r3, #29
24009ca2:	f100 809b 	bmi.w	24009ddc <HAL_RCC_ClockConfig+0x15c>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
24009ca6:	071e      	lsls	r6, r3, #28
24009ca8:	d50b      	bpl.n	24009cc2 <HAL_RCC_ClockConfig+0x42>
    if((RCC_ClkInitStruct->APB1CLKDivider) > (RCC->D2CFGR & RCC_D2CFGR_D2PPRE1))
24009caa:	4983      	ldr	r1, [pc, #524]	@ (24009eb8 <HAL_RCC_ClockConfig+0x238>)
24009cac:	6960      	ldr	r0, [r4, #20]
24009cae:	69ca      	ldr	r2, [r1, #28]
24009cb0:	f002 0270 	and.w	r2, r2, #112	@ 0x70
24009cb4:	4290      	cmp	r0, r2
24009cb6:	d904      	bls.n	24009cc2 <HAL_RCC_ClockConfig+0x42>
      MODIFY_REG(RCC->D2CFGR, RCC_D2CFGR_D2PPRE1, (RCC_ClkInitStruct->APB1CLKDivider));
24009cb8:	69ca      	ldr	r2, [r1, #28]
24009cba:	f022 0270 	bic.w	r2, r2, #112	@ 0x70
24009cbe:	4302      	orrs	r2, r0
24009cc0:	61ca      	str	r2, [r1, #28]
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
24009cc2:	06d8      	lsls	r0, r3, #27
24009cc4:	d50b      	bpl.n	24009cde <HAL_RCC_ClockConfig+0x5e>
    if((RCC_ClkInitStruct->APB2CLKDivider) > (RCC->D2CFGR & RCC_D2CFGR_D2PPRE2))
24009cc6:	497c      	ldr	r1, [pc, #496]	@ (24009eb8 <HAL_RCC_ClockConfig+0x238>)
24009cc8:	69a0      	ldr	r0, [r4, #24]
24009cca:	69ca      	ldr	r2, [r1, #28]
24009ccc:	f402 62e0 	and.w	r2, r2, #1792	@ 0x700
24009cd0:	4290      	cmp	r0, r2
24009cd2:	d904      	bls.n	24009cde <HAL_RCC_ClockConfig+0x5e>
      MODIFY_REG(RCC->D2CFGR, RCC_D2CFGR_D2PPRE2, (RCC_ClkInitStruct->APB2CLKDivider));
24009cd4:	69ca      	ldr	r2, [r1, #28]
24009cd6:	f422 62e0 	bic.w	r2, r2, #1792	@ 0x700
24009cda:	4302      	orrs	r2, r0
24009cdc:	61ca      	str	r2, [r1, #28]
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_D3PCLK1) == RCC_CLOCKTYPE_D3PCLK1)
24009cde:	0699      	lsls	r1, r3, #26
24009ce0:	d50b      	bpl.n	24009cfa <HAL_RCC_ClockConfig+0x7a>
    if((RCC_ClkInitStruct->APB4CLKDivider) > (RCC->D3CFGR & RCC_D3CFGR_D3PPRE))
24009ce2:	4975      	ldr	r1, [pc, #468]	@ (24009eb8 <HAL_RCC_ClockConfig+0x238>)
24009ce4:	69e0      	ldr	r0, [r4, #28]
24009ce6:	6a0a      	ldr	r2, [r1, #32]
24009ce8:	f002 0270 	and.w	r2, r2, #112	@ 0x70
24009cec:	4290      	cmp	r0, r2
24009cee:	d904      	bls.n	24009cfa <HAL_RCC_ClockConfig+0x7a>
      MODIFY_REG(RCC->D3CFGR, RCC_D3CFGR_D3PPRE, (RCC_ClkInitStruct->APB4CLKDivider) );
24009cf0:	6a0a      	ldr	r2, [r1, #32]
24009cf2:	f022 0270 	bic.w	r2, r2, #112	@ 0x70
24009cf6:	4302      	orrs	r2, r0
24009cf8:	620a      	str	r2, [r1, #32]
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
24009cfa:	079a      	lsls	r2, r3, #30
24009cfc:	d50b      	bpl.n	24009d16 <HAL_RCC_ClockConfig+0x96>
    if((RCC_ClkInitStruct->AHBCLKDivider) > (RCC->D1CFGR & RCC_D1CFGR_HPRE))
24009cfe:	496e      	ldr	r1, [pc, #440]	@ (24009eb8 <HAL_RCC_ClockConfig+0x238>)
24009d00:	68e0      	ldr	r0, [r4, #12]
24009d02:	698a      	ldr	r2, [r1, #24]
24009d04:	f002 020f 	and.w	r2, r2, #15
24009d08:	4290      	cmp	r0, r2
24009d0a:	d904      	bls.n	24009d16 <HAL_RCC_ClockConfig+0x96>
      MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
24009d0c:	698a      	ldr	r2, [r1, #24]
24009d0e:	f022 020f 	bic.w	r2, r2, #15
24009d12:	4302      	orrs	r2, r0
24009d14:	618a      	str	r2, [r1, #24]
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
24009d16:	07df      	lsls	r7, r3, #31
24009d18:	d46e      	bmi.n	24009df8 <HAL_RCC_ClockConfig+0x178>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
24009d1a:	6823      	ldr	r3, [r4, #0]
24009d1c:	079e      	lsls	r6, r3, #30
24009d1e:	f100 80a1 	bmi.w	24009e64 <HAL_RCC_ClockConfig+0x1e4>
  if(FLatency < __HAL_FLASH_GET_LATENCY())
24009d22:	4964      	ldr	r1, [pc, #400]	@ (24009eb4 <HAL_RCC_ClockConfig+0x234>)
24009d24:	680a      	ldr	r2, [r1, #0]
24009d26:	f002 020f 	and.w	r2, r2, #15
24009d2a:	42aa      	cmp	r2, r5
24009d2c:	f200 80a8 	bhi.w	24009e80 <HAL_RCC_ClockConfig+0x200>
 if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_D1PCLK1) == RCC_CLOCKTYPE_D1PCLK1)
24009d30:	0758      	lsls	r0, r3, #29
24009d32:	f100 80b1 	bmi.w	24009e98 <HAL_RCC_ClockConfig+0x218>
 if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
24009d36:	0719      	lsls	r1, r3, #28
24009d38:	d50b      	bpl.n	24009d52 <HAL_RCC_ClockConfig+0xd2>
   if((RCC_ClkInitStruct->APB1CLKDivider) < (RCC->D2CFGR & RCC_D2CFGR_D2PPRE1))
24009d3a:	495f      	ldr	r1, [pc, #380]	@ (24009eb8 <HAL_RCC_ClockConfig+0x238>)
24009d3c:	6960      	ldr	r0, [r4, #20]
24009d3e:	69ca      	ldr	r2, [r1, #28]
24009d40:	f002 0270 	and.w	r2, r2, #112	@ 0x70
24009d44:	4290      	cmp	r0, r2
24009d46:	d204      	bcs.n	24009d52 <HAL_RCC_ClockConfig+0xd2>
     MODIFY_REG(RCC->D2CFGR, RCC_D2CFGR_D2PPRE1, (RCC_ClkInitStruct->APB1CLKDivider));
24009d48:	69ca      	ldr	r2, [r1, #28]
24009d4a:	f022 0270 	bic.w	r2, r2, #112	@ 0x70
24009d4e:	4302      	orrs	r2, r0
24009d50:	61ca      	str	r2, [r1, #28]
 if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
24009d52:	06da      	lsls	r2, r3, #27
24009d54:	d50b      	bpl.n	24009d6e <HAL_RCC_ClockConfig+0xee>
   if((RCC_ClkInitStruct->APB2CLKDivider) < (RCC->D2CFGR & RCC_D2CFGR_D2PPRE2))
24009d56:	4958      	ldr	r1, [pc, #352]	@ (24009eb8 <HAL_RCC_ClockConfig+0x238>)
24009d58:	69a0      	ldr	r0, [r4, #24]
24009d5a:	69ca      	ldr	r2, [r1, #28]
24009d5c:	f402 62e0 	and.w	r2, r2, #1792	@ 0x700
24009d60:	4290      	cmp	r0, r2
24009d62:	d204      	bcs.n	24009d6e <HAL_RCC_ClockConfig+0xee>
     MODIFY_REG(RCC->D2CFGR, RCC_D2CFGR_D2PPRE2, (RCC_ClkInitStruct->APB2CLKDivider));
24009d64:	69ca      	ldr	r2, [r1, #28]
24009d66:	f422 62e0 	bic.w	r2, r2, #1792	@ 0x700
24009d6a:	4302      	orrs	r2, r0
24009d6c:	61ca      	str	r2, [r1, #28]
 if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_D3PCLK1) == RCC_CLOCKTYPE_D3PCLK1)
24009d6e:	069b      	lsls	r3, r3, #26
24009d70:	d50b      	bpl.n	24009d8a <HAL_RCC_ClockConfig+0x10a>
   if((RCC_ClkInitStruct->APB4CLKDivider) < (RCC->D3CFGR & RCC_D3CFGR_D3PPRE))
24009d72:	4a51      	ldr	r2, [pc, #324]	@ (24009eb8 <HAL_RCC_ClockConfig+0x238>)
24009d74:	69e1      	ldr	r1, [r4, #28]
24009d76:	6a13      	ldr	r3, [r2, #32]
24009d78:	f003 0370 	and.w	r3, r3, #112	@ 0x70
24009d7c:	4299      	cmp	r1, r3
24009d7e:	d204      	bcs.n	24009d8a <HAL_RCC_ClockConfig+0x10a>
     MODIFY_REG(RCC->D3CFGR, RCC_D3CFGR_D3PPRE, (RCC_ClkInitStruct->APB4CLKDivider) );
24009d80:	6a13      	ldr	r3, [r2, #32]
24009d82:	f023 0370 	bic.w	r3, r3, #112	@ 0x70
24009d86:	430b      	orrs	r3, r1
24009d88:	6213      	str	r3, [r2, #32]
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
24009d8a:	f7ff fed7 	bl	24009b3c <HAL_RCC_GetSysClockFreq>
24009d8e:	494a      	ldr	r1, [pc, #296]	@ (24009eb8 <HAL_RCC_ClockConfig+0x238>)
24009d90:	4a4a      	ldr	r2, [pc, #296]	@ (24009ebc <HAL_RCC_ClockConfig+0x23c>)
24009d92:	698b      	ldr	r3, [r1, #24]
24009d94:	f3c3 2303 	ubfx	r3, r3, #8, #4
24009d98:	5cd3      	ldrb	r3, [r2, r3]
24009d9a:	f003 031f 	and.w	r3, r3, #31
24009d9e:	40d8      	lsrs	r0, r3
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
24009da0:	698b      	ldr	r3, [r1, #24]
24009da2:	f003 030f 	and.w	r3, r3, #15
24009da6:	5cd3      	ldrb	r3, [r2, r3]
24009da8:	4a45      	ldr	r2, [pc, #276]	@ (24009ec0 <HAL_RCC_ClockConfig+0x240>)
24009daa:	f003 031f 	and.w	r3, r3, #31
24009dae:	fa20 f303 	lsr.w	r3, r0, r3
24009db2:	6013      	str	r3, [r2, #0]
  SystemCoreClock = common_system_clock;
24009db4:	4b43      	ldr	r3, [pc, #268]	@ (24009ec4 <HAL_RCC_ClockConfig+0x244>)
24009db6:	6018      	str	r0, [r3, #0]
  halstatus = HAL_InitTick (uwTickPrio);
24009db8:	4b43      	ldr	r3, [pc, #268]	@ (24009ec8 <HAL_RCC_ClockConfig+0x248>)
}
24009dba:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  halstatus = HAL_InitTick (uwTickPrio);
24009dbe:	6818      	ldr	r0, [r3, #0]
24009dc0:	f008 b820 	b.w	24011e04 <HAL_InitTick>
    __HAL_FLASH_SET_LATENCY(FLatency);
24009dc4:	6813      	ldr	r3, [r2, #0]
24009dc6:	f023 030f 	bic.w	r3, r3, #15
24009dca:	430b      	orrs	r3, r1
24009dcc:	6013      	str	r3, [r2, #0]
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
24009dce:	6813      	ldr	r3, [r2, #0]
24009dd0:	f003 030f 	and.w	r3, r3, #15
24009dd4:	428b      	cmp	r3, r1
24009dd6:	f47f af58 	bne.w	24009c8a <HAL_RCC_ClockConfig+0xa>
24009dda:	e760      	b.n	24009c9e <HAL_RCC_ClockConfig+0x1e>
    if((RCC_ClkInitStruct->APB3CLKDivider) > (RCC->D1CFGR & RCC_D1CFGR_D1PPRE))
24009ddc:	4936      	ldr	r1, [pc, #216]	@ (24009eb8 <HAL_RCC_ClockConfig+0x238>)
24009dde:	6920      	ldr	r0, [r4, #16]
24009de0:	698a      	ldr	r2, [r1, #24]
24009de2:	f002 0270 	and.w	r2, r2, #112	@ 0x70
24009de6:	4290      	cmp	r0, r2
24009de8:	f67f af5d 	bls.w	24009ca6 <HAL_RCC_ClockConfig+0x26>
      MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_D1PPRE, RCC_ClkInitStruct->APB3CLKDivider);
24009dec:	698a      	ldr	r2, [r1, #24]
24009dee:	f022 0270 	bic.w	r2, r2, #112	@ 0x70
24009df2:	4302      	orrs	r2, r0
24009df4:	618a      	str	r2, [r1, #24]
24009df6:	e756      	b.n	24009ca6 <HAL_RCC_ClockConfig+0x26>
      MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_D1CPRE, RCC_ClkInitStruct->SYSCLKDivider);
24009df8:	4b2f      	ldr	r3, [pc, #188]	@ (24009eb8 <HAL_RCC_ClockConfig+0x238>)
24009dfa:	68a1      	ldr	r1, [r4, #8]
24009dfc:	699a      	ldr	r2, [r3, #24]
24009dfe:	f422 6270 	bic.w	r2, r2, #3840	@ 0xf00
24009e02:	430a      	orrs	r2, r1
24009e04:	619a      	str	r2, [r3, #24]
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
24009e06:	6861      	ldr	r1, [r4, #4]
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
24009e08:	681a      	ldr	r2, [r3, #0]
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
24009e0a:	2902      	cmp	r1, #2
24009e0c:	d11d      	bne.n	24009e4a <HAL_RCC_ClockConfig+0x1ca>
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
24009e0e:	f412 3f00 	tst.w	r2, #131072	@ 0x20000
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
24009e12:	f43f af3a 	beq.w	24009c8a <HAL_RCC_ClockConfig+0xa>
      MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);
24009e16:	691a      	ldr	r2, [r3, #16]
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
24009e18:	f241 3888 	movw	r8, #5000	@ 0x1388
        while (__HAL_RCC_GET_SYSCLK_SOURCE() !=  (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
24009e1c:	4f26      	ldr	r7, [pc, #152]	@ (24009eb8 <HAL_RCC_ClockConfig+0x238>)
      MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);
24009e1e:	f022 0207 	bic.w	r2, r2, #7
24009e22:	430a      	orrs	r2, r1
24009e24:	611a      	str	r2, [r3, #16]
      tickstart = HAL_GetTick();
24009e26:	f007 ffef 	bl	24011e08 <HAL_GetTick>
24009e2a:	4606      	mov	r6, r0
        while (__HAL_RCC_GET_SYSCLK_SOURCE() !=  (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
24009e2c:	693b      	ldr	r3, [r7, #16]
24009e2e:	6862      	ldr	r2, [r4, #4]
24009e30:	f003 0338 	and.w	r3, r3, #56	@ 0x38
24009e34:	ebb3 0fc2 	cmp.w	r3, r2, lsl #3
24009e38:	f43f af6f 	beq.w	24009d1a <HAL_RCC_ClockConfig+0x9a>
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
24009e3c:	f007 ffe4 	bl	24011e08 <HAL_GetTick>
24009e40:	1b80      	subs	r0, r0, r6
24009e42:	4540      	cmp	r0, r8
24009e44:	d9f2      	bls.n	24009e2c <HAL_RCC_ClockConfig+0x1ac>
            return HAL_TIMEOUT;
24009e46:	2003      	movs	r0, #3
24009e48:	e720      	b.n	24009c8c <HAL_RCC_ClockConfig+0xc>
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
24009e4a:	2903      	cmp	r1, #3
24009e4c:	d102      	bne.n	24009e54 <HAL_RCC_ClockConfig+0x1d4>
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == 0U)
24009e4e:	f012 7f00 	tst.w	r2, #33554432	@ 0x2000000
24009e52:	e7de      	b.n	24009e12 <HAL_RCC_ClockConfig+0x192>
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_CSI)
24009e54:	2901      	cmp	r1, #1
24009e56:	d102      	bne.n	24009e5e <HAL_RCC_ClockConfig+0x1de>
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) == 0U)
24009e58:	f412 7f80 	tst.w	r2, #256	@ 0x100
24009e5c:	e7d9      	b.n	24009e12 <HAL_RCC_ClockConfig+0x192>
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
24009e5e:	f012 0f04 	tst.w	r2, #4
24009e62:	e7d6      	b.n	24009e12 <HAL_RCC_ClockConfig+0x192>
    if((RCC_ClkInitStruct->AHBCLKDivider) < (RCC->D1CFGR & RCC_D1CFGR_HPRE))
24009e64:	4914      	ldr	r1, [pc, #80]	@ (24009eb8 <HAL_RCC_ClockConfig+0x238>)
24009e66:	68e0      	ldr	r0, [r4, #12]
24009e68:	698a      	ldr	r2, [r1, #24]
24009e6a:	f002 020f 	and.w	r2, r2, #15
24009e6e:	4290      	cmp	r0, r2
24009e70:	f4bf af57 	bcs.w	24009d22 <HAL_RCC_ClockConfig+0xa2>
      MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
24009e74:	698a      	ldr	r2, [r1, #24]
24009e76:	f022 020f 	bic.w	r2, r2, #15
24009e7a:	4302      	orrs	r2, r0
24009e7c:	618a      	str	r2, [r1, #24]
24009e7e:	e750      	b.n	24009d22 <HAL_RCC_ClockConfig+0xa2>
    __HAL_FLASH_SET_LATENCY(FLatency);
24009e80:	680a      	ldr	r2, [r1, #0]
24009e82:	f022 020f 	bic.w	r2, r2, #15
24009e86:	432a      	orrs	r2, r5
24009e88:	600a      	str	r2, [r1, #0]
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
24009e8a:	680a      	ldr	r2, [r1, #0]
24009e8c:	f002 020f 	and.w	r2, r2, #15
24009e90:	42aa      	cmp	r2, r5
24009e92:	f47f aefa 	bne.w	24009c8a <HAL_RCC_ClockConfig+0xa>
24009e96:	e74b      	b.n	24009d30 <HAL_RCC_ClockConfig+0xb0>
   if((RCC_ClkInitStruct->APB3CLKDivider) < (RCC->D1CFGR & RCC_D1CFGR_D1PPRE))
24009e98:	4907      	ldr	r1, [pc, #28]	@ (24009eb8 <HAL_RCC_ClockConfig+0x238>)
24009e9a:	6920      	ldr	r0, [r4, #16]
24009e9c:	698a      	ldr	r2, [r1, #24]
24009e9e:	f002 0270 	and.w	r2, r2, #112	@ 0x70
24009ea2:	4290      	cmp	r0, r2
24009ea4:	f4bf af47 	bcs.w	24009d36 <HAL_RCC_ClockConfig+0xb6>
     MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_D1PPRE, RCC_ClkInitStruct->APB3CLKDivider);
24009ea8:	698a      	ldr	r2, [r1, #24]
24009eaa:	f022 0270 	bic.w	r2, r2, #112	@ 0x70
24009eae:	4302      	orrs	r2, r0
24009eb0:	618a      	str	r2, [r1, #24]
24009eb2:	e740      	b.n	24009d36 <HAL_RCC_ClockConfig+0xb6>
24009eb4:	52002000 	.word	0x52002000
24009eb8:	58024400 	.word	0x58024400
24009ebc:	240141fa 	.word	0x240141fa
24009ec0:	24000514 	.word	0x24000514
24009ec4:	24000518 	.word	0x24000518
24009ec8:	240004a4 	.word	0x240004a4

24009ecc <HAL_RCC_GetHCLKFreq>:
  * @note   The SystemD2Clock CMSIS variable is used to store System domain2 Clock Frequency
  *         and updated within this function
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
24009ecc:	b508      	push	{r3, lr}
uint32_t common_system_clock;

#if defined(RCC_D1CFGR_D1CPRE)
  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos] & 0x1FU);
24009ece:	f7ff fe35 	bl	24009b3c <HAL_RCC_GetSysClockFreq>
24009ed2:	4a0b      	ldr	r2, [pc, #44]	@ (24009f00 <HAL_RCC_GetHCLKFreq+0x34>)
24009ed4:	490b      	ldr	r1, [pc, #44]	@ (24009f04 <HAL_RCC_GetHCLKFreq+0x38>)
24009ed6:	6993      	ldr	r3, [r2, #24]
#else
  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->CDCFGR1 & RCC_CDCFGR1_CDCPRE)>> RCC_CDCFGR1_CDCPRE_Pos] & 0x1FU);
#endif

#if defined(RCC_D1CFGR_HPRE)
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
24009ed8:	6992      	ldr	r2, [r2, #24]
  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos] & 0x1FU);
24009eda:	f3c3 2303 	ubfx	r3, r3, #8, #4
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
24009ede:	f002 020f 	and.w	r2, r2, #15
  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos] & 0x1FU);
24009ee2:	5ccb      	ldrb	r3, [r1, r3]
24009ee4:	f003 031f 	and.w	r3, r3, #31
24009ee8:	fa20 f303 	lsr.w	r3, r0, r3
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
24009eec:	5c88      	ldrb	r0, [r1, r2]
24009eee:	4a06      	ldr	r2, [pc, #24]	@ (24009f08 <HAL_RCC_GetHCLKFreq+0x3c>)
24009ef0:	f000 001f 	and.w	r0, r0, #31
24009ef4:	fa23 f000 	lsr.w	r0, r3, r0
24009ef8:	6010      	str	r0, [r2, #0]
#endif

#if defined(DUAL_CORE) && defined(CORE_CM4)
  SystemCoreClock = SystemD2Clock;
#else
  SystemCoreClock = common_system_clock;
24009efa:	4a04      	ldr	r2, [pc, #16]	@ (24009f0c <HAL_RCC_GetHCLKFreq+0x40>)
24009efc:	6013      	str	r3, [r2, #0]
#endif /* DUAL_CORE && CORE_CM4 */

  return SystemD2Clock;
}
24009efe:	bd08      	pop	{r3, pc}
24009f00:	58024400 	.word	0x58024400
24009f04:	240141fa 	.word	0x240141fa
24009f08:	24000514 	.word	0x24000514
24009f0c:	24000518 	.word	0x24000518

24009f10 <HAL_RCC_GetPCLK1Freq>:
  * @note   Each time PCLK1 changes, this function must be called to update the
  *         right PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
24009f10:	b508      	push	{r3, lr}
#if defined (RCC_D2CFGR_D2PPRE1)
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> ((D1CorePrescTable[(RCC->D2CFGR & RCC_D2CFGR_D2PPRE1)>> RCC_D2CFGR_D2PPRE1_Pos]) & 0x1FU));
24009f12:	f7ff ffdb 	bl	24009ecc <HAL_RCC_GetHCLKFreq>
24009f16:	4b05      	ldr	r3, [pc, #20]	@ (24009f2c <HAL_RCC_GetPCLK1Freq+0x1c>)
24009f18:	4a05      	ldr	r2, [pc, #20]	@ (24009f30 <HAL_RCC_GetPCLK1Freq+0x20>)
24009f1a:	69db      	ldr	r3, [r3, #28]
24009f1c:	f3c3 1302 	ubfx	r3, r3, #4, #3
24009f20:	5cd3      	ldrb	r3, [r2, r3]
24009f22:	f003 031f 	and.w	r3, r3, #31
#else
 /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> ((D1CorePrescTable[(RCC->CDCFGR2 & RCC_CDCFGR2_CDPPRE1)>> RCC_CDCFGR2_CDPPRE1_Pos]) & 0x1FU));
#endif
}
24009f26:	40d8      	lsrs	r0, r3
24009f28:	bd08      	pop	{r3, pc}
24009f2a:	bf00      	nop
24009f2c:	58024400 	.word	0x58024400
24009f30:	240141fa 	.word	0x240141fa

24009f34 <HAL_RCC_GetPCLK2Freq>:
  * @note   Each time PCLK2 changes, this function must be called to update the
  *         right PCLK2 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK2Freq(void)
{
24009f34:	b508      	push	{r3, lr}
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
#if defined(RCC_D2CFGR_D2PPRE2)
  return (HAL_RCC_GetHCLKFreq() >> ((D1CorePrescTable[(RCC->D2CFGR & RCC_D2CFGR_D2PPRE2)>> RCC_D2CFGR_D2PPRE2_Pos]) & 0x1FU));
24009f36:	f7ff ffc9 	bl	24009ecc <HAL_RCC_GetHCLKFreq>
24009f3a:	4b05      	ldr	r3, [pc, #20]	@ (24009f50 <HAL_RCC_GetPCLK2Freq+0x1c>)
24009f3c:	4a05      	ldr	r2, [pc, #20]	@ (24009f54 <HAL_RCC_GetPCLK2Freq+0x20>)
24009f3e:	69db      	ldr	r3, [r3, #28]
24009f40:	f3c3 2302 	ubfx	r3, r3, #8, #3
24009f44:	5cd3      	ldrb	r3, [r2, r3]
24009f46:	f003 031f 	and.w	r3, r3, #31
#else
  return (HAL_RCC_GetHCLKFreq() >> ((D1CorePrescTable[(RCC->CDCFGR2 & RCC_CDCFGR2_CDPPRE2)>> RCC_CDCFGR2_CDPPRE2_Pos]) & 0x1FU));
#endif
}
24009f4a:	40d8      	lsrs	r0, r3
24009f4c:	bd08      	pop	{r3, pc}
24009f4e:	bf00      	nop
24009f50:	58024400 	.word	0x58024400
24009f54:	240141fa 	.word	0x240141fa

24009f58 <HAL_RCC_GetOscConfig>:
  * @param  RCC_OscInitStruct: pointer to an RCC_OscInitTypeDef structure that
  * will be configured.
  * @retval None
  */
void HAL_RCC_GetOscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
24009f58:	b538      	push	{r3, r4, r5, lr}
  /* Set all possible values for the Oscillator type parameter ---------------*/
  RCC_OscInitStruct->OscillatorType = RCC_OSCILLATORTYPE_HSE | RCC_OSCILLATORTYPE_HSI | RCC_OSCILLATORTYPE_CSI | \
24009f5a:	233f      	movs	r3, #63	@ 0x3f
  else
  {
    RCC_OscInitStruct->HSEState = RCC_HSE_OFF;
  }
#else
  if((RCC->CR &RCC_CR_HSEBYP) == RCC_CR_HSEBYP)
24009f5c:	4d38      	ldr	r5, [pc, #224]	@ (2400a040 <HAL_RCC_GetOscConfig+0xe8>)
{
24009f5e:	4604      	mov	r4, r0
  RCC_OscInitStruct->OscillatorType = RCC_OSCILLATORTYPE_HSE | RCC_OSCILLATORTYPE_HSI | RCC_OSCILLATORTYPE_CSI | \
24009f60:	6003      	str	r3, [r0, #0]
  if((RCC->CR &RCC_CR_HSEBYP) == RCC_CR_HSEBYP)
24009f62:	682b      	ldr	r3, [r5, #0]
24009f64:	035a      	lsls	r2, r3, #13
24009f66:	d462      	bmi.n	2400a02e <HAL_RCC_GetOscConfig+0xd6>
  {
    RCC_OscInitStruct->HSEState = RCC_HSE_BYPASS;
  }
  else if((RCC->CR &RCC_CR_HSEON) == RCC_CR_HSEON)
24009f68:	682b      	ldr	r3, [r5, #0]
24009f6a:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
    RCC_OscInitStruct->HSEState = RCC_HSE_BYPASS;
24009f6e:	6063      	str	r3, [r4, #4]
    RCC_OscInitStruct->HSEState = RCC_HSE_OFF;
  }
#endif /* RCC_CR_HSEEXT */

   /* Get the CSI configuration -----------------------------------------------*/
  if((RCC->CR &RCC_CR_CSION) == RCC_CR_CSION)
24009f70:	682b      	ldr	r3, [r5, #0]
24009f72:	f003 0380 	and.w	r3, r3, #128	@ 0x80
24009f76:	61e3      	str	r3, [r4, #28]
  {
    RCC_OscInitStruct->CSIState = RCC_CSI_OFF;
  }

#if defined(RCC_VER_X)
  if(HAL_GetREVID() <= REV_ID_Y)
24009f78:	f7f6 fd1f 	bl	240009ba <HAL_GetREVID>
24009f7c:	f241 0303 	movw	r3, #4099	@ 0x1003
24009f80:	4298      	cmp	r0, r3
24009f82:	d857      	bhi.n	2400a034 <HAL_RCC_GetOscConfig+0xdc>
  {
    RCC_OscInitStruct->CSICalibrationValue = (uint32_t)(READ_BIT(RCC->HSICFGR, HAL_RCC_REV_Y_CSITRIM_Msk) >> HAL_RCC_REV_Y_CSITRIM_Pos);
24009f84:	686b      	ldr	r3, [r5, #4]
24009f86:	f3c3 6384 	ubfx	r3, r3, #26, #5
#else
 RCC_OscInitStruct->CSICalibrationValue = (uint32_t)(READ_BIT(RCC->CSICFGR, RCC_CSICFGR_CSITRIM) >> RCC_CSICFGR_CSITRIM_Pos);
#endif /*RCC_VER_X*/

  /* Get the HSI configuration -----------------------------------------------*/
  if((RCC->CR &RCC_CR_HSION) == RCC_CR_HSION)
24009f8a:	4d2d      	ldr	r5, [pc, #180]	@ (2400a040 <HAL_RCC_GetOscConfig+0xe8>)
24009f8c:	6223      	str	r3, [r4, #32]
24009f8e:	682b      	ldr	r3, [r5, #0]
24009f90:	f003 0301 	and.w	r3, r3, #1
24009f94:	60e3      	str	r3, [r4, #12]
  {
    RCC_OscInitStruct->HSIState = RCC_HSI_OFF;
  }

#if defined(RCC_VER_X)
  if(HAL_GetREVID() <= REV_ID_Y)
24009f96:	f7f6 fd10 	bl	240009ba <HAL_GetREVID>
24009f9a:	f241 0303 	movw	r3, #4099	@ 0x1003
24009f9e:	4298      	cmp	r0, r3
  {
    RCC_OscInitStruct->HSICalibrationValue = (uint32_t)(READ_BIT(RCC->HSICFGR, HAL_RCC_REV_Y_HSITRIM_Msk) >> HAL_RCC_REV_Y_HSITRIM_Pos);
24009fa0:	686b      	ldr	r3, [r5, #4]
24009fa2:	bf94      	ite	ls
24009fa4:	f3c3 3305 	ubfxls	r3, r3, #12, #6
  }
  else
  {
    RCC_OscInitStruct->HSICalibrationValue = (uint32_t)(READ_BIT(RCC->HSICFGR, RCC_HSICFGR_HSITRIM) >> RCC_HSICFGR_HSITRIM_Pos);
24009fa8:	f3c3 6306 	ubfxhi	r3, r3, #24, #7
24009fac:	6123      	str	r3, [r4, #16]
  else
  {
    RCC_OscInitStruct->LSEState = RCC_LSE_OFF;
  }
#else
  if((RCC->BDCR &RCC_BDCR_LSEBYP) == RCC_BDCR_LSEBYP)
24009fae:	6f2b      	ldr	r3, [r5, #112]	@ 0x70
24009fb0:	075b      	lsls	r3, r3, #29
24009fb2:	d443      	bmi.n	2400a03c <HAL_RCC_GetOscConfig+0xe4>
  {
    RCC_OscInitStruct->LSEState = RCC_LSE_BYPASS;
  }
  else if((RCC->BDCR &RCC_BDCR_LSEON) == RCC_BDCR_LSEON)
24009fb4:	6f2b      	ldr	r3, [r5, #112]	@ 0x70
24009fb6:	f003 0301 	and.w	r3, r3, #1
    RCC_OscInitStruct->LSEState = RCC_LSE_BYPASS;
24009fba:	60a3      	str	r3, [r4, #8]
    RCC_OscInitStruct->LSEState = RCC_LSE_OFF;
  }
#endif /* RCC_BDCR_LSEEXT */

  /* Get the LSI configuration -----------------------------------------------*/
  if((RCC->CSR &RCC_CSR_LSION) == RCC_CSR_LSION)
24009fbc:	4b20      	ldr	r3, [pc, #128]	@ (2400a040 <HAL_RCC_GetOscConfig+0xe8>)
24009fbe:	6f5a      	ldr	r2, [r3, #116]	@ 0x74
24009fc0:	f002 0201 	and.w	r2, r2, #1
24009fc4:	6162      	str	r2, [r4, #20]
  {
    RCC_OscInitStruct->LSIState = RCC_LSI_OFF;
  }

  /* Get the HSI48 configuration ---------------------------------------------*/
  if((RCC->CR & RCC_CR_HSI48ON) == RCC_CR_HSI48ON)
24009fc6:	681a      	ldr	r2, [r3, #0]
24009fc8:	f3c2 3200 	ubfx	r2, r2, #12, #1
24009fcc:	61a2      	str	r2, [r4, #24]
  {
    RCC_OscInitStruct->HSI48State = RCC_HSI48_OFF;
  }

  /* Get the PLL configuration -----------------------------------------------*/
  if((RCC->CR &RCC_CR_PLLON) == RCC_CR_PLLON)
24009fce:	681a      	ldr	r2, [r3, #0]
  {
    RCC_OscInitStruct->PLL.PLLState = RCC_PLL_ON;
24009fd0:	f012 7f80 	tst.w	r2, #16777216	@ 0x1000000
24009fd4:	bf0c      	ite	eq
24009fd6:	2201      	moveq	r2, #1
24009fd8:	2202      	movne	r2, #2
24009fda:	6262      	str	r2, [r4, #36]	@ 0x24
  }
  else
  {
    RCC_OscInitStruct->PLL.PLLState = RCC_PLL_OFF;
  }
  RCC_OscInitStruct->PLL.PLLSource = (uint32_t)(RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
24009fdc:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
24009fde:	f002 0203 	and.w	r2, r2, #3
24009fe2:	62a2      	str	r2, [r4, #40]	@ 0x28
  RCC_OscInitStruct->PLL.PLLM = (uint32_t)((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM1)>> RCC_PLLCKSELR_DIVM1_Pos);
24009fe4:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
24009fe6:	f3c2 1205 	ubfx	r2, r2, #4, #6
24009fea:	62e2      	str	r2, [r4, #44]	@ 0x2c
  RCC_OscInitStruct->PLL.PLLN = (uint32_t)((RCC->PLL1DIVR & RCC_PLL1DIVR_N1) >> RCC_PLL1DIVR_N1_Pos)+ 1U;
24009fec:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
24009fee:	f3c2 0208 	ubfx	r2, r2, #0, #9
24009ff2:	3201      	adds	r2, #1
24009ff4:	6322      	str	r2, [r4, #48]	@ 0x30
  RCC_OscInitStruct->PLL.PLLR = (uint32_t)((RCC->PLL1DIVR & RCC_PLL1DIVR_R1) >> RCC_PLL1DIVR_R1_Pos)+ 1U;
24009ff6:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
24009ff8:	f3c2 6206 	ubfx	r2, r2, #24, #7
24009ffc:	3201      	adds	r2, #1
24009ffe:	63e2      	str	r2, [r4, #60]	@ 0x3c
  RCC_OscInitStruct->PLL.PLLP = (uint32_t)((RCC->PLL1DIVR & RCC_PLL1DIVR_P1) >> RCC_PLL1DIVR_P1_Pos)+ 1U;
2400a000:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
2400a002:	f3c2 2246 	ubfx	r2, r2, #9, #7
2400a006:	3201      	adds	r2, #1
2400a008:	6362      	str	r2, [r4, #52]	@ 0x34
  RCC_OscInitStruct->PLL.PLLQ = (uint32_t)((RCC->PLL1DIVR & RCC_PLL1DIVR_Q1) >> RCC_PLL1DIVR_Q1_Pos)+ 1U;
2400a00a:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
2400a00c:	f3c2 4206 	ubfx	r2, r2, #16, #7
2400a010:	3201      	adds	r2, #1
2400a012:	63a2      	str	r2, [r4, #56]	@ 0x38
  RCC_OscInitStruct->PLL.PLLRGE = (uint32_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLL1RGE));
2400a014:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
2400a016:	f002 020c 	and.w	r2, r2, #12
2400a01a:	6422      	str	r2, [r4, #64]	@ 0x40
  RCC_OscInitStruct->PLL.PLLVCOSEL = (uint32_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLL1VCOSEL) >> RCC_PLLCFGR_PLL1VCOSEL_Pos);
2400a01c:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
2400a01e:	f3c2 0240 	ubfx	r2, r2, #1, #1
2400a022:	6462      	str	r2, [r4, #68]	@ 0x44
  RCC_OscInitStruct->PLL.PLLFRACN = (uint32_t)(((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1) >> RCC_PLL1FRACR_FRACN1_Pos));
2400a024:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
2400a026:	f3c3 03cc 	ubfx	r3, r3, #3, #13
2400a02a:	64a3      	str	r3, [r4, #72]	@ 0x48
}
2400a02c:	bd38      	pop	{r3, r4, r5, pc}
2400a02e:	f44f 23a0 	mov.w	r3, #327680	@ 0x50000
2400a032:	e79c      	b.n	24009f6e <HAL_RCC_GetOscConfig+0x16>
    RCC_OscInitStruct->CSICalibrationValue = (uint32_t)(READ_BIT(RCC->CSICFGR, RCC_CSICFGR_CSITRIM) >> RCC_CSICFGR_CSITRIM_Pos);
2400a034:	68eb      	ldr	r3, [r5, #12]
2400a036:	f3c3 6305 	ubfx	r3, r3, #24, #6
2400a03a:	e7a6      	b.n	24009f8a <HAL_RCC_GetOscConfig+0x32>
2400a03c:	2305      	movs	r3, #5
2400a03e:	e7bc      	b.n	24009fba <HAL_RCC_GetOscConfig+0x62>
2400a040:	58024400 	.word	0x58024400

2400a044 <HAL_RCC_GetClockConfig>:
  * @retval None
  */
void HAL_RCC_GetClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t *pFLatency)
{
  /* Set all possible values for the Clock type parameter --------------------*/
  RCC_ClkInitStruct->ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_D1PCLK1 | RCC_CLOCKTYPE_PCLK1 |
2400a044:	233f      	movs	r3, #63	@ 0x3f
2400a046:	6003      	str	r3, [r0, #0]
                                 RCC_CLOCKTYPE_PCLK2 |  RCC_CLOCKTYPE_D3PCLK1  ;

  /* Get the SYSCLK configuration --------------------------------------------*/
  RCC_ClkInitStruct->SYSCLKSource = (uint32_t)(RCC->CFGR & RCC_CFGR_SW);
2400a048:	4b11      	ldr	r3, [pc, #68]	@ (2400a090 <HAL_RCC_GetClockConfig+0x4c>)
2400a04a:	691a      	ldr	r2, [r3, #16]
2400a04c:	f002 0207 	and.w	r2, r2, #7
2400a050:	6042      	str	r2, [r0, #4]

#if defined(RCC_D1CFGR_D1CPRE)
  /* Get the SYSCLK configuration ----------------------------------------------*/
  RCC_ClkInitStruct->SYSCLKDivider = (uint32_t)(RCC->D1CFGR & RCC_D1CFGR_D1CPRE);
2400a052:	699a      	ldr	r2, [r3, #24]
2400a054:	f402 6270 	and.w	r2, r2, #3840	@ 0xf00
2400a058:	6082      	str	r2, [r0, #8]

  /* Get the D1HCLK configuration ----------------------------------------------*/
  RCC_ClkInitStruct->AHBCLKDivider = (uint32_t)(RCC->D1CFGR & RCC_D1CFGR_HPRE);
2400a05a:	699a      	ldr	r2, [r3, #24]
2400a05c:	f002 020f 	and.w	r2, r2, #15
2400a060:	60c2      	str	r2, [r0, #12]

  /* Get the APB3 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB3CLKDivider = (uint32_t)(RCC->D1CFGR & RCC_D1CFGR_D1PPRE);
2400a062:	699a      	ldr	r2, [r3, #24]
2400a064:	f002 0270 	and.w	r2, r2, #112	@ 0x70
2400a068:	6102      	str	r2, [r0, #16]

  /* Get the APB1 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB1CLKDivider = (uint32_t)(RCC->D2CFGR & RCC_D2CFGR_D2PPRE1);
2400a06a:	69da      	ldr	r2, [r3, #28]
2400a06c:	f002 0270 	and.w	r2, r2, #112	@ 0x70
2400a070:	6142      	str	r2, [r0, #20]

  /* Get the APB2 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB2CLKDivider = (uint32_t)(RCC->D2CFGR & RCC_D2CFGR_D2PPRE2);
2400a072:	69da      	ldr	r2, [r3, #28]
2400a074:	f402 62e0 	and.w	r2, r2, #1792	@ 0x700
2400a078:	6182      	str	r2, [r0, #24]

  /* Get the APB4 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB4CLKDivider = (uint32_t)(RCC->D3CFGR & RCC_D3CFGR_D3PPRE);
2400a07a:	6a1b      	ldr	r3, [r3, #32]
2400a07c:	f003 0370 	and.w	r3, r3, #112	@ 0x70
2400a080:	61c3      	str	r3, [r0, #28]
  /* Get the APB4 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB4CLKDivider = (uint32_t)(RCC->SRDCFGR & RCC_SRDCFGR_SRDPPRE);
#endif

  /* Get the Flash Wait State (Latency) configuration ------------------------*/
  *pFLatency = (uint32_t)(FLASH->ACR & FLASH_ACR_LATENCY);
2400a082:	4b04      	ldr	r3, [pc, #16]	@ (2400a094 <HAL_RCC_GetClockConfig+0x50>)
2400a084:	681b      	ldr	r3, [r3, #0]
2400a086:	f003 030f 	and.w	r3, r3, #15
2400a08a:	600b      	str	r3, [r1, #0]
}
2400a08c:	4770      	bx	lr
2400a08e:	bf00      	nop
2400a090:	58024400 	.word	0x58024400
2400a094:	52002000 	.word	0x52002000

2400a098 <HAL_RCC_CSSCallback>:
__weak void HAL_RCC_CCSCallback(void)
{
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_RCC_CCSCallback could be implemented in the user file
   */
}
2400a098:	4770      	bx	lr

2400a09a <HAL_RCC_NMI_IRQHandler>:
{
2400a09a:	b510      	push	{r4, lr}
  if(__HAL_RCC_GET_IT(RCC_IT_CSS))
2400a09c:	4c04      	ldr	r4, [pc, #16]	@ (2400a0b0 <HAL_RCC_NMI_IRQHandler+0x16>)
2400a09e:	6e63      	ldr	r3, [r4, #100]	@ 0x64
2400a0a0:	055b      	lsls	r3, r3, #21
2400a0a2:	d504      	bpl.n	2400a0ae <HAL_RCC_NMI_IRQHandler+0x14>
    HAL_RCC_CCSCallback();
2400a0a4:	f7ff fff8 	bl	2400a098 <HAL_RCC_CSSCallback>
    __HAL_RCC_CLEAR_IT(RCC_IT_CSS);
2400a0a8:	f44f 6380 	mov.w	r3, #1024	@ 0x400
2400a0ac:	66a3      	str	r3, [r4, #104]	@ 0x68
}
2400a0ae:	bd10      	pop	{r4, pc}
2400a0b0:	58024400 	.word	0x58024400

2400a0b4 <RCCEx_PLL2_Config>:
  * @note   PLL2 is temporary disabled to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLL2_Config(RCC_PLL2InitTypeDef *pll2, uint32_t Divider)
{
2400a0b4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  assert_param(IS_RCC_PLL2RGE_VALUE(pll2->PLL2RGE));
  assert_param(IS_RCC_PLL2VCO_VALUE(pll2->PLL2VCOSEL));
  assert_param(IS_RCC_PLLFRACN_VALUE(pll2->PLL2FRACN));

  /* Check that PLL2 OSC clock source is already set */
  if(__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_NONE)
2400a0b6:	4c3a      	ldr	r4, [pc, #232]	@ (2400a1a0 <RCCEx_PLL2_Config+0xec>)
{
2400a0b8:	4606      	mov	r6, r0
2400a0ba:	460d      	mov	r5, r1
  if(__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_NONE)
2400a0bc:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
2400a0be:	f003 0303 	and.w	r3, r3, #3
2400a0c2:	2b03      	cmp	r3, #3
2400a0c4:	d069      	beq.n	2400a19a <RCCEx_PLL2_Config+0xe6>


  else
  {
    /* Disable  PLL2. */
    __HAL_RCC_PLL2_DISABLE();
2400a0c6:	6823      	ldr	r3, [r4, #0]
2400a0c8:	f023 6380 	bic.w	r3, r3, #67108864	@ 0x4000000
2400a0cc:	6023      	str	r3, [r4, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
2400a0ce:	f007 fe9b 	bl	24011e08 <HAL_GetTick>
2400a0d2:	4607      	mov	r7, r0

    /* Wait till PLL is disabled */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) != 0U)
2400a0d4:	6823      	ldr	r3, [r4, #0]
2400a0d6:	011a      	lsls	r2, r3, #4
2400a0d8:	d44b      	bmi.n	2400a172 <RCCEx_PLL2_Config+0xbe>
        return HAL_TIMEOUT;
      }
    }

    /* Configure PLL2 multiplication and division factors. */
    __HAL_RCC_PLL2_CONFIG(pll2->PLL2M,
2400a0da:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
2400a0dc:	6832      	ldr	r2, [r6, #0]
2400a0de:	f423 337c 	bic.w	r3, r3, #258048	@ 0x3f000
2400a0e2:	ea43 3302 	orr.w	r3, r3, r2, lsl #12
2400a0e6:	62a3      	str	r3, [r4, #40]	@ 0x28
2400a0e8:	68b3      	ldr	r3, [r6, #8]
2400a0ea:	68f2      	ldr	r2, [r6, #12]
2400a0ec:	3b01      	subs	r3, #1
2400a0ee:	3a01      	subs	r2, #1
2400a0f0:	025b      	lsls	r3, r3, #9
2400a0f2:	0412      	lsls	r2, r2, #16
2400a0f4:	b29b      	uxth	r3, r3
2400a0f6:	f402 02fe 	and.w	r2, r2, #8323072	@ 0x7f0000
2400a0fa:	4313      	orrs	r3, r2
2400a0fc:	6872      	ldr	r2, [r6, #4]
2400a0fe:	3a01      	subs	r2, #1
2400a100:	f3c2 0208 	ubfx	r2, r2, #0, #9
2400a104:	4313      	orrs	r3, r2
2400a106:	6932      	ldr	r2, [r6, #16]
2400a108:	3a01      	subs	r2, #1
2400a10a:	0612      	lsls	r2, r2, #24
2400a10c:	f002 42fe 	and.w	r2, r2, #2130706432	@ 0x7f000000
2400a110:	4313      	orrs	r3, r2
2400a112:	63a3      	str	r3, [r4, #56]	@ 0x38
                          pll2->PLL2P,
                          pll2->PLL2Q,
                          pll2->PLL2R);

    /* Select PLL2 input reference frequency range: VCI */
    __HAL_RCC_PLL2_VCIRANGE(pll2->PLL2RGE) ;
2400a114:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
2400a116:	6972      	ldr	r2, [r6, #20]
2400a118:	f023 03c0 	bic.w	r3, r3, #192	@ 0xc0
2400a11c:	4313      	orrs	r3, r2
2400a11e:	62e3      	str	r3, [r4, #44]	@ 0x2c

    /* Select PLL2 output frequency range : VCO */
    __HAL_RCC_PLL2_VCORANGE(pll2->PLL2VCOSEL) ;
2400a120:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
2400a122:	69b2      	ldr	r2, [r6, #24]
2400a124:	f023 0320 	bic.w	r3, r3, #32
2400a128:	4313      	orrs	r3, r2
2400a12a:	62e3      	str	r3, [r4, #44]	@ 0x2c

    /* Disable PLL2FRACN . */
    __HAL_RCC_PLL2FRACN_DISABLE();
2400a12c:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
2400a12e:	f023 0310 	bic.w	r3, r3, #16
2400a132:	62e3      	str	r3, [r4, #44]	@ 0x2c

    /* Configures PLL2 clock Fractional Part Of The Multiplication Factor */
    __HAL_RCC_PLL2FRACN_CONFIG(pll2->PLL2FRACN);
2400a134:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
2400a136:	69f2      	ldr	r2, [r6, #28]
2400a138:	f423 437f 	bic.w	r3, r3, #65280	@ 0xff00
2400a13c:	f023 03f8 	bic.w	r3, r3, #248	@ 0xf8
2400a140:	ea43 03c2 	orr.w	r3, r3, r2, lsl #3
2400a144:	63e3      	str	r3, [r4, #60]	@ 0x3c

    /* Enable PLL2FRACN . */
    __HAL_RCC_PLL2FRACN_ENABLE();
2400a146:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
2400a148:	f043 0310 	orr.w	r3, r3, #16
2400a14c:	62e3      	str	r3, [r4, #44]	@ 0x2c

    /* Enable the PLL2 clock output */
    if(Divider == DIVIDER_P_UPDATE)
    {
      __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL2_DIVP);
2400a14e:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
    if(Divider == DIVIDER_P_UPDATE)
2400a150:	b9b5      	cbnz	r5, 2400a180 <RCCEx_PLL2_Config+0xcc>
      __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL2_DIVP);
2400a152:	f443 2300 	orr.w	r3, r3, #524288	@ 0x80000
    {
      __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL2_DIVQ);
    }
    else
    {
      __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL2_DIVR);
2400a156:	62e3      	str	r3, [r4, #44]	@ 0x2c
    }

    /* Enable  PLL2. */
    __HAL_RCC_PLL2_ENABLE();
2400a158:	4c11      	ldr	r4, [pc, #68]	@ (2400a1a0 <RCCEx_PLL2_Config+0xec>)
2400a15a:	6823      	ldr	r3, [r4, #0]
2400a15c:	f043 6380 	orr.w	r3, r3, #67108864	@ 0x4000000
2400a160:	6023      	str	r3, [r4, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
2400a162:	f007 fe51 	bl	24011e08 <HAL_GetTick>
2400a166:	4605      	mov	r5, r0

    /* Wait till PLL2 is ready */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) == 0U)
2400a168:	6823      	ldr	r3, [r4, #0]
2400a16a:	011b      	lsls	r3, r3, #4
2400a16c:	d50f      	bpl.n	2400a18e <RCCEx_PLL2_Config+0xda>
    }

  }


  return status;
2400a16e:	2000      	movs	r0, #0
2400a170:	e005      	b.n	2400a17e <RCCEx_PLL2_Config+0xca>
      if( (HAL_GetTick() - tickstart ) > PLL2_TIMEOUT_VALUE)
2400a172:	f007 fe49 	bl	24011e08 <HAL_GetTick>
2400a176:	1bc0      	subs	r0, r0, r7
2400a178:	2802      	cmp	r0, #2
2400a17a:	d9ab      	bls.n	2400a0d4 <RCCEx_PLL2_Config+0x20>
        return HAL_TIMEOUT;
2400a17c:	2003      	movs	r0, #3
}
2400a17e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    else if(Divider == DIVIDER_Q_UPDATE)
2400a180:	2d01      	cmp	r5, #1
      __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL2_DIVQ);
2400a182:	bf0c      	ite	eq
2400a184:	f443 1380 	orreq.w	r3, r3, #1048576	@ 0x100000
      __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL2_DIVR);
2400a188:	f443 1300 	orrne.w	r3, r3, #2097152	@ 0x200000
2400a18c:	e7e3      	b.n	2400a156 <RCCEx_PLL2_Config+0xa2>
      if( (HAL_GetTick() - tickstart ) > PLL2_TIMEOUT_VALUE)
2400a18e:	f007 fe3b 	bl	24011e08 <HAL_GetTick>
2400a192:	1b40      	subs	r0, r0, r5
2400a194:	2802      	cmp	r0, #2
2400a196:	d9e7      	bls.n	2400a168 <RCCEx_PLL2_Config+0xb4>
2400a198:	e7f0      	b.n	2400a17c <RCCEx_PLL2_Config+0xc8>
    return HAL_ERROR;
2400a19a:	2001      	movs	r0, #1
2400a19c:	e7ef      	b.n	2400a17e <RCCEx_PLL2_Config+0xca>
2400a19e:	bf00      	nop
2400a1a0:	58024400 	.word	0x58024400

2400a1a4 <RCCEx_PLL3_Config>:
  * @note   PLL3 is temporary disabled to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLL3_Config(RCC_PLL3InitTypeDef *pll3, uint32_t Divider)
{
2400a1a4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  assert_param(IS_RCC_PLL3RGE_VALUE(pll3->PLL3RGE));
  assert_param(IS_RCC_PLL3VCO_VALUE(pll3->PLL3VCOSEL));
  assert_param(IS_RCC_PLLFRACN_VALUE(pll3->PLL3FRACN));

  /* Check that PLL3 OSC clock source is already set */
  if(__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_NONE)
2400a1a6:	4c3a      	ldr	r4, [pc, #232]	@ (2400a290 <RCCEx_PLL3_Config+0xec>)
{
2400a1a8:	4606      	mov	r6, r0
2400a1aa:	460d      	mov	r5, r1
  if(__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_NONE)
2400a1ac:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
2400a1ae:	f003 0303 	and.w	r3, r3, #3
2400a1b2:	2b03      	cmp	r3, #3
2400a1b4:	d069      	beq.n	2400a28a <RCCEx_PLL3_Config+0xe6>


  else
  {
    /* Disable  PLL3. */
    __HAL_RCC_PLL3_DISABLE();
2400a1b6:	6823      	ldr	r3, [r4, #0]
2400a1b8:	f023 5380 	bic.w	r3, r3, #268435456	@ 0x10000000
2400a1bc:	6023      	str	r3, [r4, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
2400a1be:	f007 fe23 	bl	24011e08 <HAL_GetTick>
2400a1c2:	4607      	mov	r7, r0
    /* Wait till PLL3 is ready */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) != 0U)
2400a1c4:	6823      	ldr	r3, [r4, #0]
2400a1c6:	009a      	lsls	r2, r3, #2
2400a1c8:	d44b      	bmi.n	2400a262 <RCCEx_PLL3_Config+0xbe>
        return HAL_TIMEOUT;
      }
    }

    /* Configure the PLL3  multiplication and division factors. */
    __HAL_RCC_PLL3_CONFIG(pll3->PLL3M,
2400a1ca:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
2400a1cc:	6832      	ldr	r2, [r6, #0]
2400a1ce:	f023 737c 	bic.w	r3, r3, #66060288	@ 0x3f00000
2400a1d2:	ea43 5302 	orr.w	r3, r3, r2, lsl #20
2400a1d6:	62a3      	str	r3, [r4, #40]	@ 0x28
2400a1d8:	68b3      	ldr	r3, [r6, #8]
2400a1da:	68f2      	ldr	r2, [r6, #12]
2400a1dc:	3b01      	subs	r3, #1
2400a1de:	3a01      	subs	r2, #1
2400a1e0:	025b      	lsls	r3, r3, #9
2400a1e2:	0412      	lsls	r2, r2, #16
2400a1e4:	b29b      	uxth	r3, r3
2400a1e6:	f402 02fe 	and.w	r2, r2, #8323072	@ 0x7f0000
2400a1ea:	4313      	orrs	r3, r2
2400a1ec:	6872      	ldr	r2, [r6, #4]
2400a1ee:	3a01      	subs	r2, #1
2400a1f0:	f3c2 0208 	ubfx	r2, r2, #0, #9
2400a1f4:	4313      	orrs	r3, r2
2400a1f6:	6932      	ldr	r2, [r6, #16]
2400a1f8:	3a01      	subs	r2, #1
2400a1fa:	0612      	lsls	r2, r2, #24
2400a1fc:	f002 42fe 	and.w	r2, r2, #2130706432	@ 0x7f000000
2400a200:	4313      	orrs	r3, r2
2400a202:	6423      	str	r3, [r4, #64]	@ 0x40
                          pll3->PLL3P,
                          pll3->PLL3Q,
                          pll3->PLL3R);

    /* Select PLL3 input reference frequency range: VCI */
    __HAL_RCC_PLL3_VCIRANGE(pll3->PLL3RGE) ;
2400a204:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
2400a206:	6972      	ldr	r2, [r6, #20]
2400a208:	f423 6340 	bic.w	r3, r3, #3072	@ 0xc00
2400a20c:	4313      	orrs	r3, r2
2400a20e:	62e3      	str	r3, [r4, #44]	@ 0x2c

    /* Select PLL3 output frequency range : VCO */
    __HAL_RCC_PLL3_VCORANGE(pll3->PLL3VCOSEL) ;
2400a210:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
2400a212:	69b2      	ldr	r2, [r6, #24]
2400a214:	f423 7300 	bic.w	r3, r3, #512	@ 0x200
2400a218:	4313      	orrs	r3, r2
2400a21a:	62e3      	str	r3, [r4, #44]	@ 0x2c

    /* Disable PLL3FRACN . */
    __HAL_RCC_PLL3FRACN_DISABLE();
2400a21c:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
2400a21e:	f423 7380 	bic.w	r3, r3, #256	@ 0x100
2400a222:	62e3      	str	r3, [r4, #44]	@ 0x2c

    /* Configures PLL3 clock Fractional Part Of The Multiplication Factor */
    __HAL_RCC_PLL3FRACN_CONFIG(pll3->PLL3FRACN);
2400a224:	6c63      	ldr	r3, [r4, #68]	@ 0x44
2400a226:	69f2      	ldr	r2, [r6, #28]
2400a228:	f423 437f 	bic.w	r3, r3, #65280	@ 0xff00
2400a22c:	f023 03f8 	bic.w	r3, r3, #248	@ 0xf8
2400a230:	ea43 03c2 	orr.w	r3, r3, r2, lsl #3
2400a234:	6463      	str	r3, [r4, #68]	@ 0x44

    /* Enable PLL3FRACN . */
    __HAL_RCC_PLL3FRACN_ENABLE();
2400a236:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
2400a238:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
2400a23c:	62e3      	str	r3, [r4, #44]	@ 0x2c

    /* Enable the PLL3 clock output */
    if(Divider == DIVIDER_P_UPDATE)
    {
      __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVP);
2400a23e:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
    if(Divider == DIVIDER_P_UPDATE)
2400a240:	b9b5      	cbnz	r5, 2400a270 <RCCEx_PLL3_Config+0xcc>
      __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVP);
2400a242:	f443 0380 	orr.w	r3, r3, #4194304	@ 0x400000
    {
      __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVQ);
    }
    else
    {
      __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVR);
2400a246:	62e3      	str	r3, [r4, #44]	@ 0x2c
    }

    /* Enable  PLL3. */
    __HAL_RCC_PLL3_ENABLE();
2400a248:	4c11      	ldr	r4, [pc, #68]	@ (2400a290 <RCCEx_PLL3_Config+0xec>)
2400a24a:	6823      	ldr	r3, [r4, #0]
2400a24c:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
2400a250:	6023      	str	r3, [r4, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
2400a252:	f007 fdd9 	bl	24011e08 <HAL_GetTick>
2400a256:	4605      	mov	r5, r0

    /* Wait till PLL3 is ready */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) == 0U)
2400a258:	6823      	ldr	r3, [r4, #0]
2400a25a:	009b      	lsls	r3, r3, #2
2400a25c:	d50f      	bpl.n	2400a27e <RCCEx_PLL3_Config+0xda>
    }

  }


  return status;
2400a25e:	2000      	movs	r0, #0
2400a260:	e005      	b.n	2400a26e <RCCEx_PLL3_Config+0xca>
      if( (HAL_GetTick() - tickstart ) > PLL3_TIMEOUT_VALUE)
2400a262:	f007 fdd1 	bl	24011e08 <HAL_GetTick>
2400a266:	1bc0      	subs	r0, r0, r7
2400a268:	2802      	cmp	r0, #2
2400a26a:	d9ab      	bls.n	2400a1c4 <RCCEx_PLL3_Config+0x20>
        return HAL_TIMEOUT;
2400a26c:	2003      	movs	r0, #3
}
2400a26e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    else if(Divider == DIVIDER_Q_UPDATE)
2400a270:	2d01      	cmp	r5, #1
      __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVQ);
2400a272:	bf0c      	ite	eq
2400a274:	f443 0300 	orreq.w	r3, r3, #8388608	@ 0x800000
      __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVR);
2400a278:	f043 7380 	orrne.w	r3, r3, #16777216	@ 0x1000000
2400a27c:	e7e3      	b.n	2400a246 <RCCEx_PLL3_Config+0xa2>
      if( (HAL_GetTick() - tickstart ) > PLL3_TIMEOUT_VALUE)
2400a27e:	f007 fdc3 	bl	24011e08 <HAL_GetTick>
2400a282:	1b40      	subs	r0, r0, r5
2400a284:	2802      	cmp	r0, #2
2400a286:	d9e7      	bls.n	2400a258 <RCCEx_PLL3_Config+0xb4>
2400a288:	e7f0      	b.n	2400a26c <RCCEx_PLL3_Config+0xc8>
    return HAL_ERROR;
2400a28a:	2001      	movs	r0, #1
2400a28c:	e7ef      	b.n	2400a26e <RCCEx_PLL3_Config+0xca>
2400a28e:	bf00      	nop
2400a290:	58024400 	.word	0x58024400

2400a294 <HAL_RCCEx_PeriphCLKConfig>:
{
2400a294:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPDIFRX) == RCC_PERIPHCLK_SPDIFRX)
2400a298:	6803      	ldr	r3, [r0, #0]
{
2400a29a:	4605      	mov	r5, r0
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPDIFRX) == RCC_PERIPHCLK_SPDIFRX)
2400a29c:	011e      	lsls	r6, r3, #4
2400a29e:	d51e      	bpl.n	2400a2de <HAL_RCCEx_PeriphCLKConfig+0x4a>
    switch(PeriphClkInit->SpdifrxClockSelection)
2400a2a0:	6e43      	ldr	r3, [r0, #100]	@ 0x64
2400a2a2:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
2400a2a6:	d02a      	beq.n	2400a2fe <HAL_RCCEx_PeriphCLKConfig+0x6a>
2400a2a8:	d80f      	bhi.n	2400a2ca <HAL_RCCEx_PeriphCLKConfig+0x36>
2400a2aa:	b1d3      	cbz	r3, 2400a2e2 <HAL_RCCEx_PeriphCLKConfig+0x4e>
2400a2ac:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
2400a2b0:	d01d      	beq.n	2400a2ee <HAL_RCCEx_PeriphCLKConfig+0x5a>
2400a2b2:	2601      	movs	r6, #1
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1)
2400a2b4:	682b      	ldr	r3, [r5, #0]
2400a2b6:	05dc      	lsls	r4, r3, #23
2400a2b8:	d54e      	bpl.n	2400a358 <HAL_RCCEx_PeriphCLKConfig+0xc4>
    switch(PeriphClkInit->Sai1ClockSelection)
2400a2ba:	6d6b      	ldr	r3, [r5, #84]	@ 0x54
2400a2bc:	2b04      	cmp	r3, #4
2400a2be:	d84a      	bhi.n	2400a356 <HAL_RCCEx_PeriphCLKConfig+0xc2>
2400a2c0:	e8df f003 	tbb	[pc, r3]
2400a2c4:	27433d22 	.word	0x27433d22
2400a2c8:	27          	.byte	0x27
2400a2c9:	00          	.byte	0x00
    switch(PeriphClkInit->SpdifrxClockSelection)
2400a2ca:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
2400a2ce:	d1f0      	bne.n	2400a2b2 <HAL_RCCEx_PeriphCLKConfig+0x1e>
      __HAL_RCC_SPDIFRX_CONFIG(PeriphClkInit->SpdifrxClockSelection);
2400a2d0:	4a82      	ldr	r2, [pc, #520]	@ (2400a4dc <HAL_RCCEx_PeriphCLKConfig+0x248>)
2400a2d2:	6e69      	ldr	r1, [r5, #100]	@ 0x64
2400a2d4:	6d13      	ldr	r3, [r2, #80]	@ 0x50
2400a2d6:	f423 1340 	bic.w	r3, r3, #3145728	@ 0x300000
2400a2da:	430b      	orrs	r3, r1
2400a2dc:	6513      	str	r3, [r2, #80]	@ 0x50
  HAL_StatusTypeDef ret = HAL_OK;      /* Intermediate status */
2400a2de:	2600      	movs	r6, #0
2400a2e0:	e7e8      	b.n	2400a2b4 <HAL_RCCEx_PeriphCLKConfig+0x20>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
2400a2e2:	4a7e      	ldr	r2, [pc, #504]	@ (2400a4dc <HAL_RCCEx_PeriphCLKConfig+0x248>)
2400a2e4:	6ad3      	ldr	r3, [r2, #44]	@ 0x2c
2400a2e6:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
2400a2ea:	62d3      	str	r3, [r2, #44]	@ 0x2c
    if(ret == HAL_OK)
2400a2ec:	e7f0      	b.n	2400a2d0 <HAL_RCCEx_PeriphCLKConfig+0x3c>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_R_UPDATE);
2400a2ee:	2102      	movs	r1, #2
2400a2f0:	3004      	adds	r0, #4
2400a2f2:	f7ff fedf 	bl	2400a0b4 <RCCEx_PLL2_Config>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE);
2400a2f6:	4606      	mov	r6, r0
    if(ret == HAL_OK)
2400a2f8:	2800      	cmp	r0, #0
2400a2fa:	d1db      	bne.n	2400a2b4 <HAL_RCCEx_PeriphCLKConfig+0x20>
2400a2fc:	e7e8      	b.n	2400a2d0 <HAL_RCCEx_PeriphCLKConfig+0x3c>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE);
2400a2fe:	2102      	movs	r1, #2
2400a300:	3024      	adds	r0, #36	@ 0x24
2400a302:	f7ff ff4f 	bl	2400a1a4 <RCCEx_PLL3_Config>
2400a306:	e7f6      	b.n	2400a2f6 <HAL_RCCEx_PeriphCLKConfig+0x62>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
2400a308:	4a74      	ldr	r2, [pc, #464]	@ (2400a4dc <HAL_RCCEx_PeriphCLKConfig+0x248>)
2400a30a:	6ad3      	ldr	r3, [r2, #44]	@ 0x2c
2400a30c:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
2400a310:	62d3      	str	r3, [r2, #44]	@ 0x2c
    switch(PeriphClkInit->SpdifrxClockSelection)
2400a312:	4634      	mov	r4, r6
    if(ret == HAL_OK)
2400a314:	bb14      	cbnz	r4, 2400a35c <HAL_RCCEx_PeriphCLKConfig+0xc8>
      __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
2400a316:	4a71      	ldr	r2, [pc, #452]	@ (2400a4dc <HAL_RCCEx_PeriphCLKConfig+0x248>)
2400a318:	6d69      	ldr	r1, [r5, #84]	@ 0x54
2400a31a:	6d13      	ldr	r3, [r2, #80]	@ 0x50
2400a31c:	f023 0307 	bic.w	r3, r3, #7
2400a320:	430b      	orrs	r3, r1
2400a322:	6513      	str	r3, [r2, #80]	@ 0x50
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI23) == RCC_PERIPHCLK_SAI23)
2400a324:	682b      	ldr	r3, [r5, #0]
2400a326:	0598      	lsls	r0, r3, #22
2400a328:	d527      	bpl.n	2400a37a <HAL_RCCEx_PeriphCLKConfig+0xe6>
    switch(PeriphClkInit->Sai23ClockSelection)
2400a32a:	6dab      	ldr	r3, [r5, #88]	@ 0x58
2400a32c:	2b80      	cmp	r3, #128	@ 0x80
2400a32e:	d041      	beq.n	2400a3b4 <HAL_RCCEx_PeriphCLKConfig+0x120>
2400a330:	d816      	bhi.n	2400a360 <HAL_RCCEx_PeriphCLKConfig+0xcc>
2400a332:	b39b      	cbz	r3, 2400a39c <HAL_RCCEx_PeriphCLKConfig+0x108>
2400a334:	2b40      	cmp	r3, #64	@ 0x40
2400a336:	d037      	beq.n	2400a3a8 <HAL_RCCEx_PeriphCLKConfig+0x114>
2400a338:	2601      	movs	r6, #1
2400a33a:	4634      	mov	r4, r6
2400a33c:	e01d      	b.n	2400a37a <HAL_RCCEx_PeriphCLKConfig+0xe6>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
2400a33e:	2100      	movs	r1, #0
2400a340:	1d28      	adds	r0, r5, #4
2400a342:	f7ff feb7 	bl	2400a0b4 <RCCEx_PLL2_Config>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_P_UPDATE);
2400a346:	4604      	mov	r4, r0
      break;
2400a348:	e7e4      	b.n	2400a314 <HAL_RCCEx_PeriphCLKConfig+0x80>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_P_UPDATE);
2400a34a:	2100      	movs	r1, #0
2400a34c:	f105 0024 	add.w	r0, r5, #36	@ 0x24
2400a350:	f7ff ff28 	bl	2400a1a4 <RCCEx_PLL3_Config>
2400a354:	e7f7      	b.n	2400a346 <HAL_RCCEx_PeriphCLKConfig+0xb2>
    switch(PeriphClkInit->Sai1ClockSelection)
2400a356:	2601      	movs	r6, #1
2400a358:	4634      	mov	r4, r6
2400a35a:	e7e3      	b.n	2400a324 <HAL_RCCEx_PeriphCLKConfig+0x90>
2400a35c:	4626      	mov	r6, r4
2400a35e:	e7e1      	b.n	2400a324 <HAL_RCCEx_PeriphCLKConfig+0x90>
    switch(PeriphClkInit->Sai23ClockSelection)
2400a360:	2bc0      	cmp	r3, #192	@ 0xc0
2400a362:	d002      	beq.n	2400a36a <HAL_RCCEx_PeriphCLKConfig+0xd6>
2400a364:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
2400a368:	d1e6      	bne.n	2400a338 <HAL_RCCEx_PeriphCLKConfig+0xa4>
    if(ret == HAL_OK)
2400a36a:	bb4c      	cbnz	r4, 2400a3c0 <HAL_RCCEx_PeriphCLKConfig+0x12c>
      __HAL_RCC_SAI23_CONFIG(PeriphClkInit->Sai23ClockSelection);
2400a36c:	4a5b      	ldr	r2, [pc, #364]	@ (2400a4dc <HAL_RCCEx_PeriphCLKConfig+0x248>)
2400a36e:	6da9      	ldr	r1, [r5, #88]	@ 0x58
2400a370:	6d13      	ldr	r3, [r2, #80]	@ 0x50
2400a372:	f423 73e0 	bic.w	r3, r3, #448	@ 0x1c0
2400a376:	430b      	orrs	r3, r1
2400a378:	6513      	str	r3, [r2, #80]	@ 0x50
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI4A) == RCC_PERIPHCLK_SAI4A)
2400a37a:	682b      	ldr	r3, [r5, #0]
2400a37c:	0559      	lsls	r1, r3, #21
2400a37e:	d530      	bpl.n	2400a3e2 <HAL_RCCEx_PeriphCLKConfig+0x14e>
    switch(PeriphClkInit->Sai4AClockSelection)
2400a380:	f8d5 30a4 	ldr.w	r3, [r5, #164]	@ 0xa4
2400a384:	f5b3 0f80 	cmp.w	r3, #4194304	@ 0x400000
2400a388:	d047      	beq.n	2400a41a <HAL_RCCEx_PeriphCLKConfig+0x186>
2400a38a:	d81b      	bhi.n	2400a3c4 <HAL_RCCEx_PeriphCLKConfig+0x130>
2400a38c:	2b00      	cmp	r3, #0
2400a38e:	d038      	beq.n	2400a402 <HAL_RCCEx_PeriphCLKConfig+0x16e>
2400a390:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
2400a394:	d03b      	beq.n	2400a40e <HAL_RCCEx_PeriphCLKConfig+0x17a>
2400a396:	2601      	movs	r6, #1
2400a398:	4634      	mov	r4, r6
2400a39a:	e022      	b.n	2400a3e2 <HAL_RCCEx_PeriphCLKConfig+0x14e>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
2400a39c:	4a4f      	ldr	r2, [pc, #316]	@ (2400a4dc <HAL_RCCEx_PeriphCLKConfig+0x248>)
2400a39e:	6ad3      	ldr	r3, [r2, #44]	@ 0x2c
2400a3a0:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
2400a3a4:	62d3      	str	r3, [r2, #44]	@ 0x2c
      break;
2400a3a6:	e7e0      	b.n	2400a36a <HAL_RCCEx_PeriphCLKConfig+0xd6>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
2400a3a8:	2100      	movs	r1, #0
2400a3aa:	1d28      	adds	r0, r5, #4
2400a3ac:	f7ff fe82 	bl	2400a0b4 <RCCEx_PLL2_Config>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_P_UPDATE);
2400a3b0:	4604      	mov	r4, r0
      break;
2400a3b2:	e7da      	b.n	2400a36a <HAL_RCCEx_PeriphCLKConfig+0xd6>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_P_UPDATE);
2400a3b4:	2100      	movs	r1, #0
2400a3b6:	f105 0024 	add.w	r0, r5, #36	@ 0x24
2400a3ba:	f7ff fef3 	bl	2400a1a4 <RCCEx_PLL3_Config>
2400a3be:	e7f7      	b.n	2400a3b0 <HAL_RCCEx_PeriphCLKConfig+0x11c>
2400a3c0:	4626      	mov	r6, r4
2400a3c2:	e7da      	b.n	2400a37a <HAL_RCCEx_PeriphCLKConfig+0xe6>
    switch(PeriphClkInit->Sai4AClockSelection)
2400a3c4:	f5b3 0fc0 	cmp.w	r3, #6291456	@ 0x600000
2400a3c8:	d002      	beq.n	2400a3d0 <HAL_RCCEx_PeriphCLKConfig+0x13c>
2400a3ca:	f5b3 0f00 	cmp.w	r3, #8388608	@ 0x800000
2400a3ce:	d1e2      	bne.n	2400a396 <HAL_RCCEx_PeriphCLKConfig+0x102>
    if(ret == HAL_OK)
2400a3d0:	bb4c      	cbnz	r4, 2400a426 <HAL_RCCEx_PeriphCLKConfig+0x192>
      __HAL_RCC_SAI4A_CONFIG(PeriphClkInit->Sai4AClockSelection);
2400a3d2:	4a42      	ldr	r2, [pc, #264]	@ (2400a4dc <HAL_RCCEx_PeriphCLKConfig+0x248>)
2400a3d4:	f8d5 10a4 	ldr.w	r1, [r5, #164]	@ 0xa4
2400a3d8:	6d93      	ldr	r3, [r2, #88]	@ 0x58
2400a3da:	f423 0360 	bic.w	r3, r3, #14680064	@ 0xe00000
2400a3de:	430b      	orrs	r3, r1
2400a3e0:	6593      	str	r3, [r2, #88]	@ 0x58
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI4B) == RCC_PERIPHCLK_SAI4B)
2400a3e2:	682b      	ldr	r3, [r5, #0]
2400a3e4:	051a      	lsls	r2, r3, #20
2400a3e6:	d52f      	bpl.n	2400a448 <HAL_RCCEx_PeriphCLKConfig+0x1b4>
    switch(PeriphClkInit->Sai4BClockSelection)
2400a3e8:	f8d5 30a8 	ldr.w	r3, [r5, #168]	@ 0xa8
2400a3ec:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
2400a3f0:	d043      	beq.n	2400a47a <HAL_RCCEx_PeriphCLKConfig+0x1e6>
2400a3f2:	d81a      	bhi.n	2400a42a <HAL_RCCEx_PeriphCLKConfig+0x196>
2400a3f4:	b3ab      	cbz	r3, 2400a462 <HAL_RCCEx_PeriphCLKConfig+0x1ce>
2400a3f6:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
2400a3fa:	d038      	beq.n	2400a46e <HAL_RCCEx_PeriphCLKConfig+0x1da>
2400a3fc:	2601      	movs	r6, #1
2400a3fe:	4634      	mov	r4, r6
2400a400:	e022      	b.n	2400a448 <HAL_RCCEx_PeriphCLKConfig+0x1b4>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
2400a402:	4a36      	ldr	r2, [pc, #216]	@ (2400a4dc <HAL_RCCEx_PeriphCLKConfig+0x248>)
2400a404:	6ad3      	ldr	r3, [r2, #44]	@ 0x2c
2400a406:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
2400a40a:	62d3      	str	r3, [r2, #44]	@ 0x2c
      break;
2400a40c:	e7e0      	b.n	2400a3d0 <HAL_RCCEx_PeriphCLKConfig+0x13c>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
2400a40e:	2100      	movs	r1, #0
2400a410:	1d28      	adds	r0, r5, #4
2400a412:	f7ff fe4f 	bl	2400a0b4 <RCCEx_PLL2_Config>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_P_UPDATE);
2400a416:	4604      	mov	r4, r0
      break;
2400a418:	e7da      	b.n	2400a3d0 <HAL_RCCEx_PeriphCLKConfig+0x13c>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_P_UPDATE);
2400a41a:	2100      	movs	r1, #0
2400a41c:	f105 0024 	add.w	r0, r5, #36	@ 0x24
2400a420:	f7ff fec0 	bl	2400a1a4 <RCCEx_PLL3_Config>
2400a424:	e7f7      	b.n	2400a416 <HAL_RCCEx_PeriphCLKConfig+0x182>
2400a426:	4626      	mov	r6, r4
2400a428:	e7db      	b.n	2400a3e2 <HAL_RCCEx_PeriphCLKConfig+0x14e>
    switch(PeriphClkInit->Sai4BClockSelection)
2400a42a:	f1b3 7f40 	cmp.w	r3, #50331648	@ 0x3000000
2400a42e:	d002      	beq.n	2400a436 <HAL_RCCEx_PeriphCLKConfig+0x1a2>
2400a430:	f1b3 6f80 	cmp.w	r3, #67108864	@ 0x4000000
2400a434:	d1e2      	bne.n	2400a3fc <HAL_RCCEx_PeriphCLKConfig+0x168>
    if(ret == HAL_OK)
2400a436:	bb34      	cbnz	r4, 2400a486 <HAL_RCCEx_PeriphCLKConfig+0x1f2>
      __HAL_RCC_SAI4B_CONFIG(PeriphClkInit->Sai4BClockSelection);
2400a438:	4a28      	ldr	r2, [pc, #160]	@ (2400a4dc <HAL_RCCEx_PeriphCLKConfig+0x248>)
2400a43a:	f8d5 10a8 	ldr.w	r1, [r5, #168]	@ 0xa8
2400a43e:	6d93      	ldr	r3, [r2, #88]	@ 0x58
2400a440:	f023 63e0 	bic.w	r3, r3, #117440512	@ 0x7000000
2400a444:	430b      	orrs	r3, r1
2400a446:	6593      	str	r3, [r2, #88]	@ 0x58
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_QSPI) == RCC_PERIPHCLK_QSPI)
2400a448:	682b      	ldr	r3, [r5, #0]
2400a44a:	019b      	lsls	r3, r3, #6
2400a44c:	d527      	bpl.n	2400a49e <HAL_RCCEx_PeriphCLKConfig+0x20a>
    switch(PeriphClkInit->QspiClockSelection)
2400a44e:	6cab      	ldr	r3, [r5, #72]	@ 0x48
2400a450:	2b20      	cmp	r3, #32
2400a452:	d03a      	beq.n	2400a4ca <HAL_RCCEx_PeriphCLKConfig+0x236>
2400a454:	d819      	bhi.n	2400a48a <HAL_RCCEx_PeriphCLKConfig+0x1f6>
2400a456:	b1d3      	cbz	r3, 2400a48e <HAL_RCCEx_PeriphCLKConfig+0x1fa>
2400a458:	2b10      	cmp	r3, #16
2400a45a:	d030      	beq.n	2400a4be <HAL_RCCEx_PeriphCLKConfig+0x22a>
2400a45c:	2601      	movs	r6, #1
2400a45e:	4634      	mov	r4, r6
2400a460:	e01d      	b.n	2400a49e <HAL_RCCEx_PeriphCLKConfig+0x20a>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
2400a462:	4a1e      	ldr	r2, [pc, #120]	@ (2400a4dc <HAL_RCCEx_PeriphCLKConfig+0x248>)
2400a464:	6ad3      	ldr	r3, [r2, #44]	@ 0x2c
2400a466:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
2400a46a:	62d3      	str	r3, [r2, #44]	@ 0x2c
      break;
2400a46c:	e7e3      	b.n	2400a436 <HAL_RCCEx_PeriphCLKConfig+0x1a2>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
2400a46e:	2100      	movs	r1, #0
2400a470:	1d28      	adds	r0, r5, #4
2400a472:	f7ff fe1f 	bl	2400a0b4 <RCCEx_PLL2_Config>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_P_UPDATE);
2400a476:	4604      	mov	r4, r0
      break;
2400a478:	e7dd      	b.n	2400a436 <HAL_RCCEx_PeriphCLKConfig+0x1a2>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_P_UPDATE);
2400a47a:	2100      	movs	r1, #0
2400a47c:	f105 0024 	add.w	r0, r5, #36	@ 0x24
2400a480:	f7ff fe90 	bl	2400a1a4 <RCCEx_PLL3_Config>
2400a484:	e7f7      	b.n	2400a476 <HAL_RCCEx_PeriphCLKConfig+0x1e2>
2400a486:	4626      	mov	r6, r4
2400a488:	e7de      	b.n	2400a448 <HAL_RCCEx_PeriphCLKConfig+0x1b4>
    switch(PeriphClkInit->QspiClockSelection)
2400a48a:	2b30      	cmp	r3, #48	@ 0x30
2400a48c:	d1e6      	bne.n	2400a45c <HAL_RCCEx_PeriphCLKConfig+0x1c8>
    if(ret == HAL_OK)
2400a48e:	bb14      	cbnz	r4, 2400a4d6 <HAL_RCCEx_PeriphCLKConfig+0x242>
      __HAL_RCC_QSPI_CONFIG(PeriphClkInit->QspiClockSelection);
2400a490:	4a12      	ldr	r2, [pc, #72]	@ (2400a4dc <HAL_RCCEx_PeriphCLKConfig+0x248>)
2400a492:	6ca9      	ldr	r1, [r5, #72]	@ 0x48
2400a494:	6cd3      	ldr	r3, [r2, #76]	@ 0x4c
2400a496:	f023 0330 	bic.w	r3, r3, #48	@ 0x30
2400a49a:	430b      	orrs	r3, r1
2400a49c:	64d3      	str	r3, [r2, #76]	@ 0x4c
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI123) == RCC_PERIPHCLK_SPI123)
2400a49e:	682b      	ldr	r3, [r5, #0]
2400a4a0:	04df      	lsls	r7, r3, #19
2400a4a2:	d52c      	bpl.n	2400a4fe <HAL_RCCEx_PeriphCLKConfig+0x26a>
    switch(PeriphClkInit->Spi123ClockSelection)
2400a4a4:	6deb      	ldr	r3, [r5, #92]	@ 0x5c
2400a4a6:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
2400a4aa:	d075      	beq.n	2400a598 <HAL_RCCEx_PeriphCLKConfig+0x304>
2400a4ac:	d818      	bhi.n	2400a4e0 <HAL_RCCEx_PeriphCLKConfig+0x24c>
2400a4ae:	2b00      	cmp	r3, #0
2400a4b0:	d066      	beq.n	2400a580 <HAL_RCCEx_PeriphCLKConfig+0x2ec>
2400a4b2:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
2400a4b6:	d069      	beq.n	2400a58c <HAL_RCCEx_PeriphCLKConfig+0x2f8>
2400a4b8:	2601      	movs	r6, #1
2400a4ba:	4634      	mov	r4, r6
2400a4bc:	e01f      	b.n	2400a4fe <HAL_RCCEx_PeriphCLKConfig+0x26a>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
2400a4be:	4a07      	ldr	r2, [pc, #28]	@ (2400a4dc <HAL_RCCEx_PeriphCLKConfig+0x248>)
2400a4c0:	6ad3      	ldr	r3, [r2, #44]	@ 0x2c
2400a4c2:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
2400a4c6:	62d3      	str	r3, [r2, #44]	@ 0x2c
      break;
2400a4c8:	e7e1      	b.n	2400a48e <HAL_RCCEx_PeriphCLKConfig+0x1fa>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_R_UPDATE);
2400a4ca:	2102      	movs	r1, #2
2400a4cc:	1d28      	adds	r0, r5, #4
2400a4ce:	f7ff fdf1 	bl	2400a0b4 <RCCEx_PLL2_Config>
2400a4d2:	4604      	mov	r4, r0
      break;
2400a4d4:	e7db      	b.n	2400a48e <HAL_RCCEx_PeriphCLKConfig+0x1fa>
2400a4d6:	4626      	mov	r6, r4
2400a4d8:	e7e1      	b.n	2400a49e <HAL_RCCEx_PeriphCLKConfig+0x20a>
2400a4da:	bf00      	nop
2400a4dc:	58024400 	.word	0x58024400
    switch(PeriphClkInit->Spi123ClockSelection)
2400a4e0:	f5b3 5f40 	cmp.w	r3, #12288	@ 0x3000
2400a4e4:	d002      	beq.n	2400a4ec <HAL_RCCEx_PeriphCLKConfig+0x258>
2400a4e6:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
2400a4ea:	d1e5      	bne.n	2400a4b8 <HAL_RCCEx_PeriphCLKConfig+0x224>
    if(ret == HAL_OK)
2400a4ec:	2c00      	cmp	r4, #0
2400a4ee:	d159      	bne.n	2400a5a4 <HAL_RCCEx_PeriphCLKConfig+0x310>
      __HAL_RCC_SPI123_CONFIG(PeriphClkInit->Spi123ClockSelection);
2400a4f0:	4a9c      	ldr	r2, [pc, #624]	@ (2400a764 <HAL_RCCEx_PeriphCLKConfig+0x4d0>)
2400a4f2:	6de9      	ldr	r1, [r5, #92]	@ 0x5c
2400a4f4:	6d13      	ldr	r3, [r2, #80]	@ 0x50
2400a4f6:	f423 43e0 	bic.w	r3, r3, #28672	@ 0x7000
2400a4fa:	430b      	orrs	r3, r1
2400a4fc:	6513      	str	r3, [r2, #80]	@ 0x50
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI45) == RCC_PERIPHCLK_SPI45)
2400a4fe:	682b      	ldr	r3, [r5, #0]
2400a500:	0498      	lsls	r0, r3, #18
2400a502:	d50b      	bpl.n	2400a51c <HAL_RCCEx_PeriphCLKConfig+0x288>
    switch(PeriphClkInit->Spi45ClockSelection)
2400a504:	6e2b      	ldr	r3, [r5, #96]	@ 0x60
2400a506:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
2400a50a:	d064      	beq.n	2400a5d6 <HAL_RCCEx_PeriphCLKConfig+0x342>
2400a50c:	d84c      	bhi.n	2400a5a8 <HAL_RCCEx_PeriphCLKConfig+0x314>
2400a50e:	2b00      	cmp	r3, #0
2400a510:	d052      	beq.n	2400a5b8 <HAL_RCCEx_PeriphCLKConfig+0x324>
2400a512:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
2400a516:	d058      	beq.n	2400a5ca <HAL_RCCEx_PeriphCLKConfig+0x336>
2400a518:	2601      	movs	r6, #1
2400a51a:	4634      	mov	r4, r6
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI6) == RCC_PERIPHCLK_SPI6)
2400a51c:	682b      	ldr	r3, [r5, #0]
2400a51e:	0459      	lsls	r1, r3, #17
2400a520:	d50c      	bpl.n	2400a53c <HAL_RCCEx_PeriphCLKConfig+0x2a8>
    switch(PeriphClkInit->Spi6ClockSelection)
2400a522:	f8d5 30ac 	ldr.w	r3, [r5, #172]	@ 0xac
2400a526:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
2400a52a:	d074      	beq.n	2400a616 <HAL_RCCEx_PeriphCLKConfig+0x382>
2400a52c:	d85b      	bhi.n	2400a5e6 <HAL_RCCEx_PeriphCLKConfig+0x352>
2400a52e:	2b00      	cmp	r3, #0
2400a530:	d061      	beq.n	2400a5f6 <HAL_RCCEx_PeriphCLKConfig+0x362>
2400a532:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
2400a536:	d068      	beq.n	2400a60a <HAL_RCCEx_PeriphCLKConfig+0x376>
2400a538:	2601      	movs	r6, #1
2400a53a:	4634      	mov	r4, r6
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_FDCAN) == RCC_PERIPHCLK_FDCAN)
2400a53c:	682b      	ldr	r3, [r5, #0]
2400a53e:	041a      	lsls	r2, r3, #16
2400a540:	d511      	bpl.n	2400a566 <HAL_RCCEx_PeriphCLKConfig+0x2d2>
    switch(PeriphClkInit->FdcanClockSelection)
2400a542:	6eeb      	ldr	r3, [r5, #108]	@ 0x6c
2400a544:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
2400a548:	d06d      	beq.n	2400a626 <HAL_RCCEx_PeriphCLKConfig+0x392>
2400a54a:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
2400a54e:	d070      	beq.n	2400a632 <HAL_RCCEx_PeriphCLKConfig+0x39e>
2400a550:	2b00      	cmp	r3, #0
2400a552:	d174      	bne.n	2400a63e <HAL_RCCEx_PeriphCLKConfig+0x3aa>
    if(ret == HAL_OK)
2400a554:	2c00      	cmp	r4, #0
2400a556:	d175      	bne.n	2400a644 <HAL_RCCEx_PeriphCLKConfig+0x3b0>
      __HAL_RCC_FDCAN_CONFIG(PeriphClkInit->FdcanClockSelection);
2400a558:	4a82      	ldr	r2, [pc, #520]	@ (2400a764 <HAL_RCCEx_PeriphCLKConfig+0x4d0>)
2400a55a:	6ee9      	ldr	r1, [r5, #108]	@ 0x6c
2400a55c:	6d13      	ldr	r3, [r2, #80]	@ 0x50
2400a55e:	f023 5340 	bic.w	r3, r3, #805306368	@ 0x30000000
2400a562:	430b      	orrs	r3, r1
2400a564:	6513      	str	r3, [r2, #80]	@ 0x50
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_FMC) == RCC_PERIPHCLK_FMC)
2400a566:	682b      	ldr	r3, [r5, #0]
2400a568:	01db      	lsls	r3, r3, #7
2400a56a:	d57b      	bpl.n	2400a664 <HAL_RCCEx_PeriphCLKConfig+0x3d0>
    switch(PeriphClkInit->FmcClockSelection)
2400a56c:	6c6b      	ldr	r3, [r5, #68]	@ 0x44
2400a56e:	2b03      	cmp	r3, #3
2400a570:	f200 80d3 	bhi.w	2400a71a <HAL_RCCEx_PeriphCLKConfig+0x486>
2400a574:	e8df f013 	tbh	[pc, r3, lsl #1]
2400a578:	0068006d 	.word	0x0068006d
2400a57c:	006d00cb 	.word	0x006d00cb
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
2400a580:	4a78      	ldr	r2, [pc, #480]	@ (2400a764 <HAL_RCCEx_PeriphCLKConfig+0x4d0>)
2400a582:	6ad3      	ldr	r3, [r2, #44]	@ 0x2c
2400a584:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
2400a588:	62d3      	str	r3, [r2, #44]	@ 0x2c
      break;
2400a58a:	e7af      	b.n	2400a4ec <HAL_RCCEx_PeriphCLKConfig+0x258>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
2400a58c:	2100      	movs	r1, #0
2400a58e:	1d28      	adds	r0, r5, #4
2400a590:	f7ff fd90 	bl	2400a0b4 <RCCEx_PLL2_Config>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_P_UPDATE);
2400a594:	4604      	mov	r4, r0
      break;
2400a596:	e7a9      	b.n	2400a4ec <HAL_RCCEx_PeriphCLKConfig+0x258>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_P_UPDATE);
2400a598:	2100      	movs	r1, #0
2400a59a:	f105 0024 	add.w	r0, r5, #36	@ 0x24
2400a59e:	f7ff fe01 	bl	2400a1a4 <RCCEx_PLL3_Config>
2400a5a2:	e7f7      	b.n	2400a594 <HAL_RCCEx_PeriphCLKConfig+0x300>
2400a5a4:	4626      	mov	r6, r4
2400a5a6:	e7aa      	b.n	2400a4fe <HAL_RCCEx_PeriphCLKConfig+0x26a>
    switch(PeriphClkInit->Spi45ClockSelection)
2400a5a8:	f423 3280 	bic.w	r2, r3, #65536	@ 0x10000
2400a5ac:	f5b2 2f80 	cmp.w	r2, #262144	@ 0x40000
2400a5b0:	d002      	beq.n	2400a5b8 <HAL_RCCEx_PeriphCLKConfig+0x324>
2400a5b2:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
2400a5b6:	d1af      	bne.n	2400a518 <HAL_RCCEx_PeriphCLKConfig+0x284>
    if(ret == HAL_OK)
2400a5b8:	b99c      	cbnz	r4, 2400a5e2 <HAL_RCCEx_PeriphCLKConfig+0x34e>
      __HAL_RCC_SPI45_CONFIG(PeriphClkInit->Spi45ClockSelection);
2400a5ba:	4a6a      	ldr	r2, [pc, #424]	@ (2400a764 <HAL_RCCEx_PeriphCLKConfig+0x4d0>)
2400a5bc:	6e29      	ldr	r1, [r5, #96]	@ 0x60
2400a5be:	6d13      	ldr	r3, [r2, #80]	@ 0x50
2400a5c0:	f423 23e0 	bic.w	r3, r3, #458752	@ 0x70000
2400a5c4:	430b      	orrs	r3, r1
2400a5c6:	6513      	str	r3, [r2, #80]	@ 0x50
2400a5c8:	e7a8      	b.n	2400a51c <HAL_RCCEx_PeriphCLKConfig+0x288>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_Q_UPDATE);
2400a5ca:	2101      	movs	r1, #1
2400a5cc:	1d28      	adds	r0, r5, #4
2400a5ce:	f7ff fd71 	bl	2400a0b4 <RCCEx_PLL2_Config>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);
2400a5d2:	4604      	mov	r4, r0
      break;
2400a5d4:	e7f0      	b.n	2400a5b8 <HAL_RCCEx_PeriphCLKConfig+0x324>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);
2400a5d6:	2101      	movs	r1, #1
2400a5d8:	f105 0024 	add.w	r0, r5, #36	@ 0x24
2400a5dc:	f7ff fde2 	bl	2400a1a4 <RCCEx_PLL3_Config>
2400a5e0:	e7f7      	b.n	2400a5d2 <HAL_RCCEx_PeriphCLKConfig+0x33e>
2400a5e2:	4626      	mov	r6, r4
2400a5e4:	e79a      	b.n	2400a51c <HAL_RCCEx_PeriphCLKConfig+0x288>
    switch(PeriphClkInit->Spi6ClockSelection)
2400a5e6:	f023 5280 	bic.w	r2, r3, #268435456	@ 0x10000000
2400a5ea:	f1b2 4f80 	cmp.w	r2, #1073741824	@ 0x40000000
2400a5ee:	d002      	beq.n	2400a5f6 <HAL_RCCEx_PeriphCLKConfig+0x362>
2400a5f0:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
2400a5f4:	d1a0      	bne.n	2400a538 <HAL_RCCEx_PeriphCLKConfig+0x2a4>
    if(ret == HAL_OK)
2400a5f6:	b9a4      	cbnz	r4, 2400a622 <HAL_RCCEx_PeriphCLKConfig+0x38e>
      __HAL_RCC_SPI6_CONFIG(PeriphClkInit->Spi6ClockSelection);
2400a5f8:	4a5a      	ldr	r2, [pc, #360]	@ (2400a764 <HAL_RCCEx_PeriphCLKConfig+0x4d0>)
2400a5fa:	f8d5 10ac 	ldr.w	r1, [r5, #172]	@ 0xac
2400a5fe:	6d93      	ldr	r3, [r2, #88]	@ 0x58
2400a600:	f023 43e0 	bic.w	r3, r3, #1879048192	@ 0x70000000
2400a604:	430b      	orrs	r3, r1
2400a606:	6593      	str	r3, [r2, #88]	@ 0x58
2400a608:	e798      	b.n	2400a53c <HAL_RCCEx_PeriphCLKConfig+0x2a8>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_Q_UPDATE);
2400a60a:	2101      	movs	r1, #1
2400a60c:	1d28      	adds	r0, r5, #4
2400a60e:	f7ff fd51 	bl	2400a0b4 <RCCEx_PLL2_Config>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);
2400a612:	4604      	mov	r4, r0
      break;
2400a614:	e7ef      	b.n	2400a5f6 <HAL_RCCEx_PeriphCLKConfig+0x362>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);
2400a616:	2101      	movs	r1, #1
2400a618:	f105 0024 	add.w	r0, r5, #36	@ 0x24
2400a61c:	f7ff fdc2 	bl	2400a1a4 <RCCEx_PLL3_Config>
2400a620:	e7f7      	b.n	2400a612 <HAL_RCCEx_PeriphCLKConfig+0x37e>
2400a622:	4626      	mov	r6, r4
2400a624:	e78a      	b.n	2400a53c <HAL_RCCEx_PeriphCLKConfig+0x2a8>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
2400a626:	4a4f      	ldr	r2, [pc, #316]	@ (2400a764 <HAL_RCCEx_PeriphCLKConfig+0x4d0>)
2400a628:	6ad3      	ldr	r3, [r2, #44]	@ 0x2c
2400a62a:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
2400a62e:	62d3      	str	r3, [r2, #44]	@ 0x2c
      break;
2400a630:	e790      	b.n	2400a554 <HAL_RCCEx_PeriphCLKConfig+0x2c0>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_Q_UPDATE);
2400a632:	2101      	movs	r1, #1
2400a634:	1d28      	adds	r0, r5, #4
2400a636:	f7ff fd3d 	bl	2400a0b4 <RCCEx_PLL2_Config>
2400a63a:	4604      	mov	r4, r0
      break;
2400a63c:	e78a      	b.n	2400a554 <HAL_RCCEx_PeriphCLKConfig+0x2c0>
    switch(PeriphClkInit->FdcanClockSelection)
2400a63e:	2601      	movs	r6, #1
2400a640:	4634      	mov	r4, r6
2400a642:	e790      	b.n	2400a566 <HAL_RCCEx_PeriphCLKConfig+0x2d2>
2400a644:	4626      	mov	r6, r4
2400a646:	e78e      	b.n	2400a566 <HAL_RCCEx_PeriphCLKConfig+0x2d2>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
2400a648:	4a46      	ldr	r2, [pc, #280]	@ (2400a764 <HAL_RCCEx_PeriphCLKConfig+0x4d0>)
2400a64a:	6ad3      	ldr	r3, [r2, #44]	@ 0x2c
2400a64c:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
2400a650:	62d3      	str	r3, [r2, #44]	@ 0x2c
    if(ret == HAL_OK)
2400a652:	2c00      	cmp	r4, #0
2400a654:	d164      	bne.n	2400a720 <HAL_RCCEx_PeriphCLKConfig+0x48c>
      __HAL_RCC_FMC_CONFIG(PeriphClkInit->FmcClockSelection);
2400a656:	4a43      	ldr	r2, [pc, #268]	@ (2400a764 <HAL_RCCEx_PeriphCLKConfig+0x4d0>)
2400a658:	6c69      	ldr	r1, [r5, #68]	@ 0x44
2400a65a:	6cd3      	ldr	r3, [r2, #76]	@ 0x4c
2400a65c:	f023 0303 	bic.w	r3, r3, #3
2400a660:	430b      	orrs	r3, r1
2400a662:	64d3      	str	r3, [r2, #76]	@ 0x4c
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
2400a664:	682b      	ldr	r3, [r5, #0]
2400a666:	025f      	lsls	r7, r3, #9
2400a668:	d539      	bpl.n	2400a6de <HAL_RCCEx_PeriphCLKConfig+0x44a>
    SET_BIT(PWR->CR1, PWR_CR1_DBP);
2400a66a:	4f3f      	ldr	r7, [pc, #252]	@ (2400a768 <HAL_RCCEx_PeriphCLKConfig+0x4d4>)
2400a66c:	683b      	ldr	r3, [r7, #0]
2400a66e:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
2400a672:	603b      	str	r3, [r7, #0]
    tickstart = HAL_GetTick();
2400a674:	f007 fbc8 	bl	24011e08 <HAL_GetTick>
2400a678:	4680      	mov	r8, r0
    while((PWR->CR1 & PWR_CR1_DBP) == 0U)
2400a67a:	683b      	ldr	r3, [r7, #0]
2400a67c:	05d8      	lsls	r0, r3, #23
2400a67e:	d551      	bpl.n	2400a724 <HAL_RCCEx_PeriphCLKConfig+0x490>
    if(ret == HAL_OK)
2400a680:	2c00      	cmp	r4, #0
2400a682:	d16d      	bne.n	2400a760 <HAL_RCCEx_PeriphCLKConfig+0x4cc>
      if((RCC->BDCR & RCC_BDCR_RTCSEL) != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL))
2400a684:	4b37      	ldr	r3, [pc, #220]	@ (2400a764 <HAL_RCCEx_PeriphCLKConfig+0x4d0>)
2400a686:	f8d5 00b0 	ldr.w	r0, [r5, #176]	@ 0xb0
2400a68a:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
2400a68c:	4042      	eors	r2, r0
2400a68e:	f412 7f40 	tst.w	r2, #768	@ 0x300
2400a692:	d00b      	beq.n	2400a6ac <HAL_RCCEx_PeriphCLKConfig+0x418>
        tmpreg = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
2400a694:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
        __HAL_RCC_BACKUPRESET_FORCE();
2400a696:	6f19      	ldr	r1, [r3, #112]	@ 0x70
        tmpreg = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
2400a698:	f422 7240 	bic.w	r2, r2, #768	@ 0x300
        __HAL_RCC_BACKUPRESET_FORCE();
2400a69c:	f441 3180 	orr.w	r1, r1, #65536	@ 0x10000
2400a6a0:	6719      	str	r1, [r3, #112]	@ 0x70
        __HAL_RCC_BACKUPRESET_RELEASE();
2400a6a2:	6f19      	ldr	r1, [r3, #112]	@ 0x70
2400a6a4:	f421 3180 	bic.w	r1, r1, #65536	@ 0x10000
2400a6a8:	6719      	str	r1, [r3, #112]	@ 0x70
        RCC->BDCR = tmpreg;
2400a6aa:	671a      	str	r2, [r3, #112]	@ 0x70
      if(PeriphClkInit->RTCClockSelection == RCC_RTCCLKSOURCE_LSE)
2400a6ac:	f5b0 7f80 	cmp.w	r0, #256	@ 0x100
2400a6b0:	d041      	beq.n	2400a736 <HAL_RCCEx_PeriphCLKConfig+0x4a2>
        __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
2400a6b2:	f8d5 30b0 	ldr.w	r3, [r5, #176]	@ 0xb0
2400a6b6:	492b      	ldr	r1, [pc, #172]	@ (2400a764 <HAL_RCCEx_PeriphCLKConfig+0x4d0>)
2400a6b8:	f403 7240 	and.w	r2, r3, #768	@ 0x300
2400a6bc:	f5b2 7f40 	cmp.w	r2, #768	@ 0x300
2400a6c0:	d14a      	bne.n	2400a758 <HAL_RCCEx_PeriphCLKConfig+0x4c4>
2400a6c2:	6908      	ldr	r0, [r1, #16]
2400a6c4:	4a29      	ldr	r2, [pc, #164]	@ (2400a76c <HAL_RCCEx_PeriphCLKConfig+0x4d8>)
2400a6c6:	f420 507c 	bic.w	r0, r0, #16128	@ 0x3f00
2400a6ca:	ea02 1213 	and.w	r2, r2, r3, lsr #4
2400a6ce:	4302      	orrs	r2, r0
2400a6d0:	610a      	str	r2, [r1, #16]
2400a6d2:	f3c3 030b 	ubfx	r3, r3, #0, #12
2400a6d6:	4a23      	ldr	r2, [pc, #140]	@ (2400a764 <HAL_RCCEx_PeriphCLKConfig+0x4d0>)
2400a6d8:	6f11      	ldr	r1, [r2, #112]	@ 0x70
2400a6da:	430b      	orrs	r3, r1
2400a6dc:	6713      	str	r3, [r2, #112]	@ 0x70
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART16) == RCC_PERIPHCLK_USART16)
2400a6de:	682b      	ldr	r3, [r5, #0]
2400a6e0:	07da      	lsls	r2, r3, #31
2400a6e2:	d509      	bpl.n	2400a6f8 <HAL_RCCEx_PeriphCLKConfig+0x464>
    switch(PeriphClkInit->Usart16ClockSelection)
2400a6e4:	6fab      	ldr	r3, [r5, #120]	@ 0x78
2400a6e6:	2b10      	cmp	r3, #16
2400a6e8:	d057      	beq.n	2400a79a <HAL_RCCEx_PeriphCLKConfig+0x506>
2400a6ea:	d841      	bhi.n	2400a770 <HAL_RCCEx_PeriphCLKConfig+0x4dc>
2400a6ec:	2b00      	cmp	r3, #0
2400a6ee:	d045      	beq.n	2400a77c <HAL_RCCEx_PeriphCLKConfig+0x4e8>
2400a6f0:	2b08      	cmp	r3, #8
2400a6f2:	d04c      	beq.n	2400a78e <HAL_RCCEx_PeriphCLKConfig+0x4fa>
2400a6f4:	2601      	movs	r6, #1
2400a6f6:	4634      	mov	r4, r6
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART234578) == RCC_PERIPHCLK_USART234578)
2400a6f8:	682b      	ldr	r3, [r5, #0]
2400a6fa:	079b      	lsls	r3, r3, #30
2400a6fc:	d562      	bpl.n	2400a7c4 <HAL_RCCEx_PeriphCLKConfig+0x530>
    switch(PeriphClkInit->Usart234578ClockSelection)
2400a6fe:	6f6b      	ldr	r3, [r5, #116]	@ 0x74
2400a700:	2b05      	cmp	r3, #5
2400a702:	d875      	bhi.n	2400a7f0 <HAL_RCCEx_PeriphCLKConfig+0x55c>
2400a704:	e8df f003 	tbb	[pc, r3]
2400a708:	566e5156 	.word	0x566e5156
2400a70c:	5656      	.short	0x5656
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_R_UPDATE);
2400a70e:	2102      	movs	r1, #2
2400a710:	1d28      	adds	r0, r5, #4
2400a712:	f7ff fccf 	bl	2400a0b4 <RCCEx_PLL2_Config>
2400a716:	4604      	mov	r4, r0
      break;
2400a718:	e79b      	b.n	2400a652 <HAL_RCCEx_PeriphCLKConfig+0x3be>
    switch(PeriphClkInit->FmcClockSelection)
2400a71a:	2601      	movs	r6, #1
2400a71c:	4634      	mov	r4, r6
2400a71e:	e7a1      	b.n	2400a664 <HAL_RCCEx_PeriphCLKConfig+0x3d0>
2400a720:	4626      	mov	r6, r4
2400a722:	e79f      	b.n	2400a664 <HAL_RCCEx_PeriphCLKConfig+0x3d0>
      if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
2400a724:	f007 fb70 	bl	24011e08 <HAL_GetTick>
2400a728:	eba0 0008 	sub.w	r0, r0, r8
2400a72c:	2864      	cmp	r0, #100	@ 0x64
2400a72e:	d9a4      	bls.n	2400a67a <HAL_RCCEx_PeriphCLKConfig+0x3e6>
        ret = HAL_TIMEOUT;
2400a730:	2603      	movs	r6, #3
2400a732:	4634      	mov	r4, r6
2400a734:	e7d3      	b.n	2400a6de <HAL_RCCEx_PeriphCLKConfig+0x44a>
        tickstart = HAL_GetTick();
2400a736:	f007 fb67 	bl	24011e08 <HAL_GetTick>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
2400a73a:	f8df 8028 	ldr.w	r8, [pc, #40]	@ 2400a764 <HAL_RCCEx_PeriphCLKConfig+0x4d0>
        tickstart = HAL_GetTick();
2400a73e:	4607      	mov	r7, r0
          if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
2400a740:	f241 3988 	movw	r9, #5000	@ 0x1388
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
2400a744:	f8d8 3070 	ldr.w	r3, [r8, #112]	@ 0x70
2400a748:	0799      	lsls	r1, r3, #30
2400a74a:	d4b2      	bmi.n	2400a6b2 <HAL_RCCEx_PeriphCLKConfig+0x41e>
          if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
2400a74c:	f007 fb5c 	bl	24011e08 <HAL_GetTick>
2400a750:	1bc0      	subs	r0, r0, r7
2400a752:	4548      	cmp	r0, r9
2400a754:	d9f6      	bls.n	2400a744 <HAL_RCCEx_PeriphCLKConfig+0x4b0>
2400a756:	e7eb      	b.n	2400a730 <HAL_RCCEx_PeriphCLKConfig+0x49c>
        __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
2400a758:	690a      	ldr	r2, [r1, #16]
2400a75a:	f422 527c 	bic.w	r2, r2, #16128	@ 0x3f00
2400a75e:	e7b7      	b.n	2400a6d0 <HAL_RCCEx_PeriphCLKConfig+0x43c>
2400a760:	4626      	mov	r6, r4
2400a762:	e7bc      	b.n	2400a6de <HAL_RCCEx_PeriphCLKConfig+0x44a>
2400a764:	58024400 	.word	0x58024400
2400a768:	58024800 	.word	0x58024800
2400a76c:	00ffffcf 	.word	0x00ffffcf
    switch(PeriphClkInit->Usart16ClockSelection)
2400a770:	f023 0208 	bic.w	r2, r3, #8
2400a774:	2a20      	cmp	r2, #32
2400a776:	d001      	beq.n	2400a77c <HAL_RCCEx_PeriphCLKConfig+0x4e8>
2400a778:	2b18      	cmp	r3, #24
2400a77a:	d1bb      	bne.n	2400a6f4 <HAL_RCCEx_PeriphCLKConfig+0x460>
    if(ret == HAL_OK)
2400a77c:	b99c      	cbnz	r4, 2400a7a6 <HAL_RCCEx_PeriphCLKConfig+0x512>
      __HAL_RCC_USART16_CONFIG(PeriphClkInit->Usart16ClockSelection);
2400a77e:	4aa4      	ldr	r2, [pc, #656]	@ (2400aa10 <HAL_RCCEx_PeriphCLKConfig+0x77c>)
2400a780:	6fa9      	ldr	r1, [r5, #120]	@ 0x78
2400a782:	6d53      	ldr	r3, [r2, #84]	@ 0x54
2400a784:	f023 0338 	bic.w	r3, r3, #56	@ 0x38
2400a788:	430b      	orrs	r3, r1
2400a78a:	6553      	str	r3, [r2, #84]	@ 0x54
2400a78c:	e7b4      	b.n	2400a6f8 <HAL_RCCEx_PeriphCLKConfig+0x464>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_Q_UPDATE);
2400a78e:	2101      	movs	r1, #1
2400a790:	1d28      	adds	r0, r5, #4
2400a792:	f7ff fc8f 	bl	2400a0b4 <RCCEx_PLL2_Config>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);
2400a796:	4604      	mov	r4, r0
      break;
2400a798:	e7f0      	b.n	2400a77c <HAL_RCCEx_PeriphCLKConfig+0x4e8>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);
2400a79a:	2101      	movs	r1, #1
2400a79c:	f105 0024 	add.w	r0, r5, #36	@ 0x24
2400a7a0:	f7ff fd00 	bl	2400a1a4 <RCCEx_PLL3_Config>
2400a7a4:	e7f7      	b.n	2400a796 <HAL_RCCEx_PeriphCLKConfig+0x502>
2400a7a6:	4626      	mov	r6, r4
2400a7a8:	e7a6      	b.n	2400a6f8 <HAL_RCCEx_PeriphCLKConfig+0x464>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_Q_UPDATE);
2400a7aa:	2101      	movs	r1, #1
2400a7ac:	1d28      	adds	r0, r5, #4
2400a7ae:	f7ff fc81 	bl	2400a0b4 <RCCEx_PLL2_Config>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);
2400a7b2:	4604      	mov	r4, r0
    if(ret == HAL_OK)
2400a7b4:	b9fc      	cbnz	r4, 2400a7f6 <HAL_RCCEx_PeriphCLKConfig+0x562>
      __HAL_RCC_USART234578_CONFIG(PeriphClkInit->Usart234578ClockSelection);
2400a7b6:	4a96      	ldr	r2, [pc, #600]	@ (2400aa10 <HAL_RCCEx_PeriphCLKConfig+0x77c>)
2400a7b8:	6f69      	ldr	r1, [r5, #116]	@ 0x74
2400a7ba:	6d53      	ldr	r3, [r2, #84]	@ 0x54
2400a7bc:	f023 0307 	bic.w	r3, r3, #7
2400a7c0:	430b      	orrs	r3, r1
2400a7c2:	6553      	str	r3, [r2, #84]	@ 0x54
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1)
2400a7c4:	682b      	ldr	r3, [r5, #0]
2400a7c6:	075f      	lsls	r7, r3, #29
2400a7c8:	d527      	bpl.n	2400a81a <HAL_RCCEx_PeriphCLKConfig+0x586>
    switch(PeriphClkInit->Lpuart1ClockSelection)
2400a7ca:	f8d5 3090 	ldr.w	r3, [r5, #144]	@ 0x90
2400a7ce:	2b05      	cmp	r3, #5
2400a7d0:	f200 8119 	bhi.w	2400aa06 <HAL_RCCEx_PeriphCLKConfig+0x772>
2400a7d4:	e8df f013 	tbh	[pc, r3, lsl #1]
2400a7d8:	00110016 	.word	0x00110016
2400a7dc:	00160111 	.word	0x00160111
2400a7e0:	00160016 	.word	0x00160016
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);
2400a7e4:	2101      	movs	r1, #1
2400a7e6:	f105 0024 	add.w	r0, r5, #36	@ 0x24
2400a7ea:	f7ff fcdb 	bl	2400a1a4 <RCCEx_PLL3_Config>
2400a7ee:	e7e0      	b.n	2400a7b2 <HAL_RCCEx_PeriphCLKConfig+0x51e>
    switch(PeriphClkInit->Usart234578ClockSelection)
2400a7f0:	2601      	movs	r6, #1
2400a7f2:	4634      	mov	r4, r6
2400a7f4:	e7e6      	b.n	2400a7c4 <HAL_RCCEx_PeriphCLKConfig+0x530>
2400a7f6:	4626      	mov	r6, r4
2400a7f8:	e7e4      	b.n	2400a7c4 <HAL_RCCEx_PeriphCLKConfig+0x530>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_Q_UPDATE);
2400a7fa:	2101      	movs	r1, #1
2400a7fc:	1d28      	adds	r0, r5, #4
2400a7fe:	f7ff fc59 	bl	2400a0b4 <RCCEx_PLL2_Config>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);
2400a802:	4604      	mov	r4, r0
    if(ret == HAL_OK)
2400a804:	2c00      	cmp	r4, #0
2400a806:	f040 8101 	bne.w	2400aa0c <HAL_RCCEx_PeriphCLKConfig+0x778>
      __HAL_RCC_LPUART1_CONFIG(PeriphClkInit->Lpuart1ClockSelection);
2400a80a:	4a81      	ldr	r2, [pc, #516]	@ (2400aa10 <HAL_RCCEx_PeriphCLKConfig+0x77c>)
2400a80c:	f8d5 1090 	ldr.w	r1, [r5, #144]	@ 0x90
2400a810:	6d93      	ldr	r3, [r2, #88]	@ 0x58
2400a812:	f023 0307 	bic.w	r3, r3, #7
2400a816:	430b      	orrs	r3, r1
2400a818:	6593      	str	r3, [r2, #88]	@ 0x58
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == RCC_PERIPHCLK_LPTIM1)
2400a81a:	682b      	ldr	r3, [r5, #0]
2400a81c:	0698      	lsls	r0, r3, #26
2400a81e:	d510      	bpl.n	2400a842 <HAL_RCCEx_PeriphCLKConfig+0x5ae>
    switch(PeriphClkInit->Lptim1ClockSelection)
2400a820:	f8d5 308c 	ldr.w	r3, [r5, #140]	@ 0x8c
2400a824:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
2400a828:	f000 810d 	beq.w	2400aa46 <HAL_RCCEx_PeriphCLKConfig+0x7b2>
2400a82c:	f200 80f2 	bhi.w	2400aa14 <HAL_RCCEx_PeriphCLKConfig+0x780>
2400a830:	2b00      	cmp	r3, #0
2400a832:	f000 80f8 	beq.w	2400aa26 <HAL_RCCEx_PeriphCLKConfig+0x792>
2400a836:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
2400a83a:	f000 80fe 	beq.w	2400aa3a <HAL_RCCEx_PeriphCLKConfig+0x7a6>
2400a83e:	2601      	movs	r6, #1
2400a840:	4634      	mov	r4, r6
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM2) == RCC_PERIPHCLK_LPTIM2)
2400a842:	682b      	ldr	r3, [r5, #0]
2400a844:	0659      	lsls	r1, r3, #25
2400a846:	d510      	bpl.n	2400a86a <HAL_RCCEx_PeriphCLKConfig+0x5d6>
    switch(PeriphClkInit->Lptim2ClockSelection)
2400a848:	f8d5 3098 	ldr.w	r3, [r5, #152]	@ 0x98
2400a84c:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
2400a850:	f000 811a 	beq.w	2400aa88 <HAL_RCCEx_PeriphCLKConfig+0x7f4>
2400a854:	f200 80ff 	bhi.w	2400aa56 <HAL_RCCEx_PeriphCLKConfig+0x7c2>
2400a858:	2b00      	cmp	r3, #0
2400a85a:	f000 8105 	beq.w	2400aa68 <HAL_RCCEx_PeriphCLKConfig+0x7d4>
2400a85e:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
2400a862:	f000 810b 	beq.w	2400aa7c <HAL_RCCEx_PeriphCLKConfig+0x7e8>
2400a866:	2601      	movs	r6, #1
2400a868:	4634      	mov	r4, r6
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM345) == RCC_PERIPHCLK_LPTIM345)
2400a86a:	682b      	ldr	r3, [r5, #0]
2400a86c:	061a      	lsls	r2, r3, #24
2400a86e:	d510      	bpl.n	2400a892 <HAL_RCCEx_PeriphCLKConfig+0x5fe>
    switch(PeriphClkInit->Lptim345ClockSelection)
2400a870:	f8d5 309c 	ldr.w	r3, [r5, #156]	@ 0x9c
2400a874:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
2400a878:	f000 8127 	beq.w	2400aaca <HAL_RCCEx_PeriphCLKConfig+0x836>
2400a87c:	f200 810c 	bhi.w	2400aa98 <HAL_RCCEx_PeriphCLKConfig+0x804>
2400a880:	2b00      	cmp	r3, #0
2400a882:	f000 8112 	beq.w	2400aaaa <HAL_RCCEx_PeriphCLKConfig+0x816>
2400a886:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
2400a88a:	f000 8118 	beq.w	2400aabe <HAL_RCCEx_PeriphCLKConfig+0x82a>
2400a88e:	2601      	movs	r6, #1
2400a890:	4634      	mov	r4, r6
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C123) == RCC_PERIPHCLK_I2C123)
2400a892:	682b      	ldr	r3, [r5, #0]
2400a894:	071b      	lsls	r3, r3, #28
2400a896:	d514      	bpl.n	2400a8c2 <HAL_RCCEx_PeriphCLKConfig+0x62e>
    if ((PeriphClkInit->I2c123ClockSelection )== RCC_I2C123CLKSOURCE_PLL3 )
2400a898:	f8d5 3080 	ldr.w	r3, [r5, #128]	@ 0x80
2400a89c:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
2400a8a0:	d107      	bne.n	2400a8b2 <HAL_RCCEx_PeriphCLKConfig+0x61e>
        if(RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE)!= HAL_OK)
2400a8a2:	2102      	movs	r1, #2
2400a8a4:	f105 0024 	add.w	r0, r5, #36	@ 0x24
2400a8a8:	f7ff fc7c 	bl	2400a1a4 <RCCEx_PLL3_Config>
          status = HAL_ERROR;
2400a8ac:	2800      	cmp	r0, #0
2400a8ae:	bf18      	it	ne
2400a8b0:	2601      	movne	r6, #1
      __HAL_RCC_I2C123_CONFIG(PeriphClkInit->I2c123ClockSelection);
2400a8b2:	4a57      	ldr	r2, [pc, #348]	@ (2400aa10 <HAL_RCCEx_PeriphCLKConfig+0x77c>)
2400a8b4:	f8d5 1080 	ldr.w	r1, [r5, #128]	@ 0x80
2400a8b8:	6d53      	ldr	r3, [r2, #84]	@ 0x54
2400a8ba:	f423 5340 	bic.w	r3, r3, #12288	@ 0x3000
2400a8be:	430b      	orrs	r3, r1
2400a8c0:	6553      	str	r3, [r2, #84]	@ 0x54
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C4) == RCC_PERIPHCLK_I2C4)
2400a8c2:	682b      	ldr	r3, [r5, #0]
2400a8c4:	06df      	lsls	r7, r3, #27
2400a8c6:	d514      	bpl.n	2400a8f2 <HAL_RCCEx_PeriphCLKConfig+0x65e>
    if ((PeriphClkInit->I2c4ClockSelection) == RCC_I2C4CLKSOURCE_PLL3 )
2400a8c8:	f8d5 3094 	ldr.w	r3, [r5, #148]	@ 0x94
2400a8cc:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
2400a8d0:	d107      	bne.n	2400a8e2 <HAL_RCCEx_PeriphCLKConfig+0x64e>
      if(RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE)!= HAL_OK)
2400a8d2:	2102      	movs	r1, #2
2400a8d4:	f105 0024 	add.w	r0, r5, #36	@ 0x24
2400a8d8:	f7ff fc64 	bl	2400a1a4 <RCCEx_PLL3_Config>
        status = HAL_ERROR;
2400a8dc:	2800      	cmp	r0, #0
2400a8de:	bf18      	it	ne
2400a8e0:	2601      	movne	r6, #1
      __HAL_RCC_I2C4_CONFIG(PeriphClkInit->I2c4ClockSelection);
2400a8e2:	4a4b      	ldr	r2, [pc, #300]	@ (2400aa10 <HAL_RCCEx_PeriphCLKConfig+0x77c>)
2400a8e4:	f8d5 1094 	ldr.w	r1, [r5, #148]	@ 0x94
2400a8e8:	6d93      	ldr	r3, [r2, #88]	@ 0x58
2400a8ea:	f423 7340 	bic.w	r3, r3, #768	@ 0x300
2400a8ee:	430b      	orrs	r3, r1
2400a8f0:	6593      	str	r3, [r2, #88]	@ 0x58
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADC) == RCC_PERIPHCLK_ADC)
2400a8f2:	682b      	ldr	r3, [r5, #0]
2400a8f4:	0318      	lsls	r0, r3, #12
2400a8f6:	d51a      	bpl.n	2400a92e <HAL_RCCEx_PeriphCLKConfig+0x69a>
    switch(PeriphClkInit->AdcClockSelection)
2400a8f8:	f8d5 10a0 	ldr.w	r1, [r5, #160]	@ 0xa0
2400a8fc:	f5b1 3f80 	cmp.w	r1, #65536	@ 0x10000
2400a900:	f000 80eb 	beq.w	2400aada <HAL_RCCEx_PeriphCLKConfig+0x846>
2400a904:	f5b1 3f00 	cmp.w	r1, #131072	@ 0x20000
2400a908:	d006      	beq.n	2400a918 <HAL_RCCEx_PeriphCLKConfig+0x684>
2400a90a:	2900      	cmp	r1, #0
2400a90c:	f040 80eb 	bne.w	2400aae6 <HAL_RCCEx_PeriphCLKConfig+0x852>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
2400a910:	1d28      	adds	r0, r5, #4
2400a912:	f7ff fbcf 	bl	2400a0b4 <RCCEx_PLL2_Config>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE);
2400a916:	4604      	mov	r4, r0
    if(ret == HAL_OK)
2400a918:	2c00      	cmp	r4, #0
2400a91a:	f040 80e7 	bne.w	2400aaec <HAL_RCCEx_PeriphCLKConfig+0x858>
      __HAL_RCC_ADC_CONFIG(PeriphClkInit->AdcClockSelection);
2400a91e:	4a3c      	ldr	r2, [pc, #240]	@ (2400aa10 <HAL_RCCEx_PeriphCLKConfig+0x77c>)
2400a920:	f8d5 10a0 	ldr.w	r1, [r5, #160]	@ 0xa0
2400a924:	6d93      	ldr	r3, [r2, #88]	@ 0x58
2400a926:	f423 3340 	bic.w	r3, r3, #196608	@ 0x30000
2400a92a:	430b      	orrs	r3, r1
2400a92c:	6593      	str	r3, [r2, #88]	@ 0x58
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USB) == RCC_PERIPHCLK_USB)
2400a92e:	682b      	ldr	r3, [r5, #0]
2400a930:	0359      	lsls	r1, r3, #13
2400a932:	d50f      	bpl.n	2400a954 <HAL_RCCEx_PeriphCLKConfig+0x6c0>
    switch(PeriphClkInit->UsbClockSelection)
2400a934:	f8d5 3084 	ldr.w	r3, [r5, #132]	@ 0x84
2400a938:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
2400a93c:	f000 80e7 	beq.w	2400ab0e <HAL_RCCEx_PeriphCLKConfig+0x87a>
2400a940:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
2400a944:	f000 80d9 	beq.w	2400aafa <HAL_RCCEx_PeriphCLKConfig+0x866>
2400a948:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
2400a94c:	f000 80d0 	beq.w	2400aaf0 <HAL_RCCEx_PeriphCLKConfig+0x85c>
2400a950:	2601      	movs	r6, #1
2400a952:	4634      	mov	r4, r6
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDMMC) == RCC_PERIPHCLK_SDMMC)
2400a954:	682b      	ldr	r3, [r5, #0]
2400a956:	03da      	lsls	r2, r3, #15
2400a958:	d509      	bpl.n	2400a96e <HAL_RCCEx_PeriphCLKConfig+0x6da>
    switch(PeriphClkInit->SdmmcClockSelection)
2400a95a:	6ceb      	ldr	r3, [r5, #76]	@ 0x4c
2400a95c:	2b00      	cmp	r3, #0
2400a95e:	f000 80df 	beq.w	2400ab20 <HAL_RCCEx_PeriphCLKConfig+0x88c>
2400a962:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
2400a966:	f000 80e9 	beq.w	2400ab3c <HAL_RCCEx_PeriphCLKConfig+0x8a8>
2400a96a:	2601      	movs	r6, #1
2400a96c:	4634      	mov	r4, r6
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LTDC) == RCC_PERIPHCLK_LTDC)
2400a96e:	682b      	ldr	r3, [r5, #0]
2400a970:	009b      	lsls	r3, r3, #2
2400a972:	d507      	bpl.n	2400a984 <HAL_RCCEx_PeriphCLKConfig+0x6f0>
    if(RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE)!=HAL_OK)
2400a974:	2102      	movs	r1, #2
2400a976:	f105 0024 	add.w	r0, r5, #36	@ 0x24
2400a97a:	f7ff fc13 	bl	2400a1a4 <RCCEx_PLL3_Config>
      status=HAL_ERROR;
2400a97e:	2800      	cmp	r0, #0
2400a980:	bf18      	it	ne
2400a982:	2601      	movne	r6, #1
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RNG) == RCC_PERIPHCLK_RNG)
2400a984:	682b      	ldr	r3, [r5, #0]
2400a986:	039f      	lsls	r7, r3, #14
2400a988:	f140 80ef 	bpl.w	2400ab6a <HAL_RCCEx_PeriphCLKConfig+0x8d6>
    switch(PeriphClkInit->RngClockSelection)
2400a98c:	6fe9      	ldr	r1, [r5, #124]	@ 0x7c
2400a98e:	f5b1 7f80 	cmp.w	r1, #256	@ 0x100
2400a992:	f000 80ec 	beq.w	2400ab6e <HAL_RCCEx_PeriphCLKConfig+0x8da>
2400a996:	f200 80d9 	bhi.w	2400ab4c <HAL_RCCEx_PeriphCLKConfig+0x8b8>
2400a99a:	2900      	cmp	r1, #0
2400a99c:	f000 80dc 	beq.w	2400ab58 <HAL_RCCEx_PeriphCLKConfig+0x8c4>
2400a9a0:	2401      	movs	r4, #1
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SWPMI1) == RCC_PERIPHCLK_SWPMI1)
2400a9a2:	02d8      	lsls	r0, r3, #11
2400a9a4:	d506      	bpl.n	2400a9b4 <HAL_RCCEx_PeriphCLKConfig+0x720>
    __HAL_RCC_SWPMI1_CONFIG(PeriphClkInit->Swpmi1ClockSelection);
2400a9a6:	491a      	ldr	r1, [pc, #104]	@ (2400aa10 <HAL_RCCEx_PeriphCLKConfig+0x77c>)
2400a9a8:	6f28      	ldr	r0, [r5, #112]	@ 0x70
2400a9aa:	6d0a      	ldr	r2, [r1, #80]	@ 0x50
2400a9ac:	f022 4200 	bic.w	r2, r2, #2147483648	@ 0x80000000
2400a9b0:	4302      	orrs	r2, r0
2400a9b2:	650a      	str	r2, [r1, #80]	@ 0x50
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_DFSDM1) == RCC_PERIPHCLK_DFSDM1)
2400a9b4:	0299      	lsls	r1, r3, #10
2400a9b6:	d506      	bpl.n	2400a9c6 <HAL_RCCEx_PeriphCLKConfig+0x732>
    __HAL_RCC_DFSDM1_CONFIG(PeriphClkInit->Dfsdm1ClockSelection);
2400a9b8:	4915      	ldr	r1, [pc, #84]	@ (2400aa10 <HAL_RCCEx_PeriphCLKConfig+0x77c>)
2400a9ba:	6ea8      	ldr	r0, [r5, #104]	@ 0x68
2400a9bc:	6d0a      	ldr	r2, [r1, #80]	@ 0x50
2400a9be:	f022 7280 	bic.w	r2, r2, #16777216	@ 0x1000000
2400a9c2:	4302      	orrs	r2, r0
2400a9c4:	650a      	str	r2, [r1, #80]	@ 0x50
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_TIM) == RCC_PERIPHCLK_TIM)
2400a9c6:	005a      	lsls	r2, r3, #1
2400a9c8:	d509      	bpl.n	2400a9de <HAL_RCCEx_PeriphCLKConfig+0x74a>
    __HAL_RCC_TIMCLKPRESCALER(PeriphClkInit->TIMPresSelection);
2400a9ca:	4a11      	ldr	r2, [pc, #68]	@ (2400aa10 <HAL_RCCEx_PeriphCLKConfig+0x77c>)
2400a9cc:	6911      	ldr	r1, [r2, #16]
2400a9ce:	f421 4100 	bic.w	r1, r1, #32768	@ 0x8000
2400a9d2:	6111      	str	r1, [r2, #16]
2400a9d4:	6911      	ldr	r1, [r2, #16]
2400a9d6:	f8d5 00b8 	ldr.w	r0, [r5, #184]	@ 0xb8
2400a9da:	4301      	orrs	r1, r0
2400a9dc:	6111      	str	r1, [r2, #16]
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CKPER) == RCC_PERIPHCLK_CKPER)
2400a9de:	2b00      	cmp	r3, #0
2400a9e0:	da06      	bge.n	2400a9f0 <HAL_RCCEx_PeriphCLKConfig+0x75c>
    __HAL_RCC_CLKP_CONFIG(PeriphClkInit->CkperClockSelection);
2400a9e2:	4a0b      	ldr	r2, [pc, #44]	@ (2400aa10 <HAL_RCCEx_PeriphCLKConfig+0x77c>)
2400a9e4:	6d29      	ldr	r1, [r5, #80]	@ 0x50
2400a9e6:	6cd3      	ldr	r3, [r2, #76]	@ 0x4c
2400a9e8:	f023 5340 	bic.w	r3, r3, #805306368	@ 0x30000000
2400a9ec:	430b      	orrs	r3, r1
2400a9ee:	64d3      	str	r3, [r2, #76]	@ 0x4c
}
2400a9f0:	1e20      	subs	r0, r4, #0
2400a9f2:	bf18      	it	ne
2400a9f4:	2001      	movne	r0, #1
2400a9f6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);
2400a9fa:	2101      	movs	r1, #1
2400a9fc:	f105 0024 	add.w	r0, r5, #36	@ 0x24
2400aa00:	f7ff fbd0 	bl	2400a1a4 <RCCEx_PLL3_Config>
2400aa04:	e6fd      	b.n	2400a802 <HAL_RCCEx_PeriphCLKConfig+0x56e>
    switch(PeriphClkInit->Lpuart1ClockSelection)
2400aa06:	2601      	movs	r6, #1
2400aa08:	4634      	mov	r4, r6
2400aa0a:	e706      	b.n	2400a81a <HAL_RCCEx_PeriphCLKConfig+0x586>
2400aa0c:	4626      	mov	r6, r4
2400aa0e:	e704      	b.n	2400a81a <HAL_RCCEx_PeriphCLKConfig+0x586>
2400aa10:	58024400 	.word	0x58024400
    switch(PeriphClkInit->Lptim1ClockSelection)
2400aa14:	f023 5280 	bic.w	r2, r3, #268435456	@ 0x10000000
2400aa18:	f1b2 4f80 	cmp.w	r2, #1073741824	@ 0x40000000
2400aa1c:	d003      	beq.n	2400aa26 <HAL_RCCEx_PeriphCLKConfig+0x792>
2400aa1e:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
2400aa22:	f47f af0c 	bne.w	2400a83e <HAL_RCCEx_PeriphCLKConfig+0x5aa>
    if(ret == HAL_OK)
2400aa26:	b9a4      	cbnz	r4, 2400aa52 <HAL_RCCEx_PeriphCLKConfig+0x7be>
      __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
2400aa28:	4a54      	ldr	r2, [pc, #336]	@ (2400ab7c <HAL_RCCEx_PeriphCLKConfig+0x8e8>)
2400aa2a:	f8d5 108c 	ldr.w	r1, [r5, #140]	@ 0x8c
2400aa2e:	6d53      	ldr	r3, [r2, #84]	@ 0x54
2400aa30:	f023 43e0 	bic.w	r3, r3, #1879048192	@ 0x70000000
2400aa34:	430b      	orrs	r3, r1
2400aa36:	6553      	str	r3, [r2, #84]	@ 0x54
2400aa38:	e703      	b.n	2400a842 <HAL_RCCEx_PeriphCLKConfig+0x5ae>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
2400aa3a:	2100      	movs	r1, #0
2400aa3c:	1d28      	adds	r0, r5, #4
2400aa3e:	f7ff fb39 	bl	2400a0b4 <RCCEx_PLL2_Config>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE);
2400aa42:	4604      	mov	r4, r0
      break;
2400aa44:	e7ef      	b.n	2400aa26 <HAL_RCCEx_PeriphCLKConfig+0x792>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE);
2400aa46:	2102      	movs	r1, #2
2400aa48:	f105 0024 	add.w	r0, r5, #36	@ 0x24
2400aa4c:	f7ff fbaa 	bl	2400a1a4 <RCCEx_PLL3_Config>
2400aa50:	e7f7      	b.n	2400aa42 <HAL_RCCEx_PeriphCLKConfig+0x7ae>
2400aa52:	4626      	mov	r6, r4
2400aa54:	e6f5      	b.n	2400a842 <HAL_RCCEx_PeriphCLKConfig+0x5ae>
    switch(PeriphClkInit->Lptim2ClockSelection)
2400aa56:	f423 6280 	bic.w	r2, r3, #1024	@ 0x400
2400aa5a:	f5b2 5f80 	cmp.w	r2, #4096	@ 0x1000
2400aa5e:	d003      	beq.n	2400aa68 <HAL_RCCEx_PeriphCLKConfig+0x7d4>
2400aa60:	f5b3 6f40 	cmp.w	r3, #3072	@ 0xc00
2400aa64:	f47f aeff 	bne.w	2400a866 <HAL_RCCEx_PeriphCLKConfig+0x5d2>
    if(ret == HAL_OK)
2400aa68:	b9a4      	cbnz	r4, 2400aa94 <HAL_RCCEx_PeriphCLKConfig+0x800>
      __HAL_RCC_LPTIM2_CONFIG(PeriphClkInit->Lptim2ClockSelection);
2400aa6a:	4a44      	ldr	r2, [pc, #272]	@ (2400ab7c <HAL_RCCEx_PeriphCLKConfig+0x8e8>)
2400aa6c:	f8d5 1098 	ldr.w	r1, [r5, #152]	@ 0x98
2400aa70:	6d93      	ldr	r3, [r2, #88]	@ 0x58
2400aa72:	f423 53e0 	bic.w	r3, r3, #7168	@ 0x1c00
2400aa76:	430b      	orrs	r3, r1
2400aa78:	6593      	str	r3, [r2, #88]	@ 0x58
2400aa7a:	e6f6      	b.n	2400a86a <HAL_RCCEx_PeriphCLKConfig+0x5d6>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
2400aa7c:	2100      	movs	r1, #0
2400aa7e:	1d28      	adds	r0, r5, #4
2400aa80:	f7ff fb18 	bl	2400a0b4 <RCCEx_PLL2_Config>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE);
2400aa84:	4604      	mov	r4, r0
      break;
2400aa86:	e7ef      	b.n	2400aa68 <HAL_RCCEx_PeriphCLKConfig+0x7d4>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE);
2400aa88:	2102      	movs	r1, #2
2400aa8a:	f105 0024 	add.w	r0, r5, #36	@ 0x24
2400aa8e:	f7ff fb89 	bl	2400a1a4 <RCCEx_PLL3_Config>
2400aa92:	e7f7      	b.n	2400aa84 <HAL_RCCEx_PeriphCLKConfig+0x7f0>
2400aa94:	4626      	mov	r6, r4
2400aa96:	e6e8      	b.n	2400a86a <HAL_RCCEx_PeriphCLKConfig+0x5d6>
    switch(PeriphClkInit->Lptim345ClockSelection)
2400aa98:	f423 5200 	bic.w	r2, r3, #8192	@ 0x2000
2400aa9c:	f5b2 4f00 	cmp.w	r2, #32768	@ 0x8000
2400aaa0:	d003      	beq.n	2400aaaa <HAL_RCCEx_PeriphCLKConfig+0x816>
2400aaa2:	f5b3 4fc0 	cmp.w	r3, #24576	@ 0x6000
2400aaa6:	f47f aef2 	bne.w	2400a88e <HAL_RCCEx_PeriphCLKConfig+0x5fa>
    if(ret == HAL_OK)
2400aaaa:	b9a4      	cbnz	r4, 2400aad6 <HAL_RCCEx_PeriphCLKConfig+0x842>
      __HAL_RCC_LPTIM345_CONFIG(PeriphClkInit->Lptim345ClockSelection);
2400aaac:	4a33      	ldr	r2, [pc, #204]	@ (2400ab7c <HAL_RCCEx_PeriphCLKConfig+0x8e8>)
2400aaae:	f8d5 109c 	ldr.w	r1, [r5, #156]	@ 0x9c
2400aab2:	6d93      	ldr	r3, [r2, #88]	@ 0x58
2400aab4:	f423 4360 	bic.w	r3, r3, #57344	@ 0xe000
2400aab8:	430b      	orrs	r3, r1
2400aaba:	6593      	str	r3, [r2, #88]	@ 0x58
2400aabc:	e6e9      	b.n	2400a892 <HAL_RCCEx_PeriphCLKConfig+0x5fe>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
2400aabe:	2100      	movs	r1, #0
2400aac0:	1d28      	adds	r0, r5, #4
2400aac2:	f7ff faf7 	bl	2400a0b4 <RCCEx_PLL2_Config>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE);
2400aac6:	4604      	mov	r4, r0
      break;
2400aac8:	e7ef      	b.n	2400aaaa <HAL_RCCEx_PeriphCLKConfig+0x816>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE);
2400aaca:	2102      	movs	r1, #2
2400aacc:	f105 0024 	add.w	r0, r5, #36	@ 0x24
2400aad0:	f7ff fb68 	bl	2400a1a4 <RCCEx_PLL3_Config>
2400aad4:	e7f7      	b.n	2400aac6 <HAL_RCCEx_PeriphCLKConfig+0x832>
2400aad6:	4626      	mov	r6, r4
2400aad8:	e6db      	b.n	2400a892 <HAL_RCCEx_PeriphCLKConfig+0x5fe>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE);
2400aada:	2102      	movs	r1, #2
2400aadc:	f105 0024 	add.w	r0, r5, #36	@ 0x24
2400aae0:	f7ff fb60 	bl	2400a1a4 <RCCEx_PLL3_Config>
2400aae4:	e717      	b.n	2400a916 <HAL_RCCEx_PeriphCLKConfig+0x682>
    switch(PeriphClkInit->AdcClockSelection)
2400aae6:	2601      	movs	r6, #1
2400aae8:	4634      	mov	r4, r6
2400aaea:	e720      	b.n	2400a92e <HAL_RCCEx_PeriphCLKConfig+0x69a>
2400aaec:	4626      	mov	r6, r4
2400aaee:	e71e      	b.n	2400a92e <HAL_RCCEx_PeriphCLKConfig+0x69a>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
2400aaf0:	4a22      	ldr	r2, [pc, #136]	@ (2400ab7c <HAL_RCCEx_PeriphCLKConfig+0x8e8>)
2400aaf2:	6ad3      	ldr	r3, [r2, #44]	@ 0x2c
2400aaf4:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
2400aaf8:	62d3      	str	r3, [r2, #44]	@ 0x2c
    if(ret == HAL_OK)
2400aafa:	b97c      	cbnz	r4, 2400ab1c <HAL_RCCEx_PeriphCLKConfig+0x888>
      __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
2400aafc:	4a1f      	ldr	r2, [pc, #124]	@ (2400ab7c <HAL_RCCEx_PeriphCLKConfig+0x8e8>)
2400aafe:	f8d5 1084 	ldr.w	r1, [r5, #132]	@ 0x84
2400ab02:	6d53      	ldr	r3, [r2, #84]	@ 0x54
2400ab04:	f423 1340 	bic.w	r3, r3, #3145728	@ 0x300000
2400ab08:	430b      	orrs	r3, r1
2400ab0a:	6553      	str	r3, [r2, #84]	@ 0x54
2400ab0c:	e722      	b.n	2400a954 <HAL_RCCEx_PeriphCLKConfig+0x6c0>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);
2400ab0e:	2101      	movs	r1, #1
2400ab10:	f105 0024 	add.w	r0, r5, #36	@ 0x24
2400ab14:	f7ff fb46 	bl	2400a1a4 <RCCEx_PLL3_Config>
2400ab18:	4604      	mov	r4, r0
      break;
2400ab1a:	e7ee      	b.n	2400aafa <HAL_RCCEx_PeriphCLKConfig+0x866>
2400ab1c:	4626      	mov	r6, r4
2400ab1e:	e719      	b.n	2400a954 <HAL_RCCEx_PeriphCLKConfig+0x6c0>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
2400ab20:	4a16      	ldr	r2, [pc, #88]	@ (2400ab7c <HAL_RCCEx_PeriphCLKConfig+0x8e8>)
2400ab22:	6ad3      	ldr	r3, [r2, #44]	@ 0x2c
2400ab24:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
2400ab28:	62d3      	str	r3, [r2, #44]	@ 0x2c
    if(ret == HAL_OK)
2400ab2a:	b96c      	cbnz	r4, 2400ab48 <HAL_RCCEx_PeriphCLKConfig+0x8b4>
      __HAL_RCC_SDMMC_CONFIG(PeriphClkInit->SdmmcClockSelection);
2400ab2c:	4a13      	ldr	r2, [pc, #76]	@ (2400ab7c <HAL_RCCEx_PeriphCLKConfig+0x8e8>)
2400ab2e:	6ce9      	ldr	r1, [r5, #76]	@ 0x4c
2400ab30:	6cd3      	ldr	r3, [r2, #76]	@ 0x4c
2400ab32:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
2400ab36:	430b      	orrs	r3, r1
2400ab38:	64d3      	str	r3, [r2, #76]	@ 0x4c
2400ab3a:	e718      	b.n	2400a96e <HAL_RCCEx_PeriphCLKConfig+0x6da>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_R_UPDATE);
2400ab3c:	2102      	movs	r1, #2
2400ab3e:	1d28      	adds	r0, r5, #4
2400ab40:	f7ff fab8 	bl	2400a0b4 <RCCEx_PLL2_Config>
2400ab44:	4604      	mov	r4, r0
      break;
2400ab46:	e7f0      	b.n	2400ab2a <HAL_RCCEx_PeriphCLKConfig+0x896>
2400ab48:	4626      	mov	r6, r4
2400ab4a:	e710      	b.n	2400a96e <HAL_RCCEx_PeriphCLKConfig+0x6da>
    switch(PeriphClkInit->RngClockSelection)
2400ab4c:	f421 7280 	bic.w	r2, r1, #256	@ 0x100
2400ab50:	f5b2 7f00 	cmp.w	r2, #512	@ 0x200
2400ab54:	f47f af24 	bne.w	2400a9a0 <HAL_RCCEx_PeriphCLKConfig+0x70c>
    if(ret == HAL_OK)
2400ab58:	2c00      	cmp	r4, #0
2400ab5a:	f47f af22 	bne.w	2400a9a2 <HAL_RCCEx_PeriphCLKConfig+0x70e>
      __HAL_RCC_RNG_CONFIG(PeriphClkInit->RngClockSelection);
2400ab5e:	4807      	ldr	r0, [pc, #28]	@ (2400ab7c <HAL_RCCEx_PeriphCLKConfig+0x8e8>)
2400ab60:	6d42      	ldr	r2, [r0, #84]	@ 0x54
2400ab62:	f422 7240 	bic.w	r2, r2, #768	@ 0x300
2400ab66:	430a      	orrs	r2, r1
2400ab68:	6542      	str	r2, [r0, #84]	@ 0x54
      status=HAL_ERROR;
2400ab6a:	4634      	mov	r4, r6
2400ab6c:	e719      	b.n	2400a9a2 <HAL_RCCEx_PeriphCLKConfig+0x70e>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
2400ab6e:	4803      	ldr	r0, [pc, #12]	@ (2400ab7c <HAL_RCCEx_PeriphCLKConfig+0x8e8>)
2400ab70:	6ac2      	ldr	r2, [r0, #44]	@ 0x2c
2400ab72:	f442 3200 	orr.w	r2, r2, #131072	@ 0x20000
2400ab76:	62c2      	str	r2, [r0, #44]	@ 0x2c
      break;
2400ab78:	e7ee      	b.n	2400ab58 <HAL_RCCEx_PeriphCLKConfig+0x8c4>
2400ab7a:	bf00      	nop
2400ab7c:	58024400 	.word	0x58024400

2400ab80 <HAL_RCCEx_GetPeriphCLKConfig>:
  PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_LTDC;
2400ab80:	f06f 53a0 	mvn.w	r3, #335544320	@ 0x14000000
2400ab84:	6003      	str	r3, [r0, #0]
  PeriphClkInit->PLL3.PLL3M = (uint32_t)((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM3)>> RCC_PLLCKSELR_DIVM3_Pos);
2400ab86:	4b62      	ldr	r3, [pc, #392]	@ (2400ad10 <HAL_RCCEx_GetPeriphCLKConfig+0x190>)
2400ab88:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
2400ab8a:	f3c2 5205 	ubfx	r2, r2, #20, #6
2400ab8e:	6242      	str	r2, [r0, #36]	@ 0x24
  PeriphClkInit->PLL3.PLL3N = (uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_N3) >> RCC_PLL3DIVR_N3_Pos)+ 1U;
2400ab90:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
2400ab92:	f3c2 0208 	ubfx	r2, r2, #0, #9
2400ab96:	3201      	adds	r2, #1
2400ab98:	6282      	str	r2, [r0, #40]	@ 0x28
  PeriphClkInit->PLL3.PLL3R = (uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_R3) >> RCC_PLL3DIVR_R3_Pos)+ 1U;
2400ab9a:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
2400ab9c:	f3c2 6206 	ubfx	r2, r2, #24, #7
2400aba0:	3201      	adds	r2, #1
2400aba2:	6342      	str	r2, [r0, #52]	@ 0x34
  PeriphClkInit->PLL3.PLL3P = (uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_P3) >> RCC_PLL3DIVR_P3_Pos)+ 1U;
2400aba4:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
2400aba6:	f3c2 2246 	ubfx	r2, r2, #9, #7
2400abaa:	3201      	adds	r2, #1
2400abac:	62c2      	str	r2, [r0, #44]	@ 0x2c
  PeriphClkInit->PLL3.PLL3Q = (uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_Q3) >> RCC_PLL3DIVR_Q3_Pos)+ 1U;
2400abae:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
2400abb0:	f3c2 4206 	ubfx	r2, r2, #16, #7
2400abb4:	3201      	adds	r2, #1
2400abb6:	6302      	str	r2, [r0, #48]	@ 0x30
  PeriphClkInit->PLL3.PLL3RGE = (uint32_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLL3RGE) >> RCC_PLLCFGR_PLL3RGE_Pos);
2400abb8:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
2400abba:	f3c2 2281 	ubfx	r2, r2, #10, #2
2400abbe:	6382      	str	r2, [r0, #56]	@ 0x38
  PeriphClkInit->PLL3.PLL3VCOSEL = (uint32_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLL3VCOSEL) >> RCC_PLLCFGR_PLL3VCOSEL_Pos);
2400abc0:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
2400abc2:	f3c2 2240 	ubfx	r2, r2, #9, #1
2400abc6:	63c2      	str	r2, [r0, #60]	@ 0x3c
  PeriphClkInit->PLL2.PLL2M = (uint32_t)((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM2)>> RCC_PLLCKSELR_DIVM2_Pos);
2400abc8:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
2400abca:	f3c2 3205 	ubfx	r2, r2, #12, #6
2400abce:	6042      	str	r2, [r0, #4]
  PeriphClkInit->PLL2.PLL2N = (uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_N2) >> RCC_PLL2DIVR_N2_Pos)+ 1U;
2400abd0:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
2400abd2:	f3c2 0208 	ubfx	r2, r2, #0, #9
2400abd6:	3201      	adds	r2, #1
2400abd8:	6082      	str	r2, [r0, #8]
  PeriphClkInit->PLL2.PLL2R = (uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_R2) >> RCC_PLL2DIVR_R2_Pos)+ 1U;
2400abda:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
2400abdc:	f3c2 6206 	ubfx	r2, r2, #24, #7
2400abe0:	3201      	adds	r2, #1
2400abe2:	6142      	str	r2, [r0, #20]
  PeriphClkInit->PLL2.PLL2P = (uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_P2) >> RCC_PLL2DIVR_P2_Pos)+ 1U;
2400abe4:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
2400abe6:	f3c2 2246 	ubfx	r2, r2, #9, #7
2400abea:	3201      	adds	r2, #1
2400abec:	60c2      	str	r2, [r0, #12]
  PeriphClkInit->PLL2.PLL2Q = (uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_Q2) >> RCC_PLL2DIVR_Q2_Pos)+ 1U;
2400abee:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
2400abf0:	f3c2 4206 	ubfx	r2, r2, #16, #7
2400abf4:	3201      	adds	r2, #1
2400abf6:	6102      	str	r2, [r0, #16]
  PeriphClkInit->PLL2.PLL2RGE = (uint32_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLL2RGE) >> RCC_PLLCFGR_PLL2RGE_Pos);
2400abf8:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
2400abfa:	f3c2 1281 	ubfx	r2, r2, #6, #2
2400abfe:	6182      	str	r2, [r0, #24]
  PeriphClkInit->PLL2.PLL2VCOSEL = (uint32_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLL2VCOSEL) >> RCC_PLLCFGR_PLL2VCOSEL_Pos);
2400ac00:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
2400ac02:	f3c2 1240 	ubfx	r2, r2, #5, #1
2400ac06:	61c2      	str	r2, [r0, #28]
  PeriphClkInit->Usart16ClockSelection      = __HAL_RCC_GET_USART16_SOURCE();
2400ac08:	6d5a      	ldr	r2, [r3, #84]	@ 0x54
2400ac0a:	f002 0238 	and.w	r2, r2, #56	@ 0x38
2400ac0e:	6782      	str	r2, [r0, #120]	@ 0x78
  PeriphClkInit->Usart234578ClockSelection  = __HAL_RCC_GET_USART234578_SOURCE();
2400ac10:	6d5a      	ldr	r2, [r3, #84]	@ 0x54
2400ac12:	f002 0207 	and.w	r2, r2, #7
2400ac16:	6742      	str	r2, [r0, #116]	@ 0x74
  PeriphClkInit->Lpuart1ClockSelection      = __HAL_RCC_GET_LPUART1_SOURCE();
2400ac18:	6d9a      	ldr	r2, [r3, #88]	@ 0x58
2400ac1a:	f002 0207 	and.w	r2, r2, #7
2400ac1e:	f8c0 2090 	str.w	r2, [r0, #144]	@ 0x90
  PeriphClkInit->I2c123ClockSelection       = __HAL_RCC_GET_I2C1_SOURCE();
2400ac22:	6d5a      	ldr	r2, [r3, #84]	@ 0x54
2400ac24:	f402 5240 	and.w	r2, r2, #12288	@ 0x3000
2400ac28:	f8c0 2080 	str.w	r2, [r0, #128]	@ 0x80
  PeriphClkInit->Lptim1ClockSelection       = __HAL_RCC_GET_LPTIM1_SOURCE();
2400ac2c:	6d5a      	ldr	r2, [r3, #84]	@ 0x54
2400ac2e:	f002 42e0 	and.w	r2, r2, #1879048192	@ 0x70000000
2400ac32:	f8c0 208c 	str.w	r2, [r0, #140]	@ 0x8c
  PeriphClkInit->Lptim2ClockSelection       = __HAL_RCC_GET_LPTIM2_SOURCE();
2400ac36:	6d9a      	ldr	r2, [r3, #88]	@ 0x58
2400ac38:	f402 52e0 	and.w	r2, r2, #7168	@ 0x1c00
2400ac3c:	f8c0 2098 	str.w	r2, [r0, #152]	@ 0x98
  PeriphClkInit->Lptim345ClockSelection     = __HAL_RCC_GET_LPTIM345_SOURCE();
2400ac40:	6d9a      	ldr	r2, [r3, #88]	@ 0x58
2400ac42:	f402 4260 	and.w	r2, r2, #57344	@ 0xe000
2400ac46:	f8c0 209c 	str.w	r2, [r0, #156]	@ 0x9c
  PeriphClkInit->Sai1ClockSelection         = __HAL_RCC_GET_SAI1_SOURCE();
2400ac4a:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
2400ac4c:	f002 0207 	and.w	r2, r2, #7
2400ac50:	6542      	str	r2, [r0, #84]	@ 0x54
  PeriphClkInit->Sai23ClockSelection        = __HAL_RCC_GET_SAI23_SOURCE();
2400ac52:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
2400ac54:	f402 72e0 	and.w	r2, r2, #448	@ 0x1c0
2400ac58:	6582      	str	r2, [r0, #88]	@ 0x58
  PeriphClkInit->Sai4AClockSelection        = __HAL_RCC_GET_SAI4A_SOURCE();
2400ac5a:	6d9a      	ldr	r2, [r3, #88]	@ 0x58
2400ac5c:	f402 0260 	and.w	r2, r2, #14680064	@ 0xe00000
2400ac60:	f8c0 20a4 	str.w	r2, [r0, #164]	@ 0xa4
  PeriphClkInit->Sai4BClockSelection        = __HAL_RCC_GET_SAI4B_SOURCE();
2400ac64:	6d9a      	ldr	r2, [r3, #88]	@ 0x58
2400ac66:	f002 62e0 	and.w	r2, r2, #117440512	@ 0x7000000
2400ac6a:	f8c0 20a8 	str.w	r2, [r0, #168]	@ 0xa8
  PeriphClkInit->RTCClockSelection          = __HAL_RCC_GET_RTC_SOURCE();
2400ac6e:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
2400ac70:	f402 7240 	and.w	r2, r2, #768	@ 0x300
2400ac74:	f8c0 20b0 	str.w	r2, [r0, #176]	@ 0xb0
  PeriphClkInit->UsbClockSelection          = __HAL_RCC_GET_USB_SOURCE();
2400ac78:	6d5a      	ldr	r2, [r3, #84]	@ 0x54
2400ac7a:	f402 1240 	and.w	r2, r2, #3145728	@ 0x300000
2400ac7e:	f8c0 2084 	str.w	r2, [r0, #132]	@ 0x84
  PeriphClkInit->SdmmcClockSelection        = __HAL_RCC_GET_SDMMC_SOURCE();
2400ac82:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
2400ac84:	f402 3280 	and.w	r2, r2, #65536	@ 0x10000
2400ac88:	64c2      	str	r2, [r0, #76]	@ 0x4c
  PeriphClkInit->RngClockSelection          = __HAL_RCC_GET_RNG_SOURCE();
2400ac8a:	6d5a      	ldr	r2, [r3, #84]	@ 0x54
2400ac8c:	f402 7240 	and.w	r2, r2, #768	@ 0x300
2400ac90:	67c2      	str	r2, [r0, #124]	@ 0x7c
  PeriphClkInit->Hrtim1ClockSelection       = __HAL_RCC_GET_HRTIM1_SOURCE();
2400ac92:	691a      	ldr	r2, [r3, #16]
2400ac94:	f402 4280 	and.w	r2, r2, #16384	@ 0x4000
2400ac98:	f8c0 20b4 	str.w	r2, [r0, #180]	@ 0xb4
  PeriphClkInit->AdcClockSelection          = __HAL_RCC_GET_ADC_SOURCE();
2400ac9c:	6d9a      	ldr	r2, [r3, #88]	@ 0x58
2400ac9e:	f402 3240 	and.w	r2, r2, #196608	@ 0x30000
2400aca2:	f8c0 20a0 	str.w	r2, [r0, #160]	@ 0xa0
  PeriphClkInit->Swpmi1ClockSelection       = __HAL_RCC_GET_SWPMI1_SOURCE();
2400aca6:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
2400aca8:	f002 4200 	and.w	r2, r2, #2147483648	@ 0x80000000
2400acac:	6702      	str	r2, [r0, #112]	@ 0x70
  PeriphClkInit->Dfsdm1ClockSelection       = __HAL_RCC_GET_DFSDM1_SOURCE();
2400acae:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
2400acb0:	f002 7280 	and.w	r2, r2, #16777216	@ 0x1000000
2400acb4:	6682      	str	r2, [r0, #104]	@ 0x68
  PeriphClkInit->SpdifrxClockSelection      = __HAL_RCC_GET_SPDIFRX_SOURCE();
2400acb6:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
2400acb8:	f402 1240 	and.w	r2, r2, #3145728	@ 0x300000
2400acbc:	6642      	str	r2, [r0, #100]	@ 0x64
  PeriphClkInit->Spi123ClockSelection       = __HAL_RCC_GET_SPI123_SOURCE();
2400acbe:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
2400acc0:	f402 42e0 	and.w	r2, r2, #28672	@ 0x7000
2400acc4:	65c2      	str	r2, [r0, #92]	@ 0x5c
  PeriphClkInit->Spi45ClockSelection        = __HAL_RCC_GET_SPI45_SOURCE();
2400acc6:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
2400acc8:	f402 22e0 	and.w	r2, r2, #458752	@ 0x70000
2400accc:	6602      	str	r2, [r0, #96]	@ 0x60
  PeriphClkInit->Spi6ClockSelection         = __HAL_RCC_GET_SPI6_SOURCE();
2400acce:	6d9a      	ldr	r2, [r3, #88]	@ 0x58
2400acd0:	f002 42e0 	and.w	r2, r2, #1879048192	@ 0x70000000
2400acd4:	f8c0 20ac 	str.w	r2, [r0, #172]	@ 0xac
  PeriphClkInit->FdcanClockSelection        = __HAL_RCC_GET_FDCAN_SOURCE();
2400acd8:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
2400acda:	f002 5240 	and.w	r2, r2, #805306368	@ 0x30000000
2400acde:	66c2      	str	r2, [r0, #108]	@ 0x6c
  PeriphClkInit->CecClockSelection          = __HAL_RCC_GET_CEC_SOURCE();
2400ace0:	6d5a      	ldr	r2, [r3, #84]	@ 0x54
2400ace2:	f402 0240 	and.w	r2, r2, #12582912	@ 0xc00000
2400ace6:	f8c0 2088 	str.w	r2, [r0, #136]	@ 0x88
  PeriphClkInit->FmcClockSelection          = __HAL_RCC_GET_FMC_SOURCE();
2400acea:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
2400acec:	f002 0203 	and.w	r2, r2, #3
2400acf0:	6442      	str	r2, [r0, #68]	@ 0x44
  PeriphClkInit->QspiClockSelection         = __HAL_RCC_GET_QSPI_SOURCE();
2400acf2:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
2400acf4:	f002 0230 	and.w	r2, r2, #48	@ 0x30
2400acf8:	6482      	str	r2, [r0, #72]	@ 0x48
  PeriphClkInit->CkperClockSelection        = __HAL_RCC_GET_CLKP_SOURCE();
2400acfa:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
2400acfc:	f002 5240 	and.w	r2, r2, #805306368	@ 0x30000000
2400ad00:	6502      	str	r2, [r0, #80]	@ 0x50
  if ((RCC->CFGR & RCC_CFGR_TIMPRE) == 0U)
2400ad02:	691b      	ldr	r3, [r3, #16]
2400ad04:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
2400ad08:	f8c0 30b8 	str.w	r3, [r0, #184]	@ 0xb8
}
2400ad0c:	4770      	bx	lr
2400ad0e:	bf00      	nop
2400ad10:	58024400 	.word	0x58024400

2400ad14 <HAL_RCCEx_GetD1PCLK1Freq>:
{
2400ad14:	b508      	push	{r3, lr}
  return (HAL_RCC_GetHCLKFreq() >> (D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1PPRE)>> RCC_D1CFGR_D1PPRE_Pos] & 0x1FU));
2400ad16:	f7ff f8d9 	bl	24009ecc <HAL_RCC_GetHCLKFreq>
2400ad1a:	4b05      	ldr	r3, [pc, #20]	@ (2400ad30 <HAL_RCCEx_GetD1PCLK1Freq+0x1c>)
2400ad1c:	4a05      	ldr	r2, [pc, #20]	@ (2400ad34 <HAL_RCCEx_GetD1PCLK1Freq+0x20>)
2400ad1e:	699b      	ldr	r3, [r3, #24]
2400ad20:	f3c3 1302 	ubfx	r3, r3, #4, #3
2400ad24:	5cd3      	ldrb	r3, [r2, r3]
2400ad26:	f003 031f 	and.w	r3, r3, #31
}
2400ad2a:	40d8      	lsrs	r0, r3
2400ad2c:	bd08      	pop	{r3, pc}
2400ad2e:	bf00      	nop
2400ad30:	58024400 	.word	0x58024400
2400ad34:	240141fa 	.word	0x240141fa

2400ad38 <HAL_RCCEx_GetD3PCLK1Freq>:
{
2400ad38:	b508      	push	{r3, lr}
  return (HAL_RCC_GetHCLKFreq() >> (D1CorePrescTable[(RCC->D3CFGR & RCC_D3CFGR_D3PPRE)>> RCC_D3CFGR_D3PPRE_Pos] & 0x1FU));
2400ad3a:	f7ff f8c7 	bl	24009ecc <HAL_RCC_GetHCLKFreq>
2400ad3e:	4b05      	ldr	r3, [pc, #20]	@ (2400ad54 <HAL_RCCEx_GetD3PCLK1Freq+0x1c>)
2400ad40:	4a05      	ldr	r2, [pc, #20]	@ (2400ad58 <HAL_RCCEx_GetD3PCLK1Freq+0x20>)
2400ad42:	6a1b      	ldr	r3, [r3, #32]
2400ad44:	f3c3 1302 	ubfx	r3, r3, #4, #3
2400ad48:	5cd3      	ldrb	r3, [r2, r3]
2400ad4a:	f003 031f 	and.w	r3, r3, #31
}
2400ad4e:	40d8      	lsrs	r0, r3
2400ad50:	bd08      	pop	{r3, pc}
2400ad52:	bf00      	nop
2400ad54:	58024400 	.word	0x58024400
2400ad58:	240141fa 	.word	0x240141fa

2400ad5c <HAL_RCCEx_GetPLL2ClockFreq>:
  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
2400ad5c:	494f      	ldr	r1, [pc, #316]	@ (2400ae9c <HAL_RCCEx_GetPLL2ClockFreq+0x140>)
{
2400ad5e:	b570      	push	{r4, r5, r6, lr}
  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
2400ad60:	6a8c      	ldr	r4, [r1, #40]	@ 0x28
  pll2m = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM2)>> 12);
2400ad62:	6a8e      	ldr	r6, [r1, #40]	@ 0x28
  pll2fracen = (RCC->PLLCFGR & RCC_PLLCFGR_PLL2FRACEN) >> RCC_PLLCFGR_PLL2FRACEN_Pos;
2400ad64:	6acd      	ldr	r5, [r1, #44]	@ 0x2c
  if (pll2m != 0U)
2400ad66:	f416 3f7c 	tst.w	r6, #258048	@ 0x3f000
  pll2m = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM2)>> 12);
2400ad6a:	f3c6 3305 	ubfx	r3, r6, #12, #6
  fracn2 =(float_t)(uint32_t)(pll2fracen* ((RCC->PLL2FRACR & RCC_PLL2FRACR_FRACN2)>> 3));
2400ad6e:	6bca      	ldr	r2, [r1, #60]	@ 0x3c
  if (pll2m != 0U)
2400ad70:	f000 8090 	beq.w	2400ae94 <HAL_RCCEx_GetPLL2ClockFreq+0x138>
        pll2vco = ( (float_t)hsivalue / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2/(float_t)0x2000) +(float_t)1 );
2400ad74:	ee07 3a90 	vmov	s15, r3
  fracn2 =(float_t)(uint32_t)(pll2fracen* ((RCC->PLL2FRACR & RCC_PLL2FRACR_FRACN2)>> 3));
2400ad78:	f3c2 03cc 	ubfx	r3, r2, #3, #13
  pll2fracen = (RCC->PLLCFGR & RCC_PLLCFGR_PLL2FRACEN) >> RCC_PLLCFGR_PLL2FRACEN_Pos;
2400ad7c:	f3c5 1200 	ubfx	r2, r5, #4, #1
  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
2400ad80:	f004 0403 	and.w	r4, r4, #3
        pll2vco = ( (float_t)hsivalue / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2/(float_t)0x2000) +(float_t)1 );
2400ad84:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
  fracn2 =(float_t)(uint32_t)(pll2fracen* ((RCC->PLL2FRACR & RCC_PLL2FRACR_FRACN2)>> 3));
2400ad88:	4353      	muls	r3, r2
    switch (pllsource)
2400ad8a:	2c01      	cmp	r4, #1
2400ad8c:	eeb7 6a00 	vmov.f32	s12, #112	@ 0x3f800000  1.0
        pll2vco = ( (float_t)hsivalue / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2/(float_t)0x2000) +(float_t)1 );
2400ad90:	ee06 3a90 	vmov	s13, r3
2400ad94:	eefa 6ae9 	vcvt.f32.s32	s13, s13, #13
    switch (pllsource)
2400ad98:	d06e      	beq.n	2400ae78 <HAL_RCCEx_GetPLL2ClockFreq+0x11c>
2400ad9a:	2c02      	cmp	r4, #2
2400ad9c:	d05e      	beq.n	2400ae5c <HAL_RCCEx_GetPLL2ClockFreq+0x100>
2400ad9e:	2c00      	cmp	r4, #0
2400ada0:	d16a      	bne.n	2400ae78 <HAL_RCCEx_GetPLL2ClockFreq+0x11c>
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
2400ada2:	680b      	ldr	r3, [r1, #0]
2400ada4:	069b      	lsls	r3, r3, #26
2400ada6:	d547      	bpl.n	2400ae38 <HAL_RCCEx_GetPLL2ClockFreq+0xdc>
        hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
2400ada8:	680a      	ldr	r2, [r1, #0]
        pll2vco = ( (float_t)hsivalue / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2/(float_t)0x2000) +(float_t)1 );
2400adaa:	6b8b      	ldr	r3, [r1, #56]	@ 0x38
        hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
2400adac:	f3c2 01c1 	ubfx	r1, r2, #3, #2
2400adb0:	4a3b      	ldr	r2, [pc, #236]	@ (2400aea0 <HAL_RCCEx_GetPLL2ClockFreq+0x144>)
        pll2vco = ( (float_t)hsivalue / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2/(float_t)0x2000) +(float_t)1 );
2400adb2:	f3c3 0308 	ubfx	r3, r3, #0, #9
        hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
2400adb6:	40ca      	lsrs	r2, r1
        pll2vco = ( (float_t)hsivalue / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2/(float_t)0x2000) +(float_t)1 );
2400adb8:	ee07 2a90 	vmov	s15, r2
2400adbc:	eef8 5ae7 	vcvt.f32.s32	s11, s15
2400adc0:	eec5 7a87 	vdiv.f32	s15, s11, s14
2400adc4:	ee07 3a10 	vmov	s14, r3
2400adc8:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
2400adcc:	ee37 7a26 	vadd.f32	s14, s14, s13
2400add0:	ee37 7a06 	vadd.f32	s14, s14, s12
2400add4:	ee67 7a87 	vmul.f32	s15, s15, s14
    PLL2_Clocks->PLL2_P_Frequency = (uint32_t)(float_t)(pll2vco/((float_t)(uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_P2) >>9)  + (float_t)1 )) ;
2400add8:	4a30      	ldr	r2, [pc, #192]	@ (2400ae9c <HAL_RCCEx_GetPLL2ClockFreq+0x140>)
2400adda:	6b93      	ldr	r3, [r2, #56]	@ 0x38
2400addc:	f3c3 2346 	ubfx	r3, r3, #9, #7
2400ade0:	ee07 3a10 	vmov	s14, r3
2400ade4:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
2400ade8:	ee37 7a06 	vadd.f32	s14, s14, s12
2400adec:	eec7 6a87 	vdiv.f32	s13, s15, s14
2400adf0:	eefc 6ae6 	vcvt.u32.f32	s13, s13
2400adf4:	edc0 6a00 	vstr	s13, [r0]
    PLL2_Clocks->PLL2_Q_Frequency = (uint32_t)(float_t)(pll2vco/((float_t)(uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_Q2) >>16) + (float_t)1 )) ;
2400adf8:	6b93      	ldr	r3, [r2, #56]	@ 0x38
2400adfa:	f3c3 4306 	ubfx	r3, r3, #16, #7
2400adfe:	ee07 3a10 	vmov	s14, r3
2400ae02:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
2400ae06:	ee37 7a06 	vadd.f32	s14, s14, s12
2400ae0a:	eec7 6a87 	vdiv.f32	s13, s15, s14
2400ae0e:	eefc 6ae6 	vcvt.u32.f32	s13, s13
2400ae12:	edc0 6a01 	vstr	s13, [r0, #4]
    PLL2_Clocks->PLL2_R_Frequency = (uint32_t)(float_t)(pll2vco/((float_t)(uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_R2) >>24) + (float_t)1 )) ;
2400ae16:	6b93      	ldr	r3, [r2, #56]	@ 0x38
2400ae18:	f3c3 6306 	ubfx	r3, r3, #24, #7
2400ae1c:	ee06 3a90 	vmov	s13, r3
2400ae20:	eef8 6ae6 	vcvt.f32.s32	s13, s13
2400ae24:	ee76 6a86 	vadd.f32	s13, s13, s12
2400ae28:	ee87 7aa6 	vdiv.f32	s14, s15, s13
2400ae2c:	eefc 7ac7 	vcvt.u32.f32	s15, s14
2400ae30:	ee17 3a90 	vmov	r3, s15
2400ae34:	6083      	str	r3, [r0, #8]
}
2400ae36:	bd70      	pop	{r4, r5, r6, pc}
        pll2vco = ((float_t)HSI_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2/(float_t)0x2000) +(float_t)1 );
2400ae38:	6b8b      	ldr	r3, [r1, #56]	@ 0x38
2400ae3a:	eddf 5a1a 	vldr	s11, [pc, #104]	@ 2400aea4 <HAL_RCCEx_GetPLL2ClockFreq+0x148>
2400ae3e:	f3c3 0308 	ubfx	r3, r3, #0, #9
2400ae42:	ee07 3a90 	vmov	s15, r3
2400ae46:	eef8 7ae7 	vcvt.f32.s32	s15, s15
2400ae4a:	ee77 7aa6 	vadd.f32	s15, s15, s13
2400ae4e:	ee77 7a86 	vadd.f32	s15, s15, s12
      pll2vco = ((float_t)CSI_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2/(float_t)0x2000) +(float_t)1 );
2400ae52:	eec5 6a87 	vdiv.f32	s13, s11, s14
2400ae56:	ee67 7aa6 	vmul.f32	s15, s15, s13
      break;
2400ae5a:	e7bd      	b.n	2400add8 <HAL_RCCEx_GetPLL2ClockFreq+0x7c>
      pll2vco = ((float_t)HSE_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2/(float_t)0x2000) +(float_t)1 );
2400ae5c:	6b8b      	ldr	r3, [r1, #56]	@ 0x38
2400ae5e:	eddf 5a12 	vldr	s11, [pc, #72]	@ 2400aea8 <HAL_RCCEx_GetPLL2ClockFreq+0x14c>
2400ae62:	f3c3 0308 	ubfx	r3, r3, #0, #9
2400ae66:	ee07 3a90 	vmov	s15, r3
2400ae6a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
2400ae6e:	ee77 7aa6 	vadd.f32	s15, s15, s13
2400ae72:	ee77 7a86 	vadd.f32	s15, s15, s12
2400ae76:	e7ec      	b.n	2400ae52 <HAL_RCCEx_GetPLL2ClockFreq+0xf6>
      pll2vco = ((float_t)CSI_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2/(float_t)0x2000) +(float_t)1 );
2400ae78:	6b8b      	ldr	r3, [r1, #56]	@ 0x38
2400ae7a:	eddf 5a0c 	vldr	s11, [pc, #48]	@ 2400aeac <HAL_RCCEx_GetPLL2ClockFreq+0x150>
2400ae7e:	f3c3 0308 	ubfx	r3, r3, #0, #9
2400ae82:	ee07 3a90 	vmov	s15, r3
2400ae86:	eef8 7ae7 	vcvt.f32.s32	s15, s15
2400ae8a:	ee77 7aa6 	vadd.f32	s15, s15, s13
2400ae8e:	ee77 7a86 	vadd.f32	s15, s15, s12
2400ae92:	e7de      	b.n	2400ae52 <HAL_RCCEx_GetPLL2ClockFreq+0xf6>
    PLL2_Clocks->PLL2_Q_Frequency = 0U;
2400ae94:	e9c0 3300 	strd	r3, r3, [r0]
    PLL2_Clocks->PLL2_R_Frequency = 0U;
2400ae98:	e7cc      	b.n	2400ae34 <HAL_RCCEx_GetPLL2ClockFreq+0xd8>
2400ae9a:	bf00      	nop
2400ae9c:	58024400 	.word	0x58024400
2400aea0:	03d09000 	.word	0x03d09000
2400aea4:	4c742400 	.word	0x4c742400
2400aea8:	4bbebc20 	.word	0x4bbebc20
2400aeac:	4a742400 	.word	0x4a742400

2400aeb0 <HAL_RCCEx_GetPLL3ClockFreq>:
  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
2400aeb0:	494f      	ldr	r1, [pc, #316]	@ (2400aff0 <HAL_RCCEx_GetPLL3ClockFreq+0x140>)
{
2400aeb2:	b570      	push	{r4, r5, r6, lr}
  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
2400aeb4:	6a8c      	ldr	r4, [r1, #40]	@ 0x28
  pll3m = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM3)>> 20)  ;
2400aeb6:	6a8e      	ldr	r6, [r1, #40]	@ 0x28
  pll3fracen = (RCC->PLLCFGR & RCC_PLLCFGR_PLL3FRACEN) >> RCC_PLLCFGR_PLL3FRACEN_Pos;
2400aeb8:	6acd      	ldr	r5, [r1, #44]	@ 0x2c
  if (pll3m != 0U)
2400aeba:	f016 7f7c 	tst.w	r6, #66060288	@ 0x3f00000
  pll3m = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM3)>> 20)  ;
2400aebe:	f3c6 5305 	ubfx	r3, r6, #20, #6
  fracn3 = (float_t)(uint32_t)(pll3fracen* ((RCC->PLL3FRACR & RCC_PLL3FRACR_FRACN3)>> 3));
2400aec2:	6c4a      	ldr	r2, [r1, #68]	@ 0x44
  if (pll3m != 0U)
2400aec4:	f000 8090 	beq.w	2400afe8 <HAL_RCCEx_GetPLL3ClockFreq+0x138>
        pll3vco = ((float_t)hsivalue / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3/(float_t)0x2000) +(float_t)1 );
2400aec8:	ee07 3a90 	vmov	s15, r3
  fracn3 = (float_t)(uint32_t)(pll3fracen* ((RCC->PLL3FRACR & RCC_PLL3FRACR_FRACN3)>> 3));
2400aecc:	f3c2 03cc 	ubfx	r3, r2, #3, #13
  pll3fracen = (RCC->PLLCFGR & RCC_PLLCFGR_PLL3FRACEN) >> RCC_PLLCFGR_PLL3FRACEN_Pos;
2400aed0:	f3c5 2200 	ubfx	r2, r5, #8, #1
  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
2400aed4:	f004 0403 	and.w	r4, r4, #3
        pll3vco = ((float_t)hsivalue / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3/(float_t)0x2000) +(float_t)1 );
2400aed8:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
  fracn3 = (float_t)(uint32_t)(pll3fracen* ((RCC->PLL3FRACR & RCC_PLL3FRACR_FRACN3)>> 3));
2400aedc:	4353      	muls	r3, r2
    switch (pllsource)
2400aede:	2c01      	cmp	r4, #1
2400aee0:	eeb7 6a00 	vmov.f32	s12, #112	@ 0x3f800000  1.0
        pll3vco = ((float_t)hsivalue / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3/(float_t)0x2000) +(float_t)1 );
2400aee4:	ee06 3a90 	vmov	s13, r3
2400aee8:	eefa 6ae9 	vcvt.f32.s32	s13, s13, #13
    switch (pllsource)
2400aeec:	d06e      	beq.n	2400afcc <HAL_RCCEx_GetPLL3ClockFreq+0x11c>
2400aeee:	2c02      	cmp	r4, #2
2400aef0:	d05e      	beq.n	2400afb0 <HAL_RCCEx_GetPLL3ClockFreq+0x100>
2400aef2:	2c00      	cmp	r4, #0
2400aef4:	d16a      	bne.n	2400afcc <HAL_RCCEx_GetPLL3ClockFreq+0x11c>
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
2400aef6:	680b      	ldr	r3, [r1, #0]
2400aef8:	069b      	lsls	r3, r3, #26
2400aefa:	d547      	bpl.n	2400af8c <HAL_RCCEx_GetPLL3ClockFreq+0xdc>
        hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
2400aefc:	680a      	ldr	r2, [r1, #0]
        pll3vco = ((float_t)hsivalue / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3/(float_t)0x2000) +(float_t)1 );
2400aefe:	6c0b      	ldr	r3, [r1, #64]	@ 0x40
        hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
2400af00:	f3c2 01c1 	ubfx	r1, r2, #3, #2
2400af04:	4a3b      	ldr	r2, [pc, #236]	@ (2400aff4 <HAL_RCCEx_GetPLL3ClockFreq+0x144>)
        pll3vco = ((float_t)hsivalue / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3/(float_t)0x2000) +(float_t)1 );
2400af06:	f3c3 0308 	ubfx	r3, r3, #0, #9
        hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
2400af0a:	40ca      	lsrs	r2, r1
        pll3vco = ((float_t)hsivalue / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3/(float_t)0x2000) +(float_t)1 );
2400af0c:	ee07 2a90 	vmov	s15, r2
2400af10:	eef8 5ae7 	vcvt.f32.s32	s11, s15
2400af14:	eec5 7a87 	vdiv.f32	s15, s11, s14
2400af18:	ee07 3a10 	vmov	s14, r3
2400af1c:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
2400af20:	ee37 7a26 	vadd.f32	s14, s14, s13
2400af24:	ee37 7a06 	vadd.f32	s14, s14, s12
2400af28:	ee67 7a87 	vmul.f32	s15, s15, s14
    PLL3_Clocks->PLL3_P_Frequency = (uint32_t)(float_t)(pll3vco/((float_t)(uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_P3) >>9)  + (float_t)1 )) ;
2400af2c:	4a30      	ldr	r2, [pc, #192]	@ (2400aff0 <HAL_RCCEx_GetPLL3ClockFreq+0x140>)
2400af2e:	6c13      	ldr	r3, [r2, #64]	@ 0x40
2400af30:	f3c3 2346 	ubfx	r3, r3, #9, #7
2400af34:	ee07 3a10 	vmov	s14, r3
2400af38:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
2400af3c:	ee37 7a06 	vadd.f32	s14, s14, s12
2400af40:	eec7 6a87 	vdiv.f32	s13, s15, s14
2400af44:	eefc 6ae6 	vcvt.u32.f32	s13, s13
2400af48:	edc0 6a00 	vstr	s13, [r0]
    PLL3_Clocks->PLL3_Q_Frequency = (uint32_t)(float_t)(pll3vco/((float_t)(uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_Q3) >>16) + (float_t)1 )) ;
2400af4c:	6c13      	ldr	r3, [r2, #64]	@ 0x40
2400af4e:	f3c3 4306 	ubfx	r3, r3, #16, #7
2400af52:	ee07 3a10 	vmov	s14, r3
2400af56:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
2400af5a:	ee37 7a06 	vadd.f32	s14, s14, s12
2400af5e:	eec7 6a87 	vdiv.f32	s13, s15, s14
2400af62:	eefc 6ae6 	vcvt.u32.f32	s13, s13
2400af66:	edc0 6a01 	vstr	s13, [r0, #4]
    PLL3_Clocks->PLL3_R_Frequency = (uint32_t)(float_t)(pll3vco/((float_t)(uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_R3) >>24) + (float_t)1 )) ;
2400af6a:	6c13      	ldr	r3, [r2, #64]	@ 0x40
2400af6c:	f3c3 6306 	ubfx	r3, r3, #24, #7
2400af70:	ee06 3a90 	vmov	s13, r3
2400af74:	eef8 6ae6 	vcvt.f32.s32	s13, s13
2400af78:	ee76 6a86 	vadd.f32	s13, s13, s12
2400af7c:	ee87 7aa6 	vdiv.f32	s14, s15, s13
2400af80:	eefc 7ac7 	vcvt.u32.f32	s15, s14
2400af84:	ee17 3a90 	vmov	r3, s15
2400af88:	6083      	str	r3, [r0, #8]
}
2400af8a:	bd70      	pop	{r4, r5, r6, pc}
        pll3vco = ((float_t)HSI_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3/(float_t)0x2000) +(float_t)1 );
2400af8c:	6c0b      	ldr	r3, [r1, #64]	@ 0x40
2400af8e:	eddf 5a1a 	vldr	s11, [pc, #104]	@ 2400aff8 <HAL_RCCEx_GetPLL3ClockFreq+0x148>
2400af92:	f3c3 0308 	ubfx	r3, r3, #0, #9
2400af96:	ee07 3a90 	vmov	s15, r3
2400af9a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
2400af9e:	ee77 7aa6 	vadd.f32	s15, s15, s13
2400afa2:	ee77 7a86 	vadd.f32	s15, s15, s12
      pll3vco = ((float_t)CSI_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3/(float_t)0x2000) +(float_t)1 );
2400afa6:	eec5 6a87 	vdiv.f32	s13, s11, s14
2400afaa:	ee67 7aa6 	vmul.f32	s15, s15, s13
      break;
2400afae:	e7bd      	b.n	2400af2c <HAL_RCCEx_GetPLL3ClockFreq+0x7c>
      pll3vco = ((float_t)HSE_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3/(float_t)0x2000) +(float_t)1 );
2400afb0:	6c0b      	ldr	r3, [r1, #64]	@ 0x40
2400afb2:	eddf 5a12 	vldr	s11, [pc, #72]	@ 2400affc <HAL_RCCEx_GetPLL3ClockFreq+0x14c>
2400afb6:	f3c3 0308 	ubfx	r3, r3, #0, #9
2400afba:	ee07 3a90 	vmov	s15, r3
2400afbe:	eef8 7ae7 	vcvt.f32.s32	s15, s15
2400afc2:	ee77 7aa6 	vadd.f32	s15, s15, s13
2400afc6:	ee77 7a86 	vadd.f32	s15, s15, s12
2400afca:	e7ec      	b.n	2400afa6 <HAL_RCCEx_GetPLL3ClockFreq+0xf6>
      pll3vco = ((float_t)CSI_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3/(float_t)0x2000) +(float_t)1 );
2400afcc:	6c0b      	ldr	r3, [r1, #64]	@ 0x40
2400afce:	eddf 5a0c 	vldr	s11, [pc, #48]	@ 2400b000 <HAL_RCCEx_GetPLL3ClockFreq+0x150>
2400afd2:	f3c3 0308 	ubfx	r3, r3, #0, #9
2400afd6:	ee07 3a90 	vmov	s15, r3
2400afda:	eef8 7ae7 	vcvt.f32.s32	s15, s15
2400afde:	ee77 7aa6 	vadd.f32	s15, s15, s13
2400afe2:	ee77 7a86 	vadd.f32	s15, s15, s12
2400afe6:	e7de      	b.n	2400afa6 <HAL_RCCEx_GetPLL3ClockFreq+0xf6>
    PLL3_Clocks->PLL3_Q_Frequency = 0U;
2400afe8:	e9c0 3300 	strd	r3, r3, [r0]
    PLL3_Clocks->PLL3_R_Frequency = 0U;
2400afec:	e7cc      	b.n	2400af88 <HAL_RCCEx_GetPLL3ClockFreq+0xd8>
2400afee:	bf00      	nop
2400aff0:	58024400 	.word	0x58024400
2400aff4:	03d09000 	.word	0x03d09000
2400aff8:	4c742400 	.word	0x4c742400
2400affc:	4bbebc20 	.word	0x4bbebc20
2400b000:	4a742400 	.word	0x4a742400

2400b004 <HAL_RCCEx_GetPLL1ClockFreq>:
  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
2400b004:	494f      	ldr	r1, [pc, #316]	@ (2400b144 <HAL_RCCEx_GetPLL1ClockFreq+0x140>)
{
2400b006:	b570      	push	{r4, r5, r6, lr}
  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
2400b008:	6a8c      	ldr	r4, [r1, #40]	@ 0x28
  pll1m = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM1)>> 4);
2400b00a:	6a8e      	ldr	r6, [r1, #40]	@ 0x28
  pll1fracen = RCC->PLLCFGR & RCC_PLLCFGR_PLL1FRACEN;
2400b00c:	6acd      	ldr	r5, [r1, #44]	@ 0x2c
  if (pll1m != 0U)
2400b00e:	f416 7f7c 	tst.w	r6, #1008	@ 0x3f0
  pll1m = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM1)>> 4);
2400b012:	f3c6 1305 	ubfx	r3, r6, #4, #6
  fracn1 = (float_t)(uint32_t)(pll1fracen * ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));
2400b016:	6b4a      	ldr	r2, [r1, #52]	@ 0x34
  if (pll1m != 0U)
2400b018:	f000 8090 	beq.w	2400b13c <HAL_RCCEx_GetPLL1ClockFreq+0x138>
        pll1vco = ((float_t)hsivalue / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
2400b01c:	ee07 3a90 	vmov	s15, r3
  fracn1 = (float_t)(uint32_t)(pll1fracen * ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));
2400b020:	f3c2 03cc 	ubfx	r3, r2, #3, #13
  pll1fracen = RCC->PLLCFGR & RCC_PLLCFGR_PLL1FRACEN;
2400b024:	f005 0201 	and.w	r2, r5, #1
  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
2400b028:	f004 0403 	and.w	r4, r4, #3
        pll1vco = ((float_t)hsivalue / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
2400b02c:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
  fracn1 = (float_t)(uint32_t)(pll1fracen * ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));
2400b030:	4353      	muls	r3, r2
    switch (pllsource)
2400b032:	2c01      	cmp	r4, #1
2400b034:	eeb7 6a00 	vmov.f32	s12, #112	@ 0x3f800000  1.0
        pll1vco = ((float_t)hsivalue / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
2400b038:	ee06 3a90 	vmov	s13, r3
2400b03c:	eefa 6ae9 	vcvt.f32.s32	s13, s13, #13
    switch (pllsource)
2400b040:	d06e      	beq.n	2400b120 <HAL_RCCEx_GetPLL1ClockFreq+0x11c>
2400b042:	2c02      	cmp	r4, #2
2400b044:	d05e      	beq.n	2400b104 <HAL_RCCEx_GetPLL1ClockFreq+0x100>
2400b046:	2c00      	cmp	r4, #0
2400b048:	d16a      	bne.n	2400b120 <HAL_RCCEx_GetPLL1ClockFreq+0x11c>
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
2400b04a:	680b      	ldr	r3, [r1, #0]
2400b04c:	069b      	lsls	r3, r3, #26
2400b04e:	d547      	bpl.n	2400b0e0 <HAL_RCCEx_GetPLL1ClockFreq+0xdc>
        hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
2400b050:	680a      	ldr	r2, [r1, #0]
        pll1vco = ((float_t)hsivalue / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
2400b052:	6b0b      	ldr	r3, [r1, #48]	@ 0x30
        hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
2400b054:	f3c2 01c1 	ubfx	r1, r2, #3, #2
2400b058:	4a3b      	ldr	r2, [pc, #236]	@ (2400b148 <HAL_RCCEx_GetPLL1ClockFreq+0x144>)
        pll1vco = ((float_t)hsivalue / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
2400b05a:	f3c3 0308 	ubfx	r3, r3, #0, #9
        hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
2400b05e:	40ca      	lsrs	r2, r1
        pll1vco = ((float_t)hsivalue / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
2400b060:	ee07 2a90 	vmov	s15, r2
2400b064:	eef8 5ae7 	vcvt.f32.s32	s11, s15
2400b068:	eec5 7a87 	vdiv.f32	s15, s11, s14
2400b06c:	ee07 3a10 	vmov	s14, r3
2400b070:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
2400b074:	ee37 7a26 	vadd.f32	s14, s14, s13
2400b078:	ee37 7a06 	vadd.f32	s14, s14, s12
2400b07c:	ee67 7a87 	vmul.f32	s15, s15, s14
    PLL1_Clocks->PLL1_P_Frequency = (uint32_t)(float_t)(pll1vco/((float_t)(uint32_t)((RCC->PLL1DIVR & RCC_PLL1DIVR_P1) >>9)  + (float_t)1 )) ;
2400b080:	4a30      	ldr	r2, [pc, #192]	@ (2400b144 <HAL_RCCEx_GetPLL1ClockFreq+0x140>)
2400b082:	6b13      	ldr	r3, [r2, #48]	@ 0x30
2400b084:	f3c3 2346 	ubfx	r3, r3, #9, #7
2400b088:	ee07 3a10 	vmov	s14, r3
2400b08c:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
2400b090:	ee37 7a06 	vadd.f32	s14, s14, s12
2400b094:	eec7 6a87 	vdiv.f32	s13, s15, s14
2400b098:	eefc 6ae6 	vcvt.u32.f32	s13, s13
2400b09c:	edc0 6a00 	vstr	s13, [r0]
    PLL1_Clocks->PLL1_Q_Frequency = (uint32_t)(float_t)(pll1vco/((float_t)(uint32_t)((RCC->PLL1DIVR & RCC_PLL1DIVR_Q1) >>16) + (float_t)1 )) ;
2400b0a0:	6b13      	ldr	r3, [r2, #48]	@ 0x30
2400b0a2:	f3c3 4306 	ubfx	r3, r3, #16, #7
2400b0a6:	ee07 3a10 	vmov	s14, r3
2400b0aa:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
2400b0ae:	ee37 7a06 	vadd.f32	s14, s14, s12
2400b0b2:	eec7 6a87 	vdiv.f32	s13, s15, s14
2400b0b6:	eefc 6ae6 	vcvt.u32.f32	s13, s13
2400b0ba:	edc0 6a01 	vstr	s13, [r0, #4]
    PLL1_Clocks->PLL1_R_Frequency = (uint32_t)(float_t)(pll1vco/((float_t)(uint32_t)((RCC->PLL1DIVR & RCC_PLL1DIVR_R1) >>24) + (float_t)1 )) ;
2400b0be:	6b13      	ldr	r3, [r2, #48]	@ 0x30
2400b0c0:	f3c3 6306 	ubfx	r3, r3, #24, #7
2400b0c4:	ee06 3a90 	vmov	s13, r3
2400b0c8:	eef8 6ae6 	vcvt.f32.s32	s13, s13
2400b0cc:	ee76 6a86 	vadd.f32	s13, s13, s12
2400b0d0:	ee87 7aa6 	vdiv.f32	s14, s15, s13
2400b0d4:	eefc 7ac7 	vcvt.u32.f32	s15, s14
2400b0d8:	ee17 3a90 	vmov	r3, s15
2400b0dc:	6083      	str	r3, [r0, #8]
}
2400b0de:	bd70      	pop	{r4, r5, r6, pc}
        pll1vco = ((float_t)HSI_VALUE / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
2400b0e0:	6b0b      	ldr	r3, [r1, #48]	@ 0x30
2400b0e2:	eddf 5a1a 	vldr	s11, [pc, #104]	@ 2400b14c <HAL_RCCEx_GetPLL1ClockFreq+0x148>
2400b0e6:	f3c3 0308 	ubfx	r3, r3, #0, #9
2400b0ea:	ee07 3a90 	vmov	s15, r3
2400b0ee:	eef8 7ae7 	vcvt.f32.s32	s15, s15
2400b0f2:	ee77 7aa6 	vadd.f32	s15, s15, s13
2400b0f6:	ee77 7a86 	vadd.f32	s15, s15, s12
      pll1vco = ((float_t)CSI_VALUE / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
2400b0fa:	eec5 6a87 	vdiv.f32	s13, s11, s14
2400b0fe:	ee67 7aa6 	vmul.f32	s15, s15, s13
      break;
2400b102:	e7bd      	b.n	2400b080 <HAL_RCCEx_GetPLL1ClockFreq+0x7c>
      pll1vco = ((float_t)HSE_VALUE / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
2400b104:	6b0b      	ldr	r3, [r1, #48]	@ 0x30
2400b106:	eddf 5a12 	vldr	s11, [pc, #72]	@ 2400b150 <HAL_RCCEx_GetPLL1ClockFreq+0x14c>
2400b10a:	f3c3 0308 	ubfx	r3, r3, #0, #9
2400b10e:	ee07 3a90 	vmov	s15, r3
2400b112:	eef8 7ae7 	vcvt.f32.s32	s15, s15
2400b116:	ee77 7aa6 	vadd.f32	s15, s15, s13
2400b11a:	ee77 7a86 	vadd.f32	s15, s15, s12
2400b11e:	e7ec      	b.n	2400b0fa <HAL_RCCEx_GetPLL1ClockFreq+0xf6>
      pll1vco = ((float_t)CSI_VALUE / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
2400b120:	6b0b      	ldr	r3, [r1, #48]	@ 0x30
2400b122:	eddf 5a0c 	vldr	s11, [pc, #48]	@ 2400b154 <HAL_RCCEx_GetPLL1ClockFreq+0x150>
2400b126:	f3c3 0308 	ubfx	r3, r3, #0, #9
2400b12a:	ee07 3a90 	vmov	s15, r3
2400b12e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
2400b132:	ee77 7aa6 	vadd.f32	s15, s15, s13
2400b136:	ee77 7a86 	vadd.f32	s15, s15, s12
2400b13a:	e7de      	b.n	2400b0fa <HAL_RCCEx_GetPLL1ClockFreq+0xf6>
    PLL1_Clocks->PLL1_Q_Frequency = 0U;
2400b13c:	e9c0 3300 	strd	r3, r3, [r0]
    PLL1_Clocks->PLL1_R_Frequency = 0U;
2400b140:	e7cc      	b.n	2400b0dc <HAL_RCCEx_GetPLL1ClockFreq+0xd8>
2400b142:	bf00      	nop
2400b144:	58024400 	.word	0x58024400
2400b148:	03d09000 	.word	0x03d09000
2400b14c:	4c742400 	.word	0x4c742400
2400b150:	4bbebc20 	.word	0x4bbebc20
2400b154:	4a742400 	.word	0x4a742400

2400b158 <HAL_RCCEx_GetPeriphCLKFreq>:
  if (PeriphClk == RCC_PERIPHCLK_SAI1)
2400b158:	f5b0 7f80 	cmp.w	r0, #256	@ 0x100
{
2400b15c:	b51f      	push	{r0, r1, r2, r3, r4, lr}
  if (PeriphClk == RCC_PERIPHCLK_SAI1)
2400b15e:	d113      	bne.n	2400b188 <HAL_RCCEx_GetPeriphCLKFreq+0x30>
      saiclocksource= __HAL_RCC_GET_SAI1_SOURCE();
2400b160:	4a67      	ldr	r2, [pc, #412]	@ (2400b300 <HAL_RCCEx_GetPeriphCLKFreq+0x1a8>)
2400b162:	6d13      	ldr	r3, [r2, #80]	@ 0x50
2400b164:	f003 0307 	and.w	r3, r3, #7
      switch (saiclocksource)
2400b168:	2b04      	cmp	r3, #4
2400b16a:	d81b      	bhi.n	2400b1a4 <HAL_RCCEx_GetPeriphCLKFreq+0x4c>
2400b16c:	e8df f003 	tbb	[pc, r3]
2400b170:	c2088203 	.word	0xc2088203
2400b174:	22          	.byte	0x22
2400b175:	00          	.byte	0x00
          HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
2400b176:	a801      	add	r0, sp, #4
2400b178:	f7ff ff44 	bl	2400b004 <HAL_RCCEx_GetPLL1ClockFreq>
          frequency = pll2_clocks.PLL2_Q_Frequency;
2400b17c:	9802      	ldr	r0, [sp, #8]
          break;
2400b17e:	e07d      	b.n	2400b27c <HAL_RCCEx_GetPeriphCLKFreq+0x124>
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
2400b180:	a801      	add	r0, sp, #4
2400b182:	f7ff fe95 	bl	2400aeb0 <HAL_RCCEx_GetPLL3ClockFreq>
2400b186:	e078      	b.n	2400b27a <HAL_RCCEx_GetPeriphCLKFreq+0x122>
  else if (PeriphClk == RCC_PERIPHCLK_SAI23)
2400b188:	f5b0 7f00 	cmp.w	r0, #512	@ 0x200
2400b18c:	d121      	bne.n	2400b1d2 <HAL_RCCEx_GetPeriphCLKFreq+0x7a>
      saiclocksource= __HAL_RCC_GET_SAI23_SOURCE();
2400b18e:	4a5c      	ldr	r2, [pc, #368]	@ (2400b300 <HAL_RCCEx_GetPeriphCLKFreq+0x1a8>)
2400b190:	6d13      	ldr	r3, [r2, #80]	@ 0x50
2400b192:	f403 73e0 	and.w	r3, r3, #448	@ 0x1c0
      switch (saiclocksource)
2400b196:	2b80      	cmp	r3, #128	@ 0x80
2400b198:	d0f2      	beq.n	2400b180 <HAL_RCCEx_GetPeriphCLKFreq+0x28>
2400b19a:	d805      	bhi.n	2400b1a8 <HAL_RCCEx_GetPeriphCLKFreq+0x50>
2400b19c:	2b00      	cmp	r3, #0
2400b19e:	d0ea      	beq.n	2400b176 <HAL_RCCEx_GetPeriphCLKFreq+0x1e>
2400b1a0:	2b40      	cmp	r3, #64	@ 0x40
      switch (srcclk)
2400b1a2:	d067      	beq.n	2400b274 <HAL_RCCEx_GetPeriphCLKFreq+0x11c>
2400b1a4:	2000      	movs	r0, #0
2400b1a6:	e069      	b.n	2400b27c <HAL_RCCEx_GetPeriphCLKFreq+0x124>
      switch (saiclocksource)
2400b1a8:	2bc0      	cmp	r3, #192	@ 0xc0
2400b1aa:	f000 80a3 	beq.w	2400b2f4 <HAL_RCCEx_GetPeriphCLKFreq+0x19c>
2400b1ae:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
      switch (srcclk)
2400b1b2:	d1f7      	bne.n	2400b1a4 <HAL_RCCEx_GetPeriphCLKFreq+0x4c>
          ckpclocksource= __HAL_RCC_GET_CLKP_SOURCE();
2400b1b4:	6cd3      	ldr	r3, [r2, #76]	@ 0x4c
          if(ckpclocksource== RCC_CLKPSOURCE_HSI)
2400b1b6:	f013 5340 	ands.w	r3, r3, #805306368	@ 0x30000000
2400b1ba:	f000 809d 	beq.w	2400b2f8 <HAL_RCCEx_GetPeriphCLKFreq+0x1a0>
          else if(ckpclocksource== RCC_CLKPSOURCE_CSI)
2400b1be:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
2400b1c2:	f000 809b 	beq.w	2400b2fc <HAL_RCCEx_GetPeriphCLKFreq+0x1a4>
            frequency = HSE_VALUE;
2400b1c6:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
      switch (srcclk)
2400b1ca:	484e      	ldr	r0, [pc, #312]	@ (2400b304 <HAL_RCCEx_GetPeriphCLKFreq+0x1ac>)
2400b1cc:	bf18      	it	ne
2400b1ce:	2000      	movne	r0, #0
2400b1d0:	e054      	b.n	2400b27c <HAL_RCCEx_GetPeriphCLKFreq+0x124>
  else if (PeriphClk == RCC_PERIPHCLK_SAI4A)
2400b1d2:	f5b0 6f80 	cmp.w	r0, #1024	@ 0x400
2400b1d6:	d112      	bne.n	2400b1fe <HAL_RCCEx_GetPeriphCLKFreq+0xa6>
      saiclocksource= __HAL_RCC_GET_SAI4A_SOURCE();
2400b1d8:	4a49      	ldr	r2, [pc, #292]	@ (2400b300 <HAL_RCCEx_GetPeriphCLKFreq+0x1a8>)
2400b1da:	6d93      	ldr	r3, [r2, #88]	@ 0x58
2400b1dc:	f403 0360 	and.w	r3, r3, #14680064	@ 0xe00000
      switch (saiclocksource)
2400b1e0:	f5b3 0f80 	cmp.w	r3, #4194304	@ 0x400000
2400b1e4:	d0cc      	beq.n	2400b180 <HAL_RCCEx_GetPeriphCLKFreq+0x28>
2400b1e6:	d804      	bhi.n	2400b1f2 <HAL_RCCEx_GetPeriphCLKFreq+0x9a>
2400b1e8:	2b00      	cmp	r3, #0
2400b1ea:	d0c4      	beq.n	2400b176 <HAL_RCCEx_GetPeriphCLKFreq+0x1e>
2400b1ec:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
2400b1f0:	e7d7      	b.n	2400b1a2 <HAL_RCCEx_GetPeriphCLKFreq+0x4a>
2400b1f2:	f5b3 0fc0 	cmp.w	r3, #6291456	@ 0x600000
2400b1f6:	d07d      	beq.n	2400b2f4 <HAL_RCCEx_GetPeriphCLKFreq+0x19c>
2400b1f8:	f5b3 0f00 	cmp.w	r3, #8388608	@ 0x800000
2400b1fc:	e7d9      	b.n	2400b1b2 <HAL_RCCEx_GetPeriphCLKFreq+0x5a>
  else if (PeriphClk == RCC_PERIPHCLK_SAI4B)
2400b1fe:	f5b0 6f00 	cmp.w	r0, #2048	@ 0x800
2400b202:	d112      	bne.n	2400b22a <HAL_RCCEx_GetPeriphCLKFreq+0xd2>
      saiclocksource= __HAL_RCC_GET_SAI4B_SOURCE();
2400b204:	4a3e      	ldr	r2, [pc, #248]	@ (2400b300 <HAL_RCCEx_GetPeriphCLKFreq+0x1a8>)
2400b206:	6d93      	ldr	r3, [r2, #88]	@ 0x58
2400b208:	f003 63e0 	and.w	r3, r3, #117440512	@ 0x7000000
      switch (saiclocksource)
2400b20c:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
2400b210:	d0b6      	beq.n	2400b180 <HAL_RCCEx_GetPeriphCLKFreq+0x28>
2400b212:	d804      	bhi.n	2400b21e <HAL_RCCEx_GetPeriphCLKFreq+0xc6>
2400b214:	2b00      	cmp	r3, #0
2400b216:	d0ae      	beq.n	2400b176 <HAL_RCCEx_GetPeriphCLKFreq+0x1e>
2400b218:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
2400b21c:	e7c1      	b.n	2400b1a2 <HAL_RCCEx_GetPeriphCLKFreq+0x4a>
2400b21e:	f1b3 7f40 	cmp.w	r3, #50331648	@ 0x3000000
2400b222:	d067      	beq.n	2400b2f4 <HAL_RCCEx_GetPeriphCLKFreq+0x19c>
2400b224:	f1b3 6f80 	cmp.w	r3, #67108864	@ 0x4000000
2400b228:	e7c3      	b.n	2400b1b2 <HAL_RCCEx_GetPeriphCLKFreq+0x5a>
  else if (PeriphClk == RCC_PERIPHCLK_SPI123)
2400b22a:	f5b0 5f80 	cmp.w	r0, #4096	@ 0x1000
2400b22e:	d112      	bne.n	2400b256 <HAL_RCCEx_GetPeriphCLKFreq+0xfe>
      srcclk= __HAL_RCC_GET_SPI123_SOURCE();
2400b230:	4a33      	ldr	r2, [pc, #204]	@ (2400b300 <HAL_RCCEx_GetPeriphCLKFreq+0x1a8>)
2400b232:	6d13      	ldr	r3, [r2, #80]	@ 0x50
2400b234:	f403 43e0 	and.w	r3, r3, #28672	@ 0x7000
      switch (srcclk)
2400b238:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
2400b23c:	d0a0      	beq.n	2400b180 <HAL_RCCEx_GetPeriphCLKFreq+0x28>
2400b23e:	d804      	bhi.n	2400b24a <HAL_RCCEx_GetPeriphCLKFreq+0xf2>
2400b240:	2b00      	cmp	r3, #0
2400b242:	d098      	beq.n	2400b176 <HAL_RCCEx_GetPeriphCLKFreq+0x1e>
2400b244:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
2400b248:	e7ab      	b.n	2400b1a2 <HAL_RCCEx_GetPeriphCLKFreq+0x4a>
2400b24a:	f5b3 5f40 	cmp.w	r3, #12288	@ 0x3000
2400b24e:	d051      	beq.n	2400b2f4 <HAL_RCCEx_GetPeriphCLKFreq+0x19c>
2400b250:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
2400b254:	e7ad      	b.n	2400b1b2 <HAL_RCCEx_GetPeriphCLKFreq+0x5a>
  else if (PeriphClk == RCC_PERIPHCLK_ADC)
2400b256:	f5b0 2f00 	cmp.w	r0, #524288	@ 0x80000
2400b25a:	d117      	bne.n	2400b28c <HAL_RCCEx_GetPeriphCLKFreq+0x134>
      srcclk= __HAL_RCC_GET_ADC_SOURCE();
2400b25c:	4a28      	ldr	r2, [pc, #160]	@ (2400b300 <HAL_RCCEx_GetPeriphCLKFreq+0x1a8>)
2400b25e:	6d93      	ldr	r3, [r2, #88]	@ 0x58
2400b260:	f403 3340 	and.w	r3, r3, #196608	@ 0x30000
      switch (srcclk)
2400b264:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
2400b268:	d00b      	beq.n	2400b282 <HAL_RCCEx_GetPeriphCLKFreq+0x12a>
2400b26a:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
2400b26e:	d0a1      	beq.n	2400b1b4 <HAL_RCCEx_GetPeriphCLKFreq+0x5c>
2400b270:	2b00      	cmp	r3, #0
2400b272:	d197      	bne.n	2400b1a4 <HAL_RCCEx_GetPeriphCLKFreq+0x4c>
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
2400b274:	a801      	add	r0, sp, #4
2400b276:	f7ff fd71 	bl	2400ad5c <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll3_clocks.PLL3_P_Frequency;
2400b27a:	9801      	ldr	r0, [sp, #4]
}
2400b27c:	b005      	add	sp, #20
2400b27e:	f85d fb04 	ldr.w	pc, [sp], #4
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
2400b282:	a801      	add	r0, sp, #4
2400b284:	f7ff fe14 	bl	2400aeb0 <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll2_clocks.PLL2_R_Frequency;
2400b288:	9803      	ldr	r0, [sp, #12]
          break;
2400b28a:	e7f7      	b.n	2400b27c <HAL_RCCEx_GetPeriphCLKFreq+0x124>
  else if (PeriphClk == RCC_PERIPHCLK_SDMMC)
2400b28c:	f5b0 3f80 	cmp.w	r0, #65536	@ 0x10000
2400b290:	d108      	bne.n	2400b2a4 <HAL_RCCEx_GetPeriphCLKFreq+0x14c>
      srcclk= __HAL_RCC_GET_SDMMC_SOURCE();
2400b292:	4b1b      	ldr	r3, [pc, #108]	@ (2400b300 <HAL_RCCEx_GetPeriphCLKFreq+0x1a8>)
2400b294:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
      switch (srcclk)
2400b296:	03db      	lsls	r3, r3, #15
2400b298:	f57f af6d 	bpl.w	2400b176 <HAL_RCCEx_GetPeriphCLKFreq+0x1e>
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
2400b29c:	a801      	add	r0, sp, #4
2400b29e:	f7ff fd5d 	bl	2400ad5c <HAL_RCCEx_GetPLL2ClockFreq>
2400b2a2:	e7f1      	b.n	2400b288 <HAL_RCCEx_GetPeriphCLKFreq+0x130>
  else if (PeriphClk == RCC_PERIPHCLK_SPI6)
2400b2a4:	f5b0 4f80 	cmp.w	r0, #16384	@ 0x4000
2400b2a8:	f47f af7c 	bne.w	2400b1a4 <HAL_RCCEx_GetPeriphCLKFreq+0x4c>
      srcclk= __HAL_RCC_GET_SPI6_SOURCE();
2400b2ac:	4b14      	ldr	r3, [pc, #80]	@ (2400b300 <HAL_RCCEx_GetPeriphCLKFreq+0x1a8>)
2400b2ae:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
2400b2b0:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
      switch (srcclk)
2400b2b4:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
2400b2b8:	d01e      	beq.n	2400b2f8 <HAL_RCCEx_GetPeriphCLKFreq+0x1a0>
2400b2ba:	d80d      	bhi.n	2400b2d8 <HAL_RCCEx_GetPeriphCLKFreq+0x180>
2400b2bc:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
2400b2c0:	d010      	beq.n	2400b2e4 <HAL_RCCEx_GetPeriphCLKFreq+0x18c>
2400b2c2:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
2400b2c6:	d011      	beq.n	2400b2ec <HAL_RCCEx_GetPeriphCLKFreq+0x194>
2400b2c8:	2b00      	cmp	r3, #0
2400b2ca:	f47f af6b 	bne.w	2400b1a4 <HAL_RCCEx_GetPeriphCLKFreq+0x4c>
}
2400b2ce:	b005      	add	sp, #20
2400b2d0:	f85d eb04 	ldr.w	lr, [sp], #4
          frequency = HAL_RCCEx_GetD3PCLK1Freq();
2400b2d4:	f7ff bd30 	b.w	2400ad38 <HAL_RCCEx_GetD3PCLK1Freq>
      switch (srcclk)
2400b2d8:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
2400b2dc:	d00e      	beq.n	2400b2fc <HAL_RCCEx_GetPeriphCLKFreq+0x1a4>
2400b2de:	f1b3 4fa0 	cmp.w	r3, #1342177280	@ 0x50000000
2400b2e2:	e772      	b.n	2400b1ca <HAL_RCCEx_GetPeriphCLKFreq+0x72>
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
2400b2e4:	a801      	add	r0, sp, #4
2400b2e6:	f7ff fd39 	bl	2400ad5c <HAL_RCCEx_GetPLL2ClockFreq>
2400b2ea:	e747      	b.n	2400b17c <HAL_RCCEx_GetPeriphCLKFreq+0x24>
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
2400b2ec:	a801      	add	r0, sp, #4
2400b2ee:	f7ff fddf 	bl	2400aeb0 <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_Q_Frequency;
2400b2f2:	e743      	b.n	2400b17c <HAL_RCCEx_GetPeriphCLKFreq+0x24>
          frequency = EXTERNAL_CLOCK_VALUE;
2400b2f4:	4804      	ldr	r0, [pc, #16]	@ (2400b308 <HAL_RCCEx_GetPeriphCLKFreq+0x1b0>)
2400b2f6:	e7c1      	b.n	2400b27c <HAL_RCCEx_GetPeriphCLKFreq+0x124>
      switch (srcclk)
2400b2f8:	4804      	ldr	r0, [pc, #16]	@ (2400b30c <HAL_RCCEx_GetPeriphCLKFreq+0x1b4>)
2400b2fa:	e7bf      	b.n	2400b27c <HAL_RCCEx_GetPeriphCLKFreq+0x124>
            frequency = CSI_VALUE;
2400b2fc:	4804      	ldr	r0, [pc, #16]	@ (2400b310 <HAL_RCCEx_GetPeriphCLKFreq+0x1b8>)
2400b2fe:	e7bd      	b.n	2400b27c <HAL_RCCEx_GetPeriphCLKFreq+0x124>
2400b300:	58024400 	.word	0x58024400
2400b304:	017d7840 	.word	0x017d7840
2400b308:	00bb8000 	.word	0x00bb8000
2400b30c:	03d09000 	.word	0x03d09000
2400b310:	003d0900 	.word	0x003d0900

2400b314 <HAL_RCCEx_GetD1SysClockFreq>:
{
2400b314:	b508      	push	{r3, lr}
  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos] & 0x1FU);
2400b316:	f7fe fc11 	bl	24009b3c <HAL_RCC_GetSysClockFreq>
2400b31a:	490b      	ldr	r1, [pc, #44]	@ (2400b348 <HAL_RCCEx_GetD1SysClockFreq+0x34>)
2400b31c:	4a0b      	ldr	r2, [pc, #44]	@ (2400b34c <HAL_RCCEx_GetD1SysClockFreq+0x38>)
2400b31e:	698b      	ldr	r3, [r1, #24]
2400b320:	f3c3 2303 	ubfx	r3, r3, #8, #4
2400b324:	5cd3      	ldrb	r3, [r2, r3]
2400b326:	f003 031f 	and.w	r3, r3, #31
2400b32a:	40d8      	lsrs	r0, r3
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
2400b32c:	698b      	ldr	r3, [r1, #24]
2400b32e:	f003 030f 	and.w	r3, r3, #15
2400b332:	5cd3      	ldrb	r3, [r2, r3]
2400b334:	4a06      	ldr	r2, [pc, #24]	@ (2400b350 <HAL_RCCEx_GetD1SysClockFreq+0x3c>)
2400b336:	f003 031f 	and.w	r3, r3, #31
2400b33a:	fa20 f303 	lsr.w	r3, r0, r3
2400b33e:	6013      	str	r3, [r2, #0]
  SystemCoreClock = common_system_clock;
2400b340:	4b04      	ldr	r3, [pc, #16]	@ (2400b354 <HAL_RCCEx_GetD1SysClockFreq+0x40>)
2400b342:	6018      	str	r0, [r3, #0]
}
2400b344:	bd08      	pop	{r3, pc}
2400b346:	bf00      	nop
2400b348:	58024400 	.word	0x58024400
2400b34c:	240141fa 	.word	0x240141fa
2400b350:	24000514 	.word	0x24000514
2400b354:	24000518 	.word	0x24000518

2400b358 <HAL_RCCEx_EnableLSECSS>:
  SET_BIT(RCC->BDCR, RCC_BDCR_LSECSSON) ;
2400b358:	4a02      	ldr	r2, [pc, #8]	@ (2400b364 <HAL_RCCEx_EnableLSECSS+0xc>)
2400b35a:	6f13      	ldr	r3, [r2, #112]	@ 0x70
2400b35c:	f043 0320 	orr.w	r3, r3, #32
2400b360:	6713      	str	r3, [r2, #112]	@ 0x70
}
2400b362:	4770      	bx	lr
2400b364:	58024400 	.word	0x58024400

2400b368 <HAL_RCCEx_DisableLSECSS>:
  CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSECSSON) ;
2400b368:	4b04      	ldr	r3, [pc, #16]	@ (2400b37c <HAL_RCCEx_DisableLSECSS+0x14>)
2400b36a:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
2400b36c:	f022 0220 	bic.w	r2, r2, #32
2400b370:	671a      	str	r2, [r3, #112]	@ 0x70
  __HAL_RCC_DISABLE_IT(RCC_IT_LSECSS);
2400b372:	6e1a      	ldr	r2, [r3, #96]	@ 0x60
2400b374:	f422 7200 	bic.w	r2, r2, #512	@ 0x200
2400b378:	661a      	str	r2, [r3, #96]	@ 0x60
}
2400b37a:	4770      	bx	lr
2400b37c:	58024400 	.word	0x58024400

2400b380 <HAL_RCCEx_EnableLSECSS_IT>:
  SET_BIT(RCC->BDCR, RCC_BDCR_LSECSSON) ;
2400b380:	4b0a      	ldr	r3, [pc, #40]	@ (2400b3ac <HAL_RCCEx_EnableLSECSS_IT+0x2c>)
2400b382:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
2400b384:	f042 0220 	orr.w	r2, r2, #32
2400b388:	671a      	str	r2, [r3, #112]	@ 0x70
  __HAL_RCC_ENABLE_IT(RCC_IT_LSECSS);
2400b38a:	6e1a      	ldr	r2, [r3, #96]	@ 0x60
2400b38c:	f442 7200 	orr.w	r2, r2, #512	@ 0x200
2400b390:	661a      	str	r2, [r3, #96]	@ 0x60
  __HAL_RCC_LSECSS_EXTI_ENABLE_IT();
2400b392:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
2400b396:	f8d3 2080 	ldr.w	r2, [r3, #128]	@ 0x80
2400b39a:	f442 2280 	orr.w	r2, r2, #262144	@ 0x40000
2400b39e:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
  __HAL_RCC_LSECSS_EXTI_ENABLE_RISING_EDGE();
2400b3a2:	681a      	ldr	r2, [r3, #0]
2400b3a4:	f442 2280 	orr.w	r2, r2, #262144	@ 0x40000
2400b3a8:	601a      	str	r2, [r3, #0]
}
2400b3aa:	4770      	bx	lr
2400b3ac:	58024400 	.word	0x58024400

2400b3b0 <HAL_RCCEx_WakeUpStopCLKConfig>:
  __HAL_RCC_WAKEUPSTOP_CLK_CONFIG(WakeUpClk);
2400b3b0:	4a03      	ldr	r2, [pc, #12]	@ (2400b3c0 <HAL_RCCEx_WakeUpStopCLKConfig+0x10>)
2400b3b2:	6913      	ldr	r3, [r2, #16]
2400b3b4:	f023 0340 	bic.w	r3, r3, #64	@ 0x40
2400b3b8:	4303      	orrs	r3, r0
2400b3ba:	6113      	str	r3, [r2, #16]
}
2400b3bc:	4770      	bx	lr
2400b3be:	bf00      	nop
2400b3c0:	58024400 	.word	0x58024400

2400b3c4 <HAL_RCCEx_KerWakeUpStopCLKConfig>:
  __HAL_RCC_KERWAKEUPSTOP_CLK_CONFIG(WakeUpClk);
2400b3c4:	4a03      	ldr	r2, [pc, #12]	@ (2400b3d4 <HAL_RCCEx_KerWakeUpStopCLKConfig+0x10>)
2400b3c6:	6913      	ldr	r3, [r2, #16]
2400b3c8:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
2400b3cc:	4303      	orrs	r3, r0
2400b3ce:	6113      	str	r3, [r2, #16]
}
2400b3d0:	4770      	bx	lr
2400b3d2:	bf00      	nop
2400b3d4:	58024400 	.word	0x58024400

2400b3d8 <HAL_RCCEx_WWDGxSysResetConfig>:
  SET_BIT(RCC->GCR, RCC_WWDGx) ;
2400b3d8:	4a03      	ldr	r2, [pc, #12]	@ (2400b3e8 <HAL_RCCEx_WWDGxSysResetConfig+0x10>)
2400b3da:	f8d2 30a0 	ldr.w	r3, [r2, #160]	@ 0xa0
2400b3de:	4303      	orrs	r3, r0
2400b3e0:	f8c2 30a0 	str.w	r3, [r2, #160]	@ 0xa0
}
2400b3e4:	4770      	bx	lr
2400b3e6:	bf00      	nop
2400b3e8:	58024400 	.word	0x58024400

2400b3ec <HAL_RCCEx_CRSConfig>:
  __HAL_RCC_CRS_FORCE_RESET();
2400b3ec:	4b18      	ldr	r3, [pc, #96]	@ (2400b450 <HAL_RCCEx_CRSConfig+0x64>)
2400b3ee:	f8d3 2094 	ldr.w	r2, [r3, #148]	@ 0x94
2400b3f2:	f042 0202 	orr.w	r2, r2, #2
{
2400b3f6:	b510      	push	{r4, lr}
  __HAL_RCC_CRS_FORCE_RESET();
2400b3f8:	f8c3 2094 	str.w	r2, [r3, #148]	@ 0x94
{
2400b3fc:	4604      	mov	r4, r0
  __HAL_RCC_CRS_RELEASE_RESET();
2400b3fe:	f8d3 2094 	ldr.w	r2, [r3, #148]	@ 0x94
2400b402:	f022 0202 	bic.w	r2, r2, #2
2400b406:	f8c3 2094 	str.w	r2, [r3, #148]	@ 0x94
  if ((HAL_GetREVID() <= REV_ID_Y) && (pInit->Source == RCC_CRS_SYNC_SOURCE_USB2))
2400b40a:	f7f5 fad6 	bl	240009ba <HAL_GetREVID>
2400b40e:	f241 0303 	movw	r3, #4099	@ 0x1003
2400b412:	4298      	cmp	r0, r3
2400b414:	6823      	ldr	r3, [r4, #0]
2400b416:	e9d4 1201 	ldrd	r1, r2, [r4, #4]
2400b41a:	d816      	bhi.n	2400b44a <HAL_RCCEx_CRSConfig+0x5e>
2400b41c:	f1b1 5f40 	cmp.w	r1, #805306368	@ 0x30000000
2400b420:	d113      	bne.n	2400b44a <HAL_RCCEx_CRSConfig+0x5e>
    value = (pInit->Prescaler | pInit->Source | pInit->Polarity);
2400b422:	431a      	orrs	r2, r3
  value |= (pInit->ErrorLimitValue << CRS_CFGR_FELIM_Pos);
2400b424:	e9d4 3103 	ldrd	r3, r1, [r4, #12]
2400b428:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
2400b42c:	431a      	orrs	r2, r3
  WRITE_REG(CRS->CFGR, value);
2400b42e:	4b09      	ldr	r3, [pc, #36]	@ (2400b454 <HAL_RCCEx_CRSConfig+0x68>)
2400b430:	605a      	str	r2, [r3, #4]
  MODIFY_REG(CRS->CR, CRS_CR_TRIM, (pInit->HSI48CalibrationValue << CRS_CR_TRIM_Pos));
2400b432:	681a      	ldr	r2, [r3, #0]
2400b434:	6961      	ldr	r1, [r4, #20]
2400b436:	f422 527c 	bic.w	r2, r2, #16128	@ 0x3f00
2400b43a:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
2400b43e:	601a      	str	r2, [r3, #0]
  SET_BIT(CRS->CR, CRS_CR_AUTOTRIMEN | CRS_CR_CEN);
2400b440:	681a      	ldr	r2, [r3, #0]
2400b442:	f042 0260 	orr.w	r2, r2, #96	@ 0x60
2400b446:	601a      	str	r2, [r3, #0]
}
2400b448:	bd10      	pop	{r4, pc}
    value = (pInit->Prescaler | pInit->Source | pInit->Polarity);
2400b44a:	430b      	orrs	r3, r1
2400b44c:	e7e9      	b.n	2400b422 <HAL_RCCEx_CRSConfig+0x36>
2400b44e:	bf00      	nop
2400b450:	58024400 	.word	0x58024400
2400b454:	40008400 	.word	0x40008400

2400b458 <HAL_RCCEx_CRSSoftwareSynchronizationGenerate>:
  SET_BIT(CRS->CR, CRS_CR_SWSYNC);
2400b458:	4a02      	ldr	r2, [pc, #8]	@ (2400b464 <HAL_RCCEx_CRSSoftwareSynchronizationGenerate+0xc>)
2400b45a:	6813      	ldr	r3, [r2, #0]
2400b45c:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
2400b460:	6013      	str	r3, [r2, #0]
}
2400b462:	4770      	bx	lr
2400b464:	40008400 	.word	0x40008400

2400b468 <HAL_RCCEx_CRSGetSynchronizationInfo>:
  pSynchroInfo->ReloadValue = (uint32_t)(READ_BIT(CRS->CFGR, CRS_CFGR_RELOAD));
2400b468:	4b07      	ldr	r3, [pc, #28]	@ (2400b488 <HAL_RCCEx_CRSGetSynchronizationInfo+0x20>)
2400b46a:	685a      	ldr	r2, [r3, #4]
2400b46c:	b292      	uxth	r2, r2
2400b46e:	6002      	str	r2, [r0, #0]
  pSynchroInfo->HSI48CalibrationValue = (uint32_t)(READ_BIT(CRS->CR, CRS_CR_TRIM) >> CRS_CR_TRIM_Pos);
2400b470:	681a      	ldr	r2, [r3, #0]
2400b472:	f3c2 2205 	ubfx	r2, r2, #8, #6
2400b476:	6042      	str	r2, [r0, #4]
  pSynchroInfo->FreqErrorCapture = (uint32_t)(READ_BIT(CRS->ISR, CRS_ISR_FECAP) >> CRS_ISR_FECAP_Pos);
2400b478:	689a      	ldr	r2, [r3, #8]
2400b47a:	0c12      	lsrs	r2, r2, #16
2400b47c:	6082      	str	r2, [r0, #8]
  pSynchroInfo->FreqErrorDirection = (uint32_t)(READ_BIT(CRS->ISR, CRS_ISR_FEDIR));
2400b47e:	689b      	ldr	r3, [r3, #8]
2400b480:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
2400b484:	60c3      	str	r3, [r0, #12]
}
2400b486:	4770      	bx	lr
2400b488:	40008400 	.word	0x40008400

2400b48c <HAL_RCCEx_CRSWaitSynchronization>:
{
2400b48c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
2400b48e:	4605      	mov	r5, r0
    if(__HAL_RCC_CRS_GET_FLAG(RCC_CRS_FLAG_SYNCOK))
2400b490:	4c1e      	ldr	r4, [pc, #120]	@ (2400b50c <HAL_RCCEx_CRSWaitSynchronization+0x80>)
  tickstart = HAL_GetTick();
2400b492:	f006 fcb9 	bl	24011e08 <HAL_GetTick>
      __HAL_RCC_CRS_CLEAR_FLAG(RCC_CRS_FLAG_SYNCOK);
2400b496:	2701      	movs	r7, #1
  tickstart = HAL_GetTick();
2400b498:	4606      	mov	r6, r0
    if(Timeout != HAL_MAX_DELAY)
2400b49a:	1c68      	adds	r0, r5, #1
2400b49c:	d031      	beq.n	2400b502 <HAL_RCCEx_CRSWaitSynchronization+0x76>
      if(((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
2400b49e:	f006 fcb3 	bl	24011e08 <HAL_GetTick>
2400b4a2:	1b80      	subs	r0, r0, r6
2400b4a4:	42a8      	cmp	r0, r5
2400b4a6:	d82e      	bhi.n	2400b506 <HAL_RCCEx_CRSWaitSynchronization+0x7a>
2400b4a8:	fab5 f085 	clz	r0, r5
2400b4ac:	0940      	lsrs	r0, r0, #5
    if(__HAL_RCC_CRS_GET_FLAG(RCC_CRS_FLAG_SYNCOK))
2400b4ae:	68a3      	ldr	r3, [r4, #8]
2400b4b0:	07d9      	lsls	r1, r3, #31
2400b4b2:	d502      	bpl.n	2400b4ba <HAL_RCCEx_CRSWaitSynchronization+0x2e>
      crsstatus |= RCC_CRS_SYNCOK;
2400b4b4:	f040 0002 	orr.w	r0, r0, #2
      __HAL_RCC_CRS_CLEAR_FLAG(RCC_CRS_FLAG_SYNCOK);
2400b4b8:	60e7      	str	r7, [r4, #12]
    if(__HAL_RCC_CRS_GET_FLAG(RCC_CRS_FLAG_SYNCWARN))
2400b4ba:	68a3      	ldr	r3, [r4, #8]
2400b4bc:	079a      	lsls	r2, r3, #30
2400b4be:	d503      	bpl.n	2400b4c8 <HAL_RCCEx_CRSWaitSynchronization+0x3c>
      __HAL_RCC_CRS_CLEAR_FLAG(RCC_CRS_FLAG_SYNCWARN);
2400b4c0:	2302      	movs	r3, #2
      crsstatus |= RCC_CRS_SYNCWARN;
2400b4c2:	f040 0004 	orr.w	r0, r0, #4
      __HAL_RCC_CRS_CLEAR_FLAG(RCC_CRS_FLAG_SYNCWARN);
2400b4c6:	60e3      	str	r3, [r4, #12]
    if(__HAL_RCC_CRS_GET_FLAG(RCC_CRS_FLAG_TRIMOVF))
2400b4c8:	68a3      	ldr	r3, [r4, #8]
2400b4ca:	055b      	lsls	r3, r3, #21
2400b4cc:	d503      	bpl.n	2400b4d6 <HAL_RCCEx_CRSWaitSynchronization+0x4a>
      __HAL_RCC_CRS_CLEAR_FLAG(RCC_CRS_FLAG_TRIMOVF);
2400b4ce:	2304      	movs	r3, #4
      crsstatus |= RCC_CRS_TRIMOVF;
2400b4d0:	f040 0020 	orr.w	r0, r0, #32
      __HAL_RCC_CRS_CLEAR_FLAG(RCC_CRS_FLAG_TRIMOVF);
2400b4d4:	60e3      	str	r3, [r4, #12]
    if(__HAL_RCC_CRS_GET_FLAG(RCC_CRS_FLAG_SYNCERR))
2400b4d6:	68a3      	ldr	r3, [r4, #8]
2400b4d8:	05d9      	lsls	r1, r3, #23
2400b4da:	d503      	bpl.n	2400b4e4 <HAL_RCCEx_CRSWaitSynchronization+0x58>
      __HAL_RCC_CRS_CLEAR_FLAG(RCC_CRS_FLAG_SYNCERR);
2400b4dc:	2304      	movs	r3, #4
      crsstatus |= RCC_CRS_SYNCERR;
2400b4de:	f040 0008 	orr.w	r0, r0, #8
      __HAL_RCC_CRS_CLEAR_FLAG(RCC_CRS_FLAG_SYNCERR);
2400b4e2:	60e3      	str	r3, [r4, #12]
    if(__HAL_RCC_CRS_GET_FLAG(RCC_CRS_FLAG_SYNCMISS))
2400b4e4:	68a3      	ldr	r3, [r4, #8]
2400b4e6:	059a      	lsls	r2, r3, #22
2400b4e8:	d503      	bpl.n	2400b4f2 <HAL_RCCEx_CRSWaitSynchronization+0x66>
      __HAL_RCC_CRS_CLEAR_FLAG(RCC_CRS_FLAG_SYNCMISS);
2400b4ea:	2304      	movs	r3, #4
      crsstatus |= RCC_CRS_SYNCMISS;
2400b4ec:	f040 0010 	orr.w	r0, r0, #16
      __HAL_RCC_CRS_CLEAR_FLAG(RCC_CRS_FLAG_SYNCMISS);
2400b4f0:	60e3      	str	r3, [r4, #12]
    if(__HAL_RCC_CRS_GET_FLAG(RCC_CRS_FLAG_ESYNC))
2400b4f2:	68a3      	ldr	r3, [r4, #8]
2400b4f4:	071b      	lsls	r3, r3, #28
2400b4f6:	d501      	bpl.n	2400b4fc <HAL_RCCEx_CRSWaitSynchronization+0x70>
      __HAL_RCC_CRS_CLEAR_FLAG(RCC_CRS_FLAG_ESYNC);
2400b4f8:	2308      	movs	r3, #8
2400b4fa:	60e3      	str	r3, [r4, #12]
  } while(RCC_CRS_NONE == crsstatus);
2400b4fc:	2800      	cmp	r0, #0
2400b4fe:	d0cc      	beq.n	2400b49a <HAL_RCCEx_CRSWaitSynchronization+0xe>
}
2400b500:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
2400b502:	2000      	movs	r0, #0
2400b504:	e7d3      	b.n	2400b4ae <HAL_RCCEx_CRSWaitSynchronization+0x22>
        crsstatus = RCC_CRS_TIMEOUT;
2400b506:	2001      	movs	r0, #1
2400b508:	e7d1      	b.n	2400b4ae <HAL_RCCEx_CRSWaitSynchronization+0x22>
2400b50a:	bf00      	nop
2400b50c:	40008400 	.word	0x40008400

2400b510 <HAL_RCCEx_CRS_SyncOkCallback>:
__weak void HAL_RCCEx_CRS_SyncOkCallback(void)
2400b510:	4770      	bx	lr

2400b512 <HAL_RCCEx_CRS_SyncWarnCallback>:
__weak void HAL_RCCEx_CRS_SyncWarnCallback(void)
2400b512:	4770      	bx	lr

2400b514 <HAL_RCCEx_CRS_ExpectedSyncCallback>:
__weak void HAL_RCCEx_CRS_ExpectedSyncCallback(void)
2400b514:	4770      	bx	lr

2400b516 <HAL_RCCEx_CRS_ErrorCallback>:
}
2400b516:	4770      	bx	lr

2400b518 <HAL_RCCEx_CRS_IRQHandler>:
  uint32_t itflags = READ_REG(CRS->ISR);
2400b518:	491b      	ldr	r1, [pc, #108]	@ (2400b588 <HAL_RCCEx_CRS_IRQHandler+0x70>)
{
2400b51a:	b508      	push	{r3, lr}
  uint32_t itflags = READ_REG(CRS->ISR);
2400b51c:	688b      	ldr	r3, [r1, #8]
  uint32_t itsources = READ_REG(CRS->CR);
2400b51e:	680a      	ldr	r2, [r1, #0]
  if(((itflags & RCC_CRS_FLAG_SYNCOK) != 0U) && ((itsources & RCC_CRS_IT_SYNCOK) != 0U))
2400b520:	07d8      	lsls	r0, r3, #31
2400b522:	d506      	bpl.n	2400b532 <HAL_RCCEx_CRS_IRQHandler+0x1a>
2400b524:	07d0      	lsls	r0, r2, #31
2400b526:	d504      	bpl.n	2400b532 <HAL_RCCEx_CRS_IRQHandler+0x1a>
    WRITE_REG(CRS->ICR, CRS_ICR_SYNCOKC);
2400b528:	2301      	movs	r3, #1
2400b52a:	60cb      	str	r3, [r1, #12]
    HAL_RCCEx_CRS_SyncOkCallback();
2400b52c:	f7ff fff0 	bl	2400b510 <HAL_RCCEx_CRS_SyncOkCallback>
}
2400b530:	bd08      	pop	{r3, pc}
  else if(((itflags & RCC_CRS_FLAG_SYNCWARN) != 0U) && ((itsources & RCC_CRS_IT_SYNCWARN) != 0U))
2400b532:	0798      	lsls	r0, r3, #30
2400b534:	d507      	bpl.n	2400b546 <HAL_RCCEx_CRS_IRQHandler+0x2e>
2400b536:	0791      	lsls	r1, r2, #30
2400b538:	d505      	bpl.n	2400b546 <HAL_RCCEx_CRS_IRQHandler+0x2e>
    WRITE_REG(CRS->ICR, CRS_ICR_SYNCWARNC);
2400b53a:	4b13      	ldr	r3, [pc, #76]	@ (2400b588 <HAL_RCCEx_CRS_IRQHandler+0x70>)
2400b53c:	2202      	movs	r2, #2
2400b53e:	60da      	str	r2, [r3, #12]
    HAL_RCCEx_CRS_SyncWarnCallback();
2400b540:	f7ff ffe7 	bl	2400b512 <HAL_RCCEx_CRS_SyncWarnCallback>
2400b544:	e7f4      	b.n	2400b530 <HAL_RCCEx_CRS_IRQHandler+0x18>
  else if(((itflags & RCC_CRS_FLAG_ESYNC) != 0U) && ((itsources & RCC_CRS_IT_ESYNC) != 0U))
2400b546:	0718      	lsls	r0, r3, #28
2400b548:	d507      	bpl.n	2400b55a <HAL_RCCEx_CRS_IRQHandler+0x42>
2400b54a:	0711      	lsls	r1, r2, #28
2400b54c:	d505      	bpl.n	2400b55a <HAL_RCCEx_CRS_IRQHandler+0x42>
    WRITE_REG(CRS->ICR, CRS_ICR_ESYNCC);
2400b54e:	4b0e      	ldr	r3, [pc, #56]	@ (2400b588 <HAL_RCCEx_CRS_IRQHandler+0x70>)
2400b550:	2208      	movs	r2, #8
2400b552:	60da      	str	r2, [r3, #12]
    HAL_RCCEx_CRS_ExpectedSyncCallback();
2400b554:	f7ff ffde 	bl	2400b514 <HAL_RCCEx_CRS_ExpectedSyncCallback>
2400b558:	e7ea      	b.n	2400b530 <HAL_RCCEx_CRS_IRQHandler+0x18>
    if(((itflags & RCC_CRS_FLAG_ERR) != 0U) && ((itsources & RCC_CRS_IT_ERR) != 0U))
2400b55a:	0758      	lsls	r0, r3, #29
2400b55c:	d5e8      	bpl.n	2400b530 <HAL_RCCEx_CRS_IRQHandler+0x18>
2400b55e:	0751      	lsls	r1, r2, #29
2400b560:	d5e6      	bpl.n	2400b530 <HAL_RCCEx_CRS_IRQHandler+0x18>
      if((itflags & RCC_CRS_FLAG_SYNCERR) != 0U)
2400b562:	f3c3 2000 	ubfx	r0, r3, #8, #1
      if((itflags & RCC_CRS_FLAG_SYNCMISS) != 0U)
2400b566:	059a      	lsls	r2, r3, #22
      WRITE_REG(CRS->ICR, CRS_ICR_ERRC);
2400b568:	f04f 0204 	mov.w	r2, #4
      if((itflags & RCC_CRS_FLAG_SYNCERR) != 0U)
2400b56c:	ea4f 00c0 	mov.w	r0, r0, lsl #3
        crserror |= RCC_CRS_SYNCMISS;
2400b570:	bf48      	it	mi
2400b572:	f040 0010 	orrmi.w	r0, r0, #16
      if((itflags & RCC_CRS_FLAG_TRIMOVF) != 0U)
2400b576:	055b      	lsls	r3, r3, #21
      WRITE_REG(CRS->ICR, CRS_ICR_ERRC);
2400b578:	4b03      	ldr	r3, [pc, #12]	@ (2400b588 <HAL_RCCEx_CRS_IRQHandler+0x70>)
        crserror |= RCC_CRS_TRIMOVF;
2400b57a:	bf48      	it	mi
2400b57c:	f040 0020 	orrmi.w	r0, r0, #32
      WRITE_REG(CRS->ICR, CRS_ICR_ERRC);
2400b580:	60da      	str	r2, [r3, #12]
      HAL_RCCEx_CRS_ErrorCallback(crserror);
2400b582:	f7ff ffc8 	bl	2400b516 <HAL_RCCEx_CRS_ErrorCallback>
}
2400b586:	e7d3      	b.n	2400b530 <HAL_RCCEx_CRS_IRQHandler+0x18>
2400b588:	40008400 	.word	0x40008400

2400b58c <HAL_RCCEx_LSECSS_Callback>:
__weak void HAL_RCCEx_LSECSS_Callback(void)
{
  /* NOTE : This function should not be modified, when the callback is needed,
            the @ref HAL_RCCEx_LSECSS_Callback should be implemented in the user file
   */
}
2400b58c:	4770      	bx	lr

2400b58e <HAL_RCCEx_LSECSS_IRQHandler>:
{
2400b58e:	b508      	push	{r3, lr}
  if(__HAL_RCC_GET_IT(RCC_IT_LSECSS))
2400b590:	4b04      	ldr	r3, [pc, #16]	@ (2400b5a4 <HAL_RCCEx_LSECSS_IRQHandler+0x16>)
2400b592:	6e5a      	ldr	r2, [r3, #100]	@ 0x64
2400b594:	0592      	lsls	r2, r2, #22
2400b596:	d504      	bpl.n	2400b5a2 <HAL_RCCEx_LSECSS_IRQHandler+0x14>
    __HAL_RCC_CLEAR_IT(RCC_IT_LSECSS);
2400b598:	f44f 7200 	mov.w	r2, #512	@ 0x200
2400b59c:	669a      	str	r2, [r3, #104]	@ 0x68
    HAL_RCCEx_LSECSS_Callback();
2400b59e:	f7ff fff5 	bl	2400b58c <HAL_RCCEx_LSECSS_Callback>
}
2400b5a2:	bd08      	pop	{r3, pc}
2400b5a4:	58024400 	.word	0x58024400

2400b5a8 <TIM_OC1_SetConfig>:
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= ~TIM_CCER_CC1E;
2400b5a8:	6a03      	ldr	r3, [r0, #32]
2400b5aa:	f023 0301 	bic.w	r3, r3, #1
{
2400b5ae:	b570      	push	{r4, r5, r6, lr}
  TIMx->CCER &= ~TIM_CCER_CC1E;
2400b5b0:	6203      	str	r3, [r0, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
2400b5b2:	6a03      	ldr	r3, [r0, #32]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
2400b5b4:	6844      	ldr	r4, [r0, #4]

  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;
2400b5b6:	6982      	ldr	r2, [r0, #24]
  tmpccmrx &= ~TIM_CCMR1_CC1S;
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC1P;
2400b5b8:	f023 0302 	bic.w	r3, r3, #2
  tmpccmrx |= OC_Config->OCMode;
2400b5bc:	680d      	ldr	r5, [r1, #0]
  tmpccmrx &= ~TIM_CCMR1_CC1S;
2400b5be:	f422 3280 	bic.w	r2, r2, #65536	@ 0x10000
2400b5c2:	f022 0273 	bic.w	r2, r2, #115	@ 0x73
  tmpccmrx |= OC_Config->OCMode;
2400b5c6:	432a      	orrs	r2, r5
  /* Set the Output Compare Polarity */
  tmpccer |= OC_Config->OCPolarity;
2400b5c8:	688d      	ldr	r5, [r1, #8]
2400b5ca:	432b      	orrs	r3, r5

  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_1))
2400b5cc:	4d1b      	ldr	r5, [pc, #108]	@ (2400b63c <TIM_OC1_SetConfig+0x94>)
2400b5ce:	42a8      	cmp	r0, r5
2400b5d0:	d00f      	beq.n	2400b5f2 <TIM_OC1_SetConfig+0x4a>
2400b5d2:	f505 6580 	add.w	r5, r5, #1024	@ 0x400
2400b5d6:	42a8      	cmp	r0, r5
2400b5d8:	d00b      	beq.n	2400b5f2 <TIM_OC1_SetConfig+0x4a>
2400b5da:	f505 5570 	add.w	r5, r5, #15360	@ 0x3c00
2400b5de:	42a8      	cmp	r0, r5
2400b5e0:	d007      	beq.n	2400b5f2 <TIM_OC1_SetConfig+0x4a>
2400b5e2:	f505 6580 	add.w	r5, r5, #1024	@ 0x400
2400b5e6:	42a8      	cmp	r0, r5
2400b5e8:	d003      	beq.n	2400b5f2 <TIM_OC1_SetConfig+0x4a>
2400b5ea:	f505 6580 	add.w	r5, r5, #1024	@ 0x400
2400b5ee:	42a8      	cmp	r0, r5
2400b5f0:	d11e      	bne.n	2400b630 <TIM_OC1_SetConfig+0x88>
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));

    /* Reset the Output N Polarity level */
    tmpccer &= ~TIM_CCER_CC1NP;
    /* Set the Output N Polarity */
    tmpccer |= OC_Config->OCNPolarity;
2400b5f2:	68cd      	ldr	r5, [r1, #12]
    tmpccer &= ~TIM_CCER_CC1NP;
2400b5f4:	f023 0308 	bic.w	r3, r3, #8
    tmpccer |= OC_Config->OCNPolarity;
2400b5f8:	432b      	orrs	r3, r5
    /* Reset the Output N State */
    tmpccer &= ~TIM_CCER_CC1NE;
  }

  if (IS_TIM_BREAK_INSTANCE(TIMx))
2400b5fa:	4d10      	ldr	r5, [pc, #64]	@ (2400b63c <TIM_OC1_SetConfig+0x94>)
2400b5fc:	42a8      	cmp	r0, r5
    tmpccer &= ~TIM_CCER_CC1NE;
2400b5fe:	f023 0304 	bic.w	r3, r3, #4
  if (IS_TIM_BREAK_INSTANCE(TIMx))
2400b602:	d00f      	beq.n	2400b624 <TIM_OC1_SetConfig+0x7c>
2400b604:	f505 6580 	add.w	r5, r5, #1024	@ 0x400
2400b608:	42a8      	cmp	r0, r5
2400b60a:	d00b      	beq.n	2400b624 <TIM_OC1_SetConfig+0x7c>
2400b60c:	f505 5570 	add.w	r5, r5, #15360	@ 0x3c00
2400b610:	42a8      	cmp	r0, r5
2400b612:	d007      	beq.n	2400b624 <TIM_OC1_SetConfig+0x7c>
2400b614:	f505 6580 	add.w	r5, r5, #1024	@ 0x400
2400b618:	42a8      	cmp	r0, r5
2400b61a:	d003      	beq.n	2400b624 <TIM_OC1_SetConfig+0x7c>
2400b61c:	f505 6580 	add.w	r5, r5, #1024	@ 0x400
2400b620:	42a8      	cmp	r0, r5
2400b622:	d105      	bne.n	2400b630 <TIM_OC1_SetConfig+0x88>
    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));

    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS1;
    tmpcr2 &= ~TIM_CR2_OIS1N;
2400b624:	f424 7540 	bic.w	r5, r4, #768	@ 0x300
    /* Set the Output Idle state */
    tmpcr2 |= OC_Config->OCIdleState;
    /* Set the Output N Idle state */
    tmpcr2 |= OC_Config->OCNIdleState;
2400b628:	e9d1 4605 	ldrd	r4, r6, [r1, #20]
2400b62c:	4334      	orrs	r4, r6
2400b62e:	432c      	orrs	r4, r5
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
2400b630:	6044      	str	r4, [r0, #4]

  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;
2400b632:	6182      	str	r2, [r0, #24]

  /* Set the Capture Compare Register value */
  TIMx->CCR1 = OC_Config->Pulse;
2400b634:	684a      	ldr	r2, [r1, #4]
2400b636:	6342      	str	r2, [r0, #52]	@ 0x34

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
2400b638:	6203      	str	r3, [r0, #32]
}
2400b63a:	bd70      	pop	{r4, r5, r6, pc}
2400b63c:	40010000 	.word	0x40010000

2400b640 <TIM_OC3_SetConfig>:
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Disable the Channel 3: Reset the CC2E Bit */
  TIMx->CCER &= ~TIM_CCER_CC3E;
2400b640:	6a03      	ldr	r3, [r0, #32]
2400b642:	f423 7380 	bic.w	r3, r3, #256	@ 0x100
{
2400b646:	b570      	push	{r4, r5, r6, lr}
  TIMx->CCER &= ~TIM_CCER_CC3E;
2400b648:	6203      	str	r3, [r0, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
2400b64a:	6a03      	ldr	r3, [r0, #32]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
2400b64c:	6842      	ldr	r2, [r0, #4]

  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
2400b64e:	69c4      	ldr	r4, [r0, #28]
  tmpccmrx &= ~TIM_CCMR2_CC3S;
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC3P;
2400b650:	f423 7300 	bic.w	r3, r3, #512	@ 0x200
  tmpccmrx |= OC_Config->OCMode;
2400b654:	680d      	ldr	r5, [r1, #0]
  tmpccmrx &= ~TIM_CCMR2_CC3S;
2400b656:	f024 0473 	bic.w	r4, r4, #115	@ 0x73
  tmpccmrx |= OC_Config->OCMode;
2400b65a:	432c      	orrs	r4, r5
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 8U);
2400b65c:	688d      	ldr	r5, [r1, #8]
2400b65e:	ea43 2305 	orr.w	r3, r3, r5, lsl #8

  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_3))
2400b662:	4d16      	ldr	r5, [pc, #88]	@ (2400b6bc <TIM_OC3_SetConfig+0x7c>)
2400b664:	42a8      	cmp	r0, r5
2400b666:	d003      	beq.n	2400b670 <TIM_OC3_SetConfig+0x30>
2400b668:	f505 6580 	add.w	r5, r5, #1024	@ 0x400
2400b66c:	42a8      	cmp	r0, r5
2400b66e:	d10d      	bne.n	2400b68c <TIM_OC3_SetConfig+0x4c>
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));

    /* Reset the Output N Polarity level */
    tmpccer &= ~TIM_CCER_CC3NP;
    /* Set the Output N Polarity */
    tmpccer |= (OC_Config->OCNPolarity << 8U);
2400b670:	68cd      	ldr	r5, [r1, #12]
    tmpccer &= ~TIM_CCER_CC3NP;
2400b672:	f423 6300 	bic.w	r3, r3, #2048	@ 0x800
    tmpccer |= (OC_Config->OCNPolarity << 8U);
2400b676:	ea43 2305 	orr.w	r3, r3, r5, lsl #8
    /* Reset the Output N State */
    tmpccer &= ~TIM_CCER_CC3NE;
  }

  if (IS_TIM_BREAK_INSTANCE(TIMx))
2400b67a:	4d10      	ldr	r5, [pc, #64]	@ (2400b6bc <TIM_OC3_SetConfig+0x7c>)
2400b67c:	42a8      	cmp	r0, r5
    tmpccer &= ~TIM_CCER_CC3NE;
2400b67e:	f423 6380 	bic.w	r3, r3, #1024	@ 0x400
  if (IS_TIM_BREAK_INSTANCE(TIMx))
2400b682:	d00e      	beq.n	2400b6a2 <TIM_OC3_SetConfig+0x62>
2400b684:	f505 6580 	add.w	r5, r5, #1024	@ 0x400
2400b688:	42a8      	cmp	r0, r5
2400b68a:	d00a      	beq.n	2400b6a2 <TIM_OC3_SetConfig+0x62>
2400b68c:	4d0c      	ldr	r5, [pc, #48]	@ (2400b6c0 <TIM_OC3_SetConfig+0x80>)
2400b68e:	42a8      	cmp	r0, r5
2400b690:	d007      	beq.n	2400b6a2 <TIM_OC3_SetConfig+0x62>
2400b692:	f505 6580 	add.w	r5, r5, #1024	@ 0x400
2400b696:	42a8      	cmp	r0, r5
2400b698:	d003      	beq.n	2400b6a2 <TIM_OC3_SetConfig+0x62>
2400b69a:	f505 6580 	add.w	r5, r5, #1024	@ 0x400
2400b69e:	42a8      	cmp	r0, r5
2400b6a0:	d106      	bne.n	2400b6b0 <TIM_OC3_SetConfig+0x70>
    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));

    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS3;
    tmpcr2 &= ~TIM_CR2_OIS3N;
2400b6a2:	f422 5540 	bic.w	r5, r2, #12288	@ 0x3000
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 4U);
    /* Set the Output N Idle state */
    tmpcr2 |= (OC_Config->OCNIdleState << 4U);
2400b6a6:	e9d1 2605 	ldrd	r2, r6, [r1, #20]
2400b6aa:	4332      	orrs	r2, r6
2400b6ac:	ea45 1202 	orr.w	r2, r5, r2, lsl #4
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
2400b6b0:	6042      	str	r2, [r0, #4]

  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;

  /* Set the Capture Compare Register value */
  TIMx->CCR3 = OC_Config->Pulse;
2400b6b2:	684a      	ldr	r2, [r1, #4]
  TIMx->CCMR2 = tmpccmrx;
2400b6b4:	61c4      	str	r4, [r0, #28]
  TIMx->CCR3 = OC_Config->Pulse;
2400b6b6:	63c2      	str	r2, [r0, #60]	@ 0x3c

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
2400b6b8:	6203      	str	r3, [r0, #32]
}
2400b6ba:	bd70      	pop	{r4, r5, r6, pc}
2400b6bc:	40010000 	.word	0x40010000
2400b6c0:	40014000 	.word	0x40014000

2400b6c4 <TIM_OC4_SetConfig>:
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Disable the Channel 4: Reset the CC4E Bit */
  TIMx->CCER &= ~TIM_CCER_CC4E;
2400b6c4:	6a03      	ldr	r3, [r0, #32]
2400b6c6:	f423 5380 	bic.w	r3, r3, #4096	@ 0x1000
{
2400b6ca:	b530      	push	{r4, r5, lr}
  TIMx->CCER &= ~TIM_CCER_CC4E;
2400b6cc:	6203      	str	r3, [r0, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
2400b6ce:	6a03      	ldr	r3, [r0, #32]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
2400b6d0:	6844      	ldr	r4, [r0, #4]

  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
2400b6d2:	69c2      	ldr	r2, [r0, #28]

  /* Select the Output Compare Mode */
  tmpccmrx |= (OC_Config->OCMode << 8U);

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC4P;
2400b6d4:	f423 5300 	bic.w	r3, r3, #8192	@ 0x2000
  tmpccmrx |= (OC_Config->OCMode << 8U);
2400b6d8:	680d      	ldr	r5, [r1, #0]
  tmpccmrx &= ~TIM_CCMR2_CC4S;
2400b6da:	f422 42e6 	bic.w	r2, r2, #29440	@ 0x7300
  tmpccmrx |= (OC_Config->OCMode << 8U);
2400b6de:	ea42 2205 	orr.w	r2, r2, r5, lsl #8
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 12U);
2400b6e2:	688d      	ldr	r5, [r1, #8]
2400b6e4:	ea43 3305 	orr.w	r3, r3, r5, lsl #12

  if (IS_TIM_BREAK_INSTANCE(TIMx))
2400b6e8:	4d0e      	ldr	r5, [pc, #56]	@ (2400b724 <TIM_OC4_SetConfig+0x60>)
2400b6ea:	42a8      	cmp	r0, r5
2400b6ec:	d00f      	beq.n	2400b70e <TIM_OC4_SetConfig+0x4a>
2400b6ee:	f505 6580 	add.w	r5, r5, #1024	@ 0x400
2400b6f2:	42a8      	cmp	r0, r5
2400b6f4:	d00b      	beq.n	2400b70e <TIM_OC4_SetConfig+0x4a>
2400b6f6:	f505 5570 	add.w	r5, r5, #15360	@ 0x3c00
2400b6fa:	42a8      	cmp	r0, r5
2400b6fc:	d007      	beq.n	2400b70e <TIM_OC4_SetConfig+0x4a>
2400b6fe:	f505 6580 	add.w	r5, r5, #1024	@ 0x400
2400b702:	42a8      	cmp	r0, r5
2400b704:	d003      	beq.n	2400b70e <TIM_OC4_SetConfig+0x4a>
2400b706:	f505 6580 	add.w	r5, r5, #1024	@ 0x400
2400b70a:	42a8      	cmp	r0, r5
2400b70c:	d104      	bne.n	2400b718 <TIM_OC4_SetConfig+0x54>
  {
    /* Check parameters */
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));

    /* Reset the Output Compare IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS4;
2400b70e:	f424 4480 	bic.w	r4, r4, #16384	@ 0x4000

    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 6U);
2400b712:	694d      	ldr	r5, [r1, #20]
2400b714:	ea44 1485 	orr.w	r4, r4, r5, lsl #6
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
2400b718:	6044      	str	r4, [r0, #4]

  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;
2400b71a:	61c2      	str	r2, [r0, #28]

  /* Set the Capture Compare Register value */
  TIMx->CCR4 = OC_Config->Pulse;
2400b71c:	684a      	ldr	r2, [r1, #4]
2400b71e:	6402      	str	r2, [r0, #64]	@ 0x40

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
2400b720:	6203      	str	r3, [r0, #32]
}
2400b722:	bd30      	pop	{r4, r5, pc}
2400b724:	40010000 	.word	0x40010000

2400b728 <TIM_OC5_SetConfig>:
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Disable the output: Reset the CCxE Bit */
  TIMx->CCER &= ~TIM_CCER_CC5E;
2400b728:	6a03      	ldr	r3, [r0, #32]
2400b72a:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
{
2400b72e:	b530      	push	{r4, r5, lr}
  TIMx->CCER &= ~TIM_CCER_CC5E;
2400b730:	6203      	str	r3, [r0, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
2400b732:	6a03      	ldr	r3, [r0, #32]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
2400b734:	6844      	ldr	r4, [r0, #4]
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR3;
2400b736:	6d42      	ldr	r2, [r0, #84]	@ 0x54
  tmpccmrx &= ~(TIM_CCMR3_OC5M);
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC5P;
2400b738:	f423 3300 	bic.w	r3, r3, #131072	@ 0x20000
  tmpccmrx |= OC_Config->OCMode;
2400b73c:	680d      	ldr	r5, [r1, #0]
  tmpccmrx &= ~(TIM_CCMR3_OC5M);
2400b73e:	f022 0270 	bic.w	r2, r2, #112	@ 0x70
  tmpccmrx |= OC_Config->OCMode;
2400b742:	432a      	orrs	r2, r5
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 16U);
2400b744:	688d      	ldr	r5, [r1, #8]
2400b746:	ea43 4305 	orr.w	r3, r3, r5, lsl #16

  if (IS_TIM_BREAK_INSTANCE(TIMx))
2400b74a:	4d0f      	ldr	r5, [pc, #60]	@ (2400b788 <TIM_OC5_SetConfig+0x60>)
2400b74c:	42a8      	cmp	r0, r5
2400b74e:	d00f      	beq.n	2400b770 <TIM_OC5_SetConfig+0x48>
2400b750:	f505 6580 	add.w	r5, r5, #1024	@ 0x400
2400b754:	42a8      	cmp	r0, r5
2400b756:	d00b      	beq.n	2400b770 <TIM_OC5_SetConfig+0x48>
2400b758:	f505 5570 	add.w	r5, r5, #15360	@ 0x3c00
2400b75c:	42a8      	cmp	r0, r5
2400b75e:	d007      	beq.n	2400b770 <TIM_OC5_SetConfig+0x48>
2400b760:	f505 6580 	add.w	r5, r5, #1024	@ 0x400
2400b764:	42a8      	cmp	r0, r5
2400b766:	d003      	beq.n	2400b770 <TIM_OC5_SetConfig+0x48>
2400b768:	f505 6580 	add.w	r5, r5, #1024	@ 0x400
2400b76c:	42a8      	cmp	r0, r5
2400b76e:	d104      	bne.n	2400b77a <TIM_OC5_SetConfig+0x52>
  {
    /* Reset the Output Compare IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS5;
2400b770:	f424 3480 	bic.w	r4, r4, #65536	@ 0x10000
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 8U);
2400b774:	694d      	ldr	r5, [r1, #20]
2400b776:	ea44 2405 	orr.w	r4, r4, r5, lsl #8
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
2400b77a:	6044      	str	r4, [r0, #4]

  /* Write to TIMx CCMR3 */
  TIMx->CCMR3 = tmpccmrx;
2400b77c:	6542      	str	r2, [r0, #84]	@ 0x54

  /* Set the Capture Compare Register value */
  TIMx->CCR5 = OC_Config->Pulse;
2400b77e:	684a      	ldr	r2, [r1, #4]
2400b780:	6582      	str	r2, [r0, #88]	@ 0x58

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
2400b782:	6203      	str	r3, [r0, #32]
}
2400b784:	bd30      	pop	{r4, r5, pc}
2400b786:	bf00      	nop
2400b788:	40010000 	.word	0x40010000

2400b78c <TIM_OC6_SetConfig>:
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Disable the output: Reset the CCxE Bit */
  TIMx->CCER &= ~TIM_CCER_CC6E;
2400b78c:	6a03      	ldr	r3, [r0, #32]
2400b78e:	f423 1380 	bic.w	r3, r3, #1048576	@ 0x100000
{
2400b792:	b530      	push	{r4, r5, lr}
  TIMx->CCER &= ~TIM_CCER_CC6E;
2400b794:	6203      	str	r3, [r0, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
2400b796:	6a03      	ldr	r3, [r0, #32]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
2400b798:	6844      	ldr	r4, [r0, #4]
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR3;
2400b79a:	6d42      	ldr	r2, [r0, #84]	@ 0x54
  tmpccmrx &= ~(TIM_CCMR3_OC6M);
  /* Select the Output Compare Mode */
  tmpccmrx |= (OC_Config->OCMode << 8U);

  /* Reset the Output Polarity level */
  tmpccer &= (uint32_t)~TIM_CCER_CC6P;
2400b79c:	f423 1300 	bic.w	r3, r3, #2097152	@ 0x200000
  tmpccmrx |= (OC_Config->OCMode << 8U);
2400b7a0:	680d      	ldr	r5, [r1, #0]
  tmpccmrx &= ~(TIM_CCMR3_OC6M);
2400b7a2:	f422 42e0 	bic.w	r2, r2, #28672	@ 0x7000
  tmpccmrx |= (OC_Config->OCMode << 8U);
2400b7a6:	ea42 2205 	orr.w	r2, r2, r5, lsl #8
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 20U);
2400b7aa:	688d      	ldr	r5, [r1, #8]
2400b7ac:	ea43 5305 	orr.w	r3, r3, r5, lsl #20

  if (IS_TIM_BREAK_INSTANCE(TIMx))
2400b7b0:	4d0e      	ldr	r5, [pc, #56]	@ (2400b7ec <TIM_OC6_SetConfig+0x60>)
2400b7b2:	42a8      	cmp	r0, r5
2400b7b4:	d00f      	beq.n	2400b7d6 <TIM_OC6_SetConfig+0x4a>
2400b7b6:	f505 6580 	add.w	r5, r5, #1024	@ 0x400
2400b7ba:	42a8      	cmp	r0, r5
2400b7bc:	d00b      	beq.n	2400b7d6 <TIM_OC6_SetConfig+0x4a>
2400b7be:	f505 5570 	add.w	r5, r5, #15360	@ 0x3c00
2400b7c2:	42a8      	cmp	r0, r5
2400b7c4:	d007      	beq.n	2400b7d6 <TIM_OC6_SetConfig+0x4a>
2400b7c6:	f505 6580 	add.w	r5, r5, #1024	@ 0x400
2400b7ca:	42a8      	cmp	r0, r5
2400b7cc:	d003      	beq.n	2400b7d6 <TIM_OC6_SetConfig+0x4a>
2400b7ce:	f505 6580 	add.w	r5, r5, #1024	@ 0x400
2400b7d2:	42a8      	cmp	r0, r5
2400b7d4:	d104      	bne.n	2400b7e0 <TIM_OC6_SetConfig+0x54>
  {
    /* Reset the Output Compare IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS6;
2400b7d6:	f424 3400 	bic.w	r4, r4, #131072	@ 0x20000
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 10U);
2400b7da:	694d      	ldr	r5, [r1, #20]
2400b7dc:	ea44 2485 	orr.w	r4, r4, r5, lsl #10
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
2400b7e0:	6044      	str	r4, [r0, #4]

  /* Write to TIMx CCMR3 */
  TIMx->CCMR3 = tmpccmrx;
2400b7e2:	6542      	str	r2, [r0, #84]	@ 0x54

  /* Set the Capture Compare Register value */
  TIMx->CCR6 = OC_Config->Pulse;
2400b7e4:	684a      	ldr	r2, [r1, #4]
2400b7e6:	65c2      	str	r2, [r0, #92]	@ 0x5c

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
2400b7e8:	6203      	str	r3, [r0, #32]
}
2400b7ea:	bd30      	pop	{r4, r5, pc}
2400b7ec:	40010000 	.word	0x40010000

2400b7f0 <HAL_TIM_Base_MspInit>:
}
2400b7f0:	4770      	bx	lr

2400b7f2 <HAL_TIM_Base_MspDeInit>:
__weak void HAL_TIM_Base_MspDeInit(TIM_HandleTypeDef *htim)
2400b7f2:	4770      	bx	lr

2400b7f4 <HAL_TIM_Base_DeInit>:
  htim->State = HAL_TIM_STATE_BUSY;
2400b7f4:	2302      	movs	r3, #2
  __HAL_TIM_DISABLE(htim);
2400b7f6:	f241 1211 	movw	r2, #4369	@ 0x1111
{
2400b7fa:	b510      	push	{r4, lr}
  htim->State = HAL_TIM_STATE_BUSY;
2400b7fc:	f880 303d 	strb.w	r3, [r0, #61]	@ 0x3d
{
2400b800:	4604      	mov	r4, r0
  __HAL_TIM_DISABLE(htim);
2400b802:	6803      	ldr	r3, [r0, #0]
2400b804:	6a19      	ldr	r1, [r3, #32]
2400b806:	4211      	tst	r1, r2
2400b808:	d108      	bne.n	2400b81c <HAL_TIM_Base_DeInit+0x28>
2400b80a:	6a19      	ldr	r1, [r3, #32]
2400b80c:	f240 4244 	movw	r2, #1092	@ 0x444
2400b810:	4211      	tst	r1, r2
2400b812:	d103      	bne.n	2400b81c <HAL_TIM_Base_DeInit+0x28>
2400b814:	681a      	ldr	r2, [r3, #0]
2400b816:	f022 0201 	bic.w	r2, r2, #1
2400b81a:	601a      	str	r2, [r3, #0]
  HAL_TIM_Base_MspDeInit(htim);
2400b81c:	4620      	mov	r0, r4
2400b81e:	f7ff ffe8 	bl	2400b7f2 <HAL_TIM_Base_MspDeInit>
  htim->State = HAL_TIM_STATE_RESET;
2400b822:	2000      	movs	r0, #0
2400b824:	f884 003d 	strb.w	r0, [r4, #61]	@ 0x3d
  __HAL_UNLOCK(htim);
2400b828:	f884 003c 	strb.w	r0, [r4, #60]	@ 0x3c
}
2400b82c:	bd10      	pop	{r4, pc}

2400b82e <HAL_TIM_Base_Start>:
  htim->State = HAL_TIM_STATE_BUSY;
2400b82e:	2302      	movs	r3, #2
  tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
2400b830:	6802      	ldr	r2, [r0, #0]
  htim->State = HAL_TIM_STATE_BUSY;
2400b832:	f880 303d 	strb.w	r3, [r0, #61]	@ 0x3d
  tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
2400b836:	4b08      	ldr	r3, [pc, #32]	@ (2400b858 <HAL_TIM_Base_Start+0x2a>)
2400b838:	6891      	ldr	r1, [r2, #8]
2400b83a:	400b      	ands	r3, r1
  if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
2400b83c:	2b06      	cmp	r3, #6
2400b83e:	d006      	beq.n	2400b84e <HAL_TIM_Base_Start+0x20>
2400b840:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
2400b844:	d003      	beq.n	2400b84e <HAL_TIM_Base_Start+0x20>
    __HAL_TIM_ENABLE(htim);
2400b846:	6813      	ldr	r3, [r2, #0]
2400b848:	f043 0301 	orr.w	r3, r3, #1
2400b84c:	6013      	str	r3, [r2, #0]
  htim->State = HAL_TIM_STATE_READY;
2400b84e:	2301      	movs	r3, #1
2400b850:	f880 303d 	strb.w	r3, [r0, #61]	@ 0x3d
}
2400b854:	2000      	movs	r0, #0
2400b856:	4770      	bx	lr
2400b858:	00010007 	.word	0x00010007

2400b85c <HAL_TIM_Base_Stop>:
  htim->State = HAL_TIM_STATE_BUSY;
2400b85c:	2302      	movs	r3, #2
  __HAL_TIM_DISABLE(htim);
2400b85e:	f241 1211 	movw	r2, #4369	@ 0x1111
  htim->State = HAL_TIM_STATE_BUSY;
2400b862:	f880 303d 	strb.w	r3, [r0, #61]	@ 0x3d
  __HAL_TIM_DISABLE(htim);
2400b866:	6803      	ldr	r3, [r0, #0]
2400b868:	6a19      	ldr	r1, [r3, #32]
2400b86a:	4211      	tst	r1, r2
2400b86c:	d108      	bne.n	2400b880 <HAL_TIM_Base_Stop+0x24>
2400b86e:	6a19      	ldr	r1, [r3, #32]
2400b870:	f240 4244 	movw	r2, #1092	@ 0x444
2400b874:	4211      	tst	r1, r2
2400b876:	d103      	bne.n	2400b880 <HAL_TIM_Base_Stop+0x24>
2400b878:	681a      	ldr	r2, [r3, #0]
2400b87a:	f022 0201 	bic.w	r2, r2, #1
2400b87e:	601a      	str	r2, [r3, #0]
  htim->State = HAL_TIM_STATE_READY;
2400b880:	2301      	movs	r3, #1
2400b882:	f880 303d 	strb.w	r3, [r0, #61]	@ 0x3d
}
2400b886:	2000      	movs	r0, #0
2400b888:	4770      	bx	lr

2400b88a <HAL_TIM_Base_Start_IT>:
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
2400b88a:	6803      	ldr	r3, [r0, #0]
2400b88c:	68da      	ldr	r2, [r3, #12]
2400b88e:	f042 0201 	orr.w	r2, r2, #1
2400b892:	60da      	str	r2, [r3, #12]
  tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
2400b894:	4a06      	ldr	r2, [pc, #24]	@ (2400b8b0 <HAL_TIM_Base_Start_IT+0x26>)
2400b896:	6899      	ldr	r1, [r3, #8]
2400b898:	400a      	ands	r2, r1
  if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
2400b89a:	2a06      	cmp	r2, #6
2400b89c:	d006      	beq.n	2400b8ac <HAL_TIM_Base_Start_IT+0x22>
2400b89e:	f5b2 3f80 	cmp.w	r2, #65536	@ 0x10000
2400b8a2:	d003      	beq.n	2400b8ac <HAL_TIM_Base_Start_IT+0x22>
    __HAL_TIM_ENABLE(htim);
2400b8a4:	681a      	ldr	r2, [r3, #0]
2400b8a6:	f042 0201 	orr.w	r2, r2, #1
2400b8aa:	601a      	str	r2, [r3, #0]
}
2400b8ac:	2000      	movs	r0, #0
2400b8ae:	4770      	bx	lr
2400b8b0:	00010007 	.word	0x00010007

2400b8b4 <HAL_TIM_Base_Stop_IT>:
  __HAL_TIM_DISABLE_IT(htim, TIM_IT_UPDATE);
2400b8b4:	6803      	ldr	r3, [r0, #0]
2400b8b6:	68da      	ldr	r2, [r3, #12]
2400b8b8:	f022 0201 	bic.w	r2, r2, #1
2400b8bc:	60da      	str	r2, [r3, #12]
  __HAL_TIM_DISABLE(htim);
2400b8be:	f241 1211 	movw	r2, #4369	@ 0x1111
2400b8c2:	6a19      	ldr	r1, [r3, #32]
2400b8c4:	4211      	tst	r1, r2
2400b8c6:	d108      	bne.n	2400b8da <HAL_TIM_Base_Stop_IT+0x26>
2400b8c8:	6a19      	ldr	r1, [r3, #32]
2400b8ca:	f240 4244 	movw	r2, #1092	@ 0x444
2400b8ce:	4211      	tst	r1, r2
2400b8d0:	d103      	bne.n	2400b8da <HAL_TIM_Base_Stop_IT+0x26>
2400b8d2:	681a      	ldr	r2, [r3, #0]
2400b8d4:	f022 0201 	bic.w	r2, r2, #1
2400b8d8:	601a      	str	r2, [r3, #0]
}
2400b8da:	2000      	movs	r0, #0
2400b8dc:	4770      	bx	lr

2400b8de <HAL_TIM_Base_Start_DMA>:
{
2400b8de:	b510      	push	{r4, lr}
2400b8e0:	4613      	mov	r3, r2
  if (htim->State == HAL_TIM_STATE_BUSY)
2400b8e2:	f890 203d 	ldrb.w	r2, [r0, #61]	@ 0x3d
{
2400b8e6:	4604      	mov	r4, r0
  if (htim->State == HAL_TIM_STATE_BUSY)
2400b8e8:	2a02      	cmp	r2, #2
2400b8ea:	b2d0      	uxtb	r0, r2
2400b8ec:	d006      	beq.n	2400b8fc <HAL_TIM_Base_Start_DMA+0x1e>
  else if (htim->State == HAL_TIM_STATE_READY)
2400b8ee:	f894 203d 	ldrb.w	r2, [r4, #61]	@ 0x3d
2400b8f2:	2a01      	cmp	r2, #1
2400b8f4:	d106      	bne.n	2400b904 <HAL_TIM_Base_Start_DMA+0x26>
    if ((pData == NULL) && (Length > 0U))
2400b8f6:	b911      	cbnz	r1, 2400b8fe <HAL_TIM_Base_Start_DMA+0x20>
2400b8f8:	b10b      	cbz	r3, 2400b8fe <HAL_TIM_Base_Start_DMA+0x20>
      return HAL_ERROR;
2400b8fa:	2001      	movs	r0, #1
}
2400b8fc:	bd10      	pop	{r4, pc}
      htim->State = HAL_TIM_STATE_BUSY;
2400b8fe:	2202      	movs	r2, #2
2400b900:	f884 203d 	strb.w	r2, [r4, #61]	@ 0x3d
  htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
2400b904:	6a20      	ldr	r0, [r4, #32]
2400b906:	4a0f      	ldr	r2, [pc, #60]	@ (2400b944 <HAL_TIM_Base_Start_DMA+0x66>)
2400b908:	63c2      	str	r2, [r0, #60]	@ 0x3c
  htim->hdma[TIM_DMA_ID_UPDATE]->XferHalfCpltCallback = TIM_DMAPeriodElapsedHalfCplt;
2400b90a:	4a0f      	ldr	r2, [pc, #60]	@ (2400b948 <HAL_TIM_Base_Start_DMA+0x6a>)
2400b90c:	6402      	str	r2, [r0, #64]	@ 0x40
  htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = TIM_DMAError ;
2400b90e:	4a0f      	ldr	r2, [pc, #60]	@ (2400b94c <HAL_TIM_Base_Start_DMA+0x6e>)
2400b910:	64c2      	str	r2, [r0, #76]	@ 0x4c
  if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)pData, (uint32_t)&htim->Instance->ARR, Length) != HAL_OK)
2400b912:	6822      	ldr	r2, [r4, #0]
2400b914:	322c      	adds	r2, #44	@ 0x2c
2400b916:	f7f6 f863 	bl	240019e0 <HAL_DMA_Start_IT>
2400b91a:	2800      	cmp	r0, #0
2400b91c:	d1ed      	bne.n	2400b8fa <HAL_TIM_Base_Start_DMA+0x1c>
  __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_UPDATE);
2400b91e:	6823      	ldr	r3, [r4, #0]
2400b920:	68da      	ldr	r2, [r3, #12]
2400b922:	f442 7280 	orr.w	r2, r2, #256	@ 0x100
2400b926:	60da      	str	r2, [r3, #12]
  tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
2400b928:	4a09      	ldr	r2, [pc, #36]	@ (2400b950 <HAL_TIM_Base_Start_DMA+0x72>)
2400b92a:	6899      	ldr	r1, [r3, #8]
2400b92c:	400a      	ands	r2, r1
  if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
2400b92e:	2a06      	cmp	r2, #6
2400b930:	d0e4      	beq.n	2400b8fc <HAL_TIM_Base_Start_DMA+0x1e>
2400b932:	f5b2 3f80 	cmp.w	r2, #65536	@ 0x10000
2400b936:	d0e1      	beq.n	2400b8fc <HAL_TIM_Base_Start_DMA+0x1e>
    __HAL_TIM_ENABLE(htim);
2400b938:	681a      	ldr	r2, [r3, #0]
2400b93a:	f042 0201 	orr.w	r2, r2, #1
2400b93e:	601a      	str	r2, [r3, #0]
2400b940:	e7dc      	b.n	2400b8fc <HAL_TIM_Base_Start_DMA+0x1e>
2400b942:	bf00      	nop
2400b944:	2400c2bd 	.word	0x2400c2bd
2400b948:	2400c2cf 	.word	0x2400c2cf
2400b94c:	2400c55f 	.word	0x2400c55f
2400b950:	00010007 	.word	0x00010007

2400b954 <HAL_TIM_Base_Stop_DMA>:
  __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_UPDATE);
2400b954:	6802      	ldr	r2, [r0, #0]
2400b956:	68d3      	ldr	r3, [r2, #12]
2400b958:	f423 7380 	bic.w	r3, r3, #256	@ 0x100
{
2400b95c:	b510      	push	{r4, lr}
2400b95e:	4604      	mov	r4, r0
  __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_UPDATE);
2400b960:	60d3      	str	r3, [r2, #12]
  (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_UPDATE]);
2400b962:	6a00      	ldr	r0, [r0, #32]
2400b964:	f7f6 fb02 	bl	24001f6c <HAL_DMA_Abort_IT>
  __HAL_TIM_DISABLE(htim);
2400b968:	6823      	ldr	r3, [r4, #0]
2400b96a:	f241 1211 	movw	r2, #4369	@ 0x1111
2400b96e:	6a19      	ldr	r1, [r3, #32]
2400b970:	4211      	tst	r1, r2
2400b972:	d108      	bne.n	2400b986 <HAL_TIM_Base_Stop_DMA+0x32>
2400b974:	6a19      	ldr	r1, [r3, #32]
2400b976:	f240 4244 	movw	r2, #1092	@ 0x444
2400b97a:	4211      	tst	r1, r2
2400b97c:	d103      	bne.n	2400b986 <HAL_TIM_Base_Stop_DMA+0x32>
2400b97e:	681a      	ldr	r2, [r3, #0]
2400b980:	f022 0201 	bic.w	r2, r2, #1
2400b984:	601a      	str	r2, [r3, #0]
  htim->State = HAL_TIM_STATE_READY;
2400b986:	2301      	movs	r3, #1
}
2400b988:	2000      	movs	r0, #0
  htim->State = HAL_TIM_STATE_READY;
2400b98a:	f884 303d 	strb.w	r3, [r4, #61]	@ 0x3d
}
2400b98e:	bd10      	pop	{r4, pc}

2400b990 <HAL_TIM_OC_MspInit>:
__weak void HAL_TIM_OC_MspInit(TIM_HandleTypeDef *htim)
2400b990:	4770      	bx	lr

2400b992 <HAL_TIM_OC_MspDeInit>:
__weak void HAL_TIM_OC_MspDeInit(TIM_HandleTypeDef *htim)
2400b992:	4770      	bx	lr

2400b994 <HAL_TIM_OC_DeInit>:
  htim->State = HAL_TIM_STATE_BUSY;
2400b994:	2302      	movs	r3, #2
  __HAL_TIM_DISABLE(htim);
2400b996:	f241 1211 	movw	r2, #4369	@ 0x1111
{
2400b99a:	b510      	push	{r4, lr}
  htim->State = HAL_TIM_STATE_BUSY;
2400b99c:	f880 303d 	strb.w	r3, [r0, #61]	@ 0x3d
{
2400b9a0:	4604      	mov	r4, r0
  __HAL_TIM_DISABLE(htim);
2400b9a2:	6803      	ldr	r3, [r0, #0]
2400b9a4:	6a19      	ldr	r1, [r3, #32]
2400b9a6:	4211      	tst	r1, r2
2400b9a8:	d108      	bne.n	2400b9bc <HAL_TIM_OC_DeInit+0x28>
2400b9aa:	6a19      	ldr	r1, [r3, #32]
2400b9ac:	f240 4244 	movw	r2, #1092	@ 0x444
2400b9b0:	4211      	tst	r1, r2
2400b9b2:	d103      	bne.n	2400b9bc <HAL_TIM_OC_DeInit+0x28>
2400b9b4:	681a      	ldr	r2, [r3, #0]
2400b9b6:	f022 0201 	bic.w	r2, r2, #1
2400b9ba:	601a      	str	r2, [r3, #0]
  HAL_TIM_OC_MspDeInit(htim);
2400b9bc:	4620      	mov	r0, r4
2400b9be:	f7ff ffe8 	bl	2400b992 <HAL_TIM_OC_MspDeInit>
  htim->State = HAL_TIM_STATE_RESET;
2400b9c2:	2000      	movs	r0, #0
2400b9c4:	f884 003d 	strb.w	r0, [r4, #61]	@ 0x3d
  __HAL_UNLOCK(htim);
2400b9c8:	f884 003c 	strb.w	r0, [r4, #60]	@ 0x3c
}
2400b9cc:	bd10      	pop	{r4, pc}

2400b9ce <HAL_TIM_PWM_MspInit>:
__weak void HAL_TIM_PWM_MspInit(TIM_HandleTypeDef *htim)
2400b9ce:	4770      	bx	lr

2400b9d0 <HAL_TIM_PWM_MspDeInit>:
__weak void HAL_TIM_PWM_MspDeInit(TIM_HandleTypeDef *htim)
2400b9d0:	4770      	bx	lr

2400b9d2 <HAL_TIM_PWM_DeInit>:
  htim->State = HAL_TIM_STATE_BUSY;
2400b9d2:	2302      	movs	r3, #2
  __HAL_TIM_DISABLE(htim);
2400b9d4:	f241 1211 	movw	r2, #4369	@ 0x1111
{
2400b9d8:	b510      	push	{r4, lr}
  htim->State = HAL_TIM_STATE_BUSY;
2400b9da:	f880 303d 	strb.w	r3, [r0, #61]	@ 0x3d
{
2400b9de:	4604      	mov	r4, r0
  __HAL_TIM_DISABLE(htim);
2400b9e0:	6803      	ldr	r3, [r0, #0]
2400b9e2:	6a19      	ldr	r1, [r3, #32]
2400b9e4:	4211      	tst	r1, r2
2400b9e6:	d108      	bne.n	2400b9fa <HAL_TIM_PWM_DeInit+0x28>
2400b9e8:	6a19      	ldr	r1, [r3, #32]
2400b9ea:	f240 4244 	movw	r2, #1092	@ 0x444
2400b9ee:	4211      	tst	r1, r2
2400b9f0:	d103      	bne.n	2400b9fa <HAL_TIM_PWM_DeInit+0x28>
2400b9f2:	681a      	ldr	r2, [r3, #0]
2400b9f4:	f022 0201 	bic.w	r2, r2, #1
2400b9f8:	601a      	str	r2, [r3, #0]
  HAL_TIM_PWM_MspDeInit(htim);
2400b9fa:	4620      	mov	r0, r4
2400b9fc:	f7ff ffe8 	bl	2400b9d0 <HAL_TIM_PWM_MspDeInit>
  htim->State = HAL_TIM_STATE_RESET;
2400ba00:	2000      	movs	r0, #0
2400ba02:	f884 003d 	strb.w	r0, [r4, #61]	@ 0x3d
  __HAL_UNLOCK(htim);
2400ba06:	f884 003c 	strb.w	r0, [r4, #60]	@ 0x3c
}
2400ba0a:	bd10      	pop	{r4, pc}

2400ba0c <HAL_TIM_IC_MspInit>:
__weak void HAL_TIM_IC_MspInit(TIM_HandleTypeDef *htim)
2400ba0c:	4770      	bx	lr

2400ba0e <HAL_TIM_IC_MspDeInit>:
__weak void HAL_TIM_IC_MspDeInit(TIM_HandleTypeDef *htim)
2400ba0e:	4770      	bx	lr

2400ba10 <HAL_TIM_IC_DeInit>:
  htim->State = HAL_TIM_STATE_BUSY;
2400ba10:	2302      	movs	r3, #2
  __HAL_TIM_DISABLE(htim);
2400ba12:	f241 1211 	movw	r2, #4369	@ 0x1111
{
2400ba16:	b510      	push	{r4, lr}
  htim->State = HAL_TIM_STATE_BUSY;
2400ba18:	f880 303d 	strb.w	r3, [r0, #61]	@ 0x3d
{
2400ba1c:	4604      	mov	r4, r0
  __HAL_TIM_DISABLE(htim);
2400ba1e:	6803      	ldr	r3, [r0, #0]
2400ba20:	6a19      	ldr	r1, [r3, #32]
2400ba22:	4211      	tst	r1, r2
2400ba24:	d108      	bne.n	2400ba38 <HAL_TIM_IC_DeInit+0x28>
2400ba26:	6a19      	ldr	r1, [r3, #32]
2400ba28:	f240 4244 	movw	r2, #1092	@ 0x444
2400ba2c:	4211      	tst	r1, r2
2400ba2e:	d103      	bne.n	2400ba38 <HAL_TIM_IC_DeInit+0x28>
2400ba30:	681a      	ldr	r2, [r3, #0]
2400ba32:	f022 0201 	bic.w	r2, r2, #1
2400ba36:	601a      	str	r2, [r3, #0]
  HAL_TIM_IC_MspDeInit(htim);
2400ba38:	4620      	mov	r0, r4
2400ba3a:	f7ff ffe8 	bl	2400ba0e <HAL_TIM_IC_MspDeInit>
  htim->State = HAL_TIM_STATE_RESET;
2400ba3e:	2000      	movs	r0, #0
2400ba40:	f884 003d 	strb.w	r0, [r4, #61]	@ 0x3d
  __HAL_UNLOCK(htim);
2400ba44:	f884 003c 	strb.w	r0, [r4, #60]	@ 0x3c
}
2400ba48:	bd10      	pop	{r4, pc}

2400ba4a <HAL_TIM_OnePulse_MspInit>:
__weak void HAL_TIM_OnePulse_MspInit(TIM_HandleTypeDef *htim)
2400ba4a:	4770      	bx	lr

2400ba4c <HAL_TIM_OnePulse_MspDeInit>:
__weak void HAL_TIM_OnePulse_MspDeInit(TIM_HandleTypeDef *htim)
2400ba4c:	4770      	bx	lr

2400ba4e <HAL_TIM_OnePulse_DeInit>:
  htim->State = HAL_TIM_STATE_BUSY;
2400ba4e:	2302      	movs	r3, #2
  __HAL_TIM_DISABLE(htim);
2400ba50:	f241 1211 	movw	r2, #4369	@ 0x1111
{
2400ba54:	b510      	push	{r4, lr}
  htim->State = HAL_TIM_STATE_BUSY;
2400ba56:	f880 303d 	strb.w	r3, [r0, #61]	@ 0x3d
{
2400ba5a:	4604      	mov	r4, r0
  __HAL_TIM_DISABLE(htim);
2400ba5c:	6803      	ldr	r3, [r0, #0]
2400ba5e:	6a19      	ldr	r1, [r3, #32]
2400ba60:	4211      	tst	r1, r2
2400ba62:	d108      	bne.n	2400ba76 <HAL_TIM_OnePulse_DeInit+0x28>
2400ba64:	6a19      	ldr	r1, [r3, #32]
2400ba66:	f240 4244 	movw	r2, #1092	@ 0x444
2400ba6a:	4211      	tst	r1, r2
2400ba6c:	d103      	bne.n	2400ba76 <HAL_TIM_OnePulse_DeInit+0x28>
2400ba6e:	681a      	ldr	r2, [r3, #0]
2400ba70:	f022 0201 	bic.w	r2, r2, #1
2400ba74:	601a      	str	r2, [r3, #0]
  HAL_TIM_OnePulse_MspDeInit(htim);
2400ba76:	4620      	mov	r0, r4
2400ba78:	f7ff ffe8 	bl	2400ba4c <HAL_TIM_OnePulse_MspDeInit>
  htim->State = HAL_TIM_STATE_RESET;
2400ba7c:	2000      	movs	r0, #0
2400ba7e:	f884 003d 	strb.w	r0, [r4, #61]	@ 0x3d
  __HAL_UNLOCK(htim);
2400ba82:	f884 003c 	strb.w	r0, [r4, #60]	@ 0x3c
}
2400ba86:	bd10      	pop	{r4, pc}

2400ba88 <HAL_TIM_OnePulse_Start>:
  TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
2400ba88:	6803      	ldr	r3, [r0, #0]
  assert_param(IS_TIM_CHANNELS(Channel));

  tmp = TIM_CCER_CC1E << (Channel & 0x1FU); /* 0x1FU = 31 bits max shift */

  /* Reset the CCxE Bit */
  TIMx->CCER &= ~tmp;
2400ba8a:	6a1a      	ldr	r2, [r3, #32]
2400ba8c:	f022 0201 	bic.w	r2, r2, #1
2400ba90:	621a      	str	r2, [r3, #32]

  /* Set or reset the CCxE Bit */
  TIMx->CCER |= (uint32_t)(ChannelState << (Channel & 0x1FU)); /* 0x1FU = 31 bits max shift */
2400ba92:	6a1a      	ldr	r2, [r3, #32]
2400ba94:	f042 0201 	orr.w	r2, r2, #1
2400ba98:	621a      	str	r2, [r3, #32]
  TIMx->CCER &= ~tmp;
2400ba9a:	6a1a      	ldr	r2, [r3, #32]
2400ba9c:	f022 0210 	bic.w	r2, r2, #16
2400baa0:	621a      	str	r2, [r3, #32]
  TIMx->CCER |= (uint32_t)(ChannelState << (Channel & 0x1FU)); /* 0x1FU = 31 bits max shift */
2400baa2:	6a1a      	ldr	r2, [r3, #32]
2400baa4:	f042 0210 	orr.w	r2, r2, #16
2400baa8:	621a      	str	r2, [r3, #32]
  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
2400baaa:	4a0c      	ldr	r2, [pc, #48]	@ (2400badc <HAL_TIM_OnePulse_Start+0x54>)
2400baac:	4293      	cmp	r3, r2
2400baae:	d00f      	beq.n	2400bad0 <HAL_TIM_OnePulse_Start+0x48>
2400bab0:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
2400bab4:	4293      	cmp	r3, r2
2400bab6:	d00b      	beq.n	2400bad0 <HAL_TIM_OnePulse_Start+0x48>
2400bab8:	f502 5270 	add.w	r2, r2, #15360	@ 0x3c00
2400babc:	4293      	cmp	r3, r2
2400babe:	d007      	beq.n	2400bad0 <HAL_TIM_OnePulse_Start+0x48>
2400bac0:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
2400bac4:	4293      	cmp	r3, r2
2400bac6:	d003      	beq.n	2400bad0 <HAL_TIM_OnePulse_Start+0x48>
2400bac8:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
2400bacc:	4293      	cmp	r3, r2
2400bace:	d103      	bne.n	2400bad8 <HAL_TIM_OnePulse_Start+0x50>
    __HAL_TIM_MOE_ENABLE(htim);
2400bad0:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
2400bad2:	f442 4200 	orr.w	r2, r2, #32768	@ 0x8000
2400bad6:	645a      	str	r2, [r3, #68]	@ 0x44
}
2400bad8:	2000      	movs	r0, #0
2400bada:	4770      	bx	lr
2400badc:	40010000 	.word	0x40010000

2400bae0 <HAL_TIM_OnePulse_Stop>:
  TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
2400bae0:	6803      	ldr	r3, [r0, #0]
  TIMx->CCER &= ~tmp;
2400bae2:	6a1a      	ldr	r2, [r3, #32]
2400bae4:	f022 0201 	bic.w	r2, r2, #1
2400bae8:	621a      	str	r2, [r3, #32]
  TIMx->CCER |= (uint32_t)(ChannelState << (Channel & 0x1FU)); /* 0x1FU = 31 bits max shift */
2400baea:	6a1a      	ldr	r2, [r3, #32]
2400baec:	621a      	str	r2, [r3, #32]
  TIMx->CCER &= ~tmp;
2400baee:	6a1a      	ldr	r2, [r3, #32]
2400baf0:	f022 0210 	bic.w	r2, r2, #16
2400baf4:	621a      	str	r2, [r3, #32]
  TIMx->CCER |= (uint32_t)(ChannelState << (Channel & 0x1FU)); /* 0x1FU = 31 bits max shift */
2400baf6:	6a1a      	ldr	r2, [r3, #32]
2400baf8:	621a      	str	r2, [r3, #32]
  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
2400bafa:	4a18      	ldr	r2, [pc, #96]	@ (2400bb5c <HAL_TIM_OnePulse_Stop+0x7c>)
2400bafc:	4293      	cmp	r3, r2
2400bafe:	d00f      	beq.n	2400bb20 <HAL_TIM_OnePulse_Stop+0x40>
2400bb00:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
2400bb04:	4293      	cmp	r3, r2
2400bb06:	d00b      	beq.n	2400bb20 <HAL_TIM_OnePulse_Stop+0x40>
2400bb08:	f502 5270 	add.w	r2, r2, #15360	@ 0x3c00
2400bb0c:	4293      	cmp	r3, r2
2400bb0e:	d007      	beq.n	2400bb20 <HAL_TIM_OnePulse_Stop+0x40>
2400bb10:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
2400bb14:	4293      	cmp	r3, r2
2400bb16:	d003      	beq.n	2400bb20 <HAL_TIM_OnePulse_Stop+0x40>
2400bb18:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
2400bb1c:	4293      	cmp	r3, r2
2400bb1e:	d10d      	bne.n	2400bb3c <HAL_TIM_OnePulse_Stop+0x5c>
    __HAL_TIM_MOE_DISABLE(htim);
2400bb20:	6a19      	ldr	r1, [r3, #32]
2400bb22:	f241 1211 	movw	r2, #4369	@ 0x1111
2400bb26:	4211      	tst	r1, r2
2400bb28:	d108      	bne.n	2400bb3c <HAL_TIM_OnePulse_Stop+0x5c>
2400bb2a:	6a19      	ldr	r1, [r3, #32]
2400bb2c:	f240 4244 	movw	r2, #1092	@ 0x444
2400bb30:	4211      	tst	r1, r2
2400bb32:	d103      	bne.n	2400bb3c <HAL_TIM_OnePulse_Stop+0x5c>
2400bb34:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
2400bb36:	f422 4200 	bic.w	r2, r2, #32768	@ 0x8000
2400bb3a:	645a      	str	r2, [r3, #68]	@ 0x44
  __HAL_TIM_DISABLE(htim);
2400bb3c:	6a19      	ldr	r1, [r3, #32]
2400bb3e:	f241 1211 	movw	r2, #4369	@ 0x1111
2400bb42:	4211      	tst	r1, r2
2400bb44:	d108      	bne.n	2400bb58 <HAL_TIM_OnePulse_Stop+0x78>
2400bb46:	6a19      	ldr	r1, [r3, #32]
2400bb48:	f240 4244 	movw	r2, #1092	@ 0x444
2400bb4c:	4211      	tst	r1, r2
2400bb4e:	d103      	bne.n	2400bb58 <HAL_TIM_OnePulse_Stop+0x78>
2400bb50:	681a      	ldr	r2, [r3, #0]
2400bb52:	f022 0201 	bic.w	r2, r2, #1
2400bb56:	601a      	str	r2, [r3, #0]
}
2400bb58:	2000      	movs	r0, #0
2400bb5a:	4770      	bx	lr
2400bb5c:	40010000 	.word	0x40010000

2400bb60 <HAL_TIM_OnePulse_Start_IT>:
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
2400bb60:	6803      	ldr	r3, [r0, #0]
2400bb62:	68da      	ldr	r2, [r3, #12]
2400bb64:	f042 0202 	orr.w	r2, r2, #2
2400bb68:	60da      	str	r2, [r3, #12]
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
2400bb6a:	68da      	ldr	r2, [r3, #12]
2400bb6c:	f042 0204 	orr.w	r2, r2, #4
2400bb70:	60da      	str	r2, [r3, #12]
  TIMx->CCER &= ~tmp;
2400bb72:	6a1a      	ldr	r2, [r3, #32]
2400bb74:	f022 0201 	bic.w	r2, r2, #1
2400bb78:	621a      	str	r2, [r3, #32]
  TIMx->CCER |= (uint32_t)(ChannelState << (Channel & 0x1FU)); /* 0x1FU = 31 bits max shift */
2400bb7a:	6a1a      	ldr	r2, [r3, #32]
2400bb7c:	f042 0201 	orr.w	r2, r2, #1
2400bb80:	621a      	str	r2, [r3, #32]
  TIMx->CCER &= ~tmp;
2400bb82:	6a1a      	ldr	r2, [r3, #32]
2400bb84:	f022 0210 	bic.w	r2, r2, #16
2400bb88:	621a      	str	r2, [r3, #32]
  TIMx->CCER |= (uint32_t)(ChannelState << (Channel & 0x1FU)); /* 0x1FU = 31 bits max shift */
2400bb8a:	6a1a      	ldr	r2, [r3, #32]
2400bb8c:	f042 0210 	orr.w	r2, r2, #16
2400bb90:	621a      	str	r2, [r3, #32]
  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
2400bb92:	4a0c      	ldr	r2, [pc, #48]	@ (2400bbc4 <HAL_TIM_OnePulse_Start_IT+0x64>)
2400bb94:	4293      	cmp	r3, r2
2400bb96:	d00f      	beq.n	2400bbb8 <HAL_TIM_OnePulse_Start_IT+0x58>
2400bb98:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
2400bb9c:	4293      	cmp	r3, r2
2400bb9e:	d00b      	beq.n	2400bbb8 <HAL_TIM_OnePulse_Start_IT+0x58>
2400bba0:	f502 5270 	add.w	r2, r2, #15360	@ 0x3c00
2400bba4:	4293      	cmp	r3, r2
2400bba6:	d007      	beq.n	2400bbb8 <HAL_TIM_OnePulse_Start_IT+0x58>
2400bba8:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
2400bbac:	4293      	cmp	r3, r2
2400bbae:	d003      	beq.n	2400bbb8 <HAL_TIM_OnePulse_Start_IT+0x58>
2400bbb0:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
2400bbb4:	4293      	cmp	r3, r2
2400bbb6:	d103      	bne.n	2400bbc0 <HAL_TIM_OnePulse_Start_IT+0x60>
    __HAL_TIM_MOE_ENABLE(htim);
2400bbb8:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
2400bbba:	f442 4200 	orr.w	r2, r2, #32768	@ 0x8000
2400bbbe:	645a      	str	r2, [r3, #68]	@ 0x44
}
2400bbc0:	2000      	movs	r0, #0
2400bbc2:	4770      	bx	lr
2400bbc4:	40010000 	.word	0x40010000

2400bbc8 <HAL_TIM_OnePulse_Stop_IT>:
  __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
2400bbc8:	6803      	ldr	r3, [r0, #0]
2400bbca:	68da      	ldr	r2, [r3, #12]
2400bbcc:	f022 0202 	bic.w	r2, r2, #2
2400bbd0:	60da      	str	r2, [r3, #12]
  __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
2400bbd2:	68da      	ldr	r2, [r3, #12]
2400bbd4:	f022 0204 	bic.w	r2, r2, #4
2400bbd8:	60da      	str	r2, [r3, #12]
  TIMx->CCER &= ~tmp;
2400bbda:	6a1a      	ldr	r2, [r3, #32]
2400bbdc:	f022 0201 	bic.w	r2, r2, #1
2400bbe0:	621a      	str	r2, [r3, #32]
  TIMx->CCER |= (uint32_t)(ChannelState << (Channel & 0x1FU)); /* 0x1FU = 31 bits max shift */
2400bbe2:	6a1a      	ldr	r2, [r3, #32]
2400bbe4:	621a      	str	r2, [r3, #32]
  TIMx->CCER &= ~tmp;
2400bbe6:	6a1a      	ldr	r2, [r3, #32]
2400bbe8:	f022 0210 	bic.w	r2, r2, #16
2400bbec:	621a      	str	r2, [r3, #32]
  TIMx->CCER |= (uint32_t)(ChannelState << (Channel & 0x1FU)); /* 0x1FU = 31 bits max shift */
2400bbee:	6a1a      	ldr	r2, [r3, #32]
2400bbf0:	621a      	str	r2, [r3, #32]
  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
2400bbf2:	4a18      	ldr	r2, [pc, #96]	@ (2400bc54 <HAL_TIM_OnePulse_Stop_IT+0x8c>)
2400bbf4:	4293      	cmp	r3, r2
2400bbf6:	d00f      	beq.n	2400bc18 <HAL_TIM_OnePulse_Stop_IT+0x50>
2400bbf8:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
2400bbfc:	4293      	cmp	r3, r2
2400bbfe:	d00b      	beq.n	2400bc18 <HAL_TIM_OnePulse_Stop_IT+0x50>
2400bc00:	f502 5270 	add.w	r2, r2, #15360	@ 0x3c00
2400bc04:	4293      	cmp	r3, r2
2400bc06:	d007      	beq.n	2400bc18 <HAL_TIM_OnePulse_Stop_IT+0x50>
2400bc08:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
2400bc0c:	4293      	cmp	r3, r2
2400bc0e:	d003      	beq.n	2400bc18 <HAL_TIM_OnePulse_Stop_IT+0x50>
2400bc10:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
2400bc14:	4293      	cmp	r3, r2
2400bc16:	d10d      	bne.n	2400bc34 <HAL_TIM_OnePulse_Stop_IT+0x6c>
    __HAL_TIM_MOE_DISABLE(htim);
2400bc18:	6a19      	ldr	r1, [r3, #32]
2400bc1a:	f241 1211 	movw	r2, #4369	@ 0x1111
2400bc1e:	4211      	tst	r1, r2
2400bc20:	d108      	bne.n	2400bc34 <HAL_TIM_OnePulse_Stop_IT+0x6c>
2400bc22:	6a19      	ldr	r1, [r3, #32]
2400bc24:	f240 4244 	movw	r2, #1092	@ 0x444
2400bc28:	4211      	tst	r1, r2
2400bc2a:	d103      	bne.n	2400bc34 <HAL_TIM_OnePulse_Stop_IT+0x6c>
2400bc2c:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
2400bc2e:	f422 4200 	bic.w	r2, r2, #32768	@ 0x8000
2400bc32:	645a      	str	r2, [r3, #68]	@ 0x44
  __HAL_TIM_DISABLE(htim);
2400bc34:	6a19      	ldr	r1, [r3, #32]
2400bc36:	f241 1211 	movw	r2, #4369	@ 0x1111
2400bc3a:	4211      	tst	r1, r2
2400bc3c:	d108      	bne.n	2400bc50 <HAL_TIM_OnePulse_Stop_IT+0x88>
2400bc3e:	6a19      	ldr	r1, [r3, #32]
2400bc40:	f240 4244 	movw	r2, #1092	@ 0x444
2400bc44:	4211      	tst	r1, r2
2400bc46:	d103      	bne.n	2400bc50 <HAL_TIM_OnePulse_Stop_IT+0x88>
2400bc48:	681a      	ldr	r2, [r3, #0]
2400bc4a:	f022 0201 	bic.w	r2, r2, #1
2400bc4e:	601a      	str	r2, [r3, #0]
}
2400bc50:	2000      	movs	r0, #0
2400bc52:	4770      	bx	lr
2400bc54:	40010000 	.word	0x40010000

2400bc58 <HAL_TIM_Encoder_MspInit>:
__weak void HAL_TIM_Encoder_MspInit(TIM_HandleTypeDef *htim)
2400bc58:	4770      	bx	lr

2400bc5a <HAL_TIM_Encoder_MspDeInit>:
__weak void HAL_TIM_Encoder_MspDeInit(TIM_HandleTypeDef *htim)
2400bc5a:	4770      	bx	lr

2400bc5c <HAL_TIM_Encoder_DeInit>:
  htim->State = HAL_TIM_STATE_BUSY;
2400bc5c:	2302      	movs	r3, #2
  __HAL_TIM_DISABLE(htim);
2400bc5e:	f241 1211 	movw	r2, #4369	@ 0x1111
{
2400bc62:	b510      	push	{r4, lr}
  htim->State = HAL_TIM_STATE_BUSY;
2400bc64:	f880 303d 	strb.w	r3, [r0, #61]	@ 0x3d
{
2400bc68:	4604      	mov	r4, r0
  __HAL_TIM_DISABLE(htim);
2400bc6a:	6803      	ldr	r3, [r0, #0]
2400bc6c:	6a19      	ldr	r1, [r3, #32]
2400bc6e:	4211      	tst	r1, r2
2400bc70:	d108      	bne.n	2400bc84 <HAL_TIM_Encoder_DeInit+0x28>
2400bc72:	6a19      	ldr	r1, [r3, #32]
2400bc74:	f240 4244 	movw	r2, #1092	@ 0x444
2400bc78:	4211      	tst	r1, r2
2400bc7a:	d103      	bne.n	2400bc84 <HAL_TIM_Encoder_DeInit+0x28>
2400bc7c:	681a      	ldr	r2, [r3, #0]
2400bc7e:	f022 0201 	bic.w	r2, r2, #1
2400bc82:	601a      	str	r2, [r3, #0]
  HAL_TIM_Encoder_MspDeInit(htim);
2400bc84:	4620      	mov	r0, r4
2400bc86:	f7ff ffe8 	bl	2400bc5a <HAL_TIM_Encoder_MspDeInit>
  htim->State = HAL_TIM_STATE_RESET;
2400bc8a:	2000      	movs	r0, #0
2400bc8c:	f884 003d 	strb.w	r0, [r4, #61]	@ 0x3d
  __HAL_UNLOCK(htim);
2400bc90:	f884 003c 	strb.w	r0, [r4, #60]	@ 0x3c
}
2400bc94:	bd10      	pop	{r4, pc}

2400bc96 <HAL_TIM_Encoder_Start>:
      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
2400bc96:	6803      	ldr	r3, [r0, #0]
  switch (Channel)
2400bc98:	b189      	cbz	r1, 2400bcbe <HAL_TIM_Encoder_Start+0x28>
2400bc9a:	2904      	cmp	r1, #4
2400bc9c:	d007      	beq.n	2400bcae <HAL_TIM_Encoder_Start+0x18>
  TIMx->CCER &= ~tmp;
2400bc9e:	6a1a      	ldr	r2, [r3, #32]
2400bca0:	f022 0201 	bic.w	r2, r2, #1
2400bca4:	621a      	str	r2, [r3, #32]
  TIMx->CCER |= (uint32_t)(ChannelState << (Channel & 0x1FU)); /* 0x1FU = 31 bits max shift */
2400bca6:	6a1a      	ldr	r2, [r3, #32]
2400bca8:	f042 0201 	orr.w	r2, r2, #1
2400bcac:	621a      	str	r2, [r3, #32]
  TIMx->CCER &= ~tmp;
2400bcae:	6a1a      	ldr	r2, [r3, #32]
2400bcb0:	f022 0210 	bic.w	r2, r2, #16
2400bcb4:	621a      	str	r2, [r3, #32]
  TIMx->CCER |= (uint32_t)(ChannelState << (Channel & 0x1FU)); /* 0x1FU = 31 bits max shift */
2400bcb6:	6a1a      	ldr	r2, [r3, #32]
2400bcb8:	f042 0210 	orr.w	r2, r2, #16
2400bcbc:	e006      	b.n	2400bccc <HAL_TIM_Encoder_Start+0x36>
  TIMx->CCER &= ~tmp;
2400bcbe:	6a1a      	ldr	r2, [r3, #32]
2400bcc0:	f022 0201 	bic.w	r2, r2, #1
2400bcc4:	621a      	str	r2, [r3, #32]
  TIMx->CCER |= (uint32_t)(ChannelState << (Channel & 0x1FU)); /* 0x1FU = 31 bits max shift */
2400bcc6:	6a1a      	ldr	r2, [r3, #32]
2400bcc8:	f042 0201 	orr.w	r2, r2, #1
2400bccc:	621a      	str	r2, [r3, #32]
}
2400bcce:	2000      	movs	r0, #0
  __HAL_TIM_ENABLE(htim);
2400bcd0:	681a      	ldr	r2, [r3, #0]
2400bcd2:	f042 0201 	orr.w	r2, r2, #1
2400bcd6:	601a      	str	r2, [r3, #0]
}
2400bcd8:	4770      	bx	lr

2400bcda <HAL_TIM_Encoder_Stop>:
      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
2400bcda:	6803      	ldr	r3, [r0, #0]
  switch (Channel)
2400bcdc:	b159      	cbz	r1, 2400bcf6 <HAL_TIM_Encoder_Stop+0x1c>
2400bcde:	2904      	cmp	r1, #4
2400bce0:	d005      	beq.n	2400bcee <HAL_TIM_Encoder_Stop+0x14>
  TIMx->CCER &= ~tmp;
2400bce2:	6a1a      	ldr	r2, [r3, #32]
2400bce4:	f022 0201 	bic.w	r2, r2, #1
2400bce8:	621a      	str	r2, [r3, #32]
  TIMx->CCER |= (uint32_t)(ChannelState << (Channel & 0x1FU)); /* 0x1FU = 31 bits max shift */
2400bcea:	6a1a      	ldr	r2, [r3, #32]
2400bcec:	621a      	str	r2, [r3, #32]
  TIMx->CCER &= ~tmp;
2400bcee:	6a1a      	ldr	r2, [r3, #32]
2400bcf0:	f022 0210 	bic.w	r2, r2, #16
2400bcf4:	e002      	b.n	2400bcfc <HAL_TIM_Encoder_Stop+0x22>
2400bcf6:	6a1a      	ldr	r2, [r3, #32]
2400bcf8:	f022 0201 	bic.w	r2, r2, #1
2400bcfc:	621a      	str	r2, [r3, #32]
  TIMx->CCER |= (uint32_t)(ChannelState << (Channel & 0x1FU)); /* 0x1FU = 31 bits max shift */
2400bcfe:	6a1a      	ldr	r2, [r3, #32]
2400bd00:	621a      	str	r2, [r3, #32]
  __HAL_TIM_DISABLE(htim);
2400bd02:	f241 1211 	movw	r2, #4369	@ 0x1111
2400bd06:	6a19      	ldr	r1, [r3, #32]
2400bd08:	4211      	tst	r1, r2
2400bd0a:	d108      	bne.n	2400bd1e <HAL_TIM_Encoder_Stop+0x44>
2400bd0c:	6a19      	ldr	r1, [r3, #32]
2400bd0e:	f240 4244 	movw	r2, #1092	@ 0x444
2400bd12:	4211      	tst	r1, r2
2400bd14:	d103      	bne.n	2400bd1e <HAL_TIM_Encoder_Stop+0x44>
2400bd16:	681a      	ldr	r2, [r3, #0]
2400bd18:	f022 0201 	bic.w	r2, r2, #1
2400bd1c:	601a      	str	r2, [r3, #0]
}
2400bd1e:	2000      	movs	r0, #0
2400bd20:	4770      	bx	lr

2400bd22 <HAL_TIM_Encoder_Start_IT>:
      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
2400bd22:	6803      	ldr	r3, [r0, #0]
  switch (Channel)
2400bd24:	b1b1      	cbz	r1, 2400bd54 <HAL_TIM_Encoder_Start_IT+0x32>
2400bd26:	2904      	cmp	r1, #4
2400bd28:	d026      	beq.n	2400bd78 <HAL_TIM_Encoder_Start_IT+0x56>
  TIMx->CCER &= ~tmp;
2400bd2a:	6a1a      	ldr	r2, [r3, #32]
2400bd2c:	f022 0201 	bic.w	r2, r2, #1
2400bd30:	621a      	str	r2, [r3, #32]
  TIMx->CCER |= (uint32_t)(ChannelState << (Channel & 0x1FU)); /* 0x1FU = 31 bits max shift */
2400bd32:	6a1a      	ldr	r2, [r3, #32]
2400bd34:	f042 0201 	orr.w	r2, r2, #1
2400bd38:	621a      	str	r2, [r3, #32]
  TIMx->CCER &= ~tmp;
2400bd3a:	6a1a      	ldr	r2, [r3, #32]
2400bd3c:	f022 0210 	bic.w	r2, r2, #16
2400bd40:	621a      	str	r2, [r3, #32]
  TIMx->CCER |= (uint32_t)(ChannelState << (Channel & 0x1FU)); /* 0x1FU = 31 bits max shift */
2400bd42:	6a1a      	ldr	r2, [r3, #32]
2400bd44:	f042 0210 	orr.w	r2, r2, #16
2400bd48:	621a      	str	r2, [r3, #32]
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
2400bd4a:	68da      	ldr	r2, [r3, #12]
2400bd4c:	f042 0202 	orr.w	r2, r2, #2
2400bd50:	60da      	str	r2, [r3, #12]
2400bd52:	e019      	b.n	2400bd88 <HAL_TIM_Encoder_Start_IT+0x66>
  TIMx->CCER &= ~tmp;
2400bd54:	6a1a      	ldr	r2, [r3, #32]
2400bd56:	f022 0201 	bic.w	r2, r2, #1
2400bd5a:	621a      	str	r2, [r3, #32]
  TIMx->CCER |= (uint32_t)(ChannelState << (Channel & 0x1FU)); /* 0x1FU = 31 bits max shift */
2400bd5c:	6a1a      	ldr	r2, [r3, #32]
2400bd5e:	f042 0201 	orr.w	r2, r2, #1
2400bd62:	621a      	str	r2, [r3, #32]
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
2400bd64:	68da      	ldr	r2, [r3, #12]
2400bd66:	f042 0202 	orr.w	r2, r2, #2
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
2400bd6a:	60da      	str	r2, [r3, #12]
}
2400bd6c:	2000      	movs	r0, #0
  __HAL_TIM_ENABLE(htim);
2400bd6e:	681a      	ldr	r2, [r3, #0]
2400bd70:	f042 0201 	orr.w	r2, r2, #1
2400bd74:	601a      	str	r2, [r3, #0]
}
2400bd76:	4770      	bx	lr
  TIMx->CCER &= ~tmp;
2400bd78:	6a1a      	ldr	r2, [r3, #32]
2400bd7a:	f022 0210 	bic.w	r2, r2, #16
2400bd7e:	621a      	str	r2, [r3, #32]
  TIMx->CCER |= (uint32_t)(ChannelState << (Channel & 0x1FU)); /* 0x1FU = 31 bits max shift */
2400bd80:	6a1a      	ldr	r2, [r3, #32]
2400bd82:	f042 0210 	orr.w	r2, r2, #16
2400bd86:	621a      	str	r2, [r3, #32]
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
2400bd88:	68da      	ldr	r2, [r3, #12]
2400bd8a:	f042 0204 	orr.w	r2, r2, #4
2400bd8e:	e7ec      	b.n	2400bd6a <HAL_TIM_Encoder_Start_IT+0x48>

2400bd90 <HAL_TIM_Encoder_Stop_IT>:
    TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
2400bd90:	6803      	ldr	r3, [r0, #0]
  TIMx->CCER &= ~tmp;
2400bd92:	6a1a      	ldr	r2, [r3, #32]
  if (Channel == TIM_CHANNEL_1)
2400bd94:	b9d9      	cbnz	r1, 2400bdce <HAL_TIM_Encoder_Stop_IT+0x3e>
  TIMx->CCER &= ~tmp;
2400bd96:	f022 0201 	bic.w	r2, r2, #1
2400bd9a:	621a      	str	r2, [r3, #32]
  TIMx->CCER |= (uint32_t)(ChannelState << (Channel & 0x1FU)); /* 0x1FU = 31 bits max shift */
2400bd9c:	6a1a      	ldr	r2, [r3, #32]
2400bd9e:	621a      	str	r2, [r3, #32]
    __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
2400bda0:	68da      	ldr	r2, [r3, #12]
2400bda2:	f022 0202 	bic.w	r2, r2, #2
    __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
2400bda6:	60da      	str	r2, [r3, #12]
  __HAL_TIM_DISABLE(htim);
2400bda8:	f241 1211 	movw	r2, #4369	@ 0x1111
2400bdac:	6a19      	ldr	r1, [r3, #32]
2400bdae:	4211      	tst	r1, r2
2400bdb0:	d108      	bne.n	2400bdc4 <HAL_TIM_Encoder_Stop_IT+0x34>
2400bdb2:	6a19      	ldr	r1, [r3, #32]
2400bdb4:	f240 4244 	movw	r2, #1092	@ 0x444
2400bdb8:	4211      	tst	r1, r2
2400bdba:	d103      	bne.n	2400bdc4 <HAL_TIM_Encoder_Stop_IT+0x34>
2400bdbc:	681a      	ldr	r2, [r3, #0]
2400bdbe:	f022 0201 	bic.w	r2, r2, #1
2400bdc2:	601a      	str	r2, [r3, #0]
  htim->State = HAL_TIM_STATE_READY;
2400bdc4:	2301      	movs	r3, #1
2400bdc6:	f880 303d 	strb.w	r3, [r0, #61]	@ 0x3d
}
2400bdca:	2000      	movs	r0, #0
2400bdcc:	4770      	bx	lr
  else if (Channel == TIM_CHANNEL_2)
2400bdce:	2904      	cmp	r1, #4
2400bdd0:	d108      	bne.n	2400bde4 <HAL_TIM_Encoder_Stop_IT+0x54>
  TIMx->CCER &= ~tmp;
2400bdd2:	f022 0210 	bic.w	r2, r2, #16
2400bdd6:	621a      	str	r2, [r3, #32]
  TIMx->CCER |= (uint32_t)(ChannelState << (Channel & 0x1FU)); /* 0x1FU = 31 bits max shift */
2400bdd8:	6a1a      	ldr	r2, [r3, #32]
2400bdda:	621a      	str	r2, [r3, #32]
    __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
2400bddc:	68da      	ldr	r2, [r3, #12]
2400bdde:	f022 0204 	bic.w	r2, r2, #4
2400bde2:	e7e0      	b.n	2400bda6 <HAL_TIM_Encoder_Stop_IT+0x16>
  TIMx->CCER &= ~tmp;
2400bde4:	f022 0201 	bic.w	r2, r2, #1
2400bde8:	621a      	str	r2, [r3, #32]
  TIMx->CCER |= (uint32_t)(ChannelState << (Channel & 0x1FU)); /* 0x1FU = 31 bits max shift */
2400bdea:	6a1a      	ldr	r2, [r3, #32]
2400bdec:	621a      	str	r2, [r3, #32]
  TIMx->CCER &= ~tmp;
2400bdee:	6a1a      	ldr	r2, [r3, #32]
2400bdf0:	f022 0210 	bic.w	r2, r2, #16
2400bdf4:	621a      	str	r2, [r3, #32]
  TIMx->CCER |= (uint32_t)(ChannelState << (Channel & 0x1FU)); /* 0x1FU = 31 bits max shift */
2400bdf6:	6a1a      	ldr	r2, [r3, #32]
2400bdf8:	621a      	str	r2, [r3, #32]
    __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
2400bdfa:	68da      	ldr	r2, [r3, #12]
2400bdfc:	f022 0202 	bic.w	r2, r2, #2
2400be00:	60da      	str	r2, [r3, #12]
2400be02:	e7eb      	b.n	2400bddc <HAL_TIM_Encoder_Stop_IT+0x4c>

2400be04 <HAL_TIM_Encoder_Start_DMA>:
{
2400be04:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
2400be08:	461d      	mov	r5, r3
  if (htim->State == HAL_TIM_STATE_BUSY)
2400be0a:	f890 303d 	ldrb.w	r3, [r0, #61]	@ 0x3d
{
2400be0e:	4604      	mov	r4, r0
2400be10:	f8bd 6020 	ldrh.w	r6, [sp, #32]
  if (htim->State == HAL_TIM_STATE_BUSY)
2400be14:	2b02      	cmp	r3, #2
2400be16:	b2d8      	uxtb	r0, r3
2400be18:	d007      	beq.n	2400be2a <HAL_TIM_Encoder_Start_DMA+0x26>
  else if (htim->State == HAL_TIM_STATE_READY)
2400be1a:	f894 303d 	ldrb.w	r3, [r4, #61]	@ 0x3d
2400be1e:	2b01      	cmp	r3, #1
2400be20:	d108      	bne.n	2400be34 <HAL_TIM_Encoder_Start_DMA+0x30>
    if ((((pData1 == NULL) || (pData2 == NULL))) && (Length > 0U))
2400be22:	b102      	cbz	r2, 2400be26 <HAL_TIM_Encoder_Start_DMA+0x22>
2400be24:	b91d      	cbnz	r5, 2400be2e <HAL_TIM_Encoder_Start_DMA+0x2a>
2400be26:	b116      	cbz	r6, 2400be2e <HAL_TIM_Encoder_Start_DMA+0x2a>
      return HAL_ERROR;
2400be28:	2001      	movs	r0, #1
}
2400be2a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      htim->State = HAL_TIM_STATE_BUSY;
2400be2e:	2302      	movs	r3, #2
2400be30:	f884 303d 	strb.w	r3, [r4, #61]	@ 0x3d
  switch (Channel)
2400be34:	2904      	cmp	r1, #4
2400be36:	d024      	beq.n	2400be82 <HAL_TIM_Encoder_Start_DMA+0x7e>
2400be38:	293c      	cmp	r1, #60	@ 0x3c
2400be3a:	d042      	beq.n	2400bec2 <HAL_TIM_Encoder_Start_DMA+0xbe>
2400be3c:	b109      	cbz	r1, 2400be42 <HAL_TIM_Encoder_Start_DMA+0x3e>
{
2400be3e:	2000      	movs	r0, #0
2400be40:	e7f3      	b.n	2400be2a <HAL_TIM_Encoder_Start_DMA+0x26>
      htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
2400be42:	6a60      	ldr	r0, [r4, #36]	@ 0x24
2400be44:	4b3d      	ldr	r3, [pc, #244]	@ (2400bf3c <HAL_TIM_Encoder_Start_DMA+0x138>)
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData1, Length) != HAL_OK)
2400be46:	6821      	ldr	r1, [r4, #0]
      htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
2400be48:	63c3      	str	r3, [r0, #60]	@ 0x3c
      htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
2400be4a:	4b3d      	ldr	r3, [pc, #244]	@ (2400bf40 <HAL_TIM_Encoder_Start_DMA+0x13c>)
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData1, Length) != HAL_OK)
2400be4c:	3134      	adds	r1, #52	@ 0x34
      htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
2400be4e:	6403      	str	r3, [r0, #64]	@ 0x40
      htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
2400be50:	4b3c      	ldr	r3, [pc, #240]	@ (2400bf44 <HAL_TIM_Encoder_Start_DMA+0x140>)
2400be52:	64c3      	str	r3, [r0, #76]	@ 0x4c
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData1, Length) != HAL_OK)
2400be54:	4633      	mov	r3, r6
2400be56:	f7f5 fdc3 	bl	240019e0 <HAL_DMA_Start_IT>
2400be5a:	2800      	cmp	r0, #0
2400be5c:	d1e4      	bne.n	2400be28 <HAL_TIM_Encoder_Start_DMA+0x24>
      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
2400be5e:	6823      	ldr	r3, [r4, #0]
2400be60:	68da      	ldr	r2, [r3, #12]
2400be62:	f442 7200 	orr.w	r2, r2, #512	@ 0x200
2400be66:	60da      	str	r2, [r3, #12]
      __HAL_TIM_ENABLE(htim);
2400be68:	681a      	ldr	r2, [r3, #0]
2400be6a:	f042 0201 	orr.w	r2, r2, #1
2400be6e:	601a      	str	r2, [r3, #0]
  TIMx->CCER &= ~tmp;
2400be70:	6a1a      	ldr	r2, [r3, #32]
2400be72:	f022 0201 	bic.w	r2, r2, #1
2400be76:	621a      	str	r2, [r3, #32]
  TIMx->CCER |= (uint32_t)(ChannelState << (Channel & 0x1FU)); /* 0x1FU = 31 bits max shift */
2400be78:	6a1a      	ldr	r2, [r3, #32]
2400be7a:	f042 0201 	orr.w	r2, r2, #1
2400be7e:	621a      	str	r2, [r3, #32]
}
2400be80:	e7dd      	b.n	2400be3e <HAL_TIM_Encoder_Start_DMA+0x3a>
      htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;
2400be82:	6aa0      	ldr	r0, [r4, #40]	@ 0x28
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData2, Length) != HAL_OK)
2400be84:	462a      	mov	r2, r5
      htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;
2400be86:	4b2d      	ldr	r3, [pc, #180]	@ (2400bf3c <HAL_TIM_Encoder_Start_DMA+0x138>)
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData2, Length) != HAL_OK)
2400be88:	6821      	ldr	r1, [r4, #0]
      htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;
2400be8a:	63c3      	str	r3, [r0, #60]	@ 0x3c
      htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
2400be8c:	4b2c      	ldr	r3, [pc, #176]	@ (2400bf40 <HAL_TIM_Encoder_Start_DMA+0x13c>)
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData2, Length) != HAL_OK)
2400be8e:	3138      	adds	r1, #56	@ 0x38
      htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
2400be90:	6403      	str	r3, [r0, #64]	@ 0x40
      htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError;
2400be92:	4b2c      	ldr	r3, [pc, #176]	@ (2400bf44 <HAL_TIM_Encoder_Start_DMA+0x140>)
2400be94:	64c3      	str	r3, [r0, #76]	@ 0x4c
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData2, Length) != HAL_OK)
2400be96:	4633      	mov	r3, r6
2400be98:	f7f5 fda2 	bl	240019e0 <HAL_DMA_Start_IT>
2400be9c:	2800      	cmp	r0, #0
2400be9e:	d1c3      	bne.n	2400be28 <HAL_TIM_Encoder_Start_DMA+0x24>
      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
2400bea0:	6823      	ldr	r3, [r4, #0]
2400bea2:	68da      	ldr	r2, [r3, #12]
2400bea4:	f442 6280 	orr.w	r2, r2, #1024	@ 0x400
2400bea8:	60da      	str	r2, [r3, #12]
      __HAL_TIM_ENABLE(htim);
2400beaa:	681a      	ldr	r2, [r3, #0]
2400beac:	f042 0201 	orr.w	r2, r2, #1
2400beb0:	601a      	str	r2, [r3, #0]
  TIMx->CCER &= ~tmp;
2400beb2:	6a1a      	ldr	r2, [r3, #32]
2400beb4:	f022 0210 	bic.w	r2, r2, #16
2400beb8:	621a      	str	r2, [r3, #32]
  TIMx->CCER |= (uint32_t)(ChannelState << (Channel & 0x1FU)); /* 0x1FU = 31 bits max shift */
2400beba:	6a1a      	ldr	r2, [r3, #32]
2400bebc:	f042 0210 	orr.w	r2, r2, #16
2400bec0:	e7dd      	b.n	2400be7e <HAL_TIM_Encoder_Start_DMA+0x7a>
      htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
2400bec2:	6a60      	ldr	r0, [r4, #36]	@ 0x24
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData1, Length) != HAL_OK)
2400bec4:	4633      	mov	r3, r6
      htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
2400bec6:	f8df 9074 	ldr.w	r9, [pc, #116]	@ 2400bf3c <HAL_TIM_Encoder_Start_DMA+0x138>
      htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
2400beca:	f8df 8074 	ldr.w	r8, [pc, #116]	@ 2400bf40 <HAL_TIM_Encoder_Start_DMA+0x13c>
      htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
2400bece:	4f1d      	ldr	r7, [pc, #116]	@ (2400bf44 <HAL_TIM_Encoder_Start_DMA+0x140>)
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData1, Length) != HAL_OK)
2400bed0:	6821      	ldr	r1, [r4, #0]
      htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
2400bed2:	f8c0 903c 	str.w	r9, [r0, #60]	@ 0x3c
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData1, Length) != HAL_OK)
2400bed6:	3134      	adds	r1, #52	@ 0x34
      htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
2400bed8:	f8c0 8040 	str.w	r8, [r0, #64]	@ 0x40
      htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
2400bedc:	64c7      	str	r7, [r0, #76]	@ 0x4c
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData1, Length) != HAL_OK)
2400bede:	f7f5 fd7f 	bl	240019e0 <HAL_DMA_Start_IT>
2400bee2:	2800      	cmp	r0, #0
2400bee4:	d1a0      	bne.n	2400be28 <HAL_TIM_Encoder_Start_DMA+0x24>
      htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;
2400bee6:	6aa0      	ldr	r0, [r4, #40]	@ 0x28
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData2, Length) != HAL_OK)
2400bee8:	4633      	mov	r3, r6
2400beea:	6821      	ldr	r1, [r4, #0]
2400beec:	462a      	mov	r2, r5
      htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
2400beee:	64c7      	str	r7, [r0, #76]	@ 0x4c
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData2, Length) != HAL_OK)
2400bef0:	3138      	adds	r1, #56	@ 0x38
      htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
2400bef2:	e9c0 980f 	strd	r9, r8, [r0, #60]	@ 0x3c
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData2, Length) != HAL_OK)
2400bef6:	f7f5 fd73 	bl	240019e0 <HAL_DMA_Start_IT>
2400befa:	2800      	cmp	r0, #0
2400befc:	d194      	bne.n	2400be28 <HAL_TIM_Encoder_Start_DMA+0x24>
      __HAL_TIM_ENABLE(htim);
2400befe:	6823      	ldr	r3, [r4, #0]
2400bf00:	681a      	ldr	r2, [r3, #0]
2400bf02:	f042 0201 	orr.w	r2, r2, #1
2400bf06:	601a      	str	r2, [r3, #0]
  TIMx->CCER &= ~tmp;
2400bf08:	6a1a      	ldr	r2, [r3, #32]
2400bf0a:	f022 0201 	bic.w	r2, r2, #1
2400bf0e:	621a      	str	r2, [r3, #32]
  TIMx->CCER |= (uint32_t)(ChannelState << (Channel & 0x1FU)); /* 0x1FU = 31 bits max shift */
2400bf10:	6a1a      	ldr	r2, [r3, #32]
2400bf12:	f042 0201 	orr.w	r2, r2, #1
2400bf16:	621a      	str	r2, [r3, #32]
  TIMx->CCER &= ~tmp;
2400bf18:	6a1a      	ldr	r2, [r3, #32]
2400bf1a:	f022 0210 	bic.w	r2, r2, #16
2400bf1e:	621a      	str	r2, [r3, #32]
  TIMx->CCER |= (uint32_t)(ChannelState << (Channel & 0x1FU)); /* 0x1FU = 31 bits max shift */
2400bf20:	6a1a      	ldr	r2, [r3, #32]
2400bf22:	f042 0210 	orr.w	r2, r2, #16
2400bf26:	621a      	str	r2, [r3, #32]
      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
2400bf28:	68da      	ldr	r2, [r3, #12]
2400bf2a:	f442 7200 	orr.w	r2, r2, #512	@ 0x200
2400bf2e:	60da      	str	r2, [r3, #12]
      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
2400bf30:	68da      	ldr	r2, [r3, #12]
2400bf32:	f442 6280 	orr.w	r2, r2, #1024	@ 0x400
2400bf36:	60da      	str	r2, [r3, #12]
      break;
2400bf38:	e781      	b.n	2400be3e <HAL_TIM_Encoder_Start_DMA+0x3a>
2400bf3a:	bf00      	nop
2400bf3c:	2400c2e3 	.word	0x2400c2e3
2400bf40:	2400c321 	.word	0x2400c321
2400bf44:	2400c55f 	.word	0x2400c55f

2400bf48 <HAL_TIM_Encoder_Stop_DMA>:
    TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
2400bf48:	6803      	ldr	r3, [r0, #0]
{
2400bf4a:	b510      	push	{r4, lr}
  TIMx->CCER &= ~tmp;
2400bf4c:	6a1a      	ldr	r2, [r3, #32]
{
2400bf4e:	4604      	mov	r4, r0
  if (Channel == TIM_CHANNEL_1)
2400bf50:	b9f9      	cbnz	r1, 2400bf92 <HAL_TIM_Encoder_Stop_DMA+0x4a>
  TIMx->CCER &= ~tmp;
2400bf52:	f022 0201 	bic.w	r2, r2, #1
    (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);
2400bf56:	6a40      	ldr	r0, [r0, #36]	@ 0x24
  TIMx->CCER &= ~tmp;
2400bf58:	621a      	str	r2, [r3, #32]
  TIMx->CCER |= (uint32_t)(ChannelState << (Channel & 0x1FU)); /* 0x1FU = 31 bits max shift */
2400bf5a:	6a1a      	ldr	r2, [r3, #32]
2400bf5c:	621a      	str	r2, [r3, #32]
    __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
2400bf5e:	68da      	ldr	r2, [r3, #12]
2400bf60:	f422 7200 	bic.w	r2, r2, #512	@ 0x200
2400bf64:	60da      	str	r2, [r3, #12]
    (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);
2400bf66:	f7f6 f801 	bl	24001f6c <HAL_DMA_Abort_IT>
  __HAL_TIM_DISABLE(htim);
2400bf6a:	6823      	ldr	r3, [r4, #0]
2400bf6c:	f241 1211 	movw	r2, #4369	@ 0x1111
2400bf70:	6a19      	ldr	r1, [r3, #32]
2400bf72:	4211      	tst	r1, r2
2400bf74:	d108      	bne.n	2400bf88 <HAL_TIM_Encoder_Stop_DMA+0x40>
2400bf76:	6a19      	ldr	r1, [r3, #32]
2400bf78:	f240 4244 	movw	r2, #1092	@ 0x444
2400bf7c:	4211      	tst	r1, r2
2400bf7e:	d103      	bne.n	2400bf88 <HAL_TIM_Encoder_Stop_DMA+0x40>
2400bf80:	681a      	ldr	r2, [r3, #0]
2400bf82:	f022 0201 	bic.w	r2, r2, #1
2400bf86:	601a      	str	r2, [r3, #0]
  htim->State = HAL_TIM_STATE_READY;
2400bf88:	2301      	movs	r3, #1
}
2400bf8a:	2000      	movs	r0, #0
  htim->State = HAL_TIM_STATE_READY;
2400bf8c:	f884 303d 	strb.w	r3, [r4, #61]	@ 0x3d
}
2400bf90:	bd10      	pop	{r4, pc}
  else if (Channel == TIM_CHANNEL_2)
2400bf92:	2904      	cmp	r1, #4
2400bf94:	d10a      	bne.n	2400bfac <HAL_TIM_Encoder_Stop_DMA+0x64>
  TIMx->CCER &= ~tmp;
2400bf96:	f022 0210 	bic.w	r2, r2, #16
2400bf9a:	621a      	str	r2, [r3, #32]
  TIMx->CCER |= (uint32_t)(ChannelState << (Channel & 0x1FU)); /* 0x1FU = 31 bits max shift */
2400bf9c:	6a1a      	ldr	r2, [r3, #32]
2400bf9e:	621a      	str	r2, [r3, #32]
    __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
2400bfa0:	68da      	ldr	r2, [r3, #12]
2400bfa2:	f422 6280 	bic.w	r2, r2, #1024	@ 0x400
2400bfa6:	60da      	str	r2, [r3, #12]
    (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);
2400bfa8:	6aa0      	ldr	r0, [r4, #40]	@ 0x28
2400bfaa:	e7dc      	b.n	2400bf66 <HAL_TIM_Encoder_Stop_DMA+0x1e>
  TIMx->CCER &= ~tmp;
2400bfac:	f022 0201 	bic.w	r2, r2, #1
    (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);
2400bfb0:	6a40      	ldr	r0, [r0, #36]	@ 0x24
  TIMx->CCER &= ~tmp;
2400bfb2:	621a      	str	r2, [r3, #32]
  TIMx->CCER |= (uint32_t)(ChannelState << (Channel & 0x1FU)); /* 0x1FU = 31 bits max shift */
2400bfb4:	6a1a      	ldr	r2, [r3, #32]
2400bfb6:	621a      	str	r2, [r3, #32]
  TIMx->CCER &= ~tmp;
2400bfb8:	6a1a      	ldr	r2, [r3, #32]
2400bfba:	f022 0210 	bic.w	r2, r2, #16
2400bfbe:	621a      	str	r2, [r3, #32]
  TIMx->CCER |= (uint32_t)(ChannelState << (Channel & 0x1FU)); /* 0x1FU = 31 bits max shift */
2400bfc0:	6a1a      	ldr	r2, [r3, #32]
2400bfc2:	621a      	str	r2, [r3, #32]
    __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
2400bfc4:	68da      	ldr	r2, [r3, #12]
2400bfc6:	f422 7200 	bic.w	r2, r2, #512	@ 0x200
2400bfca:	60da      	str	r2, [r3, #12]
    __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
2400bfcc:	68da      	ldr	r2, [r3, #12]
2400bfce:	f422 6280 	bic.w	r2, r2, #1024	@ 0x400
2400bfd2:	60da      	str	r2, [r3, #12]
    (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);
2400bfd4:	f7f5 ffca 	bl	24001f6c <HAL_DMA_Abort_IT>
2400bfd8:	e7e6      	b.n	2400bfa8 <HAL_TIM_Encoder_Stop_DMA+0x60>

2400bfda <HAL_TIM_DMABurst_MultiWriteStart>:
{
2400bfda:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
2400bfdc:	4615      	mov	r5, r2
  if (htim->State == HAL_TIM_STATE_BUSY)
2400bfde:	f890 203d 	ldrb.w	r2, [r0, #61]	@ 0x3d
{
2400bfe2:	4604      	mov	r4, r0
2400bfe4:	460f      	mov	r7, r1
  if (htim->State == HAL_TIM_STATE_BUSY)
2400bfe6:	2a02      	cmp	r2, #2
{
2400bfe8:	4619      	mov	r1, r3
  if (htim->State == HAL_TIM_STATE_BUSY)
2400bfea:	b2d0      	uxtb	r0, r2
{
2400bfec:	e9dd 6306 	ldrd	r6, r3, [sp, #24]
  if (htim->State == HAL_TIM_STATE_BUSY)
2400bff0:	d006      	beq.n	2400c000 <HAL_TIM_DMABurst_MultiWriteStart+0x26>
  else if (htim->State == HAL_TIM_STATE_READY)
2400bff2:	f894 203d 	ldrb.w	r2, [r4, #61]	@ 0x3d
2400bff6:	2a01      	cmp	r2, #1
2400bff8:	d106      	bne.n	2400c008 <HAL_TIM_DMABurst_MultiWriteStart+0x2e>
    if ((BurstBuffer == NULL) && (BurstLength > 0U))
2400bffa:	b911      	cbnz	r1, 2400c002 <HAL_TIM_DMABurst_MultiWriteStart+0x28>
2400bffc:	b10e      	cbz	r6, 2400c002 <HAL_TIM_DMABurst_MultiWriteStart+0x28>
      return HAL_ERROR;
2400bffe:	2001      	movs	r0, #1
}
2400c000:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      htim->State = HAL_TIM_STATE_BUSY;
2400c002:	2202      	movs	r2, #2
2400c004:	f884 203d 	strb.w	r2, [r4, #61]	@ 0x3d
  switch (BurstRequestSrc)
2400c008:	f5b5 6f00 	cmp.w	r5, #2048	@ 0x800
                           (uint32_t)&htim->Instance->DMAR, DataLength) != HAL_OK)
2400c00c:	6822      	ldr	r2, [r4, #0]
  switch (BurstRequestSrc)
2400c00e:	d03c      	beq.n	2400c08a <HAL_TIM_DMABurst_MultiWriteStart+0xb0>
2400c010:	d813      	bhi.n	2400c03a <HAL_TIM_DMABurst_MultiWriteStart+0x60>
2400c012:	f5b5 7f00 	cmp.w	r5, #512	@ 0x200
2400c016:	d02e      	beq.n	2400c076 <HAL_TIM_DMABurst_MultiWriteStart+0x9c>
2400c018:	f5b5 6f80 	cmp.w	r5, #1024	@ 0x400
2400c01c:	d033      	beq.n	2400c086 <HAL_TIM_DMABurst_MultiWriteStart+0xac>
2400c01e:	f5b5 7f80 	cmp.w	r5, #256	@ 0x100
2400c022:	d015      	beq.n	2400c050 <HAL_TIM_DMABurst_MultiWriteStart+0x76>
  htim->Instance->DCR = (BurstBaseAddress | BurstLength);
2400c024:	6823      	ldr	r3, [r4, #0]
2400c026:	433e      	orrs	r6, r7
  return HAL_OK;
2400c028:	2000      	movs	r0, #0
  htim->Instance->DCR = (BurstBaseAddress | BurstLength);
2400c02a:	649e      	str	r6, [r3, #72]	@ 0x48
  __HAL_TIM_ENABLE_DMA(htim, BurstRequestSrc);
2400c02c:	68da      	ldr	r2, [r3, #12]
2400c02e:	432a      	orrs	r2, r5
2400c030:	60da      	str	r2, [r3, #12]
  htim->State = HAL_TIM_STATE_READY;
2400c032:	2301      	movs	r3, #1
2400c034:	f884 303d 	strb.w	r3, [r4, #61]	@ 0x3d
  return HAL_OK;
2400c038:	e7e2      	b.n	2400c000 <HAL_TIM_DMABurst_MultiWriteStart+0x26>
  switch (BurstRequestSrc)
2400c03a:	f5b5 5f00 	cmp.w	r5, #8192	@ 0x2000
2400c03e:	d026      	beq.n	2400c08e <HAL_TIM_DMABurst_MultiWriteStart+0xb4>
2400c040:	f5b5 4f80 	cmp.w	r5, #16384	@ 0x4000
2400c044:	d02b      	beq.n	2400c09e <HAL_TIM_DMABurst_MultiWriteStart+0xc4>
2400c046:	f5b5 5f80 	cmp.w	r5, #4096	@ 0x1000
2400c04a:	d1eb      	bne.n	2400c024 <HAL_TIM_DMABurst_MultiWriteStart+0x4a>
      htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMADelayPulseCplt;
2400c04c:	6b20      	ldr	r0, [r4, #48]	@ 0x30
2400c04e:	e013      	b.n	2400c078 <HAL_TIM_DMABurst_MultiWriteStart+0x9e>
      htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
2400c050:	f8df c05c 	ldr.w	ip, [pc, #92]	@ 2400c0b0 <HAL_TIM_DMABurst_MultiWriteStart+0xd6>
2400c054:	6a20      	ldr	r0, [r4, #32]
2400c056:	f8c0 c03c 	str.w	ip, [r0, #60]	@ 0x3c
      htim->hdma[TIM_DMA_ID_UPDATE]->XferHalfCpltCallback = TIM_DMAPeriodElapsedHalfCplt;
2400c05a:	f8df c058 	ldr.w	ip, [pc, #88]	@ 2400c0b4 <HAL_TIM_DMABurst_MultiWriteStart+0xda>
      htim->hdma[TIM_DMA_ID_TRIGGER]->XferHalfCpltCallback = TIM_DMATriggerHalfCplt;
2400c05e:	f8c0 c040 	str.w	ip, [r0, #64]	@ 0x40
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_TRIGGER], (uint32_t)BurstBuffer,
2400c062:	324c      	adds	r2, #76	@ 0x4c
      htim->hdma[TIM_DMA_ID_TRIGGER]->XferErrorCallback = TIM_DMAError ;
2400c064:	f8df c050 	ldr.w	ip, [pc, #80]	@ 2400c0b8 <HAL_TIM_DMABurst_MultiWriteStart+0xde>
2400c068:	f8c0 c04c 	str.w	ip, [r0, #76]	@ 0x4c
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_TRIGGER], (uint32_t)BurstBuffer,
2400c06c:	f7f5 fcb8 	bl	240019e0 <HAL_DMA_Start_IT>
2400c070:	2800      	cmp	r0, #0
2400c072:	d0d7      	beq.n	2400c024 <HAL_TIM_DMABurst_MultiWriteStart+0x4a>
2400c074:	e7c3      	b.n	2400bffe <HAL_TIM_DMABurst_MultiWriteStart+0x24>
      htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseCplt;
2400c076:	6a60      	ldr	r0, [r4, #36]	@ 0x24
      htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;
2400c078:	f8df c040 	ldr.w	ip, [pc, #64]	@ 2400c0bc <HAL_TIM_DMABurst_MultiWriteStart+0xe2>
2400c07c:	f8c0 c03c 	str.w	ip, [r0, #60]	@ 0x3c
      htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
2400c080:	f8df c03c 	ldr.w	ip, [pc, #60]	@ 2400c0c0 <HAL_TIM_DMABurst_MultiWriteStart+0xe6>
2400c084:	e7eb      	b.n	2400c05e <HAL_TIM_DMABurst_MultiWriteStart+0x84>
      htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;
2400c086:	6aa0      	ldr	r0, [r4, #40]	@ 0x28
2400c088:	e7f6      	b.n	2400c078 <HAL_TIM_DMABurst_MultiWriteStart+0x9e>
      htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseCplt;
2400c08a:	6ae0      	ldr	r0, [r4, #44]	@ 0x2c
2400c08c:	e7f4      	b.n	2400c078 <HAL_TIM_DMABurst_MultiWriteStart+0x9e>
      htim->hdma[TIM_DMA_ID_COMMUTATION]->XferCpltCallback =  TIMEx_DMACommutationCplt;
2400c08e:	f8df c034 	ldr.w	ip, [pc, #52]	@ 2400c0c4 <HAL_TIM_DMABurst_MultiWriteStart+0xea>
2400c092:	6b60      	ldr	r0, [r4, #52]	@ 0x34
2400c094:	f8c0 c03c 	str.w	ip, [r0, #60]	@ 0x3c
      htim->hdma[TIM_DMA_ID_COMMUTATION]->XferHalfCpltCallback =  TIMEx_DMACommutationHalfCplt;
2400c098:	f8df c02c 	ldr.w	ip, [pc, #44]	@ 2400c0c8 <HAL_TIM_DMABurst_MultiWriteStart+0xee>
2400c09c:	e7df      	b.n	2400c05e <HAL_TIM_DMABurst_MultiWriteStart+0x84>
      htim->hdma[TIM_DMA_ID_TRIGGER]->XferCpltCallback = TIM_DMATriggerCplt;
2400c09e:	f8df c02c 	ldr.w	ip, [pc, #44]	@ 2400c0cc <HAL_TIM_DMABurst_MultiWriteStart+0xf2>
2400c0a2:	6ba0      	ldr	r0, [r4, #56]	@ 0x38
2400c0a4:	f8c0 c03c 	str.w	ip, [r0, #60]	@ 0x3c
      htim->hdma[TIM_DMA_ID_TRIGGER]->XferHalfCpltCallback = TIM_DMATriggerHalfCplt;
2400c0a8:	f8df c024 	ldr.w	ip, [pc, #36]	@ 2400c0d0 <HAL_TIM_DMABurst_MultiWriteStart+0xf6>
2400c0ac:	e7d7      	b.n	2400c05e <HAL_TIM_DMABurst_MultiWriteStart+0x84>
2400c0ae:	bf00      	nop
2400c0b0:	2400c2bd 	.word	0x2400c2bd
2400c0b4:	2400c2cf 	.word	0x2400c2cf
2400c0b8:	2400c55f 	.word	0x2400c55f
2400c0bc:	2400c35f 	.word	0x2400c35f
2400c0c0:	2400c39d 	.word	0x2400c39d
2400c0c4:	2400e115 	.word	0x2400e115
2400c0c8:	2400e127 	.word	0x2400e127
2400c0cc:	2400c53b 	.word	0x2400c53b
2400c0d0:	2400c54d 	.word	0x2400c54d

2400c0d4 <HAL_TIM_DMABurst_WriteStart>:
{
2400c0d4:	b537      	push	{r0, r1, r2, r4, r5, lr}
2400c0d6:	9d06      	ldr	r5, [sp, #24]
                                          ((BurstLength) >> 8U) + 1U);
2400c0d8:	0a2c      	lsrs	r4, r5, #8
  return HAL_TIM_DMABurst_MultiWriteStart(htim, BurstBaseAddress, BurstRequestSrc, BurstBuffer, BurstLength,
2400c0da:	3401      	adds	r4, #1
2400c0dc:	e9cd 5400 	strd	r5, r4, [sp]
2400c0e0:	f7ff ff7b 	bl	2400bfda <HAL_TIM_DMABurst_MultiWriteStart>
}
2400c0e4:	b003      	add	sp, #12
2400c0e6:	bd30      	pop	{r4, r5, pc}

2400c0e8 <HAL_TIM_DMABurst_WriteStop>:
  switch (BurstRequestSrc)
2400c0e8:	f5b1 6f00 	cmp.w	r1, #2048	@ 0x800
{
2400c0ec:	b538      	push	{r3, r4, r5, lr}
2400c0ee:	4605      	mov	r5, r0
2400c0f0:	460c      	mov	r4, r1
  switch (BurstRequestSrc)
2400c0f2:	d025      	beq.n	2400c140 <HAL_TIM_DMABurst_WriteStop+0x58>
2400c0f4:	d80f      	bhi.n	2400c116 <HAL_TIM_DMABurst_WriteStop+0x2e>
2400c0f6:	f5b1 7f00 	cmp.w	r1, #512	@ 0x200
2400c0fa:	d01d      	beq.n	2400c138 <HAL_TIM_DMABurst_WriteStop+0x50>
2400c0fc:	f5b1 6f80 	cmp.w	r1, #1024	@ 0x400
2400c100:	d01c      	beq.n	2400c13c <HAL_TIM_DMABurst_WriteStop+0x54>
2400c102:	f5b1 7f80 	cmp.w	r1, #256	@ 0x100
2400c106:	d011      	beq.n	2400c12c <HAL_TIM_DMABurst_WriteStop+0x44>
    __HAL_TIM_DISABLE_DMA(htim, BurstRequestSrc);
2400c108:	682a      	ldr	r2, [r5, #0]
2400c10a:	2000      	movs	r0, #0
2400c10c:	68d3      	ldr	r3, [r2, #12]
2400c10e:	ea23 0304 	bic.w	r3, r3, r4
2400c112:	60d3      	str	r3, [r2, #12]
2400c114:	e00f      	b.n	2400c136 <HAL_TIM_DMABurst_WriteStop+0x4e>
  switch (BurstRequestSrc)
2400c116:	f5b1 5f00 	cmp.w	r1, #8192	@ 0x2000
2400c11a:	d013      	beq.n	2400c144 <HAL_TIM_DMABurst_WriteStop+0x5c>
2400c11c:	f5b1 4f80 	cmp.w	r1, #16384	@ 0x4000
2400c120:	d012      	beq.n	2400c148 <HAL_TIM_DMABurst_WriteStop+0x60>
2400c122:	f5b1 5f80 	cmp.w	r1, #4096	@ 0x1000
2400c126:	d1ef      	bne.n	2400c108 <HAL_TIM_DMABurst_WriteStop+0x20>
      status = HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC4]);
2400c128:	6b00      	ldr	r0, [r0, #48]	@ 0x30
2400c12a:	e000      	b.n	2400c12e <HAL_TIM_DMABurst_WriteStop+0x46>
      status = HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_UPDATE]);
2400c12c:	6a00      	ldr	r0, [r0, #32]
      status = HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_TRIGGER]);
2400c12e:	f7f5 ff1d 	bl	24001f6c <HAL_DMA_Abort_IT>
  if (HAL_OK == status)
2400c132:	2800      	cmp	r0, #0
2400c134:	d0e8      	beq.n	2400c108 <HAL_TIM_DMABurst_WriteStop+0x20>
}
2400c136:	bd38      	pop	{r3, r4, r5, pc}
      status = HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);
2400c138:	6a40      	ldr	r0, [r0, #36]	@ 0x24
2400c13a:	e7f8      	b.n	2400c12e <HAL_TIM_DMABurst_WriteStop+0x46>
      status = HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);
2400c13c:	6a80      	ldr	r0, [r0, #40]	@ 0x28
2400c13e:	e7f6      	b.n	2400c12e <HAL_TIM_DMABurst_WriteStop+0x46>
      status =  HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC3]);
2400c140:	6ac0      	ldr	r0, [r0, #44]	@ 0x2c
2400c142:	e7f4      	b.n	2400c12e <HAL_TIM_DMABurst_WriteStop+0x46>
      status = HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_COMMUTATION]);
2400c144:	6b40      	ldr	r0, [r0, #52]	@ 0x34
2400c146:	e7f2      	b.n	2400c12e <HAL_TIM_DMABurst_WriteStop+0x46>
      status = HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_TRIGGER]);
2400c148:	6b80      	ldr	r0, [r0, #56]	@ 0x38
2400c14a:	e7f0      	b.n	2400c12e <HAL_TIM_DMABurst_WriteStop+0x46>

2400c14c <HAL_TIM_DMABurst_MultiReadStart>:
{
2400c14c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
2400c14e:	460f      	mov	r7, r1
  if (htim->State == HAL_TIM_STATE_BUSY)
2400c150:	f890 103d 	ldrb.w	r1, [r0, #61]	@ 0x3d
{
2400c154:	4604      	mov	r4, r0
2400c156:	4615      	mov	r5, r2
  if (htim->State == HAL_TIM_STATE_BUSY)
2400c158:	2902      	cmp	r1, #2
{
2400c15a:	461a      	mov	r2, r3
  if (htim->State == HAL_TIM_STATE_BUSY)
2400c15c:	b2c8      	uxtb	r0, r1
{
2400c15e:	e9dd 6306 	ldrd	r6, r3, [sp, #24]
  if (htim->State == HAL_TIM_STATE_BUSY)
2400c162:	d006      	beq.n	2400c172 <HAL_TIM_DMABurst_MultiReadStart+0x26>
  else if (htim->State == HAL_TIM_STATE_READY)
2400c164:	f894 103d 	ldrb.w	r1, [r4, #61]	@ 0x3d
2400c168:	2901      	cmp	r1, #1
2400c16a:	d106      	bne.n	2400c17a <HAL_TIM_DMABurst_MultiReadStart+0x2e>
    if ((BurstBuffer == NULL) && (BurstLength > 0U))
2400c16c:	b912      	cbnz	r2, 2400c174 <HAL_TIM_DMABurst_MultiReadStart+0x28>
2400c16e:	b10e      	cbz	r6, 2400c174 <HAL_TIM_DMABurst_MultiReadStart+0x28>
      return HAL_ERROR;
2400c170:	2001      	movs	r0, #1
}
2400c172:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      htim->State = HAL_TIM_STATE_BUSY;
2400c174:	2102      	movs	r1, #2
2400c176:	f884 103d 	strb.w	r1, [r4, #61]	@ 0x3d
  switch (BurstRequestSrc)
2400c17a:	f5b5 6f00 	cmp.w	r5, #2048	@ 0x800
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer,
2400c17e:	6821      	ldr	r1, [r4, #0]
  switch (BurstRequestSrc)
2400c180:	d03c      	beq.n	2400c1fc <HAL_TIM_DMABurst_MultiReadStart+0xb0>
2400c182:	d813      	bhi.n	2400c1ac <HAL_TIM_DMABurst_MultiReadStart+0x60>
2400c184:	f5b5 7f00 	cmp.w	r5, #512	@ 0x200
2400c188:	d02e      	beq.n	2400c1e8 <HAL_TIM_DMABurst_MultiReadStart+0x9c>
2400c18a:	f5b5 6f80 	cmp.w	r5, #1024	@ 0x400
2400c18e:	d033      	beq.n	2400c1f8 <HAL_TIM_DMABurst_MultiReadStart+0xac>
2400c190:	f5b5 7f80 	cmp.w	r5, #256	@ 0x100
2400c194:	d015      	beq.n	2400c1c2 <HAL_TIM_DMABurst_MultiReadStart+0x76>
  htim->Instance->DCR = (BurstBaseAddress | BurstLength);
2400c196:	6823      	ldr	r3, [r4, #0]
2400c198:	433e      	orrs	r6, r7
  return HAL_OK;
2400c19a:	2000      	movs	r0, #0
  htim->Instance->DCR = (BurstBaseAddress | BurstLength);
2400c19c:	649e      	str	r6, [r3, #72]	@ 0x48
  __HAL_TIM_ENABLE_DMA(htim, BurstRequestSrc);
2400c19e:	68da      	ldr	r2, [r3, #12]
2400c1a0:	432a      	orrs	r2, r5
2400c1a2:	60da      	str	r2, [r3, #12]
  htim->State = HAL_TIM_STATE_READY;
2400c1a4:	2301      	movs	r3, #1
2400c1a6:	f884 303d 	strb.w	r3, [r4, #61]	@ 0x3d
  return HAL_OK;
2400c1aa:	e7e2      	b.n	2400c172 <HAL_TIM_DMABurst_MultiReadStart+0x26>
  switch (BurstRequestSrc)
2400c1ac:	f5b5 5f00 	cmp.w	r5, #8192	@ 0x2000
2400c1b0:	d026      	beq.n	2400c200 <HAL_TIM_DMABurst_MultiReadStart+0xb4>
2400c1b2:	f5b5 4f80 	cmp.w	r5, #16384	@ 0x4000
2400c1b6:	d02b      	beq.n	2400c210 <HAL_TIM_DMABurst_MultiReadStart+0xc4>
2400c1b8:	f5b5 5f80 	cmp.w	r5, #4096	@ 0x1000
2400c1bc:	d1eb      	bne.n	2400c196 <HAL_TIM_DMABurst_MultiReadStart+0x4a>
      htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMACaptureCplt;
2400c1be:	6b20      	ldr	r0, [r4, #48]	@ 0x30
2400c1c0:	e013      	b.n	2400c1ea <HAL_TIM_DMABurst_MultiReadStart+0x9e>
      htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
2400c1c2:	f8df c05c 	ldr.w	ip, [pc, #92]	@ 2400c220 <HAL_TIM_DMABurst_MultiReadStart+0xd4>
2400c1c6:	6a20      	ldr	r0, [r4, #32]
2400c1c8:	f8c0 c03c 	str.w	ip, [r0, #60]	@ 0x3c
      htim->hdma[TIM_DMA_ID_UPDATE]->XferHalfCpltCallback = TIM_DMAPeriodElapsedHalfCplt;
2400c1cc:	f8df c054 	ldr.w	ip, [pc, #84]	@ 2400c224 <HAL_TIM_DMABurst_MultiReadStart+0xd8>
      htim->hdma[TIM_DMA_ID_TRIGGER]->XferHalfCpltCallback = TIM_DMATriggerHalfCplt;
2400c1d0:	f8c0 c040 	str.w	ip, [r0, #64]	@ 0x40
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_TRIGGER], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer,
2400c1d4:	314c      	adds	r1, #76	@ 0x4c
      htim->hdma[TIM_DMA_ID_TRIGGER]->XferErrorCallback = TIM_DMAError ;
2400c1d6:	f8df c050 	ldr.w	ip, [pc, #80]	@ 2400c228 <HAL_TIM_DMABurst_MultiReadStart+0xdc>
2400c1da:	f8c0 c04c 	str.w	ip, [r0, #76]	@ 0x4c
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_TRIGGER], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer,
2400c1de:	f7f5 fbff 	bl	240019e0 <HAL_DMA_Start_IT>
2400c1e2:	2800      	cmp	r0, #0
2400c1e4:	d0d7      	beq.n	2400c196 <HAL_TIM_DMABurst_MultiReadStart+0x4a>
2400c1e6:	e7c3      	b.n	2400c170 <HAL_TIM_DMABurst_MultiReadStart+0x24>
      htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
2400c1e8:	6a60      	ldr	r0, [r4, #36]	@ 0x24
      htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;
2400c1ea:	f8df c040 	ldr.w	ip, [pc, #64]	@ 2400c22c <HAL_TIM_DMABurst_MultiReadStart+0xe0>
2400c1ee:	f8c0 c03c 	str.w	ip, [r0, #60]	@ 0x3c
      htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
2400c1f2:	f8df c03c 	ldr.w	ip, [pc, #60]	@ 2400c230 <HAL_TIM_DMABurst_MultiReadStart+0xe4>
2400c1f6:	e7eb      	b.n	2400c1d0 <HAL_TIM_DMABurst_MultiReadStart+0x84>
      htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;
2400c1f8:	6aa0      	ldr	r0, [r4, #40]	@ 0x28
2400c1fa:	e7f6      	b.n	2400c1ea <HAL_TIM_DMABurst_MultiReadStart+0x9e>
      htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMACaptureCplt;
2400c1fc:	6ae0      	ldr	r0, [r4, #44]	@ 0x2c
2400c1fe:	e7f4      	b.n	2400c1ea <HAL_TIM_DMABurst_MultiReadStart+0x9e>
      htim->hdma[TIM_DMA_ID_COMMUTATION]->XferCpltCallback =  TIMEx_DMACommutationCplt;
2400c200:	f8df c030 	ldr.w	ip, [pc, #48]	@ 2400c234 <HAL_TIM_DMABurst_MultiReadStart+0xe8>
2400c204:	6b60      	ldr	r0, [r4, #52]	@ 0x34
2400c206:	f8c0 c03c 	str.w	ip, [r0, #60]	@ 0x3c
      htim->hdma[TIM_DMA_ID_COMMUTATION]->XferHalfCpltCallback =  TIMEx_DMACommutationHalfCplt;
2400c20a:	f8df c02c 	ldr.w	ip, [pc, #44]	@ 2400c238 <HAL_TIM_DMABurst_MultiReadStart+0xec>
2400c20e:	e7df      	b.n	2400c1d0 <HAL_TIM_DMABurst_MultiReadStart+0x84>
      htim->hdma[TIM_DMA_ID_TRIGGER]->XferCpltCallback = TIM_DMATriggerCplt;
2400c210:	f8df c028 	ldr.w	ip, [pc, #40]	@ 2400c23c <HAL_TIM_DMABurst_MultiReadStart+0xf0>
2400c214:	6ba0      	ldr	r0, [r4, #56]	@ 0x38
2400c216:	f8c0 c03c 	str.w	ip, [r0, #60]	@ 0x3c
      htim->hdma[TIM_DMA_ID_TRIGGER]->XferHalfCpltCallback = TIM_DMATriggerHalfCplt;
2400c21a:	f8df c024 	ldr.w	ip, [pc, #36]	@ 2400c240 <HAL_TIM_DMABurst_MultiReadStart+0xf4>
2400c21e:	e7d7      	b.n	2400c1d0 <HAL_TIM_DMABurst_MultiReadStart+0x84>
2400c220:	2400c2bd 	.word	0x2400c2bd
2400c224:	2400c2cf 	.word	0x2400c2cf
2400c228:	2400c55f 	.word	0x2400c55f
2400c22c:	2400c2e3 	.word	0x2400c2e3
2400c230:	2400c321 	.word	0x2400c321
2400c234:	2400e115 	.word	0x2400e115
2400c238:	2400e127 	.word	0x2400e127
2400c23c:	2400c53b 	.word	0x2400c53b
2400c240:	2400c54d 	.word	0x2400c54d

2400c244 <HAL_TIM_DMABurst_ReadStart>:
{
2400c244:	b537      	push	{r0, r1, r2, r4, r5, lr}
2400c246:	9d06      	ldr	r5, [sp, #24]
                                         ((BurstLength) >> 8U) + 1U);
2400c248:	0a2c      	lsrs	r4, r5, #8
  return HAL_TIM_DMABurst_MultiReadStart(htim, BurstBaseAddress, BurstRequestSrc, BurstBuffer, BurstLength,
2400c24a:	3401      	adds	r4, #1
2400c24c:	e9cd 5400 	strd	r5, r4, [sp]
2400c250:	f7ff ff7c 	bl	2400c14c <HAL_TIM_DMABurst_MultiReadStart>
}
2400c254:	b003      	add	sp, #12
2400c256:	bd30      	pop	{r4, r5, pc}

2400c258 <HAL_TIM_DMABurst_ReadStop>:
HAL_StatusTypeDef HAL_TIM_DMABurst_ReadStop(TIM_HandleTypeDef *htim, uint32_t BurstRequestSrc)
2400c258:	f7ff bf46 	b.w	2400c0e8 <HAL_TIM_DMABurst_WriteStop>

2400c25c <HAL_TIM_GenerateEvent>:
  __HAL_LOCK(htim);
2400c25c:	f890 203c 	ldrb.w	r2, [r0, #60]	@ 0x3c
{
2400c260:	4603      	mov	r3, r0
2400c262:	2002      	movs	r0, #2
  __HAL_LOCK(htim);
2400c264:	2a01      	cmp	r2, #1
2400c266:	d009      	beq.n	2400c27c <HAL_TIM_GenerateEvent+0x20>
  htim->Instance->EGR = EventSource;
2400c268:	681a      	ldr	r2, [r3, #0]
  htim->State = HAL_TIM_STATE_BUSY;
2400c26a:	f883 003d 	strb.w	r0, [r3, #61]	@ 0x3d
  __HAL_UNLOCK(htim);
2400c26e:	2000      	movs	r0, #0
  htim->Instance->EGR = EventSource;
2400c270:	6151      	str	r1, [r2, #20]
  htim->State = HAL_TIM_STATE_READY;
2400c272:	2201      	movs	r2, #1
  __HAL_UNLOCK(htim);
2400c274:	f883 003c 	strb.w	r0, [r3, #60]	@ 0x3c
  htim->State = HAL_TIM_STATE_READY;
2400c278:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d
}
2400c27c:	4770      	bx	lr

2400c27e <HAL_TIM_ConfigTI1Input>:
  tmpcr2 = htim->Instance->CR2;
2400c27e:	6802      	ldr	r2, [r0, #0]
}
2400c280:	2000      	movs	r0, #0
  tmpcr2 = htim->Instance->CR2;
2400c282:	6853      	ldr	r3, [r2, #4]
  tmpcr2 &= ~TIM_CR2_TI1S;
2400c284:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
  tmpcr2 |= TI1_Selection;
2400c288:	430b      	orrs	r3, r1
  htim->Instance->CR2 = tmpcr2;
2400c28a:	6053      	str	r3, [r2, #4]
}
2400c28c:	4770      	bx	lr

2400c28e <HAL_TIM_ReadCapturedValue>:
  switch (Channel)
2400c28e:	2908      	cmp	r1, #8
2400c290:	d010      	beq.n	2400c2b4 <HAL_TIM_ReadCapturedValue+0x26>
2400c292:	d804      	bhi.n	2400c29e <HAL_TIM_ReadCapturedValue+0x10>
2400c294:	b141      	cbz	r1, 2400c2a8 <HAL_TIM_ReadCapturedValue+0x1a>
2400c296:	2904      	cmp	r1, #4
2400c298:	d009      	beq.n	2400c2ae <HAL_TIM_ReadCapturedValue+0x20>
2400c29a:	2000      	movs	r0, #0
2400c29c:	4770      	bx	lr
2400c29e:	290c      	cmp	r1, #12
2400c2a0:	d1fb      	bne.n	2400c29a <HAL_TIM_ReadCapturedValue+0xc>
      tmpreg =   htim->Instance->CCR4;
2400c2a2:	6803      	ldr	r3, [r0, #0]
2400c2a4:	6c18      	ldr	r0, [r3, #64]	@ 0x40
}
2400c2a6:	4770      	bx	lr
      tmpreg =  htim->Instance->CCR1;
2400c2a8:	6803      	ldr	r3, [r0, #0]
2400c2aa:	6b58      	ldr	r0, [r3, #52]	@ 0x34
      break;
2400c2ac:	4770      	bx	lr
      tmpreg =   htim->Instance->CCR2;
2400c2ae:	6803      	ldr	r3, [r0, #0]
2400c2b0:	6b98      	ldr	r0, [r3, #56]	@ 0x38
      break;
2400c2b2:	4770      	bx	lr
      tmpreg =   htim->Instance->CCR3;
2400c2b4:	6803      	ldr	r3, [r0, #0]
2400c2b6:	6bd8      	ldr	r0, [r3, #60]	@ 0x3c
      break;
2400c2b8:	4770      	bx	lr

2400c2ba <HAL_TIM_PeriodElapsedCallback>:
__weak void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
2400c2ba:	4770      	bx	lr

2400c2bc <TIM_DMAPeriodElapsedCplt>:
{
2400c2bc:	b508      	push	{r3, lr}
  TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
2400c2be:	6b80      	ldr	r0, [r0, #56]	@ 0x38
  htim->State = HAL_TIM_STATE_READY;
2400c2c0:	2301      	movs	r3, #1
2400c2c2:	f880 303d 	strb.w	r3, [r0, #61]	@ 0x3d
  HAL_TIM_PeriodElapsedCallback(htim);
2400c2c6:	f7ff fff8 	bl	2400c2ba <HAL_TIM_PeriodElapsedCallback>
}
2400c2ca:	bd08      	pop	{r3, pc}

2400c2cc <HAL_TIM_PeriodElapsedHalfCpltCallback>:
__weak void HAL_TIM_PeriodElapsedHalfCpltCallback(TIM_HandleTypeDef *htim)
2400c2cc:	4770      	bx	lr

2400c2ce <TIM_DMAPeriodElapsedHalfCplt>:
{
2400c2ce:	b508      	push	{r3, lr}
  TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
2400c2d0:	6b80      	ldr	r0, [r0, #56]	@ 0x38
  htim->State = HAL_TIM_STATE_READY;
2400c2d2:	2301      	movs	r3, #1
2400c2d4:	f880 303d 	strb.w	r3, [r0, #61]	@ 0x3d
  HAL_TIM_PeriodElapsedHalfCpltCallback(htim);
2400c2d8:	f7ff fff8 	bl	2400c2cc <HAL_TIM_PeriodElapsedHalfCpltCallback>
}
2400c2dc:	bd08      	pop	{r3, pc}

2400c2de <HAL_TIM_OC_DelayElapsedCallback>:
__weak void HAL_TIM_OC_DelayElapsedCallback(TIM_HandleTypeDef *htim)
2400c2de:	4770      	bx	lr

2400c2e0 <HAL_TIM_IC_CaptureCallback>:
__weak void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)
2400c2e0:	4770      	bx	lr

2400c2e2 <TIM_DMACaptureCplt>:
{
2400c2e2:	b510      	push	{r4, lr}
  TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
2400c2e4:	6b84      	ldr	r4, [r0, #56]	@ 0x38
  htim->State = HAL_TIM_STATE_READY;
2400c2e6:	2301      	movs	r3, #1
  if (hdma == htim->hdma[TIM_DMA_ID_CC1])
2400c2e8:	6a62      	ldr	r2, [r4, #36]	@ 0x24
  htim->State = HAL_TIM_STATE_READY;
2400c2ea:	f884 303d 	strb.w	r3, [r4, #61]	@ 0x3d
  if (hdma == htim->hdma[TIM_DMA_ID_CC1])
2400c2ee:	4282      	cmp	r2, r0
2400c2f0:	d106      	bne.n	2400c300 <TIM_DMACaptureCplt+0x1e>
    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
2400c2f2:	7723      	strb	r3, [r4, #28]
  HAL_TIM_IC_CaptureCallback(htim);
2400c2f4:	4620      	mov	r0, r4
2400c2f6:	f7ff fff3 	bl	2400c2e0 <HAL_TIM_IC_CaptureCallback>
  htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
2400c2fa:	2300      	movs	r3, #0
2400c2fc:	7723      	strb	r3, [r4, #28]
}
2400c2fe:	bd10      	pop	{r4, pc}
  else if (hdma == htim->hdma[TIM_DMA_ID_CC2])
2400c300:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
2400c302:	4283      	cmp	r3, r0
2400c304:	d101      	bne.n	2400c30a <TIM_DMACaptureCplt+0x28>
    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
2400c306:	2302      	movs	r3, #2
2400c308:	e7f3      	b.n	2400c2f2 <TIM_DMACaptureCplt+0x10>
  else if (hdma == htim->hdma[TIM_DMA_ID_CC3])
2400c30a:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
2400c30c:	4283      	cmp	r3, r0
2400c30e:	d101      	bne.n	2400c314 <TIM_DMACaptureCplt+0x32>
    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
2400c310:	2304      	movs	r3, #4
2400c312:	e7ee      	b.n	2400c2f2 <TIM_DMACaptureCplt+0x10>
  else if (hdma == htim->hdma[TIM_DMA_ID_CC4])
2400c314:	6b23      	ldr	r3, [r4, #48]	@ 0x30
2400c316:	4283      	cmp	r3, r0
2400c318:	d1ec      	bne.n	2400c2f4 <TIM_DMACaptureCplt+0x12>
    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
2400c31a:	2308      	movs	r3, #8
2400c31c:	e7e9      	b.n	2400c2f2 <TIM_DMACaptureCplt+0x10>

2400c31e <HAL_TIM_IC_CaptureHalfCpltCallback>:
__weak void HAL_TIM_IC_CaptureHalfCpltCallback(TIM_HandleTypeDef *htim)
2400c31e:	4770      	bx	lr

2400c320 <TIM_DMACaptureHalfCplt>:
{
2400c320:	b510      	push	{r4, lr}
  TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
2400c322:	6b84      	ldr	r4, [r0, #56]	@ 0x38
  htim->State = HAL_TIM_STATE_READY;
2400c324:	2301      	movs	r3, #1
  if (hdma == htim->hdma[TIM_DMA_ID_CC1])
2400c326:	6a62      	ldr	r2, [r4, #36]	@ 0x24
  htim->State = HAL_TIM_STATE_READY;
2400c328:	f884 303d 	strb.w	r3, [r4, #61]	@ 0x3d
  if (hdma == htim->hdma[TIM_DMA_ID_CC1])
2400c32c:	4282      	cmp	r2, r0
2400c32e:	d106      	bne.n	2400c33e <TIM_DMACaptureHalfCplt+0x1e>
    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
2400c330:	7723      	strb	r3, [r4, #28]
  HAL_TIM_IC_CaptureHalfCpltCallback(htim);
2400c332:	4620      	mov	r0, r4
2400c334:	f7ff fff3 	bl	2400c31e <HAL_TIM_IC_CaptureHalfCpltCallback>
  htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
2400c338:	2300      	movs	r3, #0
2400c33a:	7723      	strb	r3, [r4, #28]
}
2400c33c:	bd10      	pop	{r4, pc}
  else if (hdma == htim->hdma[TIM_DMA_ID_CC2])
2400c33e:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
2400c340:	4283      	cmp	r3, r0
2400c342:	d101      	bne.n	2400c348 <TIM_DMACaptureHalfCplt+0x28>
    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
2400c344:	2302      	movs	r3, #2
2400c346:	e7f3      	b.n	2400c330 <TIM_DMACaptureHalfCplt+0x10>
  else if (hdma == htim->hdma[TIM_DMA_ID_CC3])
2400c348:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
2400c34a:	4283      	cmp	r3, r0
2400c34c:	d101      	bne.n	2400c352 <TIM_DMACaptureHalfCplt+0x32>
    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
2400c34e:	2304      	movs	r3, #4
2400c350:	e7ee      	b.n	2400c330 <TIM_DMACaptureHalfCplt+0x10>
  else if (hdma == htim->hdma[TIM_DMA_ID_CC4])
2400c352:	6b23      	ldr	r3, [r4, #48]	@ 0x30
2400c354:	4283      	cmp	r3, r0
2400c356:	d1ec      	bne.n	2400c332 <TIM_DMACaptureHalfCplt+0x12>
    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
2400c358:	2308      	movs	r3, #8
2400c35a:	e7e9      	b.n	2400c330 <TIM_DMACaptureHalfCplt+0x10>

2400c35c <HAL_TIM_PWM_PulseFinishedCallback>:
__weak void HAL_TIM_PWM_PulseFinishedCallback(TIM_HandleTypeDef *htim)
2400c35c:	4770      	bx	lr

2400c35e <TIM_DMADelayPulseCplt>:
{
2400c35e:	b510      	push	{r4, lr}
  TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
2400c360:	6b84      	ldr	r4, [r0, #56]	@ 0x38
  htim->State = HAL_TIM_STATE_READY;
2400c362:	2301      	movs	r3, #1
  if (hdma == htim->hdma[TIM_DMA_ID_CC1])
2400c364:	6a62      	ldr	r2, [r4, #36]	@ 0x24
  htim->State = HAL_TIM_STATE_READY;
2400c366:	f884 303d 	strb.w	r3, [r4, #61]	@ 0x3d
  if (hdma == htim->hdma[TIM_DMA_ID_CC1])
2400c36a:	4282      	cmp	r2, r0
2400c36c:	d106      	bne.n	2400c37c <TIM_DMADelayPulseCplt+0x1e>
    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
2400c36e:	7723      	strb	r3, [r4, #28]
  HAL_TIM_PWM_PulseFinishedCallback(htim);
2400c370:	4620      	mov	r0, r4
2400c372:	f7ff fff3 	bl	2400c35c <HAL_TIM_PWM_PulseFinishedCallback>
  htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
2400c376:	2300      	movs	r3, #0
2400c378:	7723      	strb	r3, [r4, #28]
}
2400c37a:	bd10      	pop	{r4, pc}
  else if (hdma == htim->hdma[TIM_DMA_ID_CC2])
2400c37c:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
2400c37e:	4283      	cmp	r3, r0
2400c380:	d101      	bne.n	2400c386 <TIM_DMADelayPulseCplt+0x28>
    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
2400c382:	2302      	movs	r3, #2
2400c384:	e7f3      	b.n	2400c36e <TIM_DMADelayPulseCplt+0x10>
  else if (hdma == htim->hdma[TIM_DMA_ID_CC3])
2400c386:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
2400c388:	4283      	cmp	r3, r0
2400c38a:	d101      	bne.n	2400c390 <TIM_DMADelayPulseCplt+0x32>
    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
2400c38c:	2304      	movs	r3, #4
2400c38e:	e7ee      	b.n	2400c36e <TIM_DMADelayPulseCplt+0x10>
  else if (hdma == htim->hdma[TIM_DMA_ID_CC4])
2400c390:	6b23      	ldr	r3, [r4, #48]	@ 0x30
2400c392:	4283      	cmp	r3, r0
2400c394:	d1ec      	bne.n	2400c370 <TIM_DMADelayPulseCplt+0x12>
    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
2400c396:	2308      	movs	r3, #8
2400c398:	e7e9      	b.n	2400c36e <TIM_DMADelayPulseCplt+0x10>

2400c39a <HAL_TIM_PWM_PulseFinishedHalfCpltCallback>:
__weak void HAL_TIM_PWM_PulseFinishedHalfCpltCallback(TIM_HandleTypeDef *htim)
2400c39a:	4770      	bx	lr

2400c39c <TIM_DMADelayPulseHalfCplt>:
{
2400c39c:	b510      	push	{r4, lr}
  TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
2400c39e:	6b84      	ldr	r4, [r0, #56]	@ 0x38
  htim->State = HAL_TIM_STATE_READY;
2400c3a0:	2301      	movs	r3, #1
  if (hdma == htim->hdma[TIM_DMA_ID_CC1])
2400c3a2:	6a62      	ldr	r2, [r4, #36]	@ 0x24
  htim->State = HAL_TIM_STATE_READY;
2400c3a4:	f884 303d 	strb.w	r3, [r4, #61]	@ 0x3d
  if (hdma == htim->hdma[TIM_DMA_ID_CC1])
2400c3a8:	4282      	cmp	r2, r0
2400c3aa:	d106      	bne.n	2400c3ba <TIM_DMADelayPulseHalfCplt+0x1e>
    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
2400c3ac:	7723      	strb	r3, [r4, #28]
  HAL_TIM_PWM_PulseFinishedHalfCpltCallback(htim);
2400c3ae:	4620      	mov	r0, r4
2400c3b0:	f7ff fff3 	bl	2400c39a <HAL_TIM_PWM_PulseFinishedHalfCpltCallback>
  htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
2400c3b4:	2300      	movs	r3, #0
2400c3b6:	7723      	strb	r3, [r4, #28]
}
2400c3b8:	bd10      	pop	{r4, pc}
  else if (hdma == htim->hdma[TIM_DMA_ID_CC2])
2400c3ba:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
2400c3bc:	4283      	cmp	r3, r0
2400c3be:	d101      	bne.n	2400c3c4 <TIM_DMADelayPulseHalfCplt+0x28>
    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
2400c3c0:	2302      	movs	r3, #2
2400c3c2:	e7f3      	b.n	2400c3ac <TIM_DMADelayPulseHalfCplt+0x10>
  else if (hdma == htim->hdma[TIM_DMA_ID_CC3])
2400c3c4:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
2400c3c6:	4283      	cmp	r3, r0
2400c3c8:	d101      	bne.n	2400c3ce <TIM_DMADelayPulseHalfCplt+0x32>
    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
2400c3ca:	2304      	movs	r3, #4
2400c3cc:	e7ee      	b.n	2400c3ac <TIM_DMADelayPulseHalfCplt+0x10>
  else if (hdma == htim->hdma[TIM_DMA_ID_CC4])
2400c3ce:	6b23      	ldr	r3, [r4, #48]	@ 0x30
2400c3d0:	4283      	cmp	r3, r0
2400c3d2:	d1ec      	bne.n	2400c3ae <TIM_DMADelayPulseHalfCplt+0x12>
    htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
2400c3d4:	2308      	movs	r3, #8
2400c3d6:	e7e9      	b.n	2400c3ac <TIM_DMADelayPulseHalfCplt+0x10>

2400c3d8 <HAL_TIM_TriggerCallback>:
__weak void HAL_TIM_TriggerCallback(TIM_HandleTypeDef *htim)
2400c3d8:	4770      	bx	lr

2400c3da <HAL_TIM_IRQHandler>:
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
2400c3da:	6803      	ldr	r3, [r0, #0]
2400c3dc:	691a      	ldr	r2, [r3, #16]
2400c3de:	0791      	lsls	r1, r2, #30
{
2400c3e0:	b510      	push	{r4, lr}
2400c3e2:	4604      	mov	r4, r0
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
2400c3e4:	d50f      	bpl.n	2400c406 <HAL_TIM_IRQHandler+0x2c>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC1) != RESET)
2400c3e6:	68da      	ldr	r2, [r3, #12]
2400c3e8:	0792      	lsls	r2, r2, #30
2400c3ea:	d50c      	bpl.n	2400c406 <HAL_TIM_IRQHandler+0x2c>
        __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1);
2400c3ec:	f06f 0202 	mvn.w	r2, #2
2400c3f0:	611a      	str	r2, [r3, #16]
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
2400c3f2:	2201      	movs	r2, #1
2400c3f4:	7702      	strb	r2, [r0, #28]
        if ((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00U)
2400c3f6:	699b      	ldr	r3, [r3, #24]
2400c3f8:	0799      	lsls	r1, r3, #30
2400c3fa:	f000 8085 	beq.w	2400c508 <HAL_TIM_IRQHandler+0x12e>
          HAL_TIM_IC_CaptureCallback(htim);
2400c3fe:	f7ff ff6f 	bl	2400c2e0 <HAL_TIM_IC_CaptureCallback>
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
2400c402:	2300      	movs	r3, #0
2400c404:	7723      	strb	r3, [r4, #28]
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC2) != RESET)
2400c406:	6823      	ldr	r3, [r4, #0]
2400c408:	691a      	ldr	r2, [r3, #16]
2400c40a:	0752      	lsls	r2, r2, #29
2400c40c:	d510      	bpl.n	2400c430 <HAL_TIM_IRQHandler+0x56>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC2) != RESET)
2400c40e:	68da      	ldr	r2, [r3, #12]
2400c410:	0750      	lsls	r0, r2, #29
2400c412:	d50d      	bpl.n	2400c430 <HAL_TIM_IRQHandler+0x56>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
2400c414:	f06f 0204 	mvn.w	r2, #4
        HAL_TIM_IC_CaptureCallback(htim);
2400c418:	4620      	mov	r0, r4
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
2400c41a:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
2400c41c:	2202      	movs	r2, #2
2400c41e:	7722      	strb	r2, [r4, #28]
      if ((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
2400c420:	699b      	ldr	r3, [r3, #24]
2400c422:	f413 7f40 	tst.w	r3, #768	@ 0x300
2400c426:	d075      	beq.n	2400c514 <HAL_TIM_IRQHandler+0x13a>
        HAL_TIM_IC_CaptureCallback(htim);
2400c428:	f7ff ff5a 	bl	2400c2e0 <HAL_TIM_IC_CaptureCallback>
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
2400c42c:	2300      	movs	r3, #0
2400c42e:	7723      	strb	r3, [r4, #28]
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC3) != RESET)
2400c430:	6823      	ldr	r3, [r4, #0]
2400c432:	691a      	ldr	r2, [r3, #16]
2400c434:	0711      	lsls	r1, r2, #28
2400c436:	d50f      	bpl.n	2400c458 <HAL_TIM_IRQHandler+0x7e>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC3) != RESET)
2400c438:	68da      	ldr	r2, [r3, #12]
2400c43a:	0712      	lsls	r2, r2, #28
2400c43c:	d50c      	bpl.n	2400c458 <HAL_TIM_IRQHandler+0x7e>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
2400c43e:	f06f 0208 	mvn.w	r2, #8
        HAL_TIM_IC_CaptureCallback(htim);
2400c442:	4620      	mov	r0, r4
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
2400c444:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
2400c446:	2204      	movs	r2, #4
2400c448:	7722      	strb	r2, [r4, #28]
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
2400c44a:	69db      	ldr	r3, [r3, #28]
2400c44c:	079b      	lsls	r3, r3, #30
2400c44e:	d067      	beq.n	2400c520 <HAL_TIM_IRQHandler+0x146>
        HAL_TIM_IC_CaptureCallback(htim);
2400c450:	f7ff ff46 	bl	2400c2e0 <HAL_TIM_IC_CaptureCallback>
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
2400c454:	2300      	movs	r3, #0
2400c456:	7723      	strb	r3, [r4, #28]
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC4) != RESET)
2400c458:	6823      	ldr	r3, [r4, #0]
2400c45a:	691a      	ldr	r2, [r3, #16]
2400c45c:	06d0      	lsls	r0, r2, #27
2400c45e:	d510      	bpl.n	2400c482 <HAL_TIM_IRQHandler+0xa8>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC4) != RESET)
2400c460:	68da      	ldr	r2, [r3, #12]
2400c462:	06d1      	lsls	r1, r2, #27
2400c464:	d50d      	bpl.n	2400c482 <HAL_TIM_IRQHandler+0xa8>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
2400c466:	f06f 0210 	mvn.w	r2, #16
        HAL_TIM_IC_CaptureCallback(htim);
2400c46a:	4620      	mov	r0, r4
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
2400c46c:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
2400c46e:	2208      	movs	r2, #8
2400c470:	7722      	strb	r2, [r4, #28]
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
2400c472:	69db      	ldr	r3, [r3, #28]
2400c474:	f413 7f40 	tst.w	r3, #768	@ 0x300
2400c478:	d058      	beq.n	2400c52c <HAL_TIM_IRQHandler+0x152>
        HAL_TIM_IC_CaptureCallback(htim);
2400c47a:	f7ff ff31 	bl	2400c2e0 <HAL_TIM_IC_CaptureCallback>
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
2400c47e:	2300      	movs	r3, #0
2400c480:	7723      	strb	r3, [r4, #28]
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_UPDATE) != RESET)
2400c482:	6823      	ldr	r3, [r4, #0]
2400c484:	691a      	ldr	r2, [r3, #16]
2400c486:	07d2      	lsls	r2, r2, #31
2400c488:	d508      	bpl.n	2400c49c <HAL_TIM_IRQHandler+0xc2>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_UPDATE) != RESET)
2400c48a:	68da      	ldr	r2, [r3, #12]
2400c48c:	07d0      	lsls	r0, r2, #31
2400c48e:	d505      	bpl.n	2400c49c <HAL_TIM_IRQHandler+0xc2>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
2400c490:	f06f 0201 	mvn.w	r2, #1
      HAL_TIM_PeriodElapsedCallback(htim);
2400c494:	4620      	mov	r0, r4
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
2400c496:	611a      	str	r2, [r3, #16]
      HAL_TIM_PeriodElapsedCallback(htim);
2400c498:	f7ff ff0f 	bl	2400c2ba <HAL_TIM_PeriodElapsedCallback>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK) != RESET)
2400c49c:	6823      	ldr	r3, [r4, #0]
2400c49e:	691a      	ldr	r2, [r3, #16]
2400c4a0:	0611      	lsls	r1, r2, #24
2400c4a2:	d508      	bpl.n	2400c4b6 <HAL_TIM_IRQHandler+0xdc>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) != RESET)
2400c4a4:	68da      	ldr	r2, [r3, #12]
2400c4a6:	0612      	lsls	r2, r2, #24
2400c4a8:	d505      	bpl.n	2400c4b6 <HAL_TIM_IRQHandler+0xdc>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
2400c4aa:	f06f 0280 	mvn.w	r2, #128	@ 0x80
      HAL_TIMEx_BreakCallback(htim);
2400c4ae:	4620      	mov	r0, r4
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
2400c4b0:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_BreakCallback(htim);
2400c4b2:	f001 fe40 	bl	2400e136 <HAL_TIMEx_BreakCallback>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK2) != RESET)
2400c4b6:	6823      	ldr	r3, [r4, #0]
2400c4b8:	691a      	ldr	r2, [r3, #16]
2400c4ba:	05d0      	lsls	r0, r2, #23
2400c4bc:	d508      	bpl.n	2400c4d0 <HAL_TIM_IRQHandler+0xf6>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) != RESET)
2400c4be:	68da      	ldr	r2, [r3, #12]
2400c4c0:	0611      	lsls	r1, r2, #24
2400c4c2:	d505      	bpl.n	2400c4d0 <HAL_TIM_IRQHandler+0xf6>
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_BREAK2);
2400c4c4:	f46f 7280 	mvn.w	r2, #256	@ 0x100
      HAL_TIMEx_Break2Callback(htim);
2400c4c8:	4620      	mov	r0, r4
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_BREAK2);
2400c4ca:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_Break2Callback(htim);
2400c4cc:	f001 fe34 	bl	2400e138 <HAL_TIMEx_Break2Callback>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_TRIGGER) != RESET)
2400c4d0:	6823      	ldr	r3, [r4, #0]
2400c4d2:	691a      	ldr	r2, [r3, #16]
2400c4d4:	0652      	lsls	r2, r2, #25
2400c4d6:	d508      	bpl.n	2400c4ea <HAL_TIM_IRQHandler+0x110>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_TRIGGER) != RESET)
2400c4d8:	68da      	ldr	r2, [r3, #12]
2400c4da:	0650      	lsls	r0, r2, #25
2400c4dc:	d505      	bpl.n	2400c4ea <HAL_TIM_IRQHandler+0x110>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);
2400c4de:	f06f 0240 	mvn.w	r2, #64	@ 0x40
      HAL_TIM_TriggerCallback(htim);
2400c4e2:	4620      	mov	r0, r4
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);
2400c4e4:	611a      	str	r2, [r3, #16]
      HAL_TIM_TriggerCallback(htim);
2400c4e6:	f7ff ff77 	bl	2400c3d8 <HAL_TIM_TriggerCallback>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_COM) != RESET)
2400c4ea:	6823      	ldr	r3, [r4, #0]
2400c4ec:	691a      	ldr	r2, [r3, #16]
2400c4ee:	0691      	lsls	r1, r2, #26
2400c4f0:	d522      	bpl.n	2400c538 <HAL_TIM_IRQHandler+0x15e>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_COM) != RESET)
2400c4f2:	68da      	ldr	r2, [r3, #12]
2400c4f4:	0692      	lsls	r2, r2, #26
2400c4f6:	d51f      	bpl.n	2400c538 <HAL_TIM_IRQHandler+0x15e>
      __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);
2400c4f8:	f06f 0220 	mvn.w	r2, #32
      HAL_TIMEx_CommutCallback(htim);
2400c4fc:	4620      	mov	r0, r4
      __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);
2400c4fe:	611a      	str	r2, [r3, #16]
}
2400c500:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      HAL_TIMEx_CommutCallback(htim);
2400c504:	f001 be05 	b.w	2400e112 <HAL_TIMEx_CommutCallback>
          HAL_TIM_OC_DelayElapsedCallback(htim);
2400c508:	f7ff fee9 	bl	2400c2de <HAL_TIM_OC_DelayElapsedCallback>
          HAL_TIM_PWM_PulseFinishedCallback(htim);
2400c50c:	4620      	mov	r0, r4
2400c50e:	f7ff ff25 	bl	2400c35c <HAL_TIM_PWM_PulseFinishedCallback>
2400c512:	e776      	b.n	2400c402 <HAL_TIM_IRQHandler+0x28>
        HAL_TIM_OC_DelayElapsedCallback(htim);
2400c514:	f7ff fee3 	bl	2400c2de <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
2400c518:	4620      	mov	r0, r4
2400c51a:	f7ff ff1f 	bl	2400c35c <HAL_TIM_PWM_PulseFinishedCallback>
2400c51e:	e785      	b.n	2400c42c <HAL_TIM_IRQHandler+0x52>
        HAL_TIM_OC_DelayElapsedCallback(htim);
2400c520:	f7ff fedd 	bl	2400c2de <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
2400c524:	4620      	mov	r0, r4
2400c526:	f7ff ff19 	bl	2400c35c <HAL_TIM_PWM_PulseFinishedCallback>
2400c52a:	e793      	b.n	2400c454 <HAL_TIM_IRQHandler+0x7a>
        HAL_TIM_OC_DelayElapsedCallback(htim);
2400c52c:	f7ff fed7 	bl	2400c2de <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
2400c530:	4620      	mov	r0, r4
2400c532:	f7ff ff13 	bl	2400c35c <HAL_TIM_PWM_PulseFinishedCallback>
2400c536:	e7a2      	b.n	2400c47e <HAL_TIM_IRQHandler+0xa4>
}
2400c538:	bd10      	pop	{r4, pc}

2400c53a <TIM_DMATriggerCplt>:
{
2400c53a:	b508      	push	{r3, lr}
  TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
2400c53c:	6b80      	ldr	r0, [r0, #56]	@ 0x38
  htim->State = HAL_TIM_STATE_READY;
2400c53e:	2301      	movs	r3, #1
2400c540:	f880 303d 	strb.w	r3, [r0, #61]	@ 0x3d
  HAL_TIM_TriggerCallback(htim);
2400c544:	f7ff ff48 	bl	2400c3d8 <HAL_TIM_TriggerCallback>
}
2400c548:	bd08      	pop	{r3, pc}

2400c54a <HAL_TIM_TriggerHalfCpltCallback>:
__weak void HAL_TIM_TriggerHalfCpltCallback(TIM_HandleTypeDef *htim)
2400c54a:	4770      	bx	lr

2400c54c <TIM_DMATriggerHalfCplt>:
{
2400c54c:	b508      	push	{r3, lr}
  TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
2400c54e:	6b80      	ldr	r0, [r0, #56]	@ 0x38
  htim->State = HAL_TIM_STATE_READY;
2400c550:	2301      	movs	r3, #1
2400c552:	f880 303d 	strb.w	r3, [r0, #61]	@ 0x3d
  HAL_TIM_TriggerHalfCpltCallback(htim);
2400c556:	f7ff fff8 	bl	2400c54a <HAL_TIM_TriggerHalfCpltCallback>
}
2400c55a:	bd08      	pop	{r3, pc}

2400c55c <HAL_TIM_ErrorCallback>:
__weak void HAL_TIM_ErrorCallback(TIM_HandleTypeDef *htim)
2400c55c:	4770      	bx	lr

2400c55e <TIM_DMAError>:
{
2400c55e:	b508      	push	{r3, lr}
  TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
2400c560:	6b80      	ldr	r0, [r0, #56]	@ 0x38
  htim->State = HAL_TIM_STATE_READY;
2400c562:	2301      	movs	r3, #1
2400c564:	f880 303d 	strb.w	r3, [r0, #61]	@ 0x3d
  HAL_TIM_ErrorCallback(htim);
2400c568:	f7ff fff8 	bl	2400c55c <HAL_TIM_ErrorCallback>
}
2400c56c:	bd08      	pop	{r3, pc}

2400c56e <HAL_TIM_Base_GetState>:
  return htim->State;
2400c56e:	f890 003d 	ldrb.w	r0, [r0, #61]	@ 0x3d
}
2400c572:	4770      	bx	lr

2400c574 <HAL_TIM_OC_GetState>:
HAL_TIM_StateTypeDef HAL_TIM_OC_GetState(TIM_HandleTypeDef *htim)
2400c574:	f890 003d 	ldrb.w	r0, [r0, #61]	@ 0x3d
2400c578:	4770      	bx	lr

2400c57a <HAL_TIM_PWM_GetState>:
HAL_TIM_StateTypeDef HAL_TIM_PWM_GetState(TIM_HandleTypeDef *htim)
2400c57a:	f890 003d 	ldrb.w	r0, [r0, #61]	@ 0x3d
2400c57e:	4770      	bx	lr

2400c580 <HAL_TIM_IC_GetState>:
HAL_TIM_StateTypeDef HAL_TIM_IC_GetState(TIM_HandleTypeDef *htim)
2400c580:	f890 003d 	ldrb.w	r0, [r0, #61]	@ 0x3d
2400c584:	4770      	bx	lr

2400c586 <HAL_TIM_OnePulse_GetState>:
HAL_TIM_StateTypeDef HAL_TIM_OnePulse_GetState(TIM_HandleTypeDef *htim)
2400c586:	f890 003d 	ldrb.w	r0, [r0, #61]	@ 0x3d
2400c58a:	4770      	bx	lr

2400c58c <HAL_TIM_Encoder_GetState>:
HAL_TIM_StateTypeDef HAL_TIM_Encoder_GetState(TIM_HandleTypeDef *htim)
2400c58c:	f890 003d 	ldrb.w	r0, [r0, #61]	@ 0x3d
2400c590:	4770      	bx	lr

2400c592 <TIM_Base_SetConfig>:
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
2400c592:	4a30      	ldr	r2, [pc, #192]	@ (2400c654 <TIM_Base_SetConfig+0xc2>)
  tmpcr1 = TIMx->CR1;
2400c594:	6803      	ldr	r3, [r0, #0]
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
2400c596:	4290      	cmp	r0, r2
2400c598:	d012      	beq.n	2400c5c0 <TIM_Base_SetConfig+0x2e>
2400c59a:	f1b0 4f80 	cmp.w	r0, #1073741824	@ 0x40000000
2400c59e:	d00f      	beq.n	2400c5c0 <TIM_Base_SetConfig+0x2e>
2400c5a0:	f5a2 427c 	sub.w	r2, r2, #64512	@ 0xfc00
2400c5a4:	4290      	cmp	r0, r2
2400c5a6:	d00b      	beq.n	2400c5c0 <TIM_Base_SetConfig+0x2e>
2400c5a8:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
2400c5ac:	4290      	cmp	r0, r2
2400c5ae:	d007      	beq.n	2400c5c0 <TIM_Base_SetConfig+0x2e>
2400c5b0:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
2400c5b4:	4290      	cmp	r0, r2
2400c5b6:	d003      	beq.n	2400c5c0 <TIM_Base_SetConfig+0x2e>
2400c5b8:	f502 4278 	add.w	r2, r2, #63488	@ 0xf800
2400c5bc:	4290      	cmp	r0, r2
2400c5be:	d119      	bne.n	2400c5f4 <TIM_Base_SetConfig+0x62>
    tmpcr1 |= Structure->CounterMode;
2400c5c0:	684a      	ldr	r2, [r1, #4]
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
2400c5c2:	f023 0370 	bic.w	r3, r3, #112	@ 0x70
    tmpcr1 |= Structure->CounterMode;
2400c5c6:	4313      	orrs	r3, r2
  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
2400c5c8:	4a22      	ldr	r2, [pc, #136]	@ (2400c654 <TIM_Base_SetConfig+0xc2>)
2400c5ca:	4290      	cmp	r0, r2
2400c5cc:	d01d      	beq.n	2400c60a <TIM_Base_SetConfig+0x78>
2400c5ce:	f1b0 4f80 	cmp.w	r0, #1073741824	@ 0x40000000
2400c5d2:	d01a      	beq.n	2400c60a <TIM_Base_SetConfig+0x78>
2400c5d4:	f5a2 427c 	sub.w	r2, r2, #64512	@ 0xfc00
2400c5d8:	4290      	cmp	r0, r2
2400c5da:	d016      	beq.n	2400c60a <TIM_Base_SetConfig+0x78>
2400c5dc:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
2400c5e0:	4290      	cmp	r0, r2
2400c5e2:	d012      	beq.n	2400c60a <TIM_Base_SetConfig+0x78>
2400c5e4:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
2400c5e8:	4290      	cmp	r0, r2
2400c5ea:	d00e      	beq.n	2400c60a <TIM_Base_SetConfig+0x78>
2400c5ec:	f502 4278 	add.w	r2, r2, #63488	@ 0xf800
2400c5f0:	4290      	cmp	r0, r2
2400c5f2:	d00a      	beq.n	2400c60a <TIM_Base_SetConfig+0x78>
2400c5f4:	4a18      	ldr	r2, [pc, #96]	@ (2400c658 <TIM_Base_SetConfig+0xc6>)
2400c5f6:	4290      	cmp	r0, r2
2400c5f8:	d007      	beq.n	2400c60a <TIM_Base_SetConfig+0x78>
2400c5fa:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
2400c5fe:	4290      	cmp	r0, r2
2400c600:	d003      	beq.n	2400c60a <TIM_Base_SetConfig+0x78>
2400c602:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
2400c606:	4290      	cmp	r0, r2
2400c608:	d103      	bne.n	2400c612 <TIM_Base_SetConfig+0x80>
    tmpcr1 &= ~TIM_CR1_CKD;
2400c60a:	f423 7340 	bic.w	r3, r3, #768	@ 0x300
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
2400c60e:	68ca      	ldr	r2, [r1, #12]
2400c610:	4313      	orrs	r3, r2
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
2400c612:	694a      	ldr	r2, [r1, #20]
2400c614:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
2400c618:	4313      	orrs	r3, r2
  TIMx->CR1 = tmpcr1;
2400c61a:	6003      	str	r3, [r0, #0]
  TIMx->ARR = (uint32_t)Structure->Period ;
2400c61c:	688b      	ldr	r3, [r1, #8]
2400c61e:	62c3      	str	r3, [r0, #44]	@ 0x2c
  TIMx->PSC = Structure->Prescaler;
2400c620:	680b      	ldr	r3, [r1, #0]
2400c622:	6283      	str	r3, [r0, #40]	@ 0x28
  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
2400c624:	4b0b      	ldr	r3, [pc, #44]	@ (2400c654 <TIM_Base_SetConfig+0xc2>)
2400c626:	4298      	cmp	r0, r3
2400c628:	d00f      	beq.n	2400c64a <TIM_Base_SetConfig+0xb8>
2400c62a:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
2400c62e:	4298      	cmp	r0, r3
2400c630:	d00b      	beq.n	2400c64a <TIM_Base_SetConfig+0xb8>
2400c632:	f503 5370 	add.w	r3, r3, #15360	@ 0x3c00
2400c636:	4298      	cmp	r0, r3
2400c638:	d007      	beq.n	2400c64a <TIM_Base_SetConfig+0xb8>
2400c63a:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
2400c63e:	4298      	cmp	r0, r3
2400c640:	d003      	beq.n	2400c64a <TIM_Base_SetConfig+0xb8>
2400c642:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
2400c646:	4298      	cmp	r0, r3
2400c648:	d101      	bne.n	2400c64e <TIM_Base_SetConfig+0xbc>
    TIMx->RCR = Structure->RepetitionCounter;
2400c64a:	690b      	ldr	r3, [r1, #16]
2400c64c:	6303      	str	r3, [r0, #48]	@ 0x30
  TIMx->EGR = TIM_EGR_UG;
2400c64e:	2301      	movs	r3, #1
2400c650:	6143      	str	r3, [r0, #20]
}
2400c652:	4770      	bx	lr
2400c654:	40010000 	.word	0x40010000
2400c658:	40014000 	.word	0x40014000

2400c65c <HAL_TIM_Base_Init>:
{
2400c65c:	b510      	push	{r4, lr}
  if (htim == NULL)
2400c65e:	4604      	mov	r4, r0
2400c660:	b1a0      	cbz	r0, 2400c68c <HAL_TIM_Base_Init+0x30>
  if (htim->State == HAL_TIM_STATE_RESET)
2400c662:	f890 303d 	ldrb.w	r3, [r0, #61]	@ 0x3d
2400c666:	f003 02ff 	and.w	r2, r3, #255	@ 0xff
2400c66a:	b91b      	cbnz	r3, 2400c674 <HAL_TIM_Base_Init+0x18>
    htim->Lock = HAL_UNLOCKED;
2400c66c:	f880 203c 	strb.w	r2, [r0, #60]	@ 0x3c
    HAL_TIM_Base_MspInit(htim);
2400c670:	f7ff f8be 	bl	2400b7f0 <HAL_TIM_Base_MspInit>
  htim->State = HAL_TIM_STATE_BUSY;
2400c674:	2302      	movs	r3, #2
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
2400c676:	6820      	ldr	r0, [r4, #0]
2400c678:	1d21      	adds	r1, r4, #4
  htim->State = HAL_TIM_STATE_BUSY;
2400c67a:	f884 303d 	strb.w	r3, [r4, #61]	@ 0x3d
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
2400c67e:	f7ff ff88 	bl	2400c592 <TIM_Base_SetConfig>
  htim->State = HAL_TIM_STATE_READY;
2400c682:	2301      	movs	r3, #1
  return HAL_OK;
2400c684:	2000      	movs	r0, #0
  htim->State = HAL_TIM_STATE_READY;
2400c686:	f884 303d 	strb.w	r3, [r4, #61]	@ 0x3d
}
2400c68a:	bd10      	pop	{r4, pc}
    return HAL_ERROR;
2400c68c:	2001      	movs	r0, #1
2400c68e:	e7fc      	b.n	2400c68a <HAL_TIM_Base_Init+0x2e>

2400c690 <HAL_TIM_OC_Init>:
{
2400c690:	b510      	push	{r4, lr}
  if (htim == NULL)
2400c692:	4604      	mov	r4, r0
2400c694:	b1a0      	cbz	r0, 2400c6c0 <HAL_TIM_OC_Init+0x30>
  if (htim->State == HAL_TIM_STATE_RESET)
2400c696:	f890 303d 	ldrb.w	r3, [r0, #61]	@ 0x3d
2400c69a:	f003 02ff 	and.w	r2, r3, #255	@ 0xff
2400c69e:	b91b      	cbnz	r3, 2400c6a8 <HAL_TIM_OC_Init+0x18>
    htim->Lock = HAL_UNLOCKED;
2400c6a0:	f880 203c 	strb.w	r2, [r0, #60]	@ 0x3c
    HAL_TIM_OC_MspInit(htim);
2400c6a4:	f7ff f974 	bl	2400b990 <HAL_TIM_OC_MspInit>
  htim->State = HAL_TIM_STATE_BUSY;
2400c6a8:	2302      	movs	r3, #2
  TIM_Base_SetConfig(htim->Instance,  &htim->Init);
2400c6aa:	6820      	ldr	r0, [r4, #0]
2400c6ac:	1d21      	adds	r1, r4, #4
  htim->State = HAL_TIM_STATE_BUSY;
2400c6ae:	f884 303d 	strb.w	r3, [r4, #61]	@ 0x3d
  TIM_Base_SetConfig(htim->Instance,  &htim->Init);
2400c6b2:	f7ff ff6e 	bl	2400c592 <TIM_Base_SetConfig>
  htim->State = HAL_TIM_STATE_READY;
2400c6b6:	2301      	movs	r3, #1
  return HAL_OK;
2400c6b8:	2000      	movs	r0, #0
  htim->State = HAL_TIM_STATE_READY;
2400c6ba:	f884 303d 	strb.w	r3, [r4, #61]	@ 0x3d
}
2400c6be:	bd10      	pop	{r4, pc}
    return HAL_ERROR;
2400c6c0:	2001      	movs	r0, #1
2400c6c2:	e7fc      	b.n	2400c6be <HAL_TIM_OC_Init+0x2e>

2400c6c4 <HAL_TIM_PWM_Init>:
{
2400c6c4:	b510      	push	{r4, lr}
  if (htim == NULL)
2400c6c6:	4604      	mov	r4, r0
2400c6c8:	b1a0      	cbz	r0, 2400c6f4 <HAL_TIM_PWM_Init+0x30>
  if (htim->State == HAL_TIM_STATE_RESET)
2400c6ca:	f890 303d 	ldrb.w	r3, [r0, #61]	@ 0x3d
2400c6ce:	f003 02ff 	and.w	r2, r3, #255	@ 0xff
2400c6d2:	b91b      	cbnz	r3, 2400c6dc <HAL_TIM_PWM_Init+0x18>
    htim->Lock = HAL_UNLOCKED;
2400c6d4:	f880 203c 	strb.w	r2, [r0, #60]	@ 0x3c
    HAL_TIM_PWM_MspInit(htim);
2400c6d8:	f7ff f979 	bl	2400b9ce <HAL_TIM_PWM_MspInit>
  htim->State = HAL_TIM_STATE_BUSY;
2400c6dc:	2302      	movs	r3, #2
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
2400c6de:	6820      	ldr	r0, [r4, #0]
2400c6e0:	1d21      	adds	r1, r4, #4
  htim->State = HAL_TIM_STATE_BUSY;
2400c6e2:	f884 303d 	strb.w	r3, [r4, #61]	@ 0x3d
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
2400c6e6:	f7ff ff54 	bl	2400c592 <TIM_Base_SetConfig>
  htim->State = HAL_TIM_STATE_READY;
2400c6ea:	2301      	movs	r3, #1
  return HAL_OK;
2400c6ec:	2000      	movs	r0, #0
  htim->State = HAL_TIM_STATE_READY;
2400c6ee:	f884 303d 	strb.w	r3, [r4, #61]	@ 0x3d
}
2400c6f2:	bd10      	pop	{r4, pc}
    return HAL_ERROR;
2400c6f4:	2001      	movs	r0, #1
2400c6f6:	e7fc      	b.n	2400c6f2 <HAL_TIM_PWM_Init+0x2e>

2400c6f8 <HAL_TIM_IC_Init>:
{
2400c6f8:	b510      	push	{r4, lr}
  if (htim == NULL)
2400c6fa:	4604      	mov	r4, r0
2400c6fc:	b1a0      	cbz	r0, 2400c728 <HAL_TIM_IC_Init+0x30>
  if (htim->State == HAL_TIM_STATE_RESET)
2400c6fe:	f890 303d 	ldrb.w	r3, [r0, #61]	@ 0x3d
2400c702:	f003 02ff 	and.w	r2, r3, #255	@ 0xff
2400c706:	b91b      	cbnz	r3, 2400c710 <HAL_TIM_IC_Init+0x18>
    htim->Lock = HAL_UNLOCKED;
2400c708:	f880 203c 	strb.w	r2, [r0, #60]	@ 0x3c
    HAL_TIM_IC_MspInit(htim);
2400c70c:	f7ff f97e 	bl	2400ba0c <HAL_TIM_IC_MspInit>
  htim->State = HAL_TIM_STATE_BUSY;
2400c710:	2302      	movs	r3, #2
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
2400c712:	6820      	ldr	r0, [r4, #0]
2400c714:	1d21      	adds	r1, r4, #4
  htim->State = HAL_TIM_STATE_BUSY;
2400c716:	f884 303d 	strb.w	r3, [r4, #61]	@ 0x3d
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
2400c71a:	f7ff ff3a 	bl	2400c592 <TIM_Base_SetConfig>
  htim->State = HAL_TIM_STATE_READY;
2400c71e:	2301      	movs	r3, #1
  return HAL_OK;
2400c720:	2000      	movs	r0, #0
  htim->State = HAL_TIM_STATE_READY;
2400c722:	f884 303d 	strb.w	r3, [r4, #61]	@ 0x3d
}
2400c726:	bd10      	pop	{r4, pc}
    return HAL_ERROR;
2400c728:	2001      	movs	r0, #1
2400c72a:	e7fc      	b.n	2400c726 <HAL_TIM_IC_Init+0x2e>

2400c72c <HAL_TIM_OnePulse_Init>:
{
2400c72c:	b538      	push	{r3, r4, r5, lr}
2400c72e:	460d      	mov	r5, r1
  if (htim == NULL)
2400c730:	4604      	mov	r4, r0
2400c732:	b1e0      	cbz	r0, 2400c76e <HAL_TIM_OnePulse_Init+0x42>
  if (htim->State == HAL_TIM_STATE_RESET)
2400c734:	f890 303d 	ldrb.w	r3, [r0, #61]	@ 0x3d
2400c738:	f003 02ff 	and.w	r2, r3, #255	@ 0xff
2400c73c:	b91b      	cbnz	r3, 2400c746 <HAL_TIM_OnePulse_Init+0x1a>
    htim->Lock = HAL_UNLOCKED;
2400c73e:	f880 203c 	strb.w	r2, [r0, #60]	@ 0x3c
    HAL_TIM_OnePulse_MspInit(htim);
2400c742:	f7ff f982 	bl	2400ba4a <HAL_TIM_OnePulse_MspInit>
  htim->State = HAL_TIM_STATE_BUSY;
2400c746:	2302      	movs	r3, #2
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
2400c748:	4621      	mov	r1, r4
  htim->State = HAL_TIM_STATE_BUSY;
2400c74a:	f884 303d 	strb.w	r3, [r4, #61]	@ 0x3d
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
2400c74e:	f851 0b04 	ldr.w	r0, [r1], #4
2400c752:	f7ff ff1e 	bl	2400c592 <TIM_Base_SetConfig>
  htim->Instance->CR1 &= ~TIM_CR1_OPM;
2400c756:	6803      	ldr	r3, [r0, #0]
2400c758:	f023 0308 	bic.w	r3, r3, #8
2400c75c:	6003      	str	r3, [r0, #0]
  htim->Instance->CR1 |= OnePulseMode;
2400c75e:	6803      	ldr	r3, [r0, #0]
2400c760:	432b      	orrs	r3, r5
2400c762:	6003      	str	r3, [r0, #0]
  htim->State = HAL_TIM_STATE_READY;
2400c764:	2301      	movs	r3, #1
  return HAL_OK;
2400c766:	2000      	movs	r0, #0
  htim->State = HAL_TIM_STATE_READY;
2400c768:	f884 303d 	strb.w	r3, [r4, #61]	@ 0x3d
}
2400c76c:	bd38      	pop	{r3, r4, r5, pc}
    return HAL_ERROR;
2400c76e:	2001      	movs	r0, #1
2400c770:	e7fc      	b.n	2400c76c <HAL_TIM_OnePulse_Init+0x40>

2400c772 <HAL_TIM_Encoder_Init>:
{
2400c772:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
2400c774:	460c      	mov	r4, r1
  if (htim == NULL)
2400c776:	4605      	mov	r5, r0
2400c778:	2800      	cmp	r0, #0
2400c77a:	d042      	beq.n	2400c802 <HAL_TIM_Encoder_Init+0x90>
  if (htim->State == HAL_TIM_STATE_RESET)
2400c77c:	f890 303d 	ldrb.w	r3, [r0, #61]	@ 0x3d
2400c780:	f003 02ff 	and.w	r2, r3, #255	@ 0xff
2400c784:	b91b      	cbnz	r3, 2400c78e <HAL_TIM_Encoder_Init+0x1c>
    htim->Lock = HAL_UNLOCKED;
2400c786:	f880 203c 	strb.w	r2, [r0, #60]	@ 0x3c
    HAL_TIM_Encoder_MspInit(htim);
2400c78a:	f7ff fa65 	bl	2400bc58 <HAL_TIM_Encoder_MspInit>
  htim->Instance->SMCR &= ~(TIM_SMCR_SMS | TIM_SMCR_ECE);
2400c78e:	4629      	mov	r1, r5
  htim->State = HAL_TIM_STATE_BUSY;
2400c790:	2302      	movs	r3, #2
2400c792:	f885 303d 	strb.w	r3, [r5, #61]	@ 0x3d
  htim->Instance->SMCR &= ~(TIM_SMCR_SMS | TIM_SMCR_ECE);
2400c796:	f851 0b04 	ldr.w	r0, [r1], #4
2400c79a:	6883      	ldr	r3, [r0, #8]
2400c79c:	f423 33a0 	bic.w	r3, r3, #81920	@ 0x14000
2400c7a0:	f023 0307 	bic.w	r3, r3, #7
2400c7a4:	6083      	str	r3, [r0, #8]
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
2400c7a6:	f7ff fef4 	bl	2400c592 <TIM_Base_SetConfig>
  tmpsmcr = htim->Instance->SMCR;
2400c7aa:	6881      	ldr	r1, [r0, #8]
  tmpsmcr |= sConfig->EncoderMode;
2400c7ac:	6822      	ldr	r2, [r4, #0]
  tmpccmr1 = htim->Instance->CCMR1;
2400c7ae:	6983      	ldr	r3, [r0, #24]
  tmpccmr1 |= (sConfig->IC1Selection | (sConfig->IC2Selection << 8U));
2400c7b0:	69a6      	ldr	r6, [r4, #24]
  tmpsmcr |= sConfig->EncoderMode;
2400c7b2:	4311      	orrs	r1, r2
  tmpccmr1 &= ~(TIM_CCMR1_CC1S | TIM_CCMR1_CC2S);
2400c7b4:	f423 7340 	bic.w	r3, r3, #768	@ 0x300
  tmpccmr1 |= (sConfig->IC1Selection | (sConfig->IC2Selection << 8U));
2400c7b8:	68a2      	ldr	r2, [r4, #8]
  tmpccer = htim->Instance->CCER;
2400c7ba:	6a07      	ldr	r7, [r0, #32]
  tmpccmr1 &= ~(TIM_CCMR1_CC1S | TIM_CCMR1_CC2S);
2400c7bc:	f023 0303 	bic.w	r3, r3, #3
  tmpccmr1 |= (sConfig->IC1Selection | (sConfig->IC2Selection << 8U));
2400c7c0:	ea42 2206 	orr.w	r2, r2, r6, lsl #8
  tmpccmr1 |= sConfig->IC1Prescaler | (sConfig->IC2Prescaler << 8U);
2400c7c4:	69e6      	ldr	r6, [r4, #28]
  tmpccer &= ~(TIM_CCER_CC1NP | TIM_CCER_CC2NP);
2400c7c6:	f027 07aa 	bic.w	r7, r7, #170	@ 0xaa
  tmpccmr1 |= (sConfig->IC1Selection | (sConfig->IC2Selection << 8U));
2400c7ca:	431a      	orrs	r2, r3
  tmpccmr1 |= (sConfig->IC1Filter << 4U) | (sConfig->IC2Filter << 12U);
2400c7cc:	6923      	ldr	r3, [r4, #16]
2400c7ce:	011b      	lsls	r3, r3, #4
  tmpccmr1 &= ~(TIM_CCMR1_IC1F | TIM_CCMR1_IC2F);
2400c7d0:	f422 427c 	bic.w	r2, r2, #64512	@ 0xfc00
  tmpccmr1 |= (sConfig->IC1Filter << 4U) | (sConfig->IC2Filter << 12U);
2400c7d4:	ea43 2306 	orr.w	r3, r3, r6, lsl #8
2400c7d8:	68e6      	ldr	r6, [r4, #12]
  tmpccmr1 &= ~(TIM_CCMR1_IC1F | TIM_CCMR1_IC2F);
2400c7da:	f022 02fc 	bic.w	r2, r2, #252	@ 0xfc
  tmpccmr1 |= (sConfig->IC1Filter << 4U) | (sConfig->IC2Filter << 12U);
2400c7de:	4333      	orrs	r3, r6
2400c7e0:	6a26      	ldr	r6, [r4, #32]
2400c7e2:	ea43 3306 	orr.w	r3, r3, r6, lsl #12
  tmpccer |= sConfig->IC1Polarity | (sConfig->IC2Polarity << 4U);
2400c7e6:	6966      	ldr	r6, [r4, #20]
  tmpccmr1 |= (sConfig->IC1Filter << 4U) | (sConfig->IC2Filter << 12U);
2400c7e8:	4313      	orrs	r3, r2
  tmpccer |= sConfig->IC1Polarity | (sConfig->IC2Polarity << 4U);
2400c7ea:	6862      	ldr	r2, [r4, #4]
  htim->Instance->SMCR = tmpsmcr;
2400c7ec:	6081      	str	r1, [r0, #8]
  tmpccer |= sConfig->IC1Polarity | (sConfig->IC2Polarity << 4U);
2400c7ee:	ea42 1206 	orr.w	r2, r2, r6, lsl #4
  htim->Instance->CCMR1 = tmpccmr1;
2400c7f2:	6183      	str	r3, [r0, #24]
  htim->State = HAL_TIM_STATE_READY;
2400c7f4:	2301      	movs	r3, #1
  tmpccer |= sConfig->IC1Polarity | (sConfig->IC2Polarity << 4U);
2400c7f6:	4317      	orrs	r7, r2
  htim->Instance->CCER = tmpccer;
2400c7f8:	6207      	str	r7, [r0, #32]
  return HAL_OK;
2400c7fa:	2000      	movs	r0, #0
  htim->State = HAL_TIM_STATE_READY;
2400c7fc:	f885 303d 	strb.w	r3, [r5, #61]	@ 0x3d
}
2400c800:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return HAL_ERROR;
2400c802:	2001      	movs	r0, #1
2400c804:	e7fc      	b.n	2400c800 <HAL_TIM_Encoder_Init+0x8e>

2400c806 <TIM_OC2_SetConfig>:
  TIMx->CCER &= ~TIM_CCER_CC2E;
2400c806:	6a03      	ldr	r3, [r0, #32]
2400c808:	f023 0310 	bic.w	r3, r3, #16
{
2400c80c:	b570      	push	{r4, r5, r6, lr}
  TIMx->CCER &= ~TIM_CCER_CC2E;
2400c80e:	6203      	str	r3, [r0, #32]
  tmpccer = TIMx->CCER;
2400c810:	6a03      	ldr	r3, [r0, #32]
  tmpcr2 =  TIMx->CR2;
2400c812:	6844      	ldr	r4, [r0, #4]
  tmpccmrx = TIMx->CCMR1;
2400c814:	6982      	ldr	r2, [r0, #24]
  tmpccer &= ~TIM_CCER_CC2P;
2400c816:	f023 0320 	bic.w	r3, r3, #32
  tmpccmrx |= (OC_Config->OCMode << 8U);
2400c81a:	680d      	ldr	r5, [r1, #0]
  tmpccmrx &= ~TIM_CCMR1_CC2S;
2400c81c:	f022 7280 	bic.w	r2, r2, #16777216	@ 0x1000000
2400c820:	f422 42e6 	bic.w	r2, r2, #29440	@ 0x7300
  tmpccmrx |= (OC_Config->OCMode << 8U);
2400c824:	ea42 2205 	orr.w	r2, r2, r5, lsl #8
  tmpccer |= (OC_Config->OCPolarity << 4U);
2400c828:	688d      	ldr	r5, [r1, #8]
2400c82a:	ea43 1305 	orr.w	r3, r3, r5, lsl #4
  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_2))
2400c82e:	4d16      	ldr	r5, [pc, #88]	@ (2400c888 <TIM_OC2_SetConfig+0x82>)
2400c830:	42a8      	cmp	r0, r5
2400c832:	d003      	beq.n	2400c83c <TIM_OC2_SetConfig+0x36>
2400c834:	f505 6580 	add.w	r5, r5, #1024	@ 0x400
2400c838:	42a8      	cmp	r0, r5
2400c83a:	d10d      	bne.n	2400c858 <TIM_OC2_SetConfig+0x52>
    tmpccer |= (OC_Config->OCNPolarity << 4U);
2400c83c:	68cd      	ldr	r5, [r1, #12]
    tmpccer &= ~TIM_CCER_CC2NP;
2400c83e:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
    tmpccer |= (OC_Config->OCNPolarity << 4U);
2400c842:	ea43 1305 	orr.w	r3, r3, r5, lsl #4
  if (IS_TIM_BREAK_INSTANCE(TIMx))
2400c846:	4d10      	ldr	r5, [pc, #64]	@ (2400c888 <TIM_OC2_SetConfig+0x82>)
2400c848:	42a8      	cmp	r0, r5
    tmpccer &= ~TIM_CCER_CC2NE;
2400c84a:	f023 0340 	bic.w	r3, r3, #64	@ 0x40
  if (IS_TIM_BREAK_INSTANCE(TIMx))
2400c84e:	d00e      	beq.n	2400c86e <TIM_OC2_SetConfig+0x68>
2400c850:	f505 6580 	add.w	r5, r5, #1024	@ 0x400
2400c854:	42a8      	cmp	r0, r5
2400c856:	d00a      	beq.n	2400c86e <TIM_OC2_SetConfig+0x68>
2400c858:	4d0c      	ldr	r5, [pc, #48]	@ (2400c88c <TIM_OC2_SetConfig+0x86>)
2400c85a:	42a8      	cmp	r0, r5
2400c85c:	d007      	beq.n	2400c86e <TIM_OC2_SetConfig+0x68>
2400c85e:	f505 6580 	add.w	r5, r5, #1024	@ 0x400
2400c862:	42a8      	cmp	r0, r5
2400c864:	d003      	beq.n	2400c86e <TIM_OC2_SetConfig+0x68>
2400c866:	f505 6580 	add.w	r5, r5, #1024	@ 0x400
2400c86a:	42a8      	cmp	r0, r5
2400c86c:	d106      	bne.n	2400c87c <TIM_OC2_SetConfig+0x76>
    tmpcr2 &= ~TIM_CR2_OIS2N;
2400c86e:	f424 6540 	bic.w	r5, r4, #3072	@ 0xc00
    tmpcr2 |= (OC_Config->OCNIdleState << 2U);
2400c872:	e9d1 4605 	ldrd	r4, r6, [r1, #20]
2400c876:	4334      	orrs	r4, r6
2400c878:	ea45 0484 	orr.w	r4, r5, r4, lsl #2
  TIMx->CR2 = tmpcr2;
2400c87c:	6044      	str	r4, [r0, #4]
  TIMx->CCMR1 = tmpccmrx;
2400c87e:	6182      	str	r2, [r0, #24]
  TIMx->CCR2 = OC_Config->Pulse;
2400c880:	684a      	ldr	r2, [r1, #4]
2400c882:	6382      	str	r2, [r0, #56]	@ 0x38
  TIMx->CCER = tmpccer;
2400c884:	6203      	str	r3, [r0, #32]
}
2400c886:	bd70      	pop	{r4, r5, r6, pc}
2400c888:	40010000 	.word	0x40010000
2400c88c:	40014000 	.word	0x40014000

2400c890 <HAL_TIM_OC_ConfigChannel>:
{
2400c890:	b510      	push	{r4, lr}
  __HAL_LOCK(htim);
2400c892:	f890 303c 	ldrb.w	r3, [r0, #60]	@ 0x3c
{
2400c896:	4604      	mov	r4, r0
2400c898:	2002      	movs	r0, #2
  __HAL_LOCK(htim);
2400c89a:	2b01      	cmp	r3, #1
2400c89c:	d00f      	beq.n	2400c8be <HAL_TIM_OC_ConfigChannel+0x2e>
  switch (Channel)
2400c89e:	2a0c      	cmp	r2, #12
  htim->State = HAL_TIM_STATE_BUSY;
2400c8a0:	f884 003d 	strb.w	r0, [r4, #61]	@ 0x3d
  switch (Channel)
2400c8a4:	d020      	beq.n	2400c8e8 <HAL_TIM_OC_ConfigChannel+0x58>
2400c8a6:	d80b      	bhi.n	2400c8c0 <HAL_TIM_OC_ConfigChannel+0x30>
2400c8a8:	2a04      	cmp	r2, #4
2400c8aa:	d015      	beq.n	2400c8d8 <HAL_TIM_OC_ConfigChannel+0x48>
2400c8ac:	2a08      	cmp	r2, #8
2400c8ae:	d017      	beq.n	2400c8e0 <HAL_TIM_OC_ConfigChannel+0x50>
2400c8b0:	b172      	cbz	r2, 2400c8d0 <HAL_TIM_OC_ConfigChannel+0x40>
  htim->State = HAL_TIM_STATE_READY;
2400c8b2:	2301      	movs	r3, #1
  __HAL_UNLOCK(htim);
2400c8b4:	2000      	movs	r0, #0
  htim->State = HAL_TIM_STATE_READY;
2400c8b6:	f884 303d 	strb.w	r3, [r4, #61]	@ 0x3d
  __HAL_UNLOCK(htim);
2400c8ba:	f884 003c 	strb.w	r0, [r4, #60]	@ 0x3c
}
2400c8be:	bd10      	pop	{r4, pc}
  switch (Channel)
2400c8c0:	2a10      	cmp	r2, #16
2400c8c2:	d015      	beq.n	2400c8f0 <HAL_TIM_OC_ConfigChannel+0x60>
2400c8c4:	2a14      	cmp	r2, #20
2400c8c6:	d1f4      	bne.n	2400c8b2 <HAL_TIM_OC_ConfigChannel+0x22>
      TIM_OC6_SetConfig(htim->Instance, sConfig);
2400c8c8:	6820      	ldr	r0, [r4, #0]
2400c8ca:	f7fe ff5f 	bl	2400b78c <TIM_OC6_SetConfig>
      break;
2400c8ce:	e7f0      	b.n	2400c8b2 <HAL_TIM_OC_ConfigChannel+0x22>
      TIM_OC1_SetConfig(htim->Instance, sConfig);
2400c8d0:	6820      	ldr	r0, [r4, #0]
2400c8d2:	f7fe fe69 	bl	2400b5a8 <TIM_OC1_SetConfig>
      break;
2400c8d6:	e7ec      	b.n	2400c8b2 <HAL_TIM_OC_ConfigChannel+0x22>
      TIM_OC2_SetConfig(htim->Instance, sConfig);
2400c8d8:	6820      	ldr	r0, [r4, #0]
2400c8da:	f7ff ff94 	bl	2400c806 <TIM_OC2_SetConfig>
      break;
2400c8de:	e7e8      	b.n	2400c8b2 <HAL_TIM_OC_ConfigChannel+0x22>
      TIM_OC3_SetConfig(htim->Instance, sConfig);
2400c8e0:	6820      	ldr	r0, [r4, #0]
2400c8e2:	f7fe fead 	bl	2400b640 <TIM_OC3_SetConfig>
      break;
2400c8e6:	e7e4      	b.n	2400c8b2 <HAL_TIM_OC_ConfigChannel+0x22>
      TIM_OC4_SetConfig(htim->Instance, sConfig);
2400c8e8:	6820      	ldr	r0, [r4, #0]
2400c8ea:	f7fe feeb 	bl	2400b6c4 <TIM_OC4_SetConfig>
      break;
2400c8ee:	e7e0      	b.n	2400c8b2 <HAL_TIM_OC_ConfigChannel+0x22>
      TIM_OC5_SetConfig(htim->Instance, sConfig);
2400c8f0:	6820      	ldr	r0, [r4, #0]
2400c8f2:	f7fe ff19 	bl	2400b728 <TIM_OC5_SetConfig>
      break;
2400c8f6:	e7dc      	b.n	2400c8b2 <HAL_TIM_OC_ConfigChannel+0x22>

2400c8f8 <HAL_TIM_PWM_ConfigChannel>:
{
2400c8f8:	b538      	push	{r3, r4, r5, lr}
  __HAL_LOCK(htim);
2400c8fa:	f890 303c 	ldrb.w	r3, [r0, #60]	@ 0x3c
{
2400c8fe:	4604      	mov	r4, r0
2400c900:	2002      	movs	r0, #2
  __HAL_LOCK(htim);
2400c902:	2b01      	cmp	r3, #1
2400c904:	d012      	beq.n	2400c92c <HAL_TIM_PWM_ConfigChannel+0x34>
2400c906:	2301      	movs	r3, #1
  switch (Channel)
2400c908:	2a0c      	cmp	r2, #12
  htim->State = HAL_TIM_STATE_BUSY;
2400c90a:	f884 003d 	strb.w	r0, [r4, #61]	@ 0x3d
  __HAL_LOCK(htim);
2400c90e:	f884 303c 	strb.w	r3, [r4, #60]	@ 0x3c
  switch (Channel)
2400c912:	d050      	beq.n	2400c9b6 <HAL_TIM_PWM_ConfigChannel+0xbe>
2400c914:	d80b      	bhi.n	2400c92e <HAL_TIM_PWM_ConfigChannel+0x36>
2400c916:	2a04      	cmp	r2, #4
2400c918:	d02d      	beq.n	2400c976 <HAL_TIM_PWM_ConfigChannel+0x7e>
2400c91a:	2a08      	cmp	r2, #8
2400c91c:	d03b      	beq.n	2400c996 <HAL_TIM_PWM_ConfigChannel+0x9e>
2400c91e:	b1d2      	cbz	r2, 2400c956 <HAL_TIM_PWM_ConfigChannel+0x5e>
  htim->State = HAL_TIM_STATE_READY;
2400c920:	2301      	movs	r3, #1
  __HAL_UNLOCK(htim);
2400c922:	2000      	movs	r0, #0
  htim->State = HAL_TIM_STATE_READY;
2400c924:	f884 303d 	strb.w	r3, [r4, #61]	@ 0x3d
  __HAL_UNLOCK(htim);
2400c928:	f884 003c 	strb.w	r0, [r4, #60]	@ 0x3c
}
2400c92c:	bd38      	pop	{r3, r4, r5, pc}
  switch (Channel)
2400c92e:	2a10      	cmp	r2, #16
2400c930:	d051      	beq.n	2400c9d6 <HAL_TIM_PWM_ConfigChannel+0xde>
2400c932:	2a14      	cmp	r2, #20
2400c934:	d1f4      	bne.n	2400c920 <HAL_TIM_PWM_ConfigChannel+0x28>
      TIM_OC6_SetConfig(htim->Instance, sConfig);
2400c936:	6820      	ldr	r0, [r4, #0]
2400c938:	f7fe ff28 	bl	2400b78c <TIM_OC6_SetConfig>
      htim->Instance->CCMR3 |= sConfig->OCFastMode << 8U;
2400c93c:	690a      	ldr	r2, [r1, #16]
      htim->Instance->CCMR3 |= TIM_CCMR3_OC6PE;
2400c93e:	6d43      	ldr	r3, [r0, #84]	@ 0x54
2400c940:	f443 6300 	orr.w	r3, r3, #2048	@ 0x800
2400c944:	6543      	str	r3, [r0, #84]	@ 0x54
      htim->Instance->CCMR3 &= ~TIM_CCMR3_OC6FE;
2400c946:	6d43      	ldr	r3, [r0, #84]	@ 0x54
2400c948:	f423 6380 	bic.w	r3, r3, #1024	@ 0x400
2400c94c:	6543      	str	r3, [r0, #84]	@ 0x54
      htim->Instance->CCMR3 |= sConfig->OCFastMode << 8U;
2400c94e:	6d43      	ldr	r3, [r0, #84]	@ 0x54
2400c950:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
2400c954:	e04d      	b.n	2400c9f2 <HAL_TIM_PWM_ConfigChannel+0xfa>
      TIM_OC1_SetConfig(htim->Instance, sConfig);
2400c956:	6820      	ldr	r0, [r4, #0]
2400c958:	f7fe fe26 	bl	2400b5a8 <TIM_OC1_SetConfig>
      htim->Instance->CCMR1 |= sConfig->OCFastMode;
2400c95c:	690a      	ldr	r2, [r1, #16]
      htim->Instance->CCMR1 |= TIM_CCMR1_OC1PE;
2400c95e:	6983      	ldr	r3, [r0, #24]
2400c960:	f043 0308 	orr.w	r3, r3, #8
2400c964:	6183      	str	r3, [r0, #24]
      htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1FE;
2400c966:	6983      	ldr	r3, [r0, #24]
2400c968:	f023 0304 	bic.w	r3, r3, #4
2400c96c:	6183      	str	r3, [r0, #24]
      htim->Instance->CCMR1 |= sConfig->OCFastMode;
2400c96e:	6983      	ldr	r3, [r0, #24]
2400c970:	4313      	orrs	r3, r2
      htim->Instance->CCMR1 |= sConfig->OCFastMode << 8U;
2400c972:	6183      	str	r3, [r0, #24]
      break;
2400c974:	e7d4      	b.n	2400c920 <HAL_TIM_PWM_ConfigChannel+0x28>
      TIM_OC2_SetConfig(htim->Instance, sConfig);
2400c976:	6820      	ldr	r0, [r4, #0]
2400c978:	f7ff ff45 	bl	2400c806 <TIM_OC2_SetConfig>
      htim->Instance->CCMR1 |= sConfig->OCFastMode << 8U;
2400c97c:	690a      	ldr	r2, [r1, #16]
      htim->Instance->CCMR1 |= TIM_CCMR1_OC2PE;
2400c97e:	6983      	ldr	r3, [r0, #24]
2400c980:	f443 6300 	orr.w	r3, r3, #2048	@ 0x800
2400c984:	6183      	str	r3, [r0, #24]
      htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2FE;
2400c986:	6983      	ldr	r3, [r0, #24]
2400c988:	f423 6380 	bic.w	r3, r3, #1024	@ 0x400
2400c98c:	6183      	str	r3, [r0, #24]
      htim->Instance->CCMR1 |= sConfig->OCFastMode << 8U;
2400c98e:	6983      	ldr	r3, [r0, #24]
2400c990:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
2400c994:	e7ed      	b.n	2400c972 <HAL_TIM_PWM_ConfigChannel+0x7a>
      TIM_OC3_SetConfig(htim->Instance, sConfig);
2400c996:	6820      	ldr	r0, [r4, #0]
2400c998:	f7fe fe52 	bl	2400b640 <TIM_OC3_SetConfig>
      htim->Instance->CCMR2 |= sConfig->OCFastMode;
2400c99c:	690a      	ldr	r2, [r1, #16]
      htim->Instance->CCMR2 |= TIM_CCMR2_OC3PE;
2400c99e:	69c3      	ldr	r3, [r0, #28]
2400c9a0:	f043 0308 	orr.w	r3, r3, #8
2400c9a4:	61c3      	str	r3, [r0, #28]
      htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3FE;
2400c9a6:	69c3      	ldr	r3, [r0, #28]
2400c9a8:	f023 0304 	bic.w	r3, r3, #4
2400c9ac:	61c3      	str	r3, [r0, #28]
      htim->Instance->CCMR2 |= sConfig->OCFastMode;
2400c9ae:	69c3      	ldr	r3, [r0, #28]
2400c9b0:	4313      	orrs	r3, r2
      htim->Instance->CCMR2 |= sConfig->OCFastMode << 8U;
2400c9b2:	61c3      	str	r3, [r0, #28]
      break;
2400c9b4:	e7b4      	b.n	2400c920 <HAL_TIM_PWM_ConfigChannel+0x28>
      TIM_OC4_SetConfig(htim->Instance, sConfig);
2400c9b6:	6820      	ldr	r0, [r4, #0]
2400c9b8:	f7fe fe84 	bl	2400b6c4 <TIM_OC4_SetConfig>
      htim->Instance->CCMR2 |= sConfig->OCFastMode << 8U;
2400c9bc:	690a      	ldr	r2, [r1, #16]
      htim->Instance->CCMR2 |= TIM_CCMR2_OC4PE;
2400c9be:	69c3      	ldr	r3, [r0, #28]
2400c9c0:	f443 6300 	orr.w	r3, r3, #2048	@ 0x800
2400c9c4:	61c3      	str	r3, [r0, #28]
      htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4FE;
2400c9c6:	69c3      	ldr	r3, [r0, #28]
2400c9c8:	f423 6380 	bic.w	r3, r3, #1024	@ 0x400
2400c9cc:	61c3      	str	r3, [r0, #28]
      htim->Instance->CCMR2 |= sConfig->OCFastMode << 8U;
2400c9ce:	69c3      	ldr	r3, [r0, #28]
2400c9d0:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
2400c9d4:	e7ed      	b.n	2400c9b2 <HAL_TIM_PWM_ConfigChannel+0xba>
      TIM_OC5_SetConfig(htim->Instance, sConfig);
2400c9d6:	6820      	ldr	r0, [r4, #0]
2400c9d8:	f7fe fea6 	bl	2400b728 <TIM_OC5_SetConfig>
      htim->Instance->CCMR3 |= sConfig->OCFastMode;
2400c9dc:	690a      	ldr	r2, [r1, #16]
      htim->Instance->CCMR3 |= TIM_CCMR3_OC5PE;
2400c9de:	6d43      	ldr	r3, [r0, #84]	@ 0x54
2400c9e0:	f043 0308 	orr.w	r3, r3, #8
2400c9e4:	6543      	str	r3, [r0, #84]	@ 0x54
      htim->Instance->CCMR3 &= ~TIM_CCMR3_OC5FE;
2400c9e6:	6d43      	ldr	r3, [r0, #84]	@ 0x54
2400c9e8:	f023 0304 	bic.w	r3, r3, #4
2400c9ec:	6543      	str	r3, [r0, #84]	@ 0x54
      htim->Instance->CCMR3 |= sConfig->OCFastMode;
2400c9ee:	6d43      	ldr	r3, [r0, #84]	@ 0x54
2400c9f0:	4313      	orrs	r3, r2
      htim->Instance->CCMR3 |= sConfig->OCFastMode << 8U;
2400c9f2:	6543      	str	r3, [r0, #84]	@ 0x54
      break;
2400c9f4:	e794      	b.n	2400c920 <HAL_TIM_PWM_ConfigChannel+0x28>

2400c9f6 <TIM_TI1_SetConfig>:
{
2400c9f6:	b570      	push	{r4, r5, r6, lr}
  TIMx->CCER &= ~TIM_CCER_CC1E;
2400c9f8:	6a04      	ldr	r4, [r0, #32]
  if (IS_TIM_CC2_INSTANCE(TIMx) != RESET)
2400c9fa:	4e1b      	ldr	r6, [pc, #108]	@ (2400ca68 <TIM_TI1_SetConfig+0x72>)
  TIMx->CCER &= ~TIM_CCER_CC1E;
2400c9fc:	f024 0401 	bic.w	r4, r4, #1
  if (IS_TIM_CC2_INSTANCE(TIMx) != RESET)
2400ca00:	42b0      	cmp	r0, r6
  TIMx->CCER &= ~TIM_CCER_CC1E;
2400ca02:	6204      	str	r4, [r0, #32]
  tmpccmr1 = TIMx->CCMR1;
2400ca04:	6984      	ldr	r4, [r0, #24]
  tmpccer = TIMx->CCER;
2400ca06:	6a05      	ldr	r5, [r0, #32]
  if (IS_TIM_CC2_INSTANCE(TIMx) != RESET)
2400ca08:	d029      	beq.n	2400ca5e <TIM_TI1_SetConfig+0x68>
2400ca0a:	f1b0 4f80 	cmp.w	r0, #1073741824	@ 0x40000000
2400ca0e:	d026      	beq.n	2400ca5e <TIM_TI1_SetConfig+0x68>
2400ca10:	f5a6 467c 	sub.w	r6, r6, #64512	@ 0xfc00
2400ca14:	42b0      	cmp	r0, r6
2400ca16:	d022      	beq.n	2400ca5e <TIM_TI1_SetConfig+0x68>
2400ca18:	f506 6680 	add.w	r6, r6, #1024	@ 0x400
2400ca1c:	42b0      	cmp	r0, r6
2400ca1e:	d01e      	beq.n	2400ca5e <TIM_TI1_SetConfig+0x68>
2400ca20:	f506 6680 	add.w	r6, r6, #1024	@ 0x400
2400ca24:	42b0      	cmp	r0, r6
2400ca26:	d01a      	beq.n	2400ca5e <TIM_TI1_SetConfig+0x68>
2400ca28:	f506 4678 	add.w	r6, r6, #63488	@ 0xf800
2400ca2c:	42b0      	cmp	r0, r6
2400ca2e:	d016      	beq.n	2400ca5e <TIM_TI1_SetConfig+0x68>
2400ca30:	f5a6 466c 	sub.w	r6, r6, #60416	@ 0xec00
2400ca34:	42b0      	cmp	r0, r6
2400ca36:	d012      	beq.n	2400ca5e <TIM_TI1_SetConfig+0x68>
2400ca38:	f506 3694 	add.w	r6, r6, #75776	@ 0x12800
2400ca3c:	42b0      	cmp	r0, r6
2400ca3e:	d00e      	beq.n	2400ca5e <TIM_TI1_SetConfig+0x68>
    tmpccmr1 |= TIM_CCMR1_CC1S_0;
2400ca40:	f044 0201 	orr.w	r2, r4, #1
  tmpccmr1 |= ((TIM_ICFilter << 4U) & TIM_CCMR1_IC1F);
2400ca44:	011b      	lsls	r3, r3, #4
  tmpccmr1 &= ~TIM_CCMR1_IC1F;
2400ca46:	f022 02f0 	bic.w	r2, r2, #240	@ 0xf0
  tmpccer |= (TIM_ICPolarity & (TIM_CCER_CC1P | TIM_CCER_CC1NP));
2400ca4a:	f001 010a 	and.w	r1, r1, #10
  tmpccmr1 |= ((TIM_ICFilter << 4U) & TIM_CCMR1_IC1F);
2400ca4e:	b2db      	uxtb	r3, r3
2400ca50:	4313      	orrs	r3, r2
  tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
2400ca52:	f025 020a 	bic.w	r2, r5, #10
  tmpccer |= (TIM_ICPolarity & (TIM_CCER_CC1P | TIM_CCER_CC1NP));
2400ca56:	4311      	orrs	r1, r2
  TIMx->CCMR1 = tmpccmr1;
2400ca58:	6183      	str	r3, [r0, #24]
  TIMx->CCER = tmpccer;
2400ca5a:	6201      	str	r1, [r0, #32]
}
2400ca5c:	bd70      	pop	{r4, r5, r6, pc}
    tmpccmr1 &= ~TIM_CCMR1_CC1S;
2400ca5e:	f024 0403 	bic.w	r4, r4, #3
    tmpccmr1 |= TIM_ICSelection;
2400ca62:	4322      	orrs	r2, r4
2400ca64:	e7ee      	b.n	2400ca44 <TIM_TI1_SetConfig+0x4e>
2400ca66:	bf00      	nop
2400ca68:	40010000 	.word	0x40010000

2400ca6c <HAL_TIM_IC_ConfigChannel>:
{
2400ca6c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  __HAL_LOCK(htim);
2400ca6e:	f890 303c 	ldrb.w	r3, [r0, #60]	@ 0x3c
{
2400ca72:	4604      	mov	r4, r0
2400ca74:	460d      	mov	r5, r1
2400ca76:	4617      	mov	r7, r2
  __HAL_LOCK(htim);
2400ca78:	2b01      	cmp	r3, #1
2400ca7a:	f04f 0002 	mov.w	r0, #2
2400ca7e:	d019      	beq.n	2400cab4 <HAL_TIM_IC_ConfigChannel+0x48>
2400ca80:	2301      	movs	r3, #1
  htim->State = HAL_TIM_STATE_BUSY;
2400ca82:	f884 003d 	strb.w	r0, [r4, #61]	@ 0x3d
    TIM_TI1_SetConfig(htim->Instance,
2400ca86:	6820      	ldr	r0, [r4, #0]
  __HAL_LOCK(htim);
2400ca88:	f884 303c 	strb.w	r3, [r4, #60]	@ 0x3c
    TIM_TI1_SetConfig(htim->Instance,
2400ca8c:	68eb      	ldr	r3, [r5, #12]
2400ca8e:	e9d1 1200 	ldrd	r1, r2, [r1]
  if (Channel == TIM_CHANNEL_1)
2400ca92:	b987      	cbnz	r7, 2400cab6 <HAL_TIM_IC_ConfigChannel+0x4a>
    TIM_TI1_SetConfig(htim->Instance,
2400ca94:	f7ff ffaf 	bl	2400c9f6 <TIM_TI1_SetConfig>
    htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;
2400ca98:	6983      	ldr	r3, [r0, #24]
    htim->Instance->CCMR1 |= sConfig->ICPrescaler;
2400ca9a:	68aa      	ldr	r2, [r5, #8]
    htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;
2400ca9c:	f023 030c 	bic.w	r3, r3, #12
2400caa0:	6183      	str	r3, [r0, #24]
    htim->Instance->CCMR1 |= sConfig->ICPrescaler;
2400caa2:	6983      	ldr	r3, [r0, #24]
2400caa4:	4313      	orrs	r3, r2
    htim->Instance->CCMR1 |= (sConfig->ICPrescaler << 8U);
2400caa6:	6183      	str	r3, [r0, #24]
  htim->State = HAL_TIM_STATE_READY;
2400caa8:	2301      	movs	r3, #1
  __HAL_UNLOCK(htim);
2400caaa:	2000      	movs	r0, #0
  htim->State = HAL_TIM_STATE_READY;
2400caac:	f884 303d 	strb.w	r3, [r4, #61]	@ 0x3d
  __HAL_UNLOCK(htim);
2400cab0:	f884 003c 	strb.w	r0, [r4, #60]	@ 0x3c
}
2400cab4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  else if (Channel == TIM_CHANNEL_2)
2400cab6:	2f04      	cmp	r7, #4
    htim->Instance->CCMR1 |= (sConfig->ICPrescaler << 8U);
2400cab8:	68ae      	ldr	r6, [r5, #8]
  TIMx->CCER &= ~TIM_CCER_CC2E;
2400caba:	6a05      	ldr	r5, [r0, #32]
  else if (Channel == TIM_CHANNEL_2)
2400cabc:	d11d      	bne.n	2400cafa <HAL_TIM_IC_ConfigChannel+0x8e>
  TIMx->CCER &= ~TIM_CCER_CC2E;
2400cabe:	f025 0510 	bic.w	r5, r5, #16
  tmpccmr1 |= ((TIM_ICFilter << 12U) & TIM_CCMR1_IC2F);
2400cac2:	031b      	lsls	r3, r3, #12
  tmpccer |= ((TIM_ICPolarity << 4U) & (TIM_CCER_CC2P | TIM_CCER_CC2NP));
2400cac4:	0109      	lsls	r1, r1, #4
  TIMx->CCER &= ~TIM_CCER_CC2E;
2400cac6:	6205      	str	r5, [r0, #32]
  tmpccmr1 |= ((TIM_ICFilter << 12U) & TIM_CCMR1_IC2F);
2400cac8:	b29b      	uxth	r3, r3
  tmpccmr1 = TIMx->CCMR1;
2400caca:	6985      	ldr	r5, [r0, #24]
  tmpccer |= ((TIM_ICPolarity << 4U) & (TIM_CCER_CC2P | TIM_CCER_CC2NP));
2400cacc:	f001 01a0 	and.w	r1, r1, #160	@ 0xa0
  tmpccer = TIMx->CCER;
2400cad0:	6a07      	ldr	r7, [r0, #32]
  tmpccmr1 &= ~TIM_CCMR1_CC2S;
2400cad2:	f425 7540 	bic.w	r5, r5, #768	@ 0x300
  tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
2400cad6:	f027 07a0 	bic.w	r7, r7, #160	@ 0xa0
  tmpccmr1 |= (TIM_ICSelection << 8U);
2400cada:	ea45 2502 	orr.w	r5, r5, r2, lsl #8
  tmpccer |= ((TIM_ICPolarity << 4U) & (TIM_CCER_CC2P | TIM_CCER_CC2NP));
2400cade:	4339      	orrs	r1, r7
  tmpccmr1 &= ~TIM_CCMR1_IC2F;
2400cae0:	f425 4570 	bic.w	r5, r5, #61440	@ 0xf000
  tmpccmr1 |= ((TIM_ICFilter << 12U) & TIM_CCMR1_IC2F);
2400cae4:	432b      	orrs	r3, r5
  TIMx->CCMR1 = tmpccmr1 ;
2400cae6:	6183      	str	r3, [r0, #24]
  TIMx->CCER = tmpccer;
2400cae8:	6201      	str	r1, [r0, #32]
    htim->Instance->CCMR1 &= ~TIM_CCMR1_IC2PSC;
2400caea:	6983      	ldr	r3, [r0, #24]
2400caec:	f423 6340 	bic.w	r3, r3, #3072	@ 0xc00
2400caf0:	6183      	str	r3, [r0, #24]
    htim->Instance->CCMR1 |= (sConfig->ICPrescaler << 8U);
2400caf2:	6983      	ldr	r3, [r0, #24]
2400caf4:	ea43 2306 	orr.w	r3, r3, r6, lsl #8
2400caf8:	e7d5      	b.n	2400caa6 <HAL_TIM_IC_ConfigChannel+0x3a>
  else if (Channel == TIM_CHANNEL_3)
2400cafa:	2f08      	cmp	r7, #8
2400cafc:	d11c      	bne.n	2400cb38 <HAL_TIM_IC_ConfigChannel+0xcc>
  TIMx->CCER &= ~TIM_CCER_CC3E;
2400cafe:	f425 7580 	bic.w	r5, r5, #256	@ 0x100
  tmpccmr2 |= ((TIM_ICFilter << 4U) & TIM_CCMR2_IC3F);
2400cb02:	011b      	lsls	r3, r3, #4
  tmpccer |= ((TIM_ICPolarity << 8U) & (TIM_CCER_CC3P | TIM_CCER_CC3NP));
2400cb04:	0209      	lsls	r1, r1, #8
  TIMx->CCER &= ~TIM_CCER_CC3E;
2400cb06:	6205      	str	r5, [r0, #32]
  tmpccmr2 |= ((TIM_ICFilter << 4U) & TIM_CCMR2_IC3F);
2400cb08:	b2db      	uxtb	r3, r3
  tmpccmr2 = TIMx->CCMR2;
2400cb0a:	69c5      	ldr	r5, [r0, #28]
  tmpccer |= ((TIM_ICPolarity << 8U) & (TIM_CCER_CC3P | TIM_CCER_CC3NP));
2400cb0c:	f401 6120 	and.w	r1, r1, #2560	@ 0xa00
  tmpccer = TIMx->CCER;
2400cb10:	6a07      	ldr	r7, [r0, #32]
  tmpccmr2 &= ~TIM_CCMR2_CC3S;
2400cb12:	f025 0503 	bic.w	r5, r5, #3
  tmpccer &= ~(TIM_CCER_CC3P | TIM_CCER_CC3NP);
2400cb16:	f427 6720 	bic.w	r7, r7, #2560	@ 0xa00
  tmpccmr2 |= TIM_ICSelection;
2400cb1a:	4315      	orrs	r5, r2
  tmpccer |= ((TIM_ICPolarity << 8U) & (TIM_CCER_CC3P | TIM_CCER_CC3NP));
2400cb1c:	4339      	orrs	r1, r7
  tmpccmr2 &= ~TIM_CCMR2_IC3F;
2400cb1e:	f025 05f0 	bic.w	r5, r5, #240	@ 0xf0
  tmpccmr2 |= ((TIM_ICFilter << 4U) & TIM_CCMR2_IC3F);
2400cb22:	432b      	orrs	r3, r5
  TIMx->CCMR2 = tmpccmr2;
2400cb24:	61c3      	str	r3, [r0, #28]
  TIMx->CCER = tmpccer;
2400cb26:	6201      	str	r1, [r0, #32]
    htim->Instance->CCMR2 &= ~TIM_CCMR2_IC3PSC;
2400cb28:	69c3      	ldr	r3, [r0, #28]
2400cb2a:	f023 030c 	bic.w	r3, r3, #12
2400cb2e:	61c3      	str	r3, [r0, #28]
    htim->Instance->CCMR2 |= sConfig->ICPrescaler;
2400cb30:	69c3      	ldr	r3, [r0, #28]
2400cb32:	4333      	orrs	r3, r6
    htim->Instance->CCMR2 |= (sConfig->ICPrescaler << 8U);
2400cb34:	61c3      	str	r3, [r0, #28]
2400cb36:	e7b7      	b.n	2400caa8 <HAL_TIM_IC_ConfigChannel+0x3c>
  TIMx->CCER &= ~TIM_CCER_CC4E;
2400cb38:	f425 5580 	bic.w	r5, r5, #4096	@ 0x1000
  tmpccmr2 |= ((TIM_ICFilter << 12U) & TIM_CCMR2_IC4F);
2400cb3c:	031b      	lsls	r3, r3, #12
  tmpccer |= ((TIM_ICPolarity << 12U) & (TIM_CCER_CC4P | TIM_CCER_CC4NP));
2400cb3e:	0309      	lsls	r1, r1, #12
  TIMx->CCER &= ~TIM_CCER_CC4E;
2400cb40:	6205      	str	r5, [r0, #32]
  tmpccmr2 |= ((TIM_ICFilter << 12U) & TIM_CCMR2_IC4F);
2400cb42:	b29b      	uxth	r3, r3
  tmpccmr2 = TIMx->CCMR2;
2400cb44:	69c5      	ldr	r5, [r0, #28]
  tmpccer |= ((TIM_ICPolarity << 12U) & (TIM_CCER_CC4P | TIM_CCER_CC4NP));
2400cb46:	f401 4120 	and.w	r1, r1, #40960	@ 0xa000
  tmpccer = TIMx->CCER;
2400cb4a:	6a07      	ldr	r7, [r0, #32]
  tmpccmr2 &= ~TIM_CCMR2_CC4S;
2400cb4c:	f425 7540 	bic.w	r5, r5, #768	@ 0x300
  tmpccer &= ~(TIM_CCER_CC4P | TIM_CCER_CC4NP);
2400cb50:	f427 4720 	bic.w	r7, r7, #40960	@ 0xa000
  tmpccmr2 |= (TIM_ICSelection << 8U);
2400cb54:	ea45 2502 	orr.w	r5, r5, r2, lsl #8
  tmpccer |= ((TIM_ICPolarity << 12U) & (TIM_CCER_CC4P | TIM_CCER_CC4NP));
2400cb58:	4339      	orrs	r1, r7
  tmpccmr2 &= ~TIM_CCMR2_IC4F;
2400cb5a:	f425 4570 	bic.w	r5, r5, #61440	@ 0xf000
  tmpccmr2 |= ((TIM_ICFilter << 12U) & TIM_CCMR2_IC4F);
2400cb5e:	432b      	orrs	r3, r5
  TIMx->CCMR2 = tmpccmr2;
2400cb60:	61c3      	str	r3, [r0, #28]
  TIMx->CCER = tmpccer ;
2400cb62:	6201      	str	r1, [r0, #32]
    htim->Instance->CCMR2 &= ~TIM_CCMR2_IC4PSC;
2400cb64:	69c3      	ldr	r3, [r0, #28]
2400cb66:	f423 6340 	bic.w	r3, r3, #3072	@ 0xc00
2400cb6a:	61c3      	str	r3, [r0, #28]
    htim->Instance->CCMR2 |= (sConfig->ICPrescaler << 8U);
2400cb6c:	69c3      	ldr	r3, [r0, #28]
2400cb6e:	ea43 2306 	orr.w	r3, r3, r6, lsl #8
2400cb72:	e7df      	b.n	2400cb34 <HAL_TIM_IC_ConfigChannel+0xc8>

2400cb74 <HAL_TIM_OnePulse_ConfigChannel>:
  if (OutputChannel != InputChannel)
2400cb74:	429a      	cmp	r2, r3
{
2400cb76:	b570      	push	{r4, r5, r6, lr}
2400cb78:	4605      	mov	r5, r0
2400cb7a:	b088      	sub	sp, #32
2400cb7c:	460c      	mov	r4, r1
2400cb7e:	461e      	mov	r6, r3
  if (OutputChannel != InputChannel)
2400cb80:	f000 8081 	beq.w	2400cc86 <HAL_TIM_OnePulse_ConfigChannel+0x112>
    __HAL_LOCK(htim);
2400cb84:	f890 303c 	ldrb.w	r3, [r0, #60]	@ 0x3c
2400cb88:	2002      	movs	r0, #2
2400cb8a:	2b01      	cmp	r3, #1
2400cb8c:	d01c      	beq.n	2400cbc8 <HAL_TIM_OnePulse_ConfigChannel+0x54>
2400cb8e:	2301      	movs	r3, #1
    htim->State = HAL_TIM_STATE_BUSY;
2400cb90:	f885 003d 	strb.w	r0, [r5, #61]	@ 0x3d
    __HAL_LOCK(htim);
2400cb94:	f885 303c 	strb.w	r3, [r5, #60]	@ 0x3c
    temp1.OCMode = sConfig->OCMode;
2400cb98:	680b      	ldr	r3, [r1, #0]
2400cb9a:	9301      	str	r3, [sp, #4]
    temp1.Pulse = sConfig->Pulse;
2400cb9c:	684b      	ldr	r3, [r1, #4]
2400cb9e:	9302      	str	r3, [sp, #8]
    temp1.OCPolarity = sConfig->OCPolarity;
2400cba0:	688b      	ldr	r3, [r1, #8]
2400cba2:	9303      	str	r3, [sp, #12]
    temp1.OCNPolarity = sConfig->OCNPolarity;
2400cba4:	68cb      	ldr	r3, [r1, #12]
2400cba6:	9304      	str	r3, [sp, #16]
    temp1.OCIdleState = sConfig->OCIdleState;
2400cba8:	690b      	ldr	r3, [r1, #16]
2400cbaa:	9306      	str	r3, [sp, #24]
    temp1.OCNIdleState = sConfig->OCNIdleState;
2400cbac:	694b      	ldr	r3, [r1, #20]
2400cbae:	9307      	str	r3, [sp, #28]
    switch (OutputChannel)
2400cbb0:	b162      	cbz	r2, 2400cbcc <HAL_TIM_OnePulse_ConfigChannel+0x58>
2400cbb2:	2a04      	cmp	r2, #4
2400cbb4:	d00f      	beq.n	2400cbd6 <HAL_TIM_OnePulse_ConfigChannel+0x62>
    switch (InputChannel)
2400cbb6:	b19e      	cbz	r6, 2400cbe0 <HAL_TIM_OnePulse_ConfigChannel+0x6c>
2400cbb8:	2e04      	cmp	r6, #4
2400cbba:	d030      	beq.n	2400cc1e <HAL_TIM_OnePulse_ConfigChannel+0xaa>
    htim->State = HAL_TIM_STATE_READY;
2400cbbc:	2301      	movs	r3, #1
    __HAL_UNLOCK(htim);
2400cbbe:	2000      	movs	r0, #0
    htim->State = HAL_TIM_STATE_READY;
2400cbc0:	f885 303d 	strb.w	r3, [r5, #61]	@ 0x3d
    __HAL_UNLOCK(htim);
2400cbc4:	f885 003c 	strb.w	r0, [r5, #60]	@ 0x3c
}
2400cbc8:	b008      	add	sp, #32
2400cbca:	bd70      	pop	{r4, r5, r6, pc}
        TIM_OC1_SetConfig(htim->Instance, &temp1);
2400cbcc:	a901      	add	r1, sp, #4
2400cbce:	6828      	ldr	r0, [r5, #0]
2400cbd0:	f7fe fcea 	bl	2400b5a8 <TIM_OC1_SetConfig>
        break;
2400cbd4:	e7ef      	b.n	2400cbb6 <HAL_TIM_OnePulse_ConfigChannel+0x42>
        TIM_OC2_SetConfig(htim->Instance, &temp1);
2400cbd6:	a901      	add	r1, sp, #4
2400cbd8:	6828      	ldr	r0, [r5, #0]
2400cbda:	f7ff fe14 	bl	2400c806 <TIM_OC2_SetConfig>
        break;
2400cbde:	e7ea      	b.n	2400cbb6 <HAL_TIM_OnePulse_ConfigChannel+0x42>
        TIM_TI1_SetConfig(htim->Instance, sConfig->ICPolarity,
2400cbe0:	6828      	ldr	r0, [r5, #0]
2400cbe2:	69a1      	ldr	r1, [r4, #24]
2400cbe4:	e9d4 2307 	ldrd	r2, r3, [r4, #28]
2400cbe8:	f7ff ff05 	bl	2400c9f6 <TIM_TI1_SetConfig>
        htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;
2400cbec:	6983      	ldr	r3, [r0, #24]
2400cbee:	f023 030c 	bic.w	r3, r3, #12
2400cbf2:	6183      	str	r3, [r0, #24]
        htim->Instance->SMCR &= ~TIM_SMCR_TS;
2400cbf4:	6883      	ldr	r3, [r0, #8]
2400cbf6:	f423 1340 	bic.w	r3, r3, #3145728	@ 0x300000
2400cbfa:	f023 0370 	bic.w	r3, r3, #112	@ 0x70
2400cbfe:	6083      	str	r3, [r0, #8]
        htim->Instance->SMCR |= TIM_TS_TI1FP1;
2400cc00:	6883      	ldr	r3, [r0, #8]
2400cc02:	f043 0350 	orr.w	r3, r3, #80	@ 0x50
2400cc06:	6083      	str	r3, [r0, #8]
        htim->Instance->SMCR &= ~TIM_SMCR_SMS;
2400cc08:	6883      	ldr	r3, [r0, #8]
2400cc0a:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
2400cc0e:	f023 0307 	bic.w	r3, r3, #7
2400cc12:	6083      	str	r3, [r0, #8]
        htim->Instance->SMCR |= TIM_SLAVEMODE_TRIGGER;
2400cc14:	6883      	ldr	r3, [r0, #8]
2400cc16:	f043 0306 	orr.w	r3, r3, #6
2400cc1a:	6083      	str	r3, [r0, #8]
        break;
2400cc1c:	e7ce      	b.n	2400cbbc <HAL_TIM_OnePulse_ConfigChannel+0x48>
        TIM_TI2_SetConfig(htim->Instance, sConfig->ICPolarity,
2400cc1e:	682b      	ldr	r3, [r5, #0]
2400cc20:	6a21      	ldr	r1, [r4, #32]
  TIMx->CCER &= ~TIM_CCER_CC2E;
2400cc22:	6a18      	ldr	r0, [r3, #32]
  tmpccmr1 |= ((TIM_ICFilter << 12U) & TIM_CCMR1_IC2F);
2400cc24:	0309      	lsls	r1, r1, #12
  TIMx->CCER &= ~TIM_CCER_CC2E;
2400cc26:	f020 0010 	bic.w	r0, r0, #16
  tmpccmr1 |= ((TIM_ICFilter << 12U) & TIM_CCMR1_IC2F);
2400cc2a:	b289      	uxth	r1, r1
        TIM_TI2_SetConfig(htim->Instance, sConfig->ICPolarity,
2400cc2c:	e9d4 2606 	ldrd	r2, r6, [r4, #24]
  TIMx->CCER &= ~TIM_CCER_CC2E;
2400cc30:	6218      	str	r0, [r3, #32]
  tmpccmr1 = TIMx->CCMR1;
2400cc32:	6998      	ldr	r0, [r3, #24]
  tmpccer |= ((TIM_ICPolarity << 4U) & (TIM_CCER_CC2P | TIM_CCER_CC2NP));
2400cc34:	0112      	lsls	r2, r2, #4
  tmpccer = TIMx->CCER;
2400cc36:	6a1c      	ldr	r4, [r3, #32]
  tmpccmr1 &= ~TIM_CCMR1_CC2S;
2400cc38:	f420 7040 	bic.w	r0, r0, #768	@ 0x300
  tmpccer |= ((TIM_ICPolarity << 4U) & (TIM_CCER_CC2P | TIM_CCER_CC2NP));
2400cc3c:	f002 02a0 	and.w	r2, r2, #160	@ 0xa0
  tmpccmr1 |= (TIM_ICSelection << 8U);
2400cc40:	ea40 2006 	orr.w	r0, r0, r6, lsl #8
  tmpccmr1 &= ~TIM_CCMR1_IC2F;
2400cc44:	f420 4070 	bic.w	r0, r0, #61440	@ 0xf000
  tmpccmr1 |= ((TIM_ICFilter << 12U) & TIM_CCMR1_IC2F);
2400cc48:	4301      	orrs	r1, r0
  tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
2400cc4a:	f024 00a0 	bic.w	r0, r4, #160	@ 0xa0
  tmpccer |= ((TIM_ICPolarity << 4U) & (TIM_CCER_CC2P | TIM_CCER_CC2NP));
2400cc4e:	4302      	orrs	r2, r0
  TIMx->CCMR1 = tmpccmr1 ;
2400cc50:	6199      	str	r1, [r3, #24]
  TIMx->CCER = tmpccer;
2400cc52:	621a      	str	r2, [r3, #32]
        htim->Instance->CCMR1 &= ~TIM_CCMR1_IC2PSC;
2400cc54:	699a      	ldr	r2, [r3, #24]
2400cc56:	f422 6240 	bic.w	r2, r2, #3072	@ 0xc00
2400cc5a:	619a      	str	r2, [r3, #24]
        htim->Instance->SMCR &= ~TIM_SMCR_TS;
2400cc5c:	689a      	ldr	r2, [r3, #8]
2400cc5e:	f422 1240 	bic.w	r2, r2, #3145728	@ 0x300000
2400cc62:	f022 0270 	bic.w	r2, r2, #112	@ 0x70
2400cc66:	609a      	str	r2, [r3, #8]
        htim->Instance->SMCR |= TIM_TS_TI2FP2;
2400cc68:	689a      	ldr	r2, [r3, #8]
2400cc6a:	f042 0260 	orr.w	r2, r2, #96	@ 0x60
2400cc6e:	609a      	str	r2, [r3, #8]
        htim->Instance->SMCR &= ~TIM_SMCR_SMS;
2400cc70:	689a      	ldr	r2, [r3, #8]
2400cc72:	f422 3280 	bic.w	r2, r2, #65536	@ 0x10000
2400cc76:	f022 0207 	bic.w	r2, r2, #7
2400cc7a:	609a      	str	r2, [r3, #8]
        htim->Instance->SMCR |= TIM_SLAVEMODE_TRIGGER;
2400cc7c:	689a      	ldr	r2, [r3, #8]
2400cc7e:	f042 0206 	orr.w	r2, r2, #6
2400cc82:	609a      	str	r2, [r3, #8]
        break;
2400cc84:	e79a      	b.n	2400cbbc <HAL_TIM_OnePulse_ConfigChannel+0x48>
    return HAL_ERROR;
2400cc86:	2001      	movs	r0, #1
2400cc88:	e79e      	b.n	2400cbc8 <HAL_TIM_OnePulse_ConfigChannel+0x54>

2400cc8a <TIM_ETR_SetConfig>:
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
2400cc8a:	430a      	orrs	r2, r1
{
2400cc8c:	b510      	push	{r4, lr}
  tmpsmcr = TIMx->SMCR;
2400cc8e:	6884      	ldr	r4, [r0, #8]
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
2400cc90:	ea42 2203 	orr.w	r2, r2, r3, lsl #8
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
2400cc94:	f424 447f 	bic.w	r4, r4, #65280	@ 0xff00
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
2400cc98:	4322      	orrs	r2, r4
  TIMx->SMCR = tmpsmcr;
2400cc9a:	6082      	str	r2, [r0, #8]
}
2400cc9c:	bd10      	pop	{r4, pc}

2400cc9e <HAL_TIM_ConfigOCrefClear>:
{
2400cc9e:	b570      	push	{r4, r5, r6, lr}
  __HAL_LOCK(htim);
2400cca0:	f890 303c 	ldrb.w	r3, [r0, #60]	@ 0x3c
{
2400cca4:	4604      	mov	r4, r0
2400cca6:	460d      	mov	r5, r1
2400cca8:	4616      	mov	r6, r2
  __HAL_LOCK(htim);
2400ccaa:	2b01      	cmp	r3, #1
2400ccac:	f04f 0002 	mov.w	r0, #2
2400ccb0:	d024      	beq.n	2400ccfc <HAL_TIM_ConfigOCrefClear+0x5e>
2400ccb2:	2301      	movs	r3, #1
  htim->State = HAL_TIM_STATE_BUSY;
2400ccb4:	f884 003d 	strb.w	r0, [r4, #61]	@ 0x3d
  __HAL_LOCK(htim);
2400ccb8:	f884 303c 	strb.w	r3, [r4, #60]	@ 0x3c
  switch (sClearInputConfig->ClearInputSource)
2400ccbc:	6848      	ldr	r0, [r1, #4]
2400ccbe:	b180      	cbz	r0, 2400cce2 <HAL_TIM_ConfigOCrefClear+0x44>
2400ccc0:	4298      	cmp	r0, r3
2400ccc2:	d014      	beq.n	2400ccee <HAL_TIM_ConfigOCrefClear+0x50>
  switch (Channel)
2400ccc4:	2e0c      	cmp	r6, #12
2400ccc6:	d04f      	beq.n	2400cd68 <HAL_TIM_ConfigOCrefClear+0xca>
2400ccc8:	d81f      	bhi.n	2400cd0a <HAL_TIM_ConfigOCrefClear+0x6c>
2400ccca:	2e04      	cmp	r6, #4
2400cccc:	d035      	beq.n	2400cd3a <HAL_TIM_ConfigOCrefClear+0x9c>
2400ccce:	2e08      	cmp	r6, #8
2400ccd0:	d03e      	beq.n	2400cd50 <HAL_TIM_ConfigOCrefClear+0xb2>
2400ccd2:	b336      	cbz	r6, 2400cd22 <HAL_TIM_ConfigOCrefClear+0x84>
  htim->State = HAL_TIM_STATE_READY;
2400ccd4:	2301      	movs	r3, #1
  __HAL_UNLOCK(htim);
2400ccd6:	2000      	movs	r0, #0
  htim->State = HAL_TIM_STATE_READY;
2400ccd8:	f884 303d 	strb.w	r3, [r4, #61]	@ 0x3d
  __HAL_UNLOCK(htim);
2400ccdc:	f884 003c 	strb.w	r0, [r4, #60]	@ 0x3c
  return HAL_OK;
2400cce0:	e00c      	b.n	2400ccfc <HAL_TIM_ConfigOCrefClear+0x5e>
      CLEAR_BIT(htim->Instance->SMCR, (TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP));
2400cce2:	6822      	ldr	r2, [r4, #0]
2400cce4:	6893      	ldr	r3, [r2, #8]
2400cce6:	f423 437f 	bic.w	r3, r3, #65280	@ 0xff00
2400ccea:	6093      	str	r3, [r2, #8]
      break;
2400ccec:	e7ea      	b.n	2400ccc4 <HAL_TIM_ConfigOCrefClear+0x26>
      if (sClearInputConfig->ClearInputPrescaler != TIM_CLEARINPUTPRESCALER_DIV1)
2400ccee:	68c9      	ldr	r1, [r1, #12]
2400ccf0:	b129      	cbz	r1, 2400ccfe <HAL_TIM_ConfigOCrefClear+0x60>
        __HAL_UNLOCK(htim);
2400ccf2:	2300      	movs	r3, #0
        htim->State = HAL_TIM_STATE_READY;
2400ccf4:	f884 003d 	strb.w	r0, [r4, #61]	@ 0x3d
        __HAL_UNLOCK(htim);
2400ccf8:	f884 303c 	strb.w	r3, [r4, #60]	@ 0x3c
}
2400ccfc:	bd70      	pop	{r4, r5, r6, pc}
      TIM_ETR_SetConfig(htim->Instance,
2400ccfe:	692b      	ldr	r3, [r5, #16]
2400cd00:	68aa      	ldr	r2, [r5, #8]
2400cd02:	6820      	ldr	r0, [r4, #0]
2400cd04:	f7ff ffc1 	bl	2400cc8a <TIM_ETR_SetConfig>
      break;
2400cd08:	e7dc      	b.n	2400ccc4 <HAL_TIM_ConfigOCrefClear+0x26>
  switch (Channel)
2400cd0a:	2e10      	cmp	r6, #16
2400cd0c:	d037      	beq.n	2400cd7e <HAL_TIM_ConfigOCrefClear+0xe0>
2400cd0e:	2e14      	cmp	r6, #20
2400cd10:	d1e0      	bne.n	2400ccd4 <HAL_TIM_ConfigOCrefClear+0x36>
      if (sClearInputConfig->ClearInputState != (uint32_t)DISABLE)
2400cd12:	682a      	ldr	r2, [r5, #0]
      CLEAR_BIT(htim->Instance->SMCR, (TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP));
2400cd14:	6823      	ldr	r3, [r4, #0]
      if (sClearInputConfig->ClearInputState != (uint32_t)DISABLE)
2400cd16:	2a00      	cmp	r2, #0
2400cd18:	d03d      	beq.n	2400cd96 <HAL_TIM_ConfigOCrefClear+0xf8>
        SET_BIT(htim->Instance->CCMR3, TIM_CCMR3_OC6CE);
2400cd1a:	6d5a      	ldr	r2, [r3, #84]	@ 0x54
2400cd1c:	f442 4200 	orr.w	r2, r2, #32768	@ 0x8000
2400cd20:	e033      	b.n	2400cd8a <HAL_TIM_ConfigOCrefClear+0xec>
      if (sClearInputConfig->ClearInputState != (uint32_t)DISABLE)
2400cd22:	682a      	ldr	r2, [r5, #0]
      CLEAR_BIT(htim->Instance->SMCR, (TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP));
2400cd24:	6823      	ldr	r3, [r4, #0]
      if (sClearInputConfig->ClearInputState != (uint32_t)DISABLE)
2400cd26:	b122      	cbz	r2, 2400cd32 <HAL_TIM_ConfigOCrefClear+0x94>
        SET_BIT(htim->Instance->CCMR1, TIM_CCMR1_OC1CE);
2400cd28:	699a      	ldr	r2, [r3, #24]
2400cd2a:	f042 0280 	orr.w	r2, r2, #128	@ 0x80
        SET_BIT(htim->Instance->CCMR1, TIM_CCMR1_OC2CE);
2400cd2e:	619a      	str	r2, [r3, #24]
2400cd30:	e7d0      	b.n	2400ccd4 <HAL_TIM_ConfigOCrefClear+0x36>
        CLEAR_BIT(htim->Instance->CCMR1, TIM_CCMR1_OC1CE);
2400cd32:	699a      	ldr	r2, [r3, #24]
2400cd34:	f022 0280 	bic.w	r2, r2, #128	@ 0x80
2400cd38:	e7f9      	b.n	2400cd2e <HAL_TIM_ConfigOCrefClear+0x90>
      if (sClearInputConfig->ClearInputState != (uint32_t)DISABLE)
2400cd3a:	682a      	ldr	r2, [r5, #0]
      CLEAR_BIT(htim->Instance->SMCR, (TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP));
2400cd3c:	6823      	ldr	r3, [r4, #0]
      if (sClearInputConfig->ClearInputState != (uint32_t)DISABLE)
2400cd3e:	b11a      	cbz	r2, 2400cd48 <HAL_TIM_ConfigOCrefClear+0xaa>
        SET_BIT(htim->Instance->CCMR1, TIM_CCMR1_OC2CE);
2400cd40:	699a      	ldr	r2, [r3, #24]
2400cd42:	f442 4200 	orr.w	r2, r2, #32768	@ 0x8000
2400cd46:	e7f2      	b.n	2400cd2e <HAL_TIM_ConfigOCrefClear+0x90>
        CLEAR_BIT(htim->Instance->CCMR1, TIM_CCMR1_OC2CE);
2400cd48:	699a      	ldr	r2, [r3, #24]
2400cd4a:	f422 4200 	bic.w	r2, r2, #32768	@ 0x8000
2400cd4e:	e7ee      	b.n	2400cd2e <HAL_TIM_ConfigOCrefClear+0x90>
      if (sClearInputConfig->ClearInputState != (uint32_t)DISABLE)
2400cd50:	682a      	ldr	r2, [r5, #0]
      CLEAR_BIT(htim->Instance->SMCR, (TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP));
2400cd52:	6823      	ldr	r3, [r4, #0]
      if (sClearInputConfig->ClearInputState != (uint32_t)DISABLE)
2400cd54:	b122      	cbz	r2, 2400cd60 <HAL_TIM_ConfigOCrefClear+0xc2>
        SET_BIT(htim->Instance->CCMR2, TIM_CCMR2_OC3CE);
2400cd56:	69da      	ldr	r2, [r3, #28]
2400cd58:	f042 0280 	orr.w	r2, r2, #128	@ 0x80
        CLEAR_BIT(htim->Instance->CCMR2, TIM_CCMR2_OC4CE);
2400cd5c:	61da      	str	r2, [r3, #28]
2400cd5e:	e7b9      	b.n	2400ccd4 <HAL_TIM_ConfigOCrefClear+0x36>
        CLEAR_BIT(htim->Instance->CCMR2, TIM_CCMR2_OC3CE);
2400cd60:	69da      	ldr	r2, [r3, #28]
2400cd62:	f022 0280 	bic.w	r2, r2, #128	@ 0x80
2400cd66:	e7f9      	b.n	2400cd5c <HAL_TIM_ConfigOCrefClear+0xbe>
      if (sClearInputConfig->ClearInputState != (uint32_t)DISABLE)
2400cd68:	682a      	ldr	r2, [r5, #0]
      CLEAR_BIT(htim->Instance->SMCR, (TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP));
2400cd6a:	6823      	ldr	r3, [r4, #0]
      if (sClearInputConfig->ClearInputState != (uint32_t)DISABLE)
2400cd6c:	b11a      	cbz	r2, 2400cd76 <HAL_TIM_ConfigOCrefClear+0xd8>
        SET_BIT(htim->Instance->CCMR2, TIM_CCMR2_OC4CE);
2400cd6e:	69da      	ldr	r2, [r3, #28]
2400cd70:	f442 4200 	orr.w	r2, r2, #32768	@ 0x8000
2400cd74:	e7f2      	b.n	2400cd5c <HAL_TIM_ConfigOCrefClear+0xbe>
        CLEAR_BIT(htim->Instance->CCMR2, TIM_CCMR2_OC4CE);
2400cd76:	69da      	ldr	r2, [r3, #28]
2400cd78:	f422 4200 	bic.w	r2, r2, #32768	@ 0x8000
2400cd7c:	e7ee      	b.n	2400cd5c <HAL_TIM_ConfigOCrefClear+0xbe>
      if (sClearInputConfig->ClearInputState != (uint32_t)DISABLE)
2400cd7e:	682a      	ldr	r2, [r5, #0]
      CLEAR_BIT(htim->Instance->SMCR, (TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP));
2400cd80:	6823      	ldr	r3, [r4, #0]
      if (sClearInputConfig->ClearInputState != (uint32_t)DISABLE)
2400cd82:	b122      	cbz	r2, 2400cd8e <HAL_TIM_ConfigOCrefClear+0xf0>
        SET_BIT(htim->Instance->CCMR3, TIM_CCMR3_OC5CE);
2400cd84:	6d5a      	ldr	r2, [r3, #84]	@ 0x54
2400cd86:	f042 0280 	orr.w	r2, r2, #128	@ 0x80
        CLEAR_BIT(htim->Instance->CCMR3, TIM_CCMR3_OC6CE);
2400cd8a:	655a      	str	r2, [r3, #84]	@ 0x54
2400cd8c:	e7a2      	b.n	2400ccd4 <HAL_TIM_ConfigOCrefClear+0x36>
        CLEAR_BIT(htim->Instance->CCMR3, TIM_CCMR3_OC5CE);
2400cd8e:	6d5a      	ldr	r2, [r3, #84]	@ 0x54
2400cd90:	f022 0280 	bic.w	r2, r2, #128	@ 0x80
2400cd94:	e7f9      	b.n	2400cd8a <HAL_TIM_ConfigOCrefClear+0xec>
        CLEAR_BIT(htim->Instance->CCMR3, TIM_CCMR3_OC6CE);
2400cd96:	6d5a      	ldr	r2, [r3, #84]	@ 0x54
2400cd98:	f422 4200 	bic.w	r2, r2, #32768	@ 0x8000
2400cd9c:	e7f5      	b.n	2400cd8a <HAL_TIM_ConfigOCrefClear+0xec>

2400cd9e <HAL_TIM_ConfigClockSource>:
{
2400cd9e:	b538      	push	{r3, r4, r5, lr}
  __HAL_LOCK(htim);
2400cda0:	f890 303c 	ldrb.w	r3, [r0, #60]	@ 0x3c
{
2400cda4:	4604      	mov	r4, r0
2400cda6:	2002      	movs	r0, #2
  __HAL_LOCK(htim);
2400cda8:	2b01      	cmp	r3, #1
2400cdaa:	d02b      	beq.n	2400ce04 <HAL_TIM_ConfigClockSource+0x66>
  htim->State = HAL_TIM_STATE_BUSY;
2400cdac:	f884 003d 	strb.w	r0, [r4, #61]	@ 0x3d
  __HAL_LOCK(htim);
2400cdb0:	2301      	movs	r3, #1
  tmpsmcr = htim->Instance->SMCR;
2400cdb2:	6820      	ldr	r0, [r4, #0]
  __HAL_LOCK(htim);
2400cdb4:	f884 303c 	strb.w	r3, [r4, #60]	@ 0x3c
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
2400cdb8:	4b4d      	ldr	r3, [pc, #308]	@ (2400cef0 <HAL_TIM_ConfigClockSource+0x152>)
  tmpsmcr = htim->Instance->SMCR;
2400cdba:	6882      	ldr	r2, [r0, #8]
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
2400cdbc:	4013      	ands	r3, r2
  htim->Instance->SMCR = tmpsmcr;
2400cdbe:	6083      	str	r3, [r0, #8]
  switch (sClockSourceConfig->ClockSource)
2400cdc0:	680b      	ldr	r3, [r1, #0]
2400cdc2:	2b60      	cmp	r3, #96	@ 0x60
2400cdc4:	d060      	beq.n	2400ce88 <HAL_TIM_ConfigClockSource+0xea>
2400cdc6:	d81e      	bhi.n	2400ce06 <HAL_TIM_ConfigClockSource+0x68>
2400cdc8:	2b40      	cmp	r3, #64	@ 0x40
2400cdca:	d077      	beq.n	2400cebc <HAL_TIM_ConfigClockSource+0x11e>
2400cdcc:	d812      	bhi.n	2400cdf4 <HAL_TIM_ConfigClockSource+0x56>
2400cdce:	2b20      	cmp	r3, #32
2400cdd0:	d003      	beq.n	2400cdda <HAL_TIM_ConfigClockSource+0x3c>
2400cdd2:	d80c      	bhi.n	2400cdee <HAL_TIM_ConfigClockSource+0x50>
2400cdd4:	f033 0210 	bics.w	r2, r3, #16
2400cdd8:	d10e      	bne.n	2400cdf8 <HAL_TIM_ConfigClockSource+0x5a>
  tmpsmcr = TIMx->SMCR;
2400cdda:	6882      	ldr	r2, [r0, #8]
  tmpsmcr &= ~TIM_SMCR_TS;
2400cddc:	f422 1240 	bic.w	r2, r2, #3145728	@ 0x300000
2400cde0:	f022 0270 	bic.w	r2, r2, #112	@ 0x70
  tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
2400cde4:	431a      	orrs	r2, r3
2400cde6:	f042 0207 	orr.w	r2, r2, #7
  TIMx->SMCR = tmpsmcr;
2400cdea:	6082      	str	r2, [r0, #8]
}
2400cdec:	e004      	b.n	2400cdf8 <HAL_TIM_ConfigClockSource+0x5a>
  switch (sClockSourceConfig->ClockSource)
2400cdee:	2b30      	cmp	r3, #48	@ 0x30
2400cdf0:	d0f3      	beq.n	2400cdda <HAL_TIM_ConfigClockSource+0x3c>
2400cdf2:	e001      	b.n	2400cdf8 <HAL_TIM_ConfigClockSource+0x5a>
2400cdf4:	2b50      	cmp	r3, #80	@ 0x50
2400cdf6:	d02e      	beq.n	2400ce56 <HAL_TIM_ConfigClockSource+0xb8>
  htim->State = HAL_TIM_STATE_READY;
2400cdf8:	2301      	movs	r3, #1
  __HAL_UNLOCK(htim);
2400cdfa:	2000      	movs	r0, #0
  htim->State = HAL_TIM_STATE_READY;
2400cdfc:	f884 303d 	strb.w	r3, [r4, #61]	@ 0x3d
  __HAL_UNLOCK(htim);
2400ce00:	f884 003c 	strb.w	r0, [r4, #60]	@ 0x3c
}
2400ce04:	bd38      	pop	{r3, r4, r5, pc}
  switch (sClockSourceConfig->ClockSource)
2400ce06:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
2400ce0a:	d01b      	beq.n	2400ce44 <HAL_TIM_ConfigClockSource+0xa6>
2400ce0c:	d80b      	bhi.n	2400ce26 <HAL_TIM_ConfigClockSource+0x88>
2400ce0e:	2b70      	cmp	r3, #112	@ 0x70
2400ce10:	d1f2      	bne.n	2400cdf8 <HAL_TIM_ConfigClockSource+0x5a>
      TIM_ETR_SetConfig(htim->Instance,
2400ce12:	68cb      	ldr	r3, [r1, #12]
2400ce14:	e9d1 2101 	ldrd	r2, r1, [r1, #4]
2400ce18:	f7ff ff37 	bl	2400cc8a <TIM_ETR_SetConfig>
      tmpsmcr = htim->Instance->SMCR;
2400ce1c:	6883      	ldr	r3, [r0, #8]
      tmpsmcr |= (TIM_SLAVEMODE_EXTERNAL1 | TIM_CLOCKSOURCE_ETRMODE1);
2400ce1e:	f043 0377 	orr.w	r3, r3, #119	@ 0x77
      htim->Instance->SMCR |= TIM_SMCR_ECE;
2400ce22:	6083      	str	r3, [r0, #8]
      break;
2400ce24:	e7e8      	b.n	2400cdf8 <HAL_TIM_ConfigClockSource+0x5a>
  switch (sClockSourceConfig->ClockSource)
2400ce26:	4a33      	ldr	r2, [pc, #204]	@ (2400cef4 <HAL_TIM_ConfigClockSource+0x156>)
2400ce28:	4293      	cmp	r3, r2
2400ce2a:	d0d6      	beq.n	2400cdda <HAL_TIM_ConfigClockSource+0x3c>
2400ce2c:	d804      	bhi.n	2400ce38 <HAL_TIM_ConfigClockSource+0x9a>
2400ce2e:	f023 0210 	bic.w	r2, r3, #16
2400ce32:	f5b2 1f80 	cmp.w	r2, #1048576	@ 0x100000
2400ce36:	e7db      	b.n	2400cdf0 <HAL_TIM_ConfigClockSource+0x52>
2400ce38:	4a2f      	ldr	r2, [pc, #188]	@ (2400cef8 <HAL_TIM_ConfigClockSource+0x15a>)
2400ce3a:	4293      	cmp	r3, r2
2400ce3c:	d0cd      	beq.n	2400cdda <HAL_TIM_ConfigClockSource+0x3c>
2400ce3e:	3210      	adds	r2, #16
2400ce40:	4293      	cmp	r3, r2
2400ce42:	e7d5      	b.n	2400cdf0 <HAL_TIM_ConfigClockSource+0x52>
      TIM_ETR_SetConfig(htim->Instance,
2400ce44:	68cb      	ldr	r3, [r1, #12]
2400ce46:	e9d1 2101 	ldrd	r2, r1, [r1, #4]
2400ce4a:	f7ff ff1e 	bl	2400cc8a <TIM_ETR_SetConfig>
      htim->Instance->SMCR |= TIM_SMCR_ECE;
2400ce4e:	6883      	ldr	r3, [r0, #8]
2400ce50:	f443 4380 	orr.w	r3, r3, #16384	@ 0x4000
2400ce54:	e7e5      	b.n	2400ce22 <HAL_TIM_ConfigClockSource+0x84>
      TIM_TI1_ConfigInputStage(htim->Instance,
2400ce56:	684a      	ldr	r2, [r1, #4]
2400ce58:	68cd      	ldr	r5, [r1, #12]
  tmpccer = TIMx->CCER;
2400ce5a:	6a01      	ldr	r1, [r0, #32]
  TIMx->CCER &= ~TIM_CCER_CC1E;
2400ce5c:	6a03      	ldr	r3, [r0, #32]
  tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
2400ce5e:	f021 010a 	bic.w	r1, r1, #10
  TIMx->CCER &= ~TIM_CCER_CC1E;
2400ce62:	f023 0301 	bic.w	r3, r3, #1
  tmpccer |= TIM_ICPolarity;
2400ce66:	430a      	orrs	r2, r1
  TIMx->CCER &= ~TIM_CCER_CC1E;
2400ce68:	6203      	str	r3, [r0, #32]
  tmpccmr1 = TIMx->CCMR1;
2400ce6a:	6983      	ldr	r3, [r0, #24]
  tmpccmr1 &= ~TIM_CCMR1_IC1F;
2400ce6c:	f023 03f0 	bic.w	r3, r3, #240	@ 0xf0
  tmpccmr1 |= (TIM_ICFilter << 4U);
2400ce70:	ea43 1305 	orr.w	r3, r3, r5, lsl #4
  TIMx->CCMR1 = tmpccmr1;
2400ce74:	6183      	str	r3, [r0, #24]
  TIMx->CCER = tmpccer;
2400ce76:	6202      	str	r2, [r0, #32]
  tmpsmcr = TIMx->SMCR;
2400ce78:	6883      	ldr	r3, [r0, #8]
  tmpsmcr &= ~TIM_SMCR_TS;
2400ce7a:	f423 1340 	bic.w	r3, r3, #3145728	@ 0x300000
2400ce7e:	f023 0370 	bic.w	r3, r3, #112	@ 0x70
  tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
2400ce82:	f043 0357 	orr.w	r3, r3, #87	@ 0x57
  TIMx->SMCR = tmpsmcr;
2400ce86:	e7cc      	b.n	2400ce22 <HAL_TIM_ConfigClockSource+0x84>
  TIMx->CCER &= ~TIM_CCER_CC2E;
2400ce88:	6a03      	ldr	r3, [r0, #32]
      TIM_TI2_ConfigInputStage(htim->Instance,
2400ce8a:	684d      	ldr	r5, [r1, #4]
  TIMx->CCER &= ~TIM_CCER_CC2E;
2400ce8c:	f023 0310 	bic.w	r3, r3, #16
      TIM_TI2_ConfigInputStage(htim->Instance,
2400ce90:	68c9      	ldr	r1, [r1, #12]
  TIMx->CCER &= ~TIM_CCER_CC2E;
2400ce92:	6203      	str	r3, [r0, #32]
  tmpccmr1 = TIMx->CCMR1;
2400ce94:	6982      	ldr	r2, [r0, #24]
  tmpccer = TIMx->CCER;
2400ce96:	6a03      	ldr	r3, [r0, #32]
  tmpccmr1 &= ~TIM_CCMR1_IC2F;
2400ce98:	f422 4270 	bic.w	r2, r2, #61440	@ 0xf000
  tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
2400ce9c:	f023 03a0 	bic.w	r3, r3, #160	@ 0xa0
  tmpccmr1 |= (TIM_ICFilter << 12U);
2400cea0:	ea42 3201 	orr.w	r2, r2, r1, lsl #12
  tmpccer |= (TIM_ICPolarity << 4U);
2400cea4:	ea43 1305 	orr.w	r3, r3, r5, lsl #4
  TIMx->CCMR1 = tmpccmr1 ;
2400cea8:	6182      	str	r2, [r0, #24]
  TIMx->CCER = tmpccer;
2400ceaa:	6203      	str	r3, [r0, #32]
  tmpsmcr = TIMx->SMCR;
2400ceac:	6883      	ldr	r3, [r0, #8]
  tmpsmcr &= ~TIM_SMCR_TS;
2400ceae:	f423 1340 	bic.w	r3, r3, #3145728	@ 0x300000
2400ceb2:	f023 0370 	bic.w	r3, r3, #112	@ 0x70
  tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
2400ceb6:	f043 0367 	orr.w	r3, r3, #103	@ 0x67
  TIMx->SMCR = tmpsmcr;
2400ceba:	e7b2      	b.n	2400ce22 <HAL_TIM_ConfigClockSource+0x84>
      TIM_TI1_ConfigInputStage(htim->Instance,
2400cebc:	684a      	ldr	r2, [r1, #4]
2400cebe:	68cd      	ldr	r5, [r1, #12]
  tmpccer = TIMx->CCER;
2400cec0:	6a01      	ldr	r1, [r0, #32]
  TIMx->CCER &= ~TIM_CCER_CC1E;
2400cec2:	6a03      	ldr	r3, [r0, #32]
  tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
2400cec4:	f021 010a 	bic.w	r1, r1, #10
  TIMx->CCER &= ~TIM_CCER_CC1E;
2400cec8:	f023 0301 	bic.w	r3, r3, #1
  tmpccer |= TIM_ICPolarity;
2400cecc:	430a      	orrs	r2, r1
  TIMx->CCER &= ~TIM_CCER_CC1E;
2400cece:	6203      	str	r3, [r0, #32]
  tmpccmr1 = TIMx->CCMR1;
2400ced0:	6983      	ldr	r3, [r0, #24]
  tmpccmr1 &= ~TIM_CCMR1_IC1F;
2400ced2:	f023 03f0 	bic.w	r3, r3, #240	@ 0xf0
  tmpccmr1 |= (TIM_ICFilter << 4U);
2400ced6:	ea43 1305 	orr.w	r3, r3, r5, lsl #4
  TIMx->CCMR1 = tmpccmr1;
2400ceda:	6183      	str	r3, [r0, #24]
  TIMx->CCER = tmpccer;
2400cedc:	6202      	str	r2, [r0, #32]
  tmpsmcr = TIMx->SMCR;
2400cede:	6883      	ldr	r3, [r0, #8]
  tmpsmcr &= ~TIM_SMCR_TS;
2400cee0:	f423 1340 	bic.w	r3, r3, #3145728	@ 0x300000
2400cee4:	f023 0370 	bic.w	r3, r3, #112	@ 0x70
  tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
2400cee8:	f043 0347 	orr.w	r3, r3, #71	@ 0x47
  TIMx->SMCR = tmpsmcr;
2400ceec:	e799      	b.n	2400ce22 <HAL_TIM_ConfigClockSource+0x84>
2400ceee:	bf00      	nop
2400cef0:	ffce0088 	.word	0xffce0088
2400cef4:	00100020 	.word	0x00100020
2400cef8:	00100030 	.word	0x00100030

2400cefc <TIM_SlaveTimer_SetConfig.constprop.0>:
  tmpsmcr = htim->Instance->SMCR;
2400cefc:	6800      	ldr	r0, [r0, #0]
  tmpsmcr |= sSlaveConfig->InputTrigger;
2400cefe:	684a      	ldr	r2, [r1, #4]
  tmpsmcr = htim->Instance->SMCR;
2400cf00:	6883      	ldr	r3, [r0, #8]
  switch (sSlaveConfig->InputTrigger)
2400cf02:	2a60      	cmp	r2, #96	@ 0x60
  tmpsmcr &= ~TIM_SMCR_TS;
2400cf04:	f423 1340 	bic.w	r3, r3, #3145728	@ 0x300000
2400cf08:	f023 0370 	bic.w	r3, r3, #112	@ 0x70
  tmpsmcr |= sSlaveConfig->InputTrigger;
2400cf0c:	ea43 0302 	orr.w	r3, r3, r2
  tmpsmcr &= ~TIM_SMCR_SMS;
2400cf10:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
static HAL_StatusTypeDef TIM_SlaveTimer_SetConfig(TIM_HandleTypeDef *htim,
2400cf14:	b510      	push	{r4, lr}
  tmpsmcr &= ~TIM_SMCR_SMS;
2400cf16:	f023 0307 	bic.w	r3, r3, #7
  tmpsmcr |= sSlaveConfig->SlaveMode;
2400cf1a:	680c      	ldr	r4, [r1, #0]
2400cf1c:	ea43 0304 	orr.w	r3, r3, r4
  htim->Instance->SMCR = tmpsmcr;
2400cf20:	6083      	str	r3, [r0, #8]
  switch (sSlaveConfig->InputTrigger)
2400cf22:	d02e      	beq.n	2400cf82 <TIM_SlaveTimer_SetConfig.constprop.0+0x86>
2400cf24:	d805      	bhi.n	2400cf32 <TIM_SlaveTimer_SetConfig.constprop.0+0x36>
2400cf26:	2a40      	cmp	r2, #64	@ 0x40
2400cf28:	d00b      	beq.n	2400cf42 <TIM_SlaveTimer_SetConfig.constprop.0+0x46>
2400cf2a:	2a50      	cmp	r2, #80	@ 0x50
2400cf2c:	d019      	beq.n	2400cf62 <TIM_SlaveTimer_SetConfig.constprop.0+0x66>
  return HAL_OK;
2400cf2e:	2000      	movs	r0, #0
}
2400cf30:	bd10      	pop	{r4, pc}
  switch (sSlaveConfig->InputTrigger)
2400cf32:	2a70      	cmp	r2, #112	@ 0x70
2400cf34:	d1fb      	bne.n	2400cf2e <TIM_SlaveTimer_SetConfig.constprop.0+0x32>
      TIM_ETR_SetConfig(htim->Instance,
2400cf36:	690b      	ldr	r3, [r1, #16]
2400cf38:	e9d1 2102 	ldrd	r2, r1, [r1, #8]
2400cf3c:	f7ff fea5 	bl	2400cc8a <TIM_ETR_SetConfig>
      break;
2400cf40:	e7f5      	b.n	2400cf2e <TIM_SlaveTimer_SetConfig.constprop.0+0x32>
      if(sSlaveConfig->SlaveMode == TIM_SLAVEMODE_GATED)
2400cf42:	2c05      	cmp	r4, #5
2400cf44:	d030      	beq.n	2400cfa8 <TIM_SlaveTimer_SetConfig.constprop.0+0xac>
      tmpccer = htim->Instance->CCER;
2400cf46:	6a02      	ldr	r2, [r0, #32]
      htim->Instance->CCER &= ~TIM_CCER_CC1E;
2400cf48:	6a03      	ldr	r3, [r0, #32]
      tmpccmr1 |= ((sSlaveConfig->TriggerFilter) << 4U);
2400cf4a:	6909      	ldr	r1, [r1, #16]
      htim->Instance->CCER &= ~TIM_CCER_CC1E;
2400cf4c:	f023 0301 	bic.w	r3, r3, #1
2400cf50:	6203      	str	r3, [r0, #32]
      tmpccmr1 = htim->Instance->CCMR1;
2400cf52:	6983      	ldr	r3, [r0, #24]
      tmpccmr1 &= ~TIM_CCMR1_IC1F;
2400cf54:	f023 03f0 	bic.w	r3, r3, #240	@ 0xf0
      tmpccmr1 |= ((sSlaveConfig->TriggerFilter) << 4U);
2400cf58:	ea43 1301 	orr.w	r3, r3, r1, lsl #4
  TIMx->CCMR1 = tmpccmr1;
2400cf5c:	6183      	str	r3, [r0, #24]
  TIMx->CCER = tmpccer;
2400cf5e:	6202      	str	r2, [r0, #32]
}
2400cf60:	e7e5      	b.n	2400cf2e <TIM_SlaveTimer_SetConfig.constprop.0+0x32>
      TIM_TI1_ConfigInputStage(htim->Instance,
2400cf62:	688a      	ldr	r2, [r1, #8]
2400cf64:	690c      	ldr	r4, [r1, #16]
  tmpccer = TIMx->CCER;
2400cf66:	6a01      	ldr	r1, [r0, #32]
  TIMx->CCER &= ~TIM_CCER_CC1E;
2400cf68:	6a03      	ldr	r3, [r0, #32]
  tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
2400cf6a:	f021 010a 	bic.w	r1, r1, #10
  TIMx->CCER &= ~TIM_CCER_CC1E;
2400cf6e:	f023 0301 	bic.w	r3, r3, #1
  tmpccer |= TIM_ICPolarity;
2400cf72:	430a      	orrs	r2, r1
  TIMx->CCER &= ~TIM_CCER_CC1E;
2400cf74:	6203      	str	r3, [r0, #32]
  tmpccmr1 = TIMx->CCMR1;
2400cf76:	6983      	ldr	r3, [r0, #24]
  tmpccmr1 &= ~TIM_CCMR1_IC1F;
2400cf78:	f023 03f0 	bic.w	r3, r3, #240	@ 0xf0
  tmpccmr1 |= (TIM_ICFilter << 4U);
2400cf7c:	ea43 1304 	orr.w	r3, r3, r4, lsl #4
  tmpccer |= TIM_ICPolarity;
2400cf80:	e7ec      	b.n	2400cf5c <TIM_SlaveTimer_SetConfig.constprop.0+0x60>
  TIMx->CCER &= ~TIM_CCER_CC2E;
2400cf82:	6a03      	ldr	r3, [r0, #32]
      TIM_TI2_ConfigInputStage(htim->Instance,
2400cf84:	688c      	ldr	r4, [r1, #8]
  TIMx->CCER &= ~TIM_CCER_CC2E;
2400cf86:	f023 0310 	bic.w	r3, r3, #16
      TIM_TI2_ConfigInputStage(htim->Instance,
2400cf8a:	6909      	ldr	r1, [r1, #16]
  TIMx->CCER &= ~TIM_CCER_CC2E;
2400cf8c:	6203      	str	r3, [r0, #32]
  tmpccmr1 = TIMx->CCMR1;
2400cf8e:	6982      	ldr	r2, [r0, #24]
  tmpccer = TIMx->CCER;
2400cf90:	6a03      	ldr	r3, [r0, #32]
  tmpccmr1 &= ~TIM_CCMR1_IC2F;
2400cf92:	f422 4270 	bic.w	r2, r2, #61440	@ 0xf000
  tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
2400cf96:	f023 03a0 	bic.w	r3, r3, #160	@ 0xa0
  tmpccmr1 |= (TIM_ICFilter << 12U);
2400cf9a:	ea42 3201 	orr.w	r2, r2, r1, lsl #12
  tmpccer |= (TIM_ICPolarity << 4U);
2400cf9e:	ea43 1304 	orr.w	r3, r3, r4, lsl #4
  TIMx->CCMR1 = tmpccmr1 ;
2400cfa2:	6182      	str	r2, [r0, #24]
  TIMx->CCER = tmpccer;
2400cfa4:	6203      	str	r3, [r0, #32]
}
2400cfa6:	e7c2      	b.n	2400cf2e <TIM_SlaveTimer_SetConfig.constprop.0+0x32>
        return HAL_ERROR;
2400cfa8:	2001      	movs	r0, #1
2400cfaa:	e7c1      	b.n	2400cf30 <TIM_SlaveTimer_SetConfig.constprop.0+0x34>

2400cfac <HAL_TIM_SlaveConfigSynchro_IT>:
{
2400cfac:	b538      	push	{r3, r4, r5, lr}
  __HAL_LOCK(htim);
2400cfae:	f890 303c 	ldrb.w	r3, [r0, #60]	@ 0x3c
{
2400cfb2:	4604      	mov	r4, r0
  __HAL_LOCK(htim);
2400cfb4:	2b01      	cmp	r3, #1
2400cfb6:	f04f 0302 	mov.w	r3, #2
2400cfba:	d01c      	beq.n	2400cff6 <HAL_TIM_SlaveConfigSynchro_IT+0x4a>
2400cfbc:	2501      	movs	r5, #1
  htim->State = HAL_TIM_STATE_BUSY;
2400cfbe:	f880 303d 	strb.w	r3, [r0, #61]	@ 0x3d
  __HAL_LOCK(htim);
2400cfc2:	f880 503c 	strb.w	r5, [r0, #60]	@ 0x3c
  if (TIM_SlaveTimer_SetConfig(htim, sSlaveConfig) != HAL_OK)
2400cfc6:	f7ff ff99 	bl	2400cefc <TIM_SlaveTimer_SetConfig.constprop.0>
2400cfca:	b130      	cbz	r0, 2400cfda <HAL_TIM_SlaveConfigSynchro_IT+0x2e>
    __HAL_UNLOCK(htim);
2400cfcc:	2300      	movs	r3, #0
    return HAL_ERROR;
2400cfce:	4628      	mov	r0, r5
    htim->State = HAL_TIM_STATE_READY;
2400cfd0:	f884 503d 	strb.w	r5, [r4, #61]	@ 0x3d
    __HAL_UNLOCK(htim);
2400cfd4:	f884 303c 	strb.w	r3, [r4, #60]	@ 0x3c
}
2400cfd8:	bd38      	pop	{r3, r4, r5, pc}
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_TRIGGER);
2400cfda:	6823      	ldr	r3, [r4, #0]
2400cfdc:	68da      	ldr	r2, [r3, #12]
2400cfde:	f042 0240 	orr.w	r2, r2, #64	@ 0x40
2400cfe2:	60da      	str	r2, [r3, #12]
  __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_TRIGGER);
2400cfe4:	68da      	ldr	r2, [r3, #12]
2400cfe6:	f422 4280 	bic.w	r2, r2, #16384	@ 0x4000
2400cfea:	60da      	str	r2, [r3, #12]
  htim->State = HAL_TIM_STATE_READY;
2400cfec:	f884 503d 	strb.w	r5, [r4, #61]	@ 0x3d
  __HAL_UNLOCK(htim);
2400cff0:	f884 003c 	strb.w	r0, [r4, #60]	@ 0x3c
  return HAL_OK;
2400cff4:	e7f0      	b.n	2400cfd8 <HAL_TIM_SlaveConfigSynchro_IT+0x2c>
  __HAL_LOCK(htim);
2400cff6:	4618      	mov	r0, r3
2400cff8:	e7ee      	b.n	2400cfd8 <HAL_TIM_SlaveConfigSynchro_IT+0x2c>

2400cffa <HAL_TIM_SlaveConfigSynchro>:
{
2400cffa:	b538      	push	{r3, r4, r5, lr}
  __HAL_LOCK(htim);
2400cffc:	f890 303c 	ldrb.w	r3, [r0, #60]	@ 0x3c
{
2400d000:	4604      	mov	r4, r0
  __HAL_LOCK(htim);
2400d002:	2b01      	cmp	r3, #1
2400d004:	f04f 0302 	mov.w	r3, #2
2400d008:	d01c      	beq.n	2400d044 <HAL_TIM_SlaveConfigSynchro+0x4a>
2400d00a:	2501      	movs	r5, #1
  htim->State = HAL_TIM_STATE_BUSY;
2400d00c:	f880 303d 	strb.w	r3, [r0, #61]	@ 0x3d
  __HAL_LOCK(htim);
2400d010:	f880 503c 	strb.w	r5, [r0, #60]	@ 0x3c
  if (TIM_SlaveTimer_SetConfig(htim, sSlaveConfig) != HAL_OK)
2400d014:	f7ff ff72 	bl	2400cefc <TIM_SlaveTimer_SetConfig.constprop.0>
2400d018:	b130      	cbz	r0, 2400d028 <HAL_TIM_SlaveConfigSynchro+0x2e>
    __HAL_UNLOCK(htim);
2400d01a:	2300      	movs	r3, #0
    return HAL_ERROR;
2400d01c:	4628      	mov	r0, r5
    htim->State = HAL_TIM_STATE_READY;
2400d01e:	f884 503d 	strb.w	r5, [r4, #61]	@ 0x3d
    __HAL_UNLOCK(htim);
2400d022:	f884 303c 	strb.w	r3, [r4, #60]	@ 0x3c
}
2400d026:	bd38      	pop	{r3, r4, r5, pc}
  __HAL_TIM_DISABLE_IT(htim, TIM_IT_TRIGGER);
2400d028:	6823      	ldr	r3, [r4, #0]
2400d02a:	68da      	ldr	r2, [r3, #12]
2400d02c:	f022 0240 	bic.w	r2, r2, #64	@ 0x40
2400d030:	60da      	str	r2, [r3, #12]
  __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_TRIGGER);
2400d032:	68da      	ldr	r2, [r3, #12]
2400d034:	f422 4280 	bic.w	r2, r2, #16384	@ 0x4000
2400d038:	60da      	str	r2, [r3, #12]
  htim->State = HAL_TIM_STATE_READY;
2400d03a:	f884 503d 	strb.w	r5, [r4, #61]	@ 0x3d
  __HAL_UNLOCK(htim);
2400d03e:	f884 003c 	strb.w	r0, [r4, #60]	@ 0x3c
  return HAL_OK;
2400d042:	e7f0      	b.n	2400d026 <HAL_TIM_SlaveConfigSynchro+0x2c>
  __HAL_LOCK(htim);
2400d044:	4618      	mov	r0, r3
2400d046:	e7ee      	b.n	2400d026 <HAL_TIM_SlaveConfigSynchro+0x2c>

2400d048 <TIM_CCxChannelCmd>:
  tmp = TIM_CCER_CC1E << (Channel & 0x1FU); /* 0x1FU = 31 bits max shift */
2400d048:	f001 011f 	and.w	r1, r1, #31
  TIMx->CCER &= ~tmp;
2400d04c:	6a03      	ldr	r3, [r0, #32]
{
2400d04e:	b510      	push	{r4, lr}
  tmp = TIM_CCER_CC1E << (Channel & 0x1FU); /* 0x1FU = 31 bits max shift */
2400d050:	2401      	movs	r4, #1
  TIMx->CCER |= (uint32_t)(ChannelState << (Channel & 0x1FU)); /* 0x1FU = 31 bits max shift */
2400d052:	408a      	lsls	r2, r1
  tmp = TIM_CCER_CC1E << (Channel & 0x1FU); /* 0x1FU = 31 bits max shift */
2400d054:	408c      	lsls	r4, r1
  TIMx->CCER &= ~tmp;
2400d056:	ea23 0304 	bic.w	r3, r3, r4
2400d05a:	6203      	str	r3, [r0, #32]
  TIMx->CCER |= (uint32_t)(ChannelState << (Channel & 0x1FU)); /* 0x1FU = 31 bits max shift */
2400d05c:	6a03      	ldr	r3, [r0, #32]
2400d05e:	431a      	orrs	r2, r3
2400d060:	6202      	str	r2, [r0, #32]
}
2400d062:	bd10      	pop	{r4, pc}

2400d064 <HAL_TIM_OC_Start>:
  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
2400d064:	6800      	ldr	r0, [r0, #0]
2400d066:	2201      	movs	r2, #1
{
2400d068:	b508      	push	{r3, lr}
  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
2400d06a:	f7ff ffed 	bl	2400d048 <TIM_CCxChannelCmd>
  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
2400d06e:	4b12      	ldr	r3, [pc, #72]	@ (2400d0b8 <HAL_TIM_OC_Start+0x54>)
2400d070:	4298      	cmp	r0, r3
2400d072:	d00f      	beq.n	2400d094 <HAL_TIM_OC_Start+0x30>
2400d074:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
2400d078:	4298      	cmp	r0, r3
2400d07a:	d00b      	beq.n	2400d094 <HAL_TIM_OC_Start+0x30>
2400d07c:	f503 5370 	add.w	r3, r3, #15360	@ 0x3c00
2400d080:	4298      	cmp	r0, r3
2400d082:	d007      	beq.n	2400d094 <HAL_TIM_OC_Start+0x30>
2400d084:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
2400d088:	4298      	cmp	r0, r3
2400d08a:	d003      	beq.n	2400d094 <HAL_TIM_OC_Start+0x30>
2400d08c:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
2400d090:	4298      	cmp	r0, r3
2400d092:	d103      	bne.n	2400d09c <HAL_TIM_OC_Start+0x38>
    __HAL_TIM_MOE_ENABLE(htim);
2400d094:	6c43      	ldr	r3, [r0, #68]	@ 0x44
2400d096:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
2400d09a:	6443      	str	r3, [r0, #68]	@ 0x44
  tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
2400d09c:	6882      	ldr	r2, [r0, #8]
2400d09e:	4b07      	ldr	r3, [pc, #28]	@ (2400d0bc <HAL_TIM_OC_Start+0x58>)
2400d0a0:	4013      	ands	r3, r2
  if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
2400d0a2:	2b06      	cmp	r3, #6
2400d0a4:	d006      	beq.n	2400d0b4 <HAL_TIM_OC_Start+0x50>
2400d0a6:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
2400d0aa:	d003      	beq.n	2400d0b4 <HAL_TIM_OC_Start+0x50>
    __HAL_TIM_ENABLE(htim);
2400d0ac:	6803      	ldr	r3, [r0, #0]
2400d0ae:	f043 0301 	orr.w	r3, r3, #1
2400d0b2:	6003      	str	r3, [r0, #0]
}
2400d0b4:	2000      	movs	r0, #0
2400d0b6:	bd08      	pop	{r3, pc}
2400d0b8:	40010000 	.word	0x40010000
2400d0bc:	00010007 	.word	0x00010007

2400d0c0 <HAL_TIM_PWM_Start>:
HAL_StatusTypeDef HAL_TIM_PWM_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
2400d0c0:	f7ff bfd0 	b.w	2400d064 <HAL_TIM_OC_Start>

2400d0c4 <HAL_TIM_OC_Stop>:
  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
2400d0c4:	6800      	ldr	r0, [r0, #0]
2400d0c6:	2200      	movs	r2, #0
{
2400d0c8:	b508      	push	{r3, lr}
  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
2400d0ca:	f7ff ffbd 	bl	2400d048 <TIM_CCxChannelCmd>
  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
2400d0ce:	4b18      	ldr	r3, [pc, #96]	@ (2400d130 <HAL_TIM_OC_Stop+0x6c>)
2400d0d0:	4298      	cmp	r0, r3
2400d0d2:	d00f      	beq.n	2400d0f4 <HAL_TIM_OC_Stop+0x30>
2400d0d4:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
2400d0d8:	4298      	cmp	r0, r3
2400d0da:	d00b      	beq.n	2400d0f4 <HAL_TIM_OC_Stop+0x30>
2400d0dc:	f503 5370 	add.w	r3, r3, #15360	@ 0x3c00
2400d0e0:	4298      	cmp	r0, r3
2400d0e2:	d007      	beq.n	2400d0f4 <HAL_TIM_OC_Stop+0x30>
2400d0e4:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
2400d0e8:	4298      	cmp	r0, r3
2400d0ea:	d003      	beq.n	2400d0f4 <HAL_TIM_OC_Stop+0x30>
2400d0ec:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
2400d0f0:	4298      	cmp	r0, r3
2400d0f2:	d10d      	bne.n	2400d110 <HAL_TIM_OC_Stop+0x4c>
    __HAL_TIM_MOE_DISABLE(htim);
2400d0f4:	6a02      	ldr	r2, [r0, #32]
2400d0f6:	f241 1311 	movw	r3, #4369	@ 0x1111
2400d0fa:	421a      	tst	r2, r3
2400d0fc:	d108      	bne.n	2400d110 <HAL_TIM_OC_Stop+0x4c>
2400d0fe:	6a02      	ldr	r2, [r0, #32]
2400d100:	f240 4344 	movw	r3, #1092	@ 0x444
2400d104:	421a      	tst	r2, r3
2400d106:	d103      	bne.n	2400d110 <HAL_TIM_OC_Stop+0x4c>
2400d108:	6c43      	ldr	r3, [r0, #68]	@ 0x44
2400d10a:	f423 4300 	bic.w	r3, r3, #32768	@ 0x8000
2400d10e:	6443      	str	r3, [r0, #68]	@ 0x44
  __HAL_TIM_DISABLE(htim);
2400d110:	6a02      	ldr	r2, [r0, #32]
2400d112:	f241 1311 	movw	r3, #4369	@ 0x1111
2400d116:	421a      	tst	r2, r3
2400d118:	d108      	bne.n	2400d12c <HAL_TIM_OC_Stop+0x68>
2400d11a:	6a02      	ldr	r2, [r0, #32]
2400d11c:	f240 4344 	movw	r3, #1092	@ 0x444
2400d120:	421a      	tst	r2, r3
2400d122:	d103      	bne.n	2400d12c <HAL_TIM_OC_Stop+0x68>
2400d124:	6803      	ldr	r3, [r0, #0]
2400d126:	f023 0301 	bic.w	r3, r3, #1
2400d12a:	6003      	str	r3, [r0, #0]
}
2400d12c:	2000      	movs	r0, #0
2400d12e:	bd08      	pop	{r3, pc}
2400d130:	40010000 	.word	0x40010000

2400d134 <HAL_TIM_OC_Start_IT>:
  switch (Channel)
2400d134:	2908      	cmp	r1, #8
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
2400d136:	6800      	ldr	r0, [r0, #0]
{
2400d138:	b508      	push	{r3, lr}
  switch (Channel)
2400d13a:	d03a      	beq.n	2400d1b2 <HAL_TIM_OC_Start_IT+0x7e>
2400d13c:	d82a      	bhi.n	2400d194 <HAL_TIM_OC_Start_IT+0x60>
2400d13e:	b379      	cbz	r1, 2400d1a0 <HAL_TIM_OC_Start_IT+0x6c>
2400d140:	2904      	cmp	r1, #4
2400d142:	d032      	beq.n	2400d1aa <HAL_TIM_OC_Start_IT+0x76>
  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
2400d144:	2201      	movs	r2, #1
2400d146:	f7ff ff7f 	bl	2400d048 <TIM_CCxChannelCmd>
  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
2400d14a:	4b1c      	ldr	r3, [pc, #112]	@ (2400d1bc <HAL_TIM_OC_Start_IT+0x88>)
2400d14c:	4298      	cmp	r0, r3
2400d14e:	d00f      	beq.n	2400d170 <HAL_TIM_OC_Start_IT+0x3c>
2400d150:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
2400d154:	4298      	cmp	r0, r3
2400d156:	d00b      	beq.n	2400d170 <HAL_TIM_OC_Start_IT+0x3c>
2400d158:	f503 5370 	add.w	r3, r3, #15360	@ 0x3c00
2400d15c:	4298      	cmp	r0, r3
2400d15e:	d007      	beq.n	2400d170 <HAL_TIM_OC_Start_IT+0x3c>
2400d160:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
2400d164:	4298      	cmp	r0, r3
2400d166:	d003      	beq.n	2400d170 <HAL_TIM_OC_Start_IT+0x3c>
2400d168:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
2400d16c:	4298      	cmp	r0, r3
2400d16e:	d103      	bne.n	2400d178 <HAL_TIM_OC_Start_IT+0x44>
    __HAL_TIM_MOE_ENABLE(htim);
2400d170:	6c43      	ldr	r3, [r0, #68]	@ 0x44
2400d172:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
2400d176:	6443      	str	r3, [r0, #68]	@ 0x44
  tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
2400d178:	6882      	ldr	r2, [r0, #8]
2400d17a:	4b11      	ldr	r3, [pc, #68]	@ (2400d1c0 <HAL_TIM_OC_Start_IT+0x8c>)
2400d17c:	4013      	ands	r3, r2
  if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
2400d17e:	2b06      	cmp	r3, #6
2400d180:	d006      	beq.n	2400d190 <HAL_TIM_OC_Start_IT+0x5c>
2400d182:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
2400d186:	d003      	beq.n	2400d190 <HAL_TIM_OC_Start_IT+0x5c>
    __HAL_TIM_ENABLE(htim);
2400d188:	6803      	ldr	r3, [r0, #0]
2400d18a:	f043 0301 	orr.w	r3, r3, #1
2400d18e:	6003      	str	r3, [r0, #0]
}
2400d190:	2000      	movs	r0, #0
2400d192:	bd08      	pop	{r3, pc}
  switch (Channel)
2400d194:	290c      	cmp	r1, #12
2400d196:	d1d5      	bne.n	2400d144 <HAL_TIM_OC_Start_IT+0x10>
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
2400d198:	68c3      	ldr	r3, [r0, #12]
2400d19a:	f043 0310 	orr.w	r3, r3, #16
2400d19e:	e002      	b.n	2400d1a6 <HAL_TIM_OC_Start_IT+0x72>
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
2400d1a0:	68c3      	ldr	r3, [r0, #12]
2400d1a2:	f043 0302 	orr.w	r3, r3, #2
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
2400d1a6:	60c3      	str	r3, [r0, #12]
      break;
2400d1a8:	e7cc      	b.n	2400d144 <HAL_TIM_OC_Start_IT+0x10>
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
2400d1aa:	68c3      	ldr	r3, [r0, #12]
2400d1ac:	f043 0304 	orr.w	r3, r3, #4
2400d1b0:	e7f9      	b.n	2400d1a6 <HAL_TIM_OC_Start_IT+0x72>
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
2400d1b2:	68c3      	ldr	r3, [r0, #12]
2400d1b4:	f043 0308 	orr.w	r3, r3, #8
2400d1b8:	e7f5      	b.n	2400d1a6 <HAL_TIM_OC_Start_IT+0x72>
2400d1ba:	bf00      	nop
2400d1bc:	40010000 	.word	0x40010000
2400d1c0:	00010007 	.word	0x00010007

2400d1c4 <HAL_TIM_PWM_Start_IT>:
HAL_StatusTypeDef HAL_TIM_PWM_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
2400d1c4:	f7ff bfb6 	b.w	2400d134 <HAL_TIM_OC_Start_IT>

2400d1c8 <HAL_TIM_OC_Stop_IT>:
  switch (Channel)
2400d1c8:	2908      	cmp	r1, #8
      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
2400d1ca:	6800      	ldr	r0, [r0, #0]
{
2400d1cc:	b508      	push	{r3, lr}
  switch (Channel)
2400d1ce:	d047      	beq.n	2400d260 <HAL_TIM_OC_Stop_IT+0x98>
2400d1d0:	d837      	bhi.n	2400d242 <HAL_TIM_OC_Stop_IT+0x7a>
2400d1d2:	2900      	cmp	r1, #0
2400d1d4:	d03b      	beq.n	2400d24e <HAL_TIM_OC_Stop_IT+0x86>
2400d1d6:	2904      	cmp	r1, #4
2400d1d8:	d03e      	beq.n	2400d258 <HAL_TIM_OC_Stop_IT+0x90>
  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
2400d1da:	2200      	movs	r2, #0
2400d1dc:	f7ff ff34 	bl	2400d048 <TIM_CCxChannelCmd>
  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
2400d1e0:	4b21      	ldr	r3, [pc, #132]	@ (2400d268 <HAL_TIM_OC_Stop_IT+0xa0>)
2400d1e2:	4298      	cmp	r0, r3
2400d1e4:	d00f      	beq.n	2400d206 <HAL_TIM_OC_Stop_IT+0x3e>
2400d1e6:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
2400d1ea:	4298      	cmp	r0, r3
2400d1ec:	d00b      	beq.n	2400d206 <HAL_TIM_OC_Stop_IT+0x3e>
2400d1ee:	f503 5370 	add.w	r3, r3, #15360	@ 0x3c00
2400d1f2:	4298      	cmp	r0, r3
2400d1f4:	d007      	beq.n	2400d206 <HAL_TIM_OC_Stop_IT+0x3e>
2400d1f6:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
2400d1fa:	4298      	cmp	r0, r3
2400d1fc:	d003      	beq.n	2400d206 <HAL_TIM_OC_Stop_IT+0x3e>
2400d1fe:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
2400d202:	4298      	cmp	r0, r3
2400d204:	d10d      	bne.n	2400d222 <HAL_TIM_OC_Stop_IT+0x5a>
    __HAL_TIM_MOE_DISABLE(htim);
2400d206:	6a02      	ldr	r2, [r0, #32]
2400d208:	f241 1311 	movw	r3, #4369	@ 0x1111
2400d20c:	421a      	tst	r2, r3
2400d20e:	d108      	bne.n	2400d222 <HAL_TIM_OC_Stop_IT+0x5a>
2400d210:	6a02      	ldr	r2, [r0, #32]
2400d212:	f240 4344 	movw	r3, #1092	@ 0x444
2400d216:	421a      	tst	r2, r3
2400d218:	d103      	bne.n	2400d222 <HAL_TIM_OC_Stop_IT+0x5a>
2400d21a:	6c43      	ldr	r3, [r0, #68]	@ 0x44
2400d21c:	f423 4300 	bic.w	r3, r3, #32768	@ 0x8000
2400d220:	6443      	str	r3, [r0, #68]	@ 0x44
  __HAL_TIM_DISABLE(htim);
2400d222:	6a02      	ldr	r2, [r0, #32]
2400d224:	f241 1311 	movw	r3, #4369	@ 0x1111
2400d228:	421a      	tst	r2, r3
2400d22a:	d108      	bne.n	2400d23e <HAL_TIM_OC_Stop_IT+0x76>
2400d22c:	6a02      	ldr	r2, [r0, #32]
2400d22e:	f240 4344 	movw	r3, #1092	@ 0x444
2400d232:	421a      	tst	r2, r3
2400d234:	d103      	bne.n	2400d23e <HAL_TIM_OC_Stop_IT+0x76>
2400d236:	6803      	ldr	r3, [r0, #0]
2400d238:	f023 0301 	bic.w	r3, r3, #1
2400d23c:	6003      	str	r3, [r0, #0]
}
2400d23e:	2000      	movs	r0, #0
2400d240:	bd08      	pop	{r3, pc}
  switch (Channel)
2400d242:	290c      	cmp	r1, #12
2400d244:	d1c9      	bne.n	2400d1da <HAL_TIM_OC_Stop_IT+0x12>
      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
2400d246:	68c3      	ldr	r3, [r0, #12]
2400d248:	f023 0310 	bic.w	r3, r3, #16
2400d24c:	e002      	b.n	2400d254 <HAL_TIM_OC_Stop_IT+0x8c>
      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
2400d24e:	68c3      	ldr	r3, [r0, #12]
2400d250:	f023 0302 	bic.w	r3, r3, #2
      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
2400d254:	60c3      	str	r3, [r0, #12]
      break;
2400d256:	e7c0      	b.n	2400d1da <HAL_TIM_OC_Stop_IT+0x12>
      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
2400d258:	68c3      	ldr	r3, [r0, #12]
2400d25a:	f023 0304 	bic.w	r3, r3, #4
2400d25e:	e7f9      	b.n	2400d254 <HAL_TIM_OC_Stop_IT+0x8c>
      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
2400d260:	68c3      	ldr	r3, [r0, #12]
2400d262:	f023 0308 	bic.w	r3, r3, #8
2400d266:	e7f5      	b.n	2400d254 <HAL_TIM_OC_Stop_IT+0x8c>
2400d268:	40010000 	.word	0x40010000

2400d26c <HAL_TIM_PWM_Stop_IT>:
HAL_StatusTypeDef HAL_TIM_PWM_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
2400d26c:	f7ff bfac 	b.w	2400d1c8 <HAL_TIM_OC_Stop_IT>

2400d270 <HAL_TIM_OC_Start_DMA>:
{
2400d270:	b570      	push	{r4, r5, r6, lr}
2400d272:	460d      	mov	r5, r1
2400d274:	4611      	mov	r1, r2
  if (htim->State == HAL_TIM_STATE_BUSY)
2400d276:	f890 203d 	ldrb.w	r2, [r0, #61]	@ 0x3d
{
2400d27a:	4604      	mov	r4, r0
  if (htim->State == HAL_TIM_STATE_BUSY)
2400d27c:	2a02      	cmp	r2, #2
2400d27e:	b2d0      	uxtb	r0, r2
2400d280:	d006      	beq.n	2400d290 <HAL_TIM_OC_Start_DMA+0x20>
  else if (htim->State == HAL_TIM_STATE_READY)
2400d282:	f894 203d 	ldrb.w	r2, [r4, #61]	@ 0x3d
2400d286:	2a01      	cmp	r2, #1
2400d288:	d106      	bne.n	2400d298 <HAL_TIM_OC_Start_DMA+0x28>
    if ((pData == NULL) && (Length > 0U))
2400d28a:	b911      	cbnz	r1, 2400d292 <HAL_TIM_OC_Start_DMA+0x22>
2400d28c:	b10b      	cbz	r3, 2400d292 <HAL_TIM_OC_Start_DMA+0x22>
      return HAL_ERROR;
2400d28e:	2001      	movs	r0, #1
}
2400d290:	bd70      	pop	{r4, r5, r6, pc}
      htim->State = HAL_TIM_STATE_BUSY;
2400d292:	2202      	movs	r2, #2
2400d294:	f884 203d 	strb.w	r2, [r4, #61]	@ 0x3d
  switch (Channel)
2400d298:	2d08      	cmp	r5, #8
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1, Length) != HAL_OK)
2400d29a:	6822      	ldr	r2, [r4, #0]
  switch (Channel)
2400d29c:	d064      	beq.n	2400d368 <HAL_TIM_OC_Start_DMA+0xf8>
2400d29e:	d82d      	bhi.n	2400d2fc <HAL_TIM_OC_Start_DMA+0x8c>
2400d2a0:	2d00      	cmp	r5, #0
2400d2a2:	d03e      	beq.n	2400d322 <HAL_TIM_OC_Start_DMA+0xb2>
2400d2a4:	2d04      	cmp	r5, #4
2400d2a6:	d04e      	beq.n	2400d346 <HAL_TIM_OC_Start_DMA+0xd6>
  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
2400d2a8:	6820      	ldr	r0, [r4, #0]
2400d2aa:	2201      	movs	r2, #1
2400d2ac:	4629      	mov	r1, r5
2400d2ae:	f7ff fecb 	bl	2400d048 <TIM_CCxChannelCmd>
  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
2400d2b2:	4b36      	ldr	r3, [pc, #216]	@ (2400d38c <HAL_TIM_OC_Start_DMA+0x11c>)
2400d2b4:	4298      	cmp	r0, r3
2400d2b6:	d00f      	beq.n	2400d2d8 <HAL_TIM_OC_Start_DMA+0x68>
2400d2b8:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
2400d2bc:	4298      	cmp	r0, r3
2400d2be:	d00b      	beq.n	2400d2d8 <HAL_TIM_OC_Start_DMA+0x68>
2400d2c0:	f503 5370 	add.w	r3, r3, #15360	@ 0x3c00
2400d2c4:	4298      	cmp	r0, r3
2400d2c6:	d007      	beq.n	2400d2d8 <HAL_TIM_OC_Start_DMA+0x68>
2400d2c8:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
2400d2cc:	4298      	cmp	r0, r3
2400d2ce:	d003      	beq.n	2400d2d8 <HAL_TIM_OC_Start_DMA+0x68>
2400d2d0:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
2400d2d4:	4298      	cmp	r0, r3
2400d2d6:	d103      	bne.n	2400d2e0 <HAL_TIM_OC_Start_DMA+0x70>
    __HAL_TIM_MOE_ENABLE(htim);
2400d2d8:	6c43      	ldr	r3, [r0, #68]	@ 0x44
2400d2da:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
2400d2de:	6443      	str	r3, [r0, #68]	@ 0x44
  tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
2400d2e0:	6882      	ldr	r2, [r0, #8]
2400d2e2:	4b2b      	ldr	r3, [pc, #172]	@ (2400d390 <HAL_TIM_OC_Start_DMA+0x120>)
2400d2e4:	4013      	ands	r3, r2
  if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
2400d2e6:	2b06      	cmp	r3, #6
2400d2e8:	d006      	beq.n	2400d2f8 <HAL_TIM_OC_Start_DMA+0x88>
2400d2ea:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
2400d2ee:	d003      	beq.n	2400d2f8 <HAL_TIM_OC_Start_DMA+0x88>
    __HAL_TIM_ENABLE(htim);
2400d2f0:	6803      	ldr	r3, [r0, #0]
2400d2f2:	f043 0301 	orr.w	r3, r3, #1
2400d2f6:	6003      	str	r3, [r0, #0]
  return HAL_OK;
2400d2f8:	2000      	movs	r0, #0
2400d2fa:	e7c9      	b.n	2400d290 <HAL_TIM_OC_Start_DMA+0x20>
  switch (Channel)
2400d2fc:	2d0c      	cmp	r5, #12
2400d2fe:	d1d3      	bne.n	2400d2a8 <HAL_TIM_OC_Start_DMA+0x38>
      htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMADelayPulseCplt;
2400d300:	6b20      	ldr	r0, [r4, #48]	@ 0x30
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)pData, (uint32_t)&htim->Instance->CCR4, Length) != HAL_OK)
2400d302:	3240      	adds	r2, #64	@ 0x40
      htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMADelayPulseCplt;
2400d304:	4e23      	ldr	r6, [pc, #140]	@ (2400d394 <HAL_TIM_OC_Start_DMA+0x124>)
2400d306:	63c6      	str	r6, [r0, #60]	@ 0x3c
      htim->hdma[TIM_DMA_ID_CC4]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
2400d308:	4e23      	ldr	r6, [pc, #140]	@ (2400d398 <HAL_TIM_OC_Start_DMA+0x128>)
2400d30a:	6406      	str	r6, [r0, #64]	@ 0x40
      htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
2400d30c:	4e23      	ldr	r6, [pc, #140]	@ (2400d39c <HAL_TIM_OC_Start_DMA+0x12c>)
2400d30e:	64c6      	str	r6, [r0, #76]	@ 0x4c
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)pData, (uint32_t)&htim->Instance->CCR4, Length) != HAL_OK)
2400d310:	f7f4 fb66 	bl	240019e0 <HAL_DMA_Start_IT>
2400d314:	2800      	cmp	r0, #0
2400d316:	d1ba      	bne.n	2400d28e <HAL_TIM_OC_Start_DMA+0x1e>
      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
2400d318:	6822      	ldr	r2, [r4, #0]
2400d31a:	68d3      	ldr	r3, [r2, #12]
2400d31c:	f443 5380 	orr.w	r3, r3, #4096	@ 0x1000
2400d320:	e00f      	b.n	2400d342 <HAL_TIM_OC_Start_DMA+0xd2>
      htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseCplt;
2400d322:	6a60      	ldr	r0, [r4, #36]	@ 0x24
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1, Length) != HAL_OK)
2400d324:	3234      	adds	r2, #52	@ 0x34
      htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseCplt;
2400d326:	4e1b      	ldr	r6, [pc, #108]	@ (2400d394 <HAL_TIM_OC_Start_DMA+0x124>)
2400d328:	63c6      	str	r6, [r0, #60]	@ 0x3c
      htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
2400d32a:	4e1b      	ldr	r6, [pc, #108]	@ (2400d398 <HAL_TIM_OC_Start_DMA+0x128>)
2400d32c:	6406      	str	r6, [r0, #64]	@ 0x40
      htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
2400d32e:	4e1b      	ldr	r6, [pc, #108]	@ (2400d39c <HAL_TIM_OC_Start_DMA+0x12c>)
2400d330:	64c6      	str	r6, [r0, #76]	@ 0x4c
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1, Length) != HAL_OK)
2400d332:	f7f4 fb55 	bl	240019e0 <HAL_DMA_Start_IT>
2400d336:	2800      	cmp	r0, #0
2400d338:	d1a9      	bne.n	2400d28e <HAL_TIM_OC_Start_DMA+0x1e>
      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
2400d33a:	6822      	ldr	r2, [r4, #0]
2400d33c:	68d3      	ldr	r3, [r2, #12]
2400d33e:	f443 7300 	orr.w	r3, r3, #512	@ 0x200
      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
2400d342:	60d3      	str	r3, [r2, #12]
      break;
2400d344:	e7b0      	b.n	2400d2a8 <HAL_TIM_OC_Start_DMA+0x38>
      htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;
2400d346:	6aa0      	ldr	r0, [r4, #40]	@ 0x28
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2, Length) != HAL_OK)
2400d348:	3238      	adds	r2, #56	@ 0x38
      htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;
2400d34a:	4e12      	ldr	r6, [pc, #72]	@ (2400d394 <HAL_TIM_OC_Start_DMA+0x124>)
2400d34c:	63c6      	str	r6, [r0, #60]	@ 0x3c
      htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
2400d34e:	4e12      	ldr	r6, [pc, #72]	@ (2400d398 <HAL_TIM_OC_Start_DMA+0x128>)
2400d350:	6406      	str	r6, [r0, #64]	@ 0x40
      htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
2400d352:	4e12      	ldr	r6, [pc, #72]	@ (2400d39c <HAL_TIM_OC_Start_DMA+0x12c>)
2400d354:	64c6      	str	r6, [r0, #76]	@ 0x4c
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2, Length) != HAL_OK)
2400d356:	f7f4 fb43 	bl	240019e0 <HAL_DMA_Start_IT>
2400d35a:	2800      	cmp	r0, #0
2400d35c:	d197      	bne.n	2400d28e <HAL_TIM_OC_Start_DMA+0x1e>
      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
2400d35e:	6822      	ldr	r2, [r4, #0]
2400d360:	68d3      	ldr	r3, [r2, #12]
2400d362:	f443 6380 	orr.w	r3, r3, #1024	@ 0x400
2400d366:	e7ec      	b.n	2400d342 <HAL_TIM_OC_Start_DMA+0xd2>
      htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseCplt;
2400d368:	6ae0      	ldr	r0, [r4, #44]	@ 0x2c
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3, Length) != HAL_OK)
2400d36a:	323c      	adds	r2, #60	@ 0x3c
      htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseCplt;
2400d36c:	4e09      	ldr	r6, [pc, #36]	@ (2400d394 <HAL_TIM_OC_Start_DMA+0x124>)
2400d36e:	63c6      	str	r6, [r0, #60]	@ 0x3c
      htim->hdma[TIM_DMA_ID_CC3]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
2400d370:	4e09      	ldr	r6, [pc, #36]	@ (2400d398 <HAL_TIM_OC_Start_DMA+0x128>)
2400d372:	6406      	str	r6, [r0, #64]	@ 0x40
      htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
2400d374:	4e09      	ldr	r6, [pc, #36]	@ (2400d39c <HAL_TIM_OC_Start_DMA+0x12c>)
2400d376:	64c6      	str	r6, [r0, #76]	@ 0x4c
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3, Length) != HAL_OK)
2400d378:	f7f4 fb32 	bl	240019e0 <HAL_DMA_Start_IT>
2400d37c:	2800      	cmp	r0, #0
2400d37e:	d186      	bne.n	2400d28e <HAL_TIM_OC_Start_DMA+0x1e>
      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
2400d380:	6822      	ldr	r2, [r4, #0]
2400d382:	68d3      	ldr	r3, [r2, #12]
2400d384:	f443 6300 	orr.w	r3, r3, #2048	@ 0x800
2400d388:	e7db      	b.n	2400d342 <HAL_TIM_OC_Start_DMA+0xd2>
2400d38a:	bf00      	nop
2400d38c:	40010000 	.word	0x40010000
2400d390:	00010007 	.word	0x00010007
2400d394:	2400c35f 	.word	0x2400c35f
2400d398:	2400c39d 	.word	0x2400c39d
2400d39c:	2400c55f 	.word	0x2400c55f

2400d3a0 <HAL_TIM_PWM_Start_DMA>:
HAL_StatusTypeDef HAL_TIM_PWM_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
2400d3a0:	f7ff bf66 	b.w	2400d270 <HAL_TIM_OC_Start_DMA>

2400d3a4 <HAL_TIM_OC_Stop_DMA>:
  switch (Channel)
2400d3a4:	2908      	cmp	r1, #8
{
2400d3a6:	b538      	push	{r3, r4, r5, lr}
2400d3a8:	4604      	mov	r4, r0
2400d3aa:	460d      	mov	r5, r1
      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
2400d3ac:	6803      	ldr	r3, [r0, #0]
  switch (Channel)
2400d3ae:	d053      	beq.n	2400d458 <HAL_TIM_OC_Stop_DMA+0xb4>
2400d3b0:	d83c      	bhi.n	2400d42c <HAL_TIM_OC_Stop_DMA+0x88>
2400d3b2:	2900      	cmp	r1, #0
2400d3b4:	d042      	beq.n	2400d43c <HAL_TIM_OC_Stop_DMA+0x98>
2400d3b6:	2904      	cmp	r1, #4
2400d3b8:	d048      	beq.n	2400d44c <HAL_TIM_OC_Stop_DMA+0xa8>
  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
2400d3ba:	6820      	ldr	r0, [r4, #0]
2400d3bc:	2200      	movs	r2, #0
2400d3be:	4629      	mov	r1, r5
2400d3c0:	f7ff fe42 	bl	2400d048 <TIM_CCxChannelCmd>
  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
2400d3c4:	4b27      	ldr	r3, [pc, #156]	@ (2400d464 <HAL_TIM_OC_Stop_DMA+0xc0>)
2400d3c6:	4298      	cmp	r0, r3
2400d3c8:	d00f      	beq.n	2400d3ea <HAL_TIM_OC_Stop_DMA+0x46>
2400d3ca:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
2400d3ce:	4298      	cmp	r0, r3
2400d3d0:	d00b      	beq.n	2400d3ea <HAL_TIM_OC_Stop_DMA+0x46>
2400d3d2:	f503 5370 	add.w	r3, r3, #15360	@ 0x3c00
2400d3d6:	4298      	cmp	r0, r3
2400d3d8:	d007      	beq.n	2400d3ea <HAL_TIM_OC_Stop_DMA+0x46>
2400d3da:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
2400d3de:	4298      	cmp	r0, r3
2400d3e0:	d003      	beq.n	2400d3ea <HAL_TIM_OC_Stop_DMA+0x46>
2400d3e2:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
2400d3e6:	4298      	cmp	r0, r3
2400d3e8:	d10d      	bne.n	2400d406 <HAL_TIM_OC_Stop_DMA+0x62>
    __HAL_TIM_MOE_DISABLE(htim);
2400d3ea:	6a02      	ldr	r2, [r0, #32]
2400d3ec:	f241 1311 	movw	r3, #4369	@ 0x1111
2400d3f0:	421a      	tst	r2, r3
2400d3f2:	d108      	bne.n	2400d406 <HAL_TIM_OC_Stop_DMA+0x62>
2400d3f4:	6a02      	ldr	r2, [r0, #32]
2400d3f6:	f240 4344 	movw	r3, #1092	@ 0x444
2400d3fa:	421a      	tst	r2, r3
2400d3fc:	d103      	bne.n	2400d406 <HAL_TIM_OC_Stop_DMA+0x62>
2400d3fe:	6c43      	ldr	r3, [r0, #68]	@ 0x44
2400d400:	f423 4300 	bic.w	r3, r3, #32768	@ 0x8000
2400d404:	6443      	str	r3, [r0, #68]	@ 0x44
  __HAL_TIM_DISABLE(htim);
2400d406:	6a02      	ldr	r2, [r0, #32]
2400d408:	f241 1311 	movw	r3, #4369	@ 0x1111
2400d40c:	421a      	tst	r2, r3
2400d40e:	d108      	bne.n	2400d422 <HAL_TIM_OC_Stop_DMA+0x7e>
2400d410:	6a02      	ldr	r2, [r0, #32]
2400d412:	f240 4344 	movw	r3, #1092	@ 0x444
2400d416:	421a      	tst	r2, r3
2400d418:	d103      	bne.n	2400d422 <HAL_TIM_OC_Stop_DMA+0x7e>
2400d41a:	6803      	ldr	r3, [r0, #0]
2400d41c:	f023 0301 	bic.w	r3, r3, #1
2400d420:	6003      	str	r3, [r0, #0]
  htim->State = HAL_TIM_STATE_READY;
2400d422:	2301      	movs	r3, #1
}
2400d424:	2000      	movs	r0, #0
  htim->State = HAL_TIM_STATE_READY;
2400d426:	f884 303d 	strb.w	r3, [r4, #61]	@ 0x3d
}
2400d42a:	bd38      	pop	{r3, r4, r5, pc}
  switch (Channel)
2400d42c:	290c      	cmp	r1, #12
2400d42e:	d1c4      	bne.n	2400d3ba <HAL_TIM_OC_Stop_DMA+0x16>
      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
2400d430:	68da      	ldr	r2, [r3, #12]
      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC4]);
2400d432:	6b00      	ldr	r0, [r0, #48]	@ 0x30
      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
2400d434:	f422 5280 	bic.w	r2, r2, #4096	@ 0x1000
2400d438:	60da      	str	r2, [r3, #12]
      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC4]);
2400d43a:	e004      	b.n	2400d446 <HAL_TIM_OC_Stop_DMA+0xa2>
      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
2400d43c:	68da      	ldr	r2, [r3, #12]
      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);
2400d43e:	6a40      	ldr	r0, [r0, #36]	@ 0x24
      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
2400d440:	f422 7200 	bic.w	r2, r2, #512	@ 0x200
2400d444:	60da      	str	r2, [r3, #12]
      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC4]);
2400d446:	f7f4 fd91 	bl	24001f6c <HAL_DMA_Abort_IT>
      break;
2400d44a:	e7b6      	b.n	2400d3ba <HAL_TIM_OC_Stop_DMA+0x16>
      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
2400d44c:	68da      	ldr	r2, [r3, #12]
      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);
2400d44e:	6a80      	ldr	r0, [r0, #40]	@ 0x28
      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
2400d450:	f422 6280 	bic.w	r2, r2, #1024	@ 0x400
2400d454:	60da      	str	r2, [r3, #12]
      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);
2400d456:	e7f6      	b.n	2400d446 <HAL_TIM_OC_Stop_DMA+0xa2>
      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
2400d458:	68da      	ldr	r2, [r3, #12]
      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC3]);
2400d45a:	6ac0      	ldr	r0, [r0, #44]	@ 0x2c
      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
2400d45c:	f422 6200 	bic.w	r2, r2, #2048	@ 0x800
2400d460:	60da      	str	r2, [r3, #12]
      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC3]);
2400d462:	e7f0      	b.n	2400d446 <HAL_TIM_OC_Stop_DMA+0xa2>
2400d464:	40010000 	.word	0x40010000

2400d468 <HAL_TIM_PWM_Stop_DMA>:
HAL_StatusTypeDef HAL_TIM_PWM_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
2400d468:	f7ff bf9c 	b.w	2400d3a4 <HAL_TIM_OC_Stop_DMA>

2400d46c <HAL_TIM_PWM_Stop>:
{
2400d46c:	b510      	push	{r4, lr}
  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
2400d46e:	2200      	movs	r2, #0
{
2400d470:	4604      	mov	r4, r0
  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
2400d472:	6800      	ldr	r0, [r0, #0]
2400d474:	f7ff fde8 	bl	2400d048 <TIM_CCxChannelCmd>
  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
2400d478:	4b19      	ldr	r3, [pc, #100]	@ (2400d4e0 <HAL_TIM_PWM_Stop+0x74>)
2400d47a:	4298      	cmp	r0, r3
2400d47c:	d00f      	beq.n	2400d49e <HAL_TIM_PWM_Stop+0x32>
2400d47e:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
2400d482:	4298      	cmp	r0, r3
2400d484:	d00b      	beq.n	2400d49e <HAL_TIM_PWM_Stop+0x32>
2400d486:	f503 5370 	add.w	r3, r3, #15360	@ 0x3c00
2400d48a:	4298      	cmp	r0, r3
2400d48c:	d007      	beq.n	2400d49e <HAL_TIM_PWM_Stop+0x32>
2400d48e:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
2400d492:	4298      	cmp	r0, r3
2400d494:	d003      	beq.n	2400d49e <HAL_TIM_PWM_Stop+0x32>
2400d496:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
2400d49a:	4298      	cmp	r0, r3
2400d49c:	d10d      	bne.n	2400d4ba <HAL_TIM_PWM_Stop+0x4e>
    __HAL_TIM_MOE_DISABLE(htim);
2400d49e:	6a02      	ldr	r2, [r0, #32]
2400d4a0:	f241 1311 	movw	r3, #4369	@ 0x1111
2400d4a4:	421a      	tst	r2, r3
2400d4a6:	d108      	bne.n	2400d4ba <HAL_TIM_PWM_Stop+0x4e>
2400d4a8:	6a02      	ldr	r2, [r0, #32]
2400d4aa:	f240 4344 	movw	r3, #1092	@ 0x444
2400d4ae:	421a      	tst	r2, r3
2400d4b0:	d103      	bne.n	2400d4ba <HAL_TIM_PWM_Stop+0x4e>
2400d4b2:	6c43      	ldr	r3, [r0, #68]	@ 0x44
2400d4b4:	f423 4300 	bic.w	r3, r3, #32768	@ 0x8000
2400d4b8:	6443      	str	r3, [r0, #68]	@ 0x44
  __HAL_TIM_DISABLE(htim);
2400d4ba:	6a02      	ldr	r2, [r0, #32]
2400d4bc:	f241 1311 	movw	r3, #4369	@ 0x1111
2400d4c0:	421a      	tst	r2, r3
2400d4c2:	d108      	bne.n	2400d4d6 <HAL_TIM_PWM_Stop+0x6a>
2400d4c4:	6a02      	ldr	r2, [r0, #32]
2400d4c6:	f240 4344 	movw	r3, #1092	@ 0x444
2400d4ca:	421a      	tst	r2, r3
2400d4cc:	d103      	bne.n	2400d4d6 <HAL_TIM_PWM_Stop+0x6a>
2400d4ce:	6803      	ldr	r3, [r0, #0]
2400d4d0:	f023 0301 	bic.w	r3, r3, #1
2400d4d4:	6003      	str	r3, [r0, #0]
  htim->State = HAL_TIM_STATE_READY;
2400d4d6:	2301      	movs	r3, #1
}
2400d4d8:	2000      	movs	r0, #0
  htim->State = HAL_TIM_STATE_READY;
2400d4da:	f884 303d 	strb.w	r3, [r4, #61]	@ 0x3d
}
2400d4de:	bd10      	pop	{r4, pc}
2400d4e0:	40010000 	.word	0x40010000

2400d4e4 <HAL_TIM_IC_Start>:
  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
2400d4e4:	6800      	ldr	r0, [r0, #0]
2400d4e6:	2201      	movs	r2, #1
{
2400d4e8:	b508      	push	{r3, lr}
  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
2400d4ea:	f7ff fdad 	bl	2400d048 <TIM_CCxChannelCmd>
  tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
2400d4ee:	6882      	ldr	r2, [r0, #8]
2400d4f0:	4b06      	ldr	r3, [pc, #24]	@ (2400d50c <HAL_TIM_IC_Start+0x28>)
2400d4f2:	4013      	ands	r3, r2
  if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
2400d4f4:	2b06      	cmp	r3, #6
2400d4f6:	d006      	beq.n	2400d506 <HAL_TIM_IC_Start+0x22>
2400d4f8:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
2400d4fc:	d003      	beq.n	2400d506 <HAL_TIM_IC_Start+0x22>
    __HAL_TIM_ENABLE(htim);
2400d4fe:	6803      	ldr	r3, [r0, #0]
2400d500:	f043 0301 	orr.w	r3, r3, #1
2400d504:	6003      	str	r3, [r0, #0]
}
2400d506:	2000      	movs	r0, #0
2400d508:	bd08      	pop	{r3, pc}
2400d50a:	bf00      	nop
2400d50c:	00010007 	.word	0x00010007

2400d510 <HAL_TIM_IC_Stop>:
  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
2400d510:	6800      	ldr	r0, [r0, #0]
2400d512:	2200      	movs	r2, #0
{
2400d514:	b508      	push	{r3, lr}
  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
2400d516:	f7ff fd97 	bl	2400d048 <TIM_CCxChannelCmd>
  __HAL_TIM_DISABLE(htim);
2400d51a:	6a02      	ldr	r2, [r0, #32]
2400d51c:	f241 1311 	movw	r3, #4369	@ 0x1111
2400d520:	421a      	tst	r2, r3
2400d522:	d108      	bne.n	2400d536 <HAL_TIM_IC_Stop+0x26>
2400d524:	6a02      	ldr	r2, [r0, #32]
2400d526:	f240 4344 	movw	r3, #1092	@ 0x444
2400d52a:	421a      	tst	r2, r3
2400d52c:	d103      	bne.n	2400d536 <HAL_TIM_IC_Stop+0x26>
2400d52e:	6803      	ldr	r3, [r0, #0]
2400d530:	f023 0301 	bic.w	r3, r3, #1
2400d534:	6003      	str	r3, [r0, #0]
}
2400d536:	2000      	movs	r0, #0
2400d538:	bd08      	pop	{r3, pc}

2400d53a <HAL_TIM_IC_Start_IT>:
  switch (Channel)
2400d53a:	2908      	cmp	r1, #8
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
2400d53c:	6800      	ldr	r0, [r0, #0]
{
2400d53e:	b508      	push	{r3, lr}
  switch (Channel)
2400d540:	d023      	beq.n	2400d58a <HAL_TIM_IC_Start_IT+0x50>
2400d542:	d813      	bhi.n	2400d56c <HAL_TIM_IC_Start_IT+0x32>
2400d544:	b1c1      	cbz	r1, 2400d578 <HAL_TIM_IC_Start_IT+0x3e>
2400d546:	2904      	cmp	r1, #4
2400d548:	d01b      	beq.n	2400d582 <HAL_TIM_IC_Start_IT+0x48>
  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
2400d54a:	2201      	movs	r2, #1
2400d54c:	f7ff fd7c 	bl	2400d048 <TIM_CCxChannelCmd>
  tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
2400d550:	6882      	ldr	r2, [r0, #8]
2400d552:	4b10      	ldr	r3, [pc, #64]	@ (2400d594 <HAL_TIM_IC_Start_IT+0x5a>)
2400d554:	4013      	ands	r3, r2
  if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
2400d556:	2b06      	cmp	r3, #6
2400d558:	d006      	beq.n	2400d568 <HAL_TIM_IC_Start_IT+0x2e>
2400d55a:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
2400d55e:	d003      	beq.n	2400d568 <HAL_TIM_IC_Start_IT+0x2e>
    __HAL_TIM_ENABLE(htim);
2400d560:	6803      	ldr	r3, [r0, #0]
2400d562:	f043 0301 	orr.w	r3, r3, #1
2400d566:	6003      	str	r3, [r0, #0]
}
2400d568:	2000      	movs	r0, #0
2400d56a:	bd08      	pop	{r3, pc}
  switch (Channel)
2400d56c:	290c      	cmp	r1, #12
2400d56e:	d1ec      	bne.n	2400d54a <HAL_TIM_IC_Start_IT+0x10>
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
2400d570:	68c3      	ldr	r3, [r0, #12]
2400d572:	f043 0310 	orr.w	r3, r3, #16
2400d576:	e002      	b.n	2400d57e <HAL_TIM_IC_Start_IT+0x44>
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
2400d578:	68c3      	ldr	r3, [r0, #12]
2400d57a:	f043 0302 	orr.w	r3, r3, #2
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
2400d57e:	60c3      	str	r3, [r0, #12]
      break;
2400d580:	e7e3      	b.n	2400d54a <HAL_TIM_IC_Start_IT+0x10>
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
2400d582:	68c3      	ldr	r3, [r0, #12]
2400d584:	f043 0304 	orr.w	r3, r3, #4
2400d588:	e7f9      	b.n	2400d57e <HAL_TIM_IC_Start_IT+0x44>
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
2400d58a:	68c3      	ldr	r3, [r0, #12]
2400d58c:	f043 0308 	orr.w	r3, r3, #8
2400d590:	e7f5      	b.n	2400d57e <HAL_TIM_IC_Start_IT+0x44>
2400d592:	bf00      	nop
2400d594:	00010007 	.word	0x00010007

2400d598 <HAL_TIM_IC_Stop_IT>:
  switch (Channel)
2400d598:	2908      	cmp	r1, #8
      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
2400d59a:	6800      	ldr	r0, [r0, #0]
{
2400d59c:	b508      	push	{r3, lr}
  switch (Channel)
2400d59e:	d025      	beq.n	2400d5ec <HAL_TIM_IC_Stop_IT+0x54>
2400d5a0:	d815      	bhi.n	2400d5ce <HAL_TIM_IC_Stop_IT+0x36>
2400d5a2:	b1d1      	cbz	r1, 2400d5da <HAL_TIM_IC_Stop_IT+0x42>
2400d5a4:	2904      	cmp	r1, #4
2400d5a6:	d01d      	beq.n	2400d5e4 <HAL_TIM_IC_Stop_IT+0x4c>
  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
2400d5a8:	2200      	movs	r2, #0
2400d5aa:	f7ff fd4d 	bl	2400d048 <TIM_CCxChannelCmd>
  __HAL_TIM_DISABLE(htim);
2400d5ae:	6a02      	ldr	r2, [r0, #32]
2400d5b0:	f241 1311 	movw	r3, #4369	@ 0x1111
2400d5b4:	421a      	tst	r2, r3
2400d5b6:	d108      	bne.n	2400d5ca <HAL_TIM_IC_Stop_IT+0x32>
2400d5b8:	6a02      	ldr	r2, [r0, #32]
2400d5ba:	f240 4344 	movw	r3, #1092	@ 0x444
2400d5be:	421a      	tst	r2, r3
2400d5c0:	d103      	bne.n	2400d5ca <HAL_TIM_IC_Stop_IT+0x32>
2400d5c2:	6803      	ldr	r3, [r0, #0]
2400d5c4:	f023 0301 	bic.w	r3, r3, #1
2400d5c8:	6003      	str	r3, [r0, #0]
}
2400d5ca:	2000      	movs	r0, #0
2400d5cc:	bd08      	pop	{r3, pc}
  switch (Channel)
2400d5ce:	290c      	cmp	r1, #12
2400d5d0:	d1ea      	bne.n	2400d5a8 <HAL_TIM_IC_Stop_IT+0x10>
      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
2400d5d2:	68c3      	ldr	r3, [r0, #12]
2400d5d4:	f023 0310 	bic.w	r3, r3, #16
2400d5d8:	e002      	b.n	2400d5e0 <HAL_TIM_IC_Stop_IT+0x48>
      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
2400d5da:	68c3      	ldr	r3, [r0, #12]
2400d5dc:	f023 0302 	bic.w	r3, r3, #2
      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
2400d5e0:	60c3      	str	r3, [r0, #12]
      break;
2400d5e2:	e7e1      	b.n	2400d5a8 <HAL_TIM_IC_Stop_IT+0x10>
      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
2400d5e4:	68c3      	ldr	r3, [r0, #12]
2400d5e6:	f023 0304 	bic.w	r3, r3, #4
2400d5ea:	e7f9      	b.n	2400d5e0 <HAL_TIM_IC_Stop_IT+0x48>
      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
2400d5ec:	68c3      	ldr	r3, [r0, #12]
2400d5ee:	f023 0308 	bic.w	r3, r3, #8
2400d5f2:	e7f5      	b.n	2400d5e0 <HAL_TIM_IC_Stop_IT+0x48>

2400d5f4 <HAL_TIM_IC_Start_DMA>:
{
2400d5f4:	b570      	push	{r4, r5, r6, lr}
2400d5f6:	460d      	mov	r5, r1
  if (htim->State == HAL_TIM_STATE_BUSY)
2400d5f8:	f890 103d 	ldrb.w	r1, [r0, #61]	@ 0x3d
{
2400d5fc:	4604      	mov	r4, r0
  if (htim->State == HAL_TIM_STATE_BUSY)
2400d5fe:	2902      	cmp	r1, #2
2400d600:	b2c8      	uxtb	r0, r1
2400d602:	d006      	beq.n	2400d612 <HAL_TIM_IC_Start_DMA+0x1e>
  else if (htim->State == HAL_TIM_STATE_READY)
2400d604:	f894 103d 	ldrb.w	r1, [r4, #61]	@ 0x3d
2400d608:	2901      	cmp	r1, #1
2400d60a:	d106      	bne.n	2400d61a <HAL_TIM_IC_Start_DMA+0x26>
    if ((pData == NULL) && (Length > 0U))
2400d60c:	b912      	cbnz	r2, 2400d614 <HAL_TIM_IC_Start_DMA+0x20>
2400d60e:	b10b      	cbz	r3, 2400d614 <HAL_TIM_IC_Start_DMA+0x20>
      return HAL_ERROR;
2400d610:	2001      	movs	r0, #1
}
2400d612:	bd70      	pop	{r4, r5, r6, pc}
      htim->State = HAL_TIM_STATE_BUSY;
2400d614:	2102      	movs	r1, #2
2400d616:	f884 103d 	strb.w	r1, [r4, #61]	@ 0x3d
  switch (Channel)
2400d61a:	2d08      	cmp	r5, #8
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData, Length) != HAL_OK)
2400d61c:	6821      	ldr	r1, [r4, #0]
  switch (Channel)
2400d61e:	d04c      	beq.n	2400d6ba <HAL_TIM_IC_Start_DMA+0xc6>
2400d620:	d815      	bhi.n	2400d64e <HAL_TIM_IC_Start_DMA+0x5a>
2400d622:	b33d      	cbz	r5, 2400d674 <HAL_TIM_IC_Start_DMA+0x80>
2400d624:	2d04      	cmp	r5, #4
2400d626:	d037      	beq.n	2400d698 <HAL_TIM_IC_Start_DMA+0xa4>
  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
2400d628:	6820      	ldr	r0, [r4, #0]
2400d62a:	2201      	movs	r2, #1
2400d62c:	4629      	mov	r1, r5
2400d62e:	f7ff fd0b 	bl	2400d048 <TIM_CCxChannelCmd>
  tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
2400d632:	6882      	ldr	r2, [r0, #8]
2400d634:	4b29      	ldr	r3, [pc, #164]	@ (2400d6dc <HAL_TIM_IC_Start_DMA+0xe8>)
2400d636:	4013      	ands	r3, r2
  if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
2400d638:	2b06      	cmp	r3, #6
2400d63a:	d006      	beq.n	2400d64a <HAL_TIM_IC_Start_DMA+0x56>
2400d63c:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
2400d640:	d003      	beq.n	2400d64a <HAL_TIM_IC_Start_DMA+0x56>
    __HAL_TIM_ENABLE(htim);
2400d642:	6803      	ldr	r3, [r0, #0]
2400d644:	f043 0301 	orr.w	r3, r3, #1
2400d648:	6003      	str	r3, [r0, #0]
  return HAL_OK;
2400d64a:	2000      	movs	r0, #0
2400d64c:	e7e1      	b.n	2400d612 <HAL_TIM_IC_Start_DMA+0x1e>
  switch (Channel)
2400d64e:	2d0c      	cmp	r5, #12
2400d650:	d1ea      	bne.n	2400d628 <HAL_TIM_IC_Start_DMA+0x34>
      htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMACaptureCplt;
2400d652:	6b20      	ldr	r0, [r4, #48]	@ 0x30
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)&htim->Instance->CCR4, (uint32_t)pData, Length) != HAL_OK)
2400d654:	3140      	adds	r1, #64	@ 0x40
      htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMACaptureCplt;
2400d656:	4e22      	ldr	r6, [pc, #136]	@ (2400d6e0 <HAL_TIM_IC_Start_DMA+0xec>)
2400d658:	63c6      	str	r6, [r0, #60]	@ 0x3c
      htim->hdma[TIM_DMA_ID_CC4]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
2400d65a:	4e22      	ldr	r6, [pc, #136]	@ (2400d6e4 <HAL_TIM_IC_Start_DMA+0xf0>)
2400d65c:	6406      	str	r6, [r0, #64]	@ 0x40
      htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
2400d65e:	4e22      	ldr	r6, [pc, #136]	@ (2400d6e8 <HAL_TIM_IC_Start_DMA+0xf4>)
2400d660:	64c6      	str	r6, [r0, #76]	@ 0x4c
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)&htim->Instance->CCR4, (uint32_t)pData, Length) != HAL_OK)
2400d662:	f7f4 f9bd 	bl	240019e0 <HAL_DMA_Start_IT>
2400d666:	2800      	cmp	r0, #0
2400d668:	d1d2      	bne.n	2400d610 <HAL_TIM_IC_Start_DMA+0x1c>
      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
2400d66a:	6822      	ldr	r2, [r4, #0]
2400d66c:	68d3      	ldr	r3, [r2, #12]
2400d66e:	f443 5380 	orr.w	r3, r3, #4096	@ 0x1000
2400d672:	e00f      	b.n	2400d694 <HAL_TIM_IC_Start_DMA+0xa0>
      htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
2400d674:	6a60      	ldr	r0, [r4, #36]	@ 0x24
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData, Length) != HAL_OK)
2400d676:	3134      	adds	r1, #52	@ 0x34
      htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
2400d678:	4e19      	ldr	r6, [pc, #100]	@ (2400d6e0 <HAL_TIM_IC_Start_DMA+0xec>)
2400d67a:	63c6      	str	r6, [r0, #60]	@ 0x3c
      htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
2400d67c:	4e19      	ldr	r6, [pc, #100]	@ (2400d6e4 <HAL_TIM_IC_Start_DMA+0xf0>)
2400d67e:	6406      	str	r6, [r0, #64]	@ 0x40
      htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
2400d680:	4e19      	ldr	r6, [pc, #100]	@ (2400d6e8 <HAL_TIM_IC_Start_DMA+0xf4>)
2400d682:	64c6      	str	r6, [r0, #76]	@ 0x4c
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData, Length) != HAL_OK)
2400d684:	f7f4 f9ac 	bl	240019e0 <HAL_DMA_Start_IT>
2400d688:	2800      	cmp	r0, #0
2400d68a:	d1c1      	bne.n	2400d610 <HAL_TIM_IC_Start_DMA+0x1c>
      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
2400d68c:	6822      	ldr	r2, [r4, #0]
2400d68e:	68d3      	ldr	r3, [r2, #12]
2400d690:	f443 7300 	orr.w	r3, r3, #512	@ 0x200
      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
2400d694:	60d3      	str	r3, [r2, #12]
      break;
2400d696:	e7c7      	b.n	2400d628 <HAL_TIM_IC_Start_DMA+0x34>
      htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;
2400d698:	6aa0      	ldr	r0, [r4, #40]	@ 0x28
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData, Length) != HAL_OK)
2400d69a:	3138      	adds	r1, #56	@ 0x38
      htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;
2400d69c:	4e10      	ldr	r6, [pc, #64]	@ (2400d6e0 <HAL_TIM_IC_Start_DMA+0xec>)
2400d69e:	63c6      	str	r6, [r0, #60]	@ 0x3c
      htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
2400d6a0:	4e10      	ldr	r6, [pc, #64]	@ (2400d6e4 <HAL_TIM_IC_Start_DMA+0xf0>)
2400d6a2:	6406      	str	r6, [r0, #64]	@ 0x40
      htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
2400d6a4:	4e10      	ldr	r6, [pc, #64]	@ (2400d6e8 <HAL_TIM_IC_Start_DMA+0xf4>)
2400d6a6:	64c6      	str	r6, [r0, #76]	@ 0x4c
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData, Length) != HAL_OK)
2400d6a8:	f7f4 f99a 	bl	240019e0 <HAL_DMA_Start_IT>
2400d6ac:	2800      	cmp	r0, #0
2400d6ae:	d1af      	bne.n	2400d610 <HAL_TIM_IC_Start_DMA+0x1c>
      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
2400d6b0:	6822      	ldr	r2, [r4, #0]
2400d6b2:	68d3      	ldr	r3, [r2, #12]
2400d6b4:	f443 6380 	orr.w	r3, r3, #1024	@ 0x400
2400d6b8:	e7ec      	b.n	2400d694 <HAL_TIM_IC_Start_DMA+0xa0>
      htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMACaptureCplt;
2400d6ba:	6ae0      	ldr	r0, [r4, #44]	@ 0x2c
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)&htim->Instance->CCR3, (uint32_t)pData, Length) != HAL_OK)
2400d6bc:	313c      	adds	r1, #60	@ 0x3c
      htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMACaptureCplt;
2400d6be:	4e08      	ldr	r6, [pc, #32]	@ (2400d6e0 <HAL_TIM_IC_Start_DMA+0xec>)
2400d6c0:	63c6      	str	r6, [r0, #60]	@ 0x3c
      htim->hdma[TIM_DMA_ID_CC3]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
2400d6c2:	4e08      	ldr	r6, [pc, #32]	@ (2400d6e4 <HAL_TIM_IC_Start_DMA+0xf0>)
2400d6c4:	6406      	str	r6, [r0, #64]	@ 0x40
      htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
2400d6c6:	4e08      	ldr	r6, [pc, #32]	@ (2400d6e8 <HAL_TIM_IC_Start_DMA+0xf4>)
2400d6c8:	64c6      	str	r6, [r0, #76]	@ 0x4c
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)&htim->Instance->CCR3, (uint32_t)pData, Length) != HAL_OK)
2400d6ca:	f7f4 f989 	bl	240019e0 <HAL_DMA_Start_IT>
2400d6ce:	2800      	cmp	r0, #0
2400d6d0:	d19e      	bne.n	2400d610 <HAL_TIM_IC_Start_DMA+0x1c>
      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
2400d6d2:	6822      	ldr	r2, [r4, #0]
2400d6d4:	68d3      	ldr	r3, [r2, #12]
2400d6d6:	f443 6300 	orr.w	r3, r3, #2048	@ 0x800
2400d6da:	e7db      	b.n	2400d694 <HAL_TIM_IC_Start_DMA+0xa0>
2400d6dc:	00010007 	.word	0x00010007
2400d6e0:	2400c2e3 	.word	0x2400c2e3
2400d6e4:	2400c321 	.word	0x2400c321
2400d6e8:	2400c55f 	.word	0x2400c55f

2400d6ec <HAL_TIM_IC_Stop_DMA>:
  switch (Channel)
2400d6ec:	2908      	cmp	r1, #8
{
2400d6ee:	b538      	push	{r3, r4, r5, lr}
2400d6f0:	4604      	mov	r4, r0
2400d6f2:	460d      	mov	r5, r1
      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
2400d6f4:	6803      	ldr	r3, [r0, #0]
  switch (Channel)
2400d6f6:	d031      	beq.n	2400d75c <HAL_TIM_IC_Stop_DMA+0x70>
2400d6f8:	d81a      	bhi.n	2400d730 <HAL_TIM_IC_Stop_DMA+0x44>
2400d6fa:	b309      	cbz	r1, 2400d740 <HAL_TIM_IC_Stop_DMA+0x54>
2400d6fc:	2904      	cmp	r1, #4
2400d6fe:	d027      	beq.n	2400d750 <HAL_TIM_IC_Stop_DMA+0x64>
  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
2400d700:	6820      	ldr	r0, [r4, #0]
2400d702:	2200      	movs	r2, #0
2400d704:	4629      	mov	r1, r5
2400d706:	f7ff fc9f 	bl	2400d048 <TIM_CCxChannelCmd>
  __HAL_TIM_DISABLE(htim);
2400d70a:	6a02      	ldr	r2, [r0, #32]
2400d70c:	f241 1311 	movw	r3, #4369	@ 0x1111
2400d710:	421a      	tst	r2, r3
2400d712:	d108      	bne.n	2400d726 <HAL_TIM_IC_Stop_DMA+0x3a>
2400d714:	6a02      	ldr	r2, [r0, #32]
2400d716:	f240 4344 	movw	r3, #1092	@ 0x444
2400d71a:	421a      	tst	r2, r3
2400d71c:	d103      	bne.n	2400d726 <HAL_TIM_IC_Stop_DMA+0x3a>
2400d71e:	6803      	ldr	r3, [r0, #0]
2400d720:	f023 0301 	bic.w	r3, r3, #1
2400d724:	6003      	str	r3, [r0, #0]
  htim->State = HAL_TIM_STATE_READY;
2400d726:	2301      	movs	r3, #1
}
2400d728:	2000      	movs	r0, #0
  htim->State = HAL_TIM_STATE_READY;
2400d72a:	f884 303d 	strb.w	r3, [r4, #61]	@ 0x3d
}
2400d72e:	bd38      	pop	{r3, r4, r5, pc}
  switch (Channel)
2400d730:	290c      	cmp	r1, #12
2400d732:	d1e5      	bne.n	2400d700 <HAL_TIM_IC_Stop_DMA+0x14>
      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
2400d734:	68da      	ldr	r2, [r3, #12]
      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC4]);
2400d736:	6b00      	ldr	r0, [r0, #48]	@ 0x30
      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
2400d738:	f422 5280 	bic.w	r2, r2, #4096	@ 0x1000
2400d73c:	60da      	str	r2, [r3, #12]
      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC4]);
2400d73e:	e004      	b.n	2400d74a <HAL_TIM_IC_Stop_DMA+0x5e>
      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
2400d740:	68da      	ldr	r2, [r3, #12]
      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);
2400d742:	6a40      	ldr	r0, [r0, #36]	@ 0x24
      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
2400d744:	f422 7200 	bic.w	r2, r2, #512	@ 0x200
2400d748:	60da      	str	r2, [r3, #12]
      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC4]);
2400d74a:	f7f4 fc0f 	bl	24001f6c <HAL_DMA_Abort_IT>
      break;
2400d74e:	e7d7      	b.n	2400d700 <HAL_TIM_IC_Stop_DMA+0x14>
      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
2400d750:	68da      	ldr	r2, [r3, #12]
      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);
2400d752:	6a80      	ldr	r0, [r0, #40]	@ 0x28
      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
2400d754:	f422 6280 	bic.w	r2, r2, #1024	@ 0x400
2400d758:	60da      	str	r2, [r3, #12]
      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);
2400d75a:	e7f6      	b.n	2400d74a <HAL_TIM_IC_Stop_DMA+0x5e>
      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
2400d75c:	68da      	ldr	r2, [r3, #12]
      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC3]);
2400d75e:	6ac0      	ldr	r0, [r0, #44]	@ 0x2c
      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
2400d760:	f422 6200 	bic.w	r2, r2, #2048	@ 0x800
2400d764:	60da      	str	r2, [r3, #12]
      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC3]);
2400d766:	e7f0      	b.n	2400d74a <HAL_TIM_IC_Stop_DMA+0x5e>

2400d768 <TIM_CCxNChannelCmd>:
  */
static void TIM_CCxNChannelCmd(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ChannelNState)
{
  uint32_t tmp;

  tmp = TIM_CCER_CC1NE << (Channel & 0x1FU); /* 0x1FU = 31 bits max shift */
2400d768:	f001 011f 	and.w	r1, r1, #31

  /* Reset the CCxNE Bit */
  TIMx->CCER &=  ~tmp;
2400d76c:	6a03      	ldr	r3, [r0, #32]
{
2400d76e:	b510      	push	{r4, lr}
  tmp = TIM_CCER_CC1NE << (Channel & 0x1FU); /* 0x1FU = 31 bits max shift */
2400d770:	2404      	movs	r4, #4

  /* Set or reset the CCxNE Bit */
  TIMx->CCER |= (uint32_t)(ChannelNState << (Channel & 0x1FU)); /* 0x1FU = 31 bits max shift */
2400d772:	408a      	lsls	r2, r1
  tmp = TIM_CCER_CC1NE << (Channel & 0x1FU); /* 0x1FU = 31 bits max shift */
2400d774:	408c      	lsls	r4, r1
  TIMx->CCER &=  ~tmp;
2400d776:	ea23 0304 	bic.w	r3, r3, r4
2400d77a:	6203      	str	r3, [r0, #32]
  TIMx->CCER |= (uint32_t)(ChannelNState << (Channel & 0x1FU)); /* 0x1FU = 31 bits max shift */
2400d77c:	6a03      	ldr	r3, [r0, #32]
2400d77e:	431a      	orrs	r2, r3
2400d780:	6202      	str	r2, [r0, #32]
}
2400d782:	bd10      	pop	{r4, pc}

2400d784 <HAL_TIMEx_HallSensor_MspInit>:
}
2400d784:	4770      	bx	lr

2400d786 <HAL_TIMEx_HallSensor_Init>:
{
2400d786:	b570      	push	{r4, r5, r6, lr}
2400d788:	460e      	mov	r6, r1
2400d78a:	b088      	sub	sp, #32
  if (htim == NULL)
2400d78c:	4604      	mov	r4, r0
2400d78e:	2800      	cmp	r0, #0
2400d790:	d052      	beq.n	2400d838 <HAL_TIMEx_HallSensor_Init+0xb2>
  if (htim->State == HAL_TIM_STATE_RESET)
2400d792:	f890 303d 	ldrb.w	r3, [r0, #61]	@ 0x3d
2400d796:	f003 02ff 	and.w	r2, r3, #255	@ 0xff
2400d79a:	b91b      	cbnz	r3, 2400d7a4 <HAL_TIMEx_HallSensor_Init+0x1e>
    htim->Lock = HAL_UNLOCKED;
2400d79c:	f880 203c 	strb.w	r2, [r0, #60]	@ 0x3c
    HAL_TIMEx_HallSensor_MspInit(htim);
2400d7a0:	f7ff fff0 	bl	2400d784 <HAL_TIMEx_HallSensor_MspInit>
  htim->State = HAL_TIM_STATE_BUSY;
2400d7a4:	2302      	movs	r3, #2
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
2400d7a6:	1d21      	adds	r1, r4, #4
2400d7a8:	6820      	ldr	r0, [r4, #0]
  OC_Config.OCFastMode = TIM_OCFAST_DISABLE;
2400d7aa:	2500      	movs	r5, #0
  htim->State = HAL_TIM_STATE_BUSY;
2400d7ac:	f884 303d 	strb.w	r3, [r4, #61]	@ 0x3d
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
2400d7b0:	f7fe feef 	bl	2400c592 <TIM_Base_SetConfig>
  TIM_TI1_SetConfig(htim->Instance, sConfig->IC1Polarity, TIM_ICSELECTION_TRC, sConfig->IC1Filter);
2400d7b4:	68b3      	ldr	r3, [r6, #8]
2400d7b6:	2203      	movs	r2, #3
2400d7b8:	6831      	ldr	r1, [r6, #0]
2400d7ba:	6820      	ldr	r0, [r4, #0]
2400d7bc:	f7ff f91b 	bl	2400c9f6 <TIM_TI1_SetConfig>
  htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;
2400d7c0:	6820      	ldr	r0, [r4, #0]
  htim->Instance->CCMR1 |= sConfig->IC1Prescaler;
2400d7c2:	6872      	ldr	r2, [r6, #4]
  TIM_OC2_SetConfig(htim->Instance, &OC_Config);
2400d7c4:	a901      	add	r1, sp, #4
  htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;
2400d7c6:	6983      	ldr	r3, [r0, #24]
2400d7c8:	f023 030c 	bic.w	r3, r3, #12
2400d7cc:	6183      	str	r3, [r0, #24]
  htim->Instance->CCMR1 |= sConfig->IC1Prescaler;
2400d7ce:	6983      	ldr	r3, [r0, #24]
2400d7d0:	4313      	orrs	r3, r2
2400d7d2:	6183      	str	r3, [r0, #24]
  htim->Instance->CR2 |= TIM_CR2_TI1S;
2400d7d4:	6843      	ldr	r3, [r0, #4]
2400d7d6:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
2400d7da:	6043      	str	r3, [r0, #4]
  htim->Instance->SMCR &= ~TIM_SMCR_TS;
2400d7dc:	6883      	ldr	r3, [r0, #8]
2400d7de:	f423 1340 	bic.w	r3, r3, #3145728	@ 0x300000
2400d7e2:	f023 0370 	bic.w	r3, r3, #112	@ 0x70
2400d7e6:	6083      	str	r3, [r0, #8]
  htim->Instance->SMCR |= TIM_TS_TI1F_ED;
2400d7e8:	6883      	ldr	r3, [r0, #8]
2400d7ea:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
2400d7ee:	6083      	str	r3, [r0, #8]
  htim->Instance->SMCR &= ~TIM_SMCR_SMS;
2400d7f0:	6883      	ldr	r3, [r0, #8]
2400d7f2:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
2400d7f6:	f023 0307 	bic.w	r3, r3, #7
2400d7fa:	6083      	str	r3, [r0, #8]
  htim->Instance->SMCR |= TIM_SLAVEMODE_RESET;
2400d7fc:	6883      	ldr	r3, [r0, #8]
2400d7fe:	f043 0304 	orr.w	r3, r3, #4
2400d802:	6083      	str	r3, [r0, #8]
  OC_Config.OCMode = TIM_OCMODE_PWM2;
2400d804:	2370      	movs	r3, #112	@ 0x70
  OC_Config.OCNIdleState = TIM_OCNIDLESTATE_RESET;
2400d806:	9507      	str	r5, [sp, #28]
  OC_Config.OCMode = TIM_OCMODE_PWM2;
2400d808:	9301      	str	r3, [sp, #4]
  OC_Config.Pulse = sConfig->Commutation_Delay;
2400d80a:	68f3      	ldr	r3, [r6, #12]
  OC_Config.OCIdleState = TIM_OCIDLESTATE_RESET;
2400d80c:	e9cd 5505 	strd	r5, r5, [sp, #20]
  OC_Config.Pulse = sConfig->Commutation_Delay;
2400d810:	9302      	str	r3, [sp, #8]
  OC_Config.OCPolarity = TIM_OCPOLARITY_HIGH;
2400d812:	e9cd 5503 	strd	r5, r5, [sp, #12]
  TIM_OC2_SetConfig(htim->Instance, &OC_Config);
2400d816:	f7fe fff6 	bl	2400c806 <TIM_OC2_SetConfig>
  htim->Instance->CR2 &= ~TIM_CR2_MMS;
2400d81a:	6823      	ldr	r3, [r4, #0]
  return HAL_OK;
2400d81c:	4628      	mov	r0, r5
  htim->Instance->CR2 &= ~TIM_CR2_MMS;
2400d81e:	685a      	ldr	r2, [r3, #4]
2400d820:	f022 0270 	bic.w	r2, r2, #112	@ 0x70
2400d824:	605a      	str	r2, [r3, #4]
  htim->Instance->CR2 |= TIM_TRGO_OC2REF;
2400d826:	685a      	ldr	r2, [r3, #4]
2400d828:	f042 0250 	orr.w	r2, r2, #80	@ 0x50
2400d82c:	605a      	str	r2, [r3, #4]
  htim->State = HAL_TIM_STATE_READY;
2400d82e:	2301      	movs	r3, #1
2400d830:	f884 303d 	strb.w	r3, [r4, #61]	@ 0x3d
}
2400d834:	b008      	add	sp, #32
2400d836:	bd70      	pop	{r4, r5, r6, pc}
    return HAL_ERROR;
2400d838:	2001      	movs	r0, #1
2400d83a:	e7fb      	b.n	2400d834 <HAL_TIMEx_HallSensor_Init+0xae>

2400d83c <HAL_TIMEx_HallSensor_MspDeInit>:
__weak void HAL_TIMEx_HallSensor_MspDeInit(TIM_HandleTypeDef *htim)
2400d83c:	4770      	bx	lr

2400d83e <HAL_TIMEx_HallSensor_DeInit>:
  htim->State = HAL_TIM_STATE_BUSY;
2400d83e:	2302      	movs	r3, #2
  __HAL_TIM_DISABLE(htim);
2400d840:	f241 1211 	movw	r2, #4369	@ 0x1111
{
2400d844:	b510      	push	{r4, lr}
  htim->State = HAL_TIM_STATE_BUSY;
2400d846:	f880 303d 	strb.w	r3, [r0, #61]	@ 0x3d
{
2400d84a:	4604      	mov	r4, r0
  __HAL_TIM_DISABLE(htim);
2400d84c:	6803      	ldr	r3, [r0, #0]
2400d84e:	6a19      	ldr	r1, [r3, #32]
2400d850:	4211      	tst	r1, r2
2400d852:	d108      	bne.n	2400d866 <HAL_TIMEx_HallSensor_DeInit+0x28>
2400d854:	6a19      	ldr	r1, [r3, #32]
2400d856:	f240 4244 	movw	r2, #1092	@ 0x444
2400d85a:	4211      	tst	r1, r2
2400d85c:	d103      	bne.n	2400d866 <HAL_TIMEx_HallSensor_DeInit+0x28>
2400d85e:	681a      	ldr	r2, [r3, #0]
2400d860:	f022 0201 	bic.w	r2, r2, #1
2400d864:	601a      	str	r2, [r3, #0]
  HAL_TIMEx_HallSensor_MspDeInit(htim);
2400d866:	4620      	mov	r0, r4
2400d868:	f7ff ffe8 	bl	2400d83c <HAL_TIMEx_HallSensor_MspDeInit>
  htim->State = HAL_TIM_STATE_RESET;
2400d86c:	2000      	movs	r0, #0
2400d86e:	f884 003d 	strb.w	r0, [r4, #61]	@ 0x3d
  __HAL_UNLOCK(htim);
2400d872:	f884 003c 	strb.w	r0, [r4, #60]	@ 0x3c
}
2400d876:	bd10      	pop	{r4, pc}

2400d878 <HAL_TIMEx_HallSensor_Start>:
{
2400d878:	b510      	push	{r4, lr}
2400d87a:	4604      	mov	r4, r0
  TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
2400d87c:	2201      	movs	r2, #1
2400d87e:	2100      	movs	r1, #0
2400d880:	6800      	ldr	r0, [r0, #0]
2400d882:	f7ff fbe1 	bl	2400d048 <TIM_CCxChannelCmd>
  tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
2400d886:	6822      	ldr	r2, [r4, #0]
2400d888:	4b06      	ldr	r3, [pc, #24]	@ (2400d8a4 <HAL_TIMEx_HallSensor_Start+0x2c>)
2400d88a:	6891      	ldr	r1, [r2, #8]
2400d88c:	400b      	ands	r3, r1
  if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
2400d88e:	2b06      	cmp	r3, #6
2400d890:	d006      	beq.n	2400d8a0 <HAL_TIMEx_HallSensor_Start+0x28>
2400d892:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
2400d896:	d003      	beq.n	2400d8a0 <HAL_TIMEx_HallSensor_Start+0x28>
    __HAL_TIM_ENABLE(htim);
2400d898:	6813      	ldr	r3, [r2, #0]
2400d89a:	f043 0301 	orr.w	r3, r3, #1
2400d89e:	6013      	str	r3, [r2, #0]
}
2400d8a0:	2000      	movs	r0, #0
2400d8a2:	bd10      	pop	{r4, pc}
2400d8a4:	00010007 	.word	0x00010007

2400d8a8 <HAL_TIMEx_HallSensor_Stop>:
  TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
2400d8a8:	2200      	movs	r2, #0
{
2400d8aa:	b510      	push	{r4, lr}
2400d8ac:	4604      	mov	r4, r0
  TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
2400d8ae:	4611      	mov	r1, r2
2400d8b0:	6800      	ldr	r0, [r0, #0]
2400d8b2:	f7ff fbc9 	bl	2400d048 <TIM_CCxChannelCmd>
  __HAL_TIM_DISABLE(htim);
2400d8b6:	6823      	ldr	r3, [r4, #0]
2400d8b8:	f241 1211 	movw	r2, #4369	@ 0x1111
2400d8bc:	6a19      	ldr	r1, [r3, #32]
2400d8be:	4211      	tst	r1, r2
2400d8c0:	d108      	bne.n	2400d8d4 <HAL_TIMEx_HallSensor_Stop+0x2c>
2400d8c2:	6a19      	ldr	r1, [r3, #32]
2400d8c4:	f240 4244 	movw	r2, #1092	@ 0x444
2400d8c8:	4211      	tst	r1, r2
2400d8ca:	d103      	bne.n	2400d8d4 <HAL_TIMEx_HallSensor_Stop+0x2c>
2400d8cc:	681a      	ldr	r2, [r3, #0]
2400d8ce:	f022 0201 	bic.w	r2, r2, #1
2400d8d2:	601a      	str	r2, [r3, #0]
}
2400d8d4:	2000      	movs	r0, #0
2400d8d6:	bd10      	pop	{r4, pc}

2400d8d8 <HAL_TIMEx_HallSensor_Start_IT>:
{
2400d8d8:	b510      	push	{r4, lr}
2400d8da:	4604      	mov	r4, r0
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
2400d8dc:	6800      	ldr	r0, [r0, #0]
  TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
2400d8de:	2201      	movs	r2, #1
2400d8e0:	2100      	movs	r1, #0
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
2400d8e2:	68c3      	ldr	r3, [r0, #12]
2400d8e4:	f043 0302 	orr.w	r3, r3, #2
2400d8e8:	60c3      	str	r3, [r0, #12]
  TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
2400d8ea:	f7ff fbad 	bl	2400d048 <TIM_CCxChannelCmd>
  tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
2400d8ee:	6822      	ldr	r2, [r4, #0]
2400d8f0:	4b06      	ldr	r3, [pc, #24]	@ (2400d90c <HAL_TIMEx_HallSensor_Start_IT+0x34>)
2400d8f2:	6891      	ldr	r1, [r2, #8]
2400d8f4:	400b      	ands	r3, r1
  if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
2400d8f6:	2b06      	cmp	r3, #6
2400d8f8:	d006      	beq.n	2400d908 <HAL_TIMEx_HallSensor_Start_IT+0x30>
2400d8fa:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
2400d8fe:	d003      	beq.n	2400d908 <HAL_TIMEx_HallSensor_Start_IT+0x30>
    __HAL_TIM_ENABLE(htim);
2400d900:	6813      	ldr	r3, [r2, #0]
2400d902:	f043 0301 	orr.w	r3, r3, #1
2400d906:	6013      	str	r3, [r2, #0]
}
2400d908:	2000      	movs	r0, #0
2400d90a:	bd10      	pop	{r4, pc}
2400d90c:	00010007 	.word	0x00010007

2400d910 <HAL_TIMEx_HallSensor_Stop_IT>:
  TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
2400d910:	2200      	movs	r2, #0
{
2400d912:	b510      	push	{r4, lr}
2400d914:	4604      	mov	r4, r0
  TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
2400d916:	4611      	mov	r1, r2
2400d918:	6800      	ldr	r0, [r0, #0]
2400d91a:	f7ff fb95 	bl	2400d048 <TIM_CCxChannelCmd>
  __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
2400d91e:	6823      	ldr	r3, [r4, #0]
2400d920:	68da      	ldr	r2, [r3, #12]
2400d922:	f022 0202 	bic.w	r2, r2, #2
2400d926:	60da      	str	r2, [r3, #12]
  __HAL_TIM_DISABLE(htim);
2400d928:	f241 1211 	movw	r2, #4369	@ 0x1111
2400d92c:	6a19      	ldr	r1, [r3, #32]
2400d92e:	4211      	tst	r1, r2
2400d930:	d108      	bne.n	2400d944 <HAL_TIMEx_HallSensor_Stop_IT+0x34>
2400d932:	6a19      	ldr	r1, [r3, #32]
2400d934:	f240 4244 	movw	r2, #1092	@ 0x444
2400d938:	4211      	tst	r1, r2
2400d93a:	d103      	bne.n	2400d944 <HAL_TIMEx_HallSensor_Stop_IT+0x34>
2400d93c:	681a      	ldr	r2, [r3, #0]
2400d93e:	f022 0201 	bic.w	r2, r2, #1
2400d942:	601a      	str	r2, [r3, #0]
}
2400d944:	2000      	movs	r0, #0
2400d946:	bd10      	pop	{r4, pc}

2400d948 <HAL_TIMEx_HallSensor_Start_DMA>:
{
2400d948:	b570      	push	{r4, r5, r6, lr}
  if (htim->State == HAL_TIM_STATE_BUSY)
2400d94a:	f890 303d 	ldrb.w	r3, [r0, #61]	@ 0x3d
{
2400d94e:	4604      	mov	r4, r0
2400d950:	460d      	mov	r5, r1
2400d952:	4616      	mov	r6, r2
  if (htim->State == HAL_TIM_STATE_BUSY)
2400d954:	2b02      	cmp	r3, #2
2400d956:	b2d8      	uxtb	r0, r3
2400d958:	d006      	beq.n	2400d968 <HAL_TIMEx_HallSensor_Start_DMA+0x20>
  else if (htim->State == HAL_TIM_STATE_READY)
2400d95a:	f894 303d 	ldrb.w	r3, [r4, #61]	@ 0x3d
2400d95e:	2b01      	cmp	r3, #1
2400d960:	d106      	bne.n	2400d970 <HAL_TIMEx_HallSensor_Start_DMA+0x28>
    if (((uint32_t)pData == 0U) && (Length > 0U))
2400d962:	b911      	cbnz	r1, 2400d96a <HAL_TIMEx_HallSensor_Start_DMA+0x22>
2400d964:	b10a      	cbz	r2, 2400d96a <HAL_TIMEx_HallSensor_Start_DMA+0x22>
      return HAL_ERROR;
2400d966:	2001      	movs	r0, #1
}
2400d968:	bd70      	pop	{r4, r5, r6, pc}
      htim->State = HAL_TIM_STATE_BUSY;
2400d96a:	2302      	movs	r3, #2
2400d96c:	f884 303d 	strb.w	r3, [r4, #61]	@ 0x3d
  TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
2400d970:	2201      	movs	r2, #1
2400d972:	2100      	movs	r1, #0
2400d974:	6820      	ldr	r0, [r4, #0]
2400d976:	f7ff fb67 	bl	2400d048 <TIM_CCxChannelCmd>
  htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
2400d97a:	6a60      	ldr	r0, [r4, #36]	@ 0x24
2400d97c:	4b0f      	ldr	r3, [pc, #60]	@ (2400d9bc <HAL_TIMEx_HallSensor_Start_DMA+0x74>)
  if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData, Length) != HAL_OK)
2400d97e:	462a      	mov	r2, r5
2400d980:	6821      	ldr	r1, [r4, #0]
  htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
2400d982:	63c3      	str	r3, [r0, #60]	@ 0x3c
  htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
2400d984:	4b0e      	ldr	r3, [pc, #56]	@ (2400d9c0 <HAL_TIMEx_HallSensor_Start_DMA+0x78>)
  if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData, Length) != HAL_OK)
2400d986:	3134      	adds	r1, #52	@ 0x34
  htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
2400d988:	6403      	str	r3, [r0, #64]	@ 0x40
  htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
2400d98a:	4b0e      	ldr	r3, [pc, #56]	@ (2400d9c4 <HAL_TIMEx_HallSensor_Start_DMA+0x7c>)
2400d98c:	64c3      	str	r3, [r0, #76]	@ 0x4c
  if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData, Length) != HAL_OK)
2400d98e:	4633      	mov	r3, r6
2400d990:	f7f4 f826 	bl	240019e0 <HAL_DMA_Start_IT>
2400d994:	2800      	cmp	r0, #0
2400d996:	d1e6      	bne.n	2400d966 <HAL_TIMEx_HallSensor_Start_DMA+0x1e>
  __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
2400d998:	6823      	ldr	r3, [r4, #0]
2400d99a:	68da      	ldr	r2, [r3, #12]
2400d99c:	f442 7200 	orr.w	r2, r2, #512	@ 0x200
2400d9a0:	60da      	str	r2, [r3, #12]
  tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
2400d9a2:	4a09      	ldr	r2, [pc, #36]	@ (2400d9c8 <HAL_TIMEx_HallSensor_Start_DMA+0x80>)
2400d9a4:	6899      	ldr	r1, [r3, #8]
2400d9a6:	400a      	ands	r2, r1
  if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
2400d9a8:	2a06      	cmp	r2, #6
2400d9aa:	d0dd      	beq.n	2400d968 <HAL_TIMEx_HallSensor_Start_DMA+0x20>
2400d9ac:	f5b2 3f80 	cmp.w	r2, #65536	@ 0x10000
2400d9b0:	d0da      	beq.n	2400d968 <HAL_TIMEx_HallSensor_Start_DMA+0x20>
    __HAL_TIM_ENABLE(htim);
2400d9b2:	681a      	ldr	r2, [r3, #0]
2400d9b4:	f042 0201 	orr.w	r2, r2, #1
2400d9b8:	601a      	str	r2, [r3, #0]
2400d9ba:	e7d5      	b.n	2400d968 <HAL_TIMEx_HallSensor_Start_DMA+0x20>
2400d9bc:	2400c2e3 	.word	0x2400c2e3
2400d9c0:	2400c321 	.word	0x2400c321
2400d9c4:	2400c55f 	.word	0x2400c55f
2400d9c8:	00010007 	.word	0x00010007

2400d9cc <HAL_TIMEx_HallSensor_Stop_DMA>:
  TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
2400d9cc:	2200      	movs	r2, #0
{
2400d9ce:	b510      	push	{r4, lr}
2400d9d0:	4604      	mov	r4, r0
  TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
2400d9d2:	4611      	mov	r1, r2
2400d9d4:	6800      	ldr	r0, [r0, #0]
2400d9d6:	f7ff fb37 	bl	2400d048 <TIM_CCxChannelCmd>
  __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
2400d9da:	6822      	ldr	r2, [r4, #0]
  (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);
2400d9dc:	6a60      	ldr	r0, [r4, #36]	@ 0x24
  __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
2400d9de:	68d3      	ldr	r3, [r2, #12]
2400d9e0:	f423 7300 	bic.w	r3, r3, #512	@ 0x200
2400d9e4:	60d3      	str	r3, [r2, #12]
  (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);
2400d9e6:	f7f4 fac1 	bl	24001f6c <HAL_DMA_Abort_IT>
  __HAL_TIM_DISABLE(htim);
2400d9ea:	6823      	ldr	r3, [r4, #0]
2400d9ec:	f241 1211 	movw	r2, #4369	@ 0x1111
2400d9f0:	6a19      	ldr	r1, [r3, #32]
2400d9f2:	4211      	tst	r1, r2
2400d9f4:	d108      	bne.n	2400da08 <HAL_TIMEx_HallSensor_Stop_DMA+0x3c>
2400d9f6:	6a19      	ldr	r1, [r3, #32]
2400d9f8:	f240 4244 	movw	r2, #1092	@ 0x444
2400d9fc:	4211      	tst	r1, r2
2400d9fe:	d103      	bne.n	2400da08 <HAL_TIMEx_HallSensor_Stop_DMA+0x3c>
2400da00:	681a      	ldr	r2, [r3, #0]
2400da02:	f022 0201 	bic.w	r2, r2, #1
2400da06:	601a      	str	r2, [r3, #0]
}
2400da08:	2000      	movs	r0, #0
2400da0a:	bd10      	pop	{r4, pc}

2400da0c <HAL_TIMEx_OCN_Start>:
  TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
2400da0c:	6800      	ldr	r0, [r0, #0]
2400da0e:	2204      	movs	r2, #4
{
2400da10:	b508      	push	{r3, lr}
  TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
2400da12:	f7ff fea9 	bl	2400d768 <TIM_CCxNChannelCmd>
  __HAL_TIM_MOE_ENABLE(htim);
2400da16:	6c43      	ldr	r3, [r0, #68]	@ 0x44
2400da18:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
2400da1c:	6443      	str	r3, [r0, #68]	@ 0x44
  tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
2400da1e:	4b07      	ldr	r3, [pc, #28]	@ (2400da3c <HAL_TIMEx_OCN_Start+0x30>)
2400da20:	6882      	ldr	r2, [r0, #8]
2400da22:	4013      	ands	r3, r2
  if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
2400da24:	2b06      	cmp	r3, #6
2400da26:	d006      	beq.n	2400da36 <HAL_TIMEx_OCN_Start+0x2a>
2400da28:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
2400da2c:	d003      	beq.n	2400da36 <HAL_TIMEx_OCN_Start+0x2a>
    __HAL_TIM_ENABLE(htim);
2400da2e:	6803      	ldr	r3, [r0, #0]
2400da30:	f043 0301 	orr.w	r3, r3, #1
2400da34:	6003      	str	r3, [r0, #0]
}
2400da36:	2000      	movs	r0, #0
2400da38:	bd08      	pop	{r3, pc}
2400da3a:	bf00      	nop
2400da3c:	00010007 	.word	0x00010007

2400da40 <HAL_TIMEx_OCN_Stop>:
  TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);
2400da40:	6800      	ldr	r0, [r0, #0]
2400da42:	2200      	movs	r2, #0
{
2400da44:	b508      	push	{r3, lr}
  TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);
2400da46:	f7ff fe8f 	bl	2400d768 <TIM_CCxNChannelCmd>
  __HAL_TIM_MOE_DISABLE(htim);
2400da4a:	6a02      	ldr	r2, [r0, #32]
2400da4c:	f241 1311 	movw	r3, #4369	@ 0x1111
2400da50:	421a      	tst	r2, r3
2400da52:	d108      	bne.n	2400da66 <HAL_TIMEx_OCN_Stop+0x26>
2400da54:	6a02      	ldr	r2, [r0, #32]
2400da56:	f240 4344 	movw	r3, #1092	@ 0x444
2400da5a:	421a      	tst	r2, r3
2400da5c:	d103      	bne.n	2400da66 <HAL_TIMEx_OCN_Stop+0x26>
2400da5e:	6c43      	ldr	r3, [r0, #68]	@ 0x44
2400da60:	f423 4300 	bic.w	r3, r3, #32768	@ 0x8000
2400da64:	6443      	str	r3, [r0, #68]	@ 0x44
  __HAL_TIM_DISABLE(htim);
2400da66:	6a02      	ldr	r2, [r0, #32]
2400da68:	f241 1311 	movw	r3, #4369	@ 0x1111
2400da6c:	421a      	tst	r2, r3
2400da6e:	d108      	bne.n	2400da82 <HAL_TIMEx_OCN_Stop+0x42>
2400da70:	6a02      	ldr	r2, [r0, #32]
2400da72:	f240 4344 	movw	r3, #1092	@ 0x444
2400da76:	421a      	tst	r2, r3
2400da78:	d103      	bne.n	2400da82 <HAL_TIMEx_OCN_Stop+0x42>
2400da7a:	6803      	ldr	r3, [r0, #0]
2400da7c:	f023 0301 	bic.w	r3, r3, #1
2400da80:	6003      	str	r3, [r0, #0]
}
2400da82:	2000      	movs	r0, #0
2400da84:	bd08      	pop	{r3, pc}

2400da86 <HAL_TIMEx_OCN_Start_IT>:
  switch (Channel)
2400da86:	2904      	cmp	r1, #4
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
2400da88:	6800      	ldr	r0, [r0, #0]
{
2400da8a:	b508      	push	{r3, lr}
  switch (Channel)
2400da8c:	d01f      	beq.n	2400dace <HAL_TIMEx_OCN_Start_IT+0x48>
2400da8e:	2908      	cmp	r1, #8
2400da90:	d021      	beq.n	2400dad6 <HAL_TIMEx_OCN_Start_IT+0x50>
2400da92:	b919      	cbnz	r1, 2400da9c <HAL_TIMEx_OCN_Start_IT+0x16>
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
2400da94:	68c3      	ldr	r3, [r0, #12]
2400da96:	f043 0302 	orr.w	r3, r3, #2
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
2400da9a:	60c3      	str	r3, [r0, #12]
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_BREAK);
2400da9c:	68c3      	ldr	r3, [r0, #12]
  TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
2400da9e:	2204      	movs	r2, #4
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_BREAK);
2400daa0:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
2400daa4:	60c3      	str	r3, [r0, #12]
  TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
2400daa6:	f7ff fe5f 	bl	2400d768 <TIM_CCxNChannelCmd>
  __HAL_TIM_MOE_ENABLE(htim);
2400daaa:	6c43      	ldr	r3, [r0, #68]	@ 0x44
2400daac:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
2400dab0:	6443      	str	r3, [r0, #68]	@ 0x44
  tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
2400dab2:	4b0b      	ldr	r3, [pc, #44]	@ (2400dae0 <HAL_TIMEx_OCN_Start_IT+0x5a>)
2400dab4:	6882      	ldr	r2, [r0, #8]
2400dab6:	4013      	ands	r3, r2
  if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
2400dab8:	2b06      	cmp	r3, #6
2400daba:	d006      	beq.n	2400daca <HAL_TIMEx_OCN_Start_IT+0x44>
2400dabc:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
2400dac0:	d003      	beq.n	2400daca <HAL_TIMEx_OCN_Start_IT+0x44>
    __HAL_TIM_ENABLE(htim);
2400dac2:	6803      	ldr	r3, [r0, #0]
2400dac4:	f043 0301 	orr.w	r3, r3, #1
2400dac8:	6003      	str	r3, [r0, #0]
}
2400daca:	2000      	movs	r0, #0
2400dacc:	bd08      	pop	{r3, pc}
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
2400dace:	68c3      	ldr	r3, [r0, #12]
2400dad0:	f043 0304 	orr.w	r3, r3, #4
2400dad4:	e7e1      	b.n	2400da9a <HAL_TIMEx_OCN_Start_IT+0x14>
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
2400dad6:	68c3      	ldr	r3, [r0, #12]
2400dad8:	f043 0308 	orr.w	r3, r3, #8
2400dadc:	e7dd      	b.n	2400da9a <HAL_TIMEx_OCN_Start_IT+0x14>
2400dade:	bf00      	nop
2400dae0:	00010007 	.word	0x00010007

2400dae4 <HAL_TIMEx_OCN_Stop_IT>:
  switch (Channel)
2400dae4:	2904      	cmp	r1, #4
      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
2400dae6:	6800      	ldr	r0, [r0, #0]
{
2400dae8:	b508      	push	{r3, lr}
  switch (Channel)
2400daea:	d030      	beq.n	2400db4e <HAL_TIMEx_OCN_Stop_IT+0x6a>
2400daec:	2908      	cmp	r1, #8
2400daee:	d032      	beq.n	2400db56 <HAL_TIMEx_OCN_Stop_IT+0x72>
2400daf0:	b919      	cbnz	r1, 2400dafa <HAL_TIMEx_OCN_Stop_IT+0x16>
      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
2400daf2:	68c3      	ldr	r3, [r0, #12]
2400daf4:	f023 0302 	bic.w	r3, r3, #2
      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
2400daf8:	60c3      	str	r3, [r0, #12]
  TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);
2400dafa:	2200      	movs	r2, #0
2400dafc:	f7ff fe34 	bl	2400d768 <TIM_CCxNChannelCmd>
  tmpccer = htim->Instance->CCER;
2400db00:	6a02      	ldr	r2, [r0, #32]
  if ((tmpccer & (TIM_CCER_CC1NE | TIM_CCER_CC2NE | TIM_CCER_CC3NE)) == (uint32_t)RESET)
2400db02:	f240 4344 	movw	r3, #1092	@ 0x444
2400db06:	421a      	tst	r2, r3
2400db08:	d103      	bne.n	2400db12 <HAL_TIMEx_OCN_Stop_IT+0x2e>
    __HAL_TIM_DISABLE_IT(htim, TIM_IT_BREAK);
2400db0a:	68c3      	ldr	r3, [r0, #12]
2400db0c:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
2400db10:	60c3      	str	r3, [r0, #12]
  __HAL_TIM_MOE_DISABLE(htim);
2400db12:	6a02      	ldr	r2, [r0, #32]
2400db14:	f241 1311 	movw	r3, #4369	@ 0x1111
2400db18:	421a      	tst	r2, r3
2400db1a:	d108      	bne.n	2400db2e <HAL_TIMEx_OCN_Stop_IT+0x4a>
2400db1c:	6a02      	ldr	r2, [r0, #32]
2400db1e:	f240 4344 	movw	r3, #1092	@ 0x444
2400db22:	421a      	tst	r2, r3
2400db24:	d103      	bne.n	2400db2e <HAL_TIMEx_OCN_Stop_IT+0x4a>
2400db26:	6c43      	ldr	r3, [r0, #68]	@ 0x44
2400db28:	f423 4300 	bic.w	r3, r3, #32768	@ 0x8000
2400db2c:	6443      	str	r3, [r0, #68]	@ 0x44
  __HAL_TIM_DISABLE(htim);
2400db2e:	6a02      	ldr	r2, [r0, #32]
2400db30:	f241 1311 	movw	r3, #4369	@ 0x1111
2400db34:	421a      	tst	r2, r3
2400db36:	d108      	bne.n	2400db4a <HAL_TIMEx_OCN_Stop_IT+0x66>
2400db38:	6a02      	ldr	r2, [r0, #32]
2400db3a:	f240 4344 	movw	r3, #1092	@ 0x444
2400db3e:	421a      	tst	r2, r3
2400db40:	d103      	bne.n	2400db4a <HAL_TIMEx_OCN_Stop_IT+0x66>
2400db42:	6803      	ldr	r3, [r0, #0]
2400db44:	f023 0301 	bic.w	r3, r3, #1
2400db48:	6003      	str	r3, [r0, #0]
}
2400db4a:	2000      	movs	r0, #0
2400db4c:	bd08      	pop	{r3, pc}
      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
2400db4e:	68c3      	ldr	r3, [r0, #12]
2400db50:	f023 0304 	bic.w	r3, r3, #4
2400db54:	e7d0      	b.n	2400daf8 <HAL_TIMEx_OCN_Stop_IT+0x14>
      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
2400db56:	68c3      	ldr	r3, [r0, #12]
2400db58:	f023 0308 	bic.w	r3, r3, #8
2400db5c:	e7cc      	b.n	2400daf8 <HAL_TIMEx_OCN_Stop_IT+0x14>

2400db5e <HAL_TIMEx_OCN_Start_DMA>:
{
2400db5e:	b570      	push	{r4, r5, r6, lr}
2400db60:	460d      	mov	r5, r1
2400db62:	4611      	mov	r1, r2
  if (htim->State == HAL_TIM_STATE_BUSY)
2400db64:	f890 203d 	ldrb.w	r2, [r0, #61]	@ 0x3d
{
2400db68:	4604      	mov	r4, r0
  if (htim->State == HAL_TIM_STATE_BUSY)
2400db6a:	2a02      	cmp	r2, #2
2400db6c:	b2d0      	uxtb	r0, r2
2400db6e:	d006      	beq.n	2400db7e <HAL_TIMEx_OCN_Start_DMA+0x20>
  else if (htim->State == HAL_TIM_STATE_READY)
2400db70:	f894 203d 	ldrb.w	r2, [r4, #61]	@ 0x3d
2400db74:	2a01      	cmp	r2, #1
2400db76:	d106      	bne.n	2400db86 <HAL_TIMEx_OCN_Start_DMA+0x28>
    if (((uint32_t)pData == 0U) && (Length > 0U))
2400db78:	b911      	cbnz	r1, 2400db80 <HAL_TIMEx_OCN_Start_DMA+0x22>
2400db7a:	b10b      	cbz	r3, 2400db80 <HAL_TIMEx_OCN_Start_DMA+0x22>
      return HAL_ERROR;
2400db7c:	2001      	movs	r0, #1
}
2400db7e:	bd70      	pop	{r4, r5, r6, pc}
      htim->State = HAL_TIM_STATE_BUSY;
2400db80:	2202      	movs	r2, #2
2400db82:	f884 203d 	strb.w	r2, [r4, #61]	@ 0x3d
  switch (Channel)
2400db86:	2d04      	cmp	r5, #4
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1, Length) != HAL_OK)
2400db88:	6822      	ldr	r2, [r4, #0]
  switch (Channel)
2400db8a:	d02a      	beq.n	2400dbe2 <HAL_TIMEx_OCN_Start_DMA+0x84>
2400db8c:	2d08      	cmp	r5, #8
2400db8e:	d039      	beq.n	2400dc04 <HAL_TIMEx_OCN_Start_DMA+0xa6>
2400db90:	b985      	cbnz	r5, 2400dbb4 <HAL_TIMEx_OCN_Start_DMA+0x56>
      htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseCplt;
2400db92:	6a60      	ldr	r0, [r4, #36]	@ 0x24
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1, Length) != HAL_OK)
2400db94:	3234      	adds	r2, #52	@ 0x34
      htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseCplt;
2400db96:	4e24      	ldr	r6, [pc, #144]	@ (2400dc28 <HAL_TIMEx_OCN_Start_DMA+0xca>)
2400db98:	63c6      	str	r6, [r0, #60]	@ 0x3c
      htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
2400db9a:	4e24      	ldr	r6, [pc, #144]	@ (2400dc2c <HAL_TIMEx_OCN_Start_DMA+0xce>)
2400db9c:	6406      	str	r6, [r0, #64]	@ 0x40
      htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
2400db9e:	4e24      	ldr	r6, [pc, #144]	@ (2400dc30 <HAL_TIMEx_OCN_Start_DMA+0xd2>)
2400dba0:	64c6      	str	r6, [r0, #76]	@ 0x4c
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1, Length) != HAL_OK)
2400dba2:	f7f3 ff1d 	bl	240019e0 <HAL_DMA_Start_IT>
2400dba6:	2800      	cmp	r0, #0
2400dba8:	d1e8      	bne.n	2400db7c <HAL_TIMEx_OCN_Start_DMA+0x1e>
      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
2400dbaa:	6822      	ldr	r2, [r4, #0]
2400dbac:	68d3      	ldr	r3, [r2, #12]
2400dbae:	f443 7300 	orr.w	r3, r3, #512	@ 0x200
      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
2400dbb2:	60d3      	str	r3, [r2, #12]
  TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
2400dbb4:	6820      	ldr	r0, [r4, #0]
2400dbb6:	2204      	movs	r2, #4
2400dbb8:	4629      	mov	r1, r5
2400dbba:	f7ff fdd5 	bl	2400d768 <TIM_CCxNChannelCmd>
  __HAL_TIM_MOE_ENABLE(htim);
2400dbbe:	6c43      	ldr	r3, [r0, #68]	@ 0x44
2400dbc0:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
2400dbc4:	6443      	str	r3, [r0, #68]	@ 0x44
  tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
2400dbc6:	4b1b      	ldr	r3, [pc, #108]	@ (2400dc34 <HAL_TIMEx_OCN_Start_DMA+0xd6>)
2400dbc8:	6882      	ldr	r2, [r0, #8]
2400dbca:	4013      	ands	r3, r2
  if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
2400dbcc:	2b06      	cmp	r3, #6
2400dbce:	d006      	beq.n	2400dbde <HAL_TIMEx_OCN_Start_DMA+0x80>
2400dbd0:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
2400dbd4:	d003      	beq.n	2400dbde <HAL_TIMEx_OCN_Start_DMA+0x80>
    __HAL_TIM_ENABLE(htim);
2400dbd6:	6803      	ldr	r3, [r0, #0]
2400dbd8:	f043 0301 	orr.w	r3, r3, #1
2400dbdc:	6003      	str	r3, [r0, #0]
  return HAL_OK;
2400dbde:	2000      	movs	r0, #0
2400dbe0:	e7cd      	b.n	2400db7e <HAL_TIMEx_OCN_Start_DMA+0x20>
      htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;
2400dbe2:	6aa0      	ldr	r0, [r4, #40]	@ 0x28
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2, Length) != HAL_OK)
2400dbe4:	3238      	adds	r2, #56	@ 0x38
      htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;
2400dbe6:	4e10      	ldr	r6, [pc, #64]	@ (2400dc28 <HAL_TIMEx_OCN_Start_DMA+0xca>)
2400dbe8:	63c6      	str	r6, [r0, #60]	@ 0x3c
      htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
2400dbea:	4e10      	ldr	r6, [pc, #64]	@ (2400dc2c <HAL_TIMEx_OCN_Start_DMA+0xce>)
2400dbec:	6406      	str	r6, [r0, #64]	@ 0x40
      htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
2400dbee:	4e10      	ldr	r6, [pc, #64]	@ (2400dc30 <HAL_TIMEx_OCN_Start_DMA+0xd2>)
2400dbf0:	64c6      	str	r6, [r0, #76]	@ 0x4c
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2, Length) != HAL_OK)
2400dbf2:	f7f3 fef5 	bl	240019e0 <HAL_DMA_Start_IT>
2400dbf6:	2800      	cmp	r0, #0
2400dbf8:	d1c0      	bne.n	2400db7c <HAL_TIMEx_OCN_Start_DMA+0x1e>
      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
2400dbfa:	6822      	ldr	r2, [r4, #0]
2400dbfc:	68d3      	ldr	r3, [r2, #12]
2400dbfe:	f443 6380 	orr.w	r3, r3, #1024	@ 0x400
2400dc02:	e7d6      	b.n	2400dbb2 <HAL_TIMEx_OCN_Start_DMA+0x54>
      htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseCplt;
2400dc04:	6ae0      	ldr	r0, [r4, #44]	@ 0x2c
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3, Length) != HAL_OK)
2400dc06:	323c      	adds	r2, #60	@ 0x3c
      htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseCplt;
2400dc08:	4e07      	ldr	r6, [pc, #28]	@ (2400dc28 <HAL_TIMEx_OCN_Start_DMA+0xca>)
2400dc0a:	63c6      	str	r6, [r0, #60]	@ 0x3c
      htim->hdma[TIM_DMA_ID_CC3]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
2400dc0c:	4e07      	ldr	r6, [pc, #28]	@ (2400dc2c <HAL_TIMEx_OCN_Start_DMA+0xce>)
2400dc0e:	6406      	str	r6, [r0, #64]	@ 0x40
      htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
2400dc10:	4e07      	ldr	r6, [pc, #28]	@ (2400dc30 <HAL_TIMEx_OCN_Start_DMA+0xd2>)
2400dc12:	64c6      	str	r6, [r0, #76]	@ 0x4c
      if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3, Length) != HAL_OK)
2400dc14:	f7f3 fee4 	bl	240019e0 <HAL_DMA_Start_IT>
2400dc18:	2800      	cmp	r0, #0
2400dc1a:	d1af      	bne.n	2400db7c <HAL_TIMEx_OCN_Start_DMA+0x1e>
      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
2400dc1c:	6822      	ldr	r2, [r4, #0]
2400dc1e:	68d3      	ldr	r3, [r2, #12]
2400dc20:	f443 6300 	orr.w	r3, r3, #2048	@ 0x800
2400dc24:	e7c5      	b.n	2400dbb2 <HAL_TIMEx_OCN_Start_DMA+0x54>
2400dc26:	bf00      	nop
2400dc28:	2400c35f 	.word	0x2400c35f
2400dc2c:	2400c39d 	.word	0x2400c39d
2400dc30:	2400c55f 	.word	0x2400c55f
2400dc34:	00010007 	.word	0x00010007

2400dc38 <HAL_TIMEx_OCN_Stop_DMA>:
  switch (Channel)
2400dc38:	2904      	cmp	r1, #4
{
2400dc3a:	b538      	push	{r3, r4, r5, lr}
2400dc3c:	4604      	mov	r4, r0
2400dc3e:	460d      	mov	r5, r1
      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
2400dc40:	6803      	ldr	r3, [r0, #0]
  switch (Channel)
2400dc42:	d02f      	beq.n	2400dca4 <HAL_TIMEx_OCN_Stop_DMA+0x6c>
2400dc44:	2908      	cmp	r1, #8
2400dc46:	d033      	beq.n	2400dcb0 <HAL_TIMEx_OCN_Stop_DMA+0x78>
2400dc48:	b931      	cbnz	r1, 2400dc58 <HAL_TIMEx_OCN_Stop_DMA+0x20>
      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
2400dc4a:	68da      	ldr	r2, [r3, #12]
      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);
2400dc4c:	6a40      	ldr	r0, [r0, #36]	@ 0x24
      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
2400dc4e:	f422 7200 	bic.w	r2, r2, #512	@ 0x200
2400dc52:	60da      	str	r2, [r3, #12]
      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC3]);
2400dc54:	f7f4 f98a 	bl	24001f6c <HAL_DMA_Abort_IT>
  TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);
2400dc58:	6820      	ldr	r0, [r4, #0]
2400dc5a:	2200      	movs	r2, #0
2400dc5c:	4629      	mov	r1, r5
2400dc5e:	f7ff fd83 	bl	2400d768 <TIM_CCxNChannelCmd>
  __HAL_TIM_MOE_DISABLE(htim);
2400dc62:	6a02      	ldr	r2, [r0, #32]
2400dc64:	f241 1311 	movw	r3, #4369	@ 0x1111
2400dc68:	421a      	tst	r2, r3
2400dc6a:	d108      	bne.n	2400dc7e <HAL_TIMEx_OCN_Stop_DMA+0x46>
2400dc6c:	6a02      	ldr	r2, [r0, #32]
2400dc6e:	f240 4344 	movw	r3, #1092	@ 0x444
2400dc72:	421a      	tst	r2, r3
2400dc74:	d103      	bne.n	2400dc7e <HAL_TIMEx_OCN_Stop_DMA+0x46>
2400dc76:	6c43      	ldr	r3, [r0, #68]	@ 0x44
2400dc78:	f423 4300 	bic.w	r3, r3, #32768	@ 0x8000
2400dc7c:	6443      	str	r3, [r0, #68]	@ 0x44
  __HAL_TIM_DISABLE(htim);
2400dc7e:	6a02      	ldr	r2, [r0, #32]
2400dc80:	f241 1311 	movw	r3, #4369	@ 0x1111
2400dc84:	421a      	tst	r2, r3
2400dc86:	d108      	bne.n	2400dc9a <HAL_TIMEx_OCN_Stop_DMA+0x62>
2400dc88:	6a02      	ldr	r2, [r0, #32]
2400dc8a:	f240 4344 	movw	r3, #1092	@ 0x444
2400dc8e:	421a      	tst	r2, r3
2400dc90:	d103      	bne.n	2400dc9a <HAL_TIMEx_OCN_Stop_DMA+0x62>
2400dc92:	6803      	ldr	r3, [r0, #0]
2400dc94:	f023 0301 	bic.w	r3, r3, #1
2400dc98:	6003      	str	r3, [r0, #0]
  htim->State = HAL_TIM_STATE_READY;
2400dc9a:	2301      	movs	r3, #1
}
2400dc9c:	2000      	movs	r0, #0
  htim->State = HAL_TIM_STATE_READY;
2400dc9e:	f884 303d 	strb.w	r3, [r4, #61]	@ 0x3d
}
2400dca2:	bd38      	pop	{r3, r4, r5, pc}
      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
2400dca4:	68da      	ldr	r2, [r3, #12]
      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);
2400dca6:	6a80      	ldr	r0, [r0, #40]	@ 0x28
      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
2400dca8:	f422 6280 	bic.w	r2, r2, #1024	@ 0x400
2400dcac:	60da      	str	r2, [r3, #12]
      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);
2400dcae:	e7d1      	b.n	2400dc54 <HAL_TIMEx_OCN_Stop_DMA+0x1c>
      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
2400dcb0:	68da      	ldr	r2, [r3, #12]
      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC3]);
2400dcb2:	6ac0      	ldr	r0, [r0, #44]	@ 0x2c
      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
2400dcb4:	f422 6200 	bic.w	r2, r2, #2048	@ 0x800
2400dcb8:	60da      	str	r2, [r3, #12]
      (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC3]);
2400dcba:	e7cb      	b.n	2400dc54 <HAL_TIMEx_OCN_Stop_DMA+0x1c>

2400dcbc <HAL_TIMEx_PWMN_Start>:
HAL_StatusTypeDef HAL_TIMEx_PWMN_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
2400dcbc:	f7ff bea6 	b.w	2400da0c <HAL_TIMEx_OCN_Start>

2400dcc0 <HAL_TIMEx_PWMN_Stop>:
HAL_StatusTypeDef HAL_TIMEx_PWMN_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
2400dcc0:	f7ff bebe 	b.w	2400da40 <HAL_TIMEx_OCN_Stop>

2400dcc4 <HAL_TIMEx_PWMN_Start_IT>:
HAL_StatusTypeDef HAL_TIMEx_PWMN_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
2400dcc4:	f7ff bedf 	b.w	2400da86 <HAL_TIMEx_OCN_Start_IT>

2400dcc8 <HAL_TIMEx_PWMN_Stop_IT>:
HAL_StatusTypeDef HAL_TIMEx_PWMN_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
2400dcc8:	f7ff bf0c 	b.w	2400dae4 <HAL_TIMEx_OCN_Stop_IT>

2400dccc <HAL_TIMEx_PWMN_Start_DMA>:
HAL_StatusTypeDef HAL_TIMEx_PWMN_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
2400dccc:	f7ff bf47 	b.w	2400db5e <HAL_TIMEx_OCN_Start_DMA>

2400dcd0 <HAL_TIMEx_PWMN_Stop_DMA>:
HAL_StatusTypeDef HAL_TIMEx_PWMN_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
2400dcd0:	f7ff bfb2 	b.w	2400dc38 <HAL_TIMEx_OCN_Stop_DMA>

2400dcd4 <HAL_TIMEx_OnePulseN_Start>:
  TIM_CCxNChannelCmd(htim->Instance, OutputChannel, TIM_CCxN_ENABLE);
2400dcd4:	6800      	ldr	r0, [r0, #0]
2400dcd6:	2204      	movs	r2, #4
{
2400dcd8:	b508      	push	{r3, lr}
  TIM_CCxNChannelCmd(htim->Instance, OutputChannel, TIM_CCxN_ENABLE);
2400dcda:	f7ff fd45 	bl	2400d768 <TIM_CCxNChannelCmd>
  __HAL_TIM_MOE_ENABLE(htim);
2400dcde:	6c43      	ldr	r3, [r0, #68]	@ 0x44
2400dce0:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
2400dce4:	6443      	str	r3, [r0, #68]	@ 0x44
}
2400dce6:	2000      	movs	r0, #0
2400dce8:	bd08      	pop	{r3, pc}

2400dcea <HAL_TIMEx_OnePulseN_Stop>:
HAL_StatusTypeDef HAL_TIMEx_OnePulseN_Stop(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
2400dcea:	f7ff bea9 	b.w	2400da40 <HAL_TIMEx_OCN_Stop>

2400dcee <HAL_TIMEx_OnePulseN_Start_IT>:
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
2400dcee:	6800      	ldr	r0, [r0, #0]
  TIM_CCxNChannelCmd(htim->Instance, OutputChannel, TIM_CCxN_ENABLE);
2400dcf0:	2204      	movs	r2, #4
{
2400dcf2:	b508      	push	{r3, lr}
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
2400dcf4:	68c3      	ldr	r3, [r0, #12]
2400dcf6:	f043 0302 	orr.w	r3, r3, #2
2400dcfa:	60c3      	str	r3, [r0, #12]
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
2400dcfc:	68c3      	ldr	r3, [r0, #12]
2400dcfe:	f043 0304 	orr.w	r3, r3, #4
2400dd02:	60c3      	str	r3, [r0, #12]
  TIM_CCxNChannelCmd(htim->Instance, OutputChannel, TIM_CCxN_ENABLE);
2400dd04:	f7ff fd30 	bl	2400d768 <TIM_CCxNChannelCmd>
  __HAL_TIM_MOE_ENABLE(htim);
2400dd08:	6c43      	ldr	r3, [r0, #68]	@ 0x44
2400dd0a:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
2400dd0e:	6443      	str	r3, [r0, #68]	@ 0x44
}
2400dd10:	2000      	movs	r0, #0
2400dd12:	bd08      	pop	{r3, pc}

2400dd14 <HAL_TIMEx_OnePulseN_Stop_IT>:
  __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
2400dd14:	6800      	ldr	r0, [r0, #0]
  TIM_CCxNChannelCmd(htim->Instance, OutputChannel, TIM_CCxN_DISABLE);
2400dd16:	2200      	movs	r2, #0
{
2400dd18:	b508      	push	{r3, lr}
  __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
2400dd1a:	68c3      	ldr	r3, [r0, #12]
2400dd1c:	f023 0302 	bic.w	r3, r3, #2
2400dd20:	60c3      	str	r3, [r0, #12]
  __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
2400dd22:	68c3      	ldr	r3, [r0, #12]
2400dd24:	f023 0304 	bic.w	r3, r3, #4
2400dd28:	60c3      	str	r3, [r0, #12]
  TIM_CCxNChannelCmd(htim->Instance, OutputChannel, TIM_CCxN_DISABLE);
2400dd2a:	f7ff fd1d 	bl	2400d768 <TIM_CCxNChannelCmd>
  __HAL_TIM_MOE_DISABLE(htim);
2400dd2e:	6a02      	ldr	r2, [r0, #32]
2400dd30:	f241 1311 	movw	r3, #4369	@ 0x1111
2400dd34:	421a      	tst	r2, r3
2400dd36:	d108      	bne.n	2400dd4a <HAL_TIMEx_OnePulseN_Stop_IT+0x36>
2400dd38:	6a02      	ldr	r2, [r0, #32]
2400dd3a:	f240 4344 	movw	r3, #1092	@ 0x444
2400dd3e:	421a      	tst	r2, r3
2400dd40:	d103      	bne.n	2400dd4a <HAL_TIMEx_OnePulseN_Stop_IT+0x36>
2400dd42:	6c43      	ldr	r3, [r0, #68]	@ 0x44
2400dd44:	f423 4300 	bic.w	r3, r3, #32768	@ 0x8000
2400dd48:	6443      	str	r3, [r0, #68]	@ 0x44
  __HAL_TIM_DISABLE(htim);
2400dd4a:	6a02      	ldr	r2, [r0, #32]
2400dd4c:	f241 1311 	movw	r3, #4369	@ 0x1111
2400dd50:	421a      	tst	r2, r3
2400dd52:	d108      	bne.n	2400dd66 <HAL_TIMEx_OnePulseN_Stop_IT+0x52>
2400dd54:	6a02      	ldr	r2, [r0, #32]
2400dd56:	f240 4344 	movw	r3, #1092	@ 0x444
2400dd5a:	421a      	tst	r2, r3
2400dd5c:	d103      	bne.n	2400dd66 <HAL_TIMEx_OnePulseN_Stop_IT+0x52>
2400dd5e:	6803      	ldr	r3, [r0, #0]
2400dd60:	f023 0301 	bic.w	r3, r3, #1
2400dd64:	6003      	str	r3, [r0, #0]
}
2400dd66:	2000      	movs	r0, #0
2400dd68:	bd08      	pop	{r3, pc}

2400dd6a <HAL_TIMEx_ConfigCommutEvent>:
{
2400dd6a:	b510      	push	{r4, lr}
  __HAL_LOCK(htim);
2400dd6c:	f890 303c 	ldrb.w	r3, [r0, #60]	@ 0x3c
{
2400dd70:	4604      	mov	r4, r0
  __HAL_LOCK(htim);
2400dd72:	2b01      	cmp	r3, #1
2400dd74:	d02b      	beq.n	2400ddce <HAL_TIMEx_ConfigCommutEvent+0x64>
2400dd76:	2301      	movs	r3, #1
2400dd78:	f880 303c 	strb.w	r3, [r0, #60]	@ 0x3c
  if ((InputTrigger == TIM_TS_ITR0)  || (InputTrigger == TIM_TS_ITR1) ||
2400dd7c:	f031 0330 	bics.w	r3, r1, #48	@ 0x30
2400dd80:	6803      	ldr	r3, [r0, #0]
2400dd82:	d004      	beq.n	2400dd8e <HAL_TIMEx_ConfigCommutEvent+0x24>
2400dd84:	f021 0010 	bic.w	r0, r1, #16
      (InputTrigger == TIM_TS_ITR2)  || (InputTrigger == TIM_TS_ITR3) ||
2400dd88:	f5b0 1f00 	cmp.w	r0, #2097152	@ 0x200000
2400dd8c:	d108      	bne.n	2400dda0 <HAL_TIMEx_ConfigCommutEvent+0x36>
    htim->Instance->SMCR &= ~TIM_SMCR_TS;
2400dd8e:	6898      	ldr	r0, [r3, #8]
2400dd90:	f420 1040 	bic.w	r0, r0, #3145728	@ 0x300000
2400dd94:	f020 0070 	bic.w	r0, r0, #112	@ 0x70
2400dd98:	6098      	str	r0, [r3, #8]
    htim->Instance->SMCR |= InputTrigger;
2400dd9a:	6898      	ldr	r0, [r3, #8]
2400dd9c:	4301      	orrs	r1, r0
2400dd9e:	6099      	str	r1, [r3, #8]
  htim->Instance->CR2 |= TIM_CR2_CCPC;
2400dda0:	6859      	ldr	r1, [r3, #4]
  __HAL_UNLOCK(htim);
2400dda2:	2000      	movs	r0, #0
  htim->Instance->CR2 |= TIM_CR2_CCPC;
2400dda4:	f041 0101 	orr.w	r1, r1, #1
2400dda8:	6059      	str	r1, [r3, #4]
  htim->Instance->CR2 &= ~TIM_CR2_CCUS;
2400ddaa:	6859      	ldr	r1, [r3, #4]
2400ddac:	f021 0104 	bic.w	r1, r1, #4
2400ddb0:	6059      	str	r1, [r3, #4]
  htim->Instance->CR2 |= CommutationSource;
2400ddb2:	6859      	ldr	r1, [r3, #4]
2400ddb4:	430a      	orrs	r2, r1
2400ddb6:	605a      	str	r2, [r3, #4]
  __HAL_TIM_DISABLE_IT(htim, TIM_IT_COM);
2400ddb8:	68da      	ldr	r2, [r3, #12]
2400ddba:	f022 0220 	bic.w	r2, r2, #32
2400ddbe:	60da      	str	r2, [r3, #12]
  __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_COM);
2400ddc0:	68da      	ldr	r2, [r3, #12]
2400ddc2:	f422 5200 	bic.w	r2, r2, #8192	@ 0x2000
2400ddc6:	60da      	str	r2, [r3, #12]
  __HAL_UNLOCK(htim);
2400ddc8:	f884 003c 	strb.w	r0, [r4, #60]	@ 0x3c
}
2400ddcc:	bd10      	pop	{r4, pc}
  __HAL_LOCK(htim);
2400ddce:	2002      	movs	r0, #2
2400ddd0:	e7fc      	b.n	2400ddcc <HAL_TIMEx_ConfigCommutEvent+0x62>

2400ddd2 <HAL_TIMEx_ConfigCommutEvent_IT>:
{
2400ddd2:	b510      	push	{r4, lr}
  __HAL_LOCK(htim);
2400ddd4:	f890 303c 	ldrb.w	r3, [r0, #60]	@ 0x3c
{
2400ddd8:	4604      	mov	r4, r0
  __HAL_LOCK(htim);
2400ddda:	2b01      	cmp	r3, #1
2400dddc:	d02b      	beq.n	2400de36 <HAL_TIMEx_ConfigCommutEvent_IT+0x64>
2400ddde:	2301      	movs	r3, #1
2400dde0:	f880 303c 	strb.w	r3, [r0, #60]	@ 0x3c
  if ((InputTrigger == TIM_TS_ITR0)  || (InputTrigger == TIM_TS_ITR1) ||
2400dde4:	f031 0330 	bics.w	r3, r1, #48	@ 0x30
2400dde8:	6803      	ldr	r3, [r0, #0]
2400ddea:	d004      	beq.n	2400ddf6 <HAL_TIMEx_ConfigCommutEvent_IT+0x24>
2400ddec:	f021 0010 	bic.w	r0, r1, #16
      (InputTrigger == TIM_TS_ITR2)  || (InputTrigger == TIM_TS_ITR3) ||
2400ddf0:	f5b0 1f00 	cmp.w	r0, #2097152	@ 0x200000
2400ddf4:	d108      	bne.n	2400de08 <HAL_TIMEx_ConfigCommutEvent_IT+0x36>
    htim->Instance->SMCR &= ~TIM_SMCR_TS;
2400ddf6:	6898      	ldr	r0, [r3, #8]
2400ddf8:	f420 1040 	bic.w	r0, r0, #3145728	@ 0x300000
2400ddfc:	f020 0070 	bic.w	r0, r0, #112	@ 0x70
2400de00:	6098      	str	r0, [r3, #8]
    htim->Instance->SMCR |= InputTrigger;
2400de02:	6898      	ldr	r0, [r3, #8]
2400de04:	4301      	orrs	r1, r0
2400de06:	6099      	str	r1, [r3, #8]
  htim->Instance->CR2 |= TIM_CR2_CCPC;
2400de08:	6859      	ldr	r1, [r3, #4]
  __HAL_UNLOCK(htim);
2400de0a:	2000      	movs	r0, #0
  htim->Instance->CR2 |= TIM_CR2_CCPC;
2400de0c:	f041 0101 	orr.w	r1, r1, #1
2400de10:	6059      	str	r1, [r3, #4]
  htim->Instance->CR2 &= ~TIM_CR2_CCUS;
2400de12:	6859      	ldr	r1, [r3, #4]
2400de14:	f021 0104 	bic.w	r1, r1, #4
2400de18:	6059      	str	r1, [r3, #4]
  htim->Instance->CR2 |= CommutationSource;
2400de1a:	6859      	ldr	r1, [r3, #4]
2400de1c:	430a      	orrs	r2, r1
2400de1e:	605a      	str	r2, [r3, #4]
  __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_COM);
2400de20:	68da      	ldr	r2, [r3, #12]
2400de22:	f422 5200 	bic.w	r2, r2, #8192	@ 0x2000
2400de26:	60da      	str	r2, [r3, #12]
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_COM);
2400de28:	68da      	ldr	r2, [r3, #12]
2400de2a:	f042 0220 	orr.w	r2, r2, #32
2400de2e:	60da      	str	r2, [r3, #12]
  __HAL_UNLOCK(htim);
2400de30:	f884 003c 	strb.w	r0, [r4, #60]	@ 0x3c
}
2400de34:	bd10      	pop	{r4, pc}
  __HAL_LOCK(htim);
2400de36:	2002      	movs	r0, #2
2400de38:	e7fc      	b.n	2400de34 <HAL_TIMEx_ConfigCommutEvent_IT+0x62>

2400de3a <HAL_TIMEx_ConfigCommutEvent_DMA>:
{
2400de3a:	b510      	push	{r4, lr}
  __HAL_LOCK(htim);
2400de3c:	f890 303c 	ldrb.w	r3, [r0, #60]	@ 0x3c
{
2400de40:	4604      	mov	r4, r0
  __HAL_LOCK(htim);
2400de42:	2b01      	cmp	r3, #1
2400de44:	d032      	beq.n	2400deac <HAL_TIMEx_ConfigCommutEvent_DMA+0x72>
2400de46:	2301      	movs	r3, #1
2400de48:	f880 303c 	strb.w	r3, [r0, #60]	@ 0x3c
  if ((InputTrigger == TIM_TS_ITR0)  || (InputTrigger == TIM_TS_ITR1) ||
2400de4c:	f031 0330 	bics.w	r3, r1, #48	@ 0x30
2400de50:	6803      	ldr	r3, [r0, #0]
2400de52:	d004      	beq.n	2400de5e <HAL_TIMEx_ConfigCommutEvent_DMA+0x24>
2400de54:	f021 0010 	bic.w	r0, r1, #16
      (InputTrigger == TIM_TS_ITR2)  || (InputTrigger == TIM_TS_ITR3) ||
2400de58:	f5b0 1f00 	cmp.w	r0, #2097152	@ 0x200000
2400de5c:	d108      	bne.n	2400de70 <HAL_TIMEx_ConfigCommutEvent_DMA+0x36>
    htim->Instance->SMCR &= ~TIM_SMCR_TS;
2400de5e:	6898      	ldr	r0, [r3, #8]
2400de60:	f420 1040 	bic.w	r0, r0, #3145728	@ 0x300000
2400de64:	f020 0070 	bic.w	r0, r0, #112	@ 0x70
2400de68:	6098      	str	r0, [r3, #8]
    htim->Instance->SMCR |= InputTrigger;
2400de6a:	6898      	ldr	r0, [r3, #8]
2400de6c:	4301      	orrs	r1, r0
2400de6e:	6099      	str	r1, [r3, #8]
  htim->Instance->CR2 |= TIM_CR2_CCPC;
2400de70:	6859      	ldr	r1, [r3, #4]
  __HAL_UNLOCK(htim);
2400de72:	2000      	movs	r0, #0
  htim->Instance->CR2 |= TIM_CR2_CCPC;
2400de74:	f041 0101 	orr.w	r1, r1, #1
2400de78:	6059      	str	r1, [r3, #4]
  htim->Instance->CR2 &= ~TIM_CR2_CCUS;
2400de7a:	6859      	ldr	r1, [r3, #4]
2400de7c:	f021 0104 	bic.w	r1, r1, #4
2400de80:	6059      	str	r1, [r3, #4]
  htim->Instance->CR2 |= CommutationSource;
2400de82:	6859      	ldr	r1, [r3, #4]
2400de84:	430a      	orrs	r2, r1
  htim->hdma[TIM_DMA_ID_COMMUTATION]->XferCpltCallback = TIMEx_DMACommutationCplt;
2400de86:	490a      	ldr	r1, [pc, #40]	@ (2400deb0 <HAL_TIMEx_ConfigCommutEvent_DMA+0x76>)
  htim->Instance->CR2 |= CommutationSource;
2400de88:	605a      	str	r2, [r3, #4]
  htim->hdma[TIM_DMA_ID_COMMUTATION]->XferCpltCallback = TIMEx_DMACommutationCplt;
2400de8a:	6b62      	ldr	r2, [r4, #52]	@ 0x34
2400de8c:	63d1      	str	r1, [r2, #60]	@ 0x3c
  htim->hdma[TIM_DMA_ID_COMMUTATION]->XferHalfCpltCallback = TIMEx_DMACommutationHalfCplt;
2400de8e:	4909      	ldr	r1, [pc, #36]	@ (2400deb4 <HAL_TIMEx_ConfigCommutEvent_DMA+0x7a>)
2400de90:	6411      	str	r1, [r2, #64]	@ 0x40
  htim->hdma[TIM_DMA_ID_COMMUTATION]->XferErrorCallback = TIM_DMAError;
2400de92:	4909      	ldr	r1, [pc, #36]	@ (2400deb8 <HAL_TIMEx_ConfigCommutEvent_DMA+0x7e>)
2400de94:	64d1      	str	r1, [r2, #76]	@ 0x4c
  __HAL_TIM_DISABLE_IT(htim, TIM_IT_COM);
2400de96:	68da      	ldr	r2, [r3, #12]
2400de98:	f022 0220 	bic.w	r2, r2, #32
2400de9c:	60da      	str	r2, [r3, #12]
  __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_COM);
2400de9e:	68da      	ldr	r2, [r3, #12]
2400dea0:	f442 5200 	orr.w	r2, r2, #8192	@ 0x2000
2400dea4:	60da      	str	r2, [r3, #12]
  __HAL_UNLOCK(htim);
2400dea6:	f884 003c 	strb.w	r0, [r4, #60]	@ 0x3c
}
2400deaa:	bd10      	pop	{r4, pc}
  __HAL_LOCK(htim);
2400deac:	2002      	movs	r0, #2
2400deae:	e7fc      	b.n	2400deaa <HAL_TIMEx_ConfigCommutEvent_DMA+0x70>
2400deb0:	2400e115 	.word	0x2400e115
2400deb4:	2400e127 	.word	0x2400e127
2400deb8:	2400c55f 	.word	0x2400c55f

2400debc <HAL_TIMEx_MasterConfigSynchronization>:
{
2400debc:	b570      	push	{r4, r5, r6, lr}
  __HAL_LOCK(htim);
2400debe:	f890 303c 	ldrb.w	r3, [r0, #60]	@ 0x3c
{
2400dec2:	4604      	mov	r4, r0
2400dec4:	2002      	movs	r0, #2
  __HAL_LOCK(htim);
2400dec6:	2b01      	cmp	r3, #1
2400dec8:	d037      	beq.n	2400df3a <HAL_TIMEx_MasterConfigSynchronization+0x7e>
  tmpcr2 = htim->Instance->CR2;
2400deca:	6823      	ldr	r3, [r4, #0]
  if (IS_TIM_TRGO2_INSTANCE(htim->Instance))
2400decc:	4d1b      	ldr	r5, [pc, #108]	@ (2400df3c <HAL_TIMEx_MasterConfigSynchronization+0x80>)
  htim->State = HAL_TIM_STATE_BUSY;
2400dece:	f884 003d 	strb.w	r0, [r4, #61]	@ 0x3d
  if (IS_TIM_TRGO2_INSTANCE(htim->Instance))
2400ded2:	42ab      	cmp	r3, r5
  tmpcr2 = htim->Instance->CR2;
2400ded4:	685a      	ldr	r2, [r3, #4]
  tmpsmcr = htim->Instance->SMCR;
2400ded6:	6898      	ldr	r0, [r3, #8]
  if (IS_TIM_TRGO2_INSTANCE(htim->Instance))
2400ded8:	d002      	beq.n	2400dee0 <HAL_TIMEx_MasterConfigSynchronization+0x24>
2400deda:	4e19      	ldr	r6, [pc, #100]	@ (2400df40 <HAL_TIMEx_MasterConfigSynchronization+0x84>)
2400dedc:	42b3      	cmp	r3, r6
2400dede:	d103      	bne.n	2400dee8 <HAL_TIMEx_MasterConfigSynchronization+0x2c>
    tmpcr2 &= ~TIM_CR2_MMS2;
2400dee0:	f422 0270 	bic.w	r2, r2, #15728640	@ 0xf00000
    tmpcr2 |= sMasterConfig->MasterOutputTrigger2;
2400dee4:	684e      	ldr	r6, [r1, #4]
2400dee6:	4332      	orrs	r2, r6
  tmpcr2 |=  sMasterConfig->MasterOutputTrigger;
2400dee8:	680e      	ldr	r6, [r1, #0]
  tmpcr2 &= ~TIM_CR2_MMS;
2400deea:	f022 0270 	bic.w	r2, r2, #112	@ 0x70
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
2400deee:	42ab      	cmp	r3, r5
  tmpcr2 |=  sMasterConfig->MasterOutputTrigger;
2400def0:	ea42 0206 	orr.w	r2, r2, r6
  htim->Instance->CR2 = tmpcr2;
2400def4:	605a      	str	r2, [r3, #4]
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
2400def6:	d015      	beq.n	2400df24 <HAL_TIMEx_MasterConfigSynchronization+0x68>
2400def8:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
2400defc:	d012      	beq.n	2400df24 <HAL_TIMEx_MasterConfigSynchronization+0x68>
2400defe:	4a11      	ldr	r2, [pc, #68]	@ (2400df44 <HAL_TIMEx_MasterConfigSynchronization+0x88>)
2400df00:	4293      	cmp	r3, r2
2400df02:	d00f      	beq.n	2400df24 <HAL_TIMEx_MasterConfigSynchronization+0x68>
2400df04:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
2400df08:	4293      	cmp	r3, r2
2400df0a:	d00b      	beq.n	2400df24 <HAL_TIMEx_MasterConfigSynchronization+0x68>
2400df0c:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
2400df10:	4293      	cmp	r3, r2
2400df12:	d007      	beq.n	2400df24 <HAL_TIMEx_MasterConfigSynchronization+0x68>
2400df14:	f502 4278 	add.w	r2, r2, #63488	@ 0xf800
2400df18:	4293      	cmp	r3, r2
2400df1a:	d003      	beq.n	2400df24 <HAL_TIMEx_MasterConfigSynchronization+0x68>
2400df1c:	f5a2 426c 	sub.w	r2, r2, #60416	@ 0xec00
2400df20:	4293      	cmp	r3, r2
2400df22:	d104      	bne.n	2400df2e <HAL_TIMEx_MasterConfigSynchronization+0x72>
    tmpsmcr |= sMasterConfig->MasterSlaveMode;
2400df24:	6889      	ldr	r1, [r1, #8]
    tmpsmcr &= ~TIM_SMCR_MSM;
2400df26:	f020 0280 	bic.w	r2, r0, #128	@ 0x80
    tmpsmcr |= sMasterConfig->MasterSlaveMode;
2400df2a:	430a      	orrs	r2, r1
    htim->Instance->SMCR = tmpsmcr;
2400df2c:	609a      	str	r2, [r3, #8]
  htim->State = HAL_TIM_STATE_READY;
2400df2e:	2301      	movs	r3, #1
  __HAL_UNLOCK(htim);
2400df30:	2000      	movs	r0, #0
  htim->State = HAL_TIM_STATE_READY;
2400df32:	f884 303d 	strb.w	r3, [r4, #61]	@ 0x3d
  __HAL_UNLOCK(htim);
2400df36:	f884 003c 	strb.w	r0, [r4, #60]	@ 0x3c
}
2400df3a:	bd70      	pop	{r4, r5, r6, pc}
2400df3c:	40010000 	.word	0x40010000
2400df40:	40010400 	.word	0x40010400
2400df44:	40000400 	.word	0x40000400

2400df48 <HAL_TIMEx_ConfigBreakDeadTime>:
{
2400df48:	b510      	push	{r4, lr}
  __HAL_LOCK(htim);
2400df4a:	f890 303c 	ldrb.w	r3, [r0, #60]	@ 0x3c
{
2400df4e:	4602      	mov	r2, r0
  __HAL_LOCK(htim);
2400df50:	2b01      	cmp	r3, #1
2400df52:	d037      	beq.n	2400dfc4 <HAL_TIMEx_ConfigBreakDeadTime+0x7c>
  MODIFY_REG(tmpbdtr, TIM_BDTR_LOCK, sBreakDeadTimeConfig->LockLevel);
2400df54:	68cb      	ldr	r3, [r1, #12]
2400df56:	6888      	ldr	r0, [r1, #8]
2400df58:	f423 7340 	bic.w	r3, r3, #768	@ 0x300
  if (IS_TIM_BKIN2_INSTANCE(htim->Instance))
2400df5c:	4c1a      	ldr	r4, [pc, #104]	@ (2400dfc8 <HAL_TIMEx_ConfigBreakDeadTime+0x80>)
  MODIFY_REG(tmpbdtr, TIM_BDTR_LOCK, sBreakDeadTimeConfig->LockLevel);
2400df5e:	4303      	orrs	r3, r0
  MODIFY_REG(tmpbdtr, TIM_BDTR_OSSI, sBreakDeadTimeConfig->OffStateIDLEMode);
2400df60:	6848      	ldr	r0, [r1, #4]
2400df62:	f423 6380 	bic.w	r3, r3, #1024	@ 0x400
2400df66:	4303      	orrs	r3, r0
  MODIFY_REG(tmpbdtr, TIM_BDTR_OSSR, sBreakDeadTimeConfig->OffStateRunMode);
2400df68:	6808      	ldr	r0, [r1, #0]
2400df6a:	f423 6300 	bic.w	r3, r3, #2048	@ 0x800
2400df6e:	4303      	orrs	r3, r0
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKE, sBreakDeadTimeConfig->BreakState);
2400df70:	6908      	ldr	r0, [r1, #16]
2400df72:	f423 5380 	bic.w	r3, r3, #4096	@ 0x1000
2400df76:	4303      	orrs	r3, r0
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKP, sBreakDeadTimeConfig->BreakPolarity);
2400df78:	6948      	ldr	r0, [r1, #20]
2400df7a:	f423 5300 	bic.w	r3, r3, #8192	@ 0x2000
2400df7e:	4303      	orrs	r3, r0
  MODIFY_REG(tmpbdtr, TIM_BDTR_AOE, sBreakDeadTimeConfig->AutomaticOutput);
2400df80:	6a88      	ldr	r0, [r1, #40]	@ 0x28
2400df82:	f423 4380 	bic.w	r3, r3, #16384	@ 0x4000
2400df86:	4303      	orrs	r3, r0
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKF, (sBreakDeadTimeConfig->BreakFilter << TIM_BDTR_BKF_Pos));
2400df88:	6988      	ldr	r0, [r1, #24]
2400df8a:	f423 2370 	bic.w	r3, r3, #983040	@ 0xf0000
2400df8e:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
  if (IS_TIM_BKIN2_INSTANCE(htim->Instance))
2400df92:	6810      	ldr	r0, [r2, #0]
2400df94:	42a0      	cmp	r0, r4
2400df96:	d003      	beq.n	2400dfa0 <HAL_TIMEx_ConfigBreakDeadTime+0x58>
2400df98:	f504 6480 	add.w	r4, r4, #1024	@ 0x400
2400df9c:	42a0      	cmp	r0, r4
2400df9e:	d10c      	bne.n	2400dfba <HAL_TIMEx_ConfigBreakDeadTime+0x72>
    MODIFY_REG(tmpbdtr, TIM_BDTR_BK2F, (sBreakDeadTimeConfig->Break2Filter << TIM_BDTR_BK2F_Pos));
2400dfa0:	6a4c      	ldr	r4, [r1, #36]	@ 0x24
2400dfa2:	f423 0370 	bic.w	r3, r3, #15728640	@ 0xf00000
2400dfa6:	ea43 5304 	orr.w	r3, r3, r4, lsl #20
    MODIFY_REG(tmpbdtr, TIM_BDTR_BK2E, sBreakDeadTimeConfig->Break2State);
2400dfaa:	69cc      	ldr	r4, [r1, #28]
    MODIFY_REG(tmpbdtr, TIM_BDTR_BK2P, sBreakDeadTimeConfig->Break2Polarity);
2400dfac:	6a09      	ldr	r1, [r1, #32]
    MODIFY_REG(tmpbdtr, TIM_BDTR_BK2E, sBreakDeadTimeConfig->Break2State);
2400dfae:	f023 7380 	bic.w	r3, r3, #16777216	@ 0x1000000
2400dfb2:	4323      	orrs	r3, r4
    MODIFY_REG(tmpbdtr, TIM_BDTR_BK2P, sBreakDeadTimeConfig->Break2Polarity);
2400dfb4:	f023 7300 	bic.w	r3, r3, #33554432	@ 0x2000000
2400dfb8:	430b      	orrs	r3, r1
  htim->Instance->BDTR = tmpbdtr;
2400dfba:	6443      	str	r3, [r0, #68]	@ 0x44
  __HAL_UNLOCK(htim);
2400dfbc:	2000      	movs	r0, #0
2400dfbe:	f882 003c 	strb.w	r0, [r2, #60]	@ 0x3c
}
2400dfc2:	bd10      	pop	{r4, pc}
  __HAL_LOCK(htim);
2400dfc4:	2002      	movs	r0, #2
2400dfc6:	e7fc      	b.n	2400dfc2 <HAL_TIMEx_ConfigBreakDeadTime+0x7a>
2400dfc8:	40010000 	.word	0x40010000

2400dfcc <HAL_TIMEx_ConfigBreakInput>:
{
2400dfcc:	b5f0      	push	{r4, r5, r6, r7, lr}
  __HAL_LOCK(htim);
2400dfce:	f890 303c 	ldrb.w	r3, [r0, #60]	@ 0x3c
{
2400dfd2:	4604      	mov	r4, r0
  if (sBreakInputConfig->Source != TIM_BREAKINPUTSOURCE_DFSDM1)
2400dfd4:	6816      	ldr	r6, [r2, #0]
  __HAL_LOCK(htim);
2400dfd6:	2b01      	cmp	r3, #1
2400dfd8:	d044      	beq.n	2400e064 <HAL_TIMEx_ConfigBreakInput+0x98>
  switch (sBreakInputConfig->Source)
2400dfda:	1e70      	subs	r0, r6, #1
2400dfdc:	2807      	cmp	r0, #7
2400dfde:	d812      	bhi.n	2400e006 <HAL_TIMEx_ConfigBreakInput+0x3a>
2400dfe0:	4b21      	ldr	r3, [pc, #132]	@ (2400e068 <HAL_TIMEx_ConfigBreakInput+0x9c>)
2400dfe2:	eb03 0540 	add.w	r5, r3, r0, lsl #1
2400dfe6:	f833 7010 	ldrh.w	r7, [r3, r0, lsl #1]
2400dfea:	4403      	add	r3, r0
2400dfec:	8a2d      	ldrh	r5, [r5, #16]
2400dfee:	f893 c020 	ldrb.w	ip, [r3, #32]
2400dff2:	f893 0028 	ldrb.w	r0, [r3, #40]	@ 0x28
  switch (BreakInput)
2400dff6:	2901      	cmp	r1, #1
2400dff8:	d00a      	beq.n	2400e010 <HAL_TIMEx_ConfigBreakInput+0x44>
2400dffa:	2902      	cmp	r1, #2
2400dffc:	d01d      	beq.n	2400e03a <HAL_TIMEx_ConfigBreakInput+0x6e>
  __HAL_UNLOCK(htim);
2400dffe:	2000      	movs	r0, #0
2400e000:	f884 003c 	strb.w	r0, [r4, #60]	@ 0x3c
}
2400e004:	bdf0      	pop	{r4, r5, r6, r7, pc}
  __HAL_LOCK(htim);
2400e006:	2000      	movs	r0, #0
2400e008:	4684      	mov	ip, r0
2400e00a:	4605      	mov	r5, r0
2400e00c:	4607      	mov	r7, r0
2400e00e:	e7f2      	b.n	2400dff6 <HAL_TIMEx_ConfigBreakInput+0x2a>
      tmporx = htim->Instance->AF1;
2400e010:	6821      	ldr	r1, [r4, #0]
      if (sBreakInputConfig->Source != TIM_BREAKINPUTSOURCE_DFSDM1)
2400e012:	2e08      	cmp	r6, #8
      tmporx |= (sBreakInputConfig->Enable << bkin_enable_bitpos) & bkin_enable_mask;
2400e014:	6853      	ldr	r3, [r2, #4]
      tmporx = htim->Instance->AF1;
2400e016:	f8d1 e060 	ldr.w	lr, [r1, #96]	@ 0x60
      tmporx |= (sBreakInputConfig->Enable << bkin_enable_bitpos) & bkin_enable_mask;
2400e01a:	fa03 f30c 	lsl.w	r3, r3, ip
2400e01e:	ea83 030e 	eor.w	r3, r3, lr
2400e022:	ea03 0307 	and.w	r3, r3, r7
2400e026:	ea83 030e 	eor.w	r3, r3, lr
      if (sBreakInputConfig->Source != TIM_BREAKINPUTSOURCE_DFSDM1)
2400e02a:	d004      	beq.n	2400e036 <HAL_TIMEx_ConfigBreakInput+0x6a>
        tmporx |= (sBreakInputConfig->Polarity << bkin_polarity_bitpos) & bkin_polarity_mask;
2400e02c:	6892      	ldr	r2, [r2, #8]
2400e02e:	4082      	lsls	r2, r0
2400e030:	405a      	eors	r2, r3
2400e032:	402a      	ands	r2, r5
2400e034:	4053      	eors	r3, r2
      htim->Instance->AF1 = tmporx;
2400e036:	660b      	str	r3, [r1, #96]	@ 0x60
      break;
2400e038:	e7e1      	b.n	2400dffe <HAL_TIMEx_ConfigBreakInput+0x32>
      tmporx = htim->Instance->AF2;
2400e03a:	6821      	ldr	r1, [r4, #0]
      if (sBreakInputConfig->Source != TIM_BREAKINPUTSOURCE_DFSDM1)
2400e03c:	2e08      	cmp	r6, #8
      tmporx |= (sBreakInputConfig->Enable << bkin_enable_bitpos) & bkin_enable_mask;
2400e03e:	6853      	ldr	r3, [r2, #4]
      tmporx = htim->Instance->AF2;
2400e040:	f8d1 e064 	ldr.w	lr, [r1, #100]	@ 0x64
      tmporx |= (sBreakInputConfig->Enable << bkin_enable_bitpos) & bkin_enable_mask;
2400e044:	fa03 f30c 	lsl.w	r3, r3, ip
2400e048:	ea83 030e 	eor.w	r3, r3, lr
2400e04c:	ea03 0307 	and.w	r3, r3, r7
2400e050:	ea83 030e 	eor.w	r3, r3, lr
      if (sBreakInputConfig->Source != TIM_BREAKINPUTSOURCE_DFSDM1)
2400e054:	d004      	beq.n	2400e060 <HAL_TIMEx_ConfigBreakInput+0x94>
        tmporx |= (sBreakInputConfig->Polarity << bkin_polarity_bitpos) & bkin_polarity_mask;
2400e056:	6892      	ldr	r2, [r2, #8]
2400e058:	4082      	lsls	r2, r0
2400e05a:	405a      	eors	r2, r3
2400e05c:	402a      	ands	r2, r5
2400e05e:	4053      	eors	r3, r2
      htim->Instance->AF2 = tmporx;
2400e060:	664b      	str	r3, [r1, #100]	@ 0x64
      break;
2400e062:	e7cc      	b.n	2400dffe <HAL_TIMEx_ConfigBreakInput+0x32>
  __HAL_LOCK(htim);
2400e064:	2002      	movs	r0, #2
2400e066:	e7cd      	b.n	2400e004 <HAL_TIMEx_ConfigBreakInput+0x38>
2400e068:	2401417c 	.word	0x2401417c

2400e06c <HAL_TIMEx_RemapConfig>:
  __HAL_LOCK(htim);
2400e06c:	f890 203c 	ldrb.w	r2, [r0, #60]	@ 0x3c
{
2400e070:	4603      	mov	r3, r0
  __HAL_LOCK(htim);
2400e072:	2a01      	cmp	r2, #1
2400e074:	d009      	beq.n	2400e08a <HAL_TIMEx_RemapConfig+0x1e>
  MODIFY_REG(htim->Instance->AF1, TIM1_AF1_ETRSEL_Msk, Remap);
2400e076:	6800      	ldr	r0, [r0, #0]
2400e078:	6e02      	ldr	r2, [r0, #96]	@ 0x60
2400e07a:	f422 3270 	bic.w	r2, r2, #245760	@ 0x3c000
2400e07e:	4311      	orrs	r1, r2
2400e080:	6601      	str	r1, [r0, #96]	@ 0x60
  __HAL_UNLOCK(htim);
2400e082:	2000      	movs	r0, #0
2400e084:	f883 003c 	strb.w	r0, [r3, #60]	@ 0x3c
  return HAL_OK;
2400e088:	4770      	bx	lr
  __HAL_LOCK(htim);
2400e08a:	2002      	movs	r0, #2
}
2400e08c:	4770      	bx	lr

2400e08e <HAL_TIMEx_TISelection>:
{
2400e08e:	4603      	mov	r3, r0
  __HAL_LOCK(htim);
2400e090:	f890 003c 	ldrb.w	r0, [r0, #60]	@ 0x3c
2400e094:	2801      	cmp	r0, #1
2400e096:	d023      	beq.n	2400e0e0 <HAL_TIMEx_TISelection+0x52>
  switch (Channel)
2400e098:	2a08      	cmp	r2, #8
2400e09a:	d01c      	beq.n	2400e0d6 <HAL_TIMEx_TISelection+0x48>
2400e09c:	d807      	bhi.n	2400e0ae <HAL_TIMEx_TISelection+0x20>
2400e09e:	b16a      	cbz	r2, 2400e0bc <HAL_TIMEx_TISelection+0x2e>
2400e0a0:	2a04      	cmp	r2, #4
2400e0a2:	d013      	beq.n	2400e0cc <HAL_TIMEx_TISelection+0x3e>
2400e0a4:	2001      	movs	r0, #1
  __HAL_UNLOCK(htim);
2400e0a6:	2200      	movs	r2, #0
2400e0a8:	f883 203c 	strb.w	r2, [r3, #60]	@ 0x3c
  return status;
2400e0ac:	4770      	bx	lr
  switch (Channel)
2400e0ae:	2a0c      	cmp	r2, #12
2400e0b0:	d1f8      	bne.n	2400e0a4 <HAL_TIMEx_TISelection+0x16>
      MODIFY_REG(htim->Instance->TISEL, TIM_TISEL_TI4SEL, TISelection);
2400e0b2:	6818      	ldr	r0, [r3, #0]
2400e0b4:	6e82      	ldr	r2, [r0, #104]	@ 0x68
2400e0b6:	f022 6270 	bic.w	r2, r2, #251658240	@ 0xf000000
2400e0ba:	e003      	b.n	2400e0c4 <HAL_TIMEx_TISelection+0x36>
      MODIFY_REG(htim->Instance->TISEL, TIM_TISEL_TI1SEL, TISelection);
2400e0bc:	6818      	ldr	r0, [r3, #0]
2400e0be:	6e82      	ldr	r2, [r0, #104]	@ 0x68
2400e0c0:	f022 020f 	bic.w	r2, r2, #15
      MODIFY_REG(htim->Instance->TISEL, TIM_TISEL_TI2SEL, TISelection);
2400e0c4:	430a      	orrs	r2, r1
2400e0c6:	6682      	str	r2, [r0, #104]	@ 0x68
  HAL_StatusTypeDef status = HAL_OK;
2400e0c8:	2000      	movs	r0, #0
2400e0ca:	e7ec      	b.n	2400e0a6 <HAL_TIMEx_TISelection+0x18>
      MODIFY_REG(htim->Instance->TISEL, TIM_TISEL_TI2SEL, TISelection);
2400e0cc:	6818      	ldr	r0, [r3, #0]
2400e0ce:	6e82      	ldr	r2, [r0, #104]	@ 0x68
2400e0d0:	f422 6270 	bic.w	r2, r2, #3840	@ 0xf00
2400e0d4:	e7f6      	b.n	2400e0c4 <HAL_TIMEx_TISelection+0x36>
      MODIFY_REG(htim->Instance->TISEL, TIM_TISEL_TI3SEL, TISelection);
2400e0d6:	6818      	ldr	r0, [r3, #0]
2400e0d8:	6e82      	ldr	r2, [r0, #104]	@ 0x68
2400e0da:	f422 2270 	bic.w	r2, r2, #983040	@ 0xf0000
2400e0de:	e7f1      	b.n	2400e0c4 <HAL_TIMEx_TISelection+0x36>
  __HAL_LOCK(htim);
2400e0e0:	2002      	movs	r0, #2
}
2400e0e2:	4770      	bx	lr

2400e0e4 <HAL_TIMEx_GroupChannel5>:
  __HAL_LOCK(htim);
2400e0e4:	f890 203c 	ldrb.w	r2, [r0, #60]	@ 0x3c
{
2400e0e8:	4603      	mov	r3, r0
2400e0ea:	2002      	movs	r0, #2
  __HAL_LOCK(htim);
2400e0ec:	2a01      	cmp	r2, #1
2400e0ee:	d00f      	beq.n	2400e110 <HAL_TIMEx_GroupChannel5+0x2c>
  htim->Instance->CCR5 &= ~(TIM_CCR5_GC5C3 | TIM_CCR5_GC5C2 | TIM_CCR5_GC5C1);
2400e0f0:	681a      	ldr	r2, [r3, #0]
  htim->State = HAL_TIM_STATE_BUSY;
2400e0f2:	f883 003d 	strb.w	r0, [r3, #61]	@ 0x3d
  htim->Instance->CCR5 &= ~(TIM_CCR5_GC5C3 | TIM_CCR5_GC5C2 | TIM_CCR5_GC5C1);
2400e0f6:	6d90      	ldr	r0, [r2, #88]	@ 0x58
2400e0f8:	f020 4060 	bic.w	r0, r0, #3758096384	@ 0xe0000000
2400e0fc:	6590      	str	r0, [r2, #88]	@ 0x58
  htim->Instance->CCR5 |= Channels;
2400e0fe:	6d90      	ldr	r0, [r2, #88]	@ 0x58
2400e100:	4301      	orrs	r1, r0
  __HAL_UNLOCK(htim);
2400e102:	2000      	movs	r0, #0
  htim->Instance->CCR5 |= Channels;
2400e104:	6591      	str	r1, [r2, #88]	@ 0x58
  htim->State = HAL_TIM_STATE_READY;
2400e106:	2201      	movs	r2, #1
  __HAL_UNLOCK(htim);
2400e108:	f883 003c 	strb.w	r0, [r3, #60]	@ 0x3c
  htim->State = HAL_TIM_STATE_READY;
2400e10c:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d
}
2400e110:	4770      	bx	lr

2400e112 <HAL_TIMEx_CommutCallback>:
__weak void HAL_TIMEx_CommutCallback(TIM_HandleTypeDef *htim)
2400e112:	4770      	bx	lr

2400e114 <TIMEx_DMACommutationCplt>:
{
2400e114:	b508      	push	{r3, lr}
  TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
2400e116:	6b80      	ldr	r0, [r0, #56]	@ 0x38
  htim->State = HAL_TIM_STATE_READY;
2400e118:	2301      	movs	r3, #1
2400e11a:	f880 303d 	strb.w	r3, [r0, #61]	@ 0x3d
  HAL_TIMEx_CommutCallback(htim);
2400e11e:	f7ff fff8 	bl	2400e112 <HAL_TIMEx_CommutCallback>
}
2400e122:	bd08      	pop	{r3, pc}

2400e124 <HAL_TIMEx_CommutHalfCpltCallback>:
__weak void HAL_TIMEx_CommutHalfCpltCallback(TIM_HandleTypeDef *htim)
2400e124:	4770      	bx	lr

2400e126 <TIMEx_DMACommutationHalfCplt>:
{
2400e126:	b508      	push	{r3, lr}
  TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
2400e128:	6b80      	ldr	r0, [r0, #56]	@ 0x38
  htim->State = HAL_TIM_STATE_READY;
2400e12a:	2301      	movs	r3, #1
2400e12c:	f880 303d 	strb.w	r3, [r0, #61]	@ 0x3d
  HAL_TIMEx_CommutHalfCpltCallback(htim);
2400e130:	f7ff fff8 	bl	2400e124 <HAL_TIMEx_CommutHalfCpltCallback>
}
2400e134:	bd08      	pop	{r3, pc}

2400e136 <HAL_TIMEx_BreakCallback>:
__weak void HAL_TIMEx_BreakCallback(TIM_HandleTypeDef *htim)
2400e136:	4770      	bx	lr

2400e138 <HAL_TIMEx_Break2Callback>:
__weak void HAL_TIMEx_Break2Callback(TIM_HandleTypeDef *htim)
2400e138:	4770      	bx	lr

2400e13a <HAL_TIMEx_HallSensor_GetState>:
  return htim->State;
2400e13a:	f890 003d 	ldrb.w	r0, [r0, #61]	@ 0x3d
}
2400e13e:	4770      	bx	lr

2400e140 <UART_EndTxTransfer>:
  * @retval None
  */
static void UART_EndTxTransfer(UART_HandleTypeDef *huart)
{
  /* Disable TXEIE, TCIE, TXFT interrupts */
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE_TXFNFIE | USART_CR1_TCIE));
2400e140:	6802      	ldr	r2, [r0, #0]
 */
__STATIC_FORCEINLINE uint32_t __LDREXW(volatile uint32_t *addr)
{
    uint32_t result;

   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
2400e142:	e852 3f00 	ldrex	r3, [r2]
2400e146:	f023 03c0 	bic.w	r3, r3, #192	@ 0xc0
 */
__STATIC_FORCEINLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
{
   uint32_t result;

   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
2400e14a:	e842 3100 	strex	r1, r3, [r2]
   return(result);
2400e14e:	6802      	ldr	r2, [r0, #0]
2400e150:	2900      	cmp	r1, #0
2400e152:	d1f5      	bne.n	2400e140 <UART_EndTxTransfer>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
2400e154:	f102 0308 	add.w	r3, r2, #8
2400e158:	e853 3f00 	ldrex	r3, [r3]
  ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_TXFTIE));
2400e15c:	f423 0300 	bic.w	r3, r3, #8388608	@ 0x800000
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
2400e160:	f102 0c08 	add.w	ip, r2, #8
2400e164:	e84c 3100 	strex	r1, r3, [ip]
2400e168:	2900      	cmp	r1, #0
2400e16a:	d1f3      	bne.n	2400e154 <UART_EndTxTransfer+0x14>

  /* At end of Tx process, restore huart->gState to Ready */
  huart->gState = HAL_UART_STATE_READY;
2400e16c:	2320      	movs	r3, #32
2400e16e:	f8c0 3088 	str.w	r3, [r0, #136]	@ 0x88
}
2400e172:	4770      	bx	lr

2400e174 <UART_EndRxTransfer>:
  * @brief  End ongoing Rx transfer on UART peripheral (following error detection or Reception completion).
  * @param  huart UART handle.
  * @retval None
  */
static void UART_EndRxTransfer(UART_HandleTypeDef *huart)
{
2400e174:	b510      	push	{r4, lr}
  /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
2400e176:	6802      	ldr	r2, [r0, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
2400e178:	e852 3f00 	ldrex	r3, [r2]
2400e17c:	f423 7390 	bic.w	r3, r3, #288	@ 0x120
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
2400e180:	e842 3100 	strex	r1, r3, [r2]
   return(result);
2400e184:	6802      	ldr	r2, [r0, #0]
2400e186:	2900      	cmp	r1, #0
2400e188:	d1f5      	bne.n	2400e176 <UART_EndRxTransfer+0x2>
  ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
2400e18a:	4c0f      	ldr	r4, [pc, #60]	@ (2400e1c8 <UART_EndRxTransfer+0x54>)
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
2400e18c:	f102 0308 	add.w	r3, r2, #8
2400e190:	e853 3f00 	ldrex	r3, [r3]
2400e194:	4023      	ands	r3, r4
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
2400e196:	f102 0c08 	add.w	ip, r2, #8
2400e19a:	e84c 3100 	strex	r1, r3, [ip]
2400e19e:	2900      	cmp	r1, #0
2400e1a0:	d1f4      	bne.n	2400e18c <UART_EndRxTransfer+0x18>

  /* In case of reception waiting for IDLE event, disable also the IDLE IE interrupt source */
  if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
2400e1a2:	6ec3      	ldr	r3, [r0, #108]	@ 0x6c
2400e1a4:	2b01      	cmp	r3, #1
2400e1a6:	d107      	bne.n	2400e1b8 <UART_EndRxTransfer+0x44>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
2400e1a8:	e852 3f00 	ldrex	r3, [r2]
  {
    ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
2400e1ac:	f023 0310 	bic.w	r3, r3, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
2400e1b0:	e842 3100 	strex	r1, r3, [r2]
2400e1b4:	2900      	cmp	r1, #0
2400e1b6:	d1f7      	bne.n	2400e1a8 <UART_EndRxTransfer+0x34>
  }

  /* At end of Rx process, restore huart->RxState to Ready */
  huart->RxState = HAL_UART_STATE_READY;
2400e1b8:	2320      	movs	r3, #32
2400e1ba:	f8c0 308c 	str.w	r3, [r0, #140]	@ 0x8c
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
2400e1be:	2300      	movs	r3, #0
2400e1c0:	66c3      	str	r3, [r0, #108]	@ 0x6c

  /* Reset RxIsr function pointer */
  huart->RxISR = NULL;
2400e1c2:	6743      	str	r3, [r0, #116]	@ 0x74
}
2400e1c4:	bd10      	pop	{r4, pc}
2400e1c6:	bf00      	nop
2400e1c8:	effffffe 	.word	0xeffffffe

2400e1cc <UART_TxISR_16BIT.part.0>:
  if (huart->gState == HAL_UART_STATE_BUSY_TX)
  {
    if (huart->TxXferCount == 0U)
    {
      /* Disable the UART Transmit Data Register Empty Interrupt */
      ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_TXEIE_TXFNFIE);
2400e1cc:	6802      	ldr	r2, [r0, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
2400e1ce:	e852 3f00 	ldrex	r3, [r2]
2400e1d2:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
2400e1d6:	e842 3100 	strex	r1, r3, [r2]
   return(result);
2400e1da:	6802      	ldr	r2, [r0, #0]
2400e1dc:	2900      	cmp	r1, #0
2400e1de:	d1f5      	bne.n	2400e1cc <UART_TxISR_16BIT.part.0>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
2400e1e0:	e852 3f00 	ldrex	r3, [r2]

      /* Enable the UART Transmit Complete Interrupt */
      ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_TCIE);
2400e1e4:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
2400e1e8:	e842 3100 	strex	r1, r3, [r2]
2400e1ec:	2900      	cmp	r1, #0
2400e1ee:	d1f7      	bne.n	2400e1e0 <UART_TxISR_16BIT.part.0+0x14>
      huart->Instance->TDR = (uint8_t)(*huart->pTxBuffPtr & (uint8_t)0xFF);
      huart->pTxBuffPtr++;
      huart->TxXferCount--;
    }
  }
}
2400e1f0:	4770      	bx	lr

2400e1f2 <UART_TxISR_8BIT>:
  if (huart->gState == HAL_UART_STATE_BUSY_TX)
2400e1f2:	f8d0 2088 	ldr.w	r2, [r0, #136]	@ 0x88
{
2400e1f6:	4603      	mov	r3, r0
  if (huart->gState == HAL_UART_STATE_BUSY_TX)
2400e1f8:	2a21      	cmp	r2, #33	@ 0x21
2400e1fa:	d110      	bne.n	2400e21e <UART_TxISR_8BIT+0x2c>
    if (huart->TxXferCount == 0U)
2400e1fc:	f8b0 2056 	ldrh.w	r2, [r0, #86]	@ 0x56
2400e200:	b292      	uxth	r2, r2
2400e202:	b902      	cbnz	r2, 2400e206 <UART_TxISR_8BIT+0x14>
2400e204:	e7e2      	b.n	2400e1cc <UART_TxISR_16BIT.part.0>
      huart->Instance->TDR = (uint8_t)(*huart->pTxBuffPtr & (uint8_t)0xFF);
2400e206:	6d02      	ldr	r2, [r0, #80]	@ 0x50
2400e208:	6801      	ldr	r1, [r0, #0]
2400e20a:	f812 0b01 	ldrb.w	r0, [r2], #1
2400e20e:	6288      	str	r0, [r1, #40]	@ 0x28
      huart->pTxBuffPtr++;
2400e210:	651a      	str	r2, [r3, #80]	@ 0x50
      huart->TxXferCount--;
2400e212:	f8b3 2056 	ldrh.w	r2, [r3, #86]	@ 0x56
2400e216:	3a01      	subs	r2, #1
2400e218:	b292      	uxth	r2, r2
2400e21a:	f8a3 2056 	strh.w	r2, [r3, #86]	@ 0x56
}
2400e21e:	4770      	bx	lr

2400e220 <UART_TxISR_16BIT>:
static void UART_TxISR_16BIT(UART_HandleTypeDef *huart)
{
  const uint16_t *tmp;

  /* Check that a Tx process is ongoing */
  if (huart->gState == HAL_UART_STATE_BUSY_TX)
2400e220:	f8d0 2088 	ldr.w	r2, [r0, #136]	@ 0x88
{
2400e224:	4603      	mov	r3, r0
  if (huart->gState == HAL_UART_STATE_BUSY_TX)
2400e226:	2a21      	cmp	r2, #33	@ 0x21
2400e228:	d112      	bne.n	2400e250 <UART_TxISR_16BIT+0x30>
  {
    if (huart->TxXferCount == 0U)
2400e22a:	f8b0 2056 	ldrh.w	r2, [r0, #86]	@ 0x56
2400e22e:	b292      	uxth	r2, r2
2400e230:	b902      	cbnz	r2, 2400e234 <UART_TxISR_16BIT+0x14>
2400e232:	e7cb      	b.n	2400e1cc <UART_TxISR_16BIT.part.0>
      ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_TCIE);
    }
    else
    {
      tmp = (const uint16_t *) huart->pTxBuffPtr;
      huart->Instance->TDR = (((uint32_t)(*tmp)) & 0x01FFUL);
2400e234:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
2400e236:	6800      	ldr	r0, [r0, #0]
2400e238:	f832 1b02 	ldrh.w	r1, [r2], #2
2400e23c:	f3c1 0108 	ubfx	r1, r1, #0, #9
2400e240:	6281      	str	r1, [r0, #40]	@ 0x28
      huart->pTxBuffPtr += 2U;
2400e242:	651a      	str	r2, [r3, #80]	@ 0x50
      huart->TxXferCount--;
2400e244:	f8b3 2056 	ldrh.w	r2, [r3, #86]	@ 0x56
2400e248:	3a01      	subs	r2, #1
2400e24a:	b292      	uxth	r2, r2
2400e24c:	f8a3 2056 	strh.w	r2, [r3, #86]	@ 0x56
    }
  }
}
2400e250:	4770      	bx	lr

2400e252 <UART_TxISR_8BIT_FIFOEN>:
static void UART_TxISR_8BIT_FIFOEN(UART_HandleTypeDef *huart)
{
  uint16_t  nb_tx_data;

  /* Check that a Tx process is ongoing */
  if (huart->gState == HAL_UART_STATE_BUSY_TX)
2400e252:	f8d0 3088 	ldr.w	r3, [r0, #136]	@ 0x88
2400e256:	2b21      	cmp	r3, #33	@ 0x21
{
2400e258:	b510      	push	{r4, lr}
  if (huart->gState == HAL_UART_STATE_BUSY_TX)
2400e25a:	d11b      	bne.n	2400e294 <UART_TxISR_8BIT_FIFOEN+0x42>
  {
    for (nb_tx_data = huart->NbTxDataToProcess ; nb_tx_data > 0U ; nb_tx_data--)
2400e25c:	f8b0 206a 	ldrh.w	r2, [r0, #106]	@ 0x6a
2400e260:	b1c2      	cbz	r2, 2400e294 <UART_TxISR_8BIT_FIFOEN+0x42>
    {
      if (huart->TxXferCount == 0U)
2400e262:	f8b0 1056 	ldrh.w	r1, [r0, #86]	@ 0x56
        /* Enable the UART Transmit Complete Interrupt */
        ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_TCIE);

        break; /* force exit loop */
      }
      else if (READ_BIT(huart->Instance->ISR, USART_ISR_TXE_TXFNF) != 0U)
2400e266:	6803      	ldr	r3, [r0, #0]
      if (huart->TxXferCount == 0U)
2400e268:	b289      	uxth	r1, r1
2400e26a:	b9a1      	cbnz	r1, 2400e296 <UART_TxISR_8BIT_FIFOEN+0x44>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
2400e26c:	f103 0208 	add.w	r2, r3, #8
2400e270:	e852 2f00 	ldrex	r2, [r2]
        ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_TXFTIE);
2400e274:	f422 0200 	bic.w	r2, r2, #8388608	@ 0x800000
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
2400e278:	f103 0008 	add.w	r0, r3, #8
2400e27c:	e840 2100 	strex	r1, r2, [r0]
2400e280:	2900      	cmp	r1, #0
2400e282:	d1f3      	bne.n	2400e26c <UART_TxISR_8BIT_FIFOEN+0x1a>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
2400e284:	e853 2f00 	ldrex	r2, [r3]
        ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_TCIE);
2400e288:	f042 0240 	orr.w	r2, r2, #64	@ 0x40
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
2400e28c:	e843 2100 	strex	r1, r2, [r3]
2400e290:	2900      	cmp	r1, #0
2400e292:	d1f7      	bne.n	2400e284 <UART_TxISR_8BIT_FIFOEN+0x32>
      {
        /* Nothing to do */
      }
    }
  }
}
2400e294:	bd10      	pop	{r4, pc}
      else if (READ_BIT(huart->Instance->ISR, USART_ISR_TXE_TXFNF) != 0U)
2400e296:	69d9      	ldr	r1, [r3, #28]
2400e298:	0609      	lsls	r1, r1, #24
2400e29a:	d50a      	bpl.n	2400e2b2 <UART_TxISR_8BIT_FIFOEN+0x60>
        huart->Instance->TDR = (uint8_t)(*huart->pTxBuffPtr & (uint8_t)0xFF);
2400e29c:	6d01      	ldr	r1, [r0, #80]	@ 0x50
2400e29e:	f811 4b01 	ldrb.w	r4, [r1], #1
2400e2a2:	629c      	str	r4, [r3, #40]	@ 0x28
        huart->TxXferCount--;
2400e2a4:	f8b0 3056 	ldrh.w	r3, [r0, #86]	@ 0x56
        huart->pTxBuffPtr++;
2400e2a8:	6501      	str	r1, [r0, #80]	@ 0x50
        huart->TxXferCount--;
2400e2aa:	3b01      	subs	r3, #1
2400e2ac:	b29b      	uxth	r3, r3
2400e2ae:	f8a0 3056 	strh.w	r3, [r0, #86]	@ 0x56
    for (nb_tx_data = huart->NbTxDataToProcess ; nb_tx_data > 0U ; nb_tx_data--)
2400e2b2:	3a01      	subs	r2, #1
2400e2b4:	b292      	uxth	r2, r2
2400e2b6:	e7d3      	b.n	2400e260 <UART_TxISR_8BIT_FIFOEN+0xe>

2400e2b8 <UART_TxISR_16BIT_FIFOEN>:
{
  const uint16_t *tmp;
  uint16_t  nb_tx_data;

  /* Check that a Tx process is ongoing */
  if (huart->gState == HAL_UART_STATE_BUSY_TX)
2400e2b8:	f8d0 3088 	ldr.w	r3, [r0, #136]	@ 0x88
2400e2bc:	2b21      	cmp	r3, #33	@ 0x21
{
2400e2be:	b510      	push	{r4, lr}
  if (huart->gState == HAL_UART_STATE_BUSY_TX)
2400e2c0:	d11b      	bne.n	2400e2fa <UART_TxISR_16BIT_FIFOEN+0x42>
  {
    for (nb_tx_data = huart->NbTxDataToProcess ; nb_tx_data > 0U ; nb_tx_data--)
2400e2c2:	f8b0 206a 	ldrh.w	r2, [r0, #106]	@ 0x6a
2400e2c6:	b1c2      	cbz	r2, 2400e2fa <UART_TxISR_16BIT_FIFOEN+0x42>
    {
      if (huart->TxXferCount == 0U)
2400e2c8:	f8b0 1056 	ldrh.w	r1, [r0, #86]	@ 0x56
        /* Enable the UART Transmit Complete Interrupt */
        ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_TCIE);

        break; /* force exit loop */
      }
      else if (READ_BIT(huart->Instance->ISR, USART_ISR_TXE_TXFNF) != 0U)
2400e2cc:	6803      	ldr	r3, [r0, #0]
      if (huart->TxXferCount == 0U)
2400e2ce:	b289      	uxth	r1, r1
2400e2d0:	b9a1      	cbnz	r1, 2400e2fc <UART_TxISR_16BIT_FIFOEN+0x44>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
2400e2d2:	f103 0208 	add.w	r2, r3, #8
2400e2d6:	e852 2f00 	ldrex	r2, [r2]
        ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_TXFTIE);
2400e2da:	f422 0200 	bic.w	r2, r2, #8388608	@ 0x800000
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
2400e2de:	f103 0008 	add.w	r0, r3, #8
2400e2e2:	e840 2100 	strex	r1, r2, [r0]
2400e2e6:	2900      	cmp	r1, #0
2400e2e8:	d1f3      	bne.n	2400e2d2 <UART_TxISR_16BIT_FIFOEN+0x1a>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
2400e2ea:	e853 2f00 	ldrex	r2, [r3]
        ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_TCIE);
2400e2ee:	f042 0240 	orr.w	r2, r2, #64	@ 0x40
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
2400e2f2:	e843 2100 	strex	r1, r2, [r3]
2400e2f6:	2900      	cmp	r1, #0
2400e2f8:	d1f7      	bne.n	2400e2ea <UART_TxISR_16BIT_FIFOEN+0x32>
      {
        /* Nothing to do */
      }
    }
  }
}
2400e2fa:	bd10      	pop	{r4, pc}
      else if (READ_BIT(huart->Instance->ISR, USART_ISR_TXE_TXFNF) != 0U)
2400e2fc:	69d9      	ldr	r1, [r3, #28]
2400e2fe:	0609      	lsls	r1, r1, #24
2400e300:	d50c      	bpl.n	2400e31c <UART_TxISR_16BIT_FIFOEN+0x64>
        huart->Instance->TDR = (((uint32_t)(*tmp)) & 0x01FFUL);
2400e302:	6d01      	ldr	r1, [r0, #80]	@ 0x50
2400e304:	f831 4b02 	ldrh.w	r4, [r1], #2
2400e308:	f3c4 0408 	ubfx	r4, r4, #0, #9
2400e30c:	629c      	str	r4, [r3, #40]	@ 0x28
        huart->TxXferCount--;
2400e30e:	f8b0 3056 	ldrh.w	r3, [r0, #86]	@ 0x56
        huart->pTxBuffPtr += 2U;
2400e312:	6501      	str	r1, [r0, #80]	@ 0x50
        huart->TxXferCount--;
2400e314:	3b01      	subs	r3, #1
2400e316:	b29b      	uxth	r3, r3
2400e318:	f8a0 3056 	strh.w	r3, [r0, #86]	@ 0x56
    for (nb_tx_data = huart->NbTxDataToProcess ; nb_tx_data > 0U ; nb_tx_data--)
2400e31c:	3a01      	subs	r2, #1
2400e31e:	b292      	uxth	r2, r2
2400e320:	e7d1      	b.n	2400e2c6 <UART_TxISR_16BIT_FIFOEN+0xe>
}
2400e322:	4770      	bx	lr
__weak void HAL_UART_MspDeInit(UART_HandleTypeDef *huart)
2400e324:	4770      	bx	lr

2400e326 <HAL_UART_DeInit>:
{
2400e326:	b538      	push	{r3, r4, r5, lr}
  if (huart == NULL)
2400e328:	4605      	mov	r5, r0
2400e32a:	b1c8      	cbz	r0, 2400e360 <HAL_UART_DeInit+0x3a>
  huart->gState = HAL_UART_STATE_BUSY;
2400e32c:	2324      	movs	r3, #36	@ 0x24
  huart->Instance->CR1 = 0x0U;
2400e32e:	2400      	movs	r4, #0
  huart->gState = HAL_UART_STATE_BUSY;
2400e330:	f8c0 3088 	str.w	r3, [r0, #136]	@ 0x88
  __HAL_UART_DISABLE(huart);
2400e334:	6803      	ldr	r3, [r0, #0]
2400e336:	681a      	ldr	r2, [r3, #0]
2400e338:	f022 0201 	bic.w	r2, r2, #1
2400e33c:	601a      	str	r2, [r3, #0]
  huart->Instance->CR1 = 0x0U;
2400e33e:	601c      	str	r4, [r3, #0]
  huart->Instance->CR2 = 0x0U;
2400e340:	605c      	str	r4, [r3, #4]
  huart->Instance->CR3 = 0x0U;
2400e342:	609c      	str	r4, [r3, #8]
  HAL_UART_MspDeInit(huart);
2400e344:	f004 fb42 	bl	240129cc <HAL_UART_MspDeInit>
  return HAL_OK;
2400e348:	4620      	mov	r0, r4
  huart->ErrorCode = HAL_UART_ERROR_NONE;
2400e34a:	f8c5 4090 	str.w	r4, [r5, #144]	@ 0x90
  __HAL_UNLOCK(huart);
2400e34e:	f885 4084 	strb.w	r4, [r5, #132]	@ 0x84
  huart->gState = HAL_UART_STATE_RESET;
2400e352:	f8c5 4088 	str.w	r4, [r5, #136]	@ 0x88
  huart->RxState = HAL_UART_STATE_RESET;
2400e356:	f8c5 408c 	str.w	r4, [r5, #140]	@ 0x8c
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
2400e35a:	66ec      	str	r4, [r5, #108]	@ 0x6c
  huart->RxEventType = HAL_UART_RXEVENT_TC;
2400e35c:	672c      	str	r4, [r5, #112]	@ 0x70
}
2400e35e:	bd38      	pop	{r3, r4, r5, pc}
    return HAL_ERROR;
2400e360:	2001      	movs	r0, #1
2400e362:	e7fc      	b.n	2400e35e <HAL_UART_DeInit+0x38>

2400e364 <HAL_UART_Transmit_IT>:
  if (huart->gState == HAL_UART_STATE_READY)
2400e364:	f8d0 3088 	ldr.w	r3, [r0, #136]	@ 0x88
2400e368:	2b20      	cmp	r3, #32
{
2400e36a:	b510      	push	{r4, lr}
  if (huart->gState == HAL_UART_STATE_READY)
2400e36c:	d143      	bne.n	2400e3f6 <HAL_UART_Transmit_IT+0x92>
    if ((pData == NULL) || (Size == 0U))
2400e36e:	2900      	cmp	r1, #0
2400e370:	d043      	beq.n	2400e3fa <HAL_UART_Transmit_IT+0x96>
2400e372:	2a00      	cmp	r2, #0
2400e374:	d041      	beq.n	2400e3fa <HAL_UART_Transmit_IT+0x96>
    huart->TxXferCount = Size;
2400e376:	f8a0 2056 	strh.w	r2, [r0, #86]	@ 0x56
    huart->ErrorCode = HAL_UART_ERROR_NONE;
2400e37a:	2300      	movs	r3, #0
    huart->TxXferSize  = Size;
2400e37c:	f8a0 2054 	strh.w	r2, [r0, #84]	@ 0x54
    if (huart->FifoMode == UART_FIFOMODE_ENABLE)
2400e380:	6e42      	ldr	r2, [r0, #100]	@ 0x64
    huart->ErrorCode = HAL_UART_ERROR_NONE;
2400e382:	f8c0 3090 	str.w	r3, [r0, #144]	@ 0x90
    huart->gState = HAL_UART_STATE_BUSY_TX;
2400e386:	2321      	movs	r3, #33	@ 0x21
    if (huart->FifoMode == UART_FIFOMODE_ENABLE)
2400e388:	f1b2 5f00 	cmp.w	r2, #536870912	@ 0x20000000
    huart->pTxBuffPtr  = pData;
2400e38c:	6501      	str	r1, [r0, #80]	@ 0x50
    huart->gState = HAL_UART_STATE_BUSY_TX;
2400e38e:	f8c0 3088 	str.w	r3, [r0, #136]	@ 0x88
    if (huart->FifoMode == UART_FIFOMODE_ENABLE)
2400e392:	6802      	ldr	r2, [r0, #0]
      if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
2400e394:	6883      	ldr	r3, [r0, #8]
    if (huart->FifoMode == UART_FIFOMODE_ENABLE)
2400e396:	d119      	bne.n	2400e3cc <HAL_UART_Transmit_IT+0x68>
      if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
2400e398:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
2400e39c:	d114      	bne.n	2400e3c8 <HAL_UART_Transmit_IT+0x64>
2400e39e:	6904      	ldr	r4, [r0, #16]
        huart->TxISR = UART_TxISR_16BIT_FIFOEN;
2400e3a0:	4b17      	ldr	r3, [pc, #92]	@ (2400e400 <HAL_UART_Transmit_IT+0x9c>)
2400e3a2:	4918      	ldr	r1, [pc, #96]	@ (2400e404 <HAL_UART_Transmit_IT+0xa0>)
2400e3a4:	2c00      	cmp	r4, #0
2400e3a6:	bf08      	it	eq
2400e3a8:	460b      	moveq	r3, r1
2400e3aa:	6783      	str	r3, [r0, #120]	@ 0x78
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
2400e3ac:	f102 0308 	add.w	r3, r2, #8
2400e3b0:	e853 3f00 	ldrex	r3, [r3]
      ATOMIC_SET_BIT(huart->Instance->CR3, USART_CR3_TXFTIE);
2400e3b4:	f443 0300 	orr.w	r3, r3, #8388608	@ 0x800000
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
2400e3b8:	f102 0008 	add.w	r0, r2, #8
2400e3bc:	e840 3100 	strex	r1, r3, [r0]
2400e3c0:	2900      	cmp	r1, #0
2400e3c2:	d1f3      	bne.n	2400e3ac <HAL_UART_Transmit_IT+0x48>
    return HAL_OK;
2400e3c4:	2000      	movs	r0, #0
}
2400e3c6:	bd10      	pop	{r4, pc}
        huart->TxISR = UART_TxISR_8BIT_FIFOEN;
2400e3c8:	4b0d      	ldr	r3, [pc, #52]	@ (2400e400 <HAL_UART_Transmit_IT+0x9c>)
2400e3ca:	e7ee      	b.n	2400e3aa <HAL_UART_Transmit_IT+0x46>
      if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
2400e3cc:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
2400e3d0:	d10f      	bne.n	2400e3f2 <HAL_UART_Transmit_IT+0x8e>
2400e3d2:	6904      	ldr	r4, [r0, #16]
        huart->TxISR = UART_TxISR_16BIT;
2400e3d4:	4b0c      	ldr	r3, [pc, #48]	@ (2400e408 <HAL_UART_Transmit_IT+0xa4>)
2400e3d6:	490d      	ldr	r1, [pc, #52]	@ (2400e40c <HAL_UART_Transmit_IT+0xa8>)
2400e3d8:	2c00      	cmp	r4, #0
2400e3da:	bf08      	it	eq
2400e3dc:	460b      	moveq	r3, r1
2400e3de:	6783      	str	r3, [r0, #120]	@ 0x78
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
2400e3e0:	e852 3f00 	ldrex	r3, [r2]
      ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_TXEIE_TXFNFIE);
2400e3e4:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
2400e3e8:	e842 3100 	strex	r1, r3, [r2]
2400e3ec:	2900      	cmp	r1, #0
2400e3ee:	d1f7      	bne.n	2400e3e0 <HAL_UART_Transmit_IT+0x7c>
2400e3f0:	e7e8      	b.n	2400e3c4 <HAL_UART_Transmit_IT+0x60>
        huart->TxISR = UART_TxISR_8BIT;
2400e3f2:	4b05      	ldr	r3, [pc, #20]	@ (2400e408 <HAL_UART_Transmit_IT+0xa4>)
2400e3f4:	e7f3      	b.n	2400e3de <HAL_UART_Transmit_IT+0x7a>
    return HAL_BUSY;
2400e3f6:	2002      	movs	r0, #2
2400e3f8:	e7e5      	b.n	2400e3c6 <HAL_UART_Transmit_IT+0x62>
      return HAL_ERROR;
2400e3fa:	2001      	movs	r0, #1
2400e3fc:	e7e3      	b.n	2400e3c6 <HAL_UART_Transmit_IT+0x62>
2400e3fe:	bf00      	nop
2400e400:	2400e253 	.word	0x2400e253
2400e404:	2400e2b9 	.word	0x2400e2b9
2400e408:	2400e1f3 	.word	0x2400e1f3
2400e40c:	2400e221 	.word	0x2400e221

2400e410 <HAL_UART_Transmit_DMA>:
{
2400e410:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
2400e412:	4604      	mov	r4, r0
2400e414:	4613      	mov	r3, r2
  if (huart->gState == HAL_UART_STATE_READY)
2400e416:	f8d4 5088 	ldr.w	r5, [r4, #136]	@ 0x88
2400e41a:	2d20      	cmp	r5, #32
2400e41c:	d132      	bne.n	2400e484 <HAL_UART_Transmit_DMA+0x74>
    if ((pData == NULL) || (Size == 0U))
2400e41e:	b1f1      	cbz	r1, 2400e45e <HAL_UART_Transmit_DMA+0x4e>
2400e420:	b1ea      	cbz	r2, 2400e45e <HAL_UART_Transmit_DMA+0x4e>
    huart->TxXferCount = Size;
2400e422:	f8a4 2056 	strh.w	r2, [r4, #86]	@ 0x56
    huart->ErrorCode = HAL_UART_ERROR_NONE;
2400e426:	2600      	movs	r6, #0
    huart->TxXferSize  = Size;
2400e428:	f8a4 2054 	strh.w	r2, [r4, #84]	@ 0x54
    huart->gState = HAL_UART_STATE_BUSY_TX;
2400e42c:	2221      	movs	r2, #33	@ 0x21
    if (huart->hdmatx != NULL)
2400e42e:	6fe0      	ldr	r0, [r4, #124]	@ 0x7c
    huart->ErrorCode = HAL_UART_ERROR_NONE;
2400e430:	f8c4 6090 	str.w	r6, [r4, #144]	@ 0x90
    huart->pTxBuffPtr  = pData;
2400e434:	6521      	str	r1, [r4, #80]	@ 0x50
    huart->gState = HAL_UART_STATE_BUSY_TX;
2400e436:	f8c4 2088 	str.w	r2, [r4, #136]	@ 0x88
      if (HAL_DMA_Start_IT(huart->hdmatx, (uint32_t)huart->pTxBuffPtr, (uint32_t)&huart->Instance->TDR, Size) != HAL_OK)
2400e43a:	6822      	ldr	r2, [r4, #0]
    if (huart->hdmatx != NULL)
2400e43c:	b188      	cbz	r0, 2400e462 <HAL_UART_Transmit_DMA+0x52>
      huart->hdmatx->XferCpltCallback = UART_DMATransmitCplt;
2400e43e:	4f12      	ldr	r7, [pc, #72]	@ (2400e488 <HAL_UART_Transmit_DMA+0x78>)
      if (HAL_DMA_Start_IT(huart->hdmatx, (uint32_t)huart->pTxBuffPtr, (uint32_t)&huart->Instance->TDR, Size) != HAL_OK)
2400e440:	3228      	adds	r2, #40	@ 0x28
      huart->hdmatx->XferCpltCallback = UART_DMATransmitCplt;
2400e442:	63c7      	str	r7, [r0, #60]	@ 0x3c
      huart->hdmatx->XferHalfCpltCallback = UART_DMATxHalfCplt;
2400e444:	4f11      	ldr	r7, [pc, #68]	@ (2400e48c <HAL_UART_Transmit_DMA+0x7c>)
2400e446:	6407      	str	r7, [r0, #64]	@ 0x40
      huart->hdmatx->XferErrorCallback = UART_DMAError;
2400e448:	4f11      	ldr	r7, [pc, #68]	@ (2400e490 <HAL_UART_Transmit_DMA+0x80>)
      huart->hdmatx->XferAbortCallback = NULL;
2400e44a:	e9c0 7613 	strd	r7, r6, [r0, #76]	@ 0x4c
      if (HAL_DMA_Start_IT(huart->hdmatx, (uint32_t)huart->pTxBuffPtr, (uint32_t)&huart->Instance->TDR, Size) != HAL_OK)
2400e44e:	f7f3 fac7 	bl	240019e0 <HAL_DMA_Start_IT>
2400e452:	b130      	cbz	r0, 2400e462 <HAL_UART_Transmit_DMA+0x52>
        huart->ErrorCode = HAL_UART_ERROR_DMA;
2400e454:	2310      	movs	r3, #16
2400e456:	f8c4 3090 	str.w	r3, [r4, #144]	@ 0x90
        huart->gState = HAL_UART_STATE_READY;
2400e45a:	f8c4 5088 	str.w	r5, [r4, #136]	@ 0x88
      return HAL_ERROR;
2400e45e:	2001      	movs	r0, #1
}
2400e460:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_TCF);
2400e462:	2240      	movs	r2, #64	@ 0x40
2400e464:	6823      	ldr	r3, [r4, #0]
2400e466:	621a      	str	r2, [r3, #32]
2400e468:	6822      	ldr	r2, [r4, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
2400e46a:	f102 0308 	add.w	r3, r2, #8
2400e46e:	e853 3f00 	ldrex	r3, [r3]
    ATOMIC_SET_BIT(huart->Instance->CR3, USART_CR3_DMAT);
2400e472:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
2400e476:	f102 0108 	add.w	r1, r2, #8
2400e47a:	e841 3000 	strex	r0, r3, [r1]
2400e47e:	2800      	cmp	r0, #0
2400e480:	d1f3      	bne.n	2400e46a <HAL_UART_Transmit_DMA+0x5a>
2400e482:	e7ed      	b.n	2400e460 <HAL_UART_Transmit_DMA+0x50>
    return HAL_BUSY;
2400e484:	2002      	movs	r0, #2
2400e486:	e7eb      	b.n	2400e460 <HAL_UART_Transmit_DMA+0x50>
2400e488:	2400e85f 	.word	0x2400e85f
2400e48c:	2400e8a7 	.word	0x2400e8a7
2400e490:	2400e8b7 	.word	0x2400e8b7

2400e494 <HAL_UART_DMAPause>:
  if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT)) &&
2400e494:	6803      	ldr	r3, [r0, #0]
  const HAL_UART_StateTypeDef gstate = huart->gState;
2400e496:	f8d0 2088 	ldr.w	r2, [r0, #136]	@ 0x88
  const HAL_UART_StateTypeDef rxstate = huart->RxState;
2400e49a:	f8d0 108c 	ldr.w	r1, [r0, #140]	@ 0x8c
  if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT)) &&
2400e49e:	6898      	ldr	r0, [r3, #8]
2400e4a0:	0600      	lsls	r0, r0, #24
2400e4a2:	d50d      	bpl.n	2400e4c0 <HAL_UART_DMAPause+0x2c>
2400e4a4:	2a21      	cmp	r2, #33	@ 0x21
2400e4a6:	d10b      	bne.n	2400e4c0 <HAL_UART_DMAPause+0x2c>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
2400e4a8:	f103 0208 	add.w	r2, r3, #8
2400e4ac:	e852 2f00 	ldrex	r2, [r2]
    ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
2400e4b0:	f022 0280 	bic.w	r2, r2, #128	@ 0x80
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
2400e4b4:	f103 0c08 	add.w	ip, r3, #8
2400e4b8:	e84c 2000 	strex	r0, r2, [ip]
2400e4bc:	2800      	cmp	r0, #0
2400e4be:	d1f3      	bne.n	2400e4a8 <HAL_UART_DMAPause+0x14>
  if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) &&
2400e4c0:	689a      	ldr	r2, [r3, #8]
2400e4c2:	0652      	lsls	r2, r2, #25
2400e4c4:	d521      	bpl.n	2400e50a <HAL_UART_DMAPause+0x76>
2400e4c6:	2922      	cmp	r1, #34	@ 0x22
2400e4c8:	d11f      	bne.n	2400e50a <HAL_UART_DMAPause+0x76>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
2400e4ca:	e853 2f00 	ldrex	r2, [r3]
    ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
2400e4ce:	f422 7280 	bic.w	r2, r2, #256	@ 0x100
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
2400e4d2:	e843 2100 	strex	r1, r2, [r3]
2400e4d6:	2900      	cmp	r1, #0
2400e4d8:	d1f7      	bne.n	2400e4ca <HAL_UART_DMAPause+0x36>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
2400e4da:	f103 0208 	add.w	r2, r3, #8
2400e4de:	e852 2f00 	ldrex	r2, [r2]
    ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
2400e4e2:	f022 0201 	bic.w	r2, r2, #1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
2400e4e6:	f103 0008 	add.w	r0, r3, #8
2400e4ea:	e840 2100 	strex	r1, r2, [r0]
2400e4ee:	2900      	cmp	r1, #0
2400e4f0:	d1f3      	bne.n	2400e4da <HAL_UART_DMAPause+0x46>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
2400e4f2:	f103 0208 	add.w	r2, r3, #8
2400e4f6:	e852 2f00 	ldrex	r2, [r2]
    ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
2400e4fa:	f022 0240 	bic.w	r2, r2, #64	@ 0x40
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
2400e4fe:	f103 0008 	add.w	r0, r3, #8
2400e502:	e840 2100 	strex	r1, r2, [r0]
2400e506:	2900      	cmp	r1, #0
2400e508:	d1f3      	bne.n	2400e4f2 <HAL_UART_DMAPause+0x5e>
}
2400e50a:	2000      	movs	r0, #0
2400e50c:	4770      	bx	lr

2400e50e <HAL_UART_DMAResume>:
  if (huart->gState == HAL_UART_STATE_BUSY_TX)
2400e50e:	f8d0 3088 	ldr.w	r3, [r0, #136]	@ 0x88
2400e512:	2b21      	cmp	r3, #33	@ 0x21
2400e514:	d10b      	bne.n	2400e52e <HAL_UART_DMAResume+0x20>
    ATOMIC_SET_BIT(huart->Instance->CR3, USART_CR3_DMAT);
2400e516:	6802      	ldr	r2, [r0, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
2400e518:	f102 0308 	add.w	r3, r2, #8
2400e51c:	e853 3f00 	ldrex	r3, [r3]
2400e520:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
2400e524:	3208      	adds	r2, #8
2400e526:	e842 3100 	strex	r1, r3, [r2]
2400e52a:	2900      	cmp	r1, #0
2400e52c:	d1f3      	bne.n	2400e516 <HAL_UART_DMAResume+0x8>
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
2400e52e:	f8d0 308c 	ldr.w	r3, [r0, #140]	@ 0x8c
2400e532:	2b22      	cmp	r3, #34	@ 0x22
2400e534:	d125      	bne.n	2400e582 <HAL_UART_DMAResume+0x74>
    __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF);
2400e536:	6803      	ldr	r3, [r0, #0]
2400e538:	2208      	movs	r2, #8
2400e53a:	621a      	str	r2, [r3, #32]
    if (huart->Init.Parity != UART_PARITY_NONE)
2400e53c:	6902      	ldr	r2, [r0, #16]
2400e53e:	6803      	ldr	r3, [r0, #0]
2400e540:	b13a      	cbz	r2, 2400e552 <HAL_UART_DMAResume+0x44>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
2400e542:	e853 2f00 	ldrex	r2, [r3]
      ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_PEIE);
2400e546:	f442 7280 	orr.w	r2, r2, #256	@ 0x100
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
2400e54a:	e843 2100 	strex	r1, r2, [r3]
2400e54e:	2900      	cmp	r1, #0
2400e550:	d1f7      	bne.n	2400e542 <HAL_UART_DMAResume+0x34>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
2400e552:	f103 0208 	add.w	r2, r3, #8
2400e556:	e852 2f00 	ldrex	r2, [r2]
    ATOMIC_SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
2400e55a:	f042 0201 	orr.w	r2, r2, #1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
2400e55e:	f103 0008 	add.w	r0, r3, #8
2400e562:	e840 2100 	strex	r1, r2, [r0]
2400e566:	2900      	cmp	r1, #0
2400e568:	d1f3      	bne.n	2400e552 <HAL_UART_DMAResume+0x44>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
2400e56a:	f103 0208 	add.w	r2, r3, #8
2400e56e:	e852 2f00 	ldrex	r2, [r2]
    ATOMIC_SET_BIT(huart->Instance->CR3, USART_CR3_DMAR);
2400e572:	f042 0240 	orr.w	r2, r2, #64	@ 0x40
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
2400e576:	f103 0008 	add.w	r0, r3, #8
2400e57a:	e840 2100 	strex	r1, r2, [r0]
2400e57e:	2900      	cmp	r1, #0
2400e580:	d1f3      	bne.n	2400e56a <HAL_UART_DMAResume+0x5c>
}
2400e582:	2000      	movs	r0, #0
2400e584:	4770      	bx	lr

2400e586 <HAL_UART_DMAStop>:
  if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT)) &&
2400e586:	6802      	ldr	r2, [r0, #0]
{
2400e588:	b538      	push	{r3, r4, r5, lr}
  const HAL_UART_StateTypeDef gstate = huart->gState;
2400e58a:	f8d0 3088 	ldr.w	r3, [r0, #136]	@ 0x88
{
2400e58e:	4604      	mov	r4, r0
  const HAL_UART_StateTypeDef rxstate = huart->RxState;
2400e590:	f8d0 508c 	ldr.w	r5, [r0, #140]	@ 0x8c
  if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT)) &&
2400e594:	6891      	ldr	r1, [r2, #8]
2400e596:	0609      	lsls	r1, r1, #24
2400e598:	d51f      	bpl.n	2400e5da <HAL_UART_DMAStop+0x54>
2400e59a:	2b21      	cmp	r3, #33	@ 0x21
2400e59c:	d11d      	bne.n	2400e5da <HAL_UART_DMAStop+0x54>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
2400e59e:	f102 0308 	add.w	r3, r2, #8
2400e5a2:	e853 3f00 	ldrex	r3, [r3]
    ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
2400e5a6:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
2400e5aa:	f102 0008 	add.w	r0, r2, #8
2400e5ae:	e840 3100 	strex	r1, r3, [r0]
2400e5b2:	2900      	cmp	r1, #0
2400e5b4:	d1f3      	bne.n	2400e59e <HAL_UART_DMAStop+0x18>
    if (huart->hdmatx != NULL)
2400e5b6:	6fe0      	ldr	r0, [r4, #124]	@ 0x7c
2400e5b8:	b160      	cbz	r0, 2400e5d4 <HAL_UART_DMAStop+0x4e>
      if (HAL_DMA_Abort(huart->hdmatx) != HAL_OK)
2400e5ba:	f7f3 fb2b 	bl	24001c14 <HAL_DMA_Abort>
2400e5be:	b148      	cbz	r0, 2400e5d4 <HAL_UART_DMAStop+0x4e>
        if (HAL_DMA_GetError(huart->hdmatx) == HAL_DMA_ERROR_TIMEOUT)
2400e5c0:	6fe0      	ldr	r0, [r4, #124]	@ 0x7c
2400e5c2:	f7f4 fa78 	bl	24002ab6 <HAL_DMA_GetError>
2400e5c6:	2820      	cmp	r0, #32
2400e5c8:	d104      	bne.n	2400e5d4 <HAL_UART_DMAStop+0x4e>
          huart->ErrorCode = HAL_UART_ERROR_DMA;
2400e5ca:	2310      	movs	r3, #16
          return HAL_TIMEOUT;
2400e5cc:	2003      	movs	r0, #3
          huart->ErrorCode = HAL_UART_ERROR_DMA;
2400e5ce:	f8c4 3090 	str.w	r3, [r4, #144]	@ 0x90
          return HAL_TIMEOUT;
2400e5d2:	e009      	b.n	2400e5e8 <HAL_UART_DMAStop+0x62>
    UART_EndTxTransfer(huart);
2400e5d4:	4620      	mov	r0, r4
2400e5d6:	f7ff fdb3 	bl	2400e140 <UART_EndTxTransfer>
  if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) &&
2400e5da:	6822      	ldr	r2, [r4, #0]
2400e5dc:	6893      	ldr	r3, [r2, #8]
2400e5de:	065b      	lsls	r3, r3, #25
2400e5e0:	d501      	bpl.n	2400e5e6 <HAL_UART_DMAStop+0x60>
2400e5e2:	2d22      	cmp	r5, #34	@ 0x22
2400e5e4:	d001      	beq.n	2400e5ea <HAL_UART_DMAStop+0x64>
  return HAL_OK;
2400e5e6:	2000      	movs	r0, #0
}
2400e5e8:	bd38      	pop	{r3, r4, r5, pc}
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
2400e5ea:	f102 0308 	add.w	r3, r2, #8
2400e5ee:	e853 3f00 	ldrex	r3, [r3]
    ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
2400e5f2:	f023 0340 	bic.w	r3, r3, #64	@ 0x40
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
2400e5f6:	f102 0008 	add.w	r0, r2, #8
2400e5fa:	e840 3100 	strex	r1, r3, [r0]
2400e5fe:	2900      	cmp	r1, #0
2400e600:	d1f3      	bne.n	2400e5ea <HAL_UART_DMAStop+0x64>
    if (huart->hdmarx != NULL)
2400e602:	f8d4 0080 	ldr.w	r0, [r4, #128]	@ 0x80
2400e606:	b140      	cbz	r0, 2400e61a <HAL_UART_DMAStop+0x94>
      if (HAL_DMA_Abort(huart->hdmarx) != HAL_OK)
2400e608:	f7f3 fb04 	bl	24001c14 <HAL_DMA_Abort>
2400e60c:	b128      	cbz	r0, 2400e61a <HAL_UART_DMAStop+0x94>
        if (HAL_DMA_GetError(huart->hdmarx) == HAL_DMA_ERROR_TIMEOUT)
2400e60e:	f8d4 0080 	ldr.w	r0, [r4, #128]	@ 0x80
2400e612:	f7f4 fa50 	bl	24002ab6 <HAL_DMA_GetError>
2400e616:	2820      	cmp	r0, #32
2400e618:	d0d7      	beq.n	2400e5ca <HAL_UART_DMAStop+0x44>
    UART_EndRxTransfer(huart);
2400e61a:	4620      	mov	r0, r4
2400e61c:	f7ff fdaa 	bl	2400e174 <UART_EndRxTransfer>
2400e620:	e7e1      	b.n	2400e5e6 <HAL_UART_DMAStop+0x60>

2400e622 <HAL_UART_Abort>:
{
2400e622:	b510      	push	{r4, lr}
2400e624:	4604      	mov	r4, r0
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE |
2400e626:	6822      	ldr	r2, [r4, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
2400e628:	e852 3f00 	ldrex	r3, [r2]
2400e62c:	f423 73f0 	bic.w	r3, r3, #480	@ 0x1e0
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
2400e630:	e842 3100 	strex	r1, r3, [r2]
   return(result);
2400e634:	6823      	ldr	r3, [r4, #0]
2400e636:	2900      	cmp	r1, #0
2400e638:	d1f5      	bne.n	2400e626 <HAL_UART_Abort+0x4>
  ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE | USART_CR3_RXFTIE | USART_CR3_TXFTIE);
2400e63a:	4838      	ldr	r0, [pc, #224]	@ (2400e71c <HAL_UART_Abort+0xfa>)
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
2400e63c:	f103 0208 	add.w	r2, r3, #8
2400e640:	e852 2f00 	ldrex	r2, [r2]
2400e644:	4002      	ands	r2, r0
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
2400e646:	f103 0c08 	add.w	ip, r3, #8
2400e64a:	e84c 2100 	strex	r1, r2, [ip]
2400e64e:	2900      	cmp	r1, #0
2400e650:	d1f4      	bne.n	2400e63c <HAL_UART_Abort+0x1a>
  if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
2400e652:	6ee2      	ldr	r2, [r4, #108]	@ 0x6c
2400e654:	2a01      	cmp	r2, #1
2400e656:	d107      	bne.n	2400e668 <HAL_UART_Abort+0x46>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
2400e658:	e853 2f00 	ldrex	r2, [r3]
    ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_IDLEIE));
2400e65c:	f022 0210 	bic.w	r2, r2, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
2400e660:	e843 2100 	strex	r1, r2, [r3]
2400e664:	2900      	cmp	r1, #0
2400e666:	d1f7      	bne.n	2400e658 <HAL_UART_Abort+0x36>
  if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
2400e668:	689a      	ldr	r2, [r3, #8]
2400e66a:	0612      	lsls	r2, r2, #24
2400e66c:	d51b      	bpl.n	2400e6a6 <HAL_UART_Abort+0x84>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
2400e66e:	f103 0208 	add.w	r2, r3, #8
2400e672:	e852 2f00 	ldrex	r2, [r2]
    ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
2400e676:	f022 0280 	bic.w	r2, r2, #128	@ 0x80
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
2400e67a:	f103 0008 	add.w	r0, r3, #8
2400e67e:	e840 2100 	strex	r1, r2, [r0]
2400e682:	2900      	cmp	r1, #0
2400e684:	d1f3      	bne.n	2400e66e <HAL_UART_Abort+0x4c>
    if (huart->hdmatx != NULL)
2400e686:	6fe0      	ldr	r0, [r4, #124]	@ 0x7c
2400e688:	b168      	cbz	r0, 2400e6a6 <HAL_UART_Abort+0x84>
      huart->hdmatx->XferAbortCallback = NULL;
2400e68a:	6501      	str	r1, [r0, #80]	@ 0x50
      if (HAL_DMA_Abort(huart->hdmatx) != HAL_OK)
2400e68c:	f7f3 fac2 	bl	24001c14 <HAL_DMA_Abort>
2400e690:	b148      	cbz	r0, 2400e6a6 <HAL_UART_Abort+0x84>
        if (HAL_DMA_GetError(huart->hdmatx) == HAL_DMA_ERROR_TIMEOUT)
2400e692:	6fe0      	ldr	r0, [r4, #124]	@ 0x7c
2400e694:	f7f4 fa0f 	bl	24002ab6 <HAL_DMA_GetError>
2400e698:	2820      	cmp	r0, #32
2400e69a:	d104      	bne.n	2400e6a6 <HAL_UART_Abort+0x84>
          huart->ErrorCode = HAL_UART_ERROR_DMA;
2400e69c:	2310      	movs	r3, #16
          return HAL_TIMEOUT;
2400e69e:	2003      	movs	r0, #3
          huart->ErrorCode = HAL_UART_ERROR_DMA;
2400e6a0:	f8c4 3090 	str.w	r3, [r4, #144]	@ 0x90
}
2400e6a4:	bd10      	pop	{r4, pc}
  if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
2400e6a6:	6822      	ldr	r2, [r4, #0]
2400e6a8:	6893      	ldr	r3, [r2, #8]
2400e6aa:	065b      	lsls	r3, r3, #25
2400e6ac:	d518      	bpl.n	2400e6e0 <HAL_UART_Abort+0xbe>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
2400e6ae:	f102 0308 	add.w	r3, r2, #8
2400e6b2:	e853 3f00 	ldrex	r3, [r3]
    ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
2400e6b6:	f023 0340 	bic.w	r3, r3, #64	@ 0x40
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
2400e6ba:	f102 0008 	add.w	r0, r2, #8
2400e6be:	e840 3100 	strex	r1, r3, [r0]
2400e6c2:	2900      	cmp	r1, #0
2400e6c4:	d1f3      	bne.n	2400e6ae <HAL_UART_Abort+0x8c>
    if (huart->hdmarx != NULL)
2400e6c6:	f8d4 0080 	ldr.w	r0, [r4, #128]	@ 0x80
2400e6ca:	b148      	cbz	r0, 2400e6e0 <HAL_UART_Abort+0xbe>
      huart->hdmarx->XferAbortCallback = NULL;
2400e6cc:	6501      	str	r1, [r0, #80]	@ 0x50
      if (HAL_DMA_Abort(huart->hdmarx) != HAL_OK)
2400e6ce:	f7f3 faa1 	bl	24001c14 <HAL_DMA_Abort>
2400e6d2:	b128      	cbz	r0, 2400e6e0 <HAL_UART_Abort+0xbe>
        if (HAL_DMA_GetError(huart->hdmarx) == HAL_DMA_ERROR_TIMEOUT)
2400e6d4:	f8d4 0080 	ldr.w	r0, [r4, #128]	@ 0x80
2400e6d8:	f7f4 f9ed 	bl	24002ab6 <HAL_DMA_GetError>
2400e6dc:	2820      	cmp	r0, #32
2400e6de:	d0dd      	beq.n	2400e69c <HAL_UART_Abort+0x7a>
  huart->TxXferCount = 0U;
2400e6e0:	2300      	movs	r3, #0
  __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF | UART_CLEAR_NEF | UART_CLEAR_PEF | UART_CLEAR_FEF);
2400e6e2:	220f      	movs	r2, #15
  huart->TxXferCount = 0U;
2400e6e4:	f8a4 3056 	strh.w	r3, [r4, #86]	@ 0x56
  huart->RxXferCount = 0U;
2400e6e8:	f8a4 305e 	strh.w	r3, [r4, #94]	@ 0x5e
  __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF | UART_CLEAR_NEF | UART_CLEAR_PEF | UART_CLEAR_FEF);
2400e6ec:	6823      	ldr	r3, [r4, #0]
2400e6ee:	621a      	str	r2, [r3, #32]
  if (huart->FifoMode == UART_FIFOMODE_ENABLE)
2400e6f0:	6e62      	ldr	r2, [r4, #100]	@ 0x64
2400e6f2:	f1b2 5f00 	cmp.w	r2, #536870912	@ 0x20000000
2400e6f6:	d103      	bne.n	2400e700 <HAL_UART_Abort+0xde>
    __HAL_UART_SEND_REQ(huart, UART_TXDATA_FLUSH_REQUEST);
2400e6f8:	699a      	ldr	r2, [r3, #24]
2400e6fa:	f042 0210 	orr.w	r2, r2, #16
2400e6fe:	619a      	str	r2, [r3, #24]
  __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
2400e700:	699a      	ldr	r2, [r3, #24]
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
2400e702:	2000      	movs	r0, #0
  __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
2400e704:	f042 0208 	orr.w	r2, r2, #8
2400e708:	619a      	str	r2, [r3, #24]
  huart->gState  = HAL_UART_STATE_READY;
2400e70a:	2320      	movs	r3, #32
2400e70c:	f8c4 3088 	str.w	r3, [r4, #136]	@ 0x88
  huart->RxState = HAL_UART_STATE_READY;
2400e710:	f8c4 308c 	str.w	r3, [r4, #140]	@ 0x8c
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
2400e714:	66e0      	str	r0, [r4, #108]	@ 0x6c
  huart->ErrorCode = HAL_UART_ERROR_NONE;
2400e716:	f8c4 0090 	str.w	r0, [r4, #144]	@ 0x90
  return HAL_OK;
2400e71a:	e7c3      	b.n	2400e6a4 <HAL_UART_Abort+0x82>
2400e71c:	ef7ffffe 	.word	0xef7ffffe

2400e720 <HAL_UART_AbortTransmit>:
{
2400e720:	b510      	push	{r4, lr}
2400e722:	4604      	mov	r4, r0
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TCIE | USART_CR1_TXEIE_TXFNFIE));
2400e724:	6822      	ldr	r2, [r4, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
2400e726:	e852 3f00 	ldrex	r3, [r2]
2400e72a:	f023 03c0 	bic.w	r3, r3, #192	@ 0xc0
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
2400e72e:	e842 3100 	strex	r1, r3, [r2]
   return(result);
2400e732:	6823      	ldr	r3, [r4, #0]
2400e734:	2900      	cmp	r1, #0
2400e736:	d1f5      	bne.n	2400e724 <HAL_UART_AbortTransmit+0x4>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
2400e738:	f103 0208 	add.w	r2, r3, #8
2400e73c:	e852 2f00 	ldrex	r2, [r2]
  ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_TXFTIE);
2400e740:	f422 0200 	bic.w	r2, r2, #8388608	@ 0x800000
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
2400e744:	f103 0008 	add.w	r0, r3, #8
2400e748:	e840 2100 	strex	r1, r2, [r0]
2400e74c:	2900      	cmp	r1, #0
2400e74e:	d1f3      	bne.n	2400e738 <HAL_UART_AbortTransmit+0x18>
  if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
2400e750:	689a      	ldr	r2, [r3, #8]
2400e752:	0612      	lsls	r2, r2, #24
2400e754:	d51b      	bpl.n	2400e78e <HAL_UART_AbortTransmit+0x6e>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
2400e756:	f103 0208 	add.w	r2, r3, #8
2400e75a:	e852 2f00 	ldrex	r2, [r2]
    ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
2400e75e:	f022 0280 	bic.w	r2, r2, #128	@ 0x80
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
2400e762:	f103 0008 	add.w	r0, r3, #8
2400e766:	e840 2100 	strex	r1, r2, [r0]
2400e76a:	2900      	cmp	r1, #0
2400e76c:	d1f3      	bne.n	2400e756 <HAL_UART_AbortTransmit+0x36>
    if (huart->hdmatx != NULL)
2400e76e:	6fe0      	ldr	r0, [r4, #124]	@ 0x7c
2400e770:	b168      	cbz	r0, 2400e78e <HAL_UART_AbortTransmit+0x6e>
      huart->hdmatx->XferAbortCallback = NULL;
2400e772:	6501      	str	r1, [r0, #80]	@ 0x50
      if (HAL_DMA_Abort(huart->hdmatx) != HAL_OK)
2400e774:	f7f3 fa4e 	bl	24001c14 <HAL_DMA_Abort>
2400e778:	b148      	cbz	r0, 2400e78e <HAL_UART_AbortTransmit+0x6e>
        if (HAL_DMA_GetError(huart->hdmatx) == HAL_DMA_ERROR_TIMEOUT)
2400e77a:	6fe0      	ldr	r0, [r4, #124]	@ 0x7c
2400e77c:	f7f4 f99b 	bl	24002ab6 <HAL_DMA_GetError>
2400e780:	2820      	cmp	r0, #32
2400e782:	d104      	bne.n	2400e78e <HAL_UART_AbortTransmit+0x6e>
          huart->ErrorCode = HAL_UART_ERROR_DMA;
2400e784:	2310      	movs	r3, #16
          return HAL_TIMEOUT;
2400e786:	2003      	movs	r0, #3
          huart->ErrorCode = HAL_UART_ERROR_DMA;
2400e788:	f8c4 3090 	str.w	r3, [r4, #144]	@ 0x90
}
2400e78c:	bd10      	pop	{r4, pc}
  huart->TxXferCount = 0U;
2400e78e:	2300      	movs	r3, #0
2400e790:	f8a4 3056 	strh.w	r3, [r4, #86]	@ 0x56
  if (huart->FifoMode == UART_FIFOMODE_ENABLE)
2400e794:	6e63      	ldr	r3, [r4, #100]	@ 0x64
2400e796:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
2400e79a:	d104      	bne.n	2400e7a6 <HAL_UART_AbortTransmit+0x86>
    __HAL_UART_SEND_REQ(huart, UART_TXDATA_FLUSH_REQUEST);
2400e79c:	6822      	ldr	r2, [r4, #0]
2400e79e:	6993      	ldr	r3, [r2, #24]
2400e7a0:	f043 0310 	orr.w	r3, r3, #16
2400e7a4:	6193      	str	r3, [r2, #24]
  huart->gState = HAL_UART_STATE_READY;
2400e7a6:	2320      	movs	r3, #32
  return HAL_OK;
2400e7a8:	2000      	movs	r0, #0
  huart->gState = HAL_UART_STATE_READY;
2400e7aa:	f8c4 3088 	str.w	r3, [r4, #136]	@ 0x88
  return HAL_OK;
2400e7ae:	e7ed      	b.n	2400e78c <HAL_UART_AbortTransmit+0x6c>

2400e7b0 <HAL_UART_AbortReceive>:
{
2400e7b0:	b510      	push	{r4, lr}
2400e7b2:	4604      	mov	r4, r0
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_PEIE | USART_CR1_RXNEIE_RXFNEIE));
2400e7b4:	6822      	ldr	r2, [r4, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
2400e7b6:	e852 3f00 	ldrex	r3, [r2]
2400e7ba:	f423 7390 	bic.w	r3, r3, #288	@ 0x120
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
2400e7be:	e842 3100 	strex	r1, r3, [r2]
   return(result);
2400e7c2:	6823      	ldr	r3, [r4, #0]
2400e7c4:	2900      	cmp	r1, #0
2400e7c6:	d1f5      	bne.n	2400e7b4 <HAL_UART_AbortReceive+0x4>
  ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE | USART_CR3_RXFTIE);
2400e7c8:	4823      	ldr	r0, [pc, #140]	@ (2400e858 <HAL_UART_AbortReceive+0xa8>)
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
2400e7ca:	f103 0208 	add.w	r2, r3, #8
2400e7ce:	e852 2f00 	ldrex	r2, [r2]
2400e7d2:	4002      	ands	r2, r0
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
2400e7d4:	f103 0c08 	add.w	ip, r3, #8
2400e7d8:	e84c 2100 	strex	r1, r2, [ip]
2400e7dc:	2900      	cmp	r1, #0
2400e7de:	d1f4      	bne.n	2400e7ca <HAL_UART_AbortReceive+0x1a>
  if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
2400e7e0:	6ee2      	ldr	r2, [r4, #108]	@ 0x6c
2400e7e2:	2a01      	cmp	r2, #1
2400e7e4:	d107      	bne.n	2400e7f6 <HAL_UART_AbortReceive+0x46>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
2400e7e6:	e853 2f00 	ldrex	r2, [r3]
    ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_IDLEIE));
2400e7ea:	f022 0210 	bic.w	r2, r2, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
2400e7ee:	e843 2100 	strex	r1, r2, [r3]
2400e7f2:	2900      	cmp	r1, #0
2400e7f4:	d1f7      	bne.n	2400e7e6 <HAL_UART_AbortReceive+0x36>
  if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
2400e7f6:	689a      	ldr	r2, [r3, #8]
2400e7f8:	0652      	lsls	r2, r2, #25
2400e7fa:	d51d      	bpl.n	2400e838 <HAL_UART_AbortReceive+0x88>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
2400e7fc:	f103 0208 	add.w	r2, r3, #8
2400e800:	e852 2f00 	ldrex	r2, [r2]
    ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
2400e804:	f022 0240 	bic.w	r2, r2, #64	@ 0x40
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
2400e808:	f103 0008 	add.w	r0, r3, #8
2400e80c:	e840 2100 	strex	r1, r2, [r0]
2400e810:	2900      	cmp	r1, #0
2400e812:	d1f3      	bne.n	2400e7fc <HAL_UART_AbortReceive+0x4c>
    if (huart->hdmarx != NULL)
2400e814:	f8d4 0080 	ldr.w	r0, [r4, #128]	@ 0x80
2400e818:	b170      	cbz	r0, 2400e838 <HAL_UART_AbortReceive+0x88>
      huart->hdmarx->XferAbortCallback = NULL;
2400e81a:	6501      	str	r1, [r0, #80]	@ 0x50
      if (HAL_DMA_Abort(huart->hdmarx) != HAL_OK)
2400e81c:	f7f3 f9fa 	bl	24001c14 <HAL_DMA_Abort>
2400e820:	b150      	cbz	r0, 2400e838 <HAL_UART_AbortReceive+0x88>
        if (HAL_DMA_GetError(huart->hdmarx) == HAL_DMA_ERROR_TIMEOUT)
2400e822:	f8d4 0080 	ldr.w	r0, [r4, #128]	@ 0x80
2400e826:	f7f4 f946 	bl	24002ab6 <HAL_DMA_GetError>
2400e82a:	2820      	cmp	r0, #32
2400e82c:	d104      	bne.n	2400e838 <HAL_UART_AbortReceive+0x88>
          huart->ErrorCode = HAL_UART_ERROR_DMA;
2400e82e:	2310      	movs	r3, #16
          return HAL_TIMEOUT;
2400e830:	2003      	movs	r0, #3
          huart->ErrorCode = HAL_UART_ERROR_DMA;
2400e832:	f8c4 3090 	str.w	r3, [r4, #144]	@ 0x90
}
2400e836:	bd10      	pop	{r4, pc}
  __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF | UART_CLEAR_NEF | UART_CLEAR_PEF | UART_CLEAR_FEF);
2400e838:	6823      	ldr	r3, [r4, #0]
  huart->RxXferCount = 0U;
2400e83a:	2000      	movs	r0, #0
  __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF | UART_CLEAR_NEF | UART_CLEAR_PEF | UART_CLEAR_FEF);
2400e83c:	220f      	movs	r2, #15
  huart->RxXferCount = 0U;
2400e83e:	f8a4 005e 	strh.w	r0, [r4, #94]	@ 0x5e
  __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF | UART_CLEAR_NEF | UART_CLEAR_PEF | UART_CLEAR_FEF);
2400e842:	621a      	str	r2, [r3, #32]
  __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
2400e844:	699a      	ldr	r2, [r3, #24]
2400e846:	f042 0208 	orr.w	r2, r2, #8
2400e84a:	619a      	str	r2, [r3, #24]
  huart->RxState = HAL_UART_STATE_READY;
2400e84c:	2320      	movs	r3, #32
2400e84e:	f8c4 308c 	str.w	r3, [r4, #140]	@ 0x8c
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
2400e852:	66e0      	str	r0, [r4, #108]	@ 0x6c
  return HAL_OK;
2400e854:	e7ef      	b.n	2400e836 <HAL_UART_AbortReceive+0x86>
2400e856:	bf00      	nop
2400e858:	effffffe 	.word	0xeffffffe

2400e85c <HAL_UART_TxCpltCallback>:
__weak void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)
2400e85c:	4770      	bx	lr

2400e85e <UART_DMATransmitCplt>:
{
2400e85e:	b508      	push	{r3, lr}
2400e860:	4603      	mov	r3, r0
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);
2400e862:	6b80      	ldr	r0, [r0, #56]	@ 0x38
  if (hdma->Init.Mode != DMA_CIRCULAR)
2400e864:	69db      	ldr	r3, [r3, #28]
2400e866:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
2400e86a:	d018      	beq.n	2400e89e <UART_DMATransmitCplt+0x40>
    huart->TxXferCount = 0U;
2400e86c:	2300      	movs	r3, #0
2400e86e:	f8a0 3056 	strh.w	r3, [r0, #86]	@ 0x56
    ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
2400e872:	6802      	ldr	r2, [r0, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
2400e874:	f102 0308 	add.w	r3, r2, #8
2400e878:	e853 3f00 	ldrex	r3, [r3]
2400e87c:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
2400e880:	3208      	adds	r2, #8
2400e882:	e842 3100 	strex	r1, r3, [r2]
   return(result);
2400e886:	6802      	ldr	r2, [r0, #0]
2400e888:	2900      	cmp	r1, #0
2400e88a:	d1f2      	bne.n	2400e872 <UART_DMATransmitCplt+0x14>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
2400e88c:	e852 3f00 	ldrex	r3, [r2]
    ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_TCIE);
2400e890:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
2400e894:	e842 3100 	strex	r1, r3, [r2]
2400e898:	2900      	cmp	r1, #0
2400e89a:	d1f7      	bne.n	2400e88c <UART_DMATransmitCplt+0x2e>
}
2400e89c:	bd08      	pop	{r3, pc}
    HAL_UART_TxCpltCallback(huart);
2400e89e:	f7ff ffdd 	bl	2400e85c <HAL_UART_TxCpltCallback>
}
2400e8a2:	e7fb      	b.n	2400e89c <UART_DMATransmitCplt+0x3e>

2400e8a4 <HAL_UART_TxHalfCpltCallback>:
__weak void HAL_UART_TxHalfCpltCallback(UART_HandleTypeDef *huart)
2400e8a4:	4770      	bx	lr

2400e8a6 <UART_DMATxHalfCplt>:
  HAL_UART_TxHalfCpltCallback(huart);
2400e8a6:	6b80      	ldr	r0, [r0, #56]	@ 0x38
{
2400e8a8:	b508      	push	{r3, lr}
  HAL_UART_TxHalfCpltCallback(huart);
2400e8aa:	f7ff fffb 	bl	2400e8a4 <HAL_UART_TxHalfCpltCallback>
}
2400e8ae:	bd08      	pop	{r3, pc}

2400e8b0 <HAL_UART_RxCpltCallback>:
__weak void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
2400e8b0:	4770      	bx	lr

2400e8b2 <HAL_UART_RxHalfCpltCallback>:
__weak void HAL_UART_RxHalfCpltCallback(UART_HandleTypeDef *huart)
2400e8b2:	4770      	bx	lr

2400e8b4 <HAL_UART_ErrorCallback>:
__weak void HAL_UART_ErrorCallback(UART_HandleTypeDef *huart)
2400e8b4:	4770      	bx	lr

2400e8b6 <UART_DMAError>:
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);
2400e8b6:	6b80      	ldr	r0, [r0, #56]	@ 0x38
{
2400e8b8:	b538      	push	{r3, r4, r5, lr}
  if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT)) &&
2400e8ba:	6804      	ldr	r4, [r0, #0]
  const HAL_UART_StateTypeDef gstate = huart->gState;
2400e8bc:	f8d0 3088 	ldr.w	r3, [r0, #136]	@ 0x88
  const HAL_UART_StateTypeDef rxstate = huart->RxState;
2400e8c0:	f8d0 508c 	ldr.w	r5, [r0, #140]	@ 0x8c
  if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT)) &&
2400e8c4:	68a2      	ldr	r2, [r4, #8]
2400e8c6:	0612      	lsls	r2, r2, #24
2400e8c8:	d506      	bpl.n	2400e8d8 <UART_DMAError+0x22>
2400e8ca:	2b21      	cmp	r3, #33	@ 0x21
2400e8cc:	d104      	bne.n	2400e8d8 <UART_DMAError+0x22>
    huart->TxXferCount = 0U;
2400e8ce:	2300      	movs	r3, #0
2400e8d0:	f8a0 3056 	strh.w	r3, [r0, #86]	@ 0x56
    UART_EndTxTransfer(huart);
2400e8d4:	f7ff fc34 	bl	2400e140 <UART_EndTxTransfer>
  if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) &&
2400e8d8:	68a3      	ldr	r3, [r4, #8]
2400e8da:	065b      	lsls	r3, r3, #25
2400e8dc:	d506      	bpl.n	2400e8ec <UART_DMAError+0x36>
2400e8de:	2d22      	cmp	r5, #34	@ 0x22
2400e8e0:	d104      	bne.n	2400e8ec <UART_DMAError+0x36>
    huart->RxXferCount = 0U;
2400e8e2:	2300      	movs	r3, #0
2400e8e4:	f8a0 305e 	strh.w	r3, [r0, #94]	@ 0x5e
    UART_EndRxTransfer(huart);
2400e8e8:	f7ff fc44 	bl	2400e174 <UART_EndRxTransfer>
  huart->ErrorCode |= HAL_UART_ERROR_DMA;
2400e8ec:	f8d0 3090 	ldr.w	r3, [r0, #144]	@ 0x90
2400e8f0:	f043 0310 	orr.w	r3, r3, #16
2400e8f4:	f8c0 3090 	str.w	r3, [r0, #144]	@ 0x90
  HAL_UART_ErrorCallback(huart);
2400e8f8:	f7ff ffdc 	bl	2400e8b4 <HAL_UART_ErrorCallback>
}
2400e8fc:	bd38      	pop	{r3, r4, r5, pc}

2400e8fe <UART_DMAAbortOnError>:
{
2400e8fe:	b508      	push	{r3, lr}
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);
2400e900:	6b80      	ldr	r0, [r0, #56]	@ 0x38
  huart->RxXferCount = 0U;
2400e902:	2300      	movs	r3, #0
2400e904:	f8a0 305e 	strh.w	r3, [r0, #94]	@ 0x5e
  huart->TxXferCount = 0U;
2400e908:	f8a0 3056 	strh.w	r3, [r0, #86]	@ 0x56
  HAL_UART_ErrorCallback(huart);
2400e90c:	f7ff ffd2 	bl	2400e8b4 <HAL_UART_ErrorCallback>
}
2400e910:	bd08      	pop	{r3, pc}

2400e912 <HAL_UART_AbortCpltCallback>:
__weak void HAL_UART_AbortCpltCallback(UART_HandleTypeDef *huart)
2400e912:	4770      	bx	lr

2400e914 <HAL_UART_Abort_IT>:
{
2400e914:	b570      	push	{r4, r5, r6, lr}
2400e916:	4604      	mov	r4, r0
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_PEIE | USART_CR1_TCIE | USART_CR1_RXNEIE_RXFNEIE |
2400e918:	6822      	ldr	r2, [r4, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
2400e91a:	e852 3f00 	ldrex	r3, [r2]
2400e91e:	f423 73f0 	bic.w	r3, r3, #480	@ 0x1e0
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
2400e922:	e842 3100 	strex	r1, r3, [r2]
   return(result);
2400e926:	6823      	ldr	r3, [r4, #0]
2400e928:	2900      	cmp	r1, #0
2400e92a:	d1f5      	bne.n	2400e918 <HAL_UART_Abort_IT+0x4>
  ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE | USART_CR3_TXFTIE));
2400e92c:	4841      	ldr	r0, [pc, #260]	@ (2400ea34 <HAL_UART_Abort_IT+0x120>)
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
2400e92e:	f103 0208 	add.w	r2, r3, #8
2400e932:	e852 2f00 	ldrex	r2, [r2]
2400e936:	4002      	ands	r2, r0
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
2400e938:	f103 0508 	add.w	r5, r3, #8
2400e93c:	e845 2100 	strex	r1, r2, [r5]
2400e940:	2900      	cmp	r1, #0
2400e942:	d1f4      	bne.n	2400e92e <HAL_UART_Abort_IT+0x1a>
  if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
2400e944:	6ee2      	ldr	r2, [r4, #108]	@ 0x6c
2400e946:	2a01      	cmp	r2, #1
2400e948:	d060      	beq.n	2400ea0c <HAL_UART_Abort_IT+0xf8>
  if (huart->hdmatx != NULL)
2400e94a:	6fe0      	ldr	r0, [r4, #124]	@ 0x7c
2400e94c:	2800      	cmp	r0, #0
2400e94e:	d166      	bne.n	2400ea1e <HAL_UART_Abort_IT+0x10a>
  if (huart->hdmarx != NULL)
2400e950:	f8d4 1080 	ldr.w	r1, [r4, #128]	@ 0x80
2400e954:	b129      	cbz	r1, 2400e962 <HAL_UART_Abort_IT+0x4e>
    if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
2400e956:	689a      	ldr	r2, [r3, #8]
2400e958:	f012 0240 	ands.w	r2, r2, #64	@ 0x40
      huart->hdmarx->XferAbortCallback = UART_DMARxAbortCallback;
2400e95c:	bf18      	it	ne
2400e95e:	4a36      	ldrne	r2, [pc, #216]	@ (2400ea38 <HAL_UART_Abort_IT+0x124>)
      huart->hdmarx->XferAbortCallback = NULL;
2400e960:	650a      	str	r2, [r1, #80]	@ 0x50
  if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
2400e962:	689a      	ldr	r2, [r3, #8]
2400e964:	0612      	lsls	r2, r2, #24
2400e966:	d512      	bpl.n	2400e98e <HAL_UART_Abort_IT+0x7a>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
2400e968:	f103 0208 	add.w	r2, r3, #8
2400e96c:	e852 2f00 	ldrex	r2, [r2]
    ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
2400e970:	f022 0280 	bic.w	r2, r2, #128	@ 0x80
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
2400e974:	f103 0108 	add.w	r1, r3, #8
2400e978:	e841 2500 	strex	r5, r2, [r1]
2400e97c:	462e      	mov	r6, r5
2400e97e:	2d00      	cmp	r5, #0
2400e980:	d1f2      	bne.n	2400e968 <HAL_UART_Abort_IT+0x54>
    if (huart->hdmatx != NULL)
2400e982:	b120      	cbz	r0, 2400e98e <HAL_UART_Abort_IT+0x7a>
      if (HAL_DMA_Abort_IT(huart->hdmatx) != HAL_OK)
2400e984:	f7f3 faf2 	bl	24001f6c <HAL_DMA_Abort_IT>
2400e988:	b110      	cbz	r0, 2400e990 <HAL_UART_Abort_IT+0x7c>
        huart->hdmatx->XferAbortCallback = NULL;
2400e98a:	6fe3      	ldr	r3, [r4, #124]	@ 0x7c
2400e98c:	651d      	str	r5, [r3, #80]	@ 0x50
  uint32_t abortcplt = 1U;
2400e98e:	2601      	movs	r6, #1
  if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
2400e990:	6822      	ldr	r2, [r4, #0]
2400e992:	6893      	ldr	r3, [r2, #8]
2400e994:	065b      	lsls	r3, r3, #25
2400e996:	d549      	bpl.n	2400ea2c <HAL_UART_Abort_IT+0x118>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
2400e998:	f102 0308 	add.w	r3, r2, #8
2400e99c:	e853 3f00 	ldrex	r3, [r3]
    ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
2400e9a0:	f023 0340 	bic.w	r3, r3, #64	@ 0x40
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
2400e9a4:	f102 0108 	add.w	r1, r2, #8
2400e9a8:	e841 3500 	strex	r5, r3, [r1]
2400e9ac:	2d00      	cmp	r5, #0
2400e9ae:	d1f3      	bne.n	2400e998 <HAL_UART_Abort_IT+0x84>
    if (huart->hdmarx != NULL)
2400e9b0:	f8d4 0080 	ldr.w	r0, [r4, #128]	@ 0x80
2400e9b4:	2800      	cmp	r0, #0
2400e9b6:	d039      	beq.n	2400ea2c <HAL_UART_Abort_IT+0x118>
      if (HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
2400e9b8:	f7f3 fad8 	bl	24001f6c <HAL_DMA_Abort_IT>
2400e9bc:	2800      	cmp	r0, #0
2400e9be:	d037      	beq.n	2400ea30 <HAL_UART_Abort_IT+0x11c>
        huart->hdmarx->XferAbortCallback = NULL;
2400e9c0:	f8d4 3080 	ldr.w	r3, [r4, #128]	@ 0x80
2400e9c4:	651d      	str	r5, [r3, #80]	@ 0x50
    huart->TxXferCount = 0U;
2400e9c6:	2300      	movs	r3, #0
    __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF | UART_CLEAR_NEF | UART_CLEAR_PEF | UART_CLEAR_FEF);
2400e9c8:	220f      	movs	r2, #15
    huart->TxXferCount = 0U;
2400e9ca:	f8a4 3056 	strh.w	r3, [r4, #86]	@ 0x56
    huart->RxXferCount = 0U;
2400e9ce:	f8a4 305e 	strh.w	r3, [r4, #94]	@ 0x5e
    huart->ErrorCode = HAL_UART_ERROR_NONE;
2400e9d2:	f8c4 3090 	str.w	r3, [r4, #144]	@ 0x90
    huart->TxISR = NULL;
2400e9d6:	e9c4 331d 	strd	r3, r3, [r4, #116]	@ 0x74
    __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF | UART_CLEAR_NEF | UART_CLEAR_PEF | UART_CLEAR_FEF);
2400e9da:	6823      	ldr	r3, [r4, #0]
2400e9dc:	621a      	str	r2, [r3, #32]
    if (huart->FifoMode == UART_FIFOMODE_ENABLE)
2400e9de:	6e62      	ldr	r2, [r4, #100]	@ 0x64
2400e9e0:	f1b2 5f00 	cmp.w	r2, #536870912	@ 0x20000000
2400e9e4:	d103      	bne.n	2400e9ee <HAL_UART_Abort_IT+0xda>
      __HAL_UART_SEND_REQ(huart, UART_TXDATA_FLUSH_REQUEST);
2400e9e6:	699a      	ldr	r2, [r3, #24]
2400e9e8:	f042 0210 	orr.w	r2, r2, #16
2400e9ec:	619a      	str	r2, [r3, #24]
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
2400e9ee:	699a      	ldr	r2, [r3, #24]
    HAL_UART_AbortCpltCallback(huart);
2400e9f0:	4620      	mov	r0, r4
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
2400e9f2:	f042 0208 	orr.w	r2, r2, #8
2400e9f6:	619a      	str	r2, [r3, #24]
    huart->gState  = HAL_UART_STATE_READY;
2400e9f8:	2320      	movs	r3, #32
2400e9fa:	f8c4 3088 	str.w	r3, [r4, #136]	@ 0x88
    huart->RxState = HAL_UART_STATE_READY;
2400e9fe:	f8c4 308c 	str.w	r3, [r4, #140]	@ 0x8c
    huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
2400ea02:	2300      	movs	r3, #0
2400ea04:	66e3      	str	r3, [r4, #108]	@ 0x6c
    HAL_UART_AbortCpltCallback(huart);
2400ea06:	f7ff ff84 	bl	2400e912 <HAL_UART_AbortCpltCallback>
2400ea0a:	e011      	b.n	2400ea30 <HAL_UART_Abort_IT+0x11c>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
2400ea0c:	e853 2f00 	ldrex	r2, [r3]
    ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_IDLEIE));
2400ea10:	f022 0210 	bic.w	r2, r2, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
2400ea14:	e843 2100 	strex	r1, r2, [r3]
2400ea18:	2900      	cmp	r1, #0
2400ea1a:	d1f7      	bne.n	2400ea0c <HAL_UART_Abort_IT+0xf8>
2400ea1c:	e795      	b.n	2400e94a <HAL_UART_Abort_IT+0x36>
    if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
2400ea1e:	689a      	ldr	r2, [r3, #8]
2400ea20:	f012 0280 	ands.w	r2, r2, #128	@ 0x80
      huart->hdmatx->XferAbortCallback = UART_DMATxAbortCallback;
2400ea24:	bf18      	it	ne
2400ea26:	4a05      	ldrne	r2, [pc, #20]	@ (2400ea3c <HAL_UART_Abort_IT+0x128>)
      huart->hdmatx->XferAbortCallback = NULL;
2400ea28:	6502      	str	r2, [r0, #80]	@ 0x50
2400ea2a:	e791      	b.n	2400e950 <HAL_UART_Abort_IT+0x3c>
  if (abortcplt == 1U)
2400ea2c:	2e01      	cmp	r6, #1
2400ea2e:	d0ca      	beq.n	2400e9c6 <HAL_UART_Abort_IT+0xb2>
}
2400ea30:	2000      	movs	r0, #0
2400ea32:	bd70      	pop	{r4, r5, r6, pc}
2400ea34:	ef7ffffe 	.word	0xef7ffffe
2400ea38:	2400ea41 	.word	0x2400ea41
2400ea3c:	2400ea81 	.word	0x2400ea81

2400ea40 <UART_DMARxAbortCallback>:
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);
2400ea40:	6b80      	ldr	r0, [r0, #56]	@ 0x38
{
2400ea42:	b508      	push	{r3, lr}
  huart->hdmarx->XferAbortCallback = NULL;
2400ea44:	f8d0 2080 	ldr.w	r2, [r0, #128]	@ 0x80
2400ea48:	2300      	movs	r3, #0
2400ea4a:	6513      	str	r3, [r2, #80]	@ 0x50
  if (huart->hdmatx != NULL)
2400ea4c:	6fc2      	ldr	r2, [r0, #124]	@ 0x7c
2400ea4e:	b10a      	cbz	r2, 2400ea54 <UART_DMARxAbortCallback+0x14>
    if (huart->hdmatx->XferAbortCallback != NULL)
2400ea50:	6d12      	ldr	r2, [r2, #80]	@ 0x50
2400ea52:	b9a2      	cbnz	r2, 2400ea7e <UART_DMARxAbortCallback+0x3e>
  __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF | UART_CLEAR_NEF | UART_CLEAR_PEF | UART_CLEAR_FEF);
2400ea54:	6802      	ldr	r2, [r0, #0]
2400ea56:	210f      	movs	r1, #15
  huart->TxXferCount = 0U;
2400ea58:	f8a0 3056 	strh.w	r3, [r0, #86]	@ 0x56
  huart->RxXferCount = 0U;
2400ea5c:	f8a0 305e 	strh.w	r3, [r0, #94]	@ 0x5e
  huart->ErrorCode = HAL_UART_ERROR_NONE;
2400ea60:	f8c0 3090 	str.w	r3, [r0, #144]	@ 0x90
  __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF | UART_CLEAR_NEF | UART_CLEAR_PEF | UART_CLEAR_FEF);
2400ea64:	6211      	str	r1, [r2, #32]
  __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
2400ea66:	6991      	ldr	r1, [r2, #24]
2400ea68:	f041 0108 	orr.w	r1, r1, #8
2400ea6c:	6191      	str	r1, [r2, #24]
  huart->gState  = HAL_UART_STATE_READY;
2400ea6e:	2220      	movs	r2, #32
2400ea70:	f8c0 2088 	str.w	r2, [r0, #136]	@ 0x88
  huart->RxState = HAL_UART_STATE_READY;
2400ea74:	f8c0 208c 	str.w	r2, [r0, #140]	@ 0x8c
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
2400ea78:	66c3      	str	r3, [r0, #108]	@ 0x6c
  HAL_UART_AbortCpltCallback(huart);
2400ea7a:	f7ff ff4a 	bl	2400e912 <HAL_UART_AbortCpltCallback>
}
2400ea7e:	bd08      	pop	{r3, pc}

2400ea80 <UART_DMATxAbortCallback>:
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);
2400ea80:	6b80      	ldr	r0, [r0, #56]	@ 0x38
{
2400ea82:	b508      	push	{r3, lr}
  huart->hdmatx->XferAbortCallback = NULL;
2400ea84:	6fc2      	ldr	r2, [r0, #124]	@ 0x7c
2400ea86:	2300      	movs	r3, #0
2400ea88:	6513      	str	r3, [r2, #80]	@ 0x50
  if (huart->hdmarx != NULL)
2400ea8a:	f8d0 2080 	ldr.w	r2, [r0, #128]	@ 0x80
2400ea8e:	b10a      	cbz	r2, 2400ea94 <UART_DMATxAbortCallback+0x14>
    if (huart->hdmarx->XferAbortCallback != NULL)
2400ea90:	6d12      	ldr	r2, [r2, #80]	@ 0x50
2400ea92:	b9ca      	cbnz	r2, 2400eac8 <UART_DMATxAbortCallback+0x48>
  huart->TxXferCount = 0U;
2400ea94:	f8a0 3056 	strh.w	r3, [r0, #86]	@ 0x56
  __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF | UART_CLEAR_NEF | UART_CLEAR_PEF | UART_CLEAR_FEF);
2400ea98:	220f      	movs	r2, #15
  huart->RxXferCount = 0U;
2400ea9a:	f8a0 305e 	strh.w	r3, [r0, #94]	@ 0x5e
  huart->ErrorCode = HAL_UART_ERROR_NONE;
2400ea9e:	f8c0 3090 	str.w	r3, [r0, #144]	@ 0x90
  __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF | UART_CLEAR_NEF | UART_CLEAR_PEF | UART_CLEAR_FEF);
2400eaa2:	6803      	ldr	r3, [r0, #0]
2400eaa4:	621a      	str	r2, [r3, #32]
  if (huart->FifoMode == UART_FIFOMODE_ENABLE)
2400eaa6:	6e42      	ldr	r2, [r0, #100]	@ 0x64
2400eaa8:	f1b2 5f00 	cmp.w	r2, #536870912	@ 0x20000000
2400eaac:	d103      	bne.n	2400eab6 <UART_DMATxAbortCallback+0x36>
    __HAL_UART_SEND_REQ(huart, UART_TXDATA_FLUSH_REQUEST);
2400eaae:	699a      	ldr	r2, [r3, #24]
2400eab0:	f042 0210 	orr.w	r2, r2, #16
2400eab4:	619a      	str	r2, [r3, #24]
  huart->gState  = HAL_UART_STATE_READY;
2400eab6:	2320      	movs	r3, #32
2400eab8:	f8c0 3088 	str.w	r3, [r0, #136]	@ 0x88
  huart->RxState = HAL_UART_STATE_READY;
2400eabc:	f8c0 308c 	str.w	r3, [r0, #140]	@ 0x8c
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
2400eac0:	2300      	movs	r3, #0
2400eac2:	66c3      	str	r3, [r0, #108]	@ 0x6c
  HAL_UART_AbortCpltCallback(huart);
2400eac4:	f7ff ff25 	bl	2400e912 <HAL_UART_AbortCpltCallback>
}
2400eac8:	bd08      	pop	{r3, pc}

2400eaca <HAL_UART_AbortTransmitCpltCallback>:
__weak void HAL_UART_AbortTransmitCpltCallback(UART_HandleTypeDef *huart)
2400eaca:	4770      	bx	lr

2400eacc <HAL_UART_AbortTransmit_IT>:
{
2400eacc:	b510      	push	{r4, lr}
2400eace:	4604      	mov	r4, r0
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TCIE | USART_CR1_TXEIE_TXFNFIE));
2400ead0:	6822      	ldr	r2, [r4, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
2400ead2:	e852 3f00 	ldrex	r3, [r2]
2400ead6:	f023 03c0 	bic.w	r3, r3, #192	@ 0xc0
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
2400eada:	e842 3100 	strex	r1, r3, [r2]
   return(result);
2400eade:	6823      	ldr	r3, [r4, #0]
2400eae0:	2900      	cmp	r1, #0
2400eae2:	d1f5      	bne.n	2400ead0 <HAL_UART_AbortTransmit_IT+0x4>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
2400eae4:	f103 0208 	add.w	r2, r3, #8
2400eae8:	e852 2f00 	ldrex	r2, [r2]
  ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_TXFTIE);
2400eaec:	f422 0200 	bic.w	r2, r2, #8388608	@ 0x800000
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
2400eaf0:	f103 0008 	add.w	r0, r3, #8
2400eaf4:	e840 2100 	strex	r1, r2, [r0]
2400eaf8:	2900      	cmp	r1, #0
2400eafa:	d1f3      	bne.n	2400eae4 <HAL_UART_AbortTransmit_IT+0x18>
  if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
2400eafc:	689a      	ldr	r2, [r3, #8]
2400eafe:	f012 0280 	ands.w	r2, r2, #128	@ 0x80
2400eb02:	d021      	beq.n	2400eb48 <HAL_UART_AbortTransmit_IT+0x7c>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
2400eb04:	f103 0208 	add.w	r2, r3, #8
2400eb08:	e852 2f00 	ldrex	r2, [r2]
    ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
2400eb0c:	f022 0280 	bic.w	r2, r2, #128	@ 0x80
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
2400eb10:	f103 0008 	add.w	r0, r3, #8
2400eb14:	e840 2100 	strex	r1, r2, [r0]
2400eb18:	2900      	cmp	r1, #0
2400eb1a:	d1f3      	bne.n	2400eb04 <HAL_UART_AbortTransmit_IT+0x38>
    if (huart->hdmatx != NULL)
2400eb1c:	6fe0      	ldr	r0, [r4, #124]	@ 0x7c
2400eb1e:	b148      	cbz	r0, 2400eb34 <HAL_UART_AbortTransmit_IT+0x68>
      huart->hdmatx->XferAbortCallback = UART_DMATxOnlyAbortCallback;
2400eb20:	4b0f      	ldr	r3, [pc, #60]	@ (2400eb60 <HAL_UART_AbortTransmit_IT+0x94>)
2400eb22:	6503      	str	r3, [r0, #80]	@ 0x50
      if (HAL_DMA_Abort_IT(huart->hdmatx) != HAL_OK)
2400eb24:	f7f3 fa22 	bl	24001f6c <HAL_DMA_Abort_IT>
2400eb28:	b110      	cbz	r0, 2400eb30 <HAL_UART_AbortTransmit_IT+0x64>
        huart->hdmatx->XferAbortCallback(huart->hdmatx);
2400eb2a:	6fe0      	ldr	r0, [r4, #124]	@ 0x7c
2400eb2c:	6d03      	ldr	r3, [r0, #80]	@ 0x50
2400eb2e:	4798      	blx	r3
}
2400eb30:	2000      	movs	r0, #0
2400eb32:	bd10      	pop	{r4, pc}
      huart->TxXferCount = 0U;
2400eb34:	f8a4 0056 	strh.w	r0, [r4, #86]	@ 0x56
      huart->TxISR = NULL;
2400eb38:	67a0      	str	r0, [r4, #120]	@ 0x78
    huart->gState = HAL_UART_STATE_READY;
2400eb3a:	2320      	movs	r3, #32
    HAL_UART_AbortTransmitCpltCallback(huart);
2400eb3c:	4620      	mov	r0, r4
    huart->gState = HAL_UART_STATE_READY;
2400eb3e:	f8c4 3088 	str.w	r3, [r4, #136]	@ 0x88
    HAL_UART_AbortTransmitCpltCallback(huart);
2400eb42:	f7ff ffc2 	bl	2400eaca <HAL_UART_AbortTransmitCpltCallback>
2400eb46:	e7f3      	b.n	2400eb30 <HAL_UART_AbortTransmit_IT+0x64>
    huart->TxXferCount = 0U;
2400eb48:	f8a4 2056 	strh.w	r2, [r4, #86]	@ 0x56
    huart->TxISR = NULL;
2400eb4c:	67a2      	str	r2, [r4, #120]	@ 0x78
    if (huart->FifoMode == UART_FIFOMODE_ENABLE)
2400eb4e:	6e62      	ldr	r2, [r4, #100]	@ 0x64
2400eb50:	f1b2 5f00 	cmp.w	r2, #536870912	@ 0x20000000
2400eb54:	d1f1      	bne.n	2400eb3a <HAL_UART_AbortTransmit_IT+0x6e>
      __HAL_UART_SEND_REQ(huart, UART_TXDATA_FLUSH_REQUEST);
2400eb56:	699a      	ldr	r2, [r3, #24]
2400eb58:	f042 0210 	orr.w	r2, r2, #16
2400eb5c:	619a      	str	r2, [r3, #24]
2400eb5e:	e7ec      	b.n	2400eb3a <HAL_UART_AbortTransmit_IT+0x6e>
2400eb60:	2400eb65 	.word	0x2400eb65

2400eb64 <UART_DMATxOnlyAbortCallback>:
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);
2400eb64:	6b80      	ldr	r0, [r0, #56]	@ 0x38
{
2400eb66:	b508      	push	{r3, lr}
  huart->TxXferCount = 0U;
2400eb68:	2300      	movs	r3, #0
2400eb6a:	f8a0 3056 	strh.w	r3, [r0, #86]	@ 0x56
  if (huart->FifoMode == UART_FIFOMODE_ENABLE)
2400eb6e:	6e43      	ldr	r3, [r0, #100]	@ 0x64
2400eb70:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
2400eb74:	d104      	bne.n	2400eb80 <UART_DMATxOnlyAbortCallback+0x1c>
    __HAL_UART_SEND_REQ(huart, UART_TXDATA_FLUSH_REQUEST);
2400eb76:	6802      	ldr	r2, [r0, #0]
2400eb78:	6993      	ldr	r3, [r2, #24]
2400eb7a:	f043 0310 	orr.w	r3, r3, #16
2400eb7e:	6193      	str	r3, [r2, #24]
  huart->gState = HAL_UART_STATE_READY;
2400eb80:	2320      	movs	r3, #32
2400eb82:	f8c0 3088 	str.w	r3, [r0, #136]	@ 0x88
  HAL_UART_AbortTransmitCpltCallback(huart);
2400eb86:	f7ff ffa0 	bl	2400eaca <HAL_UART_AbortTransmitCpltCallback>
}
2400eb8a:	bd08      	pop	{r3, pc}

2400eb8c <HAL_UART_AbortReceiveCpltCallback>:
__weak void HAL_UART_AbortReceiveCpltCallback(UART_HandleTypeDef *huart)
2400eb8c:	4770      	bx	lr

2400eb8e <HAL_UART_AbortReceive_IT>:
{
2400eb8e:	b510      	push	{r4, lr}
2400eb90:	4604      	mov	r4, r0
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_PEIE | USART_CR1_RXNEIE_RXFNEIE));
2400eb92:	6822      	ldr	r2, [r4, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
2400eb94:	e852 3f00 	ldrex	r3, [r2]
2400eb98:	f423 7390 	bic.w	r3, r3, #288	@ 0x120
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
2400eb9c:	e842 3100 	strex	r1, r3, [r2]
   return(result);
2400eba0:	6823      	ldr	r3, [r4, #0]
2400eba2:	2900      	cmp	r1, #0
2400eba4:	d1f5      	bne.n	2400eb92 <HAL_UART_AbortReceive_IT+0x4>
  ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
2400eba6:	4828      	ldr	r0, [pc, #160]	@ (2400ec48 <HAL_UART_AbortReceive_IT+0xba>)
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
2400eba8:	f103 0208 	add.w	r2, r3, #8
2400ebac:	e852 2f00 	ldrex	r2, [r2]
2400ebb0:	4002      	ands	r2, r0
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
2400ebb2:	f103 0c08 	add.w	ip, r3, #8
2400ebb6:	e84c 2100 	strex	r1, r2, [ip]
2400ebba:	2900      	cmp	r1, #0
2400ebbc:	d1f4      	bne.n	2400eba8 <HAL_UART_AbortReceive_IT+0x1a>
  if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
2400ebbe:	6ee2      	ldr	r2, [r4, #108]	@ 0x6c
2400ebc0:	2a01      	cmp	r2, #1
2400ebc2:	d107      	bne.n	2400ebd4 <HAL_UART_AbortReceive_IT+0x46>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
2400ebc4:	e853 2f00 	ldrex	r2, [r3]
    ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_IDLEIE));
2400ebc8:	f022 0210 	bic.w	r2, r2, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
2400ebcc:	e843 2100 	strex	r1, r2, [r3]
2400ebd0:	2900      	cmp	r1, #0
2400ebd2:	d1f7      	bne.n	2400ebc4 <HAL_UART_AbortReceive_IT+0x36>
  if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
2400ebd4:	689a      	ldr	r2, [r3, #8]
2400ebd6:	f012 0240 	ands.w	r2, r2, #64	@ 0x40
2400ebda:	d02a      	beq.n	2400ec32 <HAL_UART_AbortReceive_IT+0xa4>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
2400ebdc:	f103 0208 	add.w	r2, r3, #8
2400ebe0:	e852 2f00 	ldrex	r2, [r2]
    ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
2400ebe4:	f022 0240 	bic.w	r2, r2, #64	@ 0x40
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
2400ebe8:	f103 0008 	add.w	r0, r3, #8
2400ebec:	e840 2100 	strex	r1, r2, [r0]
2400ebf0:	2900      	cmp	r1, #0
2400ebf2:	d1f3      	bne.n	2400ebdc <HAL_UART_AbortReceive_IT+0x4e>
    if (huart->hdmarx != NULL)
2400ebf4:	f8d4 0080 	ldr.w	r0, [r4, #128]	@ 0x80
2400ebf8:	b150      	cbz	r0, 2400ec10 <HAL_UART_AbortReceive_IT+0x82>
      huart->hdmarx->XferAbortCallback = UART_DMARxOnlyAbortCallback;
2400ebfa:	4b14      	ldr	r3, [pc, #80]	@ (2400ec4c <HAL_UART_AbortReceive_IT+0xbe>)
2400ebfc:	6503      	str	r3, [r0, #80]	@ 0x50
      if (HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
2400ebfe:	f7f3 f9b5 	bl	24001f6c <HAL_DMA_Abort_IT>
2400ec02:	b118      	cbz	r0, 2400ec0c <HAL_UART_AbortReceive_IT+0x7e>
        huart->hdmarx->XferAbortCallback(huart->hdmarx);
2400ec04:	f8d4 0080 	ldr.w	r0, [r4, #128]	@ 0x80
2400ec08:	6d03      	ldr	r3, [r0, #80]	@ 0x50
2400ec0a:	4798      	blx	r3
}
2400ec0c:	2000      	movs	r0, #0
2400ec0e:	bd10      	pop	{r4, pc}
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF | UART_CLEAR_NEF | UART_CLEAR_PEF | UART_CLEAR_FEF);
2400ec10:	220f      	movs	r2, #15
      huart->RxXferCount = 0U;
2400ec12:	f8a4 005e 	strh.w	r0, [r4, #94]	@ 0x5e
      huart->pRxBuffPtr = NULL;
2400ec16:	65a0      	str	r0, [r4, #88]	@ 0x58
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF | UART_CLEAR_NEF | UART_CLEAR_PEF | UART_CLEAR_FEF);
2400ec18:	621a      	str	r2, [r3, #32]
      __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
2400ec1a:	699a      	ldr	r2, [r3, #24]
2400ec1c:	f042 0208 	orr.w	r2, r2, #8
2400ec20:	619a      	str	r2, [r3, #24]
      huart->RxState = HAL_UART_STATE_READY;
2400ec22:	2320      	movs	r3, #32
2400ec24:	f8c4 308c 	str.w	r3, [r4, #140]	@ 0x8c
      huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
2400ec28:	66e0      	str	r0, [r4, #108]	@ 0x6c
    HAL_UART_AbortReceiveCpltCallback(huart);
2400ec2a:	4620      	mov	r0, r4
2400ec2c:	f7ff ffae 	bl	2400eb8c <HAL_UART_AbortReceiveCpltCallback>
2400ec30:	e7ec      	b.n	2400ec0c <HAL_UART_AbortReceive_IT+0x7e>
    __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF | UART_CLEAR_NEF | UART_CLEAR_PEF | UART_CLEAR_FEF);
2400ec32:	210f      	movs	r1, #15
    huart->RxXferCount = 0U;
2400ec34:	f8a4 205e 	strh.w	r2, [r4, #94]	@ 0x5e
    huart->pRxBuffPtr = NULL;
2400ec38:	65a2      	str	r2, [r4, #88]	@ 0x58
    __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF | UART_CLEAR_NEF | UART_CLEAR_PEF | UART_CLEAR_FEF);
2400ec3a:	6219      	str	r1, [r3, #32]
    huart->RxState = HAL_UART_STATE_READY;
2400ec3c:	2320      	movs	r3, #32
2400ec3e:	f8c4 308c 	str.w	r3, [r4, #140]	@ 0x8c
    huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
2400ec42:	66e2      	str	r2, [r4, #108]	@ 0x6c
2400ec44:	e7f1      	b.n	2400ec2a <HAL_UART_AbortReceive_IT+0x9c>
2400ec46:	bf00      	nop
2400ec48:	effffffe 	.word	0xeffffffe
2400ec4c:	2400ec51 	.word	0x2400ec51

2400ec50 <UART_DMARxOnlyAbortCallback>:
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
2400ec50:	6b80      	ldr	r0, [r0, #56]	@ 0x38
  huart->RxXferCount = 0U;
2400ec52:	2100      	movs	r1, #0
  __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF | UART_CLEAR_NEF | UART_CLEAR_PEF | UART_CLEAR_FEF);
2400ec54:	220f      	movs	r2, #15
{
2400ec56:	b508      	push	{r3, lr}
  __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF | UART_CLEAR_NEF | UART_CLEAR_PEF | UART_CLEAR_FEF);
2400ec58:	6803      	ldr	r3, [r0, #0]
  huart->RxXferCount = 0U;
2400ec5a:	f8a0 105e 	strh.w	r1, [r0, #94]	@ 0x5e
  __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF | UART_CLEAR_NEF | UART_CLEAR_PEF | UART_CLEAR_FEF);
2400ec5e:	621a      	str	r2, [r3, #32]
  __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
2400ec60:	699a      	ldr	r2, [r3, #24]
2400ec62:	f042 0208 	orr.w	r2, r2, #8
2400ec66:	619a      	str	r2, [r3, #24]
  huart->RxState = HAL_UART_STATE_READY;
2400ec68:	2320      	movs	r3, #32
2400ec6a:	f8c0 308c 	str.w	r3, [r0, #140]	@ 0x8c
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
2400ec6e:	66c1      	str	r1, [r0, #108]	@ 0x6c
  HAL_UART_AbortReceiveCpltCallback(huart);
2400ec70:	f7ff ff8c 	bl	2400eb8c <HAL_UART_AbortReceiveCpltCallback>
}
2400ec74:	bd08      	pop	{r3, pc}

2400ec76 <HAL_UARTEx_RxEventCallback>:
}
2400ec76:	4770      	bx	lr

2400ec78 <HAL_UART_IRQHandler>:
  uint32_t isrflags   = READ_REG(huart->Instance->ISR);
2400ec78:	6803      	ldr	r3, [r0, #0]
{
2400ec7a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint32_t isrflags   = READ_REG(huart->Instance->ISR);
2400ec7e:	69d9      	ldr	r1, [r3, #28]
  if (errorflags == 0U)
2400ec80:	f640 060f 	movw	r6, #2063	@ 0x80f
  uint32_t cr1its     = READ_REG(huart->Instance->CR1);
2400ec84:	681a      	ldr	r2, [r3, #0]
{
2400ec86:	4604      	mov	r4, r0
  if (errorflags == 0U)
2400ec88:	4231      	tst	r1, r6
  uint32_t cr3its     = READ_REG(huart->Instance->CR3);
2400ec8a:	689d      	ldr	r5, [r3, #8]
  if (errorflags == 0U)
2400ec8c:	d110      	bne.n	2400ecb0 <HAL_UART_IRQHandler+0x38>
    if (((isrflags & USART_ISR_RXNE_RXFNE) != 0U)
2400ec8e:	068e      	lsls	r6, r1, #26
2400ec90:	f140 8097 	bpl.w	2400edc2 <HAL_UART_IRQHandler+0x14a>
        && (((cr1its & USART_CR1_RXNEIE_RXFNEIE) != 0U)
2400ec94:	f002 0620 	and.w	r6, r2, #32
            || ((cr3its & USART_CR3_RXFTIE) != 0U)))
2400ec98:	f005 5780 	and.w	r7, r5, #268435456	@ 0x10000000
2400ec9c:	433e      	orrs	r6, r7
2400ec9e:	f000 8090 	beq.w	2400edc2 <HAL_UART_IRQHandler+0x14a>
      if (huart->RxISR != NULL)
2400eca2:	6f43      	ldr	r3, [r0, #116]	@ 0x74
2400eca4:	2b00      	cmp	r3, #0
2400eca6:	f000 8085 	beq.w	2400edb4 <HAL_UART_IRQHandler+0x13c>
}
2400ecaa:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
              huart->hdmarx->XferAbortCallback(huart->hdmarx);
2400ecae:	4718      	bx	r3
      && ((((cr3its & (USART_CR3_RXFTIE | USART_CR3_EIE)) != 0U)
2400ecb0:	4eaa      	ldr	r6, [pc, #680]	@ (2400ef5c <HAL_UART_IRQHandler+0x2e4>)
           || ((cr1its & (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE | USART_CR1_RTOIE)) != 0U))))
2400ecb2:	48ab      	ldr	r0, [pc, #684]	@ (2400ef60 <HAL_UART_IRQHandler+0x2e8>)
      && ((((cr3its & (USART_CR3_RXFTIE | USART_CR3_EIE)) != 0U)
2400ecb4:	402e      	ands	r6, r5
           || ((cr1its & (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE | USART_CR1_RTOIE)) != 0U))))
2400ecb6:	4010      	ands	r0, r2
2400ecb8:	4330      	orrs	r0, r6
2400ecba:	f000 8082 	beq.w	2400edc2 <HAL_UART_IRQHandler+0x14a>
    if (((isrflags & USART_ISR_PE) != 0U) && ((cr1its & USART_CR1_PEIE) != 0U))
2400ecbe:	07cf      	lsls	r7, r1, #31
2400ecc0:	d509      	bpl.n	2400ecd6 <HAL_UART_IRQHandler+0x5e>
2400ecc2:	05d0      	lsls	r0, r2, #23
2400ecc4:	d507      	bpl.n	2400ecd6 <HAL_UART_IRQHandler+0x5e>
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_PEF);
2400ecc6:	2001      	movs	r0, #1
2400ecc8:	6218      	str	r0, [r3, #32]
      huart->ErrorCode |= HAL_UART_ERROR_PE;
2400ecca:	f8d4 0090 	ldr.w	r0, [r4, #144]	@ 0x90
2400ecce:	f040 0001 	orr.w	r0, r0, #1
2400ecd2:	f8c4 0090 	str.w	r0, [r4, #144]	@ 0x90
    if (((isrflags & USART_ISR_FE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
2400ecd6:	078f      	lsls	r7, r1, #30
2400ecd8:	d509      	bpl.n	2400ecee <HAL_UART_IRQHandler+0x76>
2400ecda:	07e8      	lsls	r0, r5, #31
2400ecdc:	d507      	bpl.n	2400ecee <HAL_UART_IRQHandler+0x76>
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_FEF);
2400ecde:	2002      	movs	r0, #2
2400ece0:	6218      	str	r0, [r3, #32]
      huart->ErrorCode |= HAL_UART_ERROR_FE;
2400ece2:	f8d4 0090 	ldr.w	r0, [r4, #144]	@ 0x90
2400ece6:	f040 0004 	orr.w	r0, r0, #4
2400ecea:	f8c4 0090 	str.w	r0, [r4, #144]	@ 0x90
    if (((isrflags & USART_ISR_NE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
2400ecee:	074f      	lsls	r7, r1, #29
2400ecf0:	d509      	bpl.n	2400ed06 <HAL_UART_IRQHandler+0x8e>
2400ecf2:	07e8      	lsls	r0, r5, #31
2400ecf4:	d507      	bpl.n	2400ed06 <HAL_UART_IRQHandler+0x8e>
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_NEF);
2400ecf6:	2004      	movs	r0, #4
2400ecf8:	6218      	str	r0, [r3, #32]
      huart->ErrorCode |= HAL_UART_ERROR_NE;
2400ecfa:	f8d4 0090 	ldr.w	r0, [r4, #144]	@ 0x90
2400ecfe:	f040 0002 	orr.w	r0, r0, #2
2400ed02:	f8c4 0090 	str.w	r0, [r4, #144]	@ 0x90
    if (((isrflags & USART_ISR_ORE) != 0U)
2400ed06:	070f      	lsls	r7, r1, #28
2400ed08:	d50b      	bpl.n	2400ed22 <HAL_UART_IRQHandler+0xaa>
        && (((cr1its & USART_CR1_RXNEIE_RXFNEIE) != 0U) ||
2400ed0a:	f002 0020 	and.w	r0, r2, #32
2400ed0e:	4330      	orrs	r0, r6
2400ed10:	d007      	beq.n	2400ed22 <HAL_UART_IRQHandler+0xaa>
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF);
2400ed12:	2008      	movs	r0, #8
2400ed14:	6218      	str	r0, [r3, #32]
      huart->ErrorCode |= HAL_UART_ERROR_ORE;
2400ed16:	f8d4 0090 	ldr.w	r0, [r4, #144]	@ 0x90
2400ed1a:	f040 0008 	orr.w	r0, r0, #8
2400ed1e:	f8c4 0090 	str.w	r0, [r4, #144]	@ 0x90
    if (((isrflags & USART_ISR_RTOF) != 0U) && ((cr1its & USART_CR1_RTOIE) != 0U))
2400ed22:	050e      	lsls	r6, r1, #20
2400ed24:	d50a      	bpl.n	2400ed3c <HAL_UART_IRQHandler+0xc4>
2400ed26:	0150      	lsls	r0, r2, #5
2400ed28:	d508      	bpl.n	2400ed3c <HAL_UART_IRQHandler+0xc4>
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
2400ed2a:	f44f 6000 	mov.w	r0, #2048	@ 0x800
2400ed2e:	6218      	str	r0, [r3, #32]
      huart->ErrorCode |= HAL_UART_ERROR_RTO;
2400ed30:	f8d4 3090 	ldr.w	r3, [r4, #144]	@ 0x90
2400ed34:	f043 0320 	orr.w	r3, r3, #32
2400ed38:	f8c4 3090 	str.w	r3, [r4, #144]	@ 0x90
    if (huart->ErrorCode != HAL_UART_ERROR_NONE)
2400ed3c:	f8d4 3090 	ldr.w	r3, [r4, #144]	@ 0x90
2400ed40:	2b00      	cmp	r3, #0
2400ed42:	d037      	beq.n	2400edb4 <HAL_UART_IRQHandler+0x13c>
      if (((isrflags & USART_ISR_RXNE_RXFNE) != 0U)
2400ed44:	068b      	lsls	r3, r1, #26
2400ed46:	d509      	bpl.n	2400ed5c <HAL_UART_IRQHandler+0xe4>
          && (((cr1its & USART_CR1_RXNEIE_RXFNEIE) != 0U)
2400ed48:	f002 0220 	and.w	r2, r2, #32
              || ((cr3its & USART_CR3_RXFTIE) != 0U)))
2400ed4c:	f005 5580 	and.w	r5, r5, #268435456	@ 0x10000000
2400ed50:	432a      	orrs	r2, r5
2400ed52:	d003      	beq.n	2400ed5c <HAL_UART_IRQHandler+0xe4>
        if (huart->RxISR != NULL)
2400ed54:	6f63      	ldr	r3, [r4, #116]	@ 0x74
2400ed56:	b10b      	cbz	r3, 2400ed5c <HAL_UART_IRQHandler+0xe4>
          huart->RxISR(huart);
2400ed58:	4620      	mov	r0, r4
2400ed5a:	4798      	blx	r3
      if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) ||
2400ed5c:	6826      	ldr	r6, [r4, #0]
        UART_EndRxTransfer(huart);
2400ed5e:	4620      	mov	r0, r4
      errorcode = huart->ErrorCode;
2400ed60:	f8d4 2090 	ldr.w	r2, [r4, #144]	@ 0x90
      if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) ||
2400ed64:	68b3      	ldr	r3, [r6, #8]
          ((errorcode & (HAL_UART_ERROR_RTO | HAL_UART_ERROR_ORE)) != 0U))
2400ed66:	f002 0228 	and.w	r2, r2, #40	@ 0x28
      if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) ||
2400ed6a:	f003 0340 	and.w	r3, r3, #64	@ 0x40
2400ed6e:	ea53 0502 	orrs.w	r5, r3, r2
2400ed72:	d021      	beq.n	2400edb8 <HAL_UART_IRQHandler+0x140>
        UART_EndRxTransfer(huart);
2400ed74:	f7ff f9fe 	bl	2400e174 <UART_EndRxTransfer>
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
2400ed78:	68b3      	ldr	r3, [r6, #8]
2400ed7a:	065f      	lsls	r7, r3, #25
2400ed7c:	d517      	bpl.n	2400edae <HAL_UART_IRQHandler+0x136>
          ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
2400ed7e:	6822      	ldr	r2, [r4, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
2400ed80:	f102 0308 	add.w	r3, r2, #8
2400ed84:	e853 3f00 	ldrex	r3, [r3]
2400ed88:	f023 0340 	bic.w	r3, r3, #64	@ 0x40
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
2400ed8c:	3208      	adds	r2, #8
2400ed8e:	e842 3100 	strex	r1, r3, [r2]
2400ed92:	2900      	cmp	r1, #0
2400ed94:	d1f3      	bne.n	2400ed7e <HAL_UART_IRQHandler+0x106>
          if (huart->hdmarx != NULL)
2400ed96:	f8d4 0080 	ldr.w	r0, [r4, #128]	@ 0x80
2400ed9a:	b140      	cbz	r0, 2400edae <HAL_UART_IRQHandler+0x136>
            huart->hdmarx->XferAbortCallback = UART_DMAAbortOnError;
2400ed9c:	4b71      	ldr	r3, [pc, #452]	@ (2400ef64 <HAL_UART_IRQHandler+0x2ec>)
2400ed9e:	6503      	str	r3, [r0, #80]	@ 0x50
            if (HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
2400eda0:	f7f3 f8e4 	bl	24001f6c <HAL_DMA_Abort_IT>
2400eda4:	b130      	cbz	r0, 2400edb4 <HAL_UART_IRQHandler+0x13c>
              huart->hdmarx->XferAbortCallback(huart->hdmarx);
2400eda6:	f8d4 0080 	ldr.w	r0, [r4, #128]	@ 0x80
2400edaa:	6d03      	ldr	r3, [r0, #80]	@ 0x50
2400edac:	e77d      	b.n	2400ecaa <HAL_UART_IRQHandler+0x32>
            HAL_UART_ErrorCallback(huart);
2400edae:	4620      	mov	r0, r4
2400edb0:	f7ff fd80 	bl	2400e8b4 <HAL_UART_ErrorCallback>
}
2400edb4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        HAL_UART_ErrorCallback(huart);
2400edb8:	f7ff fd7c 	bl	2400e8b4 <HAL_UART_ErrorCallback>
        huart->ErrorCode = HAL_UART_ERROR_NONE;
2400edbc:	f8c4 5090 	str.w	r5, [r4, #144]	@ 0x90
2400edc0:	e7f8      	b.n	2400edb4 <HAL_UART_IRQHandler+0x13c>
  if ((huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
2400edc2:	6ee0      	ldr	r0, [r4, #108]	@ 0x6c
2400edc4:	2801      	cmp	r0, #1
2400edc6:	f040 80ae 	bne.w	2400ef26 <HAL_UART_IRQHandler+0x2ae>
      && ((isrflags & USART_ISR_IDLE) != 0U)
2400edca:	06ce      	lsls	r6, r1, #27
2400edcc:	f140 80ab 	bpl.w	2400ef26 <HAL_UART_IRQHandler+0x2ae>
      && ((cr1its & USART_ISR_IDLE) != 0U))
2400edd0:	06d0      	lsls	r0, r2, #27
2400edd2:	f140 80a8 	bpl.w	2400ef26 <HAL_UART_IRQHandler+0x2ae>
    __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_IDLEF);
2400edd6:	2210      	movs	r2, #16
2400edd8:	621a      	str	r2, [r3, #32]
    if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
2400edda:	689a      	ldr	r2, [r3, #8]
2400eddc:	0652      	lsls	r2, r2, #25
2400edde:	d56e      	bpl.n	2400eebe <HAL_UART_IRQHandler+0x246>
      uint16_t nb_remaining_rx_data = (uint16_t) __HAL_DMA_GET_COUNTER(huart->hdmarx);
2400ede0:	f8d4 1080 	ldr.w	r1, [r4, #128]	@ 0x80
2400ede4:	4860      	ldr	r0, [pc, #384]	@ (2400ef68 <HAL_UART_IRQHandler+0x2f0>)
2400ede6:	680a      	ldr	r2, [r1, #0]
2400ede8:	4282      	cmp	r2, r0
2400edea:	d01e      	beq.n	2400ee2a <HAL_UART_IRQHandler+0x1b2>
2400edec:	3018      	adds	r0, #24
2400edee:	4282      	cmp	r2, r0
2400edf0:	d01b      	beq.n	2400ee2a <HAL_UART_IRQHandler+0x1b2>
2400edf2:	3018      	adds	r0, #24
2400edf4:	4282      	cmp	r2, r0
2400edf6:	d018      	beq.n	2400ee2a <HAL_UART_IRQHandler+0x1b2>
2400edf8:	3018      	adds	r0, #24
2400edfa:	4282      	cmp	r2, r0
2400edfc:	d015      	beq.n	2400ee2a <HAL_UART_IRQHandler+0x1b2>
2400edfe:	3018      	adds	r0, #24
2400ee00:	4282      	cmp	r2, r0
2400ee02:	d012      	beq.n	2400ee2a <HAL_UART_IRQHandler+0x1b2>
2400ee04:	3018      	adds	r0, #24
2400ee06:	4282      	cmp	r2, r0
2400ee08:	d00f      	beq.n	2400ee2a <HAL_UART_IRQHandler+0x1b2>
2400ee0a:	3018      	adds	r0, #24
2400ee0c:	4282      	cmp	r2, r0
2400ee0e:	d00c      	beq.n	2400ee2a <HAL_UART_IRQHandler+0x1b2>
2400ee10:	3018      	adds	r0, #24
2400ee12:	4282      	cmp	r2, r0
2400ee14:	d009      	beq.n	2400ee2a <HAL_UART_IRQHandler+0x1b2>
2400ee16:	f500 7056 	add.w	r0, r0, #856	@ 0x358
2400ee1a:	4282      	cmp	r2, r0
2400ee1c:	d005      	beq.n	2400ee2a <HAL_UART_IRQHandler+0x1b2>
2400ee1e:	3018      	adds	r0, #24
2400ee20:	4282      	cmp	r2, r0
2400ee22:	d002      	beq.n	2400ee2a <HAL_UART_IRQHandler+0x1b2>
2400ee24:	3018      	adds	r0, #24
2400ee26:	4282      	cmp	r2, r0
2400ee28:	d0ff      	beq.n	2400ee2a <HAL_UART_IRQHandler+0x1b2>
2400ee2a:	6852      	ldr	r2, [r2, #4]
2400ee2c:	b292      	uxth	r2, r2
      if ((nb_remaining_rx_data > 0U)
2400ee2e:	2a00      	cmp	r2, #0
2400ee30:	d0c0      	beq.n	2400edb4 <HAL_UART_IRQHandler+0x13c>
          && (nb_remaining_rx_data < huart->RxXferSize))
2400ee32:	f8b4 005c 	ldrh.w	r0, [r4, #92]	@ 0x5c
2400ee36:	4290      	cmp	r0, r2
2400ee38:	d9bc      	bls.n	2400edb4 <HAL_UART_IRQHandler+0x13c>
        huart->RxXferCount = nb_remaining_rx_data;
2400ee3a:	f8a4 205e 	strh.w	r2, [r4, #94]	@ 0x5e
        if (huart->hdmarx->Init.Mode != DMA_CIRCULAR)
2400ee3e:	69ca      	ldr	r2, [r1, #28]
2400ee40:	f5b2 7f80 	cmp.w	r2, #256	@ 0x100
2400ee44:	d02f      	beq.n	2400eea6 <HAL_UART_IRQHandler+0x22e>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
2400ee46:	e853 2f00 	ldrex	r2, [r3]
          ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
2400ee4a:	f422 7280 	bic.w	r2, r2, #256	@ 0x100
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
2400ee4e:	e843 2100 	strex	r1, r2, [r3]
2400ee52:	2900      	cmp	r1, #0
2400ee54:	d1f7      	bne.n	2400ee46 <HAL_UART_IRQHandler+0x1ce>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
2400ee56:	f103 0208 	add.w	r2, r3, #8
2400ee5a:	e852 2f00 	ldrex	r2, [r2]
          ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
2400ee5e:	f022 0201 	bic.w	r2, r2, #1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
2400ee62:	f103 0008 	add.w	r0, r3, #8
2400ee66:	e840 2100 	strex	r1, r2, [r0]
2400ee6a:	2900      	cmp	r1, #0
2400ee6c:	d1f3      	bne.n	2400ee56 <HAL_UART_IRQHandler+0x1de>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
2400ee6e:	f103 0208 	add.w	r2, r3, #8
2400ee72:	e852 2f00 	ldrex	r2, [r2]
          ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
2400ee76:	f022 0240 	bic.w	r2, r2, #64	@ 0x40
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
2400ee7a:	f103 0008 	add.w	r0, r3, #8
2400ee7e:	e840 2100 	strex	r1, r2, [r0]
2400ee82:	2900      	cmp	r1, #0
2400ee84:	d1f3      	bne.n	2400ee6e <HAL_UART_IRQHandler+0x1f6>
          huart->RxState = HAL_UART_STATE_READY;
2400ee86:	2220      	movs	r2, #32
2400ee88:	f8c4 208c 	str.w	r2, [r4, #140]	@ 0x8c
          huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
2400ee8c:	66e1      	str	r1, [r4, #108]	@ 0x6c
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
2400ee8e:	e853 2f00 	ldrex	r2, [r3]
          ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
2400ee92:	f022 0210 	bic.w	r2, r2, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
2400ee96:	e843 2100 	strex	r1, r2, [r3]
2400ee9a:	2900      	cmp	r1, #0
2400ee9c:	d1f7      	bne.n	2400ee8e <HAL_UART_IRQHandler+0x216>
          (void)HAL_DMA_Abort(huart->hdmarx);
2400ee9e:	f8d4 0080 	ldr.w	r0, [r4, #128]	@ 0x80
2400eea2:	f7f2 feb7 	bl	24001c14 <HAL_DMA_Abort>
        huart->RxEventType = HAL_UART_RXEVENT_IDLE;
2400eea6:	2302      	movs	r3, #2
        HAL_UARTEx_RxEventCallback(huart, (huart->RxXferSize - huart->RxXferCount));
2400eea8:	f8b4 105c 	ldrh.w	r1, [r4, #92]	@ 0x5c
        huart->RxEventType = HAL_UART_RXEVENT_IDLE;
2400eeac:	6723      	str	r3, [r4, #112]	@ 0x70
        HAL_UARTEx_RxEventCallback(huart, (huart->RxXferSize - huart->RxXferCount));
2400eeae:	f8b4 305e 	ldrh.w	r3, [r4, #94]	@ 0x5e
2400eeb2:	1ac9      	subs	r1, r1, r3
2400eeb4:	b289      	uxth	r1, r1
        HAL_UARTEx_RxEventCallback(huart, nb_rx_data);
2400eeb6:	4620      	mov	r0, r4
2400eeb8:	f7ff fedd 	bl	2400ec76 <HAL_UARTEx_RxEventCallback>
2400eebc:	e77a      	b.n	2400edb4 <HAL_UART_IRQHandler+0x13c>
      uint16_t nb_rx_data = huart->RxXferSize - huart->RxXferCount;
2400eebe:	f8b4 205e 	ldrh.w	r2, [r4, #94]	@ 0x5e
      if ((huart->RxXferCount > 0U)
2400eec2:	f8b4 005e 	ldrh.w	r0, [r4, #94]	@ 0x5e
      uint16_t nb_rx_data = huart->RxXferSize - huart->RxXferCount;
2400eec6:	f8b4 105c 	ldrh.w	r1, [r4, #92]	@ 0x5c
2400eeca:	b292      	uxth	r2, r2
      if ((huart->RxXferCount > 0U)
2400eecc:	b280      	uxth	r0, r0
2400eece:	2800      	cmp	r0, #0
2400eed0:	f43f af70 	beq.w	2400edb4 <HAL_UART_IRQHandler+0x13c>
      uint16_t nb_rx_data = huart->RxXferSize - huart->RxXferCount;
2400eed4:	1a89      	subs	r1, r1, r2
2400eed6:	b289      	uxth	r1, r1
          && (nb_rx_data > 0U))
2400eed8:	2900      	cmp	r1, #0
2400eeda:	f43f af6b 	beq.w	2400edb4 <HAL_UART_IRQHandler+0x13c>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
2400eede:	e853 2f00 	ldrex	r2, [r3]
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
2400eee2:	f422 7290 	bic.w	r2, r2, #288	@ 0x120
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
2400eee6:	e843 2000 	strex	r0, r2, [r3]
2400eeea:	2800      	cmp	r0, #0
2400eeec:	d1f7      	bne.n	2400eede <HAL_UART_IRQHandler+0x266>
        ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
2400eeee:	4d1f      	ldr	r5, [pc, #124]	@ (2400ef6c <HAL_UART_IRQHandler+0x2f4>)
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
2400eef0:	f103 0208 	add.w	r2, r3, #8
2400eef4:	e852 2f00 	ldrex	r2, [r2]
2400eef8:	402a      	ands	r2, r5
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
2400eefa:	f103 0608 	add.w	r6, r3, #8
2400eefe:	e846 2000 	strex	r0, r2, [r6]
2400ef02:	2800      	cmp	r0, #0
2400ef04:	d1f4      	bne.n	2400eef0 <HAL_UART_IRQHandler+0x278>
        huart->RxState = HAL_UART_STATE_READY;
2400ef06:	2220      	movs	r2, #32
        huart->RxISR = NULL;
2400ef08:	6760      	str	r0, [r4, #116]	@ 0x74
        huart->RxState = HAL_UART_STATE_READY;
2400ef0a:	f8c4 208c 	str.w	r2, [r4, #140]	@ 0x8c
        huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
2400ef0e:	66e0      	str	r0, [r4, #108]	@ 0x6c
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
2400ef10:	e853 2f00 	ldrex	r2, [r3]
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
2400ef14:	f022 0210 	bic.w	r2, r2, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
2400ef18:	e843 2000 	strex	r0, r2, [r3]
2400ef1c:	2800      	cmp	r0, #0
2400ef1e:	d1f7      	bne.n	2400ef10 <HAL_UART_IRQHandler+0x298>
        huart->RxEventType = HAL_UART_RXEVENT_IDLE;
2400ef20:	2302      	movs	r3, #2
2400ef22:	6723      	str	r3, [r4, #112]	@ 0x70
2400ef24:	e7c7      	b.n	2400eeb6 <HAL_UART_IRQHandler+0x23e>
  if (((isrflags & USART_ISR_WUF) != 0U) && ((cr3its & USART_CR3_WUFIE) != 0U))
2400ef26:	02cf      	lsls	r7, r1, #11
2400ef28:	d509      	bpl.n	2400ef3e <HAL_UART_IRQHandler+0x2c6>
2400ef2a:	026e      	lsls	r6, r5, #9
2400ef2c:	d507      	bpl.n	2400ef3e <HAL_UART_IRQHandler+0x2c6>
    __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_WUF);
2400ef2e:	f44f 1280 	mov.w	r2, #1048576	@ 0x100000
    HAL_UARTEx_WakeupCallback(huart);
2400ef32:	4620      	mov	r0, r4
    __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_WUF);
2400ef34:	621a      	str	r2, [r3, #32]
}
2400ef36:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    HAL_UARTEx_WakeupCallback(huart);
2400ef3a:	f001 b992 	b.w	24010262 <HAL_UARTEx_WakeupCallback>
  if (((isrflags & USART_ISR_TXE_TXFNF) != 0U)
2400ef3e:	0608      	lsls	r0, r1, #24
2400ef40:	d516      	bpl.n	2400ef70 <HAL_UART_IRQHandler+0x2f8>
      && (((cr1its & USART_CR1_TXEIE_TXFNFIE) != 0U)
2400ef42:	f002 0080 	and.w	r0, r2, #128	@ 0x80
          || ((cr3its & USART_CR3_TXFTIE) != 0U)))
2400ef46:	f405 0500 	and.w	r5, r5, #8388608	@ 0x800000
2400ef4a:	4328      	orrs	r0, r5
2400ef4c:	d010      	beq.n	2400ef70 <HAL_UART_IRQHandler+0x2f8>
    if (huart->TxISR != NULL)
2400ef4e:	6fa3      	ldr	r3, [r4, #120]	@ 0x78
2400ef50:	2b00      	cmp	r3, #0
2400ef52:	f43f af2f 	beq.w	2400edb4 <HAL_UART_IRQHandler+0x13c>
      huart->TxISR(huart);
2400ef56:	4620      	mov	r0, r4
2400ef58:	e6a7      	b.n	2400ecaa <HAL_UART_IRQHandler+0x32>
2400ef5a:	bf00      	nop
2400ef5c:	10000001 	.word	0x10000001
2400ef60:	04000120 	.word	0x04000120
2400ef64:	2400e8ff 	.word	0x2400e8ff
2400ef68:	40020010 	.word	0x40020010
2400ef6c:	effffffe 	.word	0xeffffffe
  if (((isrflags & USART_ISR_TC) != 0U) && ((cr1its & USART_CR1_TCIE) != 0U))
2400ef70:	064f      	lsls	r7, r1, #25
2400ef72:	d511      	bpl.n	2400ef98 <HAL_UART_IRQHandler+0x320>
2400ef74:	0656      	lsls	r6, r2, #25
2400ef76:	d50f      	bpl.n	2400ef98 <HAL_UART_IRQHandler+0x320>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
2400ef78:	e853 2f00 	ldrex	r2, [r3]
  * @retval None
  */
static void UART_EndTransmit_IT(UART_HandleTypeDef *huart)
{
  /* Disable the UART Transmit Complete Interrupt */
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_TCIE);
2400ef7c:	f022 0240 	bic.w	r2, r2, #64	@ 0x40
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
2400ef80:	e843 2100 	strex	r1, r2, [r3]
2400ef84:	2900      	cmp	r1, #0
2400ef86:	d1f7      	bne.n	2400ef78 <HAL_UART_IRQHandler+0x300>

  /* Tx process is ended, restore huart->gState to Ready */
  huart->gState = HAL_UART_STATE_READY;
2400ef88:	2320      	movs	r3, #32
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
  /*Call registered Tx complete callback*/
  huart->TxCpltCallback(huart);
#else
  /*Call legacy weak Tx complete callback*/
  HAL_UART_TxCpltCallback(huart);
2400ef8a:	4620      	mov	r0, r4
  huart->TxISR = NULL;
2400ef8c:	67a1      	str	r1, [r4, #120]	@ 0x78
  huart->gState = HAL_UART_STATE_READY;
2400ef8e:	f8c4 3088 	str.w	r3, [r4, #136]	@ 0x88
  HAL_UART_TxCpltCallback(huart);
2400ef92:	f7ff fc63 	bl	2400e85c <HAL_UART_TxCpltCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
}
2400ef96:	e70d      	b.n	2400edb4 <HAL_UART_IRQHandler+0x13c>
  if (((isrflags & USART_ISR_TXFE) != 0U) && ((cr1its & USART_CR1_TXFEIE) != 0U))
2400ef98:	020d      	lsls	r5, r1, #8
2400ef9a:	d506      	bpl.n	2400efaa <HAL_UART_IRQHandler+0x332>
2400ef9c:	0050      	lsls	r0, r2, #1
2400ef9e:	d504      	bpl.n	2400efaa <HAL_UART_IRQHandler+0x332>
    HAL_UARTEx_TxFifoEmptyCallback(huart);
2400efa0:	4620      	mov	r0, r4
}
2400efa2:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    HAL_UARTEx_TxFifoEmptyCallback(huart);
2400efa6:	f001 b95e 	b.w	24010266 <HAL_UARTEx_TxFifoEmptyCallback>
  if (((isrflags & USART_ISR_RXFF) != 0U) && ((cr1its & USART_CR1_RXFFIE) != 0U))
2400efaa:	01cb      	lsls	r3, r1, #7
2400efac:	f57f af02 	bpl.w	2400edb4 <HAL_UART_IRQHandler+0x13c>
2400efb0:	2a00      	cmp	r2, #0
2400efb2:	f6bf aeff 	bge.w	2400edb4 <HAL_UART_IRQHandler+0x13c>
    HAL_UARTEx_RxFifoFullCallback(huart);
2400efb6:	4620      	mov	r0, r4
}
2400efb8:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    HAL_UARTEx_RxFifoFullCallback(huart);
2400efbc:	f001 b952 	b.w	24010264 <HAL_UARTEx_RxFifoFullCallback>

2400efc0 <UART_RxISR_8BIT>:
{
  uint16_t uhMask = huart->Mask;
  uint16_t  uhdata;

  /* Check that a Rx process is ongoing */
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
2400efc0:	f8d0 208c 	ldr.w	r2, [r0, #140]	@ 0x8c
  uint16_t uhMask = huart->Mask;
2400efc4:	f8b0 1060 	ldrh.w	r1, [r0, #96]	@ 0x60
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
2400efc8:	2a22      	cmp	r2, #34	@ 0x22
{
2400efca:	b508      	push	{r3, lr}
  {
    uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
2400efcc:	6803      	ldr	r3, [r0, #0]
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
2400efce:	d155      	bne.n	2400f07c <UART_RxISR_8BIT+0xbc>
    uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
2400efd0:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
    *huart->pRxBuffPtr = (uint8_t)(uhdata & (uint8_t)uhMask);
2400efd2:	6d82      	ldr	r2, [r0, #88]	@ 0x58
2400efd4:	400b      	ands	r3, r1
2400efd6:	7013      	strb	r3, [r2, #0]
    huart->pRxBuffPtr++;
2400efd8:	6d83      	ldr	r3, [r0, #88]	@ 0x58
2400efda:	3301      	adds	r3, #1
2400efdc:	6583      	str	r3, [r0, #88]	@ 0x58
    huart->RxXferCount--;
2400efde:	f8b0 305e 	ldrh.w	r3, [r0, #94]	@ 0x5e
2400efe2:	3b01      	subs	r3, #1
2400efe4:	b29b      	uxth	r3, r3
2400efe6:	f8a0 305e 	strh.w	r3, [r0, #94]	@ 0x5e

    if (huart->RxXferCount == 0U)
2400efea:	f8b0 305e 	ldrh.w	r3, [r0, #94]	@ 0x5e
2400efee:	b29b      	uxth	r3, r3
2400eff0:	2b00      	cmp	r3, #0
2400eff2:	d142      	bne.n	2400f07a <UART_RxISR_8BIT+0xba>
    {
      /* Disable the UART Parity Error Interrupt and RXNE interrupts */
      ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
2400eff4:	6802      	ldr	r2, [r0, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
2400eff6:	e852 3f00 	ldrex	r3, [r2]
2400effa:	f423 7390 	bic.w	r3, r3, #288	@ 0x120
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
2400effe:	e842 3100 	strex	r1, r3, [r2]
   return(result);
2400f002:	6803      	ldr	r3, [r0, #0]
2400f004:	2900      	cmp	r1, #0
2400f006:	d1f5      	bne.n	2400eff4 <UART_RxISR_8BIT+0x34>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
2400f008:	f103 0208 	add.w	r2, r3, #8
2400f00c:	e852 2f00 	ldrex	r2, [r2]

      /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */
      ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
2400f010:	f022 0201 	bic.w	r2, r2, #1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
2400f014:	f103 0c08 	add.w	ip, r3, #8
2400f018:	e84c 2100 	strex	r1, r2, [ip]
2400f01c:	2900      	cmp	r1, #0
2400f01e:	d1f3      	bne.n	2400f008 <UART_RxISR_8BIT+0x48>

      /* Rx process is completed, restore huart->RxState to Ready */
      huart->RxState = HAL_UART_STATE_READY;
2400f020:	2220      	movs	r2, #32

      /* Clear RxISR function pointer */
      huart->RxISR = NULL;
2400f022:	6741      	str	r1, [r0, #116]	@ 0x74
      huart->RxState = HAL_UART_STATE_READY;
2400f024:	f8c0 208c 	str.w	r2, [r0, #140]	@ 0x8c

      /* Initialize type of RxEvent to Transfer Complete */
      huart->RxEventType = HAL_UART_RXEVENT_TC;

      if (!(IS_LPUART_INSTANCE(huart->Instance)))
2400f028:	4a17      	ldr	r2, [pc, #92]	@ (2400f088 <UART_RxISR_8BIT+0xc8>)
      huart->RxEventType = HAL_UART_RXEVENT_TC;
2400f02a:	6701      	str	r1, [r0, #112]	@ 0x70
      if (!(IS_LPUART_INSTANCE(huart->Instance)))
2400f02c:	4293      	cmp	r3, r2
2400f02e:	d105      	bne.n	2400f03c <UART_RxISR_8BIT+0x7c>
        }
      }

      /* Check current reception Mode :
         If Reception till IDLE event has been selected : */
      if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
2400f030:	6ec2      	ldr	r2, [r0, #108]	@ 0x6c
2400f032:	2a01      	cmp	r2, #1
2400f034:	d00e      	beq.n	2400f054 <UART_RxISR_8BIT+0x94>
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
        /*Call registered Rx complete callback*/
        huart->RxCpltCallback(huart);
#else
        /*Call legacy weak Rx complete callback*/
        HAL_UART_RxCpltCallback(huart);
2400f036:	f7ff fc3b 	bl	2400e8b0 <HAL_UART_RxCpltCallback>
2400f03a:	e01e      	b.n	2400f07a <UART_RxISR_8BIT+0xba>
        if (READ_BIT(huart->Instance->CR2, USART_CR2_RTOEN) != 0U)
2400f03c:	685a      	ldr	r2, [r3, #4]
2400f03e:	0211      	lsls	r1, r2, #8
2400f040:	d5f6      	bpl.n	2400f030 <UART_RxISR_8BIT+0x70>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
2400f042:	e853 2f00 	ldrex	r2, [r3]
          ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_RTOIE);
2400f046:	f022 6280 	bic.w	r2, r2, #67108864	@ 0x4000000
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
2400f04a:	e843 2100 	strex	r1, r2, [r3]
2400f04e:	2900      	cmp	r1, #0
2400f050:	d1f7      	bne.n	2400f042 <UART_RxISR_8BIT+0x82>
2400f052:	e7ed      	b.n	2400f030 <UART_RxISR_8BIT+0x70>
        huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
2400f054:	2200      	movs	r2, #0
2400f056:	66c2      	str	r2, [r0, #108]	@ 0x6c
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
2400f058:	e853 2f00 	ldrex	r2, [r3]
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
2400f05c:	f022 0210 	bic.w	r2, r2, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
2400f060:	e843 2100 	strex	r1, r2, [r3]
2400f064:	2900      	cmp	r1, #0
2400f066:	d1f7      	bne.n	2400f058 <UART_RxISR_8BIT+0x98>
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_IDLE) == SET)
2400f068:	69da      	ldr	r2, [r3, #28]
2400f06a:	06d2      	lsls	r2, r2, #27
2400f06c:	d501      	bpl.n	2400f072 <UART_RxISR_8BIT+0xb2>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_IDLEF);
2400f06e:	2210      	movs	r2, #16
2400f070:	621a      	str	r2, [r3, #32]
        HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
2400f072:	f8b0 105c 	ldrh.w	r1, [r0, #92]	@ 0x5c
2400f076:	f7ff fdfe 	bl	2400ec76 <HAL_UARTEx_RxEventCallback>
  else
  {
    /* Clear RXNE interrupt flag */
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
  }
}
2400f07a:	bd08      	pop	{r3, pc}
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
2400f07c:	699a      	ldr	r2, [r3, #24]
2400f07e:	f042 0208 	orr.w	r2, r2, #8
2400f082:	619a      	str	r2, [r3, #24]
}
2400f084:	e7f9      	b.n	2400f07a <UART_RxISR_8BIT+0xba>
2400f086:	bf00      	nop
2400f088:	58000c00 	.word	0x58000c00

2400f08c <UART_RxISR_16BIT>:
  uint16_t *tmp;
  uint16_t uhMask = huart->Mask;
  uint16_t  uhdata;

  /* Check that a Rx process is ongoing */
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
2400f08c:	f8d0 208c 	ldr.w	r2, [r0, #140]	@ 0x8c
  uint16_t uhMask = huart->Mask;
2400f090:	f8b0 1060 	ldrh.w	r1, [r0, #96]	@ 0x60
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
2400f094:	2a22      	cmp	r2, #34	@ 0x22
{
2400f096:	b508      	push	{r3, lr}
  {
    uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
2400f098:	6803      	ldr	r3, [r0, #0]
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
2400f09a:	d152      	bne.n	2400f142 <UART_RxISR_16BIT+0xb6>
    uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
2400f09c:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
    tmp = (uint16_t *) huart->pRxBuffPtr ;
    *tmp = (uint16_t)(uhdata & uhMask);
2400f09e:	4011      	ands	r1, r2
2400f0a0:	6d82      	ldr	r2, [r0, #88]	@ 0x58
2400f0a2:	f822 1b02 	strh.w	r1, [r2], #2
    huart->pRxBuffPtr += 2U;
2400f0a6:	6582      	str	r2, [r0, #88]	@ 0x58
    huart->RxXferCount--;
2400f0a8:	f8b0 205e 	ldrh.w	r2, [r0, #94]	@ 0x5e
2400f0ac:	3a01      	subs	r2, #1
2400f0ae:	b292      	uxth	r2, r2
2400f0b0:	f8a0 205e 	strh.w	r2, [r0, #94]	@ 0x5e

    if (huart->RxXferCount == 0U)
2400f0b4:	f8b0 205e 	ldrh.w	r2, [r0, #94]	@ 0x5e
2400f0b8:	b292      	uxth	r2, r2
2400f0ba:	2a00      	cmp	r2, #0
2400f0bc:	d140      	bne.n	2400f140 <UART_RxISR_16BIT+0xb4>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
2400f0be:	e853 2f00 	ldrex	r2, [r3]
    {
      /* Disable the UART Parity Error Interrupt and RXNE interrupt*/
      ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
2400f0c2:	f422 7290 	bic.w	r2, r2, #288	@ 0x120
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
2400f0c6:	e843 2100 	strex	r1, r2, [r3]
2400f0ca:	2900      	cmp	r1, #0
2400f0cc:	d1f7      	bne.n	2400f0be <UART_RxISR_16BIT+0x32>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
2400f0ce:	f103 0208 	add.w	r2, r3, #8
2400f0d2:	e852 2f00 	ldrex	r2, [r2]

      /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */
      ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
2400f0d6:	f022 0201 	bic.w	r2, r2, #1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
2400f0da:	f103 0c08 	add.w	ip, r3, #8
2400f0de:	e84c 2100 	strex	r1, r2, [ip]
2400f0e2:	2900      	cmp	r1, #0
2400f0e4:	d1f3      	bne.n	2400f0ce <UART_RxISR_16BIT+0x42>

      /* Rx process is completed, restore huart->RxState to Ready */
      huart->RxState = HAL_UART_STATE_READY;
2400f0e6:	2220      	movs	r2, #32

      /* Clear RxISR function pointer */
      huart->RxISR = NULL;
2400f0e8:	6741      	str	r1, [r0, #116]	@ 0x74
      huart->RxState = HAL_UART_STATE_READY;
2400f0ea:	f8c0 208c 	str.w	r2, [r0, #140]	@ 0x8c

      /* Initialize type of RxEvent to Transfer Complete */
      huart->RxEventType = HAL_UART_RXEVENT_TC;

      if (!(IS_LPUART_INSTANCE(huart->Instance)))
2400f0ee:	4a17      	ldr	r2, [pc, #92]	@ (2400f14c <UART_RxISR_16BIT+0xc0>)
      huart->RxEventType = HAL_UART_RXEVENT_TC;
2400f0f0:	6701      	str	r1, [r0, #112]	@ 0x70
      if (!(IS_LPUART_INSTANCE(huart->Instance)))
2400f0f2:	4293      	cmp	r3, r2
2400f0f4:	d105      	bne.n	2400f102 <UART_RxISR_16BIT+0x76>
        }
      }

      /* Check current reception Mode :
         If Reception till IDLE event has been selected : */
      if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
2400f0f6:	6ec2      	ldr	r2, [r0, #108]	@ 0x6c
2400f0f8:	2a01      	cmp	r2, #1
2400f0fa:	d00e      	beq.n	2400f11a <UART_RxISR_16BIT+0x8e>
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
        /*Call registered Rx complete callback*/
        huart->RxCpltCallback(huart);
#else
        /*Call legacy weak Rx complete callback*/
        HAL_UART_RxCpltCallback(huart);
2400f0fc:	f7ff fbd8 	bl	2400e8b0 <HAL_UART_RxCpltCallback>
2400f100:	e01e      	b.n	2400f140 <UART_RxISR_16BIT+0xb4>
        if (READ_BIT(huart->Instance->CR2, USART_CR2_RTOEN) != 0U)
2400f102:	685a      	ldr	r2, [r3, #4]
2400f104:	0211      	lsls	r1, r2, #8
2400f106:	d5f6      	bpl.n	2400f0f6 <UART_RxISR_16BIT+0x6a>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
2400f108:	e853 2f00 	ldrex	r2, [r3]
          ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_RTOIE);
2400f10c:	f022 6280 	bic.w	r2, r2, #67108864	@ 0x4000000
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
2400f110:	e843 2100 	strex	r1, r2, [r3]
2400f114:	2900      	cmp	r1, #0
2400f116:	d1f7      	bne.n	2400f108 <UART_RxISR_16BIT+0x7c>
2400f118:	e7ed      	b.n	2400f0f6 <UART_RxISR_16BIT+0x6a>
        huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
2400f11a:	2200      	movs	r2, #0
2400f11c:	66c2      	str	r2, [r0, #108]	@ 0x6c
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
2400f11e:	e853 2f00 	ldrex	r2, [r3]
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
2400f122:	f022 0210 	bic.w	r2, r2, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
2400f126:	e843 2100 	strex	r1, r2, [r3]
2400f12a:	2900      	cmp	r1, #0
2400f12c:	d1f7      	bne.n	2400f11e <UART_RxISR_16BIT+0x92>
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_IDLE) == SET)
2400f12e:	69da      	ldr	r2, [r3, #28]
2400f130:	06d2      	lsls	r2, r2, #27
2400f132:	d501      	bpl.n	2400f138 <UART_RxISR_16BIT+0xac>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_IDLEF);
2400f134:	2210      	movs	r2, #16
2400f136:	621a      	str	r2, [r3, #32]
        HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
2400f138:	f8b0 105c 	ldrh.w	r1, [r0, #92]	@ 0x5c
2400f13c:	f7ff fd9b 	bl	2400ec76 <HAL_UARTEx_RxEventCallback>
  else
  {
    /* Clear RXNE interrupt flag */
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
  }
}
2400f140:	bd08      	pop	{r3, pc}
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
2400f142:	699a      	ldr	r2, [r3, #24]
2400f144:	f042 0208 	orr.w	r2, r2, #8
2400f148:	619a      	str	r2, [r3, #24]
}
2400f14a:	e7f9      	b.n	2400f140 <UART_RxISR_16BIT+0xb4>
2400f14c:	58000c00 	.word	0x58000c00

2400f150 <UART_RxISR_8BIT_FIFOEN>:
  *         interruptions have been enabled by HAL_UART_Receive_IT()
  * @param huart UART handle.
  * @retval None
  */
static void UART_RxISR_8BIT_FIFOEN(UART_HandleTypeDef *huart)
{
2400f150:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint16_t  uhMask = huart->Mask;
  uint16_t  uhdata;
  uint16_t  nb_rx_data;
  uint16_t  rxdatacount;
  uint32_t  isrflags = READ_REG(huart->Instance->ISR);
2400f154:	6803      	ldr	r3, [r0, #0]
{
2400f156:	4604      	mov	r4, r0
  uint16_t  uhMask = huart->Mask;
2400f158:	f8b0 6060 	ldrh.w	r6, [r0, #96]	@ 0x60
  uint32_t  isrflags = READ_REG(huart->Instance->ISR);
2400f15c:	f8d3 b01c 	ldr.w	fp, [r3, #28]
  uint32_t  cr1its   = READ_REG(huart->Instance->CR1);
2400f160:	681f      	ldr	r7, [r3, #0]
  uint32_t  cr3its   = READ_REG(huart->Instance->CR3);
2400f162:	689d      	ldr	r5, [r3, #8]

  /* Check that a Rx process is ongoing */
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
2400f164:	f8d0 208c 	ldr.w	r2, [r0, #140]	@ 0x8c
2400f168:	2a22      	cmp	r2, #34	@ 0x22
2400f16a:	f040 80b9 	bne.w	2400f2e0 <UART_RxISR_8BIT_FIFOEN+0x190>
  {
    nb_rx_data = huart->NbRxDataToProcess;
    while ((nb_rx_data > 0U) && ((isrflags & USART_ISR_RXNE_RXFNE) != 0U))
2400f16e:	f8b0 3068 	ldrh.w	r3, [r0, #104]	@ 0x68
2400f172:	b143      	cbz	r3, 2400f186 <UART_RxISR_8BIT_FIFOEN+0x36>
          huart->ErrorCallback(huart);
#else
          /*Call legacy weak error callback*/
          HAL_UART_ErrorCallback(huart);
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
          huart->ErrorCode = HAL_UART_ERROR_NONE;
2400f174:	f04f 0800 	mov.w	r8, #0
        /* Disable the UART Parity Error Interrupt and RXFT interrupt*/
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);

        /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error)
           and RX FIFO Threshold interrupt */
        ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
2400f178:	f8df 9174 	ldr.w	r9, [pc, #372]	@ 2400f2f0 <UART_RxISR_8BIT_FIFOEN+0x1a0>
        huart->RxISR = NULL;

        /* Initialize type of RxEvent to Transfer Complete */
        huart->RxEventType = HAL_UART_RXEVENT_TC;

        if (!(IS_LPUART_INSTANCE(huart->Instance)))
2400f17c:	f8df a174 	ldr.w	sl, [pc, #372]	@ 2400f2f4 <UART_RxISR_8BIT_FIFOEN+0x1a4>
    while ((nb_rx_data > 0U) && ((isrflags & USART_ISR_RXNE_RXFNE) != 0U))
2400f180:	f01b 0f20 	tst.w	fp, #32
2400f184:	d120      	bne.n	2400f1c8 <UART_RxISR_8BIT_FIFOEN+0x78>

    /* When remaining number of bytes to receive is less than the RX FIFO
    threshold, next incoming frames are processed as if FIFO mode was
    disabled (i.e. one interrupt per received frame).
    */
    rxdatacount = huart->RxXferCount;
2400f186:	f8b4 305e 	ldrh.w	r3, [r4, #94]	@ 0x5e
2400f18a:	b29b      	uxth	r3, r3
    if ((rxdatacount != 0U) && (rxdatacount < huart->NbRxDataToProcess))
2400f18c:	b1d3      	cbz	r3, 2400f1c4 <UART_RxISR_8BIT_FIFOEN+0x74>
2400f18e:	f8b4 2068 	ldrh.w	r2, [r4, #104]	@ 0x68
2400f192:	429a      	cmp	r2, r3
2400f194:	d916      	bls.n	2400f1c4 <UART_RxISR_8BIT_FIFOEN+0x74>
    {
      /* Disable the UART RXFT interrupt*/
      ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_RXFTIE);
2400f196:	6822      	ldr	r2, [r4, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
2400f198:	f102 0308 	add.w	r3, r2, #8
2400f19c:	e853 3f00 	ldrex	r3, [r3]
2400f1a0:	f023 5380 	bic.w	r3, r3, #268435456	@ 0x10000000
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
2400f1a4:	3208      	adds	r2, #8
2400f1a6:	e842 3100 	strex	r1, r3, [r2]
   return(result);
2400f1aa:	6822      	ldr	r2, [r4, #0]
2400f1ac:	2900      	cmp	r1, #0
2400f1ae:	d1f2      	bne.n	2400f196 <UART_RxISR_8BIT_FIFOEN+0x46>

      /* Update the RxISR function pointer */
      huart->RxISR = UART_RxISR_8BIT;
2400f1b0:	4b4e      	ldr	r3, [pc, #312]	@ (2400f2ec <UART_RxISR_8BIT_FIFOEN+0x19c>)
2400f1b2:	6763      	str	r3, [r4, #116]	@ 0x74
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
2400f1b4:	e852 3f00 	ldrex	r3, [r2]

      /* Enable the UART Data Register Not Empty interrupt */
      ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_RXNEIE_RXFNEIE);
2400f1b8:	f043 0320 	orr.w	r3, r3, #32
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
2400f1bc:	e842 3100 	strex	r1, r3, [r2]
2400f1c0:	2900      	cmp	r1, #0
2400f1c2:	d1f7      	bne.n	2400f1b4 <UART_RxISR_8BIT_FIFOEN+0x64>
  else
  {
    /* Clear RXNE interrupt flag */
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
  }
}
2400f1c4:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
      uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
2400f1c8:	6823      	ldr	r3, [r4, #0]
      *huart->pRxBuffPtr = (uint8_t)(uhdata & (uint8_t)uhMask);
2400f1ca:	6da2      	ldr	r2, [r4, #88]	@ 0x58
      uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
2400f1cc:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
      *huart->pRxBuffPtr = (uint8_t)(uhdata & (uint8_t)uhMask);
2400f1ce:	4033      	ands	r3, r6
2400f1d0:	7013      	strb	r3, [r2, #0]
      huart->pRxBuffPtr++;
2400f1d2:	6da3      	ldr	r3, [r4, #88]	@ 0x58
2400f1d4:	3301      	adds	r3, #1
2400f1d6:	65a3      	str	r3, [r4, #88]	@ 0x58
      huart->RxXferCount--;
2400f1d8:	f8b4 305e 	ldrh.w	r3, [r4, #94]	@ 0x5e
2400f1dc:	3b01      	subs	r3, #1
2400f1de:	b29b      	uxth	r3, r3
2400f1e0:	f8a4 305e 	strh.w	r3, [r4, #94]	@ 0x5e
      isrflags = READ_REG(huart->Instance->ISR);
2400f1e4:	6823      	ldr	r3, [r4, #0]
2400f1e6:	f8d3 b01c 	ldr.w	fp, [r3, #28]
      if ((isrflags & (USART_ISR_PE | USART_ISR_FE | USART_ISR_NE)) != 0U)
2400f1ea:	f01b 0f07 	tst.w	fp, #7
2400f1ee:	d02e      	beq.n	2400f24e <UART_RxISR_8BIT_FIFOEN+0xfe>
        if (((isrflags & USART_ISR_PE) != 0U) && ((cr1its & USART_CR1_PEIE) != 0U))
2400f1f0:	f01b 0f01 	tst.w	fp, #1
2400f1f4:	d009      	beq.n	2400f20a <UART_RxISR_8BIT_FIFOEN+0xba>
2400f1f6:	05f9      	lsls	r1, r7, #23
2400f1f8:	d507      	bpl.n	2400f20a <UART_RxISR_8BIT_FIFOEN+0xba>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_PEF);
2400f1fa:	2201      	movs	r2, #1
2400f1fc:	621a      	str	r2, [r3, #32]
          huart->ErrorCode |= HAL_UART_ERROR_PE;
2400f1fe:	f8d4 2090 	ldr.w	r2, [r4, #144]	@ 0x90
2400f202:	f042 0201 	orr.w	r2, r2, #1
2400f206:	f8c4 2090 	str.w	r2, [r4, #144]	@ 0x90
        if (((isrflags & USART_ISR_FE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
2400f20a:	f01b 0f02 	tst.w	fp, #2
2400f20e:	d009      	beq.n	2400f224 <UART_RxISR_8BIT_FIFOEN+0xd4>
2400f210:	07ea      	lsls	r2, r5, #31
2400f212:	d507      	bpl.n	2400f224 <UART_RxISR_8BIT_FIFOEN+0xd4>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_FEF);
2400f214:	2202      	movs	r2, #2
2400f216:	621a      	str	r2, [r3, #32]
          huart->ErrorCode |= HAL_UART_ERROR_FE;
2400f218:	f8d4 2090 	ldr.w	r2, [r4, #144]	@ 0x90
2400f21c:	f042 0204 	orr.w	r2, r2, #4
2400f220:	f8c4 2090 	str.w	r2, [r4, #144]	@ 0x90
        if (((isrflags & USART_ISR_NE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
2400f224:	f01b 0f04 	tst.w	fp, #4
2400f228:	d009      	beq.n	2400f23e <UART_RxISR_8BIT_FIFOEN+0xee>
2400f22a:	07e8      	lsls	r0, r5, #31
2400f22c:	d507      	bpl.n	2400f23e <UART_RxISR_8BIT_FIFOEN+0xee>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_NEF);
2400f22e:	2204      	movs	r2, #4
2400f230:	621a      	str	r2, [r3, #32]
          huart->ErrorCode |= HAL_UART_ERROR_NE;
2400f232:	f8d4 3090 	ldr.w	r3, [r4, #144]	@ 0x90
2400f236:	f043 0302 	orr.w	r3, r3, #2
2400f23a:	f8c4 3090 	str.w	r3, [r4, #144]	@ 0x90
        if (huart->ErrorCode != HAL_UART_ERROR_NONE)
2400f23e:	f8d4 3090 	ldr.w	r3, [r4, #144]	@ 0x90
2400f242:	b123      	cbz	r3, 2400f24e <UART_RxISR_8BIT_FIFOEN+0xfe>
          HAL_UART_ErrorCallback(huart);
2400f244:	4620      	mov	r0, r4
2400f246:	f7ff fb35 	bl	2400e8b4 <HAL_UART_ErrorCallback>
          huart->ErrorCode = HAL_UART_ERROR_NONE;
2400f24a:	f8c4 8090 	str.w	r8, [r4, #144]	@ 0x90
      if (huart->RxXferCount == 0U)
2400f24e:	f8b4 305e 	ldrh.w	r3, [r4, #94]	@ 0x5e
2400f252:	b29b      	uxth	r3, r3
2400f254:	2b00      	cmp	r3, #0
2400f256:	d193      	bne.n	2400f180 <UART_RxISR_8BIT_FIFOEN+0x30>
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
2400f258:	6822      	ldr	r2, [r4, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
2400f25a:	e852 3f00 	ldrex	r3, [r2]
2400f25e:	f423 7380 	bic.w	r3, r3, #256	@ 0x100
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
2400f262:	e842 3100 	strex	r1, r3, [r2]
   return(result);
2400f266:	6823      	ldr	r3, [r4, #0]
2400f268:	2900      	cmp	r1, #0
2400f26a:	d1f5      	bne.n	2400f258 <UART_RxISR_8BIT_FIFOEN+0x108>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
2400f26c:	f103 0208 	add.w	r2, r3, #8
2400f270:	e852 2f00 	ldrex	r2, [r2]
        ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
2400f274:	ea02 0209 	and.w	r2, r2, r9
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
2400f278:	f103 0008 	add.w	r0, r3, #8
2400f27c:	e840 2100 	strex	r1, r2, [r0]
2400f280:	2900      	cmp	r1, #0
2400f282:	d1f3      	bne.n	2400f26c <UART_RxISR_8BIT_FIFOEN+0x11c>
        huart->RxState = HAL_UART_STATE_READY;
2400f284:	2220      	movs	r2, #32
        if (!(IS_LPUART_INSTANCE(huart->Instance)))
2400f286:	4553      	cmp	r3, sl
        huart->RxISR = NULL;
2400f288:	6761      	str	r1, [r4, #116]	@ 0x74
        huart->RxState = HAL_UART_STATE_READY;
2400f28a:	f8c4 208c 	str.w	r2, [r4, #140]	@ 0x8c
        huart->RxEventType = HAL_UART_RXEVENT_TC;
2400f28e:	6721      	str	r1, [r4, #112]	@ 0x70
        if (!(IS_LPUART_INSTANCE(huart->Instance)))
2400f290:	d00a      	beq.n	2400f2a8 <UART_RxISR_8BIT_FIFOEN+0x158>
          if (READ_BIT(huart->Instance->CR2, USART_CR2_RTOEN) != 0U)
2400f292:	685a      	ldr	r2, [r3, #4]
2400f294:	0211      	lsls	r1, r2, #8
2400f296:	d507      	bpl.n	2400f2a8 <UART_RxISR_8BIT_FIFOEN+0x158>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
2400f298:	e853 2f00 	ldrex	r2, [r3]
            ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_RTOIE);
2400f29c:	f022 6280 	bic.w	r2, r2, #67108864	@ 0x4000000
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
2400f2a0:	e843 2100 	strex	r1, r2, [r3]
2400f2a4:	2900      	cmp	r1, #0
2400f2a6:	d1f7      	bne.n	2400f298 <UART_RxISR_8BIT_FIFOEN+0x148>
        if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
2400f2a8:	6ee2      	ldr	r2, [r4, #108]	@ 0x6c
2400f2aa:	2a01      	cmp	r2, #1
2400f2ac:	d114      	bne.n	2400f2d8 <UART_RxISR_8BIT_FIFOEN+0x188>
          huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
2400f2ae:	2200      	movs	r2, #0
2400f2b0:	66e2      	str	r2, [r4, #108]	@ 0x6c
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
2400f2b2:	e853 2f00 	ldrex	r2, [r3]
          ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
2400f2b6:	f022 0210 	bic.w	r2, r2, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
2400f2ba:	e843 2100 	strex	r1, r2, [r3]
2400f2be:	2900      	cmp	r1, #0
2400f2c0:	d1f7      	bne.n	2400f2b2 <UART_RxISR_8BIT_FIFOEN+0x162>
          if (__HAL_UART_GET_FLAG(huart, UART_FLAG_IDLE) == SET)
2400f2c2:	69da      	ldr	r2, [r3, #28]
2400f2c4:	06d2      	lsls	r2, r2, #27
2400f2c6:	d501      	bpl.n	2400f2cc <UART_RxISR_8BIT_FIFOEN+0x17c>
            __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_IDLEF);
2400f2c8:	2210      	movs	r2, #16
2400f2ca:	621a      	str	r2, [r3, #32]
          HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
2400f2cc:	f8b4 105c 	ldrh.w	r1, [r4, #92]	@ 0x5c
2400f2d0:	4620      	mov	r0, r4
2400f2d2:	f7ff fcd0 	bl	2400ec76 <HAL_UARTEx_RxEventCallback>
2400f2d6:	e753      	b.n	2400f180 <UART_RxISR_8BIT_FIFOEN+0x30>
          HAL_UART_RxCpltCallback(huart);
2400f2d8:	4620      	mov	r0, r4
2400f2da:	f7ff fae9 	bl	2400e8b0 <HAL_UART_RxCpltCallback>
    while ((nb_rx_data > 0U) && ((isrflags & USART_ISR_RXNE_RXFNE) != 0U))
2400f2de:	e74f      	b.n	2400f180 <UART_RxISR_8BIT_FIFOEN+0x30>
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
2400f2e0:	699a      	ldr	r2, [r3, #24]
2400f2e2:	f042 0208 	orr.w	r2, r2, #8
2400f2e6:	619a      	str	r2, [r3, #24]
}
2400f2e8:	e76c      	b.n	2400f1c4 <UART_RxISR_8BIT_FIFOEN+0x74>
2400f2ea:	bf00      	nop
2400f2ec:	2400efc1 	.word	0x2400efc1
2400f2f0:	effffffe 	.word	0xeffffffe
2400f2f4:	58000c00 	.word	0x58000c00

2400f2f8 <UART_RxISR_16BIT_FIFOEN>:
  *         interruptions have been enabled by HAL_UART_Receive_IT()
  * @param huart UART handle.
  * @retval None
  */
static void UART_RxISR_16BIT_FIFOEN(UART_HandleTypeDef *huart)
{
2400f2f8:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint16_t *tmp;
  uint16_t  uhMask = huart->Mask;
  uint16_t  uhdata;
  uint16_t  nb_rx_data;
  uint16_t  rxdatacount;
  uint32_t  isrflags = READ_REG(huart->Instance->ISR);
2400f2fc:	6803      	ldr	r3, [r0, #0]
{
2400f2fe:	4604      	mov	r4, r0
  uint16_t  uhMask = huart->Mask;
2400f300:	f8b0 6060 	ldrh.w	r6, [r0, #96]	@ 0x60
  uint32_t  isrflags = READ_REG(huart->Instance->ISR);
2400f304:	f8d3 b01c 	ldr.w	fp, [r3, #28]
  uint32_t  cr1its   = READ_REG(huart->Instance->CR1);
2400f308:	681f      	ldr	r7, [r3, #0]
  uint32_t  cr3its   = READ_REG(huart->Instance->CR3);
2400f30a:	689d      	ldr	r5, [r3, #8]

  /* Check that a Rx process is ongoing */
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
2400f30c:	f8d0 208c 	ldr.w	r2, [r0, #140]	@ 0x8c
2400f310:	2a22      	cmp	r2, #34	@ 0x22
2400f312:	f040 80b7 	bne.w	2400f484 <UART_RxISR_16BIT_FIFOEN+0x18c>
  {
    nb_rx_data = huart->NbRxDataToProcess;
    while ((nb_rx_data > 0U) && ((isrflags & USART_ISR_RXNE_RXFNE) != 0U))
2400f316:	f8b0 3068 	ldrh.w	r3, [r0, #104]	@ 0x68
2400f31a:	b143      	cbz	r3, 2400f32e <UART_RxISR_16BIT_FIFOEN+0x36>
          huart->ErrorCallback(huart);
#else
          /*Call legacy weak error callback*/
          HAL_UART_ErrorCallback(huart);
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
          huart->ErrorCode = HAL_UART_ERROR_NONE;
2400f31c:	f04f 0800 	mov.w	r8, #0
        /* Disable the UART Parity Error Interrupt and RXFT interrupt*/
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);

        /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error)
           and RX FIFO Threshold interrupt */
        ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
2400f320:	f8df 9170 	ldr.w	r9, [pc, #368]	@ 2400f494 <UART_RxISR_16BIT_FIFOEN+0x19c>
        huart->RxISR = NULL;

        /* Initialize type of RxEvent to Transfer Complete */
        huart->RxEventType = HAL_UART_RXEVENT_TC;

        if (!(IS_LPUART_INSTANCE(huart->Instance)))
2400f324:	f8df a170 	ldr.w	sl, [pc, #368]	@ 2400f498 <UART_RxISR_16BIT_FIFOEN+0x1a0>
    while ((nb_rx_data > 0U) && ((isrflags & USART_ISR_RXNE_RXFNE) != 0U))
2400f328:	f01b 0f20 	tst.w	fp, #32
2400f32c:	d120      	bne.n	2400f370 <UART_RxISR_16BIT_FIFOEN+0x78>

    /* When remaining number of bytes to receive is less than the RX FIFO
    threshold, next incoming frames are processed as if FIFO mode was
    disabled (i.e. one interrupt per received frame).
    */
    rxdatacount = huart->RxXferCount;
2400f32e:	f8b4 305e 	ldrh.w	r3, [r4, #94]	@ 0x5e
2400f332:	b29b      	uxth	r3, r3
    if ((rxdatacount != 0U) && (rxdatacount < huart->NbRxDataToProcess))
2400f334:	b1d3      	cbz	r3, 2400f36c <UART_RxISR_16BIT_FIFOEN+0x74>
2400f336:	f8b4 2068 	ldrh.w	r2, [r4, #104]	@ 0x68
2400f33a:	429a      	cmp	r2, r3
2400f33c:	d916      	bls.n	2400f36c <UART_RxISR_16BIT_FIFOEN+0x74>
    {
      /* Disable the UART RXFT interrupt*/
      ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_RXFTIE);
2400f33e:	6822      	ldr	r2, [r4, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
2400f340:	f102 0308 	add.w	r3, r2, #8
2400f344:	e853 3f00 	ldrex	r3, [r3]
2400f348:	f023 5380 	bic.w	r3, r3, #268435456	@ 0x10000000
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
2400f34c:	3208      	adds	r2, #8
2400f34e:	e842 3100 	strex	r1, r3, [r2]
   return(result);
2400f352:	6822      	ldr	r2, [r4, #0]
2400f354:	2900      	cmp	r1, #0
2400f356:	d1f2      	bne.n	2400f33e <UART_RxISR_16BIT_FIFOEN+0x46>

      /* Update the RxISR function pointer */
      huart->RxISR = UART_RxISR_16BIT;
2400f358:	4b4d      	ldr	r3, [pc, #308]	@ (2400f490 <UART_RxISR_16BIT_FIFOEN+0x198>)
2400f35a:	6763      	str	r3, [r4, #116]	@ 0x74
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
2400f35c:	e852 3f00 	ldrex	r3, [r2]

      /* Enable the UART Data Register Not Empty interrupt */
      ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_RXNEIE_RXFNEIE);
2400f360:	f043 0320 	orr.w	r3, r3, #32
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
2400f364:	e842 3100 	strex	r1, r3, [r2]
2400f368:	2900      	cmp	r1, #0
2400f36a:	d1f7      	bne.n	2400f35c <UART_RxISR_16BIT_FIFOEN+0x64>
  else
  {
    /* Clear RXNE interrupt flag */
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
  }
}
2400f36c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
      uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
2400f370:	6823      	ldr	r3, [r4, #0]
      *tmp = (uint16_t)(uhdata & uhMask);
2400f372:	6da2      	ldr	r2, [r4, #88]	@ 0x58
      uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
2400f374:	6a59      	ldr	r1, [r3, #36]	@ 0x24
      *tmp = (uint16_t)(uhdata & uhMask);
2400f376:	4031      	ands	r1, r6
2400f378:	f822 1b02 	strh.w	r1, [r2], #2
      huart->pRxBuffPtr += 2U;
2400f37c:	65a2      	str	r2, [r4, #88]	@ 0x58
      huart->RxXferCount--;
2400f37e:	f8b4 205e 	ldrh.w	r2, [r4, #94]	@ 0x5e
2400f382:	3a01      	subs	r2, #1
2400f384:	b292      	uxth	r2, r2
2400f386:	f8a4 205e 	strh.w	r2, [r4, #94]	@ 0x5e
      isrflags = READ_REG(huart->Instance->ISR);
2400f38a:	f8d3 b01c 	ldr.w	fp, [r3, #28]
      if ((isrflags & (USART_ISR_PE | USART_ISR_FE | USART_ISR_NE)) != 0U)
2400f38e:	f01b 0f07 	tst.w	fp, #7
2400f392:	d02e      	beq.n	2400f3f2 <UART_RxISR_16BIT_FIFOEN+0xfa>
        if (((isrflags & USART_ISR_PE) != 0U) && ((cr1its & USART_CR1_PEIE) != 0U))
2400f394:	f01b 0f01 	tst.w	fp, #1
2400f398:	d009      	beq.n	2400f3ae <UART_RxISR_16BIT_FIFOEN+0xb6>
2400f39a:	05f9      	lsls	r1, r7, #23
2400f39c:	d507      	bpl.n	2400f3ae <UART_RxISR_16BIT_FIFOEN+0xb6>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_PEF);
2400f39e:	2201      	movs	r2, #1
2400f3a0:	621a      	str	r2, [r3, #32]
          huart->ErrorCode |= HAL_UART_ERROR_PE;
2400f3a2:	f8d4 2090 	ldr.w	r2, [r4, #144]	@ 0x90
2400f3a6:	f042 0201 	orr.w	r2, r2, #1
2400f3aa:	f8c4 2090 	str.w	r2, [r4, #144]	@ 0x90
        if (((isrflags & USART_ISR_FE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
2400f3ae:	f01b 0f02 	tst.w	fp, #2
2400f3b2:	d009      	beq.n	2400f3c8 <UART_RxISR_16BIT_FIFOEN+0xd0>
2400f3b4:	07ea      	lsls	r2, r5, #31
2400f3b6:	d507      	bpl.n	2400f3c8 <UART_RxISR_16BIT_FIFOEN+0xd0>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_FEF);
2400f3b8:	2202      	movs	r2, #2
2400f3ba:	621a      	str	r2, [r3, #32]
          huart->ErrorCode |= HAL_UART_ERROR_FE;
2400f3bc:	f8d4 2090 	ldr.w	r2, [r4, #144]	@ 0x90
2400f3c0:	f042 0204 	orr.w	r2, r2, #4
2400f3c4:	f8c4 2090 	str.w	r2, [r4, #144]	@ 0x90
        if (((isrflags & USART_ISR_NE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
2400f3c8:	f01b 0f04 	tst.w	fp, #4
2400f3cc:	d009      	beq.n	2400f3e2 <UART_RxISR_16BIT_FIFOEN+0xea>
2400f3ce:	07e8      	lsls	r0, r5, #31
2400f3d0:	d507      	bpl.n	2400f3e2 <UART_RxISR_16BIT_FIFOEN+0xea>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_NEF);
2400f3d2:	2204      	movs	r2, #4
2400f3d4:	621a      	str	r2, [r3, #32]
          huart->ErrorCode |= HAL_UART_ERROR_NE;
2400f3d6:	f8d4 3090 	ldr.w	r3, [r4, #144]	@ 0x90
2400f3da:	f043 0302 	orr.w	r3, r3, #2
2400f3de:	f8c4 3090 	str.w	r3, [r4, #144]	@ 0x90
        if (huart->ErrorCode != HAL_UART_ERROR_NONE)
2400f3e2:	f8d4 3090 	ldr.w	r3, [r4, #144]	@ 0x90
2400f3e6:	b123      	cbz	r3, 2400f3f2 <UART_RxISR_16BIT_FIFOEN+0xfa>
          HAL_UART_ErrorCallback(huart);
2400f3e8:	4620      	mov	r0, r4
2400f3ea:	f7ff fa63 	bl	2400e8b4 <HAL_UART_ErrorCallback>
          huart->ErrorCode = HAL_UART_ERROR_NONE;
2400f3ee:	f8c4 8090 	str.w	r8, [r4, #144]	@ 0x90
      if (huart->RxXferCount == 0U)
2400f3f2:	f8b4 305e 	ldrh.w	r3, [r4, #94]	@ 0x5e
2400f3f6:	b29b      	uxth	r3, r3
2400f3f8:	2b00      	cmp	r3, #0
2400f3fa:	d195      	bne.n	2400f328 <UART_RxISR_16BIT_FIFOEN+0x30>
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
2400f3fc:	6822      	ldr	r2, [r4, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
2400f3fe:	e852 3f00 	ldrex	r3, [r2]
2400f402:	f423 7380 	bic.w	r3, r3, #256	@ 0x100
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
2400f406:	e842 3100 	strex	r1, r3, [r2]
   return(result);
2400f40a:	6823      	ldr	r3, [r4, #0]
2400f40c:	2900      	cmp	r1, #0
2400f40e:	d1f5      	bne.n	2400f3fc <UART_RxISR_16BIT_FIFOEN+0x104>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
2400f410:	f103 0208 	add.w	r2, r3, #8
2400f414:	e852 2f00 	ldrex	r2, [r2]
        ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
2400f418:	ea02 0209 	and.w	r2, r2, r9
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
2400f41c:	f103 0008 	add.w	r0, r3, #8
2400f420:	e840 2100 	strex	r1, r2, [r0]
2400f424:	2900      	cmp	r1, #0
2400f426:	d1f3      	bne.n	2400f410 <UART_RxISR_16BIT_FIFOEN+0x118>
        huart->RxState = HAL_UART_STATE_READY;
2400f428:	2220      	movs	r2, #32
        if (!(IS_LPUART_INSTANCE(huart->Instance)))
2400f42a:	4553      	cmp	r3, sl
        huart->RxISR = NULL;
2400f42c:	6761      	str	r1, [r4, #116]	@ 0x74
        huart->RxState = HAL_UART_STATE_READY;
2400f42e:	f8c4 208c 	str.w	r2, [r4, #140]	@ 0x8c
        huart->RxEventType = HAL_UART_RXEVENT_TC;
2400f432:	6721      	str	r1, [r4, #112]	@ 0x70
        if (!(IS_LPUART_INSTANCE(huart->Instance)))
2400f434:	d00a      	beq.n	2400f44c <UART_RxISR_16BIT_FIFOEN+0x154>
          if (READ_BIT(huart->Instance->CR2, USART_CR2_RTOEN) != 0U)
2400f436:	685a      	ldr	r2, [r3, #4]
2400f438:	0211      	lsls	r1, r2, #8
2400f43a:	d507      	bpl.n	2400f44c <UART_RxISR_16BIT_FIFOEN+0x154>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
2400f43c:	e853 2f00 	ldrex	r2, [r3]
            ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_RTOIE);
2400f440:	f022 6280 	bic.w	r2, r2, #67108864	@ 0x4000000
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
2400f444:	e843 2100 	strex	r1, r2, [r3]
2400f448:	2900      	cmp	r1, #0
2400f44a:	d1f7      	bne.n	2400f43c <UART_RxISR_16BIT_FIFOEN+0x144>
        if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
2400f44c:	6ee2      	ldr	r2, [r4, #108]	@ 0x6c
2400f44e:	2a01      	cmp	r2, #1
2400f450:	d114      	bne.n	2400f47c <UART_RxISR_16BIT_FIFOEN+0x184>
          huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
2400f452:	2200      	movs	r2, #0
2400f454:	66e2      	str	r2, [r4, #108]	@ 0x6c
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
2400f456:	e853 2f00 	ldrex	r2, [r3]
          ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
2400f45a:	f022 0210 	bic.w	r2, r2, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
2400f45e:	e843 2100 	strex	r1, r2, [r3]
2400f462:	2900      	cmp	r1, #0
2400f464:	d1f7      	bne.n	2400f456 <UART_RxISR_16BIT_FIFOEN+0x15e>
          if (__HAL_UART_GET_FLAG(huart, UART_FLAG_IDLE) == SET)
2400f466:	69da      	ldr	r2, [r3, #28]
2400f468:	06d2      	lsls	r2, r2, #27
2400f46a:	d501      	bpl.n	2400f470 <UART_RxISR_16BIT_FIFOEN+0x178>
            __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_IDLEF);
2400f46c:	2210      	movs	r2, #16
2400f46e:	621a      	str	r2, [r3, #32]
          HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
2400f470:	f8b4 105c 	ldrh.w	r1, [r4, #92]	@ 0x5c
2400f474:	4620      	mov	r0, r4
2400f476:	f7ff fbfe 	bl	2400ec76 <HAL_UARTEx_RxEventCallback>
2400f47a:	e755      	b.n	2400f328 <UART_RxISR_16BIT_FIFOEN+0x30>
          HAL_UART_RxCpltCallback(huart);
2400f47c:	4620      	mov	r0, r4
2400f47e:	f7ff fa17 	bl	2400e8b0 <HAL_UART_RxCpltCallback>
    while ((nb_rx_data > 0U) && ((isrflags & USART_ISR_RXNE_RXFNE) != 0U))
2400f482:	e751      	b.n	2400f328 <UART_RxISR_16BIT_FIFOEN+0x30>
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
2400f484:	699a      	ldr	r2, [r3, #24]
2400f486:	f042 0208 	orr.w	r2, r2, #8
2400f48a:	619a      	str	r2, [r3, #24]
}
2400f48c:	e76e      	b.n	2400f36c <UART_RxISR_16BIT_FIFOEN+0x74>
2400f48e:	bf00      	nop
2400f490:	2400f08d 	.word	0x2400f08d
2400f494:	effffffe 	.word	0xeffffffe
2400f498:	58000c00 	.word	0x58000c00

2400f49c <UART_DMARxHalfCplt>:
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);
2400f49c:	6b80      	ldr	r0, [r0, #56]	@ 0x38
{
2400f49e:	b508      	push	{r3, lr}
  huart->RxEventType = HAL_UART_RXEVENT_HT;
2400f4a0:	2301      	movs	r3, #1
2400f4a2:	6703      	str	r3, [r0, #112]	@ 0x70
  if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
2400f4a4:	6ec3      	ldr	r3, [r0, #108]	@ 0x6c
2400f4a6:	2b01      	cmp	r3, #1
2400f4a8:	d105      	bne.n	2400f4b6 <UART_DMARxHalfCplt+0x1a>
    HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize / 2U);
2400f4aa:	f8b0 105c 	ldrh.w	r1, [r0, #92]	@ 0x5c
2400f4ae:	0849      	lsrs	r1, r1, #1
2400f4b0:	f7ff fbe1 	bl	2400ec76 <HAL_UARTEx_RxEventCallback>
}
2400f4b4:	bd08      	pop	{r3, pc}
    HAL_UART_RxHalfCpltCallback(huart);
2400f4b6:	f7ff f9fc 	bl	2400e8b2 <HAL_UART_RxHalfCpltCallback>
}
2400f4ba:	e7fb      	b.n	2400f4b4 <UART_DMARxHalfCplt+0x18>

2400f4bc <UART_DMAReceiveCplt>:
{
2400f4bc:	b508      	push	{r3, lr}
2400f4be:	4603      	mov	r3, r0
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);
2400f4c0:	6b80      	ldr	r0, [r0, #56]	@ 0x38
  if (hdma->Init.Mode != DMA_CIRCULAR)
2400f4c2:	69db      	ldr	r3, [r3, #28]
2400f4c4:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
2400f4c8:	d032      	beq.n	2400f530 <UART_DMAReceiveCplt+0x74>
    huart->RxXferCount = 0U;
2400f4ca:	2300      	movs	r3, #0
2400f4cc:	f8a0 305e 	strh.w	r3, [r0, #94]	@ 0x5e
    ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
2400f4d0:	6802      	ldr	r2, [r0, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
2400f4d2:	e852 3f00 	ldrex	r3, [r2]
2400f4d6:	f423 7380 	bic.w	r3, r3, #256	@ 0x100
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
2400f4da:	e842 3100 	strex	r1, r3, [r2]
   return(result);
2400f4de:	6803      	ldr	r3, [r0, #0]
2400f4e0:	2900      	cmp	r1, #0
2400f4e2:	d1f5      	bne.n	2400f4d0 <UART_DMAReceiveCplt+0x14>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
2400f4e4:	f103 0208 	add.w	r2, r3, #8
2400f4e8:	e852 2f00 	ldrex	r2, [r2]
    ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
2400f4ec:	f022 0201 	bic.w	r2, r2, #1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
2400f4f0:	f103 0c08 	add.w	ip, r3, #8
2400f4f4:	e84c 2100 	strex	r1, r2, [ip]
2400f4f8:	2900      	cmp	r1, #0
2400f4fa:	d1f3      	bne.n	2400f4e4 <UART_DMAReceiveCplt+0x28>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
2400f4fc:	f103 0208 	add.w	r2, r3, #8
2400f500:	e852 2f00 	ldrex	r2, [r2]
    ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
2400f504:	f022 0240 	bic.w	r2, r2, #64	@ 0x40
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
2400f508:	f103 0c08 	add.w	ip, r3, #8
2400f50c:	e84c 2100 	strex	r1, r2, [ip]
2400f510:	2900      	cmp	r1, #0
2400f512:	d1f3      	bne.n	2400f4fc <UART_DMAReceiveCplt+0x40>
    huart->RxState = HAL_UART_STATE_READY;
2400f514:	2220      	movs	r2, #32
2400f516:	f8c0 208c 	str.w	r2, [r0, #140]	@ 0x8c
    if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
2400f51a:	6ec2      	ldr	r2, [r0, #108]	@ 0x6c
2400f51c:	2a01      	cmp	r2, #1
2400f51e:	d107      	bne.n	2400f530 <UART_DMAReceiveCplt+0x74>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
2400f520:	e853 2f00 	ldrex	r2, [r3]
      ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
2400f524:	f022 0210 	bic.w	r2, r2, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
2400f528:	e843 2100 	strex	r1, r2, [r3]
2400f52c:	2900      	cmp	r1, #0
2400f52e:	d1f7      	bne.n	2400f520 <UART_DMAReceiveCplt+0x64>
  huart->RxEventType = HAL_UART_RXEVENT_TC;
2400f530:	2300      	movs	r3, #0
2400f532:	6703      	str	r3, [r0, #112]	@ 0x70
  if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
2400f534:	6ec3      	ldr	r3, [r0, #108]	@ 0x6c
2400f536:	2b01      	cmp	r3, #1
2400f538:	d104      	bne.n	2400f544 <UART_DMAReceiveCplt+0x88>
    HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
2400f53a:	f8b0 105c 	ldrh.w	r1, [r0, #92]	@ 0x5c
2400f53e:	f7ff fb9a 	bl	2400ec76 <HAL_UARTEx_RxEventCallback>
}
2400f542:	bd08      	pop	{r3, pc}
    HAL_UART_RxCpltCallback(huart);
2400f544:	f7ff f9b4 	bl	2400e8b0 <HAL_UART_RxCpltCallback>
}
2400f548:	e7fb      	b.n	2400f542 <UART_DMAReceiveCplt+0x86>

2400f54a <HAL_UART_ReceiverTimeout_Config>:
  if (!(IS_LPUART_INSTANCE(huart->Instance)))
2400f54a:	6802      	ldr	r2, [r0, #0]
2400f54c:	4b04      	ldr	r3, [pc, #16]	@ (2400f560 <HAL_UART_ReceiverTimeout_Config+0x16>)
2400f54e:	429a      	cmp	r2, r3
2400f550:	d004      	beq.n	2400f55c <HAL_UART_ReceiverTimeout_Config+0x12>
    MODIFY_REG(huart->Instance->RTOR, USART_RTOR_RTO, TimeoutValue);
2400f552:	6953      	ldr	r3, [r2, #20]
2400f554:	f003 437f 	and.w	r3, r3, #4278190080	@ 0xff000000
2400f558:	4319      	orrs	r1, r3
2400f55a:	6151      	str	r1, [r2, #20]
}
2400f55c:	4770      	bx	lr
2400f55e:	bf00      	nop
2400f560:	58000c00 	.word	0x58000c00

2400f564 <HAL_UART_EnableReceiverTimeout>:
  if (!(IS_LPUART_INSTANCE(huart->Instance)))
2400f564:	6803      	ldr	r3, [r0, #0]
2400f566:	4a0e      	ldr	r2, [pc, #56]	@ (2400f5a0 <HAL_UART_EnableReceiverTimeout+0x3c>)
2400f568:	4293      	cmp	r3, r2
2400f56a:	d015      	beq.n	2400f598 <HAL_UART_EnableReceiverTimeout+0x34>
    if (huart->gState == HAL_UART_STATE_READY)
2400f56c:	f8d0 1088 	ldr.w	r1, [r0, #136]	@ 0x88
2400f570:	2920      	cmp	r1, #32
2400f572:	d113      	bne.n	2400f59c <HAL_UART_EnableReceiverTimeout+0x38>
      __HAL_LOCK(huart);
2400f574:	f890 2084 	ldrb.w	r2, [r0, #132]	@ 0x84
2400f578:	2a01      	cmp	r2, #1
2400f57a:	d00f      	beq.n	2400f59c <HAL_UART_EnableReceiverTimeout+0x38>
      huart->gState = HAL_UART_STATE_BUSY;
2400f57c:	2224      	movs	r2, #36	@ 0x24
2400f57e:	f8c0 2088 	str.w	r2, [r0, #136]	@ 0x88
      SET_BIT(huart->Instance->CR2, USART_CR2_RTOEN);
2400f582:	685a      	ldr	r2, [r3, #4]
2400f584:	f442 0200 	orr.w	r2, r2, #8388608	@ 0x800000
2400f588:	605a      	str	r2, [r3, #4]
      __HAL_UNLOCK(huart);
2400f58a:	2300      	movs	r3, #0
      huart->gState = HAL_UART_STATE_READY;
2400f58c:	f8c0 1088 	str.w	r1, [r0, #136]	@ 0x88
      __HAL_UNLOCK(huart);
2400f590:	f880 3084 	strb.w	r3, [r0, #132]	@ 0x84
      return HAL_OK;
2400f594:	4618      	mov	r0, r3
2400f596:	4770      	bx	lr
    return HAL_ERROR;
2400f598:	2001      	movs	r0, #1
2400f59a:	4770      	bx	lr
      __HAL_LOCK(huart);
2400f59c:	2002      	movs	r0, #2
}
2400f59e:	4770      	bx	lr
2400f5a0:	58000c00 	.word	0x58000c00

2400f5a4 <HAL_UART_DisableReceiverTimeout>:
  if (!(IS_LPUART_INSTANCE(huart->Instance)))
2400f5a4:	6803      	ldr	r3, [r0, #0]
2400f5a6:	4a0e      	ldr	r2, [pc, #56]	@ (2400f5e0 <HAL_UART_DisableReceiverTimeout+0x3c>)
2400f5a8:	4293      	cmp	r3, r2
2400f5aa:	d015      	beq.n	2400f5d8 <HAL_UART_DisableReceiverTimeout+0x34>
    if (huart->gState == HAL_UART_STATE_READY)
2400f5ac:	f8d0 1088 	ldr.w	r1, [r0, #136]	@ 0x88
2400f5b0:	2920      	cmp	r1, #32
2400f5b2:	d113      	bne.n	2400f5dc <HAL_UART_DisableReceiverTimeout+0x38>
      __HAL_LOCK(huart);
2400f5b4:	f890 2084 	ldrb.w	r2, [r0, #132]	@ 0x84
2400f5b8:	2a01      	cmp	r2, #1
2400f5ba:	d00f      	beq.n	2400f5dc <HAL_UART_DisableReceiverTimeout+0x38>
      huart->gState = HAL_UART_STATE_BUSY;
2400f5bc:	2224      	movs	r2, #36	@ 0x24
2400f5be:	f8c0 2088 	str.w	r2, [r0, #136]	@ 0x88
      CLEAR_BIT(huart->Instance->CR2, USART_CR2_RTOEN);
2400f5c2:	685a      	ldr	r2, [r3, #4]
2400f5c4:	f422 0200 	bic.w	r2, r2, #8388608	@ 0x800000
2400f5c8:	605a      	str	r2, [r3, #4]
      __HAL_UNLOCK(huart);
2400f5ca:	2300      	movs	r3, #0
      huart->gState = HAL_UART_STATE_READY;
2400f5cc:	f8c0 1088 	str.w	r1, [r0, #136]	@ 0x88
      __HAL_UNLOCK(huart);
2400f5d0:	f880 3084 	strb.w	r3, [r0, #132]	@ 0x84
      return HAL_OK;
2400f5d4:	4618      	mov	r0, r3
2400f5d6:	4770      	bx	lr
    return HAL_ERROR;
2400f5d8:	2001      	movs	r0, #1
2400f5da:	4770      	bx	lr
      __HAL_LOCK(huart);
2400f5dc:	2002      	movs	r0, #2
}
2400f5de:	4770      	bx	lr
2400f5e0:	58000c00 	.word	0x58000c00

2400f5e4 <HAL_MultiProcessor_EnterMuteMode>:
  __HAL_UART_SEND_REQ(huart, UART_MUTE_MODE_REQUEST);
2400f5e4:	6802      	ldr	r2, [r0, #0]
2400f5e6:	6993      	ldr	r3, [r2, #24]
2400f5e8:	f043 0304 	orr.w	r3, r3, #4
2400f5ec:	6193      	str	r3, [r2, #24]
}
2400f5ee:	4770      	bx	lr

2400f5f0 <HAL_HalfDuplex_EnableTransmitter>:
{
2400f5f0:	b510      	push	{r4, lr}
  __HAL_LOCK(huart);
2400f5f2:	f890 3084 	ldrb.w	r3, [r0, #132]	@ 0x84
2400f5f6:	2b01      	cmp	r3, #1
2400f5f8:	d01e      	beq.n	2400f638 <HAL_HalfDuplex_EnableTransmitter+0x48>
2400f5fa:	2301      	movs	r3, #1
2400f5fc:	f880 3084 	strb.w	r3, [r0, #132]	@ 0x84
  huart->gState = HAL_UART_STATE_BUSY;
2400f600:	2324      	movs	r3, #36	@ 0x24
2400f602:	f8c0 3088 	str.w	r3, [r0, #136]	@ 0x88
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TE | USART_CR1_RE));
2400f606:	6802      	ldr	r2, [r0, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
2400f608:	e852 3f00 	ldrex	r3, [r2]
2400f60c:	f023 030c 	bic.w	r3, r3, #12
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
2400f610:	e842 3400 	strex	r4, r3, [r2]
   return(result);
2400f614:	6801      	ldr	r1, [r0, #0]
2400f616:	2c00      	cmp	r4, #0
2400f618:	d1f5      	bne.n	2400f606 <HAL_HalfDuplex_EnableTransmitter+0x16>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
2400f61a:	e851 2f00 	ldrex	r2, [r1]
  ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_TE);
2400f61e:	f042 0208 	orr.w	r2, r2, #8
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
2400f622:	e841 2300 	strex	r3, r2, [r1]
2400f626:	2b00      	cmp	r3, #0
2400f628:	d1f7      	bne.n	2400f61a <HAL_HalfDuplex_EnableTransmitter+0x2a>
  huart->gState = HAL_UART_STATE_READY;
2400f62a:	2220      	movs	r2, #32
  __HAL_UNLOCK(huart);
2400f62c:	f880 3084 	strb.w	r3, [r0, #132]	@ 0x84
  huart->gState = HAL_UART_STATE_READY;
2400f630:	f8c0 2088 	str.w	r2, [r0, #136]	@ 0x88
  return HAL_OK;
2400f634:	4618      	mov	r0, r3
}
2400f636:	bd10      	pop	{r4, pc}
  __HAL_LOCK(huart);
2400f638:	2002      	movs	r0, #2
2400f63a:	e7fc      	b.n	2400f636 <HAL_HalfDuplex_EnableTransmitter+0x46>

2400f63c <HAL_HalfDuplex_EnableReceiver>:
{
2400f63c:	b510      	push	{r4, lr}
  __HAL_LOCK(huart);
2400f63e:	f890 3084 	ldrb.w	r3, [r0, #132]	@ 0x84
2400f642:	2b01      	cmp	r3, #1
2400f644:	d01e      	beq.n	2400f684 <HAL_HalfDuplex_EnableReceiver+0x48>
2400f646:	2301      	movs	r3, #1
2400f648:	f880 3084 	strb.w	r3, [r0, #132]	@ 0x84
  huart->gState = HAL_UART_STATE_BUSY;
2400f64c:	2324      	movs	r3, #36	@ 0x24
2400f64e:	f8c0 3088 	str.w	r3, [r0, #136]	@ 0x88
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TE | USART_CR1_RE));
2400f652:	6802      	ldr	r2, [r0, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
2400f654:	e852 3f00 	ldrex	r3, [r2]
2400f658:	f023 030c 	bic.w	r3, r3, #12
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
2400f65c:	e842 3400 	strex	r4, r3, [r2]
   return(result);
2400f660:	6801      	ldr	r1, [r0, #0]
2400f662:	2c00      	cmp	r4, #0
2400f664:	d1f5      	bne.n	2400f652 <HAL_HalfDuplex_EnableReceiver+0x16>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
2400f666:	e851 2f00 	ldrex	r2, [r1]
  ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_RE);
2400f66a:	f042 0204 	orr.w	r2, r2, #4
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
2400f66e:	e841 2300 	strex	r3, r2, [r1]
2400f672:	2b00      	cmp	r3, #0
2400f674:	d1f7      	bne.n	2400f666 <HAL_HalfDuplex_EnableReceiver+0x2a>
  huart->gState = HAL_UART_STATE_READY;
2400f676:	2220      	movs	r2, #32
  __HAL_UNLOCK(huart);
2400f678:	f880 3084 	strb.w	r3, [r0, #132]	@ 0x84
  huart->gState = HAL_UART_STATE_READY;
2400f67c:	f8c0 2088 	str.w	r2, [r0, #136]	@ 0x88
  return HAL_OK;
2400f680:	4618      	mov	r0, r3
}
2400f682:	bd10      	pop	{r4, pc}
  __HAL_LOCK(huart);
2400f684:	2002      	movs	r0, #2
2400f686:	e7fc      	b.n	2400f682 <HAL_HalfDuplex_EnableReceiver+0x46>

2400f688 <HAL_LIN_SendBreak>:
  __HAL_LOCK(huart);
2400f688:	f890 3084 	ldrb.w	r3, [r0, #132]	@ 0x84
2400f68c:	2b01      	cmp	r3, #1
2400f68e:	d00f      	beq.n	2400f6b0 <HAL_LIN_SendBreak+0x28>
  __HAL_UART_SEND_REQ(huart, UART_SENDBREAK_REQUEST);
2400f690:	6802      	ldr	r2, [r0, #0]
  huart->gState = HAL_UART_STATE_BUSY;
2400f692:	2324      	movs	r3, #36	@ 0x24
2400f694:	f8c0 3088 	str.w	r3, [r0, #136]	@ 0x88
  __HAL_UART_SEND_REQ(huart, UART_SENDBREAK_REQUEST);
2400f698:	6993      	ldr	r3, [r2, #24]
2400f69a:	f043 0302 	orr.w	r3, r3, #2
2400f69e:	6193      	str	r3, [r2, #24]
  huart->gState = HAL_UART_STATE_READY;
2400f6a0:	2320      	movs	r3, #32
2400f6a2:	f8c0 3088 	str.w	r3, [r0, #136]	@ 0x88
  __HAL_UNLOCK(huart);
2400f6a6:	2300      	movs	r3, #0
2400f6a8:	f880 3084 	strb.w	r3, [r0, #132]	@ 0x84
  return HAL_OK;
2400f6ac:	4618      	mov	r0, r3
2400f6ae:	4770      	bx	lr
  __HAL_LOCK(huart);
2400f6b0:	2002      	movs	r0, #2
}
2400f6b2:	4770      	bx	lr

2400f6b4 <HAL_UART_GetState>:
  temp1 = huart->gState;
2400f6b4:	f8d0 2088 	ldr.w	r2, [r0, #136]	@ 0x88
  temp2 = huart->RxState;
2400f6b8:	f8d0 008c 	ldr.w	r0, [r0, #140]	@ 0x8c
}
2400f6bc:	4310      	orrs	r0, r2
2400f6be:	4770      	bx	lr

2400f6c0 <HAL_UART_GetError>:
  return huart->ErrorCode;
2400f6c0:	f8d0 0090 	ldr.w	r0, [r0, #144]	@ 0x90
}
2400f6c4:	4770      	bx	lr

2400f6c6 <UART_SetConfig>:
{
2400f6c6:	b530      	push	{r4, r5, lr}
2400f6c8:	4604      	mov	r4, r0
  if (UART_INSTANCE_LOWPOWER(huart))
2400f6ca:	6803      	ldr	r3, [r0, #0]
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
2400f6cc:	69c0      	ldr	r0, [r0, #28]
{
2400f6ce:	b087      	sub	sp, #28
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
2400f6d0:	6921      	ldr	r1, [r4, #16]
2400f6d2:	68a2      	ldr	r2, [r4, #8]
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
2400f6d4:	681d      	ldr	r5, [r3, #0]
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
2400f6d6:	430a      	orrs	r2, r1
2400f6d8:	6961      	ldr	r1, [r4, #20]
2400f6da:	430a      	orrs	r2, r1
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
2400f6dc:	4993      	ldr	r1, [pc, #588]	@ (2400f92c <UART_SetConfig+0x266>)
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
2400f6de:	4302      	orrs	r2, r0
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
2400f6e0:	4029      	ands	r1, r5
2400f6e2:	430a      	orrs	r2, r1
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
2400f6e4:	68e1      	ldr	r1, [r4, #12]
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
2400f6e6:	601a      	str	r2, [r3, #0]
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
2400f6e8:	685a      	ldr	r2, [r3, #4]
2400f6ea:	f422 5240 	bic.w	r2, r2, #12288	@ 0x3000
2400f6ee:	430a      	orrs	r2, r1
  tmpreg = (uint32_t)huart->Init.HwFlowCtl;
2400f6f0:	69a1      	ldr	r1, [r4, #24]
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
2400f6f2:	605a      	str	r2, [r3, #4]
  if (!(UART_INSTANCE_LOWPOWER(huart)))
2400f6f4:	4a8e      	ldr	r2, [pc, #568]	@ (2400f930 <UART_SetConfig+0x26a>)
2400f6f6:	4293      	cmp	r3, r2
    tmpreg |= huart->Init.OneBitSampling;
2400f6f8:	bf1c      	itt	ne
2400f6fa:	6a22      	ldrne	r2, [r4, #32]
2400f6fc:	4311      	orrne	r1, r2
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
2400f6fe:	689a      	ldr	r2, [r3, #8]
2400f700:	f022 426e 	bic.w	r2, r2, #3992977408	@ 0xee000000
2400f704:	f422 6230 	bic.w	r2, r2, #2816	@ 0xb00
2400f708:	430a      	orrs	r2, r1
  MODIFY_REG(huart->Instance->PRESC, USART_PRESC_PRESCALER, huart->Init.ClockPrescaler);
2400f70a:	6a61      	ldr	r1, [r4, #36]	@ 0x24
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
2400f70c:	609a      	str	r2, [r3, #8]
  MODIFY_REG(huart->Instance->PRESC, USART_PRESC_PRESCALER, huart->Init.ClockPrescaler);
2400f70e:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
2400f710:	f022 020f 	bic.w	r2, r2, #15
2400f714:	430a      	orrs	r2, r1
2400f716:	62da      	str	r2, [r3, #44]	@ 0x2c
  UART_GETCLOCKSOURCE(huart, clocksource);
2400f718:	4a86      	ldr	r2, [pc, #536]	@ (2400f934 <UART_SetConfig+0x26e>)
2400f71a:	4293      	cmp	r3, r2
2400f71c:	d128      	bne.n	2400f770 <UART_SetConfig+0xaa>
2400f71e:	4b86      	ldr	r3, [pc, #536]	@ (2400f938 <UART_SetConfig+0x272>)
2400f720:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
2400f722:	f003 0338 	and.w	r3, r3, #56	@ 0x38
2400f726:	2b18      	cmp	r3, #24
2400f728:	f000 811e 	beq.w	2400f968 <UART_SetConfig+0x2a2>
2400f72c:	d814      	bhi.n	2400f758 <UART_SetConfig+0x92>
2400f72e:	2b08      	cmp	r3, #8
2400f730:	f000 8143 	beq.w	2400f9ba <UART_SetConfig+0x2f4>
2400f734:	2b10      	cmp	r3, #16
2400f736:	f000 80f0 	beq.w	2400f91a <UART_SetConfig+0x254>
2400f73a:	2b00      	cmp	r3, #0
2400f73c:	f000 80e7 	beq.w	2400f90e <UART_SetConfig+0x248>
2400f740:	2380      	movs	r3, #128	@ 0x80
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
2400f742:	f5b0 4f00 	cmp.w	r0, #32768	@ 0x8000
2400f746:	f040 80a7 	bne.w	2400f898 <UART_SetConfig+0x1d2>
    switch (clocksource)
2400f74a:	2b08      	cmp	r3, #8
2400f74c:	d845      	bhi.n	2400f7da <UART_SetConfig+0x114>
        HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
2400f74e:	4668      	mov	r0, sp
2400f750:	f7fb fb04 	bl	2400ad5c <HAL_RCCEx_GetPLL2ClockFreq>
        pclk = pll2_clocks.PLL2_Q_Frequency;
2400f754:	9801      	ldr	r0, [sp, #4]
        break;
2400f756:	e0d7      	b.n	2400f908 <UART_SetConfig+0x242>
  UART_GETCLOCKSOURCE(huart, clocksource);
2400f758:	2b20      	cmp	r3, #32
2400f75a:	f000 80cb 	beq.w	2400f8f4 <UART_SetConfig+0x22e>
2400f75e:	2b28      	cmp	r3, #40	@ 0x28
2400f760:	d1ee      	bne.n	2400f740 <UART_SetConfig+0x7a>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
2400f762:	f5b0 4f00 	cmp.w	r0, #32768	@ 0x8000
2400f766:	f000 810c 	beq.w	2400f982 <UART_SetConfig+0x2bc>
        pclk = (uint32_t) LSE_VALUE;
2400f76a:	f44f 4000 	mov.w	r0, #32768	@ 0x8000
2400f76e:	e0b1      	b.n	2400f8d4 <UART_SetConfig+0x20e>
  UART_GETCLOCKSOURCE(huart, clocksource);
2400f770:	4a72      	ldr	r2, [pc, #456]	@ (2400f93c <UART_SetConfig+0x276>)
2400f772:	4293      	cmp	r3, r2
2400f774:	d114      	bne.n	2400f7a0 <UART_SetConfig+0xda>
2400f776:	4b70      	ldr	r3, [pc, #448]	@ (2400f938 <UART_SetConfig+0x272>)
2400f778:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
2400f77a:	f003 0307 	and.w	r3, r3, #7
2400f77e:	2b05      	cmp	r3, #5
2400f780:	d82b      	bhi.n	2400f7da <UART_SetConfig+0x114>
2400f782:	a201      	add	r2, pc, #4	@ (adr r2, 2400f788 <UART_SetConfig+0xc2>)
2400f784:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
2400f788:	2400f8ff 	.word	0x2400f8ff
2400f78c:	2400f895 	.word	0x2400f895
2400f790:	2400f91b 	.word	0x2400f91b
2400f794:	2400f969 	.word	0x2400f969
2400f798:	2400f8f5 	.word	0x2400f8f5
2400f79c:	2400f763 	.word	0x2400f763
2400f7a0:	4a67      	ldr	r2, [pc, #412]	@ (2400f940 <UART_SetConfig+0x27a>)
2400f7a2:	4293      	cmp	r3, r2
2400f7a4:	d0e7      	beq.n	2400f776 <UART_SetConfig+0xb0>
2400f7a6:	4a67      	ldr	r2, [pc, #412]	@ (2400f944 <UART_SetConfig+0x27e>)
2400f7a8:	4293      	cmp	r3, r2
2400f7aa:	d0e4      	beq.n	2400f776 <UART_SetConfig+0xb0>
2400f7ac:	4a66      	ldr	r2, [pc, #408]	@ (2400f948 <UART_SetConfig+0x282>)
2400f7ae:	4293      	cmp	r3, r2
2400f7b0:	d0e1      	beq.n	2400f776 <UART_SetConfig+0xb0>
2400f7b2:	4a66      	ldr	r2, [pc, #408]	@ (2400f94c <UART_SetConfig+0x286>)
2400f7b4:	4293      	cmp	r3, r2
2400f7b6:	d118      	bne.n	2400f7ea <UART_SetConfig+0x124>
2400f7b8:	4b5f      	ldr	r3, [pc, #380]	@ (2400f938 <UART_SetConfig+0x272>)
2400f7ba:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
2400f7bc:	f003 0338 	and.w	r3, r3, #56	@ 0x38
2400f7c0:	2b18      	cmp	r3, #24
2400f7c2:	f000 80d1 	beq.w	2400f968 <UART_SetConfig+0x2a2>
2400f7c6:	d80a      	bhi.n	2400f7de <UART_SetConfig+0x118>
2400f7c8:	2b08      	cmp	r3, #8
2400f7ca:	f000 80f6 	beq.w	2400f9ba <UART_SetConfig+0x2f4>
2400f7ce:	2b10      	cmp	r3, #16
2400f7d0:	f000 80a3 	beq.w	2400f91a <UART_SetConfig+0x254>
2400f7d4:	2b00      	cmp	r3, #0
2400f7d6:	f000 809a 	beq.w	2400f90e <UART_SetConfig+0x248>
        pclk = (uint32_t) CSI_VALUE;
2400f7da:	2001      	movs	r0, #1
2400f7dc:	e03d      	b.n	2400f85a <UART_SetConfig+0x194>
  UART_GETCLOCKSOURCE(huart, clocksource);
2400f7de:	2b20      	cmp	r3, #32
2400f7e0:	f000 8088 	beq.w	2400f8f4 <UART_SetConfig+0x22e>
2400f7e4:	2b28      	cmp	r3, #40	@ 0x28
2400f7e6:	d0bc      	beq.n	2400f762 <UART_SetConfig+0x9c>
2400f7e8:	e7f7      	b.n	2400f7da <UART_SetConfig+0x114>
2400f7ea:	4a59      	ldr	r2, [pc, #356]	@ (2400f950 <UART_SetConfig+0x28a>)
2400f7ec:	4293      	cmp	r3, r2
2400f7ee:	d0c2      	beq.n	2400f776 <UART_SetConfig+0xb0>
2400f7f0:	4a58      	ldr	r2, [pc, #352]	@ (2400f954 <UART_SetConfig+0x28e>)
2400f7f2:	4293      	cmp	r3, r2
2400f7f4:	d0bf      	beq.n	2400f776 <UART_SetConfig+0xb0>
2400f7f6:	4a4e      	ldr	r2, [pc, #312]	@ (2400f930 <UART_SetConfig+0x26a>)
2400f7f8:	4293      	cmp	r3, r2
2400f7fa:	d1ee      	bne.n	2400f7da <UART_SetConfig+0x114>
2400f7fc:	f502 320e 	add.w	r2, r2, #145408	@ 0x23800
2400f800:	6d93      	ldr	r3, [r2, #88]	@ 0x58
2400f802:	f003 0307 	and.w	r3, r3, #7
2400f806:	2b05      	cmp	r3, #5
2400f808:	d8e7      	bhi.n	2400f7da <UART_SetConfig+0x114>
2400f80a:	e8df f003 	tbb	[pc, r3]
2400f80e:	1f3d      	.short	0x1f3d
2400f810:	4003332e 	.word	0x4003332e
        pclk = (uint32_t) CSI_VALUE;
2400f814:	4850      	ldr	r0, [pc, #320]	@ (2400f958 <UART_SetConfig+0x292>)
      lpuart_ker_ck_pres = (pclk / UARTPrescTable[huart->Init.ClockPrescaler]);
2400f816:	6a62      	ldr	r2, [r4, #36]	@ 0x24
2400f818:	4b50      	ldr	r3, [pc, #320]	@ (2400f95c <UART_SetConfig+0x296>)
2400f81a:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
2400f81e:	6862      	ldr	r2, [r4, #4]
      lpuart_ker_ck_pres = (pclk / UARTPrescTable[huart->Init.ClockPrescaler]);
2400f820:	fbb0 f0f3 	udiv	r0, r0, r3
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
2400f824:	eb02 0342 	add.w	r3, r2, r2, lsl #1
2400f828:	4283      	cmp	r3, r0
2400f82a:	d8d6      	bhi.n	2400f7da <UART_SetConfig+0x114>
2400f82c:	ebb0 3f02 	cmp.w	r0, r2, lsl #12
2400f830:	d8d3      	bhi.n	2400f7da <UART_SetConfig+0x114>
                       (uint32_t)((huart->Init.BaudRate)/2U)) / (huart->Init.BaudRate)) );
2400f832:	0853      	lsrs	r3, r2, #1
        usartdiv = ((uint32_t)((((((uint32_t)(pclk))/(UARTPrescTable[(huart->Init.ClockPrescaler)]))*256U)+ \
2400f834:	eb03 2300 	add.w	r3, r3, r0, lsl #8
2400f838:	fbb3 f3f2 	udiv	r3, r3, r2
        if ((usartdiv >= LPUART_BRR_MIN) && (usartdiv <= LPUART_BRR_MAX))
2400f83c:	4a48      	ldr	r2, [pc, #288]	@ (2400f960 <UART_SetConfig+0x29a>)
2400f83e:	f5a3 7140 	sub.w	r1, r3, #768	@ 0x300
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
2400f842:	4291      	cmp	r1, r2
2400f844:	d8c9      	bhi.n	2400f7da <UART_SetConfig+0x114>
        huart->Instance->BRR = (uint16_t)usartdiv;
2400f846:	6822      	ldr	r2, [r4, #0]
2400f848:	60d3      	str	r3, [r2, #12]
2400f84a:	e005      	b.n	2400f858 <UART_SetConfig+0x192>
        HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
2400f84c:	4668      	mov	r0, sp
2400f84e:	f7fb fa85 	bl	2400ad5c <HAL_RCCEx_GetPLL2ClockFreq>
        pclk = pll2_clocks.PLL2_Q_Frequency;
2400f852:	9801      	ldr	r0, [sp, #4]
    if (pclk != 0U)
2400f854:	2800      	cmp	r0, #0
2400f856:	d1de      	bne.n	2400f816 <UART_SetConfig+0x150>
        pclk = (uint32_t) CSI_VALUE;
2400f858:	2000      	movs	r0, #0
  huart->NbRxDataToProcess = 1;
2400f85a:	f04f 1301 	mov.w	r3, #65537	@ 0x10001
2400f85e:	66a3      	str	r3, [r4, #104]	@ 0x68
  huart->RxISR = NULL;
2400f860:	2300      	movs	r3, #0
  huart->TxISR = NULL;
2400f862:	e9c4 331d 	strd	r3, r3, [r4, #116]	@ 0x74
}
2400f866:	b007      	add	sp, #28
2400f868:	bd30      	pop	{r4, r5, pc}
        HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
2400f86a:	a803      	add	r0, sp, #12
2400f86c:	f7fb fb20 	bl	2400aeb0 <HAL_RCCEx_GetPLL3ClockFreq>
        pclk = pll3_clocks.PLL3_Q_Frequency;
2400f870:	9804      	ldr	r0, [sp, #16]
        break;
2400f872:	e7ef      	b.n	2400f854 <UART_SetConfig+0x18e>
        if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
2400f874:	6813      	ldr	r3, [r2, #0]
2400f876:	483b      	ldr	r0, [pc, #236]	@ (2400f964 <UART_SetConfig+0x29e>)
2400f878:	f013 0f20 	tst.w	r3, #32
2400f87c:	d0cb      	beq.n	2400f816 <UART_SetConfig+0x150>
          pclk = (uint32_t)(HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3U));
2400f87e:	6813      	ldr	r3, [r2, #0]
2400f880:	f3c3 03c1 	ubfx	r3, r3, #3, #2
2400f884:	40d8      	lsrs	r0, r3
    if (pclk != 0U)
2400f886:	e7c6      	b.n	2400f816 <UART_SetConfig+0x150>
        pclk = HAL_RCCEx_GetD3PCLK1Freq();
2400f888:	f7fb fa56 	bl	2400ad38 <HAL_RCCEx_GetD3PCLK1Freq>
        break;
2400f88c:	e7e2      	b.n	2400f854 <UART_SetConfig+0x18e>
  UART_GETCLOCKSOURCE(huart, clocksource);
2400f88e:	f44f 4000 	mov.w	r0, #32768	@ 0x8000
2400f892:	e7c0      	b.n	2400f816 <UART_SetConfig+0x150>
2400f894:	2304      	movs	r3, #4
2400f896:	e754      	b.n	2400f742 <UART_SetConfig+0x7c>
    switch (clocksource)
2400f898:	2b08      	cmp	r3, #8
2400f89a:	d89e      	bhi.n	2400f7da <UART_SetConfig+0x114>
        HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
2400f89c:	4668      	mov	r0, sp
2400f89e:	f7fb fa5d 	bl	2400ad5c <HAL_RCCEx_GetPLL2ClockFreq>
        pclk = pll2_clocks.PLL2_Q_Frequency;
2400f8a2:	9801      	ldr	r0, [sp, #4]
        break;
2400f8a4:	e001      	b.n	2400f8aa <UART_SetConfig+0x1e4>
        pclk = HAL_RCC_GetPCLK1Freq();
2400f8a6:	f7fa fb33 	bl	24009f10 <HAL_RCC_GetPCLK1Freq>
    if (pclk != 0U)
2400f8aa:	2800      	cmp	r0, #0
2400f8ac:	d0d4      	beq.n	2400f858 <UART_SetConfig+0x192>
2400f8ae:	e011      	b.n	2400f8d4 <UART_SetConfig+0x20e>
        pclk = HAL_RCC_GetPCLK2Freq();
2400f8b0:	f7fa fb40 	bl	24009f34 <HAL_RCC_GetPCLK2Freq>
        break;
2400f8b4:	e7f9      	b.n	2400f8aa <UART_SetConfig+0x1e4>
        HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
2400f8b6:	a803      	add	r0, sp, #12
2400f8b8:	f7fb fafa 	bl	2400aeb0 <HAL_RCCEx_GetPLL3ClockFreq>
        pclk = pll3_clocks.PLL3_Q_Frequency;
2400f8bc:	9804      	ldr	r0, [sp, #16]
        break;
2400f8be:	e7f4      	b.n	2400f8aa <UART_SetConfig+0x1e4>
        if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
2400f8c0:	4b1d      	ldr	r3, [pc, #116]	@ (2400f938 <UART_SetConfig+0x272>)
2400f8c2:	4828      	ldr	r0, [pc, #160]	@ (2400f964 <UART_SetConfig+0x29e>)
2400f8c4:	681a      	ldr	r2, [r3, #0]
2400f8c6:	f012 0f20 	tst.w	r2, #32
2400f8ca:	d003      	beq.n	2400f8d4 <UART_SetConfig+0x20e>
          pclk = (uint32_t)(HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3U));
2400f8cc:	681b      	ldr	r3, [r3, #0]
2400f8ce:	f3c3 03c1 	ubfx	r3, r3, #3, #2
2400f8d2:	40d8      	lsrs	r0, r3
      usartdiv = (uint32_t)(UART_DIV_SAMPLING16(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
2400f8d4:	6a61      	ldr	r1, [r4, #36]	@ 0x24
2400f8d6:	4b21      	ldr	r3, [pc, #132]	@ (2400f95c <UART_SetConfig+0x296>)
2400f8d8:	6862      	ldr	r2, [r4, #4]
2400f8da:	f833 3011 	ldrh.w	r3, [r3, r1, lsl #1]
2400f8de:	fbb0 f3f3 	udiv	r3, r0, r3
2400f8e2:	eb03 0352 	add.w	r3, r3, r2, lsr #1
2400f8e6:	fbb3 f3f2 	udiv	r3, r3, r2
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
2400f8ea:	f64f 72ef 	movw	r2, #65519	@ 0xffef
2400f8ee:	f1a3 0110 	sub.w	r1, r3, #16
2400f8f2:	e7a6      	b.n	2400f842 <UART_SetConfig+0x17c>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
2400f8f4:	f5b0 4f00 	cmp.w	r0, #32768	@ 0x8000
2400f8f8:	4817      	ldr	r0, [pc, #92]	@ (2400f958 <UART_SetConfig+0x292>)
2400f8fa:	d1eb      	bne.n	2400f8d4 <UART_SetConfig+0x20e>
2400f8fc:	e041      	b.n	2400f982 <UART_SetConfig+0x2bc>
2400f8fe:	f5b0 4f00 	cmp.w	r0, #32768	@ 0x8000
2400f902:	d1d0      	bne.n	2400f8a6 <UART_SetConfig+0x1e0>
        pclk = HAL_RCC_GetPCLK1Freq();
2400f904:	f7fa fb04 	bl	24009f10 <HAL_RCC_GetPCLK1Freq>
    if (pclk != 0U)
2400f908:	2800      	cmp	r0, #0
2400f90a:	d0a5      	beq.n	2400f858 <UART_SetConfig+0x192>
2400f90c:	e039      	b.n	2400f982 <UART_SetConfig+0x2bc>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
2400f90e:	f5b0 4f00 	cmp.w	r0, #32768	@ 0x8000
2400f912:	d1cd      	bne.n	2400f8b0 <UART_SetConfig+0x1ea>
        pclk = HAL_RCC_GetPCLK2Freq();
2400f914:	f7fa fb0e 	bl	24009f34 <HAL_RCC_GetPCLK2Freq>
        break;
2400f918:	e7f6      	b.n	2400f908 <UART_SetConfig+0x242>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
2400f91a:	f5b0 4f00 	cmp.w	r0, #32768	@ 0x8000
2400f91e:	d1ca      	bne.n	2400f8b6 <UART_SetConfig+0x1f0>
        HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
2400f920:	a803      	add	r0, sp, #12
2400f922:	f7fb fac5 	bl	2400aeb0 <HAL_RCCEx_GetPLL3ClockFreq>
        pclk = pll3_clocks.PLL3_Q_Frequency;
2400f926:	9804      	ldr	r0, [sp, #16]
        break;
2400f928:	e7ee      	b.n	2400f908 <UART_SetConfig+0x242>
2400f92a:	bf00      	nop
2400f92c:	cfff69f3 	.word	0xcfff69f3
2400f930:	58000c00 	.word	0x58000c00
2400f934:	40011000 	.word	0x40011000
2400f938:	58024400 	.word	0x58024400
2400f93c:	40004400 	.word	0x40004400
2400f940:	40004800 	.word	0x40004800
2400f944:	40004c00 	.word	0x40004c00
2400f948:	40005000 	.word	0x40005000
2400f94c:	40011400 	.word	0x40011400
2400f950:	40007800 	.word	0x40007800
2400f954:	40007c00 	.word	0x40007c00
2400f958:	003d0900 	.word	0x003d0900
2400f95c:	240141ac 	.word	0x240141ac
2400f960:	000ffcff 	.word	0x000ffcff
2400f964:	03d09000 	.word	0x03d09000
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
2400f968:	f5b0 4f00 	cmp.w	r0, #32768	@ 0x8000
2400f96c:	d1a8      	bne.n	2400f8c0 <UART_SetConfig+0x1fa>
        if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
2400f96e:	4b15      	ldr	r3, [pc, #84]	@ (2400f9c4 <UART_SetConfig+0x2fe>)
2400f970:	4815      	ldr	r0, [pc, #84]	@ (2400f9c8 <UART_SetConfig+0x302>)
2400f972:	681a      	ldr	r2, [r3, #0]
2400f974:	f012 0f20 	tst.w	r2, #32
2400f978:	d003      	beq.n	2400f982 <UART_SetConfig+0x2bc>
          pclk = (uint32_t)(HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3U));
2400f97a:	681b      	ldr	r3, [r3, #0]
2400f97c:	f3c3 03c1 	ubfx	r3, r3, #3, #2
2400f980:	40d8      	lsrs	r0, r3
      usartdiv = (uint32_t)(UART_DIV_SAMPLING8(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
2400f982:	4b12      	ldr	r3, [pc, #72]	@ (2400f9cc <UART_SetConfig+0x306>)
2400f984:	6a62      	ldr	r2, [r4, #36]	@ 0x24
2400f986:	6861      	ldr	r1, [r4, #4]
2400f988:	f833 2012 	ldrh.w	r2, [r3, r2, lsl #1]
2400f98c:	084b      	lsrs	r3, r1, #1
2400f98e:	fbb0 f2f2 	udiv	r2, r0, r2
2400f992:	eb03 0342 	add.w	r3, r3, r2, lsl #1
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
2400f996:	f64f 72ef 	movw	r2, #65519	@ 0xffef
      usartdiv = (uint32_t)(UART_DIV_SAMPLING8(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
2400f99a:	fbb3 f3f1 	udiv	r3, r3, r1
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
2400f99e:	f1a3 0110 	sub.w	r1, r3, #16
2400f9a2:	4291      	cmp	r1, r2
2400f9a4:	f63f af19 	bhi.w	2400f7da <UART_SetConfig+0x114>
        brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
2400f9a8:	f023 020f 	bic.w	r2, r3, #15
        brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
2400f9ac:	f3c3 0342 	ubfx	r3, r3, #1, #3
        huart->Instance->BRR = brrtemp;
2400f9b0:	6821      	ldr	r1, [r4, #0]
        brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
2400f9b2:	b292      	uxth	r2, r2
        huart->Instance->BRR = brrtemp;
2400f9b4:	4313      	orrs	r3, r2
2400f9b6:	60cb      	str	r3, [r1, #12]
2400f9b8:	e74e      	b.n	2400f858 <UART_SetConfig+0x192>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
2400f9ba:	f5b0 4f00 	cmp.w	r0, #32768	@ 0x8000
2400f9be:	f47f af6d 	bne.w	2400f89c <UART_SetConfig+0x1d6>
2400f9c2:	e6c4      	b.n	2400f74e <UART_SetConfig+0x88>
2400f9c4:	58024400 	.word	0x58024400
2400f9c8:	03d09000 	.word	0x03d09000
2400f9cc:	240141ac 	.word	0x240141ac

2400f9d0 <UART_AdvFeatureConfig>:
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
2400f9d0:	6a83      	ldr	r3, [r0, #40]	@ 0x28
2400f9d2:	07da      	lsls	r2, r3, #31
{
2400f9d4:	b510      	push	{r4, lr}
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
2400f9d6:	d506      	bpl.n	2400f9e6 <UART_AdvFeatureConfig+0x16>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
2400f9d8:	6801      	ldr	r1, [r0, #0]
2400f9da:	6ac4      	ldr	r4, [r0, #44]	@ 0x2c
2400f9dc:	684a      	ldr	r2, [r1, #4]
2400f9de:	f422 3200 	bic.w	r2, r2, #131072	@ 0x20000
2400f9e2:	4322      	orrs	r2, r4
2400f9e4:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
2400f9e6:	079c      	lsls	r4, r3, #30
2400f9e8:	d506      	bpl.n	2400f9f8 <UART_AdvFeatureConfig+0x28>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
2400f9ea:	6801      	ldr	r1, [r0, #0]
2400f9ec:	6b04      	ldr	r4, [r0, #48]	@ 0x30
2400f9ee:	684a      	ldr	r2, [r1, #4]
2400f9f0:	f422 3280 	bic.w	r2, r2, #65536	@ 0x10000
2400f9f4:	4322      	orrs	r2, r4
2400f9f6:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
2400f9f8:	0759      	lsls	r1, r3, #29
2400f9fa:	d506      	bpl.n	2400fa0a <UART_AdvFeatureConfig+0x3a>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
2400f9fc:	6801      	ldr	r1, [r0, #0]
2400f9fe:	6b44      	ldr	r4, [r0, #52]	@ 0x34
2400fa00:	684a      	ldr	r2, [r1, #4]
2400fa02:	f422 2280 	bic.w	r2, r2, #262144	@ 0x40000
2400fa06:	4322      	orrs	r2, r4
2400fa08:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
2400fa0a:	071a      	lsls	r2, r3, #28
2400fa0c:	d506      	bpl.n	2400fa1c <UART_AdvFeatureConfig+0x4c>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
2400fa0e:	6801      	ldr	r1, [r0, #0]
2400fa10:	6b84      	ldr	r4, [r0, #56]	@ 0x38
2400fa12:	684a      	ldr	r2, [r1, #4]
2400fa14:	f422 4200 	bic.w	r2, r2, #32768	@ 0x8000
2400fa18:	4322      	orrs	r2, r4
2400fa1a:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
2400fa1c:	06dc      	lsls	r4, r3, #27
2400fa1e:	d506      	bpl.n	2400fa2e <UART_AdvFeatureConfig+0x5e>
    MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
2400fa20:	6801      	ldr	r1, [r0, #0]
2400fa22:	6bc4      	ldr	r4, [r0, #60]	@ 0x3c
2400fa24:	688a      	ldr	r2, [r1, #8]
2400fa26:	f422 5280 	bic.w	r2, r2, #4096	@ 0x1000
2400fa2a:	4322      	orrs	r2, r4
2400fa2c:	608a      	str	r2, [r1, #8]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
2400fa2e:	0699      	lsls	r1, r3, #26
2400fa30:	d506      	bpl.n	2400fa40 <UART_AdvFeatureConfig+0x70>
    MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
2400fa32:	6801      	ldr	r1, [r0, #0]
2400fa34:	6c04      	ldr	r4, [r0, #64]	@ 0x40
2400fa36:	688a      	ldr	r2, [r1, #8]
2400fa38:	f422 5200 	bic.w	r2, r2, #8192	@ 0x2000
2400fa3c:	4322      	orrs	r2, r4
2400fa3e:	608a      	str	r2, [r1, #8]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
2400fa40:	065a      	lsls	r2, r3, #25
2400fa42:	d510      	bpl.n	2400fa66 <UART_AdvFeatureConfig+0x96>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
2400fa44:	6801      	ldr	r1, [r0, #0]
2400fa46:	6c44      	ldr	r4, [r0, #68]	@ 0x44
2400fa48:	684a      	ldr	r2, [r1, #4]
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
2400fa4a:	f5b4 1f80 	cmp.w	r4, #1048576	@ 0x100000
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
2400fa4e:	f422 1280 	bic.w	r2, r2, #1048576	@ 0x100000
2400fa52:	ea42 0204 	orr.w	r2, r2, r4
2400fa56:	604a      	str	r2, [r1, #4]
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
2400fa58:	d105      	bne.n	2400fa66 <UART_AdvFeatureConfig+0x96>
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
2400fa5a:	684a      	ldr	r2, [r1, #4]
2400fa5c:	6c84      	ldr	r4, [r0, #72]	@ 0x48
2400fa5e:	f422 02c0 	bic.w	r2, r2, #6291456	@ 0x600000
2400fa62:	4322      	orrs	r2, r4
2400fa64:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
2400fa66:	061b      	lsls	r3, r3, #24
2400fa68:	d506      	bpl.n	2400fa78 <UART_AdvFeatureConfig+0xa8>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
2400fa6a:	6802      	ldr	r2, [r0, #0]
2400fa6c:	6cc1      	ldr	r1, [r0, #76]	@ 0x4c
2400fa6e:	6853      	ldr	r3, [r2, #4]
2400fa70:	f423 2300 	bic.w	r3, r3, #524288	@ 0x80000
2400fa74:	430b      	orrs	r3, r1
2400fa76:	6053      	str	r3, [r2, #4]
}
2400fa78:	bd10      	pop	{r4, pc}

2400fa7a <UART_WaitOnFlagUntilTimeout>:
{
2400fa7a:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
2400fa7e:	f8dd 9020 	ldr.w	r9, [sp, #32]
2400fa82:	4604      	mov	r4, r0
2400fa84:	460f      	mov	r7, r1
2400fa86:	4616      	mov	r6, r2
2400fa88:	4698      	mov	r8, r3
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
2400fa8a:	6822      	ldr	r2, [r4, #0]
2400fa8c:	69d3      	ldr	r3, [r2, #28]
2400fa8e:	ea37 0303 	bics.w	r3, r7, r3
2400fa92:	bf0c      	ite	eq
2400fa94:	2301      	moveq	r3, #1
2400fa96:	2300      	movne	r3, #0
2400fa98:	42b3      	cmp	r3, r6
2400fa9a:	d001      	beq.n	2400faa0 <UART_WaitOnFlagUntilTimeout+0x26>
  return HAL_OK;
2400fa9c:	2000      	movs	r0, #0
2400fa9e:	e01e      	b.n	2400fade <UART_WaitOnFlagUntilTimeout+0x64>
    if (Timeout != HAL_MAX_DELAY)
2400faa0:	f1b9 3fff 	cmp.w	r9, #4294967295
2400faa4:	d0f2      	beq.n	2400fa8c <UART_WaitOnFlagUntilTimeout+0x12>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
2400faa6:	f002 f9af 	bl	24011e08 <HAL_GetTick>
2400faaa:	eba0 0008 	sub.w	r0, r0, r8
2400faae:	4548      	cmp	r0, r9
2400fab0:	d825      	bhi.n	2400fafe <UART_WaitOnFlagUntilTimeout+0x84>
2400fab2:	f1b9 0f00 	cmp.w	r9, #0
2400fab6:	d022      	beq.n	2400fafe <UART_WaitOnFlagUntilTimeout+0x84>
      if (READ_BIT(huart->Instance->CR1, USART_CR1_RE) != 0U)
2400fab8:	6820      	ldr	r0, [r4, #0]
2400faba:	6803      	ldr	r3, [r0, #0]
2400fabc:	075a      	lsls	r2, r3, #29
2400fabe:	d5e4      	bpl.n	2400fa8a <UART_WaitOnFlagUntilTimeout+0x10>
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_ORE) == SET)
2400fac0:	69c5      	ldr	r5, [r0, #28]
2400fac2:	f015 0508 	ands.w	r5, r5, #8
2400fac6:	d00c      	beq.n	2400fae2 <UART_WaitOnFlagUntilTimeout+0x68>
           __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF);
2400fac8:	2508      	movs	r5, #8
2400faca:	6205      	str	r5, [r0, #32]
           UART_EndRxTransfer(huart);
2400facc:	4620      	mov	r0, r4
2400face:	f7fe fb51 	bl	2400e174 <UART_EndRxTransfer>
           __HAL_UNLOCK(huart);
2400fad2:	2300      	movs	r3, #0
           return HAL_ERROR;
2400fad4:	2001      	movs	r0, #1
           huart->ErrorCode = HAL_UART_ERROR_ORE;
2400fad6:	f8c4 5090 	str.w	r5, [r4, #144]	@ 0x90
           __HAL_UNLOCK(huart);
2400fada:	f884 3084 	strb.w	r3, [r4, #132]	@ 0x84
}
2400fade:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_RTOF) == SET)
2400fae2:	69c3      	ldr	r3, [r0, #28]
2400fae4:	051b      	lsls	r3, r3, #20
2400fae6:	d5d0      	bpl.n	2400fa8a <UART_WaitOnFlagUntilTimeout+0x10>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
2400fae8:	f44f 6300 	mov.w	r3, #2048	@ 0x800
2400faec:	6203      	str	r3, [r0, #32]
          UART_EndRxTransfer(huart);
2400faee:	4620      	mov	r0, r4
2400faf0:	f7fe fb40 	bl	2400e174 <UART_EndRxTransfer>
          huart->ErrorCode = HAL_UART_ERROR_RTO;
2400faf4:	2320      	movs	r3, #32
          __HAL_UNLOCK(huart);
2400faf6:	f884 5084 	strb.w	r5, [r4, #132]	@ 0x84
          huart->ErrorCode = HAL_UART_ERROR_RTO;
2400fafa:	f8c4 3090 	str.w	r3, [r4, #144]	@ 0x90
        return HAL_TIMEOUT;
2400fafe:	2003      	movs	r0, #3
2400fb00:	e7ed      	b.n	2400fade <UART_WaitOnFlagUntilTimeout+0x64>

2400fb02 <HAL_UART_Transmit>:
{
2400fb02:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
2400fb06:	4698      	mov	r8, r3
  if (huart->gState == HAL_UART_STATE_READY)
2400fb08:	f8d0 3088 	ldr.w	r3, [r0, #136]	@ 0x88
{
2400fb0c:	4604      	mov	r4, r0
2400fb0e:	460e      	mov	r6, r1
  if (huart->gState == HAL_UART_STATE_READY)
2400fb10:	2b20      	cmp	r3, #32
{
2400fb12:	4617      	mov	r7, r2
  if (huart->gState == HAL_UART_STATE_READY)
2400fb14:	d146      	bne.n	2400fba4 <HAL_UART_Transmit+0xa2>
    if ((pData == NULL) || (Size == 0U))
2400fb16:	2900      	cmp	r1, #0
2400fb18:	d046      	beq.n	2400fba8 <HAL_UART_Transmit+0xa6>
2400fb1a:	2a00      	cmp	r2, #0
2400fb1c:	d044      	beq.n	2400fba8 <HAL_UART_Transmit+0xa6>
    huart->gState = HAL_UART_STATE_BUSY_TX;
2400fb1e:	2321      	movs	r3, #33	@ 0x21
    huart->ErrorCode = HAL_UART_ERROR_NONE;
2400fb20:	2500      	movs	r5, #0
2400fb22:	f8c0 5090 	str.w	r5, [r0, #144]	@ 0x90
    huart->gState = HAL_UART_STATE_BUSY_TX;
2400fb26:	f8c0 3088 	str.w	r3, [r0, #136]	@ 0x88
    tickstart = HAL_GetTick();
2400fb2a:	f002 f96d 	bl	24011e08 <HAL_GetTick>
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
2400fb2e:	68a3      	ldr	r3, [r4, #8]
    tickstart = HAL_GetTick();
2400fb30:	4681      	mov	r9, r0
    huart->TxXferSize  = Size;
2400fb32:	f8a4 7054 	strh.w	r7, [r4, #84]	@ 0x54
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
2400fb36:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
    huart->TxXferCount = Size;
2400fb3a:	f8a4 7056 	strh.w	r7, [r4, #86]	@ 0x56
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
2400fb3e:	d103      	bne.n	2400fb48 <HAL_UART_Transmit+0x46>
2400fb40:	6923      	ldr	r3, [r4, #16]
2400fb42:	b90b      	cbnz	r3, 2400fb48 <HAL_UART_Transmit+0x46>
2400fb44:	4635      	mov	r5, r6
      pdata8bits  = NULL;
2400fb46:	461e      	mov	r6, r3
    while (huart->TxXferCount > 0U)
2400fb48:	f8b4 2056 	ldrh.w	r2, [r4, #86]	@ 0x56
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
2400fb4c:	464b      	mov	r3, r9
2400fb4e:	f8cd 8000 	str.w	r8, [sp]
    while (huart->TxXferCount > 0U)
2400fb52:	b292      	uxth	r2, r2
2400fb54:	b942      	cbnz	r2, 2400fb68 <HAL_UART_Transmit+0x66>
    if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
2400fb56:	2140      	movs	r1, #64	@ 0x40
2400fb58:	4620      	mov	r0, r4
2400fb5a:	f7ff ff8e 	bl	2400fa7a <UART_WaitOnFlagUntilTimeout>
2400fb5e:	2320      	movs	r3, #32
2400fb60:	b948      	cbnz	r0, 2400fb76 <HAL_UART_Transmit+0x74>
    huart->gState = HAL_UART_STATE_READY;
2400fb62:	f8c4 3088 	str.w	r3, [r4, #136]	@ 0x88
    return HAL_OK;
2400fb66:	e009      	b.n	2400fb7c <HAL_UART_Transmit+0x7a>
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
2400fb68:	2200      	movs	r2, #0
2400fb6a:	2180      	movs	r1, #128	@ 0x80
2400fb6c:	4620      	mov	r0, r4
2400fb6e:	f7ff ff84 	bl	2400fa7a <UART_WaitOnFlagUntilTimeout>
2400fb72:	b130      	cbz	r0, 2400fb82 <HAL_UART_Transmit+0x80>
        huart->gState = HAL_UART_STATE_READY;
2400fb74:	2320      	movs	r3, #32
        return HAL_TIMEOUT;
2400fb76:	2003      	movs	r0, #3
        huart->gState = HAL_UART_STATE_READY;
2400fb78:	f8c4 3088 	str.w	r3, [r4, #136]	@ 0x88
}
2400fb7c:	b003      	add	sp, #12
2400fb7e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        huart->Instance->TDR = (uint16_t)(*pdata16bits & 0x01FFU);
2400fb82:	6822      	ldr	r2, [r4, #0]
      if (pdata8bits == NULL)
2400fb84:	b95e      	cbnz	r6, 2400fb9e <HAL_UART_Transmit+0x9c>
        huart->Instance->TDR = (uint16_t)(*pdata16bits & 0x01FFU);
2400fb86:	f835 3b02 	ldrh.w	r3, [r5], #2
2400fb8a:	f3c3 0308 	ubfx	r3, r3, #0, #9
        huart->Instance->TDR = (uint8_t)(*pdata8bits & 0xFFU);
2400fb8e:	6293      	str	r3, [r2, #40]	@ 0x28
      huart->TxXferCount--;
2400fb90:	f8b4 2056 	ldrh.w	r2, [r4, #86]	@ 0x56
2400fb94:	3a01      	subs	r2, #1
2400fb96:	b292      	uxth	r2, r2
2400fb98:	f8a4 2056 	strh.w	r2, [r4, #86]	@ 0x56
2400fb9c:	e7d4      	b.n	2400fb48 <HAL_UART_Transmit+0x46>
        huart->Instance->TDR = (uint8_t)(*pdata8bits & 0xFFU);
2400fb9e:	f816 3b01 	ldrb.w	r3, [r6], #1
2400fba2:	e7f4      	b.n	2400fb8e <HAL_UART_Transmit+0x8c>
    return HAL_BUSY;
2400fba4:	2002      	movs	r0, #2
2400fba6:	e7e9      	b.n	2400fb7c <HAL_UART_Transmit+0x7a>
      return  HAL_ERROR;
2400fba8:	2001      	movs	r0, #1
2400fbaa:	e7e7      	b.n	2400fb7c <HAL_UART_Transmit+0x7a>

2400fbac <HAL_UART_Receive>:
{
2400fbac:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
2400fbb0:	4698      	mov	r8, r3
  if (huart->RxState == HAL_UART_STATE_READY)
2400fbb2:	f8d0 308c 	ldr.w	r3, [r0, #140]	@ 0x8c
{
2400fbb6:	4604      	mov	r4, r0
2400fbb8:	460f      	mov	r7, r1
  if (huart->RxState == HAL_UART_STATE_READY)
2400fbba:	2b20      	cmp	r3, #32
{
2400fbbc:	4616      	mov	r6, r2
  if (huart->RxState == HAL_UART_STATE_READY)
2400fbbe:	d15d      	bne.n	2400fc7c <HAL_UART_Receive+0xd0>
    if ((pData == NULL) || (Size == 0U))
2400fbc0:	2900      	cmp	r1, #0
2400fbc2:	d05d      	beq.n	2400fc80 <HAL_UART_Receive+0xd4>
2400fbc4:	2a00      	cmp	r2, #0
2400fbc6:	d05b      	beq.n	2400fc80 <HAL_UART_Receive+0xd4>
    huart->RxState = HAL_UART_STATE_BUSY_RX;
2400fbc8:	2322      	movs	r3, #34	@ 0x22
    huart->ErrorCode = HAL_UART_ERROR_NONE;
2400fbca:	2500      	movs	r5, #0
2400fbcc:	f8c0 5090 	str.w	r5, [r0, #144]	@ 0x90
    huart->RxState = HAL_UART_STATE_BUSY_RX;
2400fbd0:	f8c0 308c 	str.w	r3, [r0, #140]	@ 0x8c
    huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
2400fbd4:	66c5      	str	r5, [r0, #108]	@ 0x6c
    tickstart = HAL_GetTick();
2400fbd6:	f002 f917 	bl	24011e08 <HAL_GetTick>
    UART_MASK_COMPUTATION(huart);
2400fbda:	68a3      	ldr	r3, [r4, #8]
    tickstart = HAL_GetTick();
2400fbdc:	4681      	mov	r9, r0
    huart->RxXferSize  = Size;
2400fbde:	f8a4 605c 	strh.w	r6, [r4, #92]	@ 0x5c
    UART_MASK_COMPUTATION(huart);
2400fbe2:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
    huart->RxXferCount = Size;
2400fbe6:	f8a4 605e 	strh.w	r6, [r4, #94]	@ 0x5e
    UART_MASK_COMPUTATION(huart);
2400fbea:	d10d      	bne.n	2400fc08 <HAL_UART_Receive+0x5c>
2400fbec:	6923      	ldr	r3, [r4, #16]
2400fbee:	b1c3      	cbz	r3, 2400fc22 <HAL_UART_Receive+0x76>
    uhMask = huart->Mask;
2400fbf0:	26ff      	movs	r6, #255	@ 0xff
2400fbf2:	4632      	mov	r2, r6
    UART_MASK_COMPUTATION(huart);
2400fbf4:	f8a4 2060 	strh.w	r2, [r4, #96]	@ 0x60
    while (huart->RxXferCount > 0U)
2400fbf8:	f8b4 005e 	ldrh.w	r0, [r4, #94]	@ 0x5e
2400fbfc:	b280      	uxth	r0, r0
2400fbfe:	b9e8      	cbnz	r0, 2400fc3c <HAL_UART_Receive+0x90>
    huart->RxState = HAL_UART_STATE_READY;
2400fc00:	2320      	movs	r3, #32
2400fc02:	f8c4 308c 	str.w	r3, [r4, #140]	@ 0x8c
    return HAL_OK;
2400fc06:	e026      	b.n	2400fc56 <HAL_UART_Receive+0xaa>
    UART_MASK_COMPUTATION(huart);
2400fc08:	b923      	cbnz	r3, 2400fc14 <HAL_UART_Receive+0x68>
2400fc0a:	6925      	ldr	r5, [r4, #16]
2400fc0c:	b995      	cbnz	r5, 2400fc34 <HAL_UART_Receive+0x88>
2400fc0e:	22ff      	movs	r2, #255	@ 0xff
    uhMask = huart->Mask;
2400fc10:	4616      	mov	r6, r2
2400fc12:	e7ef      	b.n	2400fbf4 <HAL_UART_Receive+0x48>
    UART_MASK_COMPUTATION(huart);
2400fc14:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
2400fc18:	d109      	bne.n	2400fc2e <HAL_UART_Receive+0x82>
2400fc1a:	6923      	ldr	r3, [r4, #16]
2400fc1c:	b153      	cbz	r3, 2400fc34 <HAL_UART_Receive+0x88>
2400fc1e:	223f      	movs	r2, #63	@ 0x3f
2400fc20:	e7f6      	b.n	2400fc10 <HAL_UART_Receive+0x64>
    uhMask = huart->Mask;
2400fc22:	f240 16ff 	movw	r6, #511	@ 0x1ff
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
2400fc26:	463d      	mov	r5, r7
      pdata8bits  = NULL;
2400fc28:	2700      	movs	r7, #0
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
2400fc2a:	4632      	mov	r2, r6
2400fc2c:	e7e2      	b.n	2400fbf4 <HAL_UART_Receive+0x48>
2400fc2e:	462a      	mov	r2, r5
    uhMask = huart->Mask;
2400fc30:	462e      	mov	r6, r5
2400fc32:	e7df      	b.n	2400fbf4 <HAL_UART_Receive+0x48>
2400fc34:	227f      	movs	r2, #127	@ 0x7f
      pdata16bits = NULL;
2400fc36:	461d      	mov	r5, r3
    uhMask = huart->Mask;
2400fc38:	4616      	mov	r6, r2
2400fc3a:	e7db      	b.n	2400fbf4 <HAL_UART_Receive+0x48>
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_RXNE, RESET, tickstart, Timeout) != HAL_OK)
2400fc3c:	464b      	mov	r3, r9
2400fc3e:	2200      	movs	r2, #0
2400fc40:	2120      	movs	r1, #32
2400fc42:	4620      	mov	r0, r4
2400fc44:	f8cd 8000 	str.w	r8, [sp]
2400fc48:	f7ff ff17 	bl	2400fa7a <UART_WaitOnFlagUntilTimeout>
2400fc4c:	b130      	cbz	r0, 2400fc5c <HAL_UART_Receive+0xb0>
        huart->RxState = HAL_UART_STATE_READY;
2400fc4e:	2320      	movs	r3, #32
        return HAL_TIMEOUT;
2400fc50:	2003      	movs	r0, #3
        huart->RxState = HAL_UART_STATE_READY;
2400fc52:	f8c4 308c 	str.w	r3, [r4, #140]	@ 0x8c
}
2400fc56:	b003      	add	sp, #12
2400fc58:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        *pdata16bits = (uint16_t)(huart->Instance->RDR & uhMask);
2400fc5c:	6823      	ldr	r3, [r4, #0]
2400fc5e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
2400fc60:	4033      	ands	r3, r6
      if (pdata8bits == NULL)
2400fc62:	b947      	cbnz	r7, 2400fc76 <HAL_UART_Receive+0xca>
        *pdata16bits = (uint16_t)(huart->Instance->RDR & uhMask);
2400fc64:	f825 3b02 	strh.w	r3, [r5], #2
      huart->RxXferCount--;
2400fc68:	f8b4 305e 	ldrh.w	r3, [r4, #94]	@ 0x5e
2400fc6c:	3b01      	subs	r3, #1
2400fc6e:	b29b      	uxth	r3, r3
2400fc70:	f8a4 305e 	strh.w	r3, [r4, #94]	@ 0x5e
2400fc74:	e7c0      	b.n	2400fbf8 <HAL_UART_Receive+0x4c>
        *pdata8bits = (uint8_t)(huart->Instance->RDR & (uint8_t)uhMask);
2400fc76:	f807 3b01 	strb.w	r3, [r7], #1
        pdata8bits++;
2400fc7a:	e7f5      	b.n	2400fc68 <HAL_UART_Receive+0xbc>
    return HAL_BUSY;
2400fc7c:	2002      	movs	r0, #2
2400fc7e:	e7ea      	b.n	2400fc56 <HAL_UART_Receive+0xaa>
      return  HAL_ERROR;
2400fc80:	2001      	movs	r0, #1
2400fc82:	e7e8      	b.n	2400fc56 <HAL_UART_Receive+0xaa>

2400fc84 <UART_CheckIdleState>:
{
2400fc84:	b573      	push	{r0, r1, r4, r5, r6, lr}
  huart->ErrorCode = HAL_UART_ERROR_NONE;
2400fc86:	2600      	movs	r6, #0
{
2400fc88:	4604      	mov	r4, r0
  huart->ErrorCode = HAL_UART_ERROR_NONE;
2400fc8a:	f8c0 6090 	str.w	r6, [r0, #144]	@ 0x90
  tickstart = HAL_GetTick();
2400fc8e:	f002 f8bb 	bl	24011e08 <HAL_GetTick>
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
2400fc92:	6823      	ldr	r3, [r4, #0]
  tickstart = HAL_GetTick();
2400fc94:	4605      	mov	r5, r0
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
2400fc96:	681b      	ldr	r3, [r3, #0]
2400fc98:	071a      	lsls	r2, r3, #28
2400fc9a:	d51c      	bpl.n	2400fcd6 <UART_CheckIdleState+0x52>
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_TEACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
2400fc9c:	f06f 437e 	mvn.w	r3, #4261412864	@ 0xfe000000
2400fca0:	4632      	mov	r2, r6
2400fca2:	f44f 1100 	mov.w	r1, #2097152	@ 0x200000
2400fca6:	9300      	str	r3, [sp, #0]
2400fca8:	4603      	mov	r3, r0
2400fcaa:	4620      	mov	r0, r4
2400fcac:	f7ff fee5 	bl	2400fa7a <UART_WaitOnFlagUntilTimeout>
2400fcb0:	b188      	cbz	r0, 2400fcd6 <UART_CheckIdleState+0x52>
      ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE_TXFNFIE));
2400fcb2:	6822      	ldr	r2, [r4, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
2400fcb4:	e852 3f00 	ldrex	r3, [r2]
2400fcb8:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
2400fcbc:	e842 3100 	strex	r1, r3, [r2]
2400fcc0:	2900      	cmp	r1, #0
2400fcc2:	d1f6      	bne.n	2400fcb2 <UART_CheckIdleState+0x2e>
      huart->gState = HAL_UART_STATE_READY;
2400fcc4:	2320      	movs	r3, #32
2400fcc6:	f8c4 3088 	str.w	r3, [r4, #136]	@ 0x88
      return HAL_TIMEOUT;
2400fcca:	2003      	movs	r0, #3
      __HAL_UNLOCK(huart);
2400fccc:	2300      	movs	r3, #0
2400fcce:	f884 3084 	strb.w	r3, [r4, #132]	@ 0x84
}
2400fcd2:	b002      	add	sp, #8
2400fcd4:	bd70      	pop	{r4, r5, r6, pc}
  if ((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
2400fcd6:	6823      	ldr	r3, [r4, #0]
2400fcd8:	681b      	ldr	r3, [r3, #0]
2400fcda:	075b      	lsls	r3, r3, #29
2400fcdc:	d524      	bpl.n	2400fd28 <UART_CheckIdleState+0xa4>
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
2400fcde:	f06f 437e 	mvn.w	r3, #4261412864	@ 0xfe000000
2400fce2:	2200      	movs	r2, #0
2400fce4:	f44f 0180 	mov.w	r1, #4194304	@ 0x400000
2400fce8:	4620      	mov	r0, r4
2400fcea:	9300      	str	r3, [sp, #0]
2400fcec:	462b      	mov	r3, r5
2400fcee:	f7ff fec4 	bl	2400fa7a <UART_WaitOnFlagUntilTimeout>
2400fcf2:	b1c8      	cbz	r0, 2400fd28 <UART_CheckIdleState+0xa4>
      ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
2400fcf4:	6822      	ldr	r2, [r4, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
2400fcf6:	e852 3f00 	ldrex	r3, [r2]
2400fcfa:	f423 7390 	bic.w	r3, r3, #288	@ 0x120
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
2400fcfe:	e842 3100 	strex	r1, r3, [r2]
   return(result);
2400fd02:	6822      	ldr	r2, [r4, #0]
2400fd04:	2900      	cmp	r1, #0
2400fd06:	d1f5      	bne.n	2400fcf4 <UART_CheckIdleState+0x70>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
2400fd08:	f102 0308 	add.w	r3, r2, #8
2400fd0c:	e853 3f00 	ldrex	r3, [r3]
      ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
2400fd10:	f023 0301 	bic.w	r3, r3, #1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
2400fd14:	f102 0008 	add.w	r0, r2, #8
2400fd18:	e840 3100 	strex	r1, r3, [r0]
2400fd1c:	2900      	cmp	r1, #0
2400fd1e:	d1f3      	bne.n	2400fd08 <UART_CheckIdleState+0x84>
      huart->RxState = HAL_UART_STATE_READY;
2400fd20:	2320      	movs	r3, #32
2400fd22:	f8c4 308c 	str.w	r3, [r4, #140]	@ 0x8c
      return HAL_TIMEOUT;
2400fd26:	e7d0      	b.n	2400fcca <UART_CheckIdleState+0x46>
  huart->gState = HAL_UART_STATE_READY;
2400fd28:	2320      	movs	r3, #32
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
2400fd2a:	2000      	movs	r0, #0
  huart->gState = HAL_UART_STATE_READY;
2400fd2c:	f8c4 3088 	str.w	r3, [r4, #136]	@ 0x88
  huart->RxState = HAL_UART_STATE_READY;
2400fd30:	f8c4 308c 	str.w	r3, [r4, #140]	@ 0x8c
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
2400fd34:	66e0      	str	r0, [r4, #108]	@ 0x6c
  huart->RxEventType = HAL_UART_RXEVENT_TC;
2400fd36:	6720      	str	r0, [r4, #112]	@ 0x70
  return HAL_OK;
2400fd38:	e7c8      	b.n	2400fccc <UART_CheckIdleState+0x48>

2400fd3a <HAL_UART_Init>:
{
2400fd3a:	b510      	push	{r4, lr}
  if (huart == NULL)
2400fd3c:	4604      	mov	r4, r0
2400fd3e:	b350      	cbz	r0, 2400fd96 <HAL_UART_Init+0x5c>
  if (huart->gState == HAL_UART_STATE_RESET)
2400fd40:	f8d0 3088 	ldr.w	r3, [r0, #136]	@ 0x88
2400fd44:	b91b      	cbnz	r3, 2400fd4e <HAL_UART_Init+0x14>
    huart->Lock = HAL_UNLOCKED;
2400fd46:	f880 3084 	strb.w	r3, [r0, #132]	@ 0x84
    HAL_UART_MspInit(huart);
2400fd4a:	f002 fdf7 	bl	2401293c <HAL_UART_MspInit>
  __HAL_UART_DISABLE(huart);
2400fd4e:	6822      	ldr	r2, [r4, #0]
  huart->gState = HAL_UART_STATE_BUSY;
2400fd50:	2324      	movs	r3, #36	@ 0x24
  if (UART_SetConfig(huart) == HAL_ERROR)
2400fd52:	4620      	mov	r0, r4
  huart->gState = HAL_UART_STATE_BUSY;
2400fd54:	f8c4 3088 	str.w	r3, [r4, #136]	@ 0x88
  __HAL_UART_DISABLE(huart);
2400fd58:	6813      	ldr	r3, [r2, #0]
2400fd5a:	f023 0301 	bic.w	r3, r3, #1
2400fd5e:	6013      	str	r3, [r2, #0]
  if (UART_SetConfig(huart) == HAL_ERROR)
2400fd60:	f7ff fcb1 	bl	2400f6c6 <UART_SetConfig>
2400fd64:	2801      	cmp	r0, #1
2400fd66:	d016      	beq.n	2400fd96 <HAL_UART_Init+0x5c>
  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
2400fd68:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
2400fd6a:	b113      	cbz	r3, 2400fd72 <HAL_UART_Init+0x38>
    UART_AdvFeatureConfig(huart);
2400fd6c:	4620      	mov	r0, r4
2400fd6e:	f7ff fe2f 	bl	2400f9d0 <UART_AdvFeatureConfig>
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
2400fd72:	6823      	ldr	r3, [r4, #0]
  return (UART_CheckIdleState(huart));
2400fd74:	4620      	mov	r0, r4
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
2400fd76:	685a      	ldr	r2, [r3, #4]
2400fd78:	f422 4290 	bic.w	r2, r2, #18432	@ 0x4800
2400fd7c:	605a      	str	r2, [r3, #4]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
2400fd7e:	689a      	ldr	r2, [r3, #8]
2400fd80:	f022 022a 	bic.w	r2, r2, #42	@ 0x2a
2400fd84:	609a      	str	r2, [r3, #8]
  __HAL_UART_ENABLE(huart);
2400fd86:	681a      	ldr	r2, [r3, #0]
2400fd88:	f042 0201 	orr.w	r2, r2, #1
}
2400fd8c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  __HAL_UART_ENABLE(huart);
2400fd90:	601a      	str	r2, [r3, #0]
  return (UART_CheckIdleState(huart));
2400fd92:	f7ff bf77 	b.w	2400fc84 <UART_CheckIdleState>
}
2400fd96:	2001      	movs	r0, #1
2400fd98:	bd10      	pop	{r4, pc}

2400fd9a <HAL_HalfDuplex_Init>:
{
2400fd9a:	b510      	push	{r4, lr}
  if (huart == NULL)
2400fd9c:	4604      	mov	r4, r0
2400fd9e:	b370      	cbz	r0, 2400fdfe <HAL_HalfDuplex_Init+0x64>
  if (huart->gState == HAL_UART_STATE_RESET)
2400fda0:	f8d0 3088 	ldr.w	r3, [r0, #136]	@ 0x88
2400fda4:	b91b      	cbnz	r3, 2400fdae <HAL_HalfDuplex_Init+0x14>
    huart->Lock = HAL_UNLOCKED;
2400fda6:	f880 3084 	strb.w	r3, [r0, #132]	@ 0x84
    HAL_UART_MspInit(huart);
2400fdaa:	f002 fdc7 	bl	2401293c <HAL_UART_MspInit>
  __HAL_UART_DISABLE(huart);
2400fdae:	6822      	ldr	r2, [r4, #0]
  huart->gState = HAL_UART_STATE_BUSY;
2400fdb0:	2324      	movs	r3, #36	@ 0x24
  if (UART_SetConfig(huart) == HAL_ERROR)
2400fdb2:	4620      	mov	r0, r4
  huart->gState = HAL_UART_STATE_BUSY;
2400fdb4:	f8c4 3088 	str.w	r3, [r4, #136]	@ 0x88
  __HAL_UART_DISABLE(huart);
2400fdb8:	6813      	ldr	r3, [r2, #0]
2400fdba:	f023 0301 	bic.w	r3, r3, #1
2400fdbe:	6013      	str	r3, [r2, #0]
  if (UART_SetConfig(huart) == HAL_ERROR)
2400fdc0:	f7ff fc81 	bl	2400f6c6 <UART_SetConfig>
2400fdc4:	2801      	cmp	r0, #1
2400fdc6:	d01a      	beq.n	2400fdfe <HAL_HalfDuplex_Init+0x64>
  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
2400fdc8:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
2400fdca:	b113      	cbz	r3, 2400fdd2 <HAL_HalfDuplex_Init+0x38>
    UART_AdvFeatureConfig(huart);
2400fdcc:	4620      	mov	r0, r4
2400fdce:	f7ff fdff 	bl	2400f9d0 <UART_AdvFeatureConfig>
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
2400fdd2:	6823      	ldr	r3, [r4, #0]
  return (UART_CheckIdleState(huart));
2400fdd4:	4620      	mov	r0, r4
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
2400fdd6:	685a      	ldr	r2, [r3, #4]
2400fdd8:	f422 4290 	bic.w	r2, r2, #18432	@ 0x4800
2400fddc:	605a      	str	r2, [r3, #4]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_IREN | USART_CR3_SCEN));
2400fdde:	689a      	ldr	r2, [r3, #8]
2400fde0:	f022 0222 	bic.w	r2, r2, #34	@ 0x22
2400fde4:	609a      	str	r2, [r3, #8]
  SET_BIT(huart->Instance->CR3, USART_CR3_HDSEL);
2400fde6:	689a      	ldr	r2, [r3, #8]
2400fde8:	f042 0208 	orr.w	r2, r2, #8
2400fdec:	609a      	str	r2, [r3, #8]
  __HAL_UART_ENABLE(huart);
2400fdee:	681a      	ldr	r2, [r3, #0]
2400fdf0:	f042 0201 	orr.w	r2, r2, #1
}
2400fdf4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  __HAL_UART_ENABLE(huart);
2400fdf8:	601a      	str	r2, [r3, #0]
  return (UART_CheckIdleState(huart));
2400fdfa:	f7ff bf43 	b.w	2400fc84 <UART_CheckIdleState>
}
2400fdfe:	2001      	movs	r0, #1
2400fe00:	bd10      	pop	{r4, pc}

2400fe02 <HAL_LIN_Init>:
{
2400fe02:	b538      	push	{r3, r4, r5, lr}
2400fe04:	460d      	mov	r5, r1
  if (huart == NULL)
2400fe06:	4604      	mov	r4, r0
2400fe08:	2800      	cmp	r0, #0
2400fe0a:	d03a      	beq.n	2400fe82 <HAL_LIN_Init+0x80>
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
2400fe0c:	69c3      	ldr	r3, [r0, #28]
2400fe0e:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
2400fe12:	d036      	beq.n	2400fe82 <HAL_LIN_Init+0x80>
  if (huart->Init.WordLength != UART_WORDLENGTH_8B)
2400fe14:	6883      	ldr	r3, [r0, #8]
2400fe16:	2b00      	cmp	r3, #0
2400fe18:	d133      	bne.n	2400fe82 <HAL_LIN_Init+0x80>
  if (huart->gState == HAL_UART_STATE_RESET)
2400fe1a:	f8d0 3088 	ldr.w	r3, [r0, #136]	@ 0x88
2400fe1e:	b91b      	cbnz	r3, 2400fe28 <HAL_LIN_Init+0x26>
    huart->Lock = HAL_UNLOCKED;
2400fe20:	f880 3084 	strb.w	r3, [r0, #132]	@ 0x84
    HAL_UART_MspInit(huart);
2400fe24:	f002 fd8a 	bl	2401293c <HAL_UART_MspInit>
  __HAL_UART_DISABLE(huart);
2400fe28:	6822      	ldr	r2, [r4, #0]
  huart->gState = HAL_UART_STATE_BUSY;
2400fe2a:	2324      	movs	r3, #36	@ 0x24
  if (UART_SetConfig(huart) == HAL_ERROR)
2400fe2c:	4620      	mov	r0, r4
  huart->gState = HAL_UART_STATE_BUSY;
2400fe2e:	f8c4 3088 	str.w	r3, [r4, #136]	@ 0x88
  __HAL_UART_DISABLE(huart);
2400fe32:	6813      	ldr	r3, [r2, #0]
2400fe34:	f023 0301 	bic.w	r3, r3, #1
2400fe38:	6013      	str	r3, [r2, #0]
  if (UART_SetConfig(huart) == HAL_ERROR)
2400fe3a:	f7ff fc44 	bl	2400f6c6 <UART_SetConfig>
2400fe3e:	2801      	cmp	r0, #1
2400fe40:	d01f      	beq.n	2400fe82 <HAL_LIN_Init+0x80>
  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
2400fe42:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
2400fe44:	b113      	cbz	r3, 2400fe4c <HAL_LIN_Init+0x4a>
    UART_AdvFeatureConfig(huart);
2400fe46:	4620      	mov	r0, r4
2400fe48:	f7ff fdc2 	bl	2400f9d0 <UART_AdvFeatureConfig>
  CLEAR_BIT(huart->Instance->CR2, USART_CR2_CLKEN);
2400fe4c:	6823      	ldr	r3, [r4, #0]
  return (UART_CheckIdleState(huart));
2400fe4e:	4620      	mov	r0, r4
  CLEAR_BIT(huart->Instance->CR2, USART_CR2_CLKEN);
2400fe50:	685a      	ldr	r2, [r3, #4]
2400fe52:	f422 6200 	bic.w	r2, r2, #2048	@ 0x800
2400fe56:	605a      	str	r2, [r3, #4]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_HDSEL | USART_CR3_IREN | USART_CR3_SCEN));
2400fe58:	689a      	ldr	r2, [r3, #8]
2400fe5a:	f022 022a 	bic.w	r2, r2, #42	@ 0x2a
2400fe5e:	609a      	str	r2, [r3, #8]
  SET_BIT(huart->Instance->CR2, USART_CR2_LINEN);
2400fe60:	685a      	ldr	r2, [r3, #4]
2400fe62:	f442 4280 	orr.w	r2, r2, #16384	@ 0x4000
2400fe66:	605a      	str	r2, [r3, #4]
  MODIFY_REG(huart->Instance->CR2, USART_CR2_LBDL, BreakDetectLength);
2400fe68:	685a      	ldr	r2, [r3, #4]
2400fe6a:	f022 0220 	bic.w	r2, r2, #32
2400fe6e:	432a      	orrs	r2, r5
2400fe70:	605a      	str	r2, [r3, #4]
  __HAL_UART_ENABLE(huart);
2400fe72:	681a      	ldr	r2, [r3, #0]
2400fe74:	f042 0201 	orr.w	r2, r2, #1
2400fe78:	601a      	str	r2, [r3, #0]
}
2400fe7a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  return (UART_CheckIdleState(huart));
2400fe7e:	f7ff bf01 	b.w	2400fc84 <UART_CheckIdleState>
}
2400fe82:	2001      	movs	r0, #1
2400fe84:	bd38      	pop	{r3, r4, r5, pc}

2400fe86 <HAL_MultiProcessor_Init>:
{
2400fe86:	b570      	push	{r4, r5, r6, lr}
2400fe88:	460e      	mov	r6, r1
2400fe8a:	4615      	mov	r5, r2
  if (huart == NULL)
2400fe8c:	4604      	mov	r4, r0
2400fe8e:	2800      	cmp	r0, #0
2400fe90:	d038      	beq.n	2400ff04 <HAL_MultiProcessor_Init+0x7e>
  if (huart->gState == HAL_UART_STATE_RESET)
2400fe92:	f8d0 3088 	ldr.w	r3, [r0, #136]	@ 0x88
2400fe96:	b91b      	cbnz	r3, 2400fea0 <HAL_MultiProcessor_Init+0x1a>
    huart->Lock = HAL_UNLOCKED;
2400fe98:	f880 3084 	strb.w	r3, [r0, #132]	@ 0x84
    HAL_UART_MspInit(huart);
2400fe9c:	f002 fd4e 	bl	2401293c <HAL_UART_MspInit>
  __HAL_UART_DISABLE(huart);
2400fea0:	6822      	ldr	r2, [r4, #0]
  huart->gState = HAL_UART_STATE_BUSY;
2400fea2:	2324      	movs	r3, #36	@ 0x24
  if (UART_SetConfig(huart) == HAL_ERROR)
2400fea4:	4620      	mov	r0, r4
  huart->gState = HAL_UART_STATE_BUSY;
2400fea6:	f8c4 3088 	str.w	r3, [r4, #136]	@ 0x88
  __HAL_UART_DISABLE(huart);
2400feaa:	6813      	ldr	r3, [r2, #0]
2400feac:	f023 0301 	bic.w	r3, r3, #1
2400feb0:	6013      	str	r3, [r2, #0]
  if (UART_SetConfig(huart) == HAL_ERROR)
2400feb2:	f7ff fc08 	bl	2400f6c6 <UART_SetConfig>
2400feb6:	2801      	cmp	r0, #1
2400feb8:	d024      	beq.n	2400ff04 <HAL_MultiProcessor_Init+0x7e>
  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
2400feba:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
2400febc:	b113      	cbz	r3, 2400fec4 <HAL_MultiProcessor_Init+0x3e>
    UART_AdvFeatureConfig(huart);
2400febe:	4620      	mov	r0, r4
2400fec0:	f7ff fd86 	bl	2400f9d0 <UART_AdvFeatureConfig>
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
2400fec4:	6823      	ldr	r3, [r4, #0]
  if (WakeUpMethod == UART_WAKEUPMETHOD_ADDRESSMARK)
2400fec6:	f5b5 6f00 	cmp.w	r5, #2048	@ 0x800
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
2400feca:	685a      	ldr	r2, [r3, #4]
2400fecc:	f422 4290 	bic.w	r2, r2, #18432	@ 0x4800
2400fed0:	605a      	str	r2, [r3, #4]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
2400fed2:	689a      	ldr	r2, [r3, #8]
2400fed4:	f022 022a 	bic.w	r2, r2, #42	@ 0x2a
2400fed8:	609a      	str	r2, [r3, #8]
  if (WakeUpMethod == UART_WAKEUPMETHOD_ADDRESSMARK)
2400feda:	d105      	bne.n	2400fee8 <HAL_MultiProcessor_Init+0x62>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ADD, ((uint32_t)Address << UART_CR2_ADDRESS_LSB_POS));
2400fedc:	6858      	ldr	r0, [r3, #4]
2400fede:	f020 407f 	bic.w	r0, r0, #4278190080	@ 0xff000000
2400fee2:	ea40 6006 	orr.w	r0, r0, r6, lsl #24
2400fee6:	6058      	str	r0, [r3, #4]
  MODIFY_REG(huart->Instance->CR1, USART_CR1_WAKE, WakeUpMethod);
2400fee8:	6819      	ldr	r1, [r3, #0]
  return (UART_CheckIdleState(huart));
2400feea:	4620      	mov	r0, r4
  MODIFY_REG(huart->Instance->CR1, USART_CR1_WAKE, WakeUpMethod);
2400feec:	f421 6100 	bic.w	r1, r1, #2048	@ 0x800
2400fef0:	4329      	orrs	r1, r5
2400fef2:	6019      	str	r1, [r3, #0]
  __HAL_UART_ENABLE(huart);
2400fef4:	681a      	ldr	r2, [r3, #0]
2400fef6:	f042 0201 	orr.w	r2, r2, #1
}
2400fefa:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  __HAL_UART_ENABLE(huart);
2400fefe:	601a      	str	r2, [r3, #0]
  return (UART_CheckIdleState(huart));
2400ff00:	f7ff bec0 	b.w	2400fc84 <UART_CheckIdleState>
}
2400ff04:	2001      	movs	r0, #1
2400ff06:	bd70      	pop	{r4, r5, r6, pc}

2400ff08 <HAL_MultiProcessor_EnableMuteMode>:
  __HAL_LOCK(huart);
2400ff08:	f890 3084 	ldrb.w	r3, [r0, #132]	@ 0x84
2400ff0c:	2b01      	cmp	r3, #1
2400ff0e:	d013      	beq.n	2400ff38 <HAL_MultiProcessor_EnableMuteMode+0x30>
2400ff10:	2301      	movs	r3, #1
2400ff12:	f880 3084 	strb.w	r3, [r0, #132]	@ 0x84
  huart->gState = HAL_UART_STATE_BUSY;
2400ff16:	2324      	movs	r3, #36	@ 0x24
2400ff18:	f8c0 3088 	str.w	r3, [r0, #136]	@ 0x88
  ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_MME);
2400ff1c:	6802      	ldr	r2, [r0, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
2400ff1e:	e852 3f00 	ldrex	r3, [r2]
2400ff22:	f443 5300 	orr.w	r3, r3, #8192	@ 0x2000
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
2400ff26:	e842 3100 	strex	r1, r3, [r2]
2400ff2a:	2900      	cmp	r1, #0
2400ff2c:	d1f6      	bne.n	2400ff1c <HAL_MultiProcessor_EnableMuteMode+0x14>
  huart->gState = HAL_UART_STATE_READY;
2400ff2e:	2320      	movs	r3, #32
2400ff30:	f8c0 3088 	str.w	r3, [r0, #136]	@ 0x88
  return (UART_CheckIdleState(huart));
2400ff34:	f7ff bea6 	b.w	2400fc84 <UART_CheckIdleState>
}
2400ff38:	2002      	movs	r0, #2
2400ff3a:	4770      	bx	lr

2400ff3c <HAL_MultiProcessor_DisableMuteMode>:
  __HAL_LOCK(huart);
2400ff3c:	f890 3084 	ldrb.w	r3, [r0, #132]	@ 0x84
2400ff40:	2b01      	cmp	r3, #1
2400ff42:	d013      	beq.n	2400ff6c <HAL_MultiProcessor_DisableMuteMode+0x30>
2400ff44:	2301      	movs	r3, #1
2400ff46:	f880 3084 	strb.w	r3, [r0, #132]	@ 0x84
  huart->gState = HAL_UART_STATE_BUSY;
2400ff4a:	2324      	movs	r3, #36	@ 0x24
2400ff4c:	f8c0 3088 	str.w	r3, [r0, #136]	@ 0x88
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_MME);
2400ff50:	6802      	ldr	r2, [r0, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
2400ff52:	e852 3f00 	ldrex	r3, [r2]
2400ff56:	f423 5300 	bic.w	r3, r3, #8192	@ 0x2000
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
2400ff5a:	e842 3100 	strex	r1, r3, [r2]
2400ff5e:	2900      	cmp	r1, #0
2400ff60:	d1f6      	bne.n	2400ff50 <HAL_MultiProcessor_DisableMuteMode+0x14>
  huart->gState = HAL_UART_STATE_READY;
2400ff62:	2320      	movs	r3, #32
2400ff64:	f8c0 3088 	str.w	r3, [r0, #136]	@ 0x88
  return (UART_CheckIdleState(huart));
2400ff68:	f7ff be8c 	b.w	2400fc84 <UART_CheckIdleState>
}
2400ff6c:	2002      	movs	r0, #2
2400ff6e:	4770      	bx	lr

2400ff70 <UART_Start_Receive_IT>:
{
2400ff70:	b530      	push	{r4, r5, lr}
  huart->pRxBuffPtr  = pData;
2400ff72:	6581      	str	r1, [r0, #88]	@ 0x58
  huart->RxISR       = NULL;
2400ff74:	2300      	movs	r3, #0
  UART_MASK_COMPUTATION(huart);
2400ff76:	6881      	ldr	r1, [r0, #8]
  huart->RxXferSize  = Size;
2400ff78:	f8a0 205c 	strh.w	r2, [r0, #92]	@ 0x5c
  UART_MASK_COMPUTATION(huart);
2400ff7c:	f5b1 5f80 	cmp.w	r1, #4096	@ 0x1000
  huart->RxXferCount = Size;
2400ff80:	f8a0 205e 	strh.w	r2, [r0, #94]	@ 0x5e
  huart->RxISR       = NULL;
2400ff84:	6743      	str	r3, [r0, #116]	@ 0x74
  UART_MASK_COMPUTATION(huart);
2400ff86:	d135      	bne.n	2400fff4 <UART_Start_Receive_IT+0x84>
2400ff88:	6903      	ldr	r3, [r0, #16]
2400ff8a:	2b00      	cmp	r3, #0
2400ff8c:	f240 13ff 	movw	r3, #511	@ 0x1ff
2400ff90:	bf18      	it	ne
2400ff92:	23ff      	movne	r3, #255	@ 0xff
2400ff94:	f8a0 3060 	strh.w	r3, [r0, #96]	@ 0x60
  huart->ErrorCode = HAL_UART_ERROR_NONE;
2400ff98:	2300      	movs	r3, #0
2400ff9a:	f8c0 3090 	str.w	r3, [r0, #144]	@ 0x90
  huart->RxState = HAL_UART_STATE_BUSY_RX;
2400ff9e:	2322      	movs	r3, #34	@ 0x22
2400ffa0:	f8c0 308c 	str.w	r3, [r0, #140]	@ 0x8c
  ATOMIC_SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
2400ffa4:	6801      	ldr	r1, [r0, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
2400ffa6:	f101 0308 	add.w	r3, r1, #8
2400ffaa:	e853 3f00 	ldrex	r3, [r3]
2400ffae:	f043 0301 	orr.w	r3, r3, #1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
2400ffb2:	3108      	adds	r1, #8
2400ffb4:	e841 3400 	strex	r4, r3, [r1]
   return(result);
2400ffb8:	6803      	ldr	r3, [r0, #0]
2400ffba:	2c00      	cmp	r4, #0
2400ffbc:	d1f2      	bne.n	2400ffa4 <UART_Start_Receive_IT+0x34>
  if ((huart->FifoMode == UART_FIFOMODE_ENABLE) && (Size >= huart->NbRxDataToProcess))
2400ffbe:	6e45      	ldr	r5, [r0, #100]	@ 0x64
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
2400ffc0:	6884      	ldr	r4, [r0, #8]
  if ((huart->FifoMode == UART_FIFOMODE_ENABLE) && (Size >= huart->NbRxDataToProcess))
2400ffc2:	f1b5 5f00 	cmp.w	r5, #536870912	@ 0x20000000
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
2400ffc6:	6901      	ldr	r1, [r0, #16]
  if ((huart->FifoMode == UART_FIFOMODE_ENABLE) && (Size >= huart->NbRxDataToProcess))
2400ffc8:	d132      	bne.n	24010030 <UART_Start_Receive_IT+0xc0>
2400ffca:	f8b0 5068 	ldrh.w	r5, [r0, #104]	@ 0x68
2400ffce:	4295      	cmp	r5, r2
2400ffd0:	d82e      	bhi.n	24010030 <UART_Start_Receive_IT+0xc0>
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
2400ffd2:	f5b4 5f80 	cmp.w	r4, #4096	@ 0x1000
      huart->RxISR = UART_RxISR_16BIT_FIFOEN;
2400ffd6:	4a24      	ldr	r2, [pc, #144]	@ (24010068 <UART_Start_Receive_IT+0xf8>)
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
2400ffd8:	d103      	bne.n	2400ffe2 <UART_Start_Receive_IT+0x72>
      huart->RxISR = UART_RxISR_16BIT_FIFOEN;
2400ffda:	4c24      	ldr	r4, [pc, #144]	@ (2401006c <UART_Start_Receive_IT+0xfc>)
2400ffdc:	2900      	cmp	r1, #0
2400ffde:	bf08      	it	eq
2400ffe0:	4622      	moveq	r2, r4
2400ffe2:	6742      	str	r2, [r0, #116]	@ 0x74
    if (huart->Init.Parity != UART_PARITY_NONE)
2400ffe4:	b1b1      	cbz	r1, 24010014 <UART_Start_Receive_IT+0xa4>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
2400ffe6:	e853 2f00 	ldrex	r2, [r3]
      ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_PEIE);
2400ffea:	f442 7280 	orr.w	r2, r2, #256	@ 0x100
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
2400ffee:	e843 2100 	strex	r1, r2, [r3]
   return(result);
2400fff2:	e7f7      	b.n	2400ffe4 <UART_Start_Receive_IT+0x74>
  UART_MASK_COMPUTATION(huart);
2400fff4:	b929      	cbnz	r1, 24010002 <UART_Start_Receive_IT+0x92>
2400fff6:	6903      	ldr	r3, [r0, #16]
2400fff8:	2b00      	cmp	r3, #0
2400fffa:	bf14      	ite	ne
2400fffc:	237f      	movne	r3, #127	@ 0x7f
2400fffe:	23ff      	moveq	r3, #255	@ 0xff
24010000:	e7c8      	b.n	2400ff94 <UART_Start_Receive_IT+0x24>
24010002:	f1b1 5f80 	cmp.w	r1, #268435456	@ 0x10000000
24010006:	d1c5      	bne.n	2400ff94 <UART_Start_Receive_IT+0x24>
24010008:	6903      	ldr	r3, [r0, #16]
2401000a:	2b00      	cmp	r3, #0
2401000c:	bf14      	ite	ne
2401000e:	233f      	movne	r3, #63	@ 0x3f
24010010:	237f      	moveq	r3, #127	@ 0x7f
24010012:	e7bf      	b.n	2400ff94 <UART_Start_Receive_IT+0x24>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
24010014:	f103 0208 	add.w	r2, r3, #8
24010018:	e852 2f00 	ldrex	r2, [r2]
    ATOMIC_SET_BIT(huart->Instance->CR3, USART_CR3_RXFTIE);
2401001c:	f042 5280 	orr.w	r2, r2, #268435456	@ 0x10000000
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
24010020:	f103 0008 	add.w	r0, r3, #8
24010024:	e840 2100 	strex	r1, r2, [r0]
24010028:	2900      	cmp	r1, #0
2401002a:	d1f3      	bne.n	24010014 <UART_Start_Receive_IT+0xa4>
}
2401002c:	2000      	movs	r0, #0
2401002e:	bd30      	pop	{r4, r5, pc}
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
24010030:	f5b4 5f80 	cmp.w	r4, #4096	@ 0x1000
      huart->RxISR = UART_RxISR_16BIT;
24010034:	4a0e      	ldr	r2, [pc, #56]	@ (24010070 <UART_Start_Receive_IT+0x100>)
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
24010036:	d103      	bne.n	24010040 <UART_Start_Receive_IT+0xd0>
      huart->RxISR = UART_RxISR_16BIT;
24010038:	4c0e      	ldr	r4, [pc, #56]	@ (24010074 <UART_Start_Receive_IT+0x104>)
2401003a:	2900      	cmp	r1, #0
2401003c:	bf08      	it	eq
2401003e:	4622      	moveq	r2, r4
24010040:	6742      	str	r2, [r0, #116]	@ 0x74
    if (huart->Init.Parity != UART_PARITY_NONE)
24010042:	b141      	cbz	r1, 24010056 <UART_Start_Receive_IT+0xe6>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
24010044:	e853 2f00 	ldrex	r2, [r3]
      ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_PEIE | USART_CR1_RXNEIE_RXFNEIE);
24010048:	f442 7290 	orr.w	r2, r2, #288	@ 0x120
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
2401004c:	e843 2100 	strex	r1, r2, [r3]
24010050:	2900      	cmp	r1, #0
24010052:	d1f7      	bne.n	24010044 <UART_Start_Receive_IT+0xd4>
24010054:	e7ea      	b.n	2401002c <UART_Start_Receive_IT+0xbc>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
24010056:	e853 2f00 	ldrex	r2, [r3]
      ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_RXNEIE_RXFNEIE);
2401005a:	f042 0220 	orr.w	r2, r2, #32
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
2401005e:	e843 2100 	strex	r1, r2, [r3]
24010062:	2900      	cmp	r1, #0
24010064:	d1f7      	bne.n	24010056 <UART_Start_Receive_IT+0xe6>
24010066:	e7e1      	b.n	2401002c <UART_Start_Receive_IT+0xbc>
24010068:	2400f151 	.word	0x2400f151
2401006c:	2400f2f9 	.word	0x2400f2f9
24010070:	2400efc1 	.word	0x2400efc1
24010074:	2400f08d 	.word	0x2400f08d

24010078 <HAL_UART_Receive_IT>:
  if (huart->RxState == HAL_UART_STATE_READY)
24010078:	f8d0 308c 	ldr.w	r3, [r0, #140]	@ 0x8c
2401007c:	2b20      	cmp	r3, #32
{
2401007e:	b430      	push	{r4, r5}
  if (huart->RxState == HAL_UART_STATE_READY)
24010080:	d115      	bne.n	240100ae <HAL_UART_Receive_IT+0x36>
    if ((pData == NULL) || (Size == 0U))
24010082:	b1b9      	cbz	r1, 240100b4 <HAL_UART_Receive_IT+0x3c>
24010084:	b1b2      	cbz	r2, 240100b4 <HAL_UART_Receive_IT+0x3c>
    huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
24010086:	2300      	movs	r3, #0
    if (!(IS_LPUART_INSTANCE(huart->Instance)))
24010088:	6804      	ldr	r4, [r0, #0]
    huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
2401008a:	66c3      	str	r3, [r0, #108]	@ 0x6c
    if (!(IS_LPUART_INSTANCE(huart->Instance)))
2401008c:	4b0a      	ldr	r3, [pc, #40]	@ (240100b8 <HAL_UART_Receive_IT+0x40>)
2401008e:	429c      	cmp	r4, r3
24010090:	d00a      	beq.n	240100a8 <HAL_UART_Receive_IT+0x30>
      if (READ_BIT(huart->Instance->CR2, USART_CR2_RTOEN) != 0U)
24010092:	6863      	ldr	r3, [r4, #4]
24010094:	021b      	lsls	r3, r3, #8
24010096:	d507      	bpl.n	240100a8 <HAL_UART_Receive_IT+0x30>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
24010098:	e854 3f00 	ldrex	r3, [r4]
        ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_RTOIE);
2401009c:	f043 6380 	orr.w	r3, r3, #67108864	@ 0x4000000
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
240100a0:	e844 3500 	strex	r5, r3, [r4]
240100a4:	2d00      	cmp	r5, #0
240100a6:	d1f7      	bne.n	24010098 <HAL_UART_Receive_IT+0x20>
}
240100a8:	bc30      	pop	{r4, r5}
    return (UART_Start_Receive_IT(huart, pData, Size));
240100aa:	f7ff bf61 	b.w	2400ff70 <UART_Start_Receive_IT>
    return HAL_BUSY;
240100ae:	2002      	movs	r0, #2
}
240100b0:	bc30      	pop	{r4, r5}
240100b2:	4770      	bx	lr
      return HAL_ERROR;
240100b4:	2001      	movs	r0, #1
240100b6:	e7fb      	b.n	240100b0 <HAL_UART_Receive_IT+0x38>
240100b8:	58000c00 	.word	0x58000c00

240100bc <UART_Start_Receive_DMA>:
{
240100bc:	b570      	push	{r4, r5, r6, lr}
240100be:	4613      	mov	r3, r2
  huart->RxXferSize = Size;
240100c0:	f8a0 205c 	strh.w	r2, [r0, #92]	@ 0x5c
  huart->ErrorCode = HAL_UART_ERROR_NONE;
240100c4:	2200      	movs	r2, #0
{
240100c6:	4604      	mov	r4, r0
  huart->pRxBuffPtr = pData;
240100c8:	6581      	str	r1, [r0, #88]	@ 0x58
  huart->ErrorCode = HAL_UART_ERROR_NONE;
240100ca:	f8c0 2090 	str.w	r2, [r0, #144]	@ 0x90
  huart->RxState = HAL_UART_STATE_BUSY_RX;
240100ce:	2022      	movs	r0, #34	@ 0x22
    if (HAL_DMA_Start_IT(huart->hdmarx, (uint32_t)&huart->Instance->RDR, (uint32_t)huart->pRxBuffPtr, Size) != HAL_OK)
240100d0:	6825      	ldr	r5, [r4, #0]
  huart->RxState = HAL_UART_STATE_BUSY_RX;
240100d2:	f8c4 008c 	str.w	r0, [r4, #140]	@ 0x8c
  if (huart->hdmarx != NULL)
240100d6:	f8d4 0080 	ldr.w	r0, [r4, #128]	@ 0x80
240100da:	b1a0      	cbz	r0, 24010106 <UART_Start_Receive_DMA+0x4a>
    huart->hdmarx->XferCpltCallback = UART_DMAReceiveCplt;
240100dc:	4e1c      	ldr	r6, [pc, #112]	@ (24010150 <UART_Start_Receive_DMA+0x94>)
240100de:	63c6      	str	r6, [r0, #60]	@ 0x3c
    huart->hdmarx->XferHalfCpltCallback = UART_DMARxHalfCplt;
240100e0:	4e1c      	ldr	r6, [pc, #112]	@ (24010154 <UART_Start_Receive_DMA+0x98>)
240100e2:	6406      	str	r6, [r0, #64]	@ 0x40
    huart->hdmarx->XferErrorCallback = UART_DMAError;
240100e4:	4e1c      	ldr	r6, [pc, #112]	@ (24010158 <UART_Start_Receive_DMA+0x9c>)
    huart->hdmarx->XferAbortCallback = NULL;
240100e6:	e9c0 6213 	strd	r6, r2, [r0, #76]	@ 0x4c
    if (HAL_DMA_Start_IT(huart->hdmarx, (uint32_t)&huart->Instance->RDR, (uint32_t)huart->pRxBuffPtr, Size) != HAL_OK)
240100ea:	460a      	mov	r2, r1
240100ec:	f105 0124 	add.w	r1, r5, #36	@ 0x24
240100f0:	f7f1 fc76 	bl	240019e0 <HAL_DMA_Start_IT>
240100f4:	b138      	cbz	r0, 24010106 <UART_Start_Receive_DMA+0x4a>
      huart->ErrorCode = HAL_UART_ERROR_DMA;
240100f6:	2310      	movs	r3, #16
      return HAL_ERROR;
240100f8:	2001      	movs	r0, #1
      huart->ErrorCode = HAL_UART_ERROR_DMA;
240100fa:	f8c4 3090 	str.w	r3, [r4, #144]	@ 0x90
      huart->RxState = HAL_UART_STATE_READY;
240100fe:	2320      	movs	r3, #32
24010100:	f8c4 308c 	str.w	r3, [r4, #140]	@ 0x8c
}
24010104:	bd70      	pop	{r4, r5, r6, pc}
  if (huart->Init.Parity != UART_PARITY_NONE)
24010106:	6922      	ldr	r2, [r4, #16]
24010108:	6823      	ldr	r3, [r4, #0]
2401010a:	b13a      	cbz	r2, 2401011c <UART_Start_Receive_DMA+0x60>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
2401010c:	e853 2f00 	ldrex	r2, [r3]
    ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_PEIE);
24010110:	f442 7280 	orr.w	r2, r2, #256	@ 0x100
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
24010114:	e843 2100 	strex	r1, r2, [r3]
24010118:	2900      	cmp	r1, #0
2401011a:	d1f7      	bne.n	2401010c <UART_Start_Receive_DMA+0x50>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
2401011c:	f103 0208 	add.w	r2, r3, #8
24010120:	e852 2f00 	ldrex	r2, [r2]
  ATOMIC_SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
24010124:	f042 0201 	orr.w	r2, r2, #1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
24010128:	f103 0008 	add.w	r0, r3, #8
2401012c:	e840 2100 	strex	r1, r2, [r0]
24010130:	2900      	cmp	r1, #0
24010132:	d1f3      	bne.n	2401011c <UART_Start_Receive_DMA+0x60>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
24010134:	f103 0208 	add.w	r2, r3, #8
24010138:	e852 2f00 	ldrex	r2, [r2]
  ATOMIC_SET_BIT(huart->Instance->CR3, USART_CR3_DMAR);
2401013c:	f042 0240 	orr.w	r2, r2, #64	@ 0x40
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
24010140:	f103 0108 	add.w	r1, r3, #8
24010144:	e841 2000 	strex	r0, r2, [r1]
24010148:	2800      	cmp	r0, #0
2401014a:	d1f3      	bne.n	24010134 <UART_Start_Receive_DMA+0x78>
2401014c:	e7da      	b.n	24010104 <UART_Start_Receive_DMA+0x48>
2401014e:	bf00      	nop
24010150:	2400f4bd 	.word	0x2400f4bd
24010154:	2400f49d 	.word	0x2400f49d
24010158:	2400e8b7 	.word	0x2400e8b7

2401015c <HAL_UART_Receive_DMA>:
  if (huart->RxState == HAL_UART_STATE_READY)
2401015c:	f8d0 308c 	ldr.w	r3, [r0, #140]	@ 0x8c
24010160:	2b20      	cmp	r3, #32
{
24010162:	b430      	push	{r4, r5}
  if (huart->RxState == HAL_UART_STATE_READY)
24010164:	d115      	bne.n	24010192 <HAL_UART_Receive_DMA+0x36>
    if ((pData == NULL) || (Size == 0U))
24010166:	b1b9      	cbz	r1, 24010198 <HAL_UART_Receive_DMA+0x3c>
24010168:	b1b2      	cbz	r2, 24010198 <HAL_UART_Receive_DMA+0x3c>
    huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
2401016a:	2300      	movs	r3, #0
    if (!(IS_LPUART_INSTANCE(huart->Instance)))
2401016c:	6804      	ldr	r4, [r0, #0]
    huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
2401016e:	66c3      	str	r3, [r0, #108]	@ 0x6c
    if (!(IS_LPUART_INSTANCE(huart->Instance)))
24010170:	4b0a      	ldr	r3, [pc, #40]	@ (2401019c <HAL_UART_Receive_DMA+0x40>)
24010172:	429c      	cmp	r4, r3
24010174:	d00a      	beq.n	2401018c <HAL_UART_Receive_DMA+0x30>
      if (READ_BIT(huart->Instance->CR2, USART_CR2_RTOEN) != 0U)
24010176:	6863      	ldr	r3, [r4, #4]
24010178:	021b      	lsls	r3, r3, #8
2401017a:	d507      	bpl.n	2401018c <HAL_UART_Receive_DMA+0x30>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
2401017c:	e854 3f00 	ldrex	r3, [r4]
        ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_RTOIE);
24010180:	f043 6380 	orr.w	r3, r3, #67108864	@ 0x4000000
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
24010184:	e844 3500 	strex	r5, r3, [r4]
24010188:	2d00      	cmp	r5, #0
2401018a:	d1f7      	bne.n	2401017c <HAL_UART_Receive_DMA+0x20>
}
2401018c:	bc30      	pop	{r4, r5}
    return (UART_Start_Receive_DMA(huart, pData, Size));
2401018e:	f7ff bf95 	b.w	240100bc <UART_Start_Receive_DMA>
    return HAL_BUSY;
24010192:	2002      	movs	r0, #2
}
24010194:	bc30      	pop	{r4, r5}
24010196:	4770      	bx	lr
      return HAL_ERROR;
24010198:	2001      	movs	r0, #1
2401019a:	e7fb      	b.n	24010194 <HAL_UART_Receive_DMA+0x38>
2401019c:	58000c00 	.word	0x58000c00

240101a0 <UARTEx_SetNbDataToProcess>:
  uint8_t rx_fifo_threshold;
  uint8_t tx_fifo_threshold;
  static const uint8_t numerator[] = {1U, 1U, 1U, 3U, 7U, 1U, 0U, 0U};
  static const uint8_t denominator[] = {8U, 4U, 2U, 4U, 8U, 1U, 1U, 1U};

  if (huart->FifoMode == UART_FIFOMODE_DISABLE)
240101a0:	6e43      	ldr	r3, [r0, #100]	@ 0x64
{
240101a2:	b510      	push	{r4, lr}
  if (huart->FifoMode == UART_FIFOMODE_DISABLE)
240101a4:	b92b      	cbnz	r3, 240101b2 <UARTEx_SetNbDataToProcess+0x12>
  {
    huart->NbTxDataToProcess = 1U;
240101a6:	2301      	movs	r3, #1
240101a8:	f8a0 306a 	strh.w	r3, [r0, #106]	@ 0x6a
    huart->NbRxDataToProcess = 1U;
240101ac:	f8a0 3068 	strh.w	r3, [r0, #104]	@ 0x68
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
                               (uint16_t)denominator[tx_fifo_threshold];
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
                               (uint16_t)denominator[rx_fifo_threshold];
  }
}
240101b0:	bd10      	pop	{r4, pc}
    rx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_RXFTCFG) >> USART_CR3_RXFTCFG_Pos);
240101b2:	6803      	ldr	r3, [r0, #0]
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
240101b4:	4a0a      	ldr	r2, [pc, #40]	@ (240101e0 <UARTEx_SetNbDataToProcess+0x40>)
    rx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_RXFTCFG) >> USART_CR3_RXFTCFG_Pos);
240101b6:	689c      	ldr	r4, [r3, #8]
    tx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_TXFTCFG) >> USART_CR3_TXFTCFG_Pos);
240101b8:	689b      	ldr	r3, [r3, #8]
240101ba:	0f5b      	lsrs	r3, r3, #29
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
240101bc:	5cd1      	ldrb	r1, [r2, r3]
                               (uint16_t)denominator[tx_fifo_threshold];
240101be:	4413      	add	r3, r2
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
240101c0:	0109      	lsls	r1, r1, #4
                               (uint16_t)denominator[tx_fifo_threshold];
240101c2:	7a1b      	ldrb	r3, [r3, #8]
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
240101c4:	fbb1 f3f3 	udiv	r3, r1, r3
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
240101c8:	f3c4 6142 	ubfx	r1, r4, #25, #3
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
240101cc:	f8a0 306a 	strh.w	r3, [r0, #106]	@ 0x6a
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
240101d0:	5c53      	ldrb	r3, [r2, r1]
                               (uint16_t)denominator[rx_fifo_threshold];
240101d2:	440a      	add	r2, r1
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
240101d4:	011b      	lsls	r3, r3, #4
                               (uint16_t)denominator[rx_fifo_threshold];
240101d6:	7a12      	ldrb	r2, [r2, #8]
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
240101d8:	fbb3 f3f2 	udiv	r3, r3, r2
}
240101dc:	e7e6      	b.n	240101ac <UARTEx_SetNbDataToProcess+0xc>
240101de:	bf00      	nop
240101e0:	240141c4 	.word	0x240141c4

240101e4 <HAL_RS485Ex_Init>:
{
240101e4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
240101e6:	460f      	mov	r7, r1
240101e8:	4616      	mov	r6, r2
240101ea:	461d      	mov	r5, r3
  if (huart == NULL)
240101ec:	4604      	mov	r4, r0
240101ee:	2800      	cmp	r0, #0
240101f0:	d035      	beq.n	2401025e <HAL_RS485Ex_Init+0x7a>
  if (huart->gState == HAL_UART_STATE_RESET)
240101f2:	f8d0 3088 	ldr.w	r3, [r0, #136]	@ 0x88
240101f6:	b91b      	cbnz	r3, 24010200 <HAL_RS485Ex_Init+0x1c>
    huart->Lock = HAL_UNLOCKED;
240101f8:	f880 3084 	strb.w	r3, [r0, #132]	@ 0x84
    HAL_UART_MspInit(huart);
240101fc:	f002 fb9e 	bl	2401293c <HAL_UART_MspInit>
  __HAL_UART_DISABLE(huart);
24010200:	6822      	ldr	r2, [r4, #0]
  huart->gState = HAL_UART_STATE_BUSY;
24010202:	2324      	movs	r3, #36	@ 0x24
  if (UART_SetConfig(huart) == HAL_ERROR)
24010204:	4620      	mov	r0, r4
  huart->gState = HAL_UART_STATE_BUSY;
24010206:	f8c4 3088 	str.w	r3, [r4, #136]	@ 0x88
  __HAL_UART_DISABLE(huart);
2401020a:	6813      	ldr	r3, [r2, #0]
2401020c:	f023 0301 	bic.w	r3, r3, #1
24010210:	6013      	str	r3, [r2, #0]
  if (UART_SetConfig(huart) == HAL_ERROR)
24010212:	f7ff fa58 	bl	2400f6c6 <UART_SetConfig>
24010216:	2801      	cmp	r0, #1
24010218:	d021      	beq.n	2401025e <HAL_RS485Ex_Init+0x7a>
  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
2401021a:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
2401021c:	b113      	cbz	r3, 24010224 <HAL_RS485Ex_Init+0x40>
    UART_AdvFeatureConfig(huart);
2401021e:	4620      	mov	r0, r4
24010220:	f7ff fbd6 	bl	2400f9d0 <UART_AdvFeatureConfig>
  SET_BIT(huart->Instance->CR3, USART_CR3_DEM);
24010224:	6823      	ldr	r3, [r4, #0]
  temp |= (DeassertionTime << UART_CR1_DEDT_ADDRESS_LSB_POS);
24010226:	042d      	lsls	r5, r5, #16
  SET_BIT(huart->Instance->CR3, USART_CR3_DEM);
24010228:	689a      	ldr	r2, [r3, #8]
  temp |= (DeassertionTime << UART_CR1_DEDT_ADDRESS_LSB_POS);
2401022a:	ea45 5546 	orr.w	r5, r5, r6, lsl #21
  SET_BIT(huart->Instance->CR3, USART_CR3_DEM);
2401022e:	f442 4280 	orr.w	r2, r2, #16384	@ 0x4000
24010232:	609a      	str	r2, [r3, #8]
  MODIFY_REG(huart->Instance->CR3, USART_CR3_DEP, Polarity);
24010234:	6898      	ldr	r0, [r3, #8]
24010236:	f420 4000 	bic.w	r0, r0, #32768	@ 0x8000
2401023a:	4338      	orrs	r0, r7
2401023c:	6098      	str	r0, [r3, #8]
  return (UART_CheckIdleState(huart));
2401023e:	4620      	mov	r0, r4
  MODIFY_REG(huart->Instance->CR1, (USART_CR1_DEDT | USART_CR1_DEAT), temp);
24010240:	681a      	ldr	r2, [r3, #0]
24010242:	f022 727f 	bic.w	r2, r2, #66846720	@ 0x3fc0000
24010246:	f422 3240 	bic.w	r2, r2, #196608	@ 0x30000
2401024a:	4315      	orrs	r5, r2
2401024c:	601d      	str	r5, [r3, #0]
  __HAL_UART_ENABLE(huart);
2401024e:	681a      	ldr	r2, [r3, #0]
24010250:	f042 0201 	orr.w	r2, r2, #1
24010254:	601a      	str	r2, [r3, #0]
}
24010256:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  return (UART_CheckIdleState(huart));
2401025a:	f7ff bd13 	b.w	2400fc84 <UART_CheckIdleState>
}
2401025e:	2001      	movs	r0, #1
24010260:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

24010262 <HAL_UARTEx_WakeupCallback>:
}
24010262:	4770      	bx	lr

24010264 <HAL_UARTEx_RxFifoFullCallback>:
__weak void HAL_UARTEx_RxFifoFullCallback(UART_HandleTypeDef *huart)
24010264:	4770      	bx	lr

24010266 <HAL_UARTEx_TxFifoEmptyCallback>:
__weak void HAL_UARTEx_TxFifoEmptyCallback(UART_HandleTypeDef *huart)
24010266:	4770      	bx	lr

24010268 <HAL_MultiProcessorEx_AddressLength_Set>:
  if (huart == NULL)
24010268:	b190      	cbz	r0, 24010290 <HAL_MultiProcessorEx_AddressLength_Set+0x28>
  __HAL_UART_DISABLE(huart);
2401026a:	6803      	ldr	r3, [r0, #0]
  huart->gState = HAL_UART_STATE_BUSY;
2401026c:	2224      	movs	r2, #36	@ 0x24
2401026e:	f8c0 2088 	str.w	r2, [r0, #136]	@ 0x88
  __HAL_UART_DISABLE(huart);
24010272:	681a      	ldr	r2, [r3, #0]
24010274:	f022 0201 	bic.w	r2, r2, #1
24010278:	601a      	str	r2, [r3, #0]
  MODIFY_REG(huart->Instance->CR2, USART_CR2_ADDM7, AddressLength);
2401027a:	685a      	ldr	r2, [r3, #4]
2401027c:	f022 0210 	bic.w	r2, r2, #16
24010280:	4311      	orrs	r1, r2
24010282:	6059      	str	r1, [r3, #4]
  __HAL_UART_ENABLE(huart);
24010284:	681a      	ldr	r2, [r3, #0]
24010286:	f042 0201 	orr.w	r2, r2, #1
2401028a:	601a      	str	r2, [r3, #0]
  return (UART_CheckIdleState(huart));
2401028c:	f7ff bcfa 	b.w	2400fc84 <UART_CheckIdleState>
}
24010290:	2001      	movs	r0, #1
24010292:	4770      	bx	lr

24010294 <HAL_UARTEx_StopModeWakeUpSourceConfig>:
{
24010294:	b51f      	push	{r0, r1, r2, r3, r4, lr}
24010296:	ab04      	add	r3, sp, #16
24010298:	4604      	mov	r4, r0
2401029a:	e903 0006 	stmdb	r3, {r1, r2}
  __HAL_LOCK(huart);
2401029e:	f890 3084 	ldrb.w	r3, [r0, #132]	@ 0x84
240102a2:	2b01      	cmp	r3, #1
240102a4:	d03a      	beq.n	2401031c <HAL_UARTEx_StopModeWakeUpSourceConfig+0x88>
240102a6:	2301      	movs	r3, #1
240102a8:	f880 3084 	strb.w	r3, [r0, #132]	@ 0x84
  huart->gState = HAL_UART_STATE_BUSY;
240102ac:	2324      	movs	r3, #36	@ 0x24
240102ae:	f8c0 3088 	str.w	r3, [r0, #136]	@ 0x88
  __HAL_UART_DISABLE(huart);
240102b2:	6803      	ldr	r3, [r0, #0]
240102b4:	681a      	ldr	r2, [r3, #0]
240102b6:	f022 0201 	bic.w	r2, r2, #1
240102ba:	601a      	str	r2, [r3, #0]
  MODIFY_REG(huart->Instance->CR3, USART_CR3_WUS, WakeUpSelection.WakeUpEvent);
240102bc:	689a      	ldr	r2, [r3, #8]
240102be:	f422 1240 	bic.w	r2, r2, #3145728	@ 0x300000
240102c2:	430a      	orrs	r2, r1
240102c4:	609a      	str	r2, [r3, #8]
  if (WakeUpSelection.WakeUpEvent == UART_WAKEUP_ON_ADDRESS)
240102c6:	b971      	cbnz	r1, 240102e6 <HAL_UARTEx_StopModeWakeUpSourceConfig+0x52>
  MODIFY_REG(huart->Instance->CR2, USART_CR2_ADDM7, WakeUpSelection.AddressLength);
240102c8:	685a      	ldr	r2, [r3, #4]
240102ca:	f8bd 000c 	ldrh.w	r0, [sp, #12]
240102ce:	f022 0210 	bic.w	r2, r2, #16
240102d2:	f89d 100e 	ldrb.w	r1, [sp, #14]
240102d6:	4302      	orrs	r2, r0
240102d8:	605a      	str	r2, [r3, #4]
  MODIFY_REG(huart->Instance->CR2, USART_CR2_ADD, ((uint32_t)WakeUpSelection.Address << UART_CR2_ADDRESS_LSB_POS));
240102da:	685a      	ldr	r2, [r3, #4]
240102dc:	f022 427f 	bic.w	r2, r2, #4278190080	@ 0xff000000
240102e0:	ea42 6201 	orr.w	r2, r2, r1, lsl #24
240102e4:	605a      	str	r2, [r3, #4]
  __HAL_UART_ENABLE(huart);
240102e6:	681a      	ldr	r2, [r3, #0]
240102e8:	f042 0201 	orr.w	r2, r2, #1
240102ec:	601a      	str	r2, [r3, #0]
  tickstart = HAL_GetTick();
240102ee:	f001 fd8b 	bl	24011e08 <HAL_GetTick>
  if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
240102f2:	f06f 427e 	mvn.w	r2, #4261412864	@ 0xfe000000
  tickstart = HAL_GetTick();
240102f6:	4603      	mov	r3, r0
  if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
240102f8:	f44f 0180 	mov.w	r1, #4194304	@ 0x400000
240102fc:	9200      	str	r2, [sp, #0]
240102fe:	4620      	mov	r0, r4
24010300:	2200      	movs	r2, #0
24010302:	f7ff fbba 	bl	2400fa7a <UART_WaitOnFlagUntilTimeout>
24010306:	b938      	cbnz	r0, 24010318 <HAL_UARTEx_StopModeWakeUpSourceConfig+0x84>
    huart->gState = HAL_UART_STATE_READY;
24010308:	2320      	movs	r3, #32
2401030a:	f8c4 3088 	str.w	r3, [r4, #136]	@ 0x88
  __HAL_UNLOCK(huart);
2401030e:	2300      	movs	r3, #0
24010310:	f884 3084 	strb.w	r3, [r4, #132]	@ 0x84
}
24010314:	b004      	add	sp, #16
24010316:	bd10      	pop	{r4, pc}
    status = HAL_TIMEOUT;
24010318:	2003      	movs	r0, #3
2401031a:	e7f8      	b.n	2401030e <HAL_UARTEx_StopModeWakeUpSourceConfig+0x7a>
  __HAL_LOCK(huart);
2401031c:	2002      	movs	r0, #2
2401031e:	e7f9      	b.n	24010314 <HAL_UARTEx_StopModeWakeUpSourceConfig+0x80>

24010320 <HAL_UARTEx_EnableStopMode>:
  __HAL_LOCK(huart);
24010320:	f890 3084 	ldrb.w	r3, [r0, #132]	@ 0x84
24010324:	2b01      	cmp	r3, #1
24010326:	d00f      	beq.n	24010348 <HAL_UARTEx_EnableStopMode+0x28>
24010328:	2301      	movs	r3, #1
2401032a:	f880 3084 	strb.w	r3, [r0, #132]	@ 0x84
  ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_UESM);
2401032e:	6801      	ldr	r1, [r0, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
24010330:	e851 2f00 	ldrex	r2, [r1]
24010334:	f042 0202 	orr.w	r2, r2, #2
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
24010338:	e841 2300 	strex	r3, r2, [r1]
2401033c:	2b00      	cmp	r3, #0
2401033e:	d1f6      	bne.n	2401032e <HAL_UARTEx_EnableStopMode+0xe>
  __HAL_UNLOCK(huart);
24010340:	f880 3084 	strb.w	r3, [r0, #132]	@ 0x84
  return HAL_OK;
24010344:	4618      	mov	r0, r3
24010346:	4770      	bx	lr
  __HAL_LOCK(huart);
24010348:	2002      	movs	r0, #2
}
2401034a:	4770      	bx	lr

2401034c <HAL_UARTEx_DisableStopMode>:
  __HAL_LOCK(huart);
2401034c:	f890 3084 	ldrb.w	r3, [r0, #132]	@ 0x84
24010350:	2b01      	cmp	r3, #1
24010352:	d00f      	beq.n	24010374 <HAL_UARTEx_DisableStopMode+0x28>
24010354:	2301      	movs	r3, #1
24010356:	f880 3084 	strb.w	r3, [r0, #132]	@ 0x84
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_UESM);
2401035a:	6801      	ldr	r1, [r0, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
2401035c:	e851 2f00 	ldrex	r2, [r1]
24010360:	f022 0202 	bic.w	r2, r2, #2
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
24010364:	e841 2300 	strex	r3, r2, [r1]
24010368:	2b00      	cmp	r3, #0
2401036a:	d1f6      	bne.n	2401035a <HAL_UARTEx_DisableStopMode+0xe>
  __HAL_UNLOCK(huart);
2401036c:	f880 3084 	strb.w	r3, [r0, #132]	@ 0x84
  return HAL_OK;
24010370:	4618      	mov	r0, r3
24010372:	4770      	bx	lr
  __HAL_LOCK(huart);
24010374:	2002      	movs	r0, #2
}
24010376:	4770      	bx	lr

24010378 <HAL_UARTEx_EnableFifoMode>:
{
24010378:	b510      	push	{r4, lr}
  __HAL_LOCK(huart);
2401037a:	f890 3084 	ldrb.w	r3, [r0, #132]	@ 0x84
{
2401037e:	4604      	mov	r4, r0
  __HAL_LOCK(huart);
24010380:	2b01      	cmp	r3, #1
24010382:	d017      	beq.n	240103b4 <HAL_UARTEx_EnableFifoMode+0x3c>
  huart->gState = HAL_UART_STATE_BUSY;
24010384:	2324      	movs	r3, #36	@ 0x24
24010386:	f8c0 3088 	str.w	r3, [r0, #136]	@ 0x88
  tmpcr1 = READ_REG(huart->Instance->CR1);
2401038a:	6803      	ldr	r3, [r0, #0]
2401038c:	681a      	ldr	r2, [r3, #0]
  __HAL_UART_DISABLE(huart);
2401038e:	6819      	ldr	r1, [r3, #0]
  SET_BIT(tmpcr1, USART_CR1_FIFOEN);
24010390:	f042 5200 	orr.w	r2, r2, #536870912	@ 0x20000000
  __HAL_UART_DISABLE(huart);
24010394:	f021 0101 	bic.w	r1, r1, #1
24010398:	6019      	str	r1, [r3, #0]
  huart->FifoMode = UART_FIFOMODE_ENABLE;
2401039a:	f04f 5100 	mov.w	r1, #536870912	@ 0x20000000
2401039e:	6641      	str	r1, [r0, #100]	@ 0x64
  WRITE_REG(huart->Instance->CR1, tmpcr1);
240103a0:	601a      	str	r2, [r3, #0]
  UARTEx_SetNbDataToProcess(huart);
240103a2:	f7ff fefd 	bl	240101a0 <UARTEx_SetNbDataToProcess>
  huart->gState = HAL_UART_STATE_READY;
240103a6:	2320      	movs	r3, #32
240103a8:	f8c0 3088 	str.w	r3, [r0, #136]	@ 0x88
  __HAL_UNLOCK(huart);
240103ac:	2000      	movs	r0, #0
240103ae:	f884 0084 	strb.w	r0, [r4, #132]	@ 0x84
}
240103b2:	bd10      	pop	{r4, pc}
  __HAL_LOCK(huart);
240103b4:	2002      	movs	r0, #2
240103b6:	e7fc      	b.n	240103b2 <HAL_UARTEx_EnableFifoMode+0x3a>

240103b8 <HAL_UARTEx_DisableFifoMode>:
  __HAL_LOCK(huart);
240103b8:	f890 3084 	ldrb.w	r3, [r0, #132]	@ 0x84
240103bc:	2b01      	cmp	r3, #1
240103be:	d014      	beq.n	240103ea <HAL_UARTEx_DisableFifoMode+0x32>
  tmpcr1 = READ_REG(huart->Instance->CR1);
240103c0:	6802      	ldr	r2, [r0, #0]
  huart->gState = HAL_UART_STATE_BUSY;
240103c2:	2324      	movs	r3, #36	@ 0x24
240103c4:	f8c0 3088 	str.w	r3, [r0, #136]	@ 0x88
  tmpcr1 = READ_REG(huart->Instance->CR1);
240103c8:	6811      	ldr	r1, [r2, #0]
  __HAL_UART_DISABLE(huart);
240103ca:	6813      	ldr	r3, [r2, #0]
  CLEAR_BIT(tmpcr1, USART_CR1_FIFOEN);
240103cc:	f021 5100 	bic.w	r1, r1, #536870912	@ 0x20000000
  __HAL_UART_DISABLE(huart);
240103d0:	f023 0301 	bic.w	r3, r3, #1
240103d4:	6013      	str	r3, [r2, #0]
  huart->FifoMode = UART_FIFOMODE_DISABLE;
240103d6:	2300      	movs	r3, #0
240103d8:	6643      	str	r3, [r0, #100]	@ 0x64
  WRITE_REG(huart->Instance->CR1, tmpcr1);
240103da:	6011      	str	r1, [r2, #0]
  huart->gState = HAL_UART_STATE_READY;
240103dc:	2220      	movs	r2, #32
  __HAL_UNLOCK(huart);
240103de:	f880 3084 	strb.w	r3, [r0, #132]	@ 0x84
  huart->gState = HAL_UART_STATE_READY;
240103e2:	f8c0 2088 	str.w	r2, [r0, #136]	@ 0x88
  return HAL_OK;
240103e6:	4618      	mov	r0, r3
240103e8:	4770      	bx	lr
  __HAL_LOCK(huart);
240103ea:	2002      	movs	r0, #2
}
240103ec:	4770      	bx	lr

240103ee <HAL_UARTEx_SetTxFifoThreshold>:
{
240103ee:	b570      	push	{r4, r5, r6, lr}
  __HAL_LOCK(huart);
240103f0:	f890 3084 	ldrb.w	r3, [r0, #132]	@ 0x84
{
240103f4:	4604      	mov	r4, r0
  __HAL_LOCK(huart);
240103f6:	2b01      	cmp	r3, #1
240103f8:	d017      	beq.n	2401042a <HAL_UARTEx_SetTxFifoThreshold+0x3c>
  tmpcr1 = READ_REG(huart->Instance->CR1);
240103fa:	6805      	ldr	r5, [r0, #0]
  huart->gState = HAL_UART_STATE_BUSY;
240103fc:	2324      	movs	r3, #36	@ 0x24
240103fe:	f8c0 3088 	str.w	r3, [r0, #136]	@ 0x88
  tmpcr1 = READ_REG(huart->Instance->CR1);
24010402:	682e      	ldr	r6, [r5, #0]
  __HAL_UART_DISABLE(huart);
24010404:	682b      	ldr	r3, [r5, #0]
24010406:	f023 0301 	bic.w	r3, r3, #1
2401040a:	602b      	str	r3, [r5, #0]
  MODIFY_REG(huart->Instance->CR3, USART_CR3_TXFTCFG, Threshold);
2401040c:	68ab      	ldr	r3, [r5, #8]
2401040e:	f023 4360 	bic.w	r3, r3, #3758096384	@ 0xe0000000
24010412:	4319      	orrs	r1, r3
24010414:	60a9      	str	r1, [r5, #8]
  UARTEx_SetNbDataToProcess(huart);
24010416:	f7ff fec3 	bl	240101a0 <UARTEx_SetNbDataToProcess>
  huart->gState = HAL_UART_STATE_READY;
2401041a:	2320      	movs	r3, #32
  WRITE_REG(huart->Instance->CR1, tmpcr1);
2401041c:	602e      	str	r6, [r5, #0]
  huart->gState = HAL_UART_STATE_READY;
2401041e:	f8c0 3088 	str.w	r3, [r0, #136]	@ 0x88
  __HAL_UNLOCK(huart);
24010422:	2000      	movs	r0, #0
24010424:	f884 0084 	strb.w	r0, [r4, #132]	@ 0x84
}
24010428:	bd70      	pop	{r4, r5, r6, pc}
  __HAL_LOCK(huart);
2401042a:	2002      	movs	r0, #2
2401042c:	e7fc      	b.n	24010428 <HAL_UARTEx_SetTxFifoThreshold+0x3a>

2401042e <HAL_UARTEx_SetRxFifoThreshold>:
{
2401042e:	b570      	push	{r4, r5, r6, lr}
  __HAL_LOCK(huart);
24010430:	f890 3084 	ldrb.w	r3, [r0, #132]	@ 0x84
{
24010434:	4604      	mov	r4, r0
  __HAL_LOCK(huart);
24010436:	2b01      	cmp	r3, #1
24010438:	d017      	beq.n	2401046a <HAL_UARTEx_SetRxFifoThreshold+0x3c>
  tmpcr1 = READ_REG(huart->Instance->CR1);
2401043a:	6805      	ldr	r5, [r0, #0]
  huart->gState = HAL_UART_STATE_BUSY;
2401043c:	2324      	movs	r3, #36	@ 0x24
2401043e:	f8c0 3088 	str.w	r3, [r0, #136]	@ 0x88
  tmpcr1 = READ_REG(huart->Instance->CR1);
24010442:	682e      	ldr	r6, [r5, #0]
  __HAL_UART_DISABLE(huart);
24010444:	682b      	ldr	r3, [r5, #0]
24010446:	f023 0301 	bic.w	r3, r3, #1
2401044a:	602b      	str	r3, [r5, #0]
  MODIFY_REG(huart->Instance->CR3, USART_CR3_RXFTCFG, Threshold);
2401044c:	68ab      	ldr	r3, [r5, #8]
2401044e:	f023 6360 	bic.w	r3, r3, #234881024	@ 0xe000000
24010452:	4319      	orrs	r1, r3
24010454:	60a9      	str	r1, [r5, #8]
  UARTEx_SetNbDataToProcess(huart);
24010456:	f7ff fea3 	bl	240101a0 <UARTEx_SetNbDataToProcess>
  huart->gState = HAL_UART_STATE_READY;
2401045a:	2320      	movs	r3, #32
  WRITE_REG(huart->Instance->CR1, tmpcr1);
2401045c:	602e      	str	r6, [r5, #0]
  huart->gState = HAL_UART_STATE_READY;
2401045e:	f8c0 3088 	str.w	r3, [r0, #136]	@ 0x88
  __HAL_UNLOCK(huart);
24010462:	2000      	movs	r0, #0
24010464:	f884 0084 	strb.w	r0, [r4, #132]	@ 0x84
}
24010468:	bd70      	pop	{r4, r5, r6, pc}
  __HAL_LOCK(huart);
2401046a:	2002      	movs	r0, #2
2401046c:	e7fc      	b.n	24010468 <HAL_UARTEx_SetRxFifoThreshold+0x3a>

2401046e <HAL_UARTEx_ReceiveToIdle>:
{
2401046e:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
24010472:	4698      	mov	r8, r3
  if (huart->RxState == HAL_UART_STATE_READY)
24010474:	f8d0 308c 	ldr.w	r3, [r0, #140]	@ 0x8c
{
24010478:	4604      	mov	r4, r0
2401047a:	460f      	mov	r7, r1
  if (huart->RxState == HAL_UART_STATE_READY)
2401047c:	2b20      	cmp	r3, #32
{
2401047e:	4616      	mov	r6, r2
24010480:	f8dd 9028 	ldr.w	r9, [sp, #40]	@ 0x28
  if (huart->RxState == HAL_UART_STATE_READY)
24010484:	f040 8082 	bne.w	2401058c <HAL_UARTEx_ReceiveToIdle+0x11e>
    if ((pData == NULL) || (Size == 0U))
24010488:	2900      	cmp	r1, #0
2401048a:	f000 8081 	beq.w	24010590 <HAL_UARTEx_ReceiveToIdle+0x122>
2401048e:	2a00      	cmp	r2, #0
24010490:	d07e      	beq.n	24010590 <HAL_UARTEx_ReceiveToIdle+0x122>
    huart->ErrorCode = HAL_UART_ERROR_NONE;
24010492:	2500      	movs	r5, #0
    huart->RxState = HAL_UART_STATE_BUSY_RX;
24010494:	2322      	movs	r3, #34	@ 0x22
    huart->ErrorCode = HAL_UART_ERROR_NONE;
24010496:	f8c0 5090 	str.w	r5, [r0, #144]	@ 0x90
    huart->RxState = HAL_UART_STATE_BUSY_RX;
2401049a:	f8c0 308c 	str.w	r3, [r0, #140]	@ 0x8c
    huart->ReceptionType = HAL_UART_RECEPTION_TOIDLE;
2401049e:	2301      	movs	r3, #1
240104a0:	66c3      	str	r3, [r0, #108]	@ 0x6c
    huart->RxEventType = HAL_UART_RXEVENT_TC;
240104a2:	6705      	str	r5, [r0, #112]	@ 0x70
    tickstart = HAL_GetTick();
240104a4:	f001 fcb0 	bl	24011e08 <HAL_GetTick>
    UART_MASK_COMPUTATION(huart);
240104a8:	68a3      	ldr	r3, [r4, #8]
    tickstart = HAL_GetTick();
240104aa:	4682      	mov	sl, r0
    huart->RxXferSize  = Size;
240104ac:	f8a4 605c 	strh.w	r6, [r4, #92]	@ 0x5c
    UART_MASK_COMPUTATION(huart);
240104b0:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
    huart->RxXferCount = Size;
240104b4:	f8a4 605e 	strh.w	r6, [r4, #94]	@ 0x5e
    UART_MASK_COMPUTATION(huart);
240104b8:	d116      	bne.n	240104e8 <HAL_UARTEx_ReceiveToIdle+0x7a>
240104ba:	6923      	ldr	r3, [r4, #16]
240104bc:	b30b      	cbz	r3, 24010502 <HAL_UARTEx_ReceiveToIdle+0x94>
    uhMask = huart->Mask;
240104be:	26ff      	movs	r6, #255	@ 0xff
240104c0:	4632      	mov	r2, r6
    *RxLen = 0U;
240104c2:	2300      	movs	r3, #0
        __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_IDLEF);
240104c4:	f04f 0b10 	mov.w	fp, #16
    UART_MASK_COMPUTATION(huart);
240104c8:	f8a4 2060 	strh.w	r2, [r4, #96]	@ 0x60
    *RxLen = 0U;
240104cc:	f8a8 3000 	strh.w	r3, [r8]
    while (huart->RxXferCount > 0U)
240104d0:	f8b4 305e 	ldrh.w	r3, [r4, #94]	@ 0x5e
240104d4:	b29b      	uxth	r3, r3
240104d6:	bb0b      	cbnz	r3, 2401051c <HAL_UARTEx_ReceiveToIdle+0xae>
    *RxLen = huart->RxXferSize - huart->RxXferCount;
240104d8:	f8b4 205e 	ldrh.w	r2, [r4, #94]	@ 0x5e
240104dc:	f8b4 305c 	ldrh.w	r3, [r4, #92]	@ 0x5c
240104e0:	1a9b      	subs	r3, r3, r2
240104e2:	f8a8 3000 	strh.w	r3, [r8]
    huart->RxState = HAL_UART_STATE_READY;
240104e6:	e024      	b.n	24010532 <HAL_UARTEx_ReceiveToIdle+0xc4>
    UART_MASK_COMPUTATION(huart);
240104e8:	b923      	cbnz	r3, 240104f4 <HAL_UARTEx_ReceiveToIdle+0x86>
240104ea:	6925      	ldr	r5, [r4, #16]
240104ec:	b995      	cbnz	r5, 24010514 <HAL_UARTEx_ReceiveToIdle+0xa6>
240104ee:	22ff      	movs	r2, #255	@ 0xff
    uhMask = huart->Mask;
240104f0:	4616      	mov	r6, r2
240104f2:	e7e6      	b.n	240104c2 <HAL_UARTEx_ReceiveToIdle+0x54>
    UART_MASK_COMPUTATION(huart);
240104f4:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
240104f8:	d109      	bne.n	2401050e <HAL_UARTEx_ReceiveToIdle+0xa0>
240104fa:	6923      	ldr	r3, [r4, #16]
240104fc:	b153      	cbz	r3, 24010514 <HAL_UARTEx_ReceiveToIdle+0xa6>
240104fe:	223f      	movs	r2, #63	@ 0x3f
24010500:	e7f6      	b.n	240104f0 <HAL_UARTEx_ReceiveToIdle+0x82>
    uhMask = huart->Mask;
24010502:	f240 16ff 	movw	r6, #511	@ 0x1ff
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
24010506:	463d      	mov	r5, r7
      pdata8bits  = NULL;
24010508:	2700      	movs	r7, #0
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
2401050a:	4632      	mov	r2, r6
2401050c:	e7d9      	b.n	240104c2 <HAL_UARTEx_ReceiveToIdle+0x54>
2401050e:	462a      	mov	r2, r5
    uhMask = huart->Mask;
24010510:	462e      	mov	r6, r5
24010512:	e7d6      	b.n	240104c2 <HAL_UARTEx_ReceiveToIdle+0x54>
24010514:	227f      	movs	r2, #127	@ 0x7f
      pdata16bits = NULL;
24010516:	461d      	mov	r5, r3
    uhMask = huart->Mask;
24010518:	4616      	mov	r6, r2
2401051a:	e7d2      	b.n	240104c2 <HAL_UARTEx_ReceiveToIdle+0x54>
      if (__HAL_UART_GET_FLAG(huart, UART_FLAG_IDLE))
2401051c:	6823      	ldr	r3, [r4, #0]
2401051e:	69da      	ldr	r2, [r3, #28]
24010520:	06d1      	lsls	r1, r2, #27
24010522:	d50c      	bpl.n	2401053e <HAL_UARTEx_ReceiveToIdle+0xd0>
        if (*RxLen > 0U)
24010524:	f8b8 2000 	ldrh.w	r2, [r8]
        __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_IDLEF);
24010528:	f8c3 b020 	str.w	fp, [r3, #32]
        if (*RxLen > 0U)
2401052c:	b13a      	cbz	r2, 2401053e <HAL_UARTEx_ReceiveToIdle+0xd0>
          huart->RxEventType = HAL_UART_RXEVENT_IDLE;
2401052e:	2302      	movs	r3, #2
24010530:	6723      	str	r3, [r4, #112]	@ 0x70
          huart->RxState = HAL_UART_STATE_READY;
24010532:	2320      	movs	r3, #32
          return HAL_OK;
24010534:	2000      	movs	r0, #0
          huart->RxState = HAL_UART_STATE_READY;
24010536:	f8c4 308c 	str.w	r3, [r4, #140]	@ 0x8c
}
2401053a:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
      if (__HAL_UART_GET_FLAG(huart, UART_FLAG_RXNE))
2401053e:	69da      	ldr	r2, [r3, #28]
24010540:	0692      	lsls	r2, r2, #26
24010542:	d50f      	bpl.n	24010564 <HAL_UARTEx_ReceiveToIdle+0xf6>
          *pdata16bits = (uint16_t)(huart->Instance->RDR & uhMask);
24010544:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
24010546:	4033      	ands	r3, r6
        if (pdata8bits == NULL)
24010548:	b9ef      	cbnz	r7, 24010586 <HAL_UARTEx_ReceiveToIdle+0x118>
          *pdata16bits = (uint16_t)(huart->Instance->RDR & uhMask);
2401054a:	f825 3b02 	strh.w	r3, [r5], #2
        *RxLen += 1U;
2401054e:	f8b8 3000 	ldrh.w	r3, [r8]
24010552:	3301      	adds	r3, #1
24010554:	f8a8 3000 	strh.w	r3, [r8]
        huart->RxXferCount--;
24010558:	f8b4 305e 	ldrh.w	r3, [r4, #94]	@ 0x5e
2401055c:	3b01      	subs	r3, #1
2401055e:	b29b      	uxth	r3, r3
24010560:	f8a4 305e 	strh.w	r3, [r4, #94]	@ 0x5e
      if (Timeout != HAL_MAX_DELAY)
24010564:	f1b9 3fff 	cmp.w	r9, #4294967295
24010568:	d0b2      	beq.n	240104d0 <HAL_UARTEx_ReceiveToIdle+0x62>
        if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
2401056a:	f001 fc4d 	bl	24011e08 <HAL_GetTick>
2401056e:	eba0 000a 	sub.w	r0, r0, sl
24010572:	4548      	cmp	r0, r9
24010574:	d802      	bhi.n	2401057c <HAL_UARTEx_ReceiveToIdle+0x10e>
24010576:	f1b9 0f00 	cmp.w	r9, #0
2401057a:	d1a9      	bne.n	240104d0 <HAL_UARTEx_ReceiveToIdle+0x62>
          huart->RxState = HAL_UART_STATE_READY;
2401057c:	2320      	movs	r3, #32
          return HAL_TIMEOUT;
2401057e:	2003      	movs	r0, #3
          huart->RxState = HAL_UART_STATE_READY;
24010580:	f8c4 308c 	str.w	r3, [r4, #140]	@ 0x8c
          return HAL_TIMEOUT;
24010584:	e7d9      	b.n	2401053a <HAL_UARTEx_ReceiveToIdle+0xcc>
          *pdata8bits = (uint8_t)(huart->Instance->RDR & (uint8_t)uhMask);
24010586:	f807 3b01 	strb.w	r3, [r7], #1
          pdata8bits++;
2401058a:	e7e0      	b.n	2401054e <HAL_UARTEx_ReceiveToIdle+0xe0>
    return HAL_BUSY;
2401058c:	2002      	movs	r0, #2
2401058e:	e7d4      	b.n	2401053a <HAL_UARTEx_ReceiveToIdle+0xcc>
      return  HAL_ERROR;
24010590:	2001      	movs	r0, #1
24010592:	e7d2      	b.n	2401053a <HAL_UARTEx_ReceiveToIdle+0xcc>

24010594 <HAL_UARTEx_ReceiveToIdle_IT>:
{
24010594:	b570      	push	{r4, r5, r6, lr}
  if (huart->RxState == HAL_UART_STATE_READY)
24010596:	f8d0 608c 	ldr.w	r6, [r0, #140]	@ 0x8c
{
2401059a:	4604      	mov	r4, r0
  if (huart->RxState == HAL_UART_STATE_READY)
2401059c:	2e20      	cmp	r6, #32
2401059e:	d11c      	bne.n	240105da <HAL_UARTEx_ReceiveToIdle_IT+0x46>
    if ((pData == NULL) || (Size == 0U))
240105a0:	b909      	cbnz	r1, 240105a6 <HAL_UARTEx_ReceiveToIdle_IT+0x12>
      return HAL_ERROR;
240105a2:	2001      	movs	r0, #1
}
240105a4:	bd70      	pop	{r4, r5, r6, pc}
    if ((pData == NULL) || (Size == 0U))
240105a6:	2a00      	cmp	r2, #0
240105a8:	d0fb      	beq.n	240105a2 <HAL_UARTEx_ReceiveToIdle_IT+0xe>
    huart->ReceptionType = HAL_UART_RECEPTION_TOIDLE;
240105aa:	2301      	movs	r3, #1
240105ac:	66c3      	str	r3, [r0, #108]	@ 0x6c
    huart->RxEventType = HAL_UART_RXEVENT_TC;
240105ae:	2300      	movs	r3, #0
240105b0:	6703      	str	r3, [r0, #112]	@ 0x70
    status =  UART_Start_Receive_IT(huart, pData, Size);
240105b2:	f7ff fcdd 	bl	2400ff70 <UART_Start_Receive_IT>
    if (status == HAL_OK)
240105b6:	2800      	cmp	r0, #0
240105b8:	d1f4      	bne.n	240105a4 <HAL_UARTEx_ReceiveToIdle_IT+0x10>
      if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
240105ba:	6ee3      	ldr	r3, [r4, #108]	@ 0x6c
240105bc:	2b01      	cmp	r3, #1
240105be:	d1f0      	bne.n	240105a2 <HAL_UARTEx_ReceiveToIdle_IT+0xe>
        __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_IDLEF);
240105c0:	2210      	movs	r2, #16
240105c2:	6823      	ldr	r3, [r4, #0]
240105c4:	621a      	str	r2, [r3, #32]
240105c6:	6822      	ldr	r2, [r4, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
240105c8:	e852 3f00 	ldrex	r3, [r2]
        ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
240105cc:	f043 0310 	orr.w	r3, r3, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
240105d0:	e842 3100 	strex	r1, r3, [r2]
240105d4:	2900      	cmp	r1, #0
240105d6:	d1f7      	bne.n	240105c8 <HAL_UARTEx_ReceiveToIdle_IT+0x34>
240105d8:	e7e4      	b.n	240105a4 <HAL_UARTEx_ReceiveToIdle_IT+0x10>
    return HAL_BUSY;
240105da:	2002      	movs	r0, #2
240105dc:	e7e2      	b.n	240105a4 <HAL_UARTEx_ReceiveToIdle_IT+0x10>

240105de <HAL_UARTEx_ReceiveToIdle_DMA>:
{
240105de:	b570      	push	{r4, r5, r6, lr}
  if (huart->RxState == HAL_UART_STATE_READY)
240105e0:	f8d0 608c 	ldr.w	r6, [r0, #140]	@ 0x8c
{
240105e4:	4604      	mov	r4, r0
  if (huart->RxState == HAL_UART_STATE_READY)
240105e6:	2e20      	cmp	r6, #32
240105e8:	d11c      	bne.n	24010624 <HAL_UARTEx_ReceiveToIdle_DMA+0x46>
    if ((pData == NULL) || (Size == 0U))
240105ea:	b909      	cbnz	r1, 240105f0 <HAL_UARTEx_ReceiveToIdle_DMA+0x12>
      return HAL_ERROR;
240105ec:	2001      	movs	r0, #1
}
240105ee:	bd70      	pop	{r4, r5, r6, pc}
    if ((pData == NULL) || (Size == 0U))
240105f0:	2a00      	cmp	r2, #0
240105f2:	d0fb      	beq.n	240105ec <HAL_UARTEx_ReceiveToIdle_DMA+0xe>
    huart->ReceptionType = HAL_UART_RECEPTION_TOIDLE;
240105f4:	2301      	movs	r3, #1
240105f6:	66c3      	str	r3, [r0, #108]	@ 0x6c
    huart->RxEventType = HAL_UART_RXEVENT_TC;
240105f8:	2300      	movs	r3, #0
240105fa:	6703      	str	r3, [r0, #112]	@ 0x70
    status =  UART_Start_Receive_DMA(huart, pData, Size);
240105fc:	f7ff fd5e 	bl	240100bc <UART_Start_Receive_DMA>
    if (status == HAL_OK)
24010600:	2800      	cmp	r0, #0
24010602:	d1f4      	bne.n	240105ee <HAL_UARTEx_ReceiveToIdle_DMA+0x10>
      if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
24010604:	6ee3      	ldr	r3, [r4, #108]	@ 0x6c
24010606:	2b01      	cmp	r3, #1
24010608:	d1f0      	bne.n	240105ec <HAL_UARTEx_ReceiveToIdle_DMA+0xe>
        __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_IDLEF);
2401060a:	2210      	movs	r2, #16
2401060c:	6823      	ldr	r3, [r4, #0]
2401060e:	621a      	str	r2, [r3, #32]
24010610:	6822      	ldr	r2, [r4, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
24010612:	e852 3f00 	ldrex	r3, [r2]
        ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
24010616:	f043 0310 	orr.w	r3, r3, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
2401061a:	e842 3100 	strex	r1, r3, [r2]
2401061e:	2900      	cmp	r1, #0
24010620:	d1f7      	bne.n	24010612 <HAL_UARTEx_ReceiveToIdle_DMA+0x34>
24010622:	e7e4      	b.n	240105ee <HAL_UARTEx_ReceiveToIdle_DMA+0x10>
    return HAL_BUSY;
24010624:	2002      	movs	r0, #2
24010626:	e7e2      	b.n	240105ee <HAL_UARTEx_ReceiveToIdle_DMA+0x10>

24010628 <HAL_UARTEx_GetRxEventType>:
  return (huart->RxEventType);
24010628:	6f00      	ldr	r0, [r0, #112]	@ 0x70
}
2401062a:	4770      	bx	lr

2401062c <USART_EndTransfer>:
  * @retval None
  */
static void USART_EndTransfer(USART_HandleTypeDef *husart)
{
  /* Disable TXEIE, TCIE, RXNE, RXFT, TXFT, PE and ERR (Frame error, noise error, overrun error) interrupts */
  CLEAR_BIT(husart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE | USART_CR1_TXEIE_TXFNFIE |
2401062c:	6802      	ldr	r2, [r0, #0]
2401062e:	6813      	ldr	r3, [r2, #0]
24010630:	f423 73f0 	bic.w	r3, r3, #480	@ 0x1e0
24010634:	6013      	str	r3, [r2, #0]
                                    USART_CR1_TCIE));
  CLEAR_BIT(husart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE | USART_CR3_TXFTIE));
24010636:	6893      	ldr	r3, [r2, #8]
24010638:	f023 5384 	bic.w	r3, r3, #276824064	@ 0x10800000
2401063c:	f023 0301 	bic.w	r3, r3, #1
24010640:	6093      	str	r3, [r2, #8]

  /* At end of process, restore husart->State to Ready */
  husart->State = HAL_USART_STATE_READY;
24010642:	2301      	movs	r3, #1
24010644:	f880 3059 	strb.w	r3, [r0, #89]	@ 0x59
}
24010648:	4770      	bx	lr

2401064a <USART_TxISR_8BIT>:
  * @param  husart USART handle.
  * @retval None
  */
static void USART_TxISR_8BIT(USART_HandleTypeDef *husart)
{
  const HAL_USART_StateTypeDef state = husart->State;
2401064a:	f890 3059 	ldrb.w	r3, [r0, #89]	@ 0x59

  /* Check that a Tx process is ongoing */
  if ((state == HAL_USART_STATE_BUSY_TX) ||
2401064e:	f003 03df 	and.w	r3, r3, #223	@ 0xdf
24010652:	2b12      	cmp	r3, #18
24010654:	d115      	bne.n	24010682 <USART_TxISR_8BIT+0x38>
      (state == HAL_USART_STATE_BUSY_TX_RX))
  {
    if (husart->TxXferCount == 0U)
24010656:	8dc2      	ldrh	r2, [r0, #46]	@ 0x2e
    {
      /* Disable the USART Transmit data register empty interrupt */
      __HAL_USART_DISABLE_IT(husart, USART_IT_TXE);
24010658:	6803      	ldr	r3, [r0, #0]
    if (husart->TxXferCount == 0U)
2401065a:	b292      	uxth	r2, r2
2401065c:	b942      	cbnz	r2, 24010670 <USART_TxISR_8BIT+0x26>
      __HAL_USART_DISABLE_IT(husart, USART_IT_TXE);
2401065e:	681a      	ldr	r2, [r3, #0]
24010660:	f022 0280 	bic.w	r2, r2, #128	@ 0x80
24010664:	601a      	str	r2, [r3, #0]

      /* Enable the USART Transmit Complete Interrupt */
      __HAL_USART_ENABLE_IT(husart, USART_IT_TC);
24010666:	681a      	ldr	r2, [r3, #0]
24010668:	f042 0240 	orr.w	r2, r2, #64	@ 0x40
2401066c:	601a      	str	r2, [r3, #0]
2401066e:	4770      	bx	lr
    }
    else
    {
      husart->Instance->TDR = (uint8_t)(*husart->pTxBuffPtr & (uint8_t)0xFF);
24010670:	6a82      	ldr	r2, [r0, #40]	@ 0x28
24010672:	f812 1b01 	ldrb.w	r1, [r2], #1
24010676:	6299      	str	r1, [r3, #40]	@ 0x28
      husart->pTxBuffPtr++;
      husart->TxXferCount--;
24010678:	8dc3      	ldrh	r3, [r0, #46]	@ 0x2e
      husart->pTxBuffPtr++;
2401067a:	6282      	str	r2, [r0, #40]	@ 0x28
      husart->TxXferCount--;
2401067c:	3b01      	subs	r3, #1
2401067e:	b29b      	uxth	r3, r3
24010680:	85c3      	strh	r3, [r0, #46]	@ 0x2e
    }
  }
}
24010682:	4770      	bx	lr

24010684 <USART_TxISR_16BIT>:
  * @param  husart USART handle.
  * @retval None
  */
static void USART_TxISR_16BIT(USART_HandleTypeDef *husart)
{
  const HAL_USART_StateTypeDef state = husart->State;
24010684:	f890 3059 	ldrb.w	r3, [r0, #89]	@ 0x59
  const uint16_t *tmp;

  if ((state == HAL_USART_STATE_BUSY_TX) ||
24010688:	f003 03df 	and.w	r3, r3, #223	@ 0xdf
2401068c:	2b12      	cmp	r3, #18
2401068e:	d117      	bne.n	240106c0 <USART_TxISR_16BIT+0x3c>
      (state == HAL_USART_STATE_BUSY_TX_RX))
  {
    if (husart->TxXferCount == 0U)
24010690:	8dc2      	ldrh	r2, [r0, #46]	@ 0x2e
    {
      /* Disable the USART Transmit data register empty interrupt */
      __HAL_USART_DISABLE_IT(husart, USART_IT_TXE);
24010692:	6803      	ldr	r3, [r0, #0]
    if (husart->TxXferCount == 0U)
24010694:	b292      	uxth	r2, r2
24010696:	b942      	cbnz	r2, 240106aa <USART_TxISR_16BIT+0x26>
      __HAL_USART_DISABLE_IT(husart, USART_IT_TXE);
24010698:	681a      	ldr	r2, [r3, #0]
2401069a:	f022 0280 	bic.w	r2, r2, #128	@ 0x80
2401069e:	601a      	str	r2, [r3, #0]

      /* Enable the USART Transmit Complete Interrupt */
      __HAL_USART_ENABLE_IT(husart, USART_IT_TC);
240106a0:	681a      	ldr	r2, [r3, #0]
240106a2:	f042 0240 	orr.w	r2, r2, #64	@ 0x40
240106a6:	601a      	str	r2, [r3, #0]
240106a8:	4770      	bx	lr
    }
    else
    {
      tmp = (const uint16_t *) husart->pTxBuffPtr;
      husart->Instance->TDR = (uint16_t)(*tmp & 0x01FFU);
240106aa:	6a82      	ldr	r2, [r0, #40]	@ 0x28
240106ac:	f832 1b02 	ldrh.w	r1, [r2], #2
240106b0:	f3c1 0108 	ubfx	r1, r1, #0, #9
240106b4:	6299      	str	r1, [r3, #40]	@ 0x28
      husart->pTxBuffPtr += 2U;
      husart->TxXferCount--;
240106b6:	8dc3      	ldrh	r3, [r0, #46]	@ 0x2e
      husart->pTxBuffPtr += 2U;
240106b8:	6282      	str	r2, [r0, #40]	@ 0x28
      husart->TxXferCount--;
240106ba:	3b01      	subs	r3, #1
240106bc:	b29b      	uxth	r3, r3
240106be:	85c3      	strh	r3, [r0, #46]	@ 0x2e
    }
  }
}
240106c0:	4770      	bx	lr

240106c2 <USART_TxISR_8BIT_FIFOEN>:
  * @param  husart USART handle.
  * @retval None
  */
static void USART_TxISR_8BIT_FIFOEN(USART_HandleTypeDef *husart)
{
  const HAL_USART_StateTypeDef state = husart->State;
240106c2:	f890 3059 	ldrb.w	r3, [r0, #89]	@ 0x59
  uint16_t  nb_tx_data;

  /* Check that a Tx process is ongoing */
  if ((state == HAL_USART_STATE_BUSY_TX) ||
240106c6:	f003 03df 	and.w	r3, r3, #223	@ 0xdf
240106ca:	2b12      	cmp	r3, #18
{
240106cc:	b510      	push	{r4, lr}
  if ((state == HAL_USART_STATE_BUSY_TX) ||
240106ce:	d10d      	bne.n	240106ec <USART_TxISR_8BIT_FIFOEN+0x2a>
      (state == HAL_USART_STATE_BUSY_TX_RX))
  {
    for (nb_tx_data = husart->NbTxDataToProcess ; nb_tx_data > 0U ; nb_tx_data--)
240106d0:	8f82      	ldrh	r2, [r0, #60]	@ 0x3c
240106d2:	b15a      	cbz	r2, 240106ec <USART_TxISR_8BIT_FIFOEN+0x2a>
    {
      if (husart->TxXferCount == 0U)
240106d4:	8dc1      	ldrh	r1, [r0, #46]	@ 0x2e
      {
        /* Disable the TX FIFO threshold interrupt */
        __HAL_USART_DISABLE_IT(husart, USART_IT_TXFT);
240106d6:	6803      	ldr	r3, [r0, #0]
      if (husart->TxXferCount == 0U)
240106d8:	b289      	uxth	r1, r1
240106da:	b941      	cbnz	r1, 240106ee <USART_TxISR_8BIT_FIFOEN+0x2c>
        __HAL_USART_DISABLE_IT(husart, USART_IT_TXFT);
240106dc:	689a      	ldr	r2, [r3, #8]
240106de:	f422 0200 	bic.w	r2, r2, #8388608	@ 0x800000
240106e2:	609a      	str	r2, [r3, #8]

        /* Enable the USART Transmit Complete Interrupt */
        __HAL_USART_ENABLE_IT(husart, USART_IT_TC);
240106e4:	681a      	ldr	r2, [r3, #0]
240106e6:	f042 0240 	orr.w	r2, r2, #64	@ 0x40
240106ea:	601a      	str	r2, [r3, #0]
      {
        /* Nothing to do */
      }
    }
  }
}
240106ec:	bd10      	pop	{r4, pc}
      else if (__HAL_USART_GET_FLAG(husart, USART_FLAG_TXFNF) == SET)
240106ee:	69d9      	ldr	r1, [r3, #28]
240106f0:	0609      	lsls	r1, r1, #24
240106f2:	d508      	bpl.n	24010706 <USART_TxISR_8BIT_FIFOEN+0x44>
        husart->Instance->TDR = (uint8_t)(*husart->pTxBuffPtr & (uint8_t)0xFF);
240106f4:	6a81      	ldr	r1, [r0, #40]	@ 0x28
240106f6:	f811 4b01 	ldrb.w	r4, [r1], #1
240106fa:	629c      	str	r4, [r3, #40]	@ 0x28
        husart->TxXferCount--;
240106fc:	8dc3      	ldrh	r3, [r0, #46]	@ 0x2e
        husart->pTxBuffPtr++;
240106fe:	6281      	str	r1, [r0, #40]	@ 0x28
        husart->TxXferCount--;
24010700:	3b01      	subs	r3, #1
24010702:	b29b      	uxth	r3, r3
24010704:	85c3      	strh	r3, [r0, #46]	@ 0x2e
    for (nb_tx_data = husart->NbTxDataToProcess ; nb_tx_data > 0U ; nb_tx_data--)
24010706:	3a01      	subs	r2, #1
24010708:	b292      	uxth	r2, r2
2401070a:	e7e2      	b.n	240106d2 <USART_TxISR_8BIT_FIFOEN+0x10>

2401070c <USART_TxISR_16BIT_FIFOEN>:
  * @param  husart USART handle.
  * @retval None
  */
static void USART_TxISR_16BIT_FIFOEN(USART_HandleTypeDef *husart)
{
  const HAL_USART_StateTypeDef state = husart->State;
2401070c:	f890 3059 	ldrb.w	r3, [r0, #89]	@ 0x59
  const uint16_t *tmp;
  uint16_t  nb_tx_data;

  /* Check that a Tx process is ongoing */
  if ((state == HAL_USART_STATE_BUSY_TX) ||
24010710:	f003 03df 	and.w	r3, r3, #223	@ 0xdf
24010714:	2b12      	cmp	r3, #18
{
24010716:	b510      	push	{r4, lr}
  if ((state == HAL_USART_STATE_BUSY_TX) ||
24010718:	d10d      	bne.n	24010736 <USART_TxISR_16BIT_FIFOEN+0x2a>
      (state == HAL_USART_STATE_BUSY_TX_RX))
  {
    for (nb_tx_data = husart->NbTxDataToProcess ; nb_tx_data > 0U ; nb_tx_data--)
2401071a:	8f82      	ldrh	r2, [r0, #60]	@ 0x3c
2401071c:	b15a      	cbz	r2, 24010736 <USART_TxISR_16BIT_FIFOEN+0x2a>
    {
      if (husart->TxXferCount == 0U)
2401071e:	8dc1      	ldrh	r1, [r0, #46]	@ 0x2e
      {
        /* Disable the TX FIFO threshold interrupt */
        __HAL_USART_DISABLE_IT(husart, USART_IT_TXFT);
24010720:	6803      	ldr	r3, [r0, #0]
      if (husart->TxXferCount == 0U)
24010722:	b289      	uxth	r1, r1
24010724:	b941      	cbnz	r1, 24010738 <USART_TxISR_16BIT_FIFOEN+0x2c>
        __HAL_USART_DISABLE_IT(husart, USART_IT_TXFT);
24010726:	689a      	ldr	r2, [r3, #8]
24010728:	f422 0200 	bic.w	r2, r2, #8388608	@ 0x800000
2401072c:	609a      	str	r2, [r3, #8]

        /* Enable the USART Transmit Complete Interrupt */
        __HAL_USART_ENABLE_IT(husart, USART_IT_TC);
2401072e:	681a      	ldr	r2, [r3, #0]
24010730:	f042 0240 	orr.w	r2, r2, #64	@ 0x40
24010734:	601a      	str	r2, [r3, #0]
      {
        /* Nothing to do */
      }
    }
  }
}
24010736:	bd10      	pop	{r4, pc}
      else if (__HAL_USART_GET_FLAG(husart, USART_FLAG_TXFNF) == SET)
24010738:	69d9      	ldr	r1, [r3, #28]
2401073a:	0609      	lsls	r1, r1, #24
2401073c:	d50a      	bpl.n	24010754 <USART_TxISR_16BIT_FIFOEN+0x48>
        husart->Instance->TDR = (uint16_t)(*tmp & 0x01FFU);
2401073e:	6a81      	ldr	r1, [r0, #40]	@ 0x28
24010740:	f831 4b02 	ldrh.w	r4, [r1], #2
24010744:	f3c4 0408 	ubfx	r4, r4, #0, #9
24010748:	629c      	str	r4, [r3, #40]	@ 0x28
        husart->TxXferCount--;
2401074a:	8dc3      	ldrh	r3, [r0, #46]	@ 0x2e
        husart->pTxBuffPtr += 2U;
2401074c:	6281      	str	r1, [r0, #40]	@ 0x28
        husart->TxXferCount--;
2401074e:	3b01      	subs	r3, #1
24010750:	b29b      	uxth	r3, r3
24010752:	85c3      	strh	r3, [r0, #46]	@ 0x2e
    for (nb_tx_data = husart->NbTxDataToProcess ; nb_tx_data > 0U ; nb_tx_data--)
24010754:	3a01      	subs	r2, #1
24010756:	b292      	uxth	r2, r2
24010758:	e7e0      	b.n	2401071c <USART_TxISR_16BIT_FIFOEN+0x10>

2401075a <USART_WaitOnFlagUntilTimeout.constprop.0>:
static HAL_StatusTypeDef USART_WaitOnFlagUntilTimeout(USART_HandleTypeDef *husart, uint32_t Flag, FlagStatus Status,
2401075a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
2401075c:	4604      	mov	r4, r0
2401075e:	460e      	mov	r6, r1
24010760:	4617      	mov	r7, r2
24010762:	461d      	mov	r5, r3
  while ((__HAL_USART_GET_FLAG(husart, Flag) ? SET : RESET) == Status)
24010764:	6822      	ldr	r2, [r4, #0]
24010766:	69d3      	ldr	r3, [r2, #28]
24010768:	ea36 0303 	bics.w	r3, r6, r3
2401076c:	d101      	bne.n	24010772 <USART_WaitOnFlagUntilTimeout.constprop.0+0x18>
  return HAL_OK;
2401076e:	2000      	movs	r0, #0
24010770:	e00f      	b.n	24010792 <USART_WaitOnFlagUntilTimeout.constprop.0+0x38>
    if (Timeout != HAL_MAX_DELAY)
24010772:	1c6b      	adds	r3, r5, #1
24010774:	d0f7      	beq.n	24010766 <USART_WaitOnFlagUntilTimeout.constprop.0+0xc>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
24010776:	f001 fb47 	bl	24011e08 <HAL_GetTick>
2401077a:	1bc0      	subs	r0, r0, r7
2401077c:	4285      	cmp	r5, r0
2401077e:	d301      	bcc.n	24010784 <USART_WaitOnFlagUntilTimeout.constprop.0+0x2a>
24010780:	2d00      	cmp	r5, #0
24010782:	d1ef      	bne.n	24010764 <USART_WaitOnFlagUntilTimeout.constprop.0+0xa>
        husart->State = HAL_USART_STATE_READY;
24010784:	2301      	movs	r3, #1
        return HAL_TIMEOUT;
24010786:	2003      	movs	r0, #3
        husart->State = HAL_USART_STATE_READY;
24010788:	f884 3059 	strb.w	r3, [r4, #89]	@ 0x59
        __HAL_UNLOCK(husart);
2401078c:	2300      	movs	r3, #0
2401078e:	f884 3058 	strb.w	r3, [r4, #88]	@ 0x58
}
24010792:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

24010794 <HAL_USART_MspInit>:
}
24010794:	4770      	bx	lr

24010796 <HAL_USART_Init>:
{
24010796:	b570      	push	{r4, r5, r6, lr}
  if (husart == NULL)
24010798:	4604      	mov	r4, r0
{
2401079a:	b086      	sub	sp, #24
  if (husart == NULL)
2401079c:	b918      	cbnz	r0, 240107a6 <HAL_USART_Init+0x10>
    return HAL_ERROR;
2401079e:	2501      	movs	r5, #1
}
240107a0:	4628      	mov	r0, r5
240107a2:	b006      	add	sp, #24
240107a4:	bd70      	pop	{r4, r5, r6, pc}
  if (husart->State == HAL_USART_STATE_RESET)
240107a6:	f890 3059 	ldrb.w	r3, [r0, #89]	@ 0x59
240107aa:	f003 02ff 	and.w	r2, r3, #255	@ 0xff
240107ae:	b91b      	cbnz	r3, 240107b8 <HAL_USART_Init+0x22>
    husart->Lock = HAL_UNLOCKED;
240107b0:	f880 2058 	strb.w	r2, [r0, #88]	@ 0x58
    HAL_USART_MspInit(husart);
240107b4:	f7ff ffee 	bl	24010794 <HAL_USART_MspInit>
  husart->State = HAL_USART_STATE_BUSY;
240107b8:	2302      	movs	r3, #2
  tmpreg = (uint32_t)husart->Init.WordLength | husart->Init.Parity | husart->Init.Mode | USART_CR1_OVER8;
240107ba:	6921      	ldr	r1, [r4, #16]
  husart->State = HAL_USART_STATE_BUSY;
240107bc:	f884 3059 	strb.w	r3, [r4, #89]	@ 0x59
  __HAL_USART_DISABLE(husart);
240107c0:	6823      	ldr	r3, [r4, #0]
240107c2:	681a      	ldr	r2, [r3, #0]
240107c4:	f022 0201 	bic.w	r2, r2, #1
240107c8:	601a      	str	r2, [r3, #0]
  tmpreg = (uint32_t)husart->Init.WordLength | husart->Init.Parity | husart->Init.Mode | USART_CR1_OVER8;
240107ca:	68a2      	ldr	r2, [r4, #8]
  MODIFY_REG(husart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
240107cc:	6818      	ldr	r0, [r3, #0]
  tmpreg = (uint32_t)husart->Init.WordLength | husart->Init.Parity | husart->Init.Mode | USART_CR1_OVER8;
240107ce:	430a      	orrs	r2, r1
  MODIFY_REG(husart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
240107d0:	4993      	ldr	r1, [pc, #588]	@ (24010a20 <HAL_USART_Init+0x28a>)
240107d2:	4001      	ands	r1, r0
  MODIFY_REG(husart->Instance->CR2, USART_CR2_FIELDS, tmpreg);
240107d4:	69a0      	ldr	r0, [r4, #24]
  MODIFY_REG(husart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
240107d6:	430a      	orrs	r2, r1
240107d8:	6961      	ldr	r1, [r4, #20]
240107da:	430a      	orrs	r2, r1
240107dc:	f442 4200 	orr.w	r2, r2, #32768	@ 0x8000
240107e0:	601a      	str	r2, [r3, #0]
  MODIFY_REG(husart->Instance->CR2, USART_CR2_FIELDS, tmpreg);
240107e2:	6859      	ldr	r1, [r3, #4]
240107e4:	6a22      	ldr	r2, [r4, #32]
240107e6:	f421 517c 	bic.w	r1, r1, #16128	@ 0x3f00
240107ea:	4302      	orrs	r2, r0
240107ec:	f021 0109 	bic.w	r1, r1, #9
240107f0:	430a      	orrs	r2, r1
240107f2:	69e1      	ldr	r1, [r4, #28]
240107f4:	430a      	orrs	r2, r1
240107f6:	68e1      	ldr	r1, [r4, #12]
240107f8:	430a      	orrs	r2, r1
240107fa:	f442 6200 	orr.w	r2, r2, #2048	@ 0x800
240107fe:	605a      	str	r2, [r3, #4]
  MODIFY_REG(husart->Instance->PRESC, USART_PRESC_PRESCALER, husart->Init.ClockPrescaler);
24010800:	6ad9      	ldr	r1, [r3, #44]	@ 0x2c
24010802:	6a62      	ldr	r2, [r4, #36]	@ 0x24
24010804:	f021 010f 	bic.w	r1, r1, #15
24010808:	4311      	orrs	r1, r2
2401080a:	62d9      	str	r1, [r3, #44]	@ 0x2c
  USART_GETCLOCKSOURCE(husart, clocksource);
2401080c:	4985      	ldr	r1, [pc, #532]	@ (24010a24 <HAL_USART_Init+0x28e>)
2401080e:	428b      	cmp	r3, r1
24010810:	d11a      	bne.n	24010848 <HAL_USART_Init+0xb2>
24010812:	4b85      	ldr	r3, [pc, #532]	@ (24010a28 <HAL_USART_Init+0x292>)
24010814:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
24010816:	f003 0338 	and.w	r3, r3, #56	@ 0x38
2401081a:	2b18      	cmp	r3, #24
2401081c:	f000 80b8 	beq.w	24010990 <HAL_USART_Init+0x1fa>
24010820:	d829      	bhi.n	24010876 <HAL_USART_Init+0xe0>
24010822:	2b08      	cmp	r3, #8
24010824:	f000 8092 	beq.w	2401094c <HAL_USART_Init+0x1b6>
24010828:	2b10      	cmp	r3, #16
2401082a:	f000 80a4 	beq.w	24010976 <HAL_USART_Init+0x1e0>
2401082e:	b9fb      	cbnz	r3, 24010870 <HAL_USART_Init+0xda>
      pclk = HAL_RCC_GetPCLK2Freq();
24010830:	f7f9 fb80 	bl	24009f34 <HAL_RCC_GetPCLK2Freq>
      usartdiv = (uint32_t)(USART_DIV_SAMPLING8(pclk, husart->Init.BaudRate, husart->Init.ClockPrescaler));
24010834:	6a63      	ldr	r3, [r4, #36]	@ 0x24
24010836:	2b00      	cmp	r3, #0
24010838:	f000 8086 	beq.w	24010948 <HAL_USART_Init+0x1b2>
2401083c:	3b01      	subs	r3, #1
2401083e:	2b0a      	cmp	r3, #10
24010840:	f200 8082 	bhi.w	24010948 <HAL_USART_Init+0x1b2>
24010844:	4a79      	ldr	r2, [pc, #484]	@ (24010a2c <HAL_USART_Init+0x296>)
24010846:	e032      	b.n	240108ae <HAL_USART_Init+0x118>
  USART_GETCLOCKSOURCE(husart, clocksource);
24010848:	4979      	ldr	r1, [pc, #484]	@ (24010a30 <HAL_USART_Init+0x29a>)
2401084a:	428b      	cmp	r3, r1
2401084c:	d10a      	bne.n	24010864 <HAL_USART_Init+0xce>
2401084e:	4b76      	ldr	r3, [pc, #472]	@ (24010a28 <HAL_USART_Init+0x292>)
24010850:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
24010852:	f003 0307 	and.w	r3, r3, #7
24010856:	2b05      	cmp	r3, #5
24010858:	d80a      	bhi.n	24010870 <HAL_USART_Init+0xda>
2401085a:	e8df f003 	tbb	[pc, r3]
2401085e:	771f      	.short	0x771f
24010860:	11c5998c 	.word	0x11c5998c
24010864:	4973      	ldr	r1, [pc, #460]	@ (24010a34 <HAL_USART_Init+0x29e>)
24010866:	428b      	cmp	r3, r1
24010868:	d0f1      	beq.n	2401084e <HAL_USART_Init+0xb8>
2401086a:	4973      	ldr	r1, [pc, #460]	@ (24010a38 <HAL_USART_Init+0x2a2>)
2401086c:	428b      	cmp	r3, r1
2401086e:	d0d0      	beq.n	24010812 <HAL_USART_Init+0x7c>
24010870:	2300      	movs	r3, #0
24010872:	2501      	movs	r5, #1
24010874:	e026      	b.n	240108c4 <HAL_USART_Init+0x12e>
24010876:	2b20      	cmp	r3, #32
24010878:	f000 80b6 	beq.w	240109e8 <HAL_USART_Init+0x252>
2401087c:	2b28      	cmp	r3, #40	@ 0x28
2401087e:	d1f7      	bne.n	24010870 <HAL_USART_Init+0xda>
      usartdiv = (uint32_t)(USART_DIV_SAMPLING8(LSE_VALUE, husart->Init.BaudRate, husart->Init.ClockPrescaler));
24010880:	2a00      	cmp	r2, #0
24010882:	f000 80bd 	beq.w	24010a00 <HAL_USART_Init+0x26a>
24010886:	3a01      	subs	r2, #1
24010888:	2a0a      	cmp	r2, #10
2401088a:	f200 80b9 	bhi.w	24010a00 <HAL_USART_Init+0x26a>
2401088e:	4b6b      	ldr	r3, [pc, #428]	@ (24010a3c <HAL_USART_Init+0x2a6>)
24010890:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
24010894:	6861      	ldr	r1, [r4, #4]
24010896:	f44f 4200 	mov.w	r2, #32768	@ 0x8000
2401089a:	e064      	b.n	24010966 <HAL_USART_Init+0x1d0>
      pclk = HAL_RCC_GetPCLK1Freq();
2401089c:	f7f9 fb38 	bl	24009f10 <HAL_RCC_GetPCLK1Freq>
      usartdiv = (uint32_t)(USART_DIV_SAMPLING8(pclk, husart->Init.BaudRate, husart->Init.ClockPrescaler));
240108a0:	6a63      	ldr	r3, [r4, #36]	@ 0x24
240108a2:	2b00      	cmp	r3, #0
240108a4:	d050      	beq.n	24010948 <HAL_USART_Init+0x1b2>
240108a6:	3b01      	subs	r3, #1
240108a8:	2b0a      	cmp	r3, #10
240108aa:	d84d      	bhi.n	24010948 <HAL_USART_Init+0x1b2>
240108ac:	4a64      	ldr	r2, [pc, #400]	@ (24010a40 <HAL_USART_Init+0x2aa>)
240108ae:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
      usartdiv = (uint32_t)(USART_DIV_SAMPLING8(pclk, husart->Init.BaudRate, husart->Init.ClockPrescaler));
240108b2:	6862      	ldr	r2, [r4, #4]
240108b4:	fbb0 f0f3 	udiv	r0, r0, r3
240108b8:	0853      	lsrs	r3, r2, #1
240108ba:	eb03 0340 	add.w	r3, r3, r0, lsl #1
240108be:	fbb3 f3f2 	udiv	r3, r3, r2
  HAL_StatusTypeDef ret                = HAL_OK;
240108c2:	2500      	movs	r5, #0
  if ((usartdiv >= USART_BRR_MIN) && (usartdiv <= USART_BRR_MAX))
240108c4:	f1a3 0110 	sub.w	r1, r3, #16
240108c8:	f64f 72ef 	movw	r2, #65519	@ 0xffef
240108cc:	4291      	cmp	r1, r2
240108ce:	f200 8099 	bhi.w	24010a04 <HAL_USART_Init+0x26e>
    brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
240108d2:	f023 020f 	bic.w	r2, r3, #15
    brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
240108d6:	f3c3 0342 	ubfx	r3, r3, #1, #3
    husart->Instance->BRR = brrtemp;
240108da:	6821      	ldr	r1, [r4, #0]
    brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
240108dc:	b292      	uxth	r2, r2
    husart->Instance->BRR = brrtemp;
240108de:	4313      	orrs	r3, r2
240108e0:	60cb      	str	r3, [r1, #12]
  husart->NbTxDataToProcess = 1U;
240108e2:	2301      	movs	r3, #1
  husart->RxISR   = NULL;
240108e4:	2200      	movs	r2, #0
  if (USART_SetConfig(husart) == HAL_ERROR)
240108e6:	429d      	cmp	r5, r3
  husart->NbTxDataToProcess = 1U;
240108e8:	87a3      	strh	r3, [r4, #60]	@ 0x3c
  husart->NbRxDataToProcess = 1U;
240108ea:	8763      	strh	r3, [r4, #58]	@ 0x3a
  husart->TxISR   = NULL;
240108ec:	e9c4 2212 	strd	r2, r2, [r4, #72]	@ 0x48
  if (USART_SetConfig(husart) == HAL_ERROR)
240108f0:	f43f af55 	beq.w	2401079e <HAL_USART_Init+0x8>
  husart->Instance->CR2 &= ~USART_CR2_LINEN;
240108f4:	6823      	ldr	r3, [r4, #0]
240108f6:	6859      	ldr	r1, [r3, #4]
240108f8:	f421 4180 	bic.w	r1, r1, #16384	@ 0x4000
240108fc:	6059      	str	r1, [r3, #4]
  husart->Instance->CR3 &= ~(USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN);
240108fe:	6899      	ldr	r1, [r3, #8]
24010900:	f021 012a 	bic.w	r1, r1, #42	@ 0x2a
24010904:	6099      	str	r1, [r3, #8]
  __HAL_USART_ENABLE(husart);
24010906:	6819      	ldr	r1, [r3, #0]
24010908:	f041 0101 	orr.w	r1, r1, #1
2401090c:	6019      	str	r1, [r3, #0]
  husart->ErrorCode = HAL_USART_ERROR_NONE;
2401090e:	65e2      	str	r2, [r4, #92]	@ 0x5c
  tickstart = HAL_GetTick();
24010910:	f001 fa7a 	bl	24011e08 <HAL_GetTick>
  if ((husart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
24010914:	6823      	ldr	r3, [r4, #0]
  tickstart = HAL_GetTick();
24010916:	4606      	mov	r6, r0
  if ((husart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
24010918:	681b      	ldr	r3, [r3, #0]
2401091a:	071a      	lsls	r2, r3, #28
2401091c:	d474      	bmi.n	24010a08 <HAL_USART_Init+0x272>
  if ((husart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
2401091e:	6823      	ldr	r3, [r4, #0]
24010920:	681b      	ldr	r3, [r3, #0]
24010922:	075b      	lsls	r3, r3, #29
24010924:	d509      	bpl.n	2401093a <HAL_USART_Init+0x1a4>
    if (USART_WaitOnFlagUntilTimeout(husart, USART_ISR_REACK, RESET, tickstart, USART_TEACK_REACK_TIMEOUT) != HAL_OK)
24010926:	f44f 737a 	mov.w	r3, #1000	@ 0x3e8
2401092a:	4632      	mov	r2, r6
2401092c:	f44f 0180 	mov.w	r1, #4194304	@ 0x400000
24010930:	4620      	mov	r0, r4
24010932:	f7ff ff12 	bl	2401075a <USART_WaitOnFlagUntilTimeout.constprop.0>
24010936:	2800      	cmp	r0, #0
24010938:	d170      	bne.n	24010a1c <HAL_USART_Init+0x286>
  husart->State = HAL_USART_STATE_READY;
2401093a:	2301      	movs	r3, #1
2401093c:	f884 3059 	strb.w	r3, [r4, #89]	@ 0x59
  __HAL_UNLOCK(husart);
24010940:	2300      	movs	r3, #0
24010942:	f884 3058 	strb.w	r3, [r4, #88]	@ 0x58
  return HAL_OK;
24010946:	e72b      	b.n	240107a0 <HAL_USART_Init+0xa>
      usartdiv = (uint32_t)(USART_DIV_SAMPLING8(pclk, husart->Init.BaudRate, husart->Init.ClockPrescaler));
24010948:	2301      	movs	r3, #1
2401094a:	e7b2      	b.n	240108b2 <HAL_USART_Init+0x11c>
      HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
2401094c:	4668      	mov	r0, sp
2401094e:	f7fa fa05 	bl	2400ad5c <HAL_RCCEx_GetPLL2ClockFreq>
      usartdiv = (uint32_t)(USART_DIV_SAMPLING8(pll2_clocks.PLL2_Q_Frequency, husart->Init.BaudRate,
24010952:	6a63      	ldr	r3, [r4, #36]	@ 0x24
24010954:	9a01      	ldr	r2, [sp, #4]
24010956:	b1cb      	cbz	r3, 2401098c <HAL_USART_Init+0x1f6>
24010958:	3b01      	subs	r3, #1
2401095a:	2b0a      	cmp	r3, #10
2401095c:	d816      	bhi.n	2401098c <HAL_USART_Init+0x1f6>
2401095e:	4939      	ldr	r1, [pc, #228]	@ (24010a44 <HAL_USART_Init+0x2ae>)
24010960:	f831 3013 	ldrh.w	r3, [r1, r3, lsl #1]
      usartdiv = (uint32_t)(USART_DIV_SAMPLING8(pll3_clocks.PLL3_Q_Frequency, husart->Init.BaudRate,
24010964:	6861      	ldr	r1, [r4, #4]
      usartdiv = (uint32_t)(USART_DIV_SAMPLING8(LSE_VALUE, husart->Init.BaudRate, husart->Init.ClockPrescaler));
24010966:	fbb2 f2f3 	udiv	r2, r2, r3
2401096a:	084b      	lsrs	r3, r1, #1
2401096c:	eb03 0342 	add.w	r3, r3, r2, lsl #1
24010970:	fbb3 f3f1 	udiv	r3, r3, r1
24010974:	e7a5      	b.n	240108c2 <HAL_USART_Init+0x12c>
      HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
24010976:	a803      	add	r0, sp, #12
24010978:	f7fa fa9a 	bl	2400aeb0 <HAL_RCCEx_GetPLL3ClockFreq>
      usartdiv = (uint32_t)(USART_DIV_SAMPLING8(pll3_clocks.PLL3_Q_Frequency, husart->Init.BaudRate,
2401097c:	6a63      	ldr	r3, [r4, #36]	@ 0x24
2401097e:	9a04      	ldr	r2, [sp, #16]
24010980:	b123      	cbz	r3, 2401098c <HAL_USART_Init+0x1f6>
24010982:	3b01      	subs	r3, #1
24010984:	2b0a      	cmp	r3, #10
24010986:	d801      	bhi.n	2401098c <HAL_USART_Init+0x1f6>
24010988:	492f      	ldr	r1, [pc, #188]	@ (24010a48 <HAL_USART_Init+0x2b2>)
2401098a:	e7e9      	b.n	24010960 <HAL_USART_Init+0x1ca>
2401098c:	2301      	movs	r3, #1
2401098e:	e7e9      	b.n	24010964 <HAL_USART_Init+0x1ce>
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
24010990:	4925      	ldr	r1, [pc, #148]	@ (24010a28 <HAL_USART_Init+0x292>)
24010992:	680b      	ldr	r3, [r1, #0]
24010994:	f013 0f20 	tst.w	r3, #32
24010998:	6863      	ldr	r3, [r4, #4]
2401099a:	d015      	beq.n	240109c8 <HAL_USART_Init+0x232>
        usartdiv = (uint32_t)(USART_DIV_SAMPLING8((HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3U)),
2401099c:	6808      	ldr	r0, [r1, #0]
2401099e:	492b      	ldr	r1, [pc, #172]	@ (24010a4c <HAL_USART_Init+0x2b6>)
240109a0:	f3c0 00c1 	ubfx	r0, r0, #3, #2
240109a4:	40c1      	lsrs	r1, r0
240109a6:	b16a      	cbz	r2, 240109c4 <HAL_USART_Init+0x22e>
240109a8:	3a01      	subs	r2, #1
240109aa:	2a0a      	cmp	r2, #10
240109ac:	d80a      	bhi.n	240109c4 <HAL_USART_Init+0x22e>
240109ae:	4828      	ldr	r0, [pc, #160]	@ (24010a50 <HAL_USART_Init+0x2ba>)
240109b0:	f830 2012 	ldrh.w	r2, [r0, r2, lsl #1]
240109b4:	fbb1 f2f2 	udiv	r2, r1, r2
240109b8:	0859      	lsrs	r1, r3, #1
240109ba:	eb01 0242 	add.w	r2, r1, r2, lsl #1
        usartdiv = (uint32_t)(USART_DIV_SAMPLING8(HSI_VALUE, husart->Init.BaudRate, husart->Init.ClockPrescaler));
240109be:	fbb2 f3f3 	udiv	r3, r2, r3
240109c2:	e77e      	b.n	240108c2 <HAL_USART_Init+0x12c>
        usartdiv = (uint32_t)(USART_DIV_SAMPLING8((HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3U)),
240109c4:	2201      	movs	r2, #1
240109c6:	e7f5      	b.n	240109b4 <HAL_USART_Init+0x21e>
        usartdiv = (uint32_t)(USART_DIV_SAMPLING8(HSI_VALUE, husart->Init.BaudRate, husart->Init.ClockPrescaler));
240109c8:	b162      	cbz	r2, 240109e4 <HAL_USART_Init+0x24e>
240109ca:	3a01      	subs	r2, #1
240109cc:	2a0a      	cmp	r2, #10
240109ce:	d809      	bhi.n	240109e4 <HAL_USART_Init+0x24e>
240109d0:	4920      	ldr	r1, [pc, #128]	@ (24010a54 <HAL_USART_Init+0x2be>)
240109d2:	f831 2012 	ldrh.w	r2, [r1, r2, lsl #1]
240109d6:	491d      	ldr	r1, [pc, #116]	@ (24010a4c <HAL_USART_Init+0x2b6>)
240109d8:	fbb1 f1f2 	udiv	r1, r1, r2
240109dc:	085a      	lsrs	r2, r3, #1
240109de:	eb02 0241 	add.w	r2, r2, r1, lsl #1
240109e2:	e7ec      	b.n	240109be <HAL_USART_Init+0x228>
240109e4:	2201      	movs	r2, #1
240109e6:	e7f6      	b.n	240109d6 <HAL_USART_Init+0x240>
      usartdiv = (uint32_t)(USART_DIV_SAMPLING8(CSI_VALUE, husart->Init.BaudRate, husart->Init.ClockPrescaler));
240109e8:	b142      	cbz	r2, 240109fc <HAL_USART_Init+0x266>
240109ea:	3a01      	subs	r2, #1
240109ec:	2a0a      	cmp	r2, #10
240109ee:	d805      	bhi.n	240109fc <HAL_USART_Init+0x266>
240109f0:	4b19      	ldr	r3, [pc, #100]	@ (24010a58 <HAL_USART_Init+0x2c2>)
240109f2:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
240109f6:	6861      	ldr	r1, [r4, #4]
240109f8:	4a18      	ldr	r2, [pc, #96]	@ (24010a5c <HAL_USART_Init+0x2c6>)
240109fa:	e7b4      	b.n	24010966 <HAL_USART_Init+0x1d0>
240109fc:	2301      	movs	r3, #1
240109fe:	e7fa      	b.n	240109f6 <HAL_USART_Init+0x260>
      usartdiv = (uint32_t)(USART_DIV_SAMPLING8(LSE_VALUE, husart->Init.BaudRate, husart->Init.ClockPrescaler));
24010a00:	2301      	movs	r3, #1
24010a02:	e747      	b.n	24010894 <HAL_USART_Init+0xfe>
    ret = HAL_ERROR;
24010a04:	2501      	movs	r5, #1
24010a06:	e76c      	b.n	240108e2 <HAL_USART_Init+0x14c>
    if (USART_WaitOnFlagUntilTimeout(husart, USART_ISR_TEACK, RESET, tickstart, USART_TEACK_REACK_TIMEOUT) != HAL_OK)
24010a08:	4602      	mov	r2, r0
24010a0a:	f44f 737a 	mov.w	r3, #1000	@ 0x3e8
24010a0e:	f44f 1100 	mov.w	r1, #2097152	@ 0x200000
24010a12:	4620      	mov	r0, r4
24010a14:	f7ff fea1 	bl	2401075a <USART_WaitOnFlagUntilTimeout.constprop.0>
24010a18:	2800      	cmp	r0, #0
24010a1a:	d080      	beq.n	2401091e <HAL_USART_Init+0x188>
      return HAL_TIMEOUT;
24010a1c:	2503      	movs	r5, #3
24010a1e:	e6bf      	b.n	240107a0 <HAL_USART_Init+0xa>
24010a20:	cfff69f3 	.word	0xcfff69f3
24010a24:	40011000 	.word	0x40011000
24010a28:	58024400 	.word	0x58024400
24010a2c:	240141d4 	.word	0x240141d4
24010a30:	40004400 	.word	0x40004400
24010a34:	40004800 	.word	0x40004800
24010a38:	40011400 	.word	0x40011400
24010a3c:	240141d4 	.word	0x240141d4
24010a40:	240141d4 	.word	0x240141d4
24010a44:	240141d4 	.word	0x240141d4
24010a48:	240141d4 	.word	0x240141d4
24010a4c:	03d09000 	.word	0x03d09000
24010a50:	240141d4 	.word	0x240141d4
24010a54:	240141d4 	.word	0x240141d4
24010a58:	240141d4 	.word	0x240141d4
24010a5c:	003d0900 	.word	0x003d0900

24010a60 <HAL_USART_MspDeInit>:
__weak void HAL_USART_MspDeInit(USART_HandleTypeDef *husart)
24010a60:	4770      	bx	lr

24010a62 <HAL_USART_DeInit>:
{
24010a62:	b538      	push	{r3, r4, r5, lr}
  if (husart == NULL)
24010a64:	4605      	mov	r5, r0
24010a66:	b180      	cbz	r0, 24010a8a <HAL_USART_DeInit+0x28>
  husart->State = HAL_USART_STATE_BUSY;
24010a68:	2302      	movs	r3, #2
  husart->Instance->CR1 = 0x0U;
24010a6a:	2400      	movs	r4, #0
  husart->State = HAL_USART_STATE_BUSY;
24010a6c:	f880 3059 	strb.w	r3, [r0, #89]	@ 0x59
  husart->Instance->CR1 = 0x0U;
24010a70:	6803      	ldr	r3, [r0, #0]
24010a72:	601c      	str	r4, [r3, #0]
  husart->Instance->CR2 = 0x0U;
24010a74:	605c      	str	r4, [r3, #4]
  husart->Instance->CR3 = 0x0U;
24010a76:	609c      	str	r4, [r3, #8]
  HAL_USART_MspDeInit(husart);
24010a78:	f7ff fff2 	bl	24010a60 <HAL_USART_MspDeInit>
  return HAL_OK;
24010a7c:	4620      	mov	r0, r4
  husart->ErrorCode = HAL_USART_ERROR_NONE;
24010a7e:	65ec      	str	r4, [r5, #92]	@ 0x5c
  __HAL_UNLOCK(husart);
24010a80:	f885 4058 	strb.w	r4, [r5, #88]	@ 0x58
  husart->State = HAL_USART_STATE_RESET;
24010a84:	f885 4059 	strb.w	r4, [r5, #89]	@ 0x59
}
24010a88:	bd38      	pop	{r3, r4, r5, pc}
    return HAL_ERROR;
24010a8a:	2001      	movs	r0, #1
24010a8c:	e7fc      	b.n	24010a88 <HAL_USART_DeInit+0x26>

24010a8e <HAL_USART_Transmit>:
{
24010a8e:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
24010a92:	461f      	mov	r7, r3
  if (husart->State == HAL_USART_STATE_READY)
24010a94:	f890 3059 	ldrb.w	r3, [r0, #89]	@ 0x59
{
24010a98:	4604      	mov	r4, r0
24010a9a:	460e      	mov	r6, r1
  if (husart->State == HAL_USART_STATE_READY)
24010a9c:	2b01      	cmp	r3, #1
{
24010a9e:	4691      	mov	r9, r2
  if (husart->State == HAL_USART_STATE_READY)
24010aa0:	b2d8      	uxtb	r0, r3
24010aa2:	d153      	bne.n	24010b4c <HAL_USART_Transmit+0xbe>
    if ((pTxData == NULL) || (Size == 0U))
24010aa4:	2900      	cmp	r1, #0
24010aa6:	d040      	beq.n	24010b2a <HAL_USART_Transmit+0x9c>
24010aa8:	2a00      	cmp	r2, #0
24010aaa:	d03e      	beq.n	24010b2a <HAL_USART_Transmit+0x9c>
    __HAL_LOCK(husart);
24010aac:	f894 3058 	ldrb.w	r3, [r4, #88]	@ 0x58
24010ab0:	2b01      	cmp	r3, #1
24010ab2:	d04b      	beq.n	24010b4c <HAL_USART_Transmit+0xbe>
    husart->State = HAL_USART_STATE_BUSY_TX;
24010ab4:	2312      	movs	r3, #18
    husart->ErrorCode = HAL_USART_ERROR_NONE;
24010ab6:	2500      	movs	r5, #0
    __HAL_LOCK(husart);
24010ab8:	f884 0058 	strb.w	r0, [r4, #88]	@ 0x58
    husart->ErrorCode = HAL_USART_ERROR_NONE;
24010abc:	65e5      	str	r5, [r4, #92]	@ 0x5c
    husart->State = HAL_USART_STATE_BUSY_TX;
24010abe:	f884 3059 	strb.w	r3, [r4, #89]	@ 0x59
    tickstart = HAL_GetTick();
24010ac2:	f001 f9a1 	bl	24011e08 <HAL_GetTick>
    if ((husart->Init.WordLength == USART_WORDLENGTH_9B) && (husart->Init.Parity == USART_PARITY_NONE))
24010ac6:	68a3      	ldr	r3, [r4, #8]
    tickstart = HAL_GetTick();
24010ac8:	4680      	mov	r8, r0
    husart->TxXferSize = Size;
24010aca:	f8a4 902c 	strh.w	r9, [r4, #44]	@ 0x2c
    if ((husart->Init.WordLength == USART_WORDLENGTH_9B) && (husart->Init.Parity == USART_PARITY_NONE))
24010ace:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
    husart->TxXferCount = Size;
24010ad2:	f8a4 902e 	strh.w	r9, [r4, #46]	@ 0x2e
    if ((husart->Init.WordLength == USART_WORDLENGTH_9B) && (husart->Init.Parity == USART_PARITY_NONE))
24010ad6:	d103      	bne.n	24010ae0 <HAL_USART_Transmit+0x52>
24010ad8:	6923      	ldr	r3, [r4, #16]
24010ada:	b90b      	cbnz	r3, 24010ae0 <HAL_USART_Transmit+0x52>
24010adc:	4635      	mov	r5, r6
      ptxdata8bits  = NULL;
24010ade:	461e      	mov	r6, r3
    while (husart->TxXferCount > 0U)
24010ae0:	8de3      	ldrh	r3, [r4, #46]	@ 0x2e
24010ae2:	b29b      	uxth	r3, r3
24010ae4:	b9cb      	cbnz	r3, 24010b1a <HAL_USART_Transmit+0x8c>
    if (USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
24010ae6:	463b      	mov	r3, r7
24010ae8:	4642      	mov	r2, r8
24010aea:	2140      	movs	r1, #64	@ 0x40
24010aec:	4620      	mov	r0, r4
24010aee:	f7ff fe34 	bl	2401075a <USART_WaitOnFlagUntilTimeout.constprop.0>
24010af2:	b9c8      	cbnz	r0, 24010b28 <HAL_USART_Transmit+0x9a>
    __HAL_USART_CLEAR_FLAG(husart, USART_CLEAR_TCF);
24010af4:	6823      	ldr	r3, [r4, #0]
24010af6:	2240      	movs	r2, #64	@ 0x40
24010af8:	621a      	str	r2, [r3, #32]
    __HAL_USART_CLEAR_OREFLAG(husart);
24010afa:	2208      	movs	r2, #8
24010afc:	621a      	str	r2, [r3, #32]
    __HAL_USART_SEND_REQ(husart, USART_RXDATA_FLUSH_REQUEST);
24010afe:	699a      	ldr	r2, [r3, #24]
24010b00:	f042 0208 	orr.w	r2, r2, #8
24010b04:	619a      	str	r2, [r3, #24]
    __HAL_USART_SEND_REQ(husart, USART_TXDATA_FLUSH_REQUEST);
24010b06:	699a      	ldr	r2, [r3, #24]
24010b08:	f042 0210 	orr.w	r2, r2, #16
24010b0c:	619a      	str	r2, [r3, #24]
    husart->State = HAL_USART_STATE_READY;
24010b0e:	2301      	movs	r3, #1
    __HAL_UNLOCK(husart);
24010b10:	f884 0058 	strb.w	r0, [r4, #88]	@ 0x58
    husart->State = HAL_USART_STATE_READY;
24010b14:	f884 3059 	strb.w	r3, [r4, #89]	@ 0x59
    return HAL_OK;
24010b18:	e007      	b.n	24010b2a <HAL_USART_Transmit+0x9c>
      if (USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
24010b1a:	463b      	mov	r3, r7
24010b1c:	4642      	mov	r2, r8
24010b1e:	2180      	movs	r1, #128	@ 0x80
24010b20:	4620      	mov	r0, r4
24010b22:	f7ff fe1a 	bl	2401075a <USART_WaitOnFlagUntilTimeout.constprop.0>
24010b26:	b110      	cbz	r0, 24010b2e <HAL_USART_Transmit+0xa0>
        return HAL_TIMEOUT;
24010b28:	2003      	movs	r0, #3
}
24010b2a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        husart->Instance->TDR = (uint16_t)(*ptxdata16bits & 0x01FFU);
24010b2e:	6822      	ldr	r2, [r4, #0]
      if (ptxdata8bits == NULL)
24010b30:	b94e      	cbnz	r6, 24010b46 <HAL_USART_Transmit+0xb8>
        husart->Instance->TDR = (uint16_t)(*ptxdata16bits & 0x01FFU);
24010b32:	f835 3b02 	ldrh.w	r3, [r5], #2
24010b36:	f3c3 0308 	ubfx	r3, r3, #0, #9
        husart->Instance->TDR = (uint8_t)(*ptxdata8bits & 0xFFU);
24010b3a:	6293      	str	r3, [r2, #40]	@ 0x28
      husart->TxXferCount--;
24010b3c:	8de1      	ldrh	r1, [r4, #46]	@ 0x2e
24010b3e:	3901      	subs	r1, #1
24010b40:	b289      	uxth	r1, r1
24010b42:	85e1      	strh	r1, [r4, #46]	@ 0x2e
24010b44:	e7cc      	b.n	24010ae0 <HAL_USART_Transmit+0x52>
        husart->Instance->TDR = (uint8_t)(*ptxdata8bits & 0xFFU);
24010b46:	f816 3b01 	ldrb.w	r3, [r6], #1
24010b4a:	e7f6      	b.n	24010b3a <HAL_USART_Transmit+0xac>
    __HAL_LOCK(husart);
24010b4c:	2002      	movs	r0, #2
24010b4e:	e7ec      	b.n	24010b2a <HAL_USART_Transmit+0x9c>

24010b50 <HAL_USART_Receive>:
{
24010b50:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
24010b54:	4699      	mov	r9, r3
  if (husart->State == HAL_USART_STATE_READY)
24010b56:	f890 3059 	ldrb.w	r3, [r0, #89]	@ 0x59
{
24010b5a:	4604      	mov	r4, r0
24010b5c:	4688      	mov	r8, r1
  if (husart->State == HAL_USART_STATE_READY)
24010b5e:	2b01      	cmp	r3, #1
{
24010b60:	4615      	mov	r5, r2
  if (husart->State == HAL_USART_STATE_READY)
24010b62:	b2d8      	uxtb	r0, r3
24010b64:	d177      	bne.n	24010c56 <HAL_USART_Receive+0x106>
    if ((pRxData == NULL) || (Size == 0U))
24010b66:	2900      	cmp	r1, #0
24010b68:	d059      	beq.n	24010c1e <HAL_USART_Receive+0xce>
24010b6a:	2a00      	cmp	r2, #0
24010b6c:	d057      	beq.n	24010c1e <HAL_USART_Receive+0xce>
    __HAL_LOCK(husart);
24010b6e:	f894 3058 	ldrb.w	r3, [r4, #88]	@ 0x58
24010b72:	2b01      	cmp	r3, #1
24010b74:	d06f      	beq.n	24010c56 <HAL_USART_Receive+0x106>
    husart->State = HAL_USART_STATE_BUSY_RX;
24010b76:	2322      	movs	r3, #34	@ 0x22
    husart->ErrorCode = HAL_USART_ERROR_NONE;
24010b78:	f04f 0b00 	mov.w	fp, #0
    __HAL_LOCK(husart);
24010b7c:	f884 0058 	strb.w	r0, [r4, #88]	@ 0x58
    husart->ErrorCode = HAL_USART_ERROR_NONE;
24010b80:	f8c4 b05c 	str.w	fp, [r4, #92]	@ 0x5c
    husart->State = HAL_USART_STATE_BUSY_RX;
24010b84:	f884 3059 	strb.w	r3, [r4, #89]	@ 0x59
    tickstart = HAL_GetTick();
24010b88:	f001 f93e 	bl	24011e08 <HAL_GetTick>
    husart->RxXferSize = Size;
24010b8c:	86a5      	strh	r5, [r4, #52]	@ 0x34
    husart->RxXferCount = Size;
24010b8e:	86e5      	strh	r5, [r4, #54]	@ 0x36
    tickstart = HAL_GetTick();
24010b90:	4682      	mov	sl, r0
    USART_MASK_COMPUTATION(husart);
24010b92:	68a5      	ldr	r5, [r4, #8]
24010b94:	f5b5 5f80 	cmp.w	r5, #4096	@ 0x1000
24010b98:	d105      	bne.n	24010ba6 <HAL_USART_Receive+0x56>
24010b9a:	6923      	ldr	r3, [r4, #16]
24010b9c:	b343      	cbz	r3, 24010bf0 <HAL_USART_Receive+0xa0>
    uhMask = husart->Mask;
24010b9e:	27ff      	movs	r7, #255	@ 0xff
24010ba0:	463e      	mov	r6, r7
      prxdata16bits = NULL;
24010ba2:	465d      	mov	r5, fp
24010ba4:	e005      	b.n	24010bb2 <HAL_USART_Receive+0x62>
    USART_MASK_COMPUTATION(husart);
24010ba6:	b9dd      	cbnz	r5, 24010be0 <HAL_USART_Receive+0x90>
24010ba8:	6923      	ldr	r3, [r4, #16]
24010baa:	bb63      	cbnz	r3, 24010c06 <HAL_USART_Receive+0xb6>
24010bac:	26ff      	movs	r6, #255	@ 0xff
      prxdata16bits = NULL;
24010bae:	461d      	mov	r5, r3
    uhMask = husart->Mask;
24010bb0:	4637      	mov	r7, r6
    USART_MASK_COMPUTATION(husart);
24010bb2:	8726      	strh	r6, [r4, #56]	@ 0x38
        husart->Instance->TDR = (USART_DUMMY_DATA & (uint16_t)0x0FF);
24010bb4:	26ff      	movs	r6, #255	@ 0xff
    while (husart->RxXferCount > 0U)
24010bb6:	8ee3      	ldrh	r3, [r4, #54]	@ 0x36
      if (husart->SlaveMode == USART_SLAVEMODE_DISABLE)
24010bb8:	6c22      	ldr	r2, [r4, #64]	@ 0x40
    while (husart->RxXferCount > 0U)
24010bba:	b29b      	uxth	r3, r3
24010bbc:	bb33      	cbnz	r3, 24010c0c <HAL_USART_Receive+0xbc>
    if (husart->SlaveMode == USART_SLAVEMODE_ENABLE)
24010bbe:	2a01      	cmp	r2, #1
24010bc0:	d107      	bne.n	24010bd2 <HAL_USART_Receive+0x82>
      __HAL_USART_CLEAR_UDRFLAG(husart);
24010bc2:	6823      	ldr	r3, [r4, #0]
24010bc4:	f44f 5200 	mov.w	r2, #8192	@ 0x2000
24010bc8:	621a      	str	r2, [r3, #32]
      __HAL_USART_SEND_REQ(husart, USART_TXDATA_FLUSH_REQUEST);
24010bca:	699a      	ldr	r2, [r3, #24]
24010bcc:	f042 0210 	orr.w	r2, r2, #16
24010bd0:	619a      	str	r2, [r3, #24]
    husart->State = HAL_USART_STATE_READY;
24010bd2:	2301      	movs	r3, #1
    __HAL_UNLOCK(husart);
24010bd4:	2000      	movs	r0, #0
    husart->State = HAL_USART_STATE_READY;
24010bd6:	f884 3059 	strb.w	r3, [r4, #89]	@ 0x59
    __HAL_UNLOCK(husart);
24010bda:	f884 0058 	strb.w	r0, [r4, #88]	@ 0x58
    return HAL_OK;
24010bde:	e01e      	b.n	24010c1e <HAL_USART_Receive+0xce>
    USART_MASK_COMPUTATION(husart);
24010be0:	f1b5 5f80 	cmp.w	r5, #268435456	@ 0x10000000
24010be4:	d10b      	bne.n	24010bfe <HAL_USART_Receive+0xae>
24010be6:	6925      	ldr	r5, [r4, #16]
24010be8:	b16d      	cbz	r5, 24010c06 <HAL_USART_Receive+0xb6>
24010bea:	263f      	movs	r6, #63	@ 0x3f
    uhMask = husart->Mask;
24010bec:	4637      	mov	r7, r6
24010bee:	e7d8      	b.n	24010ba2 <HAL_USART_Receive+0x52>
24010bf0:	f240 17ff 	movw	r7, #511	@ 0x1ff
    if ((husart->Init.WordLength == USART_WORDLENGTH_9B) && (husart->Init.Parity == USART_PARITY_NONE))
24010bf4:	4645      	mov	r5, r8
      prxdata8bits  = NULL;
24010bf6:	f04f 0800 	mov.w	r8, #0
    if ((husart->Init.WordLength == USART_WORDLENGTH_9B) && (husart->Init.Parity == USART_PARITY_NONE))
24010bfa:	463e      	mov	r6, r7
24010bfc:	e7d9      	b.n	24010bb2 <HAL_USART_Receive+0x62>
24010bfe:	465e      	mov	r6, fp
    uhMask = husart->Mask;
24010c00:	465f      	mov	r7, fp
      prxdata16bits = NULL;
24010c02:	465d      	mov	r5, fp
24010c04:	e7d5      	b.n	24010bb2 <HAL_USART_Receive+0x62>
24010c06:	267f      	movs	r6, #127	@ 0x7f
    uhMask = husart->Mask;
24010c08:	4637      	mov	r7, r6
24010c0a:	e7d2      	b.n	24010bb2 <HAL_USART_Receive+0x62>
      if (husart->SlaveMode == USART_SLAVEMODE_DISABLE)
24010c0c:	b95a      	cbnz	r2, 24010c26 <HAL_USART_Receive+0xd6>
        if (USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
24010c0e:	464b      	mov	r3, r9
24010c10:	4652      	mov	r2, sl
24010c12:	2180      	movs	r1, #128	@ 0x80
24010c14:	4620      	mov	r0, r4
24010c16:	f7ff fda0 	bl	2401075a <USART_WaitOnFlagUntilTimeout.constprop.0>
24010c1a:	b110      	cbz	r0, 24010c22 <HAL_USART_Receive+0xd2>
          return HAL_TIMEOUT;
24010c1c:	2003      	movs	r0, #3
}
24010c1e:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
        husart->Instance->TDR = (USART_DUMMY_DATA & (uint16_t)0x0FF);
24010c22:	6823      	ldr	r3, [r4, #0]
24010c24:	629e      	str	r6, [r3, #40]	@ 0x28
      if (USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_RXNE, RESET, tickstart, Timeout) != HAL_OK)
24010c26:	464b      	mov	r3, r9
24010c28:	4652      	mov	r2, sl
24010c2a:	2120      	movs	r1, #32
24010c2c:	4620      	mov	r0, r4
24010c2e:	f7ff fd94 	bl	2401075a <USART_WaitOnFlagUntilTimeout.constprop.0>
24010c32:	2800      	cmp	r0, #0
24010c34:	d1f2      	bne.n	24010c1c <HAL_USART_Receive+0xcc>
        *prxdata16bits = (uint16_t)(husart->Instance->RDR & uhMask);
24010c36:	6823      	ldr	r3, [r4, #0]
24010c38:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
24010c3a:	403b      	ands	r3, r7
      if (prxdata8bits == NULL)
24010c3c:	f1b8 0f00 	cmp.w	r8, #0
24010c40:	d106      	bne.n	24010c50 <HAL_USART_Receive+0x100>
        *prxdata16bits = (uint16_t)(husart->Instance->RDR & uhMask);
24010c42:	f825 3b02 	strh.w	r3, [r5], #2
      husart->RxXferCount--;
24010c46:	8ee1      	ldrh	r1, [r4, #54]	@ 0x36
24010c48:	3901      	subs	r1, #1
24010c4a:	b289      	uxth	r1, r1
24010c4c:	86e1      	strh	r1, [r4, #54]	@ 0x36
24010c4e:	e7b2      	b.n	24010bb6 <HAL_USART_Receive+0x66>
        *prxdata8bits = (uint8_t)(husart->Instance->RDR & (uint8_t)(uhMask & 0xFFU));
24010c50:	f808 3b01 	strb.w	r3, [r8], #1
        prxdata8bits++;
24010c54:	e7f7      	b.n	24010c46 <HAL_USART_Receive+0xf6>
    __HAL_LOCK(husart);
24010c56:	2002      	movs	r0, #2
24010c58:	e7e1      	b.n	24010c1e <HAL_USART_Receive+0xce>

24010c5a <HAL_USART_TransmitReceive>:
{
24010c5a:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
24010c5e:	461d      	mov	r5, r3
  if (husart->State == HAL_USART_STATE_READY)
24010c60:	f890 3059 	ldrb.w	r3, [r0, #89]	@ 0x59
{
24010c64:	4604      	mov	r4, r0
24010c66:	460f      	mov	r7, r1
  if (husart->State == HAL_USART_STATE_READY)
24010c68:	2b01      	cmp	r3, #1
{
24010c6a:	4691      	mov	r9, r2
24010c6c:	f8dd a028 	ldr.w	sl, [sp, #40]	@ 0x28
  if (husart->State == HAL_USART_STATE_READY)
24010c70:	b2d8      	uxtb	r0, r3
24010c72:	f040 80a0 	bne.w	24010db6 <HAL_USART_TransmitReceive+0x15c>
    if ((pTxData == NULL) || (pRxData == NULL) || (Size == 0U))
24010c76:	b379      	cbz	r1, 24010cd8 <HAL_USART_TransmitReceive+0x7e>
24010c78:	b372      	cbz	r2, 24010cd8 <HAL_USART_TransmitReceive+0x7e>
24010c7a:	b36d      	cbz	r5, 24010cd8 <HAL_USART_TransmitReceive+0x7e>
    __HAL_LOCK(husart);
24010c7c:	f894 3058 	ldrb.w	r3, [r4, #88]	@ 0x58
24010c80:	2b01      	cmp	r3, #1
24010c82:	f000 8098 	beq.w	24010db6 <HAL_USART_TransmitReceive+0x15c>
    husart->State = HAL_USART_STATE_BUSY_RX;
24010c86:	2322      	movs	r3, #34	@ 0x22
    husart->ErrorCode = HAL_USART_ERROR_NONE;
24010c88:	f04f 0800 	mov.w	r8, #0
    __HAL_LOCK(husart);
24010c8c:	f884 0058 	strb.w	r0, [r4, #88]	@ 0x58
    husart->ErrorCode = HAL_USART_ERROR_NONE;
24010c90:	f8c4 805c 	str.w	r8, [r4, #92]	@ 0x5c
    husart->State = HAL_USART_STATE_BUSY_RX;
24010c94:	f884 3059 	strb.w	r3, [r4, #89]	@ 0x59
    tickstart = HAL_GetTick();
24010c98:	f001 f8b6 	bl	24011e08 <HAL_GetTick>
    husart->TxXferCount = Size;
24010c9c:	85e5      	strh	r5, [r4, #46]	@ 0x2e
    husart->RxXferSize = Size;
24010c9e:	86a5      	strh	r5, [r4, #52]	@ 0x34
    tickstart = HAL_GetTick();
24010ca0:	4683      	mov	fp, r0
    husart->TxXferSize = Size;
24010ca2:	85a5      	strh	r5, [r4, #44]	@ 0x2c
    husart->RxXferCount = Size;
24010ca4:	86e5      	strh	r5, [r4, #54]	@ 0x36
    USART_MASK_COMPUTATION(husart);
24010ca6:	68a5      	ldr	r5, [r4, #8]
24010ca8:	f5b5 5f80 	cmp.w	r5, #4096	@ 0x1000
24010cac:	d116      	bne.n	24010cdc <HAL_USART_TransmitReceive+0x82>
24010cae:	6923      	ldr	r3, [r4, #16]
24010cb0:	b32b      	cbz	r3, 24010cfe <HAL_USART_TransmitReceive+0xa4>
    uhMask = husart->Mask;
24010cb2:	26ff      	movs	r6, #255	@ 0xff
      ptxdata16bits = NULL;
24010cb4:	4645      	mov	r5, r8
24010cb6:	4633      	mov	r3, r6
    USART_MASK_COMPUTATION(husart);
24010cb8:	8723      	strh	r3, [r4, #56]	@ 0x38
    if ((husart->TxXferCount == 0x01U) || (husart->SlaveMode == USART_SLAVEMODE_ENABLE))
24010cba:	8de3      	ldrh	r3, [r4, #46]	@ 0x2e
24010cbc:	b29b      	uxth	r3, r3
24010cbe:	2b01      	cmp	r3, #1
24010cc0:	d002      	beq.n	24010cc8 <HAL_USART_TransmitReceive+0x6e>
24010cc2:	6c23      	ldr	r3, [r4, #64]	@ 0x40
24010cc4:	2b01      	cmp	r3, #1
24010cc6:	d133      	bne.n	24010d30 <HAL_USART_TransmitReceive+0xd6>
      if (USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
24010cc8:	4653      	mov	r3, sl
24010cca:	465a      	mov	r2, fp
24010ccc:	2180      	movs	r1, #128	@ 0x80
24010cce:	4620      	mov	r0, r4
24010cd0:	f7ff fd43 	bl	2401075a <USART_WaitOnFlagUntilTimeout.constprop.0>
24010cd4:	b310      	cbz	r0, 24010d1c <HAL_USART_TransmitReceive+0xc2>
        return HAL_TIMEOUT;
24010cd6:	2003      	movs	r0, #3
}
24010cd8:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    USART_MASK_COMPUTATION(husart);
24010cdc:	b935      	cbnz	r5, 24010cec <HAL_USART_TransmitReceive+0x92>
24010cde:	6922      	ldr	r2, [r4, #16]
24010ce0:	b9ca      	cbnz	r2, 24010d16 <HAL_USART_TransmitReceive+0xbc>
24010ce2:	23ff      	movs	r3, #255	@ 0xff
      ptxdata16bits = NULL;
24010ce4:	4615      	mov	r5, r2
    uhMask = husart->Mask;
24010ce6:	461e      	mov	r6, r3
      prxdata16bits = NULL;
24010ce8:	46a8      	mov	r8, r5
24010cea:	e7e5      	b.n	24010cb8 <HAL_USART_TransmitReceive+0x5e>
    USART_MASK_COMPUTATION(husart);
24010cec:	f1b5 5f80 	cmp.w	r5, #268435456	@ 0x10000000
24010cf0:	d10d      	bne.n	24010d0e <HAL_USART_TransmitReceive+0xb4>
24010cf2:	6925      	ldr	r5, [r4, #16]
24010cf4:	b17d      	cbz	r5, 24010d16 <HAL_USART_TransmitReceive+0xbc>
24010cf6:	233f      	movs	r3, #63	@ 0x3f
      ptxdata16bits = NULL;
24010cf8:	4645      	mov	r5, r8
    uhMask = husart->Mask;
24010cfa:	461e      	mov	r6, r3
24010cfc:	e7f4      	b.n	24010ce8 <HAL_USART_TransmitReceive+0x8e>
24010cfe:	f240 16ff 	movw	r6, #511	@ 0x1ff
    if ((husart->Init.WordLength == USART_WORDLENGTH_9B) && (husart->Init.Parity == USART_PARITY_NONE))
24010d02:	463d      	mov	r5, r7
      ptxdata8bits  = NULL;
24010d04:	2700      	movs	r7, #0
    if ((husart->Init.WordLength == USART_WORDLENGTH_9B) && (husart->Init.Parity == USART_PARITY_NONE))
24010d06:	46c8      	mov	r8, r9
24010d08:	4633      	mov	r3, r6
      prxdata8bits  = NULL;
24010d0a:	46b9      	mov	r9, r7
24010d0c:	e7d4      	b.n	24010cb8 <HAL_USART_TransmitReceive+0x5e>
24010d0e:	4643      	mov	r3, r8
    uhMask = husart->Mask;
24010d10:	4646      	mov	r6, r8
      ptxdata16bits = NULL;
24010d12:	4645      	mov	r5, r8
24010d14:	e7d0      	b.n	24010cb8 <HAL_USART_TransmitReceive+0x5e>
24010d16:	237f      	movs	r3, #127	@ 0x7f
    uhMask = husart->Mask;
24010d18:	461e      	mov	r6, r3
24010d1a:	e7e5      	b.n	24010ce8 <HAL_USART_TransmitReceive+0x8e>
        husart->Instance->TDR = (uint16_t)(*ptxdata16bits & uhMask);
24010d1c:	6822      	ldr	r2, [r4, #0]
      if (ptxdata8bits == NULL)
24010d1e:	b99f      	cbnz	r7, 24010d48 <HAL_USART_TransmitReceive+0xee>
        husart->Instance->TDR = (uint16_t)(*ptxdata16bits & uhMask);
24010d20:	f835 3b02 	ldrh.w	r3, [r5], #2
        husart->Instance->TDR = (uint8_t)(*ptxdata8bits & (uint8_t)(uhMask & 0xFFU));
24010d24:	4033      	ands	r3, r6
24010d26:	6293      	str	r3, [r2, #40]	@ 0x28
      husart->TxXferCount--;
24010d28:	8de3      	ldrh	r3, [r4, #46]	@ 0x2e
24010d2a:	3b01      	subs	r3, #1
24010d2c:	b29b      	uxth	r3, r3
24010d2e:	85e3      	strh	r3, [r4, #46]	@ 0x2e
      rxdatacount = husart->RxXferCount;
24010d30:	8ee3      	ldrh	r3, [r4, #54]	@ 0x36
    while ((husart->TxXferCount > 0U) || (rxdatacount > 0U))
24010d32:	8de0      	ldrh	r0, [r4, #46]	@ 0x2e
      rxdatacount = husart->RxXferCount;
24010d34:	b29b      	uxth	r3, r3
    while ((husart->TxXferCount > 0U) || (rxdatacount > 0U))
24010d36:	b280      	uxth	r0, r0
24010d38:	4318      	orrs	r0, r3
24010d3a:	d108      	bne.n	24010d4e <HAL_USART_TransmitReceive+0xf4>
    husart->State = HAL_USART_STATE_READY;
24010d3c:	2301      	movs	r3, #1
    __HAL_UNLOCK(husart);
24010d3e:	f884 0058 	strb.w	r0, [r4, #88]	@ 0x58
    husart->State = HAL_USART_STATE_READY;
24010d42:	f884 3059 	strb.w	r3, [r4, #89]	@ 0x59
    return HAL_OK;
24010d46:	e7c7      	b.n	24010cd8 <HAL_USART_TransmitReceive+0x7e>
        husart->Instance->TDR = (uint8_t)(*ptxdata8bits & (uint8_t)(uhMask & 0xFFU));
24010d48:	f817 3b01 	ldrb.w	r3, [r7], #1
24010d4c:	e7ea      	b.n	24010d24 <HAL_USART_TransmitReceive+0xca>
      if (husart->TxXferCount > 0U)
24010d4e:	8de3      	ldrh	r3, [r4, #46]	@ 0x2e
24010d50:	b29b      	uxth	r3, r3
24010d52:	b18b      	cbz	r3, 24010d78 <HAL_USART_TransmitReceive+0x11e>
        if (USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
24010d54:	4653      	mov	r3, sl
24010d56:	465a      	mov	r2, fp
24010d58:	2180      	movs	r1, #128	@ 0x80
24010d5a:	4620      	mov	r0, r4
24010d5c:	f7ff fcfd 	bl	2401075a <USART_WaitOnFlagUntilTimeout.constprop.0>
24010d60:	2800      	cmp	r0, #0
24010d62:	d1b8      	bne.n	24010cd6 <HAL_USART_TransmitReceive+0x7c>
          husart->Instance->TDR = (uint16_t)(*ptxdata16bits & uhMask);
24010d64:	6822      	ldr	r2, [r4, #0]
        if (ptxdata8bits == NULL)
24010d66:	bb07      	cbnz	r7, 24010daa <HAL_USART_TransmitReceive+0x150>
          husart->Instance->TDR = (uint16_t)(*ptxdata16bits & uhMask);
24010d68:	f835 3b02 	ldrh.w	r3, [r5], #2
          husart->Instance->TDR = (uint8_t)(*ptxdata8bits & (uint8_t)(uhMask & 0xFFU));
24010d6c:	4033      	ands	r3, r6
24010d6e:	6293      	str	r3, [r2, #40]	@ 0x28
        husart->TxXferCount--;
24010d70:	8de3      	ldrh	r3, [r4, #46]	@ 0x2e
24010d72:	3b01      	subs	r3, #1
24010d74:	b29b      	uxth	r3, r3
24010d76:	85e3      	strh	r3, [r4, #46]	@ 0x2e
      if (husart->RxXferCount > 0U)
24010d78:	8ee3      	ldrh	r3, [r4, #54]	@ 0x36
24010d7a:	b29b      	uxth	r3, r3
24010d7c:	2b00      	cmp	r3, #0
24010d7e:	d0d7      	beq.n	24010d30 <HAL_USART_TransmitReceive+0xd6>
        if (USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_RXNE, RESET, tickstart, Timeout) != HAL_OK)
24010d80:	4653      	mov	r3, sl
24010d82:	465a      	mov	r2, fp
24010d84:	2120      	movs	r1, #32
24010d86:	4620      	mov	r0, r4
24010d88:	f7ff fce7 	bl	2401075a <USART_WaitOnFlagUntilTimeout.constprop.0>
24010d8c:	2800      	cmp	r0, #0
24010d8e:	d1a2      	bne.n	24010cd6 <HAL_USART_TransmitReceive+0x7c>
          *prxdata16bits = (uint16_t)(husart->Instance->RDR & uhMask);
24010d90:	6823      	ldr	r3, [r4, #0]
24010d92:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
24010d94:	4033      	ands	r3, r6
        if (prxdata8bits == NULL)
24010d96:	f1b9 0f00 	cmp.w	r9, #0
24010d9a:	d109      	bne.n	24010db0 <HAL_USART_TransmitReceive+0x156>
          *prxdata16bits = (uint16_t)(husart->Instance->RDR & uhMask);
24010d9c:	f828 3b02 	strh.w	r3, [r8], #2
        husart->RxXferCount--;
24010da0:	8ee3      	ldrh	r3, [r4, #54]	@ 0x36
24010da2:	3b01      	subs	r3, #1
24010da4:	b29b      	uxth	r3, r3
24010da6:	86e3      	strh	r3, [r4, #54]	@ 0x36
24010da8:	e7c2      	b.n	24010d30 <HAL_USART_TransmitReceive+0xd6>
          husart->Instance->TDR = (uint8_t)(*ptxdata8bits & (uint8_t)(uhMask & 0xFFU));
24010daa:	f817 3b01 	ldrb.w	r3, [r7], #1
24010dae:	e7dd      	b.n	24010d6c <HAL_USART_TransmitReceive+0x112>
          *prxdata8bits = (uint8_t)(husart->Instance->RDR & (uint8_t)(uhMask & 0xFFU));
24010db0:	f809 3b01 	strb.w	r3, [r9], #1
          prxdata8bits++;
24010db4:	e7f4      	b.n	24010da0 <HAL_USART_TransmitReceive+0x146>
    __HAL_LOCK(husart);
24010db6:	2002      	movs	r0, #2
24010db8:	e78e      	b.n	24010cd8 <HAL_USART_TransmitReceive+0x7e>

24010dba <HAL_USART_Transmit_IT>:
{
24010dba:	b510      	push	{r4, lr}
  if (husart->State == HAL_USART_STATE_READY)
24010dbc:	f890 4059 	ldrb.w	r4, [r0, #89]	@ 0x59
{
24010dc0:	4603      	mov	r3, r0
  if (husart->State == HAL_USART_STATE_READY)
24010dc2:	2c01      	cmp	r4, #1
24010dc4:	b2e0      	uxtb	r0, r4
24010dc6:	d13e      	bne.n	24010e46 <HAL_USART_Transmit_IT+0x8c>
    if ((pTxData == NULL) || (Size == 0U))
24010dc8:	b331      	cbz	r1, 24010e18 <HAL_USART_Transmit_IT+0x5e>
24010dca:	b32a      	cbz	r2, 24010e18 <HAL_USART_Transmit_IT+0x5e>
    __HAL_LOCK(husart);
24010dcc:	f893 4058 	ldrb.w	r4, [r3, #88]	@ 0x58
24010dd0:	2c01      	cmp	r4, #1
24010dd2:	d038      	beq.n	24010e46 <HAL_USART_Transmit_IT+0x8c>
    husart->TxXferCount = Size;
24010dd4:	85da      	strh	r2, [r3, #46]	@ 0x2e
    husart->TxXferSize  = Size;
24010dd6:	859a      	strh	r2, [r3, #44]	@ 0x2c
    husart->ErrorCode = HAL_USART_ERROR_NONE;
24010dd8:	2200      	movs	r2, #0
    husart->pTxBuffPtr  = pTxData;
24010dda:	6299      	str	r1, [r3, #40]	@ 0x28
    husart->ErrorCode = HAL_USART_ERROR_NONE;
24010ddc:	65da      	str	r2, [r3, #92]	@ 0x5c
    husart->State     = HAL_USART_STATE_BUSY_TX;
24010dde:	2212      	movs	r2, #18
      if ((husart->Init.WordLength == USART_WORDLENGTH_9B) && (husart->Init.Parity == USART_PARITY_NONE))
24010de0:	6899      	ldr	r1, [r3, #8]
    husart->State     = HAL_USART_STATE_BUSY_TX;
24010de2:	f883 2059 	strb.w	r2, [r3, #89]	@ 0x59
    if (husart->FifoMode == USART_FIFOMODE_ENABLE)
24010de6:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
    __HAL_LOCK(husart);
24010de8:	f883 0058 	strb.w	r0, [r3, #88]	@ 0x58
    if (husart->FifoMode == USART_FIFOMODE_ENABLE)
24010dec:	f1b2 5f00 	cmp.w	r2, #536870912	@ 0x20000000
24010df0:	681a      	ldr	r2, [r3, #0]
24010df2:	d114      	bne.n	24010e1e <HAL_USART_Transmit_IT+0x64>
      if ((husart->Init.WordLength == USART_WORDLENGTH_9B) && (husart->Init.Parity == USART_PARITY_NONE))
24010df4:	f5b1 5f80 	cmp.w	r1, #4096	@ 0x1000
24010df8:	d10f      	bne.n	24010e1a <HAL_USART_Transmit_IT+0x60>
24010dfa:	691c      	ldr	r4, [r3, #16]
        husart->TxISR = USART_TxISR_16BIT_FIFOEN;
24010dfc:	4913      	ldr	r1, [pc, #76]	@ (24010e4c <HAL_USART_Transmit_IT+0x92>)
24010dfe:	4814      	ldr	r0, [pc, #80]	@ (24010e50 <HAL_USART_Transmit_IT+0x96>)
24010e00:	2c00      	cmp	r4, #0
24010e02:	bf08      	it	eq
24010e04:	4601      	moveq	r1, r0
24010e06:	64d9      	str	r1, [r3, #76]	@ 0x4c
      __HAL_UNLOCK(husart);
24010e08:	2100      	movs	r1, #0
24010e0a:	f883 1058 	strb.w	r1, [r3, #88]	@ 0x58
      __HAL_USART_ENABLE_IT(husart, USART_IT_TXFT);
24010e0e:	6893      	ldr	r3, [r2, #8]
24010e10:	f443 0300 	orr.w	r3, r3, #8388608	@ 0x800000
24010e14:	6093      	str	r3, [r2, #8]
    return HAL_OK;
24010e16:	2000      	movs	r0, #0
}
24010e18:	bd10      	pop	{r4, pc}
        husart->TxISR = USART_TxISR_8BIT_FIFOEN;
24010e1a:	490c      	ldr	r1, [pc, #48]	@ (24010e4c <HAL_USART_Transmit_IT+0x92>)
24010e1c:	e7f3      	b.n	24010e06 <HAL_USART_Transmit_IT+0x4c>
      if ((husart->Init.WordLength == USART_WORDLENGTH_9B) && (husart->Init.Parity == USART_PARITY_NONE))
24010e1e:	f5b1 5f80 	cmp.w	r1, #4096	@ 0x1000
24010e22:	d10e      	bne.n	24010e42 <HAL_USART_Transmit_IT+0x88>
24010e24:	691c      	ldr	r4, [r3, #16]
        husart->TxISR = USART_TxISR_16BIT;
24010e26:	490b      	ldr	r1, [pc, #44]	@ (24010e54 <HAL_USART_Transmit_IT+0x9a>)
24010e28:	480b      	ldr	r0, [pc, #44]	@ (24010e58 <HAL_USART_Transmit_IT+0x9e>)
24010e2a:	2c00      	cmp	r4, #0
24010e2c:	bf08      	it	eq
24010e2e:	4601      	moveq	r1, r0
24010e30:	64d9      	str	r1, [r3, #76]	@ 0x4c
      __HAL_UNLOCK(husart);
24010e32:	2100      	movs	r1, #0
24010e34:	f883 1058 	strb.w	r1, [r3, #88]	@ 0x58
      __HAL_USART_ENABLE_IT(husart, USART_IT_TXE);
24010e38:	6813      	ldr	r3, [r2, #0]
24010e3a:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
24010e3e:	6013      	str	r3, [r2, #0]
24010e40:	e7e9      	b.n	24010e16 <HAL_USART_Transmit_IT+0x5c>
        husart->TxISR = USART_TxISR_8BIT;
24010e42:	4904      	ldr	r1, [pc, #16]	@ (24010e54 <HAL_USART_Transmit_IT+0x9a>)
24010e44:	e7f4      	b.n	24010e30 <HAL_USART_Transmit_IT+0x76>
    __HAL_LOCK(husart);
24010e46:	2002      	movs	r0, #2
24010e48:	e7e6      	b.n	24010e18 <HAL_USART_Transmit_IT+0x5e>
24010e4a:	bf00      	nop
24010e4c:	240106c3 	.word	0x240106c3
24010e50:	2401070d 	.word	0x2401070d
24010e54:	2401064b 	.word	0x2401064b
24010e58:	24010685 	.word	0x24010685

24010e5c <HAL_USART_Receive_IT>:
{
24010e5c:	b570      	push	{r4, r5, r6, lr}
  if (husart->State == HAL_USART_STATE_READY)
24010e5e:	f890 4059 	ldrb.w	r4, [r0, #89]	@ 0x59
{
24010e62:	4603      	mov	r3, r0
  if (husart->State == HAL_USART_STATE_READY)
24010e64:	2c01      	cmp	r4, #1
24010e66:	b2e0      	uxtb	r0, r4
24010e68:	d177      	bne.n	24010f5a <HAL_USART_Receive_IT+0xfe>
    if ((pRxData == NULL) || (Size == 0U))
24010e6a:	2900      	cmp	r1, #0
24010e6c:	d03e      	beq.n	24010eec <HAL_USART_Receive_IT+0x90>
24010e6e:	2a00      	cmp	r2, #0
24010e70:	d03c      	beq.n	24010eec <HAL_USART_Receive_IT+0x90>
    __HAL_LOCK(husart);
24010e72:	f893 4058 	ldrb.w	r4, [r3, #88]	@ 0x58
24010e76:	2c01      	cmp	r4, #1
24010e78:	d06f      	beq.n	24010f5a <HAL_USART_Receive_IT+0xfe>
    USART_MASK_COMPUTATION(husart);
24010e7a:	689c      	ldr	r4, [r3, #8]
    __HAL_LOCK(husart);
24010e7c:	f883 0058 	strb.w	r0, [r3, #88]	@ 0x58
    USART_MASK_COMPUTATION(husart);
24010e80:	f5b4 5f80 	cmp.w	r4, #4096	@ 0x1000
24010e84:	6918      	ldr	r0, [r3, #16]
    husart->pRxBuffPtr  = pRxData;
24010e86:	6319      	str	r1, [r3, #48]	@ 0x30
    husart->RxXferSize  = Size;
24010e88:	869a      	strh	r2, [r3, #52]	@ 0x34
    husart->RxXferCount = Size;
24010e8a:	86da      	strh	r2, [r3, #54]	@ 0x36
    USART_MASK_COMPUTATION(husart);
24010e8c:	d12f      	bne.n	24010eee <HAL_USART_Receive_IT+0x92>
24010e8e:	2800      	cmp	r0, #0
24010e90:	f240 11ff 	movw	r1, #511	@ 0x1ff
24010e94:	bf18      	it	ne
24010e96:	21ff      	movne	r1, #255	@ 0xff
24010e98:	8719      	strh	r1, [r3, #56]	@ 0x38
    husart->ErrorCode = HAL_USART_ERROR_NONE;
24010e9a:	2100      	movs	r1, #0
24010e9c:	65d9      	str	r1, [r3, #92]	@ 0x5c
    husart->State = HAL_USART_STATE_BUSY_RX;
24010e9e:	2122      	movs	r1, #34	@ 0x22
24010ea0:	f883 1059 	strb.w	r1, [r3, #89]	@ 0x59
    SET_BIT(husart->Instance->CR3, USART_CR3_EIE);
24010ea4:	6819      	ldr	r1, [r3, #0]
24010ea6:	688d      	ldr	r5, [r1, #8]
24010ea8:	f045 0501 	orr.w	r5, r5, #1
24010eac:	608d      	str	r5, [r1, #8]
    if ((husart->FifoMode == USART_FIFOMODE_ENABLE) && (Size >= husart->NbRxDataToProcess))
24010eae:	6c5d      	ldr	r5, [r3, #68]	@ 0x44
24010eb0:	f1b5 5f00 	cmp.w	r5, #536870912	@ 0x20000000
24010eb4:	d12b      	bne.n	24010f0e <HAL_USART_Receive_IT+0xb2>
24010eb6:	8f5e      	ldrh	r6, [r3, #58]	@ 0x3a
24010eb8:	4296      	cmp	r6, r2
24010eba:	d828      	bhi.n	24010f0e <HAL_USART_Receive_IT+0xb2>
      if ((husart->Init.WordLength == USART_WORDLENGTH_9B) && (husart->Init.Parity == USART_PARITY_NONE))
24010ebc:	f5b4 5f80 	cmp.w	r4, #4096	@ 0x1000
        husart->RxISR = USART_RxISR_16BIT_FIFOEN;
24010ec0:	4c27      	ldr	r4, [pc, #156]	@ (24010f60 <HAL_USART_Receive_IT+0x104>)
      if ((husart->Init.WordLength == USART_WORDLENGTH_9B) && (husart->Init.Parity == USART_PARITY_NONE))
24010ec2:	d103      	bne.n	24010ecc <HAL_USART_Receive_IT+0x70>
        husart->RxISR = USART_RxISR_16BIT_FIFOEN;
24010ec4:	4e27      	ldr	r6, [pc, #156]	@ (24010f64 <HAL_USART_Receive_IT+0x108>)
24010ec6:	2800      	cmp	r0, #0
24010ec8:	bf08      	it	eq
24010eca:	4634      	moveq	r4, r6
24010ecc:	649c      	str	r4, [r3, #72]	@ 0x48
      __HAL_UNLOCK(husart);
24010ece:	2400      	movs	r4, #0
24010ed0:	f883 4058 	strb.w	r4, [r3, #88]	@ 0x58
      if (husart->Init.Parity != USART_PARITY_NONE)
24010ed4:	b118      	cbz	r0, 24010ede <HAL_USART_Receive_IT+0x82>
        SET_BIT(husart->Instance->CR1, USART_CR1_PEIE);
24010ed6:	6808      	ldr	r0, [r1, #0]
24010ed8:	f440 7080 	orr.w	r0, r0, #256	@ 0x100
24010edc:	6008      	str	r0, [r1, #0]
      SET_BIT(husart->Instance->CR3, USART_CR3_RXFTIE);
24010ede:	6888      	ldr	r0, [r1, #8]
24010ee0:	f040 5080 	orr.w	r0, r0, #268435456	@ 0x10000000
24010ee4:	6088      	str	r0, [r1, #8]
    if (husart->SlaveMode == USART_SLAVEMODE_DISABLE)
24010ee6:	6c18      	ldr	r0, [r3, #64]	@ 0x40
24010ee8:	b338      	cbz	r0, 24010f3a <HAL_USART_Receive_IT+0xde>
    return HAL_OK;
24010eea:	2000      	movs	r0, #0
}
24010eec:	bd70      	pop	{r4, r5, r6, pc}
    USART_MASK_COMPUTATION(husart);
24010eee:	b924      	cbnz	r4, 24010efa <HAL_USART_Receive_IT+0x9e>
24010ef0:	2800      	cmp	r0, #0
24010ef2:	bf14      	ite	ne
24010ef4:	217f      	movne	r1, #127	@ 0x7f
24010ef6:	21ff      	moveq	r1, #255	@ 0xff
24010ef8:	e7ce      	b.n	24010e98 <HAL_USART_Receive_IT+0x3c>
24010efa:	f1b4 5f80 	cmp.w	r4, #268435456	@ 0x10000000
24010efe:	d104      	bne.n	24010f0a <HAL_USART_Receive_IT+0xae>
24010f00:	2800      	cmp	r0, #0
24010f02:	bf14      	ite	ne
24010f04:	213f      	movne	r1, #63	@ 0x3f
24010f06:	217f      	moveq	r1, #127	@ 0x7f
24010f08:	e7c6      	b.n	24010e98 <HAL_USART_Receive_IT+0x3c>
24010f0a:	2100      	movs	r1, #0
24010f0c:	e7c4      	b.n	24010e98 <HAL_USART_Receive_IT+0x3c>
      if ((husart->Init.WordLength == USART_WORDLENGTH_9B) && (husart->Init.Parity == USART_PARITY_NONE))
24010f0e:	f5b4 5f80 	cmp.w	r4, #4096	@ 0x1000
        husart->RxISR = USART_RxISR_16BIT;
24010f12:	4c15      	ldr	r4, [pc, #84]	@ (24010f68 <HAL_USART_Receive_IT+0x10c>)
      if ((husart->Init.WordLength == USART_WORDLENGTH_9B) && (husart->Init.Parity == USART_PARITY_NONE))
24010f14:	d103      	bne.n	24010f1e <HAL_USART_Receive_IT+0xc2>
        husart->RxISR = USART_RxISR_16BIT;
24010f16:	4e15      	ldr	r6, [pc, #84]	@ (24010f6c <HAL_USART_Receive_IT+0x110>)
24010f18:	2800      	cmp	r0, #0
24010f1a:	bf08      	it	eq
24010f1c:	4634      	moveq	r4, r6
24010f1e:	649c      	str	r4, [r3, #72]	@ 0x48
      __HAL_UNLOCK(husart);
24010f20:	2400      	movs	r4, #0
24010f22:	f883 4058 	strb.w	r4, [r3, #88]	@ 0x58
      if (husart->Init.Parity != USART_PARITY_NONE)
24010f26:	b120      	cbz	r0, 24010f32 <HAL_USART_Receive_IT+0xd6>
        SET_BIT(husart->Instance->CR1, USART_CR1_PEIE | USART_CR1_RXNEIE_RXFNEIE);
24010f28:	6808      	ldr	r0, [r1, #0]
24010f2a:	f440 7090 	orr.w	r0, r0, #288	@ 0x120
        SET_BIT(husart->Instance->CR1, USART_CR1_RXNEIE_RXFNEIE);
24010f2e:	6008      	str	r0, [r1, #0]
24010f30:	e7d9      	b.n	24010ee6 <HAL_USART_Receive_IT+0x8a>
24010f32:	6808      	ldr	r0, [r1, #0]
24010f34:	f040 0020 	orr.w	r0, r0, #32
24010f38:	e7f9      	b.n	24010f2e <HAL_USART_Receive_IT+0xd2>
      if ((husart->FifoMode == USART_FIFOMODE_ENABLE) && (Size >= husart->NbRxDataToProcess))
24010f3a:	f1b5 5f00 	cmp.w	r5, #536870912	@ 0x20000000
24010f3e:	d109      	bne.n	24010f54 <HAL_USART_Receive_IT+0xf8>
24010f40:	8f5b      	ldrh	r3, [r3, #58]	@ 0x3a
24010f42:	4293      	cmp	r3, r2
24010f44:	d806      	bhi.n	24010f54 <HAL_USART_Receive_IT+0xf8>
          husart->Instance->TDR = (USART_DUMMY_DATA & (uint16_t)0x00FF);
24010f46:	22ff      	movs	r2, #255	@ 0xff
        for (nb_dummy_data = husart->NbRxDataToProcess ; nb_dummy_data > 0U ; nb_dummy_data--)
24010f48:	2b00      	cmp	r3, #0
24010f4a:	d0ce      	beq.n	24010eea <HAL_USART_Receive_IT+0x8e>
24010f4c:	3b01      	subs	r3, #1
          husart->Instance->TDR = (USART_DUMMY_DATA & (uint16_t)0x00FF);
24010f4e:	628a      	str	r2, [r1, #40]	@ 0x28
        for (nb_dummy_data = husart->NbRxDataToProcess ; nb_dummy_data > 0U ; nb_dummy_data--)
24010f50:	b29b      	uxth	r3, r3
24010f52:	e7f9      	b.n	24010f48 <HAL_USART_Receive_IT+0xec>
        husart->Instance->TDR = (USART_DUMMY_DATA & (uint16_t)0x00FF);
24010f54:	23ff      	movs	r3, #255	@ 0xff
24010f56:	628b      	str	r3, [r1, #40]	@ 0x28
24010f58:	e7c7      	b.n	24010eea <HAL_USART_Receive_IT+0x8e>
    __HAL_LOCK(husart);
24010f5a:	2002      	movs	r0, #2
24010f5c:	e7c6      	b.n	24010eec <HAL_USART_Receive_IT+0x90>
24010f5e:	bf00      	nop
24010f60:	24011655 	.word	0x24011655
24010f64:	24011759 	.word	0x24011759
24010f68:	24011517 	.word	0x24011517
24010f6c:	240115b9 	.word	0x240115b9

24010f70 <HAL_USART_TransmitReceive_IT>:
{
24010f70:	b530      	push	{r4, r5, lr}
  if (husart->State == HAL_USART_STATE_READY)
24010f72:	f890 5059 	ldrb.w	r5, [r0, #89]	@ 0x59
{
24010f76:	4604      	mov	r4, r0
  if (husart->State == HAL_USART_STATE_READY)
24010f78:	2d01      	cmp	r5, #1
24010f7a:	b2e8      	uxtb	r0, r5
24010f7c:	f040 8082 	bne.w	24011084 <HAL_USART_TransmitReceive_IT+0x114>
    if ((pTxData == NULL) || (pRxData == NULL) || (Size == 0U))
24010f80:	2900      	cmp	r1, #0
24010f82:	d046      	beq.n	24011012 <HAL_USART_TransmitReceive_IT+0xa2>
24010f84:	2a00      	cmp	r2, #0
24010f86:	d044      	beq.n	24011012 <HAL_USART_TransmitReceive_IT+0xa2>
24010f88:	2b00      	cmp	r3, #0
24010f8a:	d042      	beq.n	24011012 <HAL_USART_TransmitReceive_IT+0xa2>
    __HAL_LOCK(husart);
24010f8c:	f894 5058 	ldrb.w	r5, [r4, #88]	@ 0x58
24010f90:	2d01      	cmp	r5, #1
24010f92:	d077      	beq.n	24011084 <HAL_USART_TransmitReceive_IT+0x114>
24010f94:	f884 0058 	strb.w	r0, [r4, #88]	@ 0x58
    USART_MASK_COMPUTATION(husart);
24010f98:	68a0      	ldr	r0, [r4, #8]
    husart->RxXferCount = Size;
24010f9a:	86e3      	strh	r3, [r4, #54]	@ 0x36
    USART_MASK_COMPUTATION(husart);
24010f9c:	f5b0 5f80 	cmp.w	r0, #4096	@ 0x1000
    husart->pTxBuffPtr = pTxData;
24010fa0:	62a1      	str	r1, [r4, #40]	@ 0x28
    husart->pRxBuffPtr = pRxData;
24010fa2:	6322      	str	r2, [r4, #48]	@ 0x30
    USART_MASK_COMPUTATION(husart);
24010fa4:	6921      	ldr	r1, [r4, #16]
    husart->RxXferSize = Size;
24010fa6:	86a3      	strh	r3, [r4, #52]	@ 0x34
    husart->TxXferSize = Size;
24010fa8:	85a3      	strh	r3, [r4, #44]	@ 0x2c
    husart->TxXferCount = Size;
24010faa:	85e3      	strh	r3, [r4, #46]	@ 0x2e
    USART_MASK_COMPUTATION(husart);
24010fac:	d132      	bne.n	24011014 <HAL_USART_TransmitReceive_IT+0xa4>
24010fae:	2900      	cmp	r1, #0
24010fb0:	f240 12ff 	movw	r2, #511	@ 0x1ff
24010fb4:	bf18      	it	ne
24010fb6:	22ff      	movne	r2, #255	@ 0xff
24010fb8:	8722      	strh	r2, [r4, #56]	@ 0x38
    husart->ErrorCode = HAL_USART_ERROR_NONE;
24010fba:	2200      	movs	r2, #0
24010fbc:	65e2      	str	r2, [r4, #92]	@ 0x5c
    husart->State = HAL_USART_STATE_BUSY_TX_RX;
24010fbe:	2232      	movs	r2, #50	@ 0x32
24010fc0:	f884 2059 	strb.w	r2, [r4, #89]	@ 0x59
    if ((husart->FifoMode == USART_FIFOMODE_ENABLE) && (Size >= husart->NbRxDataToProcess))
24010fc4:	6c62      	ldr	r2, [r4, #68]	@ 0x44
24010fc6:	f1b2 5f00 	cmp.w	r2, #536870912	@ 0x20000000
24010fca:	6822      	ldr	r2, [r4, #0]
24010fcc:	d135      	bne.n	2401103a <HAL_USART_TransmitReceive_IT+0xca>
24010fce:	8f65      	ldrh	r5, [r4, #58]	@ 0x3a
24010fd0:	429d      	cmp	r5, r3
24010fd2:	d832      	bhi.n	2401103a <HAL_USART_TransmitReceive_IT+0xca>
      if ((husart->Init.WordLength == USART_WORDLENGTH_9B) && (husart->Init.Parity == USART_PARITY_NONE))
24010fd4:	f5b0 5f80 	cmp.w	r0, #4096	@ 0x1000
24010fd8:	d12c      	bne.n	24011034 <HAL_USART_TransmitReceive_IT+0xc4>
24010fda:	2900      	cmp	r1, #0
24010fdc:	4b2a      	ldr	r3, [pc, #168]	@ (24011088 <HAL_USART_TransmitReceive_IT+0x118>)
24010fde:	4d2b      	ldr	r5, [pc, #172]	@ (2401108c <HAL_USART_TransmitReceive_IT+0x11c>)
24010fe0:	482b      	ldr	r0, [pc, #172]	@ (24011090 <HAL_USART_TransmitReceive_IT+0x120>)
24010fe2:	bf08      	it	eq
24010fe4:	4618      	moveq	r0, r3
24010fe6:	4b2b      	ldr	r3, [pc, #172]	@ (24011094 <HAL_USART_TransmitReceive_IT+0x124>)
24010fe8:	bf08      	it	eq
24010fea:	462b      	moveq	r3, r5
        husart->RxISR = USART_RxISR_16BIT_FIFOEN;
24010fec:	e9c4 3012 	strd	r3, r0, [r4, #72]	@ 0x48
      __HAL_UNLOCK(husart);
24010ff0:	2300      	movs	r3, #0
24010ff2:	f884 3058 	strb.w	r3, [r4, #88]	@ 0x58
      SET_BIT(husart->Instance->CR3, USART_CR3_EIE);
24010ff6:	6893      	ldr	r3, [r2, #8]
24010ff8:	f043 0301 	orr.w	r3, r3, #1
24010ffc:	6093      	str	r3, [r2, #8]
      if (husart->Init.Parity != USART_PARITY_NONE)
24010ffe:	b119      	cbz	r1, 24011008 <HAL_USART_TransmitReceive_IT+0x98>
        SET_BIT(husart->Instance->CR1, USART_CR1_PEIE);
24011000:	6813      	ldr	r3, [r2, #0]
24011002:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
24011006:	6013      	str	r3, [r2, #0]
      SET_BIT(husart->Instance->CR3, (USART_CR3_TXFTIE | USART_CR3_RXFTIE));
24011008:	6893      	ldr	r3, [r2, #8]
2401100a:	f043 5384 	orr.w	r3, r3, #276824064	@ 0x10800000
2401100e:	6093      	str	r3, [r2, #8]
    return HAL_OK;
24011010:	2000      	movs	r0, #0
}
24011012:	bd30      	pop	{r4, r5, pc}
    USART_MASK_COMPUTATION(husart);
24011014:	b920      	cbnz	r0, 24011020 <HAL_USART_TransmitReceive_IT+0xb0>
24011016:	2900      	cmp	r1, #0
24011018:	bf14      	ite	ne
2401101a:	227f      	movne	r2, #127	@ 0x7f
2401101c:	22ff      	moveq	r2, #255	@ 0xff
2401101e:	e7cb      	b.n	24010fb8 <HAL_USART_TransmitReceive_IT+0x48>
24011020:	f1b0 5f80 	cmp.w	r0, #268435456	@ 0x10000000
24011024:	d104      	bne.n	24011030 <HAL_USART_TransmitReceive_IT+0xc0>
24011026:	2900      	cmp	r1, #0
24011028:	bf14      	ite	ne
2401102a:	223f      	movne	r2, #63	@ 0x3f
2401102c:	227f      	moveq	r2, #127	@ 0x7f
2401102e:	e7c3      	b.n	24010fb8 <HAL_USART_TransmitReceive_IT+0x48>
24011030:	2200      	movs	r2, #0
24011032:	e7c1      	b.n	24010fb8 <HAL_USART_TransmitReceive_IT+0x48>
24011034:	4816      	ldr	r0, [pc, #88]	@ (24011090 <HAL_USART_TransmitReceive_IT+0x120>)
24011036:	4b17      	ldr	r3, [pc, #92]	@ (24011094 <HAL_USART_TransmitReceive_IT+0x124>)
24011038:	e7d8      	b.n	24010fec <HAL_USART_TransmitReceive_IT+0x7c>
      if ((husart->Init.WordLength == USART_WORDLENGTH_9B) && (husart->Init.Parity == USART_PARITY_NONE))
2401103a:	f5b0 5f80 	cmp.w	r0, #4096	@ 0x1000
2401103e:	d11b      	bne.n	24011078 <HAL_USART_TransmitReceive_IT+0x108>
24011040:	2900      	cmp	r1, #0
24011042:	4b15      	ldr	r3, [pc, #84]	@ (24011098 <HAL_USART_TransmitReceive_IT+0x128>)
24011044:	4d15      	ldr	r5, [pc, #84]	@ (2401109c <HAL_USART_TransmitReceive_IT+0x12c>)
24011046:	4816      	ldr	r0, [pc, #88]	@ (240110a0 <HAL_USART_TransmitReceive_IT+0x130>)
24011048:	bf08      	it	eq
2401104a:	4618      	moveq	r0, r3
2401104c:	4b15      	ldr	r3, [pc, #84]	@ (240110a4 <HAL_USART_TransmitReceive_IT+0x134>)
2401104e:	bf08      	it	eq
24011050:	462b      	moveq	r3, r5
        husart->RxISR = USART_RxISR_16BIT;
24011052:	e9c4 3012 	strd	r3, r0, [r4, #72]	@ 0x48
      __HAL_UNLOCK(husart);
24011056:	2300      	movs	r3, #0
24011058:	f884 3058 	strb.w	r3, [r4, #88]	@ 0x58
      SET_BIT(husart->Instance->CR3, USART_CR3_EIE);
2401105c:	6893      	ldr	r3, [r2, #8]
2401105e:	f043 0301 	orr.w	r3, r3, #1
24011062:	6093      	str	r3, [r2, #8]
        SET_BIT(husart->Instance->CR1, USART_CR1_PEIE | USART_CR1_RXNEIE_RXFNEIE);
24011064:	6813      	ldr	r3, [r2, #0]
      if (husart->Init.Parity != USART_PARITY_NONE)
24011066:	b151      	cbz	r1, 2401107e <HAL_USART_TransmitReceive_IT+0x10e>
        SET_BIT(husart->Instance->CR1, USART_CR1_PEIE | USART_CR1_RXNEIE_RXFNEIE);
24011068:	f443 7390 	orr.w	r3, r3, #288	@ 0x120
        SET_BIT(husart->Instance->CR1, USART_CR1_RXNEIE_RXFNEIE);
2401106c:	6013      	str	r3, [r2, #0]
      SET_BIT(husart->Instance->CR1, USART_CR1_TXEIE_TXFNFIE);
2401106e:	6813      	ldr	r3, [r2, #0]
24011070:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
24011074:	6013      	str	r3, [r2, #0]
24011076:	e7cb      	b.n	24011010 <HAL_USART_TransmitReceive_IT+0xa0>
24011078:	4809      	ldr	r0, [pc, #36]	@ (240110a0 <HAL_USART_TransmitReceive_IT+0x130>)
2401107a:	4b0a      	ldr	r3, [pc, #40]	@ (240110a4 <HAL_USART_TransmitReceive_IT+0x134>)
2401107c:	e7e9      	b.n	24011052 <HAL_USART_TransmitReceive_IT+0xe2>
        SET_BIT(husart->Instance->CR1, USART_CR1_RXNEIE_RXFNEIE);
2401107e:	f043 0320 	orr.w	r3, r3, #32
24011082:	e7f3      	b.n	2401106c <HAL_USART_TransmitReceive_IT+0xfc>
    __HAL_LOCK(husart);
24011084:	2002      	movs	r0, #2
24011086:	e7c4      	b.n	24011012 <HAL_USART_TransmitReceive_IT+0xa2>
24011088:	2401070d 	.word	0x2401070d
2401108c:	24011759 	.word	0x24011759
24011090:	240106c3 	.word	0x240106c3
24011094:	24011655 	.word	0x24011655
24011098:	24010685 	.word	0x24010685
2401109c:	240115b9 	.word	0x240115b9
240110a0:	2401064b 	.word	0x2401064b
240110a4:	24011517 	.word	0x24011517

240110a8 <HAL_USART_Transmit_DMA>:
{
240110a8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
240110aa:	4604      	mov	r4, r0
240110ac:	4613      	mov	r3, r2
  if (husart->State == HAL_USART_STATE_READY)
240110ae:	f894 2059 	ldrb.w	r2, [r4, #89]	@ 0x59
240110b2:	2a01      	cmp	r2, #1
240110b4:	b2d5      	uxtb	r5, r2
240110b6:	d130      	bne.n	2401111a <HAL_USART_Transmit_DMA+0x72>
    if ((pTxData == NULL) || (Size == 0U))
240110b8:	b1d9      	cbz	r1, 240110f2 <HAL_USART_Transmit_DMA+0x4a>
240110ba:	b1d3      	cbz	r3, 240110f2 <HAL_USART_Transmit_DMA+0x4a>
    __HAL_LOCK(husart);
240110bc:	f894 2058 	ldrb.w	r2, [r4, #88]	@ 0x58
240110c0:	2a01      	cmp	r2, #1
240110c2:	d02a      	beq.n	2401111a <HAL_USART_Transmit_DMA+0x72>
    husart->State = HAL_USART_STATE_BUSY_TX;
240110c4:	2212      	movs	r2, #18
    husart->ErrorCode = HAL_USART_ERROR_NONE;
240110c6:	2600      	movs	r6, #0
    if (husart->hdmatx != NULL)
240110c8:	6d20      	ldr	r0, [r4, #80]	@ 0x50
    husart->TxXferCount = Size;
240110ca:	85e3      	strh	r3, [r4, #46]	@ 0x2e
    __HAL_LOCK(husart);
240110cc:	f884 5058 	strb.w	r5, [r4, #88]	@ 0x58
    husart->ErrorCode = HAL_USART_ERROR_NONE;
240110d0:	65e6      	str	r6, [r4, #92]	@ 0x5c
    husart->pTxBuffPtr = pTxData;
240110d2:	62a1      	str	r1, [r4, #40]	@ 0x28
    husart->State = HAL_USART_STATE_BUSY_TX;
240110d4:	f884 2059 	strb.w	r2, [r4, #89]	@ 0x59
    husart->TxXferSize = Size;
240110d8:	85a3      	strh	r3, [r4, #44]	@ 0x2c
      status = HAL_DMA_Start_IT(husart->hdmatx, *(const uint32_t *)tmp, (uint32_t)&husart->Instance->TDR, Size);
240110da:	6822      	ldr	r2, [r4, #0]
    if (husart->hdmatx != NULL)
240110dc:	b958      	cbnz	r0, 240110f6 <HAL_USART_Transmit_DMA+0x4e>
      __HAL_USART_CLEAR_FLAG(husart, USART_CLEAR_TCF);
240110de:	6823      	ldr	r3, [r4, #0]
240110e0:	2240      	movs	r2, #64	@ 0x40
      __HAL_UNLOCK(husart);
240110e2:	2500      	movs	r5, #0
      __HAL_USART_CLEAR_FLAG(husart, USART_CLEAR_TCF);
240110e4:	621a      	str	r2, [r3, #32]
      __HAL_UNLOCK(husart);
240110e6:	f884 5058 	strb.w	r5, [r4, #88]	@ 0x58
      SET_BIT(husart->Instance->CR3, USART_CR3_DMAT);
240110ea:	689a      	ldr	r2, [r3, #8]
240110ec:	f042 0280 	orr.w	r2, r2, #128	@ 0x80
240110f0:	609a      	str	r2, [r3, #8]
}
240110f2:	4628      	mov	r0, r5
240110f4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      husart->hdmatx->XferCpltCallback = USART_DMATransmitCplt;
240110f6:	4f0a      	ldr	r7, [pc, #40]	@ (24011120 <HAL_USART_Transmit_DMA+0x78>)
      status = HAL_DMA_Start_IT(husart->hdmatx, *(const uint32_t *)tmp, (uint32_t)&husart->Instance->TDR, Size);
240110f8:	3228      	adds	r2, #40	@ 0x28
      husart->hdmatx->XferCpltCallback = USART_DMATransmitCplt;
240110fa:	63c7      	str	r7, [r0, #60]	@ 0x3c
      husart->hdmatx->XferHalfCpltCallback = USART_DMATxHalfCplt;
240110fc:	4f09      	ldr	r7, [pc, #36]	@ (24011124 <HAL_USART_Transmit_DMA+0x7c>)
240110fe:	6407      	str	r7, [r0, #64]	@ 0x40
      husart->hdmatx->XferErrorCallback = USART_DMAError;
24011100:	4f09      	ldr	r7, [pc, #36]	@ (24011128 <HAL_USART_Transmit_DMA+0x80>)
24011102:	64c7      	str	r7, [r0, #76]	@ 0x4c
      status = HAL_DMA_Start_IT(husart->hdmatx, *(const uint32_t *)tmp, (uint32_t)&husart->Instance->TDR, Size);
24011104:	f7f0 fc6c 	bl	240019e0 <HAL_DMA_Start_IT>
    if (status == HAL_OK)
24011108:	2800      	cmp	r0, #0
2401110a:	d0e8      	beq.n	240110de <HAL_USART_Transmit_DMA+0x36>
      husart->ErrorCode = HAL_USART_ERROR_DMA;
2401110c:	2310      	movs	r3, #16
      __HAL_UNLOCK(husart);
2401110e:	f884 6058 	strb.w	r6, [r4, #88]	@ 0x58
      husart->ErrorCode = HAL_USART_ERROR_DMA;
24011112:	65e3      	str	r3, [r4, #92]	@ 0x5c
      husart->State = HAL_USART_STATE_READY;
24011114:	f884 5059 	strb.w	r5, [r4, #89]	@ 0x59
      return HAL_ERROR;
24011118:	e7eb      	b.n	240110f2 <HAL_USART_Transmit_DMA+0x4a>
    __HAL_LOCK(husart);
2401111a:	2502      	movs	r5, #2
2401111c:	e7e9      	b.n	240110f2 <HAL_USART_Transmit_DMA+0x4a>
2401111e:	bf00      	nop
24011120:	240114bf 	.word	0x240114bf
24011124:	240114fd 	.word	0x240114fd
24011128:	240118bb 	.word	0x240118bb

2401112c <HAL_USART_Receive_DMA>:
{
2401112c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if (husart->State == HAL_USART_STATE_READY)
2401112e:	f890 3059 	ldrb.w	r3, [r0, #89]	@ 0x59
{
24011132:	4604      	mov	r4, r0
24011134:	460d      	mov	r5, r1
24011136:	4616      	mov	r6, r2
  if (husart->State == HAL_USART_STATE_READY)
24011138:	2b01      	cmp	r3, #1
2401113a:	b2df      	uxtb	r7, r3
2401113c:	d15a      	bne.n	240111f4 <HAL_USART_Receive_DMA+0xc8>
    if ((pRxData == NULL) || (Size == 0U))
2401113e:	b351      	cbz	r1, 24011196 <HAL_USART_Receive_DMA+0x6a>
24011140:	b34a      	cbz	r2, 24011196 <HAL_USART_Receive_DMA+0x6a>
    __HAL_LOCK(husart);
24011142:	f890 3058 	ldrb.w	r3, [r0, #88]	@ 0x58
24011146:	2b01      	cmp	r3, #1
24011148:	d054      	beq.n	240111f4 <HAL_USART_Receive_DMA+0xc8>
    husart->ErrorCode = HAL_USART_ERROR_NONE;
2401114a:	2300      	movs	r3, #0
    __HAL_LOCK(husart);
2401114c:	f880 7058 	strb.w	r7, [r0, #88]	@ 0x58
    husart->pRxBuffPtr = pRxData;
24011150:	6301      	str	r1, [r0, #48]	@ 0x30
    husart->ErrorCode = HAL_USART_ERROR_NONE;
24011152:	65c3      	str	r3, [r0, #92]	@ 0x5c
    husart->State = HAL_USART_STATE_BUSY_RX;
24011154:	2322      	movs	r3, #34	@ 0x22
    husart->pTxBuffPtr = pRxData;
24011156:	6281      	str	r1, [r0, #40]	@ 0x28
    husart->State = HAL_USART_STATE_BUSY_RX;
24011158:	f880 3059 	strb.w	r3, [r0, #89]	@ 0x59
    husart->RxXferSize = Size;
2401115c:	8682      	strh	r2, [r0, #52]	@ 0x34
    husart->TxXferSize = Size;
2401115e:	8582      	strh	r2, [r0, #44]	@ 0x2c
    if (husart->hdmarx != NULL)
24011160:	6d40      	ldr	r0, [r0, #84]	@ 0x54
      status = HAL_DMA_Start_IT(husart->hdmarx, (uint32_t)&husart->Instance->RDR, *(uint32_t *)tmp, Size);
24011162:	6821      	ldr	r1, [r4, #0]
    if (husart->hdmarx != NULL)
24011164:	b9c8      	cbnz	r0, 2401119a <HAL_USART_Receive_DMA+0x6e>
    if ((status == HAL_OK) &&
24011166:	6c23      	ldr	r3, [r4, #64]	@ 0x40
        status = HAL_DMA_Start_IT(husart->hdmatx, *(uint32_t *)tmp, (uint32_t)&husart->Instance->TDR, Size);
24011168:	6822      	ldr	r2, [r4, #0]
    if ((status == HAL_OK) &&
2401116a:	2b00      	cmp	r3, #0
2401116c:	d02f      	beq.n	240111ce <HAL_USART_Receive_DMA+0xa2>
      __HAL_UNLOCK(husart);
2401116e:	2300      	movs	r3, #0
      if (husart->Init.Parity != USART_PARITY_NONE)
24011170:	6922      	ldr	r2, [r4, #16]
      __HAL_UNLOCK(husart);
24011172:	f884 3058 	strb.w	r3, [r4, #88]	@ 0x58
        SET_BIT(husart->Instance->CR1, USART_CR1_PEIE);
24011176:	6823      	ldr	r3, [r4, #0]
      if (husart->Init.Parity != USART_PARITY_NONE)
24011178:	2a00      	cmp	r2, #0
2401117a:	d136      	bne.n	240111ea <HAL_USART_Receive_DMA+0xbe>
      SET_BIT(husart->Instance->CR3, USART_CR3_EIE);
2401117c:	689a      	ldr	r2, [r3, #8]
      return HAL_OK;
2401117e:	2700      	movs	r7, #0
      SET_BIT(husart->Instance->CR3, USART_CR3_EIE);
24011180:	f042 0201 	orr.w	r2, r2, #1
24011184:	609a      	str	r2, [r3, #8]
      SET_BIT(husart->Instance->CR3, USART_CR3_DMAR);
24011186:	689a      	ldr	r2, [r3, #8]
24011188:	f042 0240 	orr.w	r2, r2, #64	@ 0x40
2401118c:	609a      	str	r2, [r3, #8]
      SET_BIT(husart->Instance->CR3, USART_CR3_DMAT);
2401118e:	689a      	ldr	r2, [r3, #8]
24011190:	f042 0280 	orr.w	r2, r2, #128	@ 0x80
24011194:	609a      	str	r2, [r3, #8]
}
24011196:	4638      	mov	r0, r7
24011198:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      husart->hdmarx->XferCpltCallback = USART_DMAReceiveCplt;
2401119a:	4b17      	ldr	r3, [pc, #92]	@ (240111f8 <HAL_USART_Receive_DMA+0xcc>)
      status = HAL_DMA_Start_IT(husart->hdmarx, (uint32_t)&husart->Instance->RDR, *(uint32_t *)tmp, Size);
2401119c:	3124      	adds	r1, #36	@ 0x24
      husart->hdmarx->XferCpltCallback = USART_DMAReceiveCplt;
2401119e:	63c3      	str	r3, [r0, #60]	@ 0x3c
      husart->hdmarx->XferHalfCpltCallback = USART_DMARxHalfCplt;
240111a0:	4b16      	ldr	r3, [pc, #88]	@ (240111fc <HAL_USART_Receive_DMA+0xd0>)
240111a2:	6403      	str	r3, [r0, #64]	@ 0x40
      husart->hdmarx->XferErrorCallback = USART_DMAError;
240111a4:	4b16      	ldr	r3, [pc, #88]	@ (24011200 <HAL_USART_Receive_DMA+0xd4>)
240111a6:	64c3      	str	r3, [r0, #76]	@ 0x4c
      status = HAL_DMA_Start_IT(husart->hdmarx, (uint32_t)&husart->Instance->RDR, *(uint32_t *)tmp, Size);
240111a8:	4613      	mov	r3, r2
240111aa:	462a      	mov	r2, r5
240111ac:	f7f0 fc18 	bl	240019e0 <HAL_DMA_Start_IT>
    if ((status == HAL_OK) &&
240111b0:	2800      	cmp	r0, #0
240111b2:	d0d8      	beq.n	24011166 <HAL_USART_Receive_DMA+0x3a>
      if (husart->hdmarx != NULL)
240111b4:	6d60      	ldr	r0, [r4, #84]	@ 0x54
240111b6:	b108      	cbz	r0, 240111bc <HAL_USART_Receive_DMA+0x90>
        status = HAL_DMA_Abort(husart->hdmarx);
240111b8:	f7f0 fd2c 	bl	24001c14 <HAL_DMA_Abort>
      husart->ErrorCode = HAL_USART_ERROR_DMA;
240111bc:	2310      	movs	r3, #16
240111be:	65e3      	str	r3, [r4, #92]	@ 0x5c
      __HAL_UNLOCK(husart);
240111c0:	2300      	movs	r3, #0
240111c2:	f884 3058 	strb.w	r3, [r4, #88]	@ 0x58
      husart->State = HAL_USART_STATE_READY;
240111c6:	2301      	movs	r3, #1
240111c8:	f884 3059 	strb.w	r3, [r4, #89]	@ 0x59
      return HAL_ERROR;
240111cc:	e7e3      	b.n	24011196 <HAL_USART_Receive_DMA+0x6a>
      if (husart->hdmatx != NULL)
240111ce:	6d20      	ldr	r0, [r4, #80]	@ 0x50
240111d0:	2800      	cmp	r0, #0
240111d2:	d0cc      	beq.n	2401116e <HAL_USART_Receive_DMA+0x42>
        husart->hdmatx->XferErrorCallback = NULL;
240111d4:	64c3      	str	r3, [r0, #76]	@ 0x4c
        status = HAL_DMA_Start_IT(husart->hdmatx, *(uint32_t *)tmp, (uint32_t)&husart->Instance->TDR, Size);
240111d6:	3228      	adds	r2, #40	@ 0x28
240111d8:	4629      	mov	r1, r5
        husart->hdmatx->XferCpltCallback = NULL;
240111da:	e9c0 330f 	strd	r3, r3, [r0, #60]	@ 0x3c
        status = HAL_DMA_Start_IT(husart->hdmatx, *(uint32_t *)tmp, (uint32_t)&husart->Instance->TDR, Size);
240111de:	4633      	mov	r3, r6
240111e0:	f7f0 fbfe 	bl	240019e0 <HAL_DMA_Start_IT>
    if (status == HAL_OK)
240111e4:	2800      	cmp	r0, #0
240111e6:	d1e5      	bne.n	240111b4 <HAL_USART_Receive_DMA+0x88>
240111e8:	e7c1      	b.n	2401116e <HAL_USART_Receive_DMA+0x42>
        SET_BIT(husart->Instance->CR1, USART_CR1_PEIE);
240111ea:	681a      	ldr	r2, [r3, #0]
240111ec:	f442 7280 	orr.w	r2, r2, #256	@ 0x100
240111f0:	601a      	str	r2, [r3, #0]
240111f2:	e7c3      	b.n	2401117c <HAL_USART_Receive_DMA+0x50>
    __HAL_LOCK(husart);
240111f4:	2702      	movs	r7, #2
240111f6:	e7ce      	b.n	24011196 <HAL_USART_Receive_DMA+0x6a>
240111f8:	24011855 	.word	0x24011855
240111fc:	2401150b 	.word	0x2401150b
24011200:	240118bb 	.word	0x240118bb

24011204 <HAL_USART_TransmitReceive_DMA>:
{
24011204:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
24011206:	4604      	mov	r4, r0
  if (husart->State == HAL_USART_STATE_READY)
24011208:	f890 0059 	ldrb.w	r0, [r0, #89]	@ 0x59
{
2401120c:	460f      	mov	r7, r1
2401120e:	461d      	mov	r5, r3
  if (husart->State == HAL_USART_STATE_READY)
24011210:	2801      	cmp	r0, #1
24011212:	b2c6      	uxtb	r6, r0
24011214:	d164      	bne.n	240112e0 <HAL_USART_TransmitReceive_DMA+0xdc>
    if ((pTxData == NULL) || (pRxData == NULL) || (Size == 0U))
24011216:	2f00      	cmp	r7, #0
24011218:	d053      	beq.n	240112c2 <HAL_USART_TransmitReceive_DMA+0xbe>
2401121a:	2a00      	cmp	r2, #0
2401121c:	d051      	beq.n	240112c2 <HAL_USART_TransmitReceive_DMA+0xbe>
2401121e:	2b00      	cmp	r3, #0
24011220:	d04f      	beq.n	240112c2 <HAL_USART_TransmitReceive_DMA+0xbe>
    __HAL_LOCK(husart);
24011222:	f894 0058 	ldrb.w	r0, [r4, #88]	@ 0x58
24011226:	2801      	cmp	r0, #1
24011228:	d05a      	beq.n	240112e0 <HAL_USART_TransmitReceive_DMA+0xdc>
    husart->ErrorCode = HAL_USART_ERROR_NONE;
2401122a:	2100      	movs	r1, #0
    if ((husart->hdmarx != NULL) && (husart->hdmatx != NULL))
2401122c:	6d60      	ldr	r0, [r4, #84]	@ 0x54
    __HAL_LOCK(husart);
2401122e:	f884 6058 	strb.w	r6, [r4, #88]	@ 0x58
    husart->ErrorCode = HAL_USART_ERROR_NONE;
24011232:	65e1      	str	r1, [r4, #92]	@ 0x5c
    husart->State = HAL_USART_STATE_BUSY_TX_RX;
24011234:	2132      	movs	r1, #50	@ 0x32
    husart->pRxBuffPtr = pRxData;
24011236:	6322      	str	r2, [r4, #48]	@ 0x30
    husart->RxXferSize = Size;
24011238:	86a3      	strh	r3, [r4, #52]	@ 0x34
    husart->pTxBuffPtr = pTxData;
2401123a:	62a7      	str	r7, [r4, #40]	@ 0x28
    husart->TxXferSize = Size;
2401123c:	85a3      	strh	r3, [r4, #44]	@ 0x2c
    husart->State = HAL_USART_STATE_BUSY_TX_RX;
2401123e:	f884 1059 	strb.w	r1, [r4, #89]	@ 0x59
    if ((husart->hdmarx != NULL) && (husart->hdmatx != NULL))
24011242:	2800      	cmp	r0, #0
24011244:	d03f      	beq.n	240112c6 <HAL_USART_TransmitReceive_DMA+0xc2>
24011246:	6d21      	ldr	r1, [r4, #80]	@ 0x50
24011248:	2900      	cmp	r1, #0
2401124a:	d03c      	beq.n	240112c6 <HAL_USART_TransmitReceive_DMA+0xc2>
      husart->hdmarx->XferCpltCallback = USART_DMAReceiveCplt;
2401124c:	f8df c094 	ldr.w	ip, [pc, #148]	@ 240112e4 <HAL_USART_TransmitReceive_DMA+0xe0>
24011250:	f8c0 c03c 	str.w	ip, [r0, #60]	@ 0x3c
      husart->hdmarx->XferHalfCpltCallback = USART_DMARxHalfCplt;
24011254:	f8df c090 	ldr.w	ip, [pc, #144]	@ 240112e8 <HAL_USART_TransmitReceive_DMA+0xe4>
24011258:	f8c0 c040 	str.w	ip, [r0, #64]	@ 0x40
      husart->hdmatx->XferCpltCallback = USART_DMATransmitCplt;
2401125c:	f8df c08c 	ldr.w	ip, [pc, #140]	@ 240112ec <HAL_USART_TransmitReceive_DMA+0xe8>
24011260:	f8c1 c03c 	str.w	ip, [r1, #60]	@ 0x3c
      husart->hdmatx->XferHalfCpltCallback = USART_DMATxHalfCplt;
24011264:	f8df c088 	ldr.w	ip, [pc, #136]	@ 240112f0 <HAL_USART_TransmitReceive_DMA+0xec>
24011268:	f8c1 c040 	str.w	ip, [r1, #64]	@ 0x40
      husart->hdmatx->XferErrorCallback = USART_DMAError;
2401126c:	f8df c084 	ldr.w	ip, [pc, #132]	@ 240112f4 <HAL_USART_TransmitReceive_DMA+0xf0>
24011270:	f8c1 c04c 	str.w	ip, [r1, #76]	@ 0x4c
      status = HAL_DMA_Start_IT(husart->hdmarx, (uint32_t)&husart->Instance->RDR, *(const uint32_t *)tmp, Size);
24011274:	6821      	ldr	r1, [r4, #0]
      husart->hdmarx->XferErrorCallback = USART_DMAError;
24011276:	f8c0 c04c 	str.w	ip, [r0, #76]	@ 0x4c
      status = HAL_DMA_Start_IT(husart->hdmarx, (uint32_t)&husart->Instance->RDR, *(const uint32_t *)tmp, Size);
2401127a:	3124      	adds	r1, #36	@ 0x24
2401127c:	f7f0 fbb0 	bl	240019e0 <HAL_DMA_Start_IT>
      if (status == HAL_OK)
24011280:	bb08      	cbnz	r0, 240112c6 <HAL_USART_TransmitReceive_DMA+0xc2>
        status = HAL_DMA_Start_IT(husart->hdmatx, *(const uint32_t *)tmp, (uint32_t)&husart->Instance->TDR, Size);
24011282:	6822      	ldr	r2, [r4, #0]
24011284:	462b      	mov	r3, r5
24011286:	4639      	mov	r1, r7
24011288:	6d20      	ldr	r0, [r4, #80]	@ 0x50
2401128a:	3228      	adds	r2, #40	@ 0x28
2401128c:	f7f0 fba8 	bl	240019e0 <HAL_DMA_Start_IT>
    if (status == HAL_OK)
24011290:	b9c8      	cbnz	r0, 240112c6 <HAL_USART_TransmitReceive_DMA+0xc2>
      if (husart->Init.Parity != USART_PARITY_NONE)
24011292:	6922      	ldr	r2, [r4, #16]
        SET_BIT(husart->Instance->CR1, USART_CR1_PEIE);
24011294:	6823      	ldr	r3, [r4, #0]
      __HAL_UNLOCK(husart);
24011296:	f884 0058 	strb.w	r0, [r4, #88]	@ 0x58
      if (husart->Init.Parity != USART_PARITY_NONE)
2401129a:	b11a      	cbz	r2, 240112a4 <HAL_USART_TransmitReceive_DMA+0xa0>
        SET_BIT(husart->Instance->CR1, USART_CR1_PEIE);
2401129c:	681a      	ldr	r2, [r3, #0]
2401129e:	f442 7280 	orr.w	r2, r2, #256	@ 0x100
240112a2:	601a      	str	r2, [r3, #0]
      SET_BIT(husart->Instance->CR3, USART_CR3_EIE);
240112a4:	689a      	ldr	r2, [r3, #8]
      return HAL_OK;
240112a6:	2600      	movs	r6, #0
      SET_BIT(husart->Instance->CR3, USART_CR3_EIE);
240112a8:	f042 0201 	orr.w	r2, r2, #1
240112ac:	609a      	str	r2, [r3, #8]
      __HAL_USART_CLEAR_FLAG(husart, USART_CLEAR_TCF);
240112ae:	2240      	movs	r2, #64	@ 0x40
240112b0:	621a      	str	r2, [r3, #32]
      SET_BIT(husart->Instance->CR3, USART_CR3_DMAR);
240112b2:	689a      	ldr	r2, [r3, #8]
240112b4:	f042 0240 	orr.w	r2, r2, #64	@ 0x40
240112b8:	609a      	str	r2, [r3, #8]
      SET_BIT(husart->Instance->CR3, USART_CR3_DMAT);
240112ba:	689a      	ldr	r2, [r3, #8]
240112bc:	f042 0280 	orr.w	r2, r2, #128	@ 0x80
240112c0:	609a      	str	r2, [r3, #8]
}
240112c2:	4630      	mov	r0, r6
240112c4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      if (husart->hdmarx != NULL)
240112c6:	6d60      	ldr	r0, [r4, #84]	@ 0x54
240112c8:	b108      	cbz	r0, 240112ce <HAL_USART_TransmitReceive_DMA+0xca>
        status = HAL_DMA_Abort(husart->hdmarx);
240112ca:	f7f0 fca3 	bl	24001c14 <HAL_DMA_Abort>
      husart->ErrorCode = HAL_USART_ERROR_DMA;
240112ce:	2310      	movs	r3, #16
240112d0:	65e3      	str	r3, [r4, #92]	@ 0x5c
      __HAL_UNLOCK(husart);
240112d2:	2300      	movs	r3, #0
240112d4:	f884 3058 	strb.w	r3, [r4, #88]	@ 0x58
      husart->State = HAL_USART_STATE_READY;
240112d8:	2301      	movs	r3, #1
240112da:	f884 3059 	strb.w	r3, [r4, #89]	@ 0x59
      return HAL_ERROR;
240112de:	e7f0      	b.n	240112c2 <HAL_USART_TransmitReceive_DMA+0xbe>
    __HAL_LOCK(husart);
240112e0:	2602      	movs	r6, #2
240112e2:	e7ee      	b.n	240112c2 <HAL_USART_TransmitReceive_DMA+0xbe>
240112e4:	24011855 	.word	0x24011855
240112e8:	2401150b 	.word	0x2401150b
240112ec:	240114bf 	.word	0x240114bf
240112f0:	240114fd 	.word	0x240114fd
240112f4:	240118bb 	.word	0x240118bb

240112f8 <HAL_USART_DMAPause>:
  __HAL_LOCK(husart);
240112f8:	f890 3058 	ldrb.w	r3, [r0, #88]	@ 0x58
{
240112fc:	4602      	mov	r2, r0
  const HAL_USART_StateTypeDef state = husart->State;
240112fe:	f890 1059 	ldrb.w	r1, [r0, #89]	@ 0x59
  __HAL_LOCK(husart);
24011302:	2b01      	cmp	r3, #1
  const HAL_USART_StateTypeDef state = husart->State;
24011304:	b2c9      	uxtb	r1, r1
  __HAL_LOCK(husart);
24011306:	d02a      	beq.n	2401135e <HAL_USART_DMAPause+0x66>
24011308:	2301      	movs	r3, #1
2401130a:	f880 3058 	strb.w	r3, [r0, #88]	@ 0x58
  if ((HAL_IS_BIT_SET(husart->Instance->CR3, USART_CR3_DMAT)) &&
2401130e:	6803      	ldr	r3, [r0, #0]
24011310:	6898      	ldr	r0, [r3, #8]
24011312:	0600      	lsls	r0, r0, #24
24011314:	d509      	bpl.n	2401132a <HAL_USART_DMAPause+0x32>
24011316:	2912      	cmp	r1, #18
24011318:	d107      	bne.n	2401132a <HAL_USART_DMAPause+0x32>
    CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAT);
2401131a:	6899      	ldr	r1, [r3, #8]
2401131c:	f021 0180 	bic.w	r1, r1, #128	@ 0x80
      CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAR);
24011320:	6099      	str	r1, [r3, #8]
  __HAL_UNLOCK(husart);
24011322:	2000      	movs	r0, #0
24011324:	f882 0058 	strb.w	r0, [r2, #88]	@ 0x58
  return HAL_OK;
24011328:	4770      	bx	lr
  else if ((state == HAL_USART_STATE_BUSY_RX) ||
2401132a:	f001 01ef 	and.w	r1, r1, #239	@ 0xef
2401132e:	2922      	cmp	r1, #34	@ 0x22
24011330:	d1f7      	bne.n	24011322 <HAL_USART_DMAPause+0x2a>
    if (HAL_IS_BIT_SET(husart->Instance->CR3, USART_CR3_DMAT))
24011332:	6899      	ldr	r1, [r3, #8]
24011334:	0608      	lsls	r0, r1, #24
24011336:	d503      	bpl.n	24011340 <HAL_USART_DMAPause+0x48>
      CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAT);
24011338:	6899      	ldr	r1, [r3, #8]
2401133a:	f021 0180 	bic.w	r1, r1, #128	@ 0x80
2401133e:	6099      	str	r1, [r3, #8]
    if (HAL_IS_BIT_SET(husart->Instance->CR3, USART_CR3_DMAR))
24011340:	6899      	ldr	r1, [r3, #8]
24011342:	0649      	lsls	r1, r1, #25
24011344:	d5ed      	bpl.n	24011322 <HAL_USART_DMAPause+0x2a>
      CLEAR_BIT(husart->Instance->CR1, USART_CR1_PEIE);
24011346:	6819      	ldr	r1, [r3, #0]
24011348:	f421 7180 	bic.w	r1, r1, #256	@ 0x100
2401134c:	6019      	str	r1, [r3, #0]
      CLEAR_BIT(husart->Instance->CR3, USART_CR3_EIE);
2401134e:	6899      	ldr	r1, [r3, #8]
24011350:	f021 0101 	bic.w	r1, r1, #1
24011354:	6099      	str	r1, [r3, #8]
      CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAR);
24011356:	6899      	ldr	r1, [r3, #8]
24011358:	f021 0140 	bic.w	r1, r1, #64	@ 0x40
2401135c:	e7e0      	b.n	24011320 <HAL_USART_DMAPause+0x28>
  __HAL_LOCK(husart);
2401135e:	2002      	movs	r0, #2
}
24011360:	4770      	bx	lr

24011362 <HAL_USART_DMAResume>:
  __HAL_LOCK(husart);
24011362:	f890 1058 	ldrb.w	r1, [r0, #88]	@ 0x58
{
24011366:	4603      	mov	r3, r0
  const HAL_USART_StateTypeDef state = husart->State;
24011368:	f890 2059 	ldrb.w	r2, [r0, #89]	@ 0x59
  __HAL_LOCK(husart);
2401136c:	2901      	cmp	r1, #1
  const HAL_USART_StateTypeDef state = husart->State;
2401136e:	b2d2      	uxtb	r2, r2
  __HAL_LOCK(husart);
24011370:	d027      	beq.n	240113c2 <HAL_USART_DMAResume+0x60>
24011372:	2101      	movs	r1, #1
  if (state == HAL_USART_STATE_BUSY_TX)
24011374:	2a12      	cmp	r2, #18
  __HAL_LOCK(husart);
24011376:	f880 1058 	strb.w	r1, [r0, #88]	@ 0x58
  if (state == HAL_USART_STATE_BUSY_TX)
2401137a:	d108      	bne.n	2401138e <HAL_USART_DMAResume+0x2c>
    SET_BIT(husart->Instance->CR3, USART_CR3_DMAT);
2401137c:	6801      	ldr	r1, [r0, #0]
2401137e:	688a      	ldr	r2, [r1, #8]
24011380:	f042 0280 	orr.w	r2, r2, #128	@ 0x80
24011384:	608a      	str	r2, [r1, #8]
  __HAL_UNLOCK(husart);
24011386:	2000      	movs	r0, #0
24011388:	f883 0058 	strb.w	r0, [r3, #88]	@ 0x58
  return HAL_OK;
2401138c:	4770      	bx	lr
  else if ((state == HAL_USART_STATE_BUSY_RX) ||
2401138e:	f002 02ef 	and.w	r2, r2, #239	@ 0xef
24011392:	2a22      	cmp	r2, #34	@ 0x22
24011394:	d1f7      	bne.n	24011386 <HAL_USART_DMAResume+0x24>
    __HAL_USART_CLEAR_FLAG(husart, USART_CLEAR_OREF);
24011396:	2108      	movs	r1, #8
24011398:	6802      	ldr	r2, [r0, #0]
2401139a:	6211      	str	r1, [r2, #32]
    if (husart->Init.Parity != USART_PARITY_NONE)
2401139c:	6901      	ldr	r1, [r0, #16]
2401139e:	b119      	cbz	r1, 240113a8 <HAL_USART_DMAResume+0x46>
      SET_BIT(husart->Instance->CR1, USART_CR1_PEIE);
240113a0:	6811      	ldr	r1, [r2, #0]
240113a2:	f441 7180 	orr.w	r1, r1, #256	@ 0x100
240113a6:	6011      	str	r1, [r2, #0]
    SET_BIT(husart->Instance->CR3, USART_CR3_EIE);
240113a8:	6891      	ldr	r1, [r2, #8]
240113aa:	f041 0101 	orr.w	r1, r1, #1
240113ae:	6091      	str	r1, [r2, #8]
    SET_BIT(husart->Instance->CR3, USART_CR3_DMAR);
240113b0:	6891      	ldr	r1, [r2, #8]
240113b2:	f041 0140 	orr.w	r1, r1, #64	@ 0x40
240113b6:	6091      	str	r1, [r2, #8]
    SET_BIT(husart->Instance->CR3, USART_CR3_DMAT);
240113b8:	6891      	ldr	r1, [r2, #8]
240113ba:	f041 0180 	orr.w	r1, r1, #128	@ 0x80
240113be:	6091      	str	r1, [r2, #8]
240113c0:	e7e1      	b.n	24011386 <HAL_USART_DMAResume+0x24>
  __HAL_LOCK(husart);
240113c2:	2002      	movs	r0, #2
}
240113c4:	4770      	bx	lr

240113c6 <HAL_USART_DMAStop>:
  CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAT);
240113c6:	6803      	ldr	r3, [r0, #0]
240113c8:	689a      	ldr	r2, [r3, #8]
240113ca:	f022 0280 	bic.w	r2, r2, #128	@ 0x80
{
240113ce:	b510      	push	{r4, lr}
  CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAT);
240113d0:	609a      	str	r2, [r3, #8]
{
240113d2:	4604      	mov	r4, r0
  CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAR);
240113d4:	689a      	ldr	r2, [r3, #8]
  if (husart->hdmatx != NULL)
240113d6:	6d00      	ldr	r0, [r0, #80]	@ 0x50
  CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAR);
240113d8:	f022 0240 	bic.w	r2, r2, #64	@ 0x40
240113dc:	609a      	str	r2, [r3, #8]
  if (husart->hdmatx != NULL)
240113de:	b158      	cbz	r0, 240113f8 <HAL_USART_DMAStop+0x32>
    if (HAL_DMA_Abort(husart->hdmatx) != HAL_OK)
240113e0:	f7f0 fc18 	bl	24001c14 <HAL_DMA_Abort>
240113e4:	b140      	cbz	r0, 240113f8 <HAL_USART_DMAStop+0x32>
      if (HAL_DMA_GetError(husart->hdmatx) == HAL_DMA_ERROR_TIMEOUT)
240113e6:	6d20      	ldr	r0, [r4, #80]	@ 0x50
240113e8:	f7f1 fb65 	bl	24002ab6 <HAL_DMA_GetError>
240113ec:	2820      	cmp	r0, #32
240113ee:	d103      	bne.n	240113f8 <HAL_USART_DMAStop+0x32>
        husart->ErrorCode = HAL_USART_ERROR_DMA;
240113f0:	2310      	movs	r3, #16
        return HAL_TIMEOUT;
240113f2:	2003      	movs	r0, #3
        husart->ErrorCode = HAL_USART_ERROR_DMA;
240113f4:	65e3      	str	r3, [r4, #92]	@ 0x5c
}
240113f6:	bd10      	pop	{r4, pc}
  if (husart->hdmarx != NULL)
240113f8:	6d60      	ldr	r0, [r4, #84]	@ 0x54
240113fa:	b138      	cbz	r0, 2401140c <HAL_USART_DMAStop+0x46>
    if (HAL_DMA_Abort(husart->hdmarx) != HAL_OK)
240113fc:	f7f0 fc0a 	bl	24001c14 <HAL_DMA_Abort>
24011400:	b120      	cbz	r0, 2401140c <HAL_USART_DMAStop+0x46>
      if (HAL_DMA_GetError(husart->hdmarx) == HAL_DMA_ERROR_TIMEOUT)
24011402:	6d60      	ldr	r0, [r4, #84]	@ 0x54
24011404:	f7f1 fb57 	bl	24002ab6 <HAL_DMA_GetError>
24011408:	2820      	cmp	r0, #32
2401140a:	d0f1      	beq.n	240113f0 <HAL_USART_DMAStop+0x2a>
  USART_EndTransfer(husart);
2401140c:	4620      	mov	r0, r4
2401140e:	f7ff f90d 	bl	2401062c <USART_EndTransfer>
  husart->State = HAL_USART_STATE_READY;
24011412:	2301      	movs	r3, #1
  return HAL_OK;
24011414:	2000      	movs	r0, #0
  husart->State = HAL_USART_STATE_READY;
24011416:	f884 3059 	strb.w	r3, [r4, #89]	@ 0x59
  return HAL_OK;
2401141a:	e7ec      	b.n	240113f6 <HAL_USART_DMAStop+0x30>

2401141c <HAL_USART_Abort>:
  CLEAR_BIT(husart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE | USART_CR1_TXEIE_TXFNFIE |
2401141c:	6803      	ldr	r3, [r0, #0]
2401141e:	681a      	ldr	r2, [r3, #0]
24011420:	f422 72f0 	bic.w	r2, r2, #480	@ 0x1e0
{
24011424:	b510      	push	{r4, lr}
  CLEAR_BIT(husart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE | USART_CR1_TXEIE_TXFNFIE |
24011426:	601a      	str	r2, [r3, #0]
{
24011428:	4604      	mov	r4, r0
  CLEAR_BIT(husart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE | USART_CR3_TXFTIE));
2401142a:	689a      	ldr	r2, [r3, #8]
2401142c:	f022 5284 	bic.w	r2, r2, #276824064	@ 0x10800000
24011430:	f022 0201 	bic.w	r2, r2, #1
24011434:	609a      	str	r2, [r3, #8]
  if (HAL_IS_BIT_SET(husart->Instance->CR3, USART_CR3_DMAT))
24011436:	689a      	ldr	r2, [r3, #8]
24011438:	0611      	lsls	r1, r2, #24
2401143a:	d513      	bpl.n	24011464 <HAL_USART_Abort+0x48>
    CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAT);
2401143c:	689a      	ldr	r2, [r3, #8]
    if (husart->hdmatx != NULL)
2401143e:	6d00      	ldr	r0, [r0, #80]	@ 0x50
    CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAT);
24011440:	f022 0280 	bic.w	r2, r2, #128	@ 0x80
24011444:	609a      	str	r2, [r3, #8]
    if (husart->hdmatx != NULL)
24011446:	b168      	cbz	r0, 24011464 <HAL_USART_Abort+0x48>
      husart->hdmatx->XferAbortCallback = NULL;
24011448:	2300      	movs	r3, #0
2401144a:	6503      	str	r3, [r0, #80]	@ 0x50
      if (HAL_DMA_Abort(husart->hdmatx) != HAL_OK)
2401144c:	f7f0 fbe2 	bl	24001c14 <HAL_DMA_Abort>
24011450:	b140      	cbz	r0, 24011464 <HAL_USART_Abort+0x48>
        if (HAL_DMA_GetError(husart->hdmatx) == HAL_DMA_ERROR_TIMEOUT)
24011452:	6d20      	ldr	r0, [r4, #80]	@ 0x50
24011454:	f7f1 fb2f 	bl	24002ab6 <HAL_DMA_GetError>
24011458:	2820      	cmp	r0, #32
2401145a:	d103      	bne.n	24011464 <HAL_USART_Abort+0x48>
          husart->ErrorCode = HAL_USART_ERROR_DMA;
2401145c:	2310      	movs	r3, #16
          return HAL_TIMEOUT;
2401145e:	2003      	movs	r0, #3
          husart->ErrorCode = HAL_USART_ERROR_DMA;
24011460:	65e3      	str	r3, [r4, #92]	@ 0x5c
}
24011462:	bd10      	pop	{r4, pc}
  if (HAL_IS_BIT_SET(husart->Instance->CR3, USART_CR3_DMAR))
24011464:	6823      	ldr	r3, [r4, #0]
24011466:	689a      	ldr	r2, [r3, #8]
24011468:	0652      	lsls	r2, r2, #25
2401146a:	d50f      	bpl.n	2401148c <HAL_USART_Abort+0x70>
    CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAR);
2401146c:	689a      	ldr	r2, [r3, #8]
    if (husart->hdmarx != NULL)
2401146e:	6d60      	ldr	r0, [r4, #84]	@ 0x54
    CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAR);
24011470:	f022 0240 	bic.w	r2, r2, #64	@ 0x40
24011474:	609a      	str	r2, [r3, #8]
    if (husart->hdmarx != NULL)
24011476:	b148      	cbz	r0, 2401148c <HAL_USART_Abort+0x70>
      husart->hdmarx->XferAbortCallback = NULL;
24011478:	2300      	movs	r3, #0
2401147a:	6503      	str	r3, [r0, #80]	@ 0x50
      if (HAL_DMA_Abort(husart->hdmarx) != HAL_OK)
2401147c:	f7f0 fbca 	bl	24001c14 <HAL_DMA_Abort>
24011480:	b120      	cbz	r0, 2401148c <HAL_USART_Abort+0x70>
        if (HAL_DMA_GetError(husart->hdmarx) == HAL_DMA_ERROR_TIMEOUT)
24011482:	6d60      	ldr	r0, [r4, #84]	@ 0x54
24011484:	f7f1 fb17 	bl	24002ab6 <HAL_DMA_GetError>
24011488:	2820      	cmp	r0, #32
2401148a:	d0e7      	beq.n	2401145c <HAL_USART_Abort+0x40>
  husart->TxXferCount = 0U;
2401148c:	2300      	movs	r3, #0
  __HAL_USART_CLEAR_FLAG(husart, USART_CLEAR_OREF | USART_CLEAR_NEF | USART_CLEAR_PEF | USART_CLEAR_FEF);
2401148e:	220f      	movs	r2, #15
  husart->TxXferCount = 0U;
24011490:	85e3      	strh	r3, [r4, #46]	@ 0x2e
  husart->RxXferCount = 0U;
24011492:	86e3      	strh	r3, [r4, #54]	@ 0x36
  __HAL_USART_CLEAR_FLAG(husart, USART_CLEAR_OREF | USART_CLEAR_NEF | USART_CLEAR_PEF | USART_CLEAR_FEF);
24011494:	6823      	ldr	r3, [r4, #0]
24011496:	621a      	str	r2, [r3, #32]
  if (husart->FifoMode == USART_FIFOMODE_ENABLE)
24011498:	6c62      	ldr	r2, [r4, #68]	@ 0x44
2401149a:	f1b2 5f00 	cmp.w	r2, #536870912	@ 0x20000000
2401149e:	d103      	bne.n	240114a8 <HAL_USART_Abort+0x8c>
    __HAL_USART_SEND_REQ(husart, USART_TXDATA_FLUSH_REQUEST);
240114a0:	699a      	ldr	r2, [r3, #24]
240114a2:	f042 0210 	orr.w	r2, r2, #16
240114a6:	619a      	str	r2, [r3, #24]
  __HAL_USART_SEND_REQ(husart, USART_RXDATA_FLUSH_REQUEST);
240114a8:	699a      	ldr	r2, [r3, #24]
  husart->ErrorCode = HAL_USART_ERROR_NONE;
240114aa:	2000      	movs	r0, #0
  __HAL_USART_SEND_REQ(husart, USART_RXDATA_FLUSH_REQUEST);
240114ac:	f042 0208 	orr.w	r2, r2, #8
240114b0:	619a      	str	r2, [r3, #24]
  husart->State  = HAL_USART_STATE_READY;
240114b2:	2301      	movs	r3, #1
240114b4:	f884 3059 	strb.w	r3, [r4, #89]	@ 0x59
  husart->ErrorCode = HAL_USART_ERROR_NONE;
240114b8:	65e0      	str	r0, [r4, #92]	@ 0x5c
  return HAL_OK;
240114ba:	e7d2      	b.n	24011462 <HAL_USART_Abort+0x46>

240114bc <HAL_USART_TxCpltCallback>:
__weak void HAL_USART_TxCpltCallback(USART_HandleTypeDef *husart)
240114bc:	4770      	bx	lr

240114be <USART_DMATransmitCplt>:
{
240114be:	b508      	push	{r3, lr}
240114c0:	4603      	mov	r3, r0
  USART_HandleTypeDef *husart = (USART_HandleTypeDef *)(hdma->Parent);
240114c2:	6b80      	ldr	r0, [r0, #56]	@ 0x38
  if (hdma->Init.Mode != DMA_CIRCULAR)
240114c4:	69db      	ldr	r3, [r3, #28]
240114c6:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
240114ca:	d00f      	beq.n	240114ec <USART_DMATransmitCplt+0x2e>
    husart->TxXferCount = 0U;
240114cc:	2300      	movs	r3, #0
240114ce:	85c3      	strh	r3, [r0, #46]	@ 0x2e
    if (husart->State == HAL_USART_STATE_BUSY_TX)
240114d0:	f890 3059 	ldrb.w	r3, [r0, #89]	@ 0x59
240114d4:	2b12      	cmp	r3, #18
240114d6:	d108      	bne.n	240114ea <USART_DMATransmitCplt+0x2c>
      CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAT);
240114d8:	6803      	ldr	r3, [r0, #0]
240114da:	689a      	ldr	r2, [r3, #8]
240114dc:	f022 0280 	bic.w	r2, r2, #128	@ 0x80
240114e0:	609a      	str	r2, [r3, #8]
      __HAL_USART_ENABLE_IT(husart, USART_IT_TC);
240114e2:	681a      	ldr	r2, [r3, #0]
240114e4:	f042 0240 	orr.w	r2, r2, #64	@ 0x40
240114e8:	601a      	str	r2, [r3, #0]
}
240114ea:	bd08      	pop	{r3, pc}
    if (husart->State == HAL_USART_STATE_BUSY_TX)
240114ec:	f890 3059 	ldrb.w	r3, [r0, #89]	@ 0x59
240114f0:	2b12      	cmp	r3, #18
240114f2:	d1fa      	bne.n	240114ea <USART_DMATransmitCplt+0x2c>
      HAL_USART_TxCpltCallback(husart);
240114f4:	f7ff ffe2 	bl	240114bc <HAL_USART_TxCpltCallback>
}
240114f8:	e7f7      	b.n	240114ea <USART_DMATransmitCplt+0x2c>

240114fa <HAL_USART_TxHalfCpltCallback>:
__weak void HAL_USART_TxHalfCpltCallback(USART_HandleTypeDef *husart)
240114fa:	4770      	bx	lr

240114fc <USART_DMATxHalfCplt>:
  HAL_USART_TxHalfCpltCallback(husart);
240114fc:	6b80      	ldr	r0, [r0, #56]	@ 0x38
{
240114fe:	b508      	push	{r3, lr}
  HAL_USART_TxHalfCpltCallback(husart);
24011500:	f7ff fffb 	bl	240114fa <HAL_USART_TxHalfCpltCallback>
}
24011504:	bd08      	pop	{r3, pc}

24011506 <HAL_USART_RxCpltCallback>:
__weak void HAL_USART_RxCpltCallback(USART_HandleTypeDef *husart)
24011506:	4770      	bx	lr

24011508 <HAL_USART_RxHalfCpltCallback>:
__weak void HAL_USART_RxHalfCpltCallback(USART_HandleTypeDef *husart)
24011508:	4770      	bx	lr

2401150a <USART_DMARxHalfCplt>:
  HAL_USART_RxHalfCpltCallback(husart);
2401150a:	6b80      	ldr	r0, [r0, #56]	@ 0x38
{
2401150c:	b508      	push	{r3, lr}
  HAL_USART_RxHalfCpltCallback(husart);
2401150e:	f7ff fffb 	bl	24011508 <HAL_USART_RxHalfCpltCallback>
}
24011512:	bd08      	pop	{r3, pc}

24011514 <HAL_USART_TxRxCpltCallback>:
__weak void HAL_USART_TxRxCpltCallback(USART_HandleTypeDef *husart)
24011514:	4770      	bx	lr

24011516 <USART_RxISR_8BIT>:
  *         data word length is less than 9 bits long.
  * @param  husart USART handle
  * @retval None
  */
static void USART_RxISR_8BIT(USART_HandleTypeDef *husart)
{
24011516:	b538      	push	{r3, r4, r5, lr}
  const HAL_USART_StateTypeDef state = husart->State;
24011518:	f890 2059 	ldrb.w	r2, [r0, #89]	@ 0x59
{
2401151c:	4603      	mov	r3, r0
  uint16_t txdatacount;
  uint16_t uhMask = husart->Mask;
2401151e:	8f04      	ldrh	r4, [r0, #56]	@ 0x38
  const HAL_USART_StateTypeDef state = husart->State;
24011520:	b2d5      	uxtb	r5, r2
  uint32_t txftie;

  if ((state == HAL_USART_STATE_BUSY_RX) ||
24011522:	f002 02ef 	and.w	r2, r2, #239	@ 0xef
24011526:	2a22      	cmp	r2, #34	@ 0x22
24011528:	d12d      	bne.n	24011586 <USART_RxISR_8BIT+0x70>
      (state == HAL_USART_STATE_BUSY_TX_RX))
  {
    *husart->pRxBuffPtr = (uint8_t)(husart->Instance->RDR & (uint8_t)uhMask);
2401152a:	6802      	ldr	r2, [r0, #0]
2401152c:	6b01      	ldr	r1, [r0, #48]	@ 0x30
2401152e:	6a52      	ldr	r2, [r2, #36]	@ 0x24
24011530:	4022      	ands	r2, r4
24011532:	700a      	strb	r2, [r1, #0]
    husart->pRxBuffPtr++;
24011534:	6b02      	ldr	r2, [r0, #48]	@ 0x30
24011536:	3201      	adds	r2, #1
24011538:	6302      	str	r2, [r0, #48]	@ 0x30
    husart->RxXferCount--;
2401153a:	8ec2      	ldrh	r2, [r0, #54]	@ 0x36
2401153c:	3a01      	subs	r2, #1
2401153e:	b292      	uxth	r2, r2
24011540:	86c2      	strh	r2, [r0, #54]	@ 0x36

    if (husart->RxXferCount == 0U)
24011542:	8ec1      	ldrh	r1, [r0, #54]	@ 0x36
24011544:	b289      	uxth	r1, r1
24011546:	bb71      	cbnz	r1, 240115a6 <USART_RxISR_8BIT+0x90>
    {
      /* Disable the USART Parity Error Interrupt and RXNE interrupt*/
      CLEAR_BIT(husart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
24011548:	6802      	ldr	r2, [r0, #0]

      /* txftie and txdatacount are temporary variables for MISRAC2012-Rule-13.5 */
      txftie = READ_BIT(husart->Instance->CR3, USART_CR3_TXFTIE);
      txdatacount = husart->TxXferCount;

      if (state == HAL_USART_STATE_BUSY_RX)
2401154a:	2d22      	cmp	r5, #34	@ 0x22
      CLEAR_BIT(husart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
2401154c:	6814      	ldr	r4, [r2, #0]
2401154e:	f424 7490 	bic.w	r4, r4, #288	@ 0x120
24011552:	6014      	str	r4, [r2, #0]
      CLEAR_BIT(husart->Instance->CR3, USART_CR3_EIE);
24011554:	6894      	ldr	r4, [r2, #8]
24011556:	f024 0401 	bic.w	r4, r4, #1
2401155a:	6094      	str	r4, [r2, #8]
      husart->RxISR = NULL;
2401155c:	6481      	str	r1, [r0, #72]	@ 0x48
      txftie = READ_BIT(husart->Instance->CR3, USART_CR3_TXFTIE);
2401155e:	6894      	ldr	r4, [r2, #8]
      txdatacount = husart->TxXferCount;
24011560:	8dc1      	ldrh	r1, [r0, #46]	@ 0x2e
24011562:	b289      	uxth	r1, r1
      if (state == HAL_USART_STATE_BUSY_RX)
24011564:	d110      	bne.n	24011588 <USART_RxISR_8BIT+0x72>
      {
        /* Clear SPI slave underrun flag and discard transmit data */
        if (husart->SlaveMode == USART_SLAVEMODE_ENABLE)
24011566:	6c01      	ldr	r1, [r0, #64]	@ 0x40
24011568:	2901      	cmp	r1, #1
2401156a:	d106      	bne.n	2401157a <USART_RxISR_8BIT+0x64>
        {
          __HAL_USART_CLEAR_UDRFLAG(husart);
2401156c:	f44f 5100 	mov.w	r1, #8192	@ 0x2000
24011570:	6211      	str	r1, [r2, #32]
          __HAL_USART_SEND_REQ(husart, USART_TXDATA_FLUSH_REQUEST);
24011572:	6991      	ldr	r1, [r2, #24]
24011574:	f041 0110 	orr.w	r1, r1, #16
24011578:	6191      	str	r1, [r2, #24]
        }

        /* Rx process is completed, restore husart->State to Ready */
        husart->State = HAL_USART_STATE_READY;
2401157a:	2201      	movs	r2, #1
#if (USE_HAL_USART_REGISTER_CALLBACKS == 1)
        /* Call registered Rx Complete Callback */
        husart->RxCpltCallback(husart);
#else
        /* Call legacy weak Rx Complete Callback */
        HAL_USART_RxCpltCallback(husart);
2401157c:	4618      	mov	r0, r3
        husart->State = HAL_USART_STATE_READY;
2401157e:	f883 2059 	strb.w	r2, [r3, #89]	@ 0x59
        HAL_USART_RxCpltCallback(husart);
24011582:	f7ff ffc0 	bl	24011506 <HAL_USART_RxCpltCallback>
    else
    {
      /* Nothing to do */
    }
  }
}
24011586:	bd38      	pop	{r3, r4, r5, pc}
      else if ((READ_BIT(husart->Instance->CR1, USART_CR1_TCIE) != USART_CR1_TCIE) &&
24011588:	6812      	ldr	r2, [r2, #0]
      txftie = READ_BIT(husart->Instance->CR3, USART_CR3_TXFTIE);
2401158a:	f404 0400 	and.w	r4, r4, #8388608	@ 0x800000
      else if ((READ_BIT(husart->Instance->CR1, USART_CR1_TCIE) != USART_CR1_TCIE) &&
2401158e:	f002 0240 	and.w	r2, r2, #64	@ 0x40
24011592:	4322      	orrs	r2, r4
24011594:	d1f7      	bne.n	24011586 <USART_RxISR_8BIT+0x70>
               (txftie != USART_CR3_TXFTIE) &&
24011596:	2900      	cmp	r1, #0
24011598:	d1f5      	bne.n	24011586 <USART_RxISR_8BIT+0x70>
        husart->State = HAL_USART_STATE_READY;
2401159a:	2201      	movs	r2, #1
2401159c:	f880 2059 	strb.w	r2, [r0, #89]	@ 0x59
        HAL_USART_TxRxCpltCallback(husart);
240115a0:	f7ff ffb8 	bl	24011514 <HAL_USART_TxRxCpltCallback>
240115a4:	e7ef      	b.n	24011586 <USART_RxISR_8BIT+0x70>
    else if ((state == HAL_USART_STATE_BUSY_RX) &&
240115a6:	2d22      	cmp	r5, #34	@ 0x22
240115a8:	d1ed      	bne.n	24011586 <USART_RxISR_8BIT+0x70>
240115aa:	6c02      	ldr	r2, [r0, #64]	@ 0x40
240115ac:	2a00      	cmp	r2, #0
240115ae:	d1ea      	bne.n	24011586 <USART_RxISR_8BIT+0x70>
      husart->Instance->TDR = (USART_DUMMY_DATA & (uint16_t)0x00FF);
240115b0:	6803      	ldr	r3, [r0, #0]
240115b2:	22ff      	movs	r2, #255	@ 0xff
240115b4:	629a      	str	r2, [r3, #40]	@ 0x28
}
240115b6:	e7e6      	b.n	24011586 <USART_RxISR_8BIT+0x70>

240115b8 <USART_RxISR_16BIT>:
  *         data word length is 9 bits long.
  * @param  husart USART handle
  * @retval None
  */
static void USART_RxISR_16BIT(USART_HandleTypeDef *husart)
{
240115b8:	b538      	push	{r3, r4, r5, lr}
  const HAL_USART_StateTypeDef state = husart->State;
240115ba:	f890 2059 	ldrb.w	r2, [r0, #89]	@ 0x59
{
240115be:	4603      	mov	r3, r0
  uint16_t txdatacount;
  uint16_t *tmp;
  uint16_t uhMask = husart->Mask;
240115c0:	8f04      	ldrh	r4, [r0, #56]	@ 0x38
  const HAL_USART_StateTypeDef state = husart->State;
240115c2:	b2d5      	uxtb	r5, r2
  uint32_t txftie;

  if ((state == HAL_USART_STATE_BUSY_RX) ||
240115c4:	f002 02ef 	and.w	r2, r2, #239	@ 0xef
240115c8:	2a22      	cmp	r2, #34	@ 0x22
240115ca:	d12b      	bne.n	24011624 <USART_RxISR_16BIT+0x6c>
      (state == HAL_USART_STATE_BUSY_TX_RX))
  {
    tmp = (uint16_t *) husart->pRxBuffPtr;
    *tmp = (uint16_t)(husart->Instance->RDR & uhMask);
240115cc:	6802      	ldr	r2, [r0, #0]
240115ce:	6a51      	ldr	r1, [r2, #36]	@ 0x24
240115d0:	400c      	ands	r4, r1
240115d2:	6b01      	ldr	r1, [r0, #48]	@ 0x30
240115d4:	f821 4b02 	strh.w	r4, [r1], #2
    husart->pRxBuffPtr += 2U;
240115d8:	6301      	str	r1, [r0, #48]	@ 0x30
    husart->RxXferCount--;
240115da:	8ec1      	ldrh	r1, [r0, #54]	@ 0x36
240115dc:	3901      	subs	r1, #1
240115de:	b289      	uxth	r1, r1
240115e0:	86c1      	strh	r1, [r0, #54]	@ 0x36

    if (husart->RxXferCount == 0U)
240115e2:	8ec1      	ldrh	r1, [r0, #54]	@ 0x36
240115e4:	b289      	uxth	r1, r1
240115e6:	bb69      	cbnz	r1, 24011644 <USART_RxISR_16BIT+0x8c>
    {
      /* Disable the USART Parity Error Interrupt and RXNE interrupt*/
      CLEAR_BIT(husart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
240115e8:	6814      	ldr	r4, [r2, #0]

      /* txftie and txdatacount are temporary variables for MISRAC2012-Rule-13.5 */
      txftie = READ_BIT(husart->Instance->CR3, USART_CR3_TXFTIE);
      txdatacount = husart->TxXferCount;

      if (state == HAL_USART_STATE_BUSY_RX)
240115ea:	2d22      	cmp	r5, #34	@ 0x22
      CLEAR_BIT(husart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
240115ec:	f424 7490 	bic.w	r4, r4, #288	@ 0x120
240115f0:	6014      	str	r4, [r2, #0]
      CLEAR_BIT(husart->Instance->CR3, USART_CR3_EIE);
240115f2:	6894      	ldr	r4, [r2, #8]
240115f4:	f024 0401 	bic.w	r4, r4, #1
240115f8:	6094      	str	r4, [r2, #8]
      husart->RxISR = NULL;
240115fa:	6481      	str	r1, [r0, #72]	@ 0x48
      txftie = READ_BIT(husart->Instance->CR3, USART_CR3_TXFTIE);
240115fc:	6894      	ldr	r4, [r2, #8]
      txdatacount = husart->TxXferCount;
240115fe:	8dc1      	ldrh	r1, [r0, #46]	@ 0x2e
24011600:	b289      	uxth	r1, r1
      if (state == HAL_USART_STATE_BUSY_RX)
24011602:	d110      	bne.n	24011626 <USART_RxISR_16BIT+0x6e>
      {
        /* Clear SPI slave underrun flag and discard transmit data */
        if (husart->SlaveMode == USART_SLAVEMODE_ENABLE)
24011604:	6c01      	ldr	r1, [r0, #64]	@ 0x40
24011606:	2901      	cmp	r1, #1
24011608:	d106      	bne.n	24011618 <USART_RxISR_16BIT+0x60>
        {
          __HAL_USART_CLEAR_UDRFLAG(husart);
2401160a:	f44f 5100 	mov.w	r1, #8192	@ 0x2000
2401160e:	6211      	str	r1, [r2, #32]
          __HAL_USART_SEND_REQ(husart, USART_TXDATA_FLUSH_REQUEST);
24011610:	6991      	ldr	r1, [r2, #24]
24011612:	f041 0110 	orr.w	r1, r1, #16
24011616:	6191      	str	r1, [r2, #24]
        }

        /* Rx process is completed, restore husart->State to Ready */
        husart->State = HAL_USART_STATE_READY;
24011618:	2201      	movs	r2, #1
#if (USE_HAL_USART_REGISTER_CALLBACKS == 1)
        /* Call registered Rx Complete Callback */
        husart->RxCpltCallback(husart);
#else
        /* Call legacy weak Rx Complete Callback */
        HAL_USART_RxCpltCallback(husart);
2401161a:	4618      	mov	r0, r3
        husart->State = HAL_USART_STATE_READY;
2401161c:	f883 2059 	strb.w	r2, [r3, #89]	@ 0x59
        HAL_USART_RxCpltCallback(husart);
24011620:	f7ff ff71 	bl	24011506 <HAL_USART_RxCpltCallback>
    else
    {
      /* Nothing to do */
    }
  }
}
24011624:	bd38      	pop	{r3, r4, r5, pc}
      else if ((READ_BIT(husart->Instance->CR1, USART_CR1_TCIE) != USART_CR1_TCIE) &&
24011626:	6812      	ldr	r2, [r2, #0]
      txftie = READ_BIT(husart->Instance->CR3, USART_CR3_TXFTIE);
24011628:	f404 0400 	and.w	r4, r4, #8388608	@ 0x800000
      else if ((READ_BIT(husart->Instance->CR1, USART_CR1_TCIE) != USART_CR1_TCIE) &&
2401162c:	f002 0240 	and.w	r2, r2, #64	@ 0x40
24011630:	4322      	orrs	r2, r4
24011632:	d1f7      	bne.n	24011624 <USART_RxISR_16BIT+0x6c>
               (txftie != USART_CR3_TXFTIE) &&
24011634:	2900      	cmp	r1, #0
24011636:	d1f5      	bne.n	24011624 <USART_RxISR_16BIT+0x6c>
        husart->State = HAL_USART_STATE_READY;
24011638:	2201      	movs	r2, #1
2401163a:	f880 2059 	strb.w	r2, [r0, #89]	@ 0x59
        HAL_USART_TxRxCpltCallback(husart);
2401163e:	f7ff ff69 	bl	24011514 <HAL_USART_TxRxCpltCallback>
24011642:	e7ef      	b.n	24011624 <USART_RxISR_16BIT+0x6c>
    else if ((state == HAL_USART_STATE_BUSY_RX) &&
24011644:	2d22      	cmp	r5, #34	@ 0x22
24011646:	d1ed      	bne.n	24011624 <USART_RxISR_16BIT+0x6c>
24011648:	6c03      	ldr	r3, [r0, #64]	@ 0x40
2401164a:	2b00      	cmp	r3, #0
2401164c:	d1ea      	bne.n	24011624 <USART_RxISR_16BIT+0x6c>
      husart->Instance->TDR = (USART_DUMMY_DATA & (uint16_t)0x00FF);
2401164e:	23ff      	movs	r3, #255	@ 0xff
24011650:	6293      	str	r3, [r2, #40]	@ 0x28
}
24011652:	e7e7      	b.n	24011624 <USART_RxISR_16BIT+0x6c>

24011654 <USART_RxISR_8BIT_FIFOEN>:
  *         data word length is less than 9 bits long.
  * @param  husart USART handle
  * @retval None
  */
static void USART_RxISR_8BIT_FIFOEN(USART_HandleTypeDef *husart)
{
24011654:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  HAL_USART_StateTypeDef state = husart->State;
24011656:	f890 3059 	ldrb.w	r3, [r0, #89]	@ 0x59
{
2401165a:	4604      	mov	r4, r0
  uint16_t txdatacount;
  uint16_t rxdatacount;
  uint16_t uhMask = husart->Mask;
2401165c:	8f06      	ldrh	r6, [r0, #56]	@ 0x38
  HAL_USART_StateTypeDef state = husart->State;
2401165e:	b2da      	uxtb	r2, r3
  uint16_t nb_rx_data;
  uint32_t txftie;

  /* Check that a Rx process is ongoing */
  if ((state == HAL_USART_STATE_BUSY_RX) ||
24011660:	f003 03ef 	and.w	r3, r3, #239	@ 0xef
24011664:	2b22      	cmp	r3, #34	@ 0x22
24011666:	d16c      	bne.n	24011742 <USART_RxISR_8BIT_FIFOEN+0xee>
      (state == HAL_USART_STATE_BUSY_TX_RX))
  {
    for (nb_rx_data = husart->NbRxDataToProcess ; nb_rx_data > 0U ; nb_rx_data--)
24011668:	8f45      	ldrh	r5, [r0, #58]	@ 0x3a
          /* Disable the USART Parity Error Interrupt */
          CLEAR_BIT(husart->Instance->CR1, USART_CR1_PEIE);

          /* Disable the USART Error Interrupt: (Frame error, noise error, overrun error)
             and RX FIFO Threshold interrupt */
          CLEAR_BIT(husart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
2401166a:	4f39      	ldr	r7, [pc, #228]	@ (24011750 <USART_RxISR_8BIT_FIFOEN+0xfc>)
    for (nb_rx_data = husart->NbRxDataToProcess ; nb_rx_data > 0U ; nb_rx_data--)
2401166c:	b9d5      	cbnz	r5, 240116a4 <USART_RxISR_8BIT_FIFOEN+0x50>

    /* When remaining number of bytes to receive is less than the RX FIFO
    threshold, next incoming frames are processed as if FIFO mode was
    disabled (i.e. one interrupt per received frame).
    */
    rxdatacount = husart->RxXferCount;
2401166e:	8ee3      	ldrh	r3, [r4, #54]	@ 0x36
24011670:	b29b      	uxth	r3, r3
    if (((rxdatacount != 0U)) && (rxdatacount < husart->NbRxDataToProcess))
24011672:	b1b3      	cbz	r3, 240116a2 <USART_RxISR_8BIT_FIFOEN+0x4e>
24011674:	8f61      	ldrh	r1, [r4, #58]	@ 0x3a
24011676:	4299      	cmp	r1, r3
24011678:	d913      	bls.n	240116a2 <USART_RxISR_8BIT_FIFOEN+0x4e>
    {
      /* Disable the USART RXFT interrupt*/
      CLEAR_BIT(husart->Instance->CR3, USART_CR3_RXFTIE);
2401167a:	6823      	ldr	r3, [r4, #0]
2401167c:	6899      	ldr	r1, [r3, #8]
2401167e:	f021 5180 	bic.w	r1, r1, #268435456	@ 0x10000000
24011682:	6099      	str	r1, [r3, #8]

      /* Update the RxISR function pointer */
      husart->RxISR = USART_RxISR_8BIT;
24011684:	4933      	ldr	r1, [pc, #204]	@ (24011754 <USART_RxISR_8BIT_FIFOEN+0x100>)
24011686:	64a1      	str	r1, [r4, #72]	@ 0x48

      /* Enable the USART Data Register Not Empty interrupt */
      SET_BIT(husart->Instance->CR1, USART_CR1_RXNEIE_RXFNEIE);
24011688:	6819      	ldr	r1, [r3, #0]
2401168a:	f041 0120 	orr.w	r1, r1, #32
2401168e:	6019      	str	r1, [r3, #0]

      if ((husart->TxXferCount == 0U) &&
24011690:	8de1      	ldrh	r1, [r4, #46]	@ 0x2e
24011692:	b289      	uxth	r1, r1
24011694:	b929      	cbnz	r1, 240116a2 <USART_RxISR_8BIT_FIFOEN+0x4e>
24011696:	2a32      	cmp	r2, #50	@ 0x32
24011698:	d103      	bne.n	240116a2 <USART_RxISR_8BIT_FIFOEN+0x4e>
          (state == HAL_USART_STATE_BUSY_TX_RX) &&
2401169a:	6c22      	ldr	r2, [r4, #64]	@ 0x40
2401169c:	b90a      	cbnz	r2, 240116a2 <USART_RxISR_8BIT_FIFOEN+0x4e>
          (husart->SlaveMode == USART_SLAVEMODE_DISABLE))
      {
        /* Send dummy byte in order to generate the clock for the Slave to Send the next data */
        husart->Instance->TDR = (USART_DUMMY_DATA & (uint16_t)0x00FF);
2401169e:	22ff      	movs	r2, #255	@ 0xff
240116a0:	629a      	str	r2, [r3, #40]	@ 0x28
  else
  {
    /* Clear RXNE interrupt flag */
    __HAL_USART_SEND_REQ(husart, USART_RXDATA_FLUSH_REQUEST);
  }
}
240116a2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      if (__HAL_USART_GET_FLAG(husart, USART_FLAG_RXFNE) == SET)
240116a4:	6823      	ldr	r3, [r4, #0]
240116a6:	69d9      	ldr	r1, [r3, #28]
240116a8:	0689      	lsls	r1, r1, #26
240116aa:	d52e      	bpl.n	2401170a <USART_RxISR_8BIT_FIFOEN+0xb6>
        *husart->pRxBuffPtr = (uint8_t)(husart->Instance->RDR & (uint8_t)(uhMask & 0xFFU));
240116ac:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
240116ae:	6b21      	ldr	r1, [r4, #48]	@ 0x30
240116b0:	4033      	ands	r3, r6
240116b2:	700b      	strb	r3, [r1, #0]
        husart->pRxBuffPtr++;
240116b4:	6b23      	ldr	r3, [r4, #48]	@ 0x30
240116b6:	3301      	adds	r3, #1
240116b8:	6323      	str	r3, [r4, #48]	@ 0x30
        husart->RxXferCount--;
240116ba:	8ee3      	ldrh	r3, [r4, #54]	@ 0x36
240116bc:	3b01      	subs	r3, #1
240116be:	b29b      	uxth	r3, r3
240116c0:	86e3      	strh	r3, [r4, #54]	@ 0x36
        if (husart->RxXferCount == 0U)
240116c2:	8ee1      	ldrh	r1, [r4, #54]	@ 0x36
240116c4:	b289      	uxth	r1, r1
240116c6:	2900      	cmp	r1, #0
240116c8:	d132      	bne.n	24011730 <USART_RxISR_8BIT_FIFOEN+0xdc>
          CLEAR_BIT(husart->Instance->CR1, USART_CR1_PEIE);
240116ca:	6823      	ldr	r3, [r4, #0]
          if (state == HAL_USART_STATE_BUSY_RX)
240116cc:	2a22      	cmp	r2, #34	@ 0x22
          CLEAR_BIT(husart->Instance->CR1, USART_CR1_PEIE);
240116ce:	6818      	ldr	r0, [r3, #0]
240116d0:	f420 7080 	bic.w	r0, r0, #256	@ 0x100
240116d4:	6018      	str	r0, [r3, #0]
          CLEAR_BIT(husart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
240116d6:	6898      	ldr	r0, [r3, #8]
240116d8:	ea00 0007 	and.w	r0, r0, r7
240116dc:	6098      	str	r0, [r3, #8]
          husart->RxISR = NULL;
240116de:	64a1      	str	r1, [r4, #72]	@ 0x48
          txftie = READ_BIT(husart->Instance->CR3, USART_CR3_TXFTIE);
240116e0:	6898      	ldr	r0, [r3, #8]
          txdatacount = husart->TxXferCount;
240116e2:	8de1      	ldrh	r1, [r4, #46]	@ 0x2e
240116e4:	b289      	uxth	r1, r1
          if (state == HAL_USART_STATE_BUSY_RX)
240116e6:	d113      	bne.n	24011710 <USART_RxISR_8BIT_FIFOEN+0xbc>
            if (husart->SlaveMode == USART_SLAVEMODE_ENABLE)
240116e8:	6c22      	ldr	r2, [r4, #64]	@ 0x40
240116ea:	2a01      	cmp	r2, #1
240116ec:	d106      	bne.n	240116fc <USART_RxISR_8BIT_FIFOEN+0xa8>
              __HAL_USART_CLEAR_UDRFLAG(husart);
240116ee:	f44f 5200 	mov.w	r2, #8192	@ 0x2000
240116f2:	621a      	str	r2, [r3, #32]
              __HAL_USART_SEND_REQ(husart, USART_TXDATA_FLUSH_REQUEST);
240116f4:	699a      	ldr	r2, [r3, #24]
240116f6:	f042 0210 	orr.w	r2, r2, #16
240116fa:	619a      	str	r2, [r3, #24]
            husart->State = HAL_USART_STATE_READY;
240116fc:	2301      	movs	r3, #1
            HAL_USART_RxCpltCallback(husart);
240116fe:	4620      	mov	r0, r4
            husart->State = HAL_USART_STATE_READY;
24011700:	f884 3059 	strb.w	r3, [r4, #89]	@ 0x59
            HAL_USART_RxCpltCallback(husart);
24011704:	f7ff feff 	bl	24011506 <HAL_USART_RxCpltCallback>
            state = HAL_USART_STATE_READY;
24011708:	2201      	movs	r2, #1
    for (nb_rx_data = husart->NbRxDataToProcess ; nb_rx_data > 0U ; nb_rx_data--)
2401170a:	3d01      	subs	r5, #1
2401170c:	b2ad      	uxth	r5, r5
2401170e:	e7ad      	b.n	2401166c <USART_RxISR_8BIT_FIFOEN+0x18>
          else if ((READ_BIT(husart->Instance->CR1, USART_CR1_TCIE) != USART_CR1_TCIE) &&
24011710:	681b      	ldr	r3, [r3, #0]
          txftie = READ_BIT(husart->Instance->CR3, USART_CR3_TXFTIE);
24011712:	f400 0000 	and.w	r0, r0, #8388608	@ 0x800000
          else if ((READ_BIT(husart->Instance->CR1, USART_CR1_TCIE) != USART_CR1_TCIE) &&
24011716:	f003 0340 	and.w	r3, r3, #64	@ 0x40
2401171a:	4303      	orrs	r3, r0
2401171c:	d1f5      	bne.n	2401170a <USART_RxISR_8BIT_FIFOEN+0xb6>
                   (txftie != USART_CR3_TXFTIE) &&
2401171e:	2900      	cmp	r1, #0
24011720:	d1f3      	bne.n	2401170a <USART_RxISR_8BIT_FIFOEN+0xb6>
            husart->State = HAL_USART_STATE_READY;
24011722:	2301      	movs	r3, #1
            HAL_USART_TxRxCpltCallback(husart);
24011724:	4620      	mov	r0, r4
            husart->State = HAL_USART_STATE_READY;
24011726:	f884 3059 	strb.w	r3, [r4, #89]	@ 0x59
            HAL_USART_TxRxCpltCallback(husart);
2401172a:	f7ff fef3 	bl	24011514 <HAL_USART_TxRxCpltCallback>
2401172e:	e7eb      	b.n	24011708 <USART_RxISR_8BIT_FIFOEN+0xb4>
        else if ((state == HAL_USART_STATE_BUSY_RX) &&
24011730:	2a22      	cmp	r2, #34	@ 0x22
24011732:	d1ea      	bne.n	2401170a <USART_RxISR_8BIT_FIFOEN+0xb6>
24011734:	6c23      	ldr	r3, [r4, #64]	@ 0x40
24011736:	2b00      	cmp	r3, #0
24011738:	d1e7      	bne.n	2401170a <USART_RxISR_8BIT_FIFOEN+0xb6>
          husart->Instance->TDR = (USART_DUMMY_DATA & (uint16_t)0x00FF);
2401173a:	6823      	ldr	r3, [r4, #0]
2401173c:	21ff      	movs	r1, #255	@ 0xff
2401173e:	6299      	str	r1, [r3, #40]	@ 0x28
24011740:	e7e3      	b.n	2401170a <USART_RxISR_8BIT_FIFOEN+0xb6>
    __HAL_USART_SEND_REQ(husart, USART_RXDATA_FLUSH_REQUEST);
24011742:	6802      	ldr	r2, [r0, #0]
24011744:	6993      	ldr	r3, [r2, #24]
24011746:	f043 0308 	orr.w	r3, r3, #8
2401174a:	6193      	str	r3, [r2, #24]
}
2401174c:	e7a9      	b.n	240116a2 <USART_RxISR_8BIT_FIFOEN+0x4e>
2401174e:	bf00      	nop
24011750:	effffffe 	.word	0xeffffffe
24011754:	24011517 	.word	0x24011517

24011758 <USART_RxISR_16BIT_FIFOEN>:
  *         data word length is 9 bits long.
  * @param  husart USART handle
  * @retval None
  */
static void USART_RxISR_16BIT_FIFOEN(USART_HandleTypeDef *husart)
{
24011758:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  HAL_USART_StateTypeDef state = husart->State;
2401175a:	f890 3059 	ldrb.w	r3, [r0, #89]	@ 0x59
{
2401175e:	4604      	mov	r4, r0
  uint16_t txdatacount;
  uint16_t rxdatacount;
  uint16_t *tmp;
  uint16_t uhMask = husart->Mask;
24011760:	8f06      	ldrh	r6, [r0, #56]	@ 0x38
  HAL_USART_StateTypeDef state = husart->State;
24011762:	b2d9      	uxtb	r1, r3
  uint16_t nb_rx_data;
  uint32_t txftie;

  /* Check that a Tx process is ongoing */
  if ((state == HAL_USART_STATE_BUSY_RX) ||
24011764:	f003 03ef 	and.w	r3, r3, #239	@ 0xef
24011768:	2b22      	cmp	r3, #34	@ 0x22
2401176a:	d169      	bne.n	24011840 <USART_RxISR_16BIT_FIFOEN+0xe8>
      (state == HAL_USART_STATE_BUSY_TX_RX))
  {
    for (nb_rx_data = husart->NbRxDataToProcess ; nb_rx_data > 0U ; nb_rx_data--)
2401176c:	8f45      	ldrh	r5, [r0, #58]	@ 0x3a
          /* Disable the USART Parity Error Interrupt */
          CLEAR_BIT(husart->Instance->CR1, USART_CR1_PEIE);

          /* Disable the USART Error Interrupt: (Frame error, noise error, overrun error)
             and RX FIFO Threshold interrupt */
          CLEAR_BIT(husart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
2401176e:	4f37      	ldr	r7, [pc, #220]	@ (2401184c <USART_RxISR_16BIT_FIFOEN+0xf4>)
    for (nb_rx_data = husart->NbRxDataToProcess ; nb_rx_data > 0U ; nb_rx_data--)
24011770:	b9d5      	cbnz	r5, 240117a8 <USART_RxISR_16BIT_FIFOEN+0x50>

    /* When remaining number of bytes to receive is less than the RX FIFO
    threshold, next incoming frames are processed as if FIFO mode was
    disabled (i.e. one interrupt per received frame).
    */
    rxdatacount = husart->RxXferCount;
24011772:	8ee3      	ldrh	r3, [r4, #54]	@ 0x36
24011774:	b29b      	uxth	r3, r3
    if (((rxdatacount != 0U)) && (rxdatacount < husart->NbRxDataToProcess))
24011776:	b1b3      	cbz	r3, 240117a6 <USART_RxISR_16BIT_FIFOEN+0x4e>
24011778:	8f62      	ldrh	r2, [r4, #58]	@ 0x3a
2401177a:	429a      	cmp	r2, r3
2401177c:	d913      	bls.n	240117a6 <USART_RxISR_16BIT_FIFOEN+0x4e>
    {
      /* Disable the USART RXFT interrupt*/
      CLEAR_BIT(husart->Instance->CR3, USART_CR3_RXFTIE);
2401177e:	6823      	ldr	r3, [r4, #0]
24011780:	689a      	ldr	r2, [r3, #8]
24011782:	f022 5280 	bic.w	r2, r2, #268435456	@ 0x10000000
24011786:	609a      	str	r2, [r3, #8]

      /* Update the RxISR function pointer */
      husart->RxISR = USART_RxISR_16BIT;
24011788:	4a31      	ldr	r2, [pc, #196]	@ (24011850 <USART_RxISR_16BIT_FIFOEN+0xf8>)
2401178a:	64a2      	str	r2, [r4, #72]	@ 0x48

      /* Enable the USART Data Register Not Empty interrupt */
      SET_BIT(husart->Instance->CR1, USART_CR1_RXNEIE_RXFNEIE);
2401178c:	681a      	ldr	r2, [r3, #0]
2401178e:	f042 0220 	orr.w	r2, r2, #32
24011792:	601a      	str	r2, [r3, #0]

      if ((husart->TxXferCount == 0U) &&
24011794:	8de2      	ldrh	r2, [r4, #46]	@ 0x2e
24011796:	b292      	uxth	r2, r2
24011798:	b92a      	cbnz	r2, 240117a6 <USART_RxISR_16BIT_FIFOEN+0x4e>
2401179a:	2932      	cmp	r1, #50	@ 0x32
2401179c:	d103      	bne.n	240117a6 <USART_RxISR_16BIT_FIFOEN+0x4e>
          (state == HAL_USART_STATE_BUSY_TX_RX) &&
2401179e:	6c22      	ldr	r2, [r4, #64]	@ 0x40
240117a0:	b90a      	cbnz	r2, 240117a6 <USART_RxISR_16BIT_FIFOEN+0x4e>
          (husart->SlaveMode == USART_SLAVEMODE_DISABLE))
      {
        /* Send dummy byte in order to generate the clock for the Slave to Send the next data */
        husart->Instance->TDR = (USART_DUMMY_DATA & (uint16_t)0x00FF);
240117a2:	22ff      	movs	r2, #255	@ 0xff
240117a4:	629a      	str	r2, [r3, #40]	@ 0x28
  else
  {
    /* Clear RXNE interrupt flag */
    __HAL_USART_SEND_REQ(husart, USART_RXDATA_FLUSH_REQUEST);
  }
}
240117a6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      if (__HAL_USART_GET_FLAG(husart, USART_FLAG_RXFNE) == SET)
240117a8:	6823      	ldr	r3, [r4, #0]
240117aa:	69da      	ldr	r2, [r3, #28]
240117ac:	0692      	lsls	r2, r2, #26
240117ae:	d52c      	bpl.n	2401180a <USART_RxISR_16BIT_FIFOEN+0xb2>
        *tmp = (uint16_t)(husart->Instance->RDR & uhMask);
240117b0:	6a58      	ldr	r0, [r3, #36]	@ 0x24
240117b2:	6b22      	ldr	r2, [r4, #48]	@ 0x30
240117b4:	4030      	ands	r0, r6
240117b6:	f822 0b02 	strh.w	r0, [r2], #2
        husart->pRxBuffPtr += 2U;
240117ba:	6322      	str	r2, [r4, #48]	@ 0x30
        husart->RxXferCount--;
240117bc:	8ee2      	ldrh	r2, [r4, #54]	@ 0x36
240117be:	3a01      	subs	r2, #1
240117c0:	b292      	uxth	r2, r2
240117c2:	86e2      	strh	r2, [r4, #54]	@ 0x36
        if (husart->RxXferCount == 0U)
240117c4:	8ee2      	ldrh	r2, [r4, #54]	@ 0x36
240117c6:	b292      	uxth	r2, r2
240117c8:	2a00      	cmp	r2, #0
240117ca:	d131      	bne.n	24011830 <USART_RxISR_16BIT_FIFOEN+0xd8>
          CLEAR_BIT(husart->Instance->CR1, USART_CR1_PEIE);
240117cc:	6818      	ldr	r0, [r3, #0]
          if (state == HAL_USART_STATE_BUSY_RX)
240117ce:	2922      	cmp	r1, #34	@ 0x22
          CLEAR_BIT(husart->Instance->CR1, USART_CR1_PEIE);
240117d0:	f420 7080 	bic.w	r0, r0, #256	@ 0x100
240117d4:	6018      	str	r0, [r3, #0]
          CLEAR_BIT(husart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
240117d6:	6898      	ldr	r0, [r3, #8]
240117d8:	ea00 0007 	and.w	r0, r0, r7
240117dc:	6098      	str	r0, [r3, #8]
          husart->RxISR = NULL;
240117de:	64a2      	str	r2, [r4, #72]	@ 0x48
          txftie = READ_BIT(husart->Instance->CR3, USART_CR3_TXFTIE);
240117e0:	6898      	ldr	r0, [r3, #8]
          txdatacount = husart->TxXferCount;
240117e2:	8de2      	ldrh	r2, [r4, #46]	@ 0x2e
240117e4:	b292      	uxth	r2, r2
          if (state == HAL_USART_STATE_BUSY_RX)
240117e6:	d113      	bne.n	24011810 <USART_RxISR_16BIT_FIFOEN+0xb8>
            if (husart->SlaveMode == USART_SLAVEMODE_ENABLE)
240117e8:	6c22      	ldr	r2, [r4, #64]	@ 0x40
240117ea:	2a01      	cmp	r2, #1
240117ec:	d106      	bne.n	240117fc <USART_RxISR_16BIT_FIFOEN+0xa4>
              __HAL_USART_CLEAR_UDRFLAG(husart);
240117ee:	f44f 5200 	mov.w	r2, #8192	@ 0x2000
240117f2:	621a      	str	r2, [r3, #32]
              __HAL_USART_SEND_REQ(husart, USART_TXDATA_FLUSH_REQUEST);
240117f4:	699a      	ldr	r2, [r3, #24]
240117f6:	f042 0210 	orr.w	r2, r2, #16
240117fa:	619a      	str	r2, [r3, #24]
            husart->State = HAL_USART_STATE_READY;
240117fc:	2301      	movs	r3, #1
            HAL_USART_RxCpltCallback(husart);
240117fe:	4620      	mov	r0, r4
            husart->State = HAL_USART_STATE_READY;
24011800:	f884 3059 	strb.w	r3, [r4, #89]	@ 0x59
            HAL_USART_RxCpltCallback(husart);
24011804:	f7ff fe7f 	bl	24011506 <HAL_USART_RxCpltCallback>
            state = HAL_USART_STATE_READY;
24011808:	2101      	movs	r1, #1
    for (nb_rx_data = husart->NbRxDataToProcess ; nb_rx_data > 0U ; nb_rx_data--)
2401180a:	3d01      	subs	r5, #1
2401180c:	b2ad      	uxth	r5, r5
2401180e:	e7af      	b.n	24011770 <USART_RxISR_16BIT_FIFOEN+0x18>
          else if ((READ_BIT(husart->Instance->CR1, USART_CR1_TCIE) != USART_CR1_TCIE) &&
24011810:	681b      	ldr	r3, [r3, #0]
          txftie = READ_BIT(husart->Instance->CR3, USART_CR3_TXFTIE);
24011812:	f400 0000 	and.w	r0, r0, #8388608	@ 0x800000
          else if ((READ_BIT(husart->Instance->CR1, USART_CR1_TCIE) != USART_CR1_TCIE) &&
24011816:	f003 0340 	and.w	r3, r3, #64	@ 0x40
2401181a:	4303      	orrs	r3, r0
2401181c:	d1f5      	bne.n	2401180a <USART_RxISR_16BIT_FIFOEN+0xb2>
                   (txftie != USART_CR3_TXFTIE) &&
2401181e:	2a00      	cmp	r2, #0
24011820:	d1f3      	bne.n	2401180a <USART_RxISR_16BIT_FIFOEN+0xb2>
            husart->State = HAL_USART_STATE_READY;
24011822:	2301      	movs	r3, #1
            HAL_USART_TxRxCpltCallback(husart);
24011824:	4620      	mov	r0, r4
            husart->State = HAL_USART_STATE_READY;
24011826:	f884 3059 	strb.w	r3, [r4, #89]	@ 0x59
            HAL_USART_TxRxCpltCallback(husart);
2401182a:	f7ff fe73 	bl	24011514 <HAL_USART_TxRxCpltCallback>
2401182e:	e7eb      	b.n	24011808 <USART_RxISR_16BIT_FIFOEN+0xb0>
        else if ((state == HAL_USART_STATE_BUSY_RX) &&
24011830:	2922      	cmp	r1, #34	@ 0x22
24011832:	d1ea      	bne.n	2401180a <USART_RxISR_16BIT_FIFOEN+0xb2>
24011834:	6c22      	ldr	r2, [r4, #64]	@ 0x40
24011836:	2a00      	cmp	r2, #0
24011838:	d1e7      	bne.n	2401180a <USART_RxISR_16BIT_FIFOEN+0xb2>
          husart->Instance->TDR = (USART_DUMMY_DATA & (uint16_t)0x00FF);
2401183a:	22ff      	movs	r2, #255	@ 0xff
2401183c:	629a      	str	r2, [r3, #40]	@ 0x28
2401183e:	e7e4      	b.n	2401180a <USART_RxISR_16BIT_FIFOEN+0xb2>
    __HAL_USART_SEND_REQ(husart, USART_RXDATA_FLUSH_REQUEST);
24011840:	6802      	ldr	r2, [r0, #0]
24011842:	6993      	ldr	r3, [r2, #24]
24011844:	f043 0308 	orr.w	r3, r3, #8
24011848:	6193      	str	r3, [r2, #24]
}
2401184a:	e7ac      	b.n	240117a6 <USART_RxISR_16BIT_FIFOEN+0x4e>
2401184c:	effffffe 	.word	0xeffffffe
24011850:	240115b9 	.word	0x240115b9

24011854 <USART_DMAReceiveCplt>:
  if (hdma->Init.Mode != DMA_CIRCULAR)
24011854:	69c3      	ldr	r3, [r0, #28]
24011856:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
{
2401185a:	b510      	push	{r4, lr}
  USART_HandleTypeDef *husart = (USART_HandleTypeDef *)(hdma->Parent);
2401185c:	6b84      	ldr	r4, [r0, #56]	@ 0x38
  if (hdma->Init.Mode != DMA_CIRCULAR)
2401185e:	d020      	beq.n	240118a2 <USART_DMAReceiveCplt+0x4e>
    husart->RxXferCount = 0U;
24011860:	2300      	movs	r3, #0
      HAL_USART_RxCpltCallback(husart);
24011862:	4620      	mov	r0, r4
    husart->RxXferCount = 0U;
24011864:	86e3      	strh	r3, [r4, #54]	@ 0x36
    CLEAR_BIT(husart->Instance->CR1, USART_CR1_PEIE);
24011866:	6823      	ldr	r3, [r4, #0]
24011868:	681a      	ldr	r2, [r3, #0]
2401186a:	f422 7280 	bic.w	r2, r2, #256	@ 0x100
2401186e:	601a      	str	r2, [r3, #0]
    CLEAR_BIT(husart->Instance->CR3, USART_CR3_EIE);
24011870:	689a      	ldr	r2, [r3, #8]
24011872:	f022 0201 	bic.w	r2, r2, #1
24011876:	609a      	str	r2, [r3, #8]
    CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAR);
24011878:	689a      	ldr	r2, [r3, #8]
2401187a:	f022 0240 	bic.w	r2, r2, #64	@ 0x40
2401187e:	609a      	str	r2, [r3, #8]
    CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAT);
24011880:	689a      	ldr	r2, [r3, #8]
24011882:	f022 0280 	bic.w	r2, r2, #128	@ 0x80
24011886:	609a      	str	r2, [r3, #8]
    if (husart->State == HAL_USART_STATE_BUSY_RX)
24011888:	f894 3059 	ldrb.w	r3, [r4, #89]	@ 0x59
2401188c:	2b22      	cmp	r3, #34	@ 0x22
2401188e:	d105      	bne.n	2401189c <USART_DMAReceiveCplt+0x48>
      HAL_USART_RxCpltCallback(husart);
24011890:	f7ff fe39 	bl	24011506 <HAL_USART_RxCpltCallback>
    husart->State = HAL_USART_STATE_READY;
24011894:	2301      	movs	r3, #1
24011896:	f884 3059 	strb.w	r3, [r4, #89]	@ 0x59
}
2401189a:	bd10      	pop	{r4, pc}
      HAL_USART_TxRxCpltCallback(husart);
2401189c:	f7ff fe3a 	bl	24011514 <HAL_USART_TxRxCpltCallback>
240118a0:	e7f8      	b.n	24011894 <USART_DMAReceiveCplt+0x40>
    if (husart->State == HAL_USART_STATE_BUSY_RX)
240118a2:	f894 3059 	ldrb.w	r3, [r4, #89]	@ 0x59
      HAL_USART_RxCpltCallback(husart);
240118a6:	4620      	mov	r0, r4
    if (husart->State == HAL_USART_STATE_BUSY_RX)
240118a8:	2b22      	cmp	r3, #34	@ 0x22
240118aa:	d102      	bne.n	240118b2 <USART_DMAReceiveCplt+0x5e>
      HAL_USART_RxCpltCallback(husart);
240118ac:	f7ff fe2b 	bl	24011506 <HAL_USART_RxCpltCallback>
240118b0:	e7f3      	b.n	2401189a <USART_DMAReceiveCplt+0x46>
      HAL_USART_TxRxCpltCallback(husart);
240118b2:	f7ff fe2f 	bl	24011514 <HAL_USART_TxRxCpltCallback>
}
240118b6:	e7f0      	b.n	2401189a <USART_DMAReceiveCplt+0x46>

240118b8 <HAL_USART_ErrorCallback>:
__weak void HAL_USART_ErrorCallback(USART_HandleTypeDef *husart)
240118b8:	4770      	bx	lr

240118ba <USART_DMAError>:
  USART_HandleTypeDef *husart = (USART_HandleTypeDef *)(hdma->Parent);
240118ba:	6b80      	ldr	r0, [r0, #56]	@ 0x38
{
240118bc:	b508      	push	{r3, lr}
  husart->RxXferCount = 0U;
240118be:	2300      	movs	r3, #0
240118c0:	86c3      	strh	r3, [r0, #54]	@ 0x36
  husart->TxXferCount = 0U;
240118c2:	85c3      	strh	r3, [r0, #46]	@ 0x2e
  USART_EndTransfer(husart);
240118c4:	f7fe feb2 	bl	2401062c <USART_EndTransfer>
  husart->ErrorCode |= HAL_USART_ERROR_DMA;
240118c8:	6dc3      	ldr	r3, [r0, #92]	@ 0x5c
240118ca:	f043 0310 	orr.w	r3, r3, #16
240118ce:	65c3      	str	r3, [r0, #92]	@ 0x5c
  husart->State = HAL_USART_STATE_READY;
240118d0:	2301      	movs	r3, #1
240118d2:	f880 3059 	strb.w	r3, [r0, #89]	@ 0x59
  HAL_USART_ErrorCallback(husart);
240118d6:	f7ff ffef 	bl	240118b8 <HAL_USART_ErrorCallback>
}
240118da:	bd08      	pop	{r3, pc}

240118dc <HAL_USART_IRQHandler>:
  uint32_t isrflags   = READ_REG(husart->Instance->ISR);
240118dc:	6803      	ldr	r3, [r0, #0]
{
240118de:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint32_t isrflags   = READ_REG(husart->Instance->ISR);
240118e2:	69d9      	ldr	r1, [r3, #28]
  if (errorflags == 0U)
240118e4:	f642 060f 	movw	r6, #10255	@ 0x280f
  uint32_t cr1its     = READ_REG(husart->Instance->CR1);
240118e8:	681a      	ldr	r2, [r3, #0]
{
240118ea:	4604      	mov	r4, r0
  if (errorflags == 0U)
240118ec:	4231      	tst	r1, r6
  uint32_t cr3its     = READ_REG(husart->Instance->CR3);
240118ee:	689d      	ldr	r5, [r3, #8]
  if (errorflags == 0U)
240118f0:	d10f      	bne.n	24011912 <HAL_USART_IRQHandler+0x36>
    if (((isrflags & USART_ISR_RXNE_RXFNE) != 0U)
240118f2:	068e      	lsls	r6, r1, #26
240118f4:	f140 8096 	bpl.w	24011a24 <HAL_USART_IRQHandler+0x148>
        && (((cr1its & USART_CR1_RXNEIE_RXFNEIE) != 0U)
240118f8:	f002 0620 	and.w	r6, r2, #32
            || ((cr3its & USART_CR3_RXFTIE) != 0U)))
240118fc:	f005 5780 	and.w	r7, r5, #268435456	@ 0x10000000
24011900:	433e      	orrs	r6, r7
24011902:	f000 808f 	beq.w	24011a24 <HAL_USART_IRQHandler+0x148>
      if (husart->RxISR != NULL)
24011906:	6c83      	ldr	r3, [r0, #72]	@ 0x48
24011908:	2b00      	cmp	r3, #0
2401190a:	d049      	beq.n	240119a0 <HAL_USART_IRQHandler+0xc4>
}
2401190c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
              husart->hdmarx->XferAbortCallback(husart->hdmarx);
24011910:	4718      	bx	r3
      && (((cr3its & (USART_CR3_RXFTIE | USART_CR3_EIE)) != 0U)
24011912:	4e6a      	ldr	r6, [pc, #424]	@ (24011abc <HAL_USART_IRQHandler+0x1e0>)
          || ((cr1its & (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE)) != 0U)))
24011914:	f402 7090 	and.w	r0, r2, #288	@ 0x120
      && (((cr3its & (USART_CR3_RXFTIE | USART_CR3_EIE)) != 0U)
24011918:	402e      	ands	r6, r5
          || ((cr1its & (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE)) != 0U)))
2401191a:	4330      	orrs	r0, r6
2401191c:	f000 8082 	beq.w	24011a24 <HAL_USART_IRQHandler+0x148>
    if (((isrflags & USART_ISR_PE) != 0U) && ((cr1its & USART_CR1_PEIE) != 0U))
24011920:	07c8      	lsls	r0, r1, #31
24011922:	d507      	bpl.n	24011934 <HAL_USART_IRQHandler+0x58>
24011924:	05d7      	lsls	r7, r2, #23
24011926:	d505      	bpl.n	24011934 <HAL_USART_IRQHandler+0x58>
      __HAL_USART_CLEAR_IT(husart, USART_CLEAR_PEF);
24011928:	2001      	movs	r0, #1
2401192a:	6218      	str	r0, [r3, #32]
      husart->ErrorCode |= HAL_USART_ERROR_PE;
2401192c:	6de0      	ldr	r0, [r4, #92]	@ 0x5c
2401192e:	f040 0001 	orr.w	r0, r0, #1
24011932:	65e0      	str	r0, [r4, #92]	@ 0x5c
    if (((isrflags & USART_ISR_FE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
24011934:	0788      	lsls	r0, r1, #30
24011936:	d507      	bpl.n	24011948 <HAL_USART_IRQHandler+0x6c>
24011938:	07ef      	lsls	r7, r5, #31
2401193a:	d505      	bpl.n	24011948 <HAL_USART_IRQHandler+0x6c>
      __HAL_USART_CLEAR_IT(husart, USART_CLEAR_FEF);
2401193c:	2002      	movs	r0, #2
2401193e:	6218      	str	r0, [r3, #32]
      husart->ErrorCode |= HAL_USART_ERROR_FE;
24011940:	6de0      	ldr	r0, [r4, #92]	@ 0x5c
24011942:	f040 0004 	orr.w	r0, r0, #4
24011946:	65e0      	str	r0, [r4, #92]	@ 0x5c
    if (((isrflags & USART_ISR_NE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
24011948:	0748      	lsls	r0, r1, #29
2401194a:	d507      	bpl.n	2401195c <HAL_USART_IRQHandler+0x80>
2401194c:	07ef      	lsls	r7, r5, #31
2401194e:	d505      	bpl.n	2401195c <HAL_USART_IRQHandler+0x80>
      __HAL_USART_CLEAR_IT(husart, USART_CLEAR_NEF);
24011950:	2004      	movs	r0, #4
24011952:	6218      	str	r0, [r3, #32]
      husart->ErrorCode |= HAL_USART_ERROR_NE;
24011954:	6de0      	ldr	r0, [r4, #92]	@ 0x5c
24011956:	f040 0002 	orr.w	r0, r0, #2
2401195a:	65e0      	str	r0, [r4, #92]	@ 0x5c
    if (((isrflags & USART_ISR_ORE) != 0U)
2401195c:	0708      	lsls	r0, r1, #28
2401195e:	d509      	bpl.n	24011974 <HAL_USART_IRQHandler+0x98>
        && (((cr1its & USART_CR1_RXNEIE_RXFNEIE) != 0U) ||
24011960:	f002 0020 	and.w	r0, r2, #32
24011964:	4330      	orrs	r0, r6
24011966:	d005      	beq.n	24011974 <HAL_USART_IRQHandler+0x98>
      __HAL_USART_CLEAR_IT(husart, USART_CLEAR_OREF);
24011968:	2008      	movs	r0, #8
2401196a:	6218      	str	r0, [r3, #32]
      husart->ErrorCode |= HAL_USART_ERROR_ORE;
2401196c:	6de0      	ldr	r0, [r4, #92]	@ 0x5c
2401196e:	f040 0008 	orr.w	r0, r0, #8
24011972:	65e0      	str	r0, [r4, #92]	@ 0x5c
    if (((isrflags & USART_ISR_RTOF) != 0U) && ((cr1its & USART_CR1_RTOIE) != 0U))
24011974:	050f      	lsls	r7, r1, #20
24011976:	d508      	bpl.n	2401198a <HAL_USART_IRQHandler+0xae>
24011978:	0156      	lsls	r6, r2, #5
2401197a:	d506      	bpl.n	2401198a <HAL_USART_IRQHandler+0xae>
      __HAL_USART_CLEAR_IT(husart, USART_CLEAR_RTOF);
2401197c:	f44f 6000 	mov.w	r0, #2048	@ 0x800
24011980:	6218      	str	r0, [r3, #32]
      husart->ErrorCode |= HAL_USART_ERROR_RTO;
24011982:	6de0      	ldr	r0, [r4, #92]	@ 0x5c
24011984:	f040 0080 	orr.w	r0, r0, #128	@ 0x80
24011988:	65e0      	str	r0, [r4, #92]	@ 0x5c
    if (((isrflags & USART_ISR_UDR) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
2401198a:	0488      	lsls	r0, r1, #18
2401198c:	d50e      	bpl.n	240119ac <HAL_USART_IRQHandler+0xd0>
2401198e:	07ef      	lsls	r7, r5, #31
24011990:	d50c      	bpl.n	240119ac <HAL_USART_IRQHandler+0xd0>
      if (husart->State == HAL_USART_STATE_BUSY_RX)
24011992:	f894 0059 	ldrb.w	r0, [r4, #89]	@ 0x59
24011996:	2822      	cmp	r0, #34	@ 0x22
24011998:	f44f 5000 	mov.w	r0, #8192	@ 0x2000
        __HAL_USART_CLEAR_UDRFLAG(husart);
2401199c:	6218      	str	r0, [r3, #32]
      if (husart->State == HAL_USART_STATE_BUSY_RX)
2401199e:	d101      	bne.n	240119a4 <HAL_USART_IRQHandler+0xc8>
}
240119a0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        husart->ErrorCode |= HAL_USART_ERROR_UDR;
240119a4:	6de3      	ldr	r3, [r4, #92]	@ 0x5c
240119a6:	f043 0320 	orr.w	r3, r3, #32
240119aa:	65e3      	str	r3, [r4, #92]	@ 0x5c
    if (husart->ErrorCode != HAL_USART_ERROR_NONE)
240119ac:	6de3      	ldr	r3, [r4, #92]	@ 0x5c
240119ae:	2b00      	cmp	r3, #0
240119b0:	d0f6      	beq.n	240119a0 <HAL_USART_IRQHandler+0xc4>
      if (((isrflags & USART_ISR_RXNE_RXFNE) != 0U)
240119b2:	068e      	lsls	r6, r1, #26
240119b4:	d509      	bpl.n	240119ca <HAL_USART_IRQHandler+0xee>
          && (((cr1its & USART_CR1_RXNEIE_RXFNEIE) != 0U)
240119b6:	f002 0220 	and.w	r2, r2, #32
              || ((cr3its & USART_CR3_RXFTIE) != 0U)))
240119ba:	f005 5580 	and.w	r5, r5, #268435456	@ 0x10000000
240119be:	432a      	orrs	r2, r5
240119c0:	d003      	beq.n	240119ca <HAL_USART_IRQHandler+0xee>
        if (husart->RxISR != NULL)
240119c2:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
240119c4:	b10b      	cbz	r3, 240119ca <HAL_USART_IRQHandler+0xee>
          husart->RxISR(husart);
240119c6:	4620      	mov	r0, r4
240119c8:	4798      	blx	r3
      if ((HAL_IS_BIT_SET(husart->Instance->CR3, USART_CR3_DMAR)) ||
240119ca:	6821      	ldr	r1, [r4, #0]
        USART_EndTransfer(husart);
240119cc:	4620      	mov	r0, r4
      errorcode = husart->ErrorCode & HAL_USART_ERROR_ORE;
240119ce:	6de2      	ldr	r2, [r4, #92]	@ 0x5c
      if ((HAL_IS_BIT_SET(husart->Instance->CR3, USART_CR3_DMAR)) ||
240119d0:	688b      	ldr	r3, [r1, #8]
      errorcode = husart->ErrorCode & HAL_USART_ERROR_ORE;
240119d2:	f002 0208 	and.w	r2, r2, #8
      if ((HAL_IS_BIT_SET(husart->Instance->CR3, USART_CR3_DMAR)) ||
240119d6:	f003 0340 	and.w	r3, r3, #64	@ 0x40
240119da:	ea53 0502 	orrs.w	r5, r3, r2
240119de:	d01d      	beq.n	24011a1c <HAL_USART_IRQHandler+0x140>
        USART_EndTransfer(husart);
240119e0:	f7fe fe24 	bl	2401062c <USART_EndTransfer>
        if (HAL_IS_BIT_SET(husart->Instance->CR3, USART_CR3_DMAR))
240119e4:	688b      	ldr	r3, [r1, #8]
240119e6:	065d      	lsls	r5, r3, #25
240119e8:	d514      	bpl.n	24011a14 <HAL_USART_IRQHandler+0x138>
          CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAR | USART_CR3_DMAR);
240119ea:	688b      	ldr	r3, [r1, #8]
          if (husart->hdmatx != NULL)
240119ec:	6d20      	ldr	r0, [r4, #80]	@ 0x50
          CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAR | USART_CR3_DMAR);
240119ee:	f023 0340 	bic.w	r3, r3, #64	@ 0x40
240119f2:	608b      	str	r3, [r1, #8]
          if (husart->hdmatx != NULL)
240119f4:	b118      	cbz	r0, 240119fe <HAL_USART_IRQHandler+0x122>
            husart->hdmatx->XferAbortCallback = NULL;
240119f6:	2300      	movs	r3, #0
240119f8:	6503      	str	r3, [r0, #80]	@ 0x50
            (void)HAL_DMA_Abort_IT(husart->hdmatx);
240119fa:	f7f0 fab7 	bl	24001f6c <HAL_DMA_Abort_IT>
          if (husart->hdmarx != NULL)
240119fe:	6d60      	ldr	r0, [r4, #84]	@ 0x54
24011a00:	b140      	cbz	r0, 24011a14 <HAL_USART_IRQHandler+0x138>
            husart->hdmarx->XferAbortCallback = USART_DMAAbortOnError;
24011a02:	4b2f      	ldr	r3, [pc, #188]	@ (24011ac0 <HAL_USART_IRQHandler+0x1e4>)
24011a04:	6503      	str	r3, [r0, #80]	@ 0x50
            if (HAL_DMA_Abort_IT(husart->hdmarx) != HAL_OK)
24011a06:	f7f0 fab1 	bl	24001f6c <HAL_DMA_Abort_IT>
24011a0a:	2800      	cmp	r0, #0
24011a0c:	d0c8      	beq.n	240119a0 <HAL_USART_IRQHandler+0xc4>
              husart->hdmarx->XferAbortCallback(husart->hdmarx);
24011a0e:	6d60      	ldr	r0, [r4, #84]	@ 0x54
24011a10:	6d03      	ldr	r3, [r0, #80]	@ 0x50
24011a12:	e77b      	b.n	2401190c <HAL_USART_IRQHandler+0x30>
            HAL_USART_ErrorCallback(husart);
24011a14:	4620      	mov	r0, r4
24011a16:	f7ff ff4f 	bl	240118b8 <HAL_USART_ErrorCallback>
24011a1a:	e7c1      	b.n	240119a0 <HAL_USART_IRQHandler+0xc4>
        HAL_USART_ErrorCallback(husart);
24011a1c:	f7ff ff4c 	bl	240118b8 <HAL_USART_ErrorCallback>
        husart->ErrorCode = HAL_USART_ERROR_NONE;
24011a20:	65e5      	str	r5, [r4, #92]	@ 0x5c
24011a22:	e7bd      	b.n	240119a0 <HAL_USART_IRQHandler+0xc4>
  if (((isrflags & USART_ISR_TXE_TXFNF) != 0U)
24011a24:	0608      	lsls	r0, r1, #24
24011a26:	d50a      	bpl.n	24011a3e <HAL_USART_IRQHandler+0x162>
      && (((cr1its & USART_CR1_TXEIE_TXFNFIE) != 0U)
24011a28:	f002 0080 	and.w	r0, r2, #128	@ 0x80
          || ((cr3its & USART_CR3_TXFTIE) != 0U)))
24011a2c:	f405 0500 	and.w	r5, r5, #8388608	@ 0x800000
24011a30:	4328      	orrs	r0, r5
24011a32:	d004      	beq.n	24011a3e <HAL_USART_IRQHandler+0x162>
    if (husart->TxISR != NULL)
24011a34:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
24011a36:	2b00      	cmp	r3, #0
24011a38:	d0b2      	beq.n	240119a0 <HAL_USART_IRQHandler+0xc4>
      husart->TxISR(husart);
24011a3a:	4620      	mov	r0, r4
24011a3c:	e766      	b.n	2401190c <HAL_USART_IRQHandler+0x30>
  if (((isrflags & USART_ISR_TC) != 0U) && ((cr1its & USART_CR1_TCIE) != 0U))
24011a3e:	064f      	lsls	r7, r1, #25
24011a40:	d527      	bpl.n	24011a92 <HAL_USART_IRQHandler+0x1b6>
24011a42:	0656      	lsls	r6, r2, #25
24011a44:	d525      	bpl.n	24011a92 <HAL_USART_IRQHandler+0x1b6>
  __HAL_USART_DISABLE_IT(husart, USART_IT_TC);
24011a46:	681a      	ldr	r2, [r3, #0]
24011a48:	f022 0240 	bic.w	r2, r2, #64	@ 0x40
24011a4c:	601a      	str	r2, [r3, #0]
  __HAL_USART_DISABLE_IT(husart, USART_IT_ERR);
24011a4e:	689a      	ldr	r2, [r3, #8]
24011a50:	f022 0201 	bic.w	r2, r2, #1
24011a54:	609a      	str	r2, [r3, #8]
  husart->TxISR = NULL;
24011a56:	2200      	movs	r2, #0
24011a58:	64e2      	str	r2, [r4, #76]	@ 0x4c
  if (husart->State == HAL_USART_STATE_BUSY_TX)
24011a5a:	f894 2059 	ldrb.w	r2, [r4, #89]	@ 0x59
24011a5e:	2a12      	cmp	r2, #18
24011a60:	d10c      	bne.n	24011a7c <HAL_USART_IRQHandler+0x1a0>
    __HAL_USART_CLEAR_OREFLAG(husart);
24011a62:	2208      	movs	r2, #8
    HAL_USART_TxCpltCallback(husart);
24011a64:	4620      	mov	r0, r4
    __HAL_USART_CLEAR_OREFLAG(husart);
24011a66:	621a      	str	r2, [r3, #32]
    __HAL_USART_SEND_REQ(husart, USART_RXDATA_FLUSH_REQUEST);
24011a68:	699a      	ldr	r2, [r3, #24]
24011a6a:	f042 0208 	orr.w	r2, r2, #8
24011a6e:	619a      	str	r2, [r3, #24]
    husart->State = HAL_USART_STATE_READY;
24011a70:	2301      	movs	r3, #1
24011a72:	f884 3059 	strb.w	r3, [r4, #89]	@ 0x59
    HAL_USART_TxCpltCallback(husart);
24011a76:	f7ff fd21 	bl	240114bc <HAL_USART_TxCpltCallback>
24011a7a:	e791      	b.n	240119a0 <HAL_USART_IRQHandler+0xc4>
  else if (husart->RxXferCount == 0U)
24011a7c:	8ee3      	ldrh	r3, [r4, #54]	@ 0x36
24011a7e:	b29b      	uxth	r3, r3
24011a80:	2b00      	cmp	r3, #0
24011a82:	d18d      	bne.n	240119a0 <HAL_USART_IRQHandler+0xc4>
    husart->State = HAL_USART_STATE_READY;
24011a84:	2301      	movs	r3, #1
    HAL_USART_TxRxCpltCallback(husart);
24011a86:	4620      	mov	r0, r4
    husart->State = HAL_USART_STATE_READY;
24011a88:	f884 3059 	strb.w	r3, [r4, #89]	@ 0x59
    HAL_USART_TxRxCpltCallback(husart);
24011a8c:	f7ff fd42 	bl	24011514 <HAL_USART_TxRxCpltCallback>
24011a90:	e786      	b.n	240119a0 <HAL_USART_IRQHandler+0xc4>
  if (((isrflags & USART_ISR_TXFE) != 0U) && ((cr1its & USART_CR1_TXFEIE) != 0U))
24011a92:	020d      	lsls	r5, r1, #8
24011a94:	d506      	bpl.n	24011aa4 <HAL_USART_IRQHandler+0x1c8>
24011a96:	0050      	lsls	r0, r2, #1
24011a98:	d504      	bpl.n	24011aa4 <HAL_USART_IRQHandler+0x1c8>
    HAL_USARTEx_TxFifoEmptyCallback(husart);
24011a9a:	4620      	mov	r0, r4
}
24011a9c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    HAL_USARTEx_TxFifoEmptyCallback(husart);
24011aa0:	f000 b8c7 	b.w	24011c32 <HAL_USARTEx_TxFifoEmptyCallback>
  if (((isrflags & USART_ISR_RXFF) != 0U) && ((cr1its & USART_CR1_RXFFIE) != 0U))
24011aa4:	01cb      	lsls	r3, r1, #7
24011aa6:	f57f af7b 	bpl.w	240119a0 <HAL_USART_IRQHandler+0xc4>
24011aaa:	2a00      	cmp	r2, #0
24011aac:	f6bf af78 	bge.w	240119a0 <HAL_USART_IRQHandler+0xc4>
    HAL_USARTEx_RxFifoFullCallback(husart);
24011ab0:	4620      	mov	r0, r4
}
24011ab2:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    HAL_USARTEx_RxFifoFullCallback(husart);
24011ab6:	f000 b8bb 	b.w	24011c30 <HAL_USARTEx_RxFifoFullCallback>
24011aba:	bf00      	nop
24011abc:	10000001 	.word	0x10000001
24011ac0:	24011ac5 	.word	0x24011ac5

24011ac4 <USART_DMAAbortOnError>:
{
24011ac4:	b508      	push	{r3, lr}
  USART_HandleTypeDef *husart = (USART_HandleTypeDef *)(hdma->Parent);
24011ac6:	6b80      	ldr	r0, [r0, #56]	@ 0x38
  husart->RxXferCount = 0U;
24011ac8:	2300      	movs	r3, #0
24011aca:	86c3      	strh	r3, [r0, #54]	@ 0x36
  husart->TxXferCount = 0U;
24011acc:	85c3      	strh	r3, [r0, #46]	@ 0x2e
  HAL_USART_ErrorCallback(husart);
24011ace:	f7ff fef3 	bl	240118b8 <HAL_USART_ErrorCallback>
}
24011ad2:	bd08      	pop	{r3, pc}

24011ad4 <HAL_USART_AbortCpltCallback>:
__weak void HAL_USART_AbortCpltCallback(USART_HandleTypeDef *husart)
24011ad4:	4770      	bx	lr

24011ad6 <HAL_USART_Abort_IT>:
  CLEAR_BIT(husart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE | USART_CR1_TXEIE_TXFNFIE |
24011ad6:	6803      	ldr	r3, [r0, #0]
24011ad8:	681a      	ldr	r2, [r3, #0]
24011ada:	f422 72f0 	bic.w	r2, r2, #480	@ 0x1e0
{
24011ade:	b510      	push	{r4, lr}
  CLEAR_BIT(husart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE | USART_CR1_TXEIE_TXFNFIE |
24011ae0:	601a      	str	r2, [r3, #0]
{
24011ae2:	4604      	mov	r4, r0
  CLEAR_BIT(husart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE | USART_CR3_TXFTIE));
24011ae4:	689a      	ldr	r2, [r3, #8]
  if (husart->hdmatx != NULL)
24011ae6:	6d00      	ldr	r0, [r0, #80]	@ 0x50
  CLEAR_BIT(husart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE | USART_CR3_TXFTIE));
24011ae8:	f022 5284 	bic.w	r2, r2, #276824064	@ 0x10800000
24011aec:	f022 0201 	bic.w	r2, r2, #1
24011af0:	609a      	str	r2, [r3, #8]
  if (husart->hdmatx != NULL)
24011af2:	b128      	cbz	r0, 24011b00 <HAL_USART_Abort_IT+0x2a>
    if (HAL_IS_BIT_SET(husart->Instance->CR3, USART_CR3_DMAT))
24011af4:	689a      	ldr	r2, [r3, #8]
24011af6:	f012 0280 	ands.w	r2, r2, #128	@ 0x80
      husart->hdmatx->XferAbortCallback = USART_DMATxAbortCallback;
24011afa:	bf18      	it	ne
24011afc:	4a23      	ldrne	r2, [pc, #140]	@ (24011b8c <HAL_USART_Abort_IT+0xb6>)
      husart->hdmatx->XferAbortCallback = NULL;
24011afe:	6502      	str	r2, [r0, #80]	@ 0x50
  if (husart->hdmarx != NULL)
24011b00:	6d61      	ldr	r1, [r4, #84]	@ 0x54
24011b02:	b129      	cbz	r1, 24011b10 <HAL_USART_Abort_IT+0x3a>
    if (HAL_IS_BIT_SET(husart->Instance->CR3, USART_CR3_DMAR))
24011b04:	689a      	ldr	r2, [r3, #8]
24011b06:	f012 0240 	ands.w	r2, r2, #64	@ 0x40
      husart->hdmarx->XferAbortCallback = USART_DMARxAbortCallback;
24011b0a:	bf18      	it	ne
24011b0c:	4a20      	ldrne	r2, [pc, #128]	@ (24011b90 <HAL_USART_Abort_IT+0xba>)
      husart->hdmarx->XferAbortCallback = NULL;
24011b0e:	650a      	str	r2, [r1, #80]	@ 0x50
  if (HAL_IS_BIT_SET(husart->Instance->CR3, USART_CR3_DMAT))
24011b10:	689a      	ldr	r2, [r3, #8]
24011b12:	0612      	lsls	r2, r2, #24
24011b14:	d50b      	bpl.n	24011b2e <HAL_USART_Abort_IT+0x58>
    CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAT);
24011b16:	689a      	ldr	r2, [r3, #8]
24011b18:	f022 0280 	bic.w	r2, r2, #128	@ 0x80
24011b1c:	609a      	str	r2, [r3, #8]
    if (husart->hdmatx != NULL)
24011b1e:	b130      	cbz	r0, 24011b2e <HAL_USART_Abort_IT+0x58>
      if (HAL_DMA_Abort_IT(husart->hdmatx) != HAL_OK)
24011b20:	f7f0 fa24 	bl	24001f6c <HAL_DMA_Abort_IT>
24011b24:	4603      	mov	r3, r0
24011b26:	b118      	cbz	r0, 24011b30 <HAL_USART_Abort_IT+0x5a>
        husart->hdmatx->XferAbortCallback = NULL;
24011b28:	6d23      	ldr	r3, [r4, #80]	@ 0x50
24011b2a:	2200      	movs	r2, #0
24011b2c:	651a      	str	r2, [r3, #80]	@ 0x50
  uint32_t abortcplt = 1U;
24011b2e:	2301      	movs	r3, #1
  if (HAL_IS_BIT_SET(husart->Instance->CR3, USART_CR3_DMAR))
24011b30:	6822      	ldr	r2, [r4, #0]
24011b32:	6891      	ldr	r1, [r2, #8]
24011b34:	0649      	lsls	r1, r1, #25
24011b36:	d525      	bpl.n	24011b84 <HAL_USART_Abort_IT+0xae>
    CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAR);
24011b38:	6891      	ldr	r1, [r2, #8]
    if (husart->hdmarx != NULL)
24011b3a:	6d60      	ldr	r0, [r4, #84]	@ 0x54
    CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAR);
24011b3c:	f021 0140 	bic.w	r1, r1, #64	@ 0x40
24011b40:	6091      	str	r1, [r2, #8]
    if (husart->hdmarx != NULL)
24011b42:	b1f8      	cbz	r0, 24011b84 <HAL_USART_Abort_IT+0xae>
      if (HAL_DMA_Abort_IT(husart->hdmarx) != HAL_OK)
24011b44:	f7f0 fa12 	bl	24001f6c <HAL_DMA_Abort_IT>
24011b48:	b1f0      	cbz	r0, 24011b88 <HAL_USART_Abort_IT+0xb2>
        husart->hdmarx->XferAbortCallback = NULL;
24011b4a:	6d63      	ldr	r3, [r4, #84]	@ 0x54
24011b4c:	2200      	movs	r2, #0
24011b4e:	651a      	str	r2, [r3, #80]	@ 0x50
    husart->TxXferCount = 0U;
24011b50:	2300      	movs	r3, #0
    __HAL_USART_CLEAR_FLAG(husart, USART_CLEAR_OREF | USART_CLEAR_NEF | USART_CLEAR_PEF | USART_CLEAR_FEF);
24011b52:	220f      	movs	r2, #15
    husart->TxXferCount = 0U;
24011b54:	85e3      	strh	r3, [r4, #46]	@ 0x2e
    husart->RxXferCount = 0U;
24011b56:	86e3      	strh	r3, [r4, #54]	@ 0x36
    husart->ErrorCode = HAL_USART_ERROR_NONE;
24011b58:	65e3      	str	r3, [r4, #92]	@ 0x5c
    __HAL_USART_CLEAR_FLAG(husart, USART_CLEAR_OREF | USART_CLEAR_NEF | USART_CLEAR_PEF | USART_CLEAR_FEF);
24011b5a:	6823      	ldr	r3, [r4, #0]
24011b5c:	621a      	str	r2, [r3, #32]
    if (husart->FifoMode == USART_FIFOMODE_ENABLE)
24011b5e:	6c62      	ldr	r2, [r4, #68]	@ 0x44
24011b60:	f1b2 5f00 	cmp.w	r2, #536870912	@ 0x20000000
24011b64:	d103      	bne.n	24011b6e <HAL_USART_Abort_IT+0x98>
      __HAL_USART_SEND_REQ(husart, USART_TXDATA_FLUSH_REQUEST);
24011b66:	699a      	ldr	r2, [r3, #24]
24011b68:	f042 0210 	orr.w	r2, r2, #16
24011b6c:	619a      	str	r2, [r3, #24]
    __HAL_USART_SEND_REQ(husart, USART_RXDATA_FLUSH_REQUEST);
24011b6e:	699a      	ldr	r2, [r3, #24]
    HAL_USART_AbortCpltCallback(husart);
24011b70:	4620      	mov	r0, r4
    __HAL_USART_SEND_REQ(husart, USART_RXDATA_FLUSH_REQUEST);
24011b72:	f042 0208 	orr.w	r2, r2, #8
24011b76:	619a      	str	r2, [r3, #24]
    husart->State  = HAL_USART_STATE_READY;
24011b78:	2301      	movs	r3, #1
24011b7a:	f884 3059 	strb.w	r3, [r4, #89]	@ 0x59
    HAL_USART_AbortCpltCallback(husart);
24011b7e:	f7ff ffa9 	bl	24011ad4 <HAL_USART_AbortCpltCallback>
24011b82:	e001      	b.n	24011b88 <HAL_USART_Abort_IT+0xb2>
  if (abortcplt == 1U)
24011b84:	2b00      	cmp	r3, #0
24011b86:	d1e3      	bne.n	24011b50 <HAL_USART_Abort_IT+0x7a>
}
24011b88:	2000      	movs	r0, #0
24011b8a:	bd10      	pop	{r4, pc}
24011b8c:	24011bbf 	.word	0x24011bbf
24011b90:	24011b95 	.word	0x24011b95

24011b94 <USART_DMARxAbortCallback>:
  USART_HandleTypeDef *husart = (USART_HandleTypeDef *)(hdma->Parent);
24011b94:	6b80      	ldr	r0, [r0, #56]	@ 0x38
{
24011b96:	b508      	push	{r3, lr}
  husart->hdmarx->XferAbortCallback = NULL;
24011b98:	6d42      	ldr	r2, [r0, #84]	@ 0x54
24011b9a:	2300      	movs	r3, #0
24011b9c:	6513      	str	r3, [r2, #80]	@ 0x50
  if (husart->hdmatx != NULL)
24011b9e:	6d02      	ldr	r2, [r0, #80]	@ 0x50
24011ba0:	b10a      	cbz	r2, 24011ba6 <USART_DMARxAbortCallback+0x12>
    if (husart->hdmatx->XferAbortCallback != NULL)
24011ba2:	6d12      	ldr	r2, [r2, #80]	@ 0x50
24011ba4:	b952      	cbnz	r2, 24011bbc <USART_DMARxAbortCallback+0x28>
  husart->TxXferCount = 0U;
24011ba6:	85c3      	strh	r3, [r0, #46]	@ 0x2e
  __HAL_USART_CLEAR_FLAG(husart, USART_CLEAR_OREF | USART_CLEAR_NEF | USART_CLEAR_PEF | USART_CLEAR_FEF);
24011ba8:	220f      	movs	r2, #15
  husart->RxXferCount = 0U;
24011baa:	86c3      	strh	r3, [r0, #54]	@ 0x36
  husart->ErrorCode = HAL_USART_ERROR_NONE;
24011bac:	65c3      	str	r3, [r0, #92]	@ 0x5c
  __HAL_USART_CLEAR_FLAG(husart, USART_CLEAR_OREF | USART_CLEAR_NEF | USART_CLEAR_PEF | USART_CLEAR_FEF);
24011bae:	6803      	ldr	r3, [r0, #0]
24011bb0:	621a      	str	r2, [r3, #32]
  husart->State  = HAL_USART_STATE_READY;
24011bb2:	2301      	movs	r3, #1
24011bb4:	f880 3059 	strb.w	r3, [r0, #89]	@ 0x59
  HAL_USART_AbortCpltCallback(husart);
24011bb8:	f7ff ff8c 	bl	24011ad4 <HAL_USART_AbortCpltCallback>
}
24011bbc:	bd08      	pop	{r3, pc}

24011bbe <USART_DMATxAbortCallback>:
  USART_HandleTypeDef *husart = (USART_HandleTypeDef *)(hdma->Parent);
24011bbe:	6b80      	ldr	r0, [r0, #56]	@ 0x38
{
24011bc0:	b508      	push	{r3, lr}
  husart->hdmatx->XferAbortCallback = NULL;
24011bc2:	6d02      	ldr	r2, [r0, #80]	@ 0x50
24011bc4:	2300      	movs	r3, #0
24011bc6:	6513      	str	r3, [r2, #80]	@ 0x50
  if (husart->hdmarx != NULL)
24011bc8:	6d42      	ldr	r2, [r0, #84]	@ 0x54
24011bca:	b10a      	cbz	r2, 24011bd0 <USART_DMATxAbortCallback+0x12>
    if (husart->hdmarx->XferAbortCallback != NULL)
24011bcc:	6d12      	ldr	r2, [r2, #80]	@ 0x50
24011bce:	b952      	cbnz	r2, 24011be6 <USART_DMATxAbortCallback+0x28>
  husart->TxXferCount = 0U;
24011bd0:	85c3      	strh	r3, [r0, #46]	@ 0x2e
  __HAL_USART_CLEAR_FLAG(husart, USART_CLEAR_OREF | USART_CLEAR_NEF | USART_CLEAR_PEF | USART_CLEAR_FEF);
24011bd2:	220f      	movs	r2, #15
  husart->RxXferCount = 0U;
24011bd4:	86c3      	strh	r3, [r0, #54]	@ 0x36
  husart->ErrorCode = HAL_USART_ERROR_NONE;
24011bd6:	65c3      	str	r3, [r0, #92]	@ 0x5c
  __HAL_USART_CLEAR_FLAG(husart, USART_CLEAR_OREF | USART_CLEAR_NEF | USART_CLEAR_PEF | USART_CLEAR_FEF);
24011bd8:	6803      	ldr	r3, [r0, #0]
24011bda:	621a      	str	r2, [r3, #32]
  husart->State = HAL_USART_STATE_READY;
24011bdc:	2301      	movs	r3, #1
24011bde:	f880 3059 	strb.w	r3, [r0, #89]	@ 0x59
  HAL_USART_AbortCpltCallback(husart);
24011be2:	f7ff ff77 	bl	24011ad4 <HAL_USART_AbortCpltCallback>
}
24011be6:	bd08      	pop	{r3, pc}

24011be8 <HAL_USART_GetState>:
  return husart->State;
24011be8:	f890 0059 	ldrb.w	r0, [r0, #89]	@ 0x59
}
24011bec:	4770      	bx	lr

24011bee <HAL_USART_GetError>:
  return husart->ErrorCode;
24011bee:	6dc0      	ldr	r0, [r0, #92]	@ 0x5c
}
24011bf0:	4770      	bx	lr
24011bf2:	bf00      	nop

24011bf4 <USARTEx_SetNbDataToProcess>:
  uint8_t tx_fifo_threshold;
  /* 2 0U/1U added for MISRAC2012-Rule-18.1_b and MISRAC2012-Rule-18.1_d */
  static const uint8_t numerator[]   = {1U, 1U, 1U, 3U, 7U, 1U, 0U, 0U};
  static const uint8_t denominator[] = {8U, 4U, 2U, 4U, 8U, 1U, 1U, 1U};

  if (husart->FifoMode == USART_FIFOMODE_DISABLE)
24011bf4:	6c43      	ldr	r3, [r0, #68]	@ 0x44
{
24011bf6:	b510      	push	{r4, lr}
  if (husart->FifoMode == USART_FIFOMODE_DISABLE)
24011bf8:	b91b      	cbnz	r3, 24011c02 <USARTEx_SetNbDataToProcess+0xe>
  {
    husart->NbTxDataToProcess = 1U;
24011bfa:	2301      	movs	r3, #1
24011bfc:	8783      	strh	r3, [r0, #60]	@ 0x3c
    husart->NbRxDataToProcess = 1U;
24011bfe:	8743      	strh	r3, [r0, #58]	@ 0x3a
    husart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
                                (uint16_t)denominator[tx_fifo_threshold];
    husart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
                                (uint16_t)denominator[rx_fifo_threshold];
  }
}
24011c00:	bd10      	pop	{r4, pc}
    rx_fifo_threshold = (uint8_t)((READ_BIT(husart->Instance->CR3,
24011c02:	6803      	ldr	r3, [r0, #0]
    husart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
24011c04:	4a09      	ldr	r2, [pc, #36]	@ (24011c2c <USARTEx_SetNbDataToProcess+0x38>)
    rx_fifo_threshold = (uint8_t)((READ_BIT(husart->Instance->CR3,
24011c06:	689c      	ldr	r4, [r3, #8]
    tx_fifo_threshold = (uint8_t)((READ_BIT(husart->Instance->CR3,
24011c08:	689b      	ldr	r3, [r3, #8]
                                            USART_CR3_TXFTCFG) >> USART_CR3_TXFTCFG_Pos) & 0xFFU);
24011c0a:	0f5b      	lsrs	r3, r3, #29
    husart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
24011c0c:	5cd1      	ldrb	r1, [r2, r3]
                                (uint16_t)denominator[tx_fifo_threshold];
24011c0e:	4413      	add	r3, r2
    husart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
24011c10:	0109      	lsls	r1, r1, #4
                                (uint16_t)denominator[tx_fifo_threshold];
24011c12:	7a1b      	ldrb	r3, [r3, #8]
    husart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
24011c14:	fbb1 f3f3 	udiv	r3, r1, r3
    husart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
24011c18:	f3c4 6142 	ubfx	r1, r4, #25, #3
    husart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
24011c1c:	8783      	strh	r3, [r0, #60]	@ 0x3c
    husart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
24011c1e:	5c53      	ldrb	r3, [r2, r1]
                                (uint16_t)denominator[rx_fifo_threshold];
24011c20:	440a      	add	r2, r1
    husart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
24011c22:	011b      	lsls	r3, r3, #4
                                (uint16_t)denominator[rx_fifo_threshold];
24011c24:	7a12      	ldrb	r2, [r2, #8]
    husart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
24011c26:	fbb3 f3f2 	udiv	r3, r3, r2
}
24011c2a:	e7e8      	b.n	24011bfe <USARTEx_SetNbDataToProcess+0xa>
24011c2c:	240141ea 	.word	0x240141ea

24011c30 <HAL_USARTEx_RxFifoFullCallback>:
}
24011c30:	4770      	bx	lr

24011c32 <HAL_USARTEx_TxFifoEmptyCallback>:
__weak void HAL_USARTEx_TxFifoEmptyCallback(USART_HandleTypeDef *husart)
24011c32:	4770      	bx	lr

24011c34 <HAL_USARTEx_EnableSlaveMode>:
  __HAL_LOCK(husart);
24011c34:	f890 3058 	ldrb.w	r3, [r0, #88]	@ 0x58
{
24011c38:	4602      	mov	r2, r0
24011c3a:	2002      	movs	r0, #2
  __HAL_LOCK(husart);
24011c3c:	2b01      	cmp	r3, #1
24011c3e:	d01f      	beq.n	24011c80 <HAL_USARTEx_EnableSlaveMode+0x4c>
  tmpcr1 = READ_REG(husart->Instance->CR1);
24011c40:	6813      	ldr	r3, [r2, #0]
  husart->State = HAL_USART_STATE_BUSY;
24011c42:	f882 0059 	strb.w	r0, [r2, #89]	@ 0x59
  tmpcr1 = READ_REG(husart->Instance->CR1);
24011c46:	6818      	ldr	r0, [r3, #0]
  __HAL_USART_DISABLE(husart);
24011c48:	6819      	ldr	r1, [r3, #0]
24011c4a:	f021 0101 	bic.w	r1, r1, #1
24011c4e:	6019      	str	r1, [r3, #0]
  CLEAR_BIT(husart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
24011c50:	6859      	ldr	r1, [r3, #4]
24011c52:	f421 4190 	bic.w	r1, r1, #18432	@ 0x4800
24011c56:	6059      	str	r1, [r3, #4]
  CLEAR_BIT(husart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
24011c58:	6899      	ldr	r1, [r3, #8]
24011c5a:	f021 012a 	bic.w	r1, r1, #42	@ 0x2a
24011c5e:	6099      	str	r1, [r3, #8]
  SET_BIT(husart->Instance->CR2, USART_CR2_SLVEN);
24011c60:	6859      	ldr	r1, [r3, #4]
24011c62:	f041 0101 	orr.w	r1, r1, #1
24011c66:	6059      	str	r1, [r3, #4]
  husart->SlaveMode = USART_SLAVEMODE_ENABLE;
24011c68:	2101      	movs	r1, #1
  WRITE_REG(husart->Instance->CR1, tmpcr1);
24011c6a:	6018      	str	r0, [r3, #0]
  __HAL_UNLOCK(husart);
24011c6c:	2000      	movs	r0, #0
  husart->SlaveMode = USART_SLAVEMODE_ENABLE;
24011c6e:	6411      	str	r1, [r2, #64]	@ 0x40
  husart->State = HAL_USART_STATE_READY;
24011c70:	f882 1059 	strb.w	r1, [r2, #89]	@ 0x59
  __HAL_USART_ENABLE(husart);
24011c74:	6819      	ldr	r1, [r3, #0]
24011c76:	f041 0101 	orr.w	r1, r1, #1
24011c7a:	6019      	str	r1, [r3, #0]
  __HAL_UNLOCK(husart);
24011c7c:	f882 0058 	strb.w	r0, [r2, #88]	@ 0x58
}
24011c80:	4770      	bx	lr

24011c82 <HAL_USARTEx_DisableSlaveMode>:
  __HAL_LOCK(husart);
24011c82:	f890 3058 	ldrb.w	r3, [r0, #88]	@ 0x58
24011c86:	2b01      	cmp	r3, #1
24011c88:	f04f 0302 	mov.w	r3, #2
24011c8c:	d013      	beq.n	24011cb6 <HAL_USARTEx_DisableSlaveMode+0x34>
  husart->State = HAL_USART_STATE_BUSY;
24011c8e:	f880 3059 	strb.w	r3, [r0, #89]	@ 0x59
  tmpcr1 = READ_REG(husart->Instance->CR1);
24011c92:	6803      	ldr	r3, [r0, #0]
24011c94:	6819      	ldr	r1, [r3, #0]
  __HAL_USART_DISABLE(husart);
24011c96:	681a      	ldr	r2, [r3, #0]
24011c98:	f022 0201 	bic.w	r2, r2, #1
24011c9c:	601a      	str	r2, [r3, #0]
  CLEAR_BIT(husart->Instance->CR2, USART_CR2_SLVEN);
24011c9e:	685a      	ldr	r2, [r3, #4]
24011ca0:	f022 0201 	bic.w	r2, r2, #1
24011ca4:	605a      	str	r2, [r3, #4]
  husart->State = HAL_USART_STATE_READY;
24011ca6:	2201      	movs	r2, #1
  WRITE_REG(husart->Instance->CR1, tmpcr1);
24011ca8:	6019      	str	r1, [r3, #0]
  husart->SlaveMode = USART_SLAVEMODE_DISABLE;
24011caa:	2300      	movs	r3, #0
  husart->State = HAL_USART_STATE_READY;
24011cac:	f880 2059 	strb.w	r2, [r0, #89]	@ 0x59
  husart->SlaveMode = USART_SLAVEMODE_DISABLE;
24011cb0:	6403      	str	r3, [r0, #64]	@ 0x40
  __HAL_UNLOCK(husart);
24011cb2:	f880 3058 	strb.w	r3, [r0, #88]	@ 0x58
  __HAL_LOCK(husart);
24011cb6:	4618      	mov	r0, r3
}
24011cb8:	4770      	bx	lr

24011cba <HAL_USARTEx_ConfigNSS>:
{
24011cba:	b510      	push	{r4, lr}
  __HAL_LOCK(husart);
24011cbc:	f890 2058 	ldrb.w	r2, [r0, #88]	@ 0x58
{
24011cc0:	4603      	mov	r3, r0
24011cc2:	2002      	movs	r0, #2
  __HAL_LOCK(husart);
24011cc4:	2a01      	cmp	r2, #1
24011cc6:	d013      	beq.n	24011cf0 <HAL_USARTEx_ConfigNSS+0x36>
  tmpcr1 = READ_REG(husart->Instance->CR1);
24011cc8:	681a      	ldr	r2, [r3, #0]
  husart->State = HAL_USART_STATE_BUSY;
24011cca:	f883 0059 	strb.w	r0, [r3, #89]	@ 0x59
  tmpcr1 = READ_REG(husart->Instance->CR1);
24011cce:	6814      	ldr	r4, [r2, #0]
  __HAL_USART_DISABLE(husart);
24011cd0:	6810      	ldr	r0, [r2, #0]
24011cd2:	f020 0001 	bic.w	r0, r0, #1
24011cd6:	6010      	str	r0, [r2, #0]
  MODIFY_REG(husart->Instance->CR2, USART_CR2_DIS_NSS, NSSConfig);
24011cd8:	6850      	ldr	r0, [r2, #4]
24011cda:	f020 0008 	bic.w	r0, r0, #8
24011cde:	4301      	orrs	r1, r0
  __HAL_UNLOCK(husart);
24011ce0:	2000      	movs	r0, #0
  MODIFY_REG(husart->Instance->CR2, USART_CR2_DIS_NSS, NSSConfig);
24011ce2:	6051      	str	r1, [r2, #4]
  WRITE_REG(husart->Instance->CR1, tmpcr1);
24011ce4:	6014      	str	r4, [r2, #0]
  husart->State = HAL_USART_STATE_READY;
24011ce6:	2201      	movs	r2, #1
  __HAL_UNLOCK(husart);
24011ce8:	f883 0058 	strb.w	r0, [r3, #88]	@ 0x58
  husart->State = HAL_USART_STATE_READY;
24011cec:	f883 2059 	strb.w	r2, [r3, #89]	@ 0x59
}
24011cf0:	bd10      	pop	{r4, pc}

24011cf2 <HAL_USARTEx_EnableFifoMode>:
{
24011cf2:	b510      	push	{r4, lr}
  __HAL_LOCK(husart);
24011cf4:	f890 3058 	ldrb.w	r3, [r0, #88]	@ 0x58
24011cf8:	2b01      	cmp	r3, #1
24011cfa:	f04f 0302 	mov.w	r3, #2
24011cfe:	d015      	beq.n	24011d2c <HAL_USARTEx_EnableFifoMode+0x3a>
  husart->State = HAL_USART_STATE_BUSY;
24011d00:	f880 3059 	strb.w	r3, [r0, #89]	@ 0x59
  tmpcr1 = READ_REG(husart->Instance->CR1);
24011d04:	6803      	ldr	r3, [r0, #0]
24011d06:	681a      	ldr	r2, [r3, #0]
  __HAL_USART_DISABLE(husart);
24011d08:	6819      	ldr	r1, [r3, #0]
  SET_BIT(tmpcr1, USART_CR1_FIFOEN);
24011d0a:	f042 5200 	orr.w	r2, r2, #536870912	@ 0x20000000
  __HAL_USART_DISABLE(husart);
24011d0e:	f021 0101 	bic.w	r1, r1, #1
24011d12:	6019      	str	r1, [r3, #0]
  husart->FifoMode = USART_FIFOMODE_ENABLE;
24011d14:	f04f 5100 	mov.w	r1, #536870912	@ 0x20000000
24011d18:	6441      	str	r1, [r0, #68]	@ 0x44
  WRITE_REG(husart->Instance->CR1, tmpcr1);
24011d1a:	601a      	str	r2, [r3, #0]
  USARTEx_SetNbDataToProcess(husart);
24011d1c:	f7ff ff6a 	bl	24011bf4 <USARTEx_SetNbDataToProcess>
  husart->State = HAL_USART_STATE_READY;
24011d20:	2301      	movs	r3, #1
24011d22:	f880 3059 	strb.w	r3, [r0, #89]	@ 0x59
  __HAL_UNLOCK(husart);
24011d26:	2300      	movs	r3, #0
24011d28:	f880 3058 	strb.w	r3, [r0, #88]	@ 0x58
  __HAL_LOCK(husart);
24011d2c:	4618      	mov	r0, r3
}
24011d2e:	bd10      	pop	{r4, pc}

24011d30 <HAL_USARTEx_DisableFifoMode>:
  __HAL_LOCK(husart);
24011d30:	f890 3058 	ldrb.w	r3, [r0, #88]	@ 0x58
24011d34:	2b01      	cmp	r3, #1
24011d36:	f04f 0302 	mov.w	r3, #2
24011d3a:	d011      	beq.n	24011d60 <HAL_USARTEx_DisableFifoMode+0x30>
  tmpcr1 = READ_REG(husart->Instance->CR1);
24011d3c:	6802      	ldr	r2, [r0, #0]
  husart->State = HAL_USART_STATE_BUSY;
24011d3e:	f880 3059 	strb.w	r3, [r0, #89]	@ 0x59
  tmpcr1 = READ_REG(husart->Instance->CR1);
24011d42:	6811      	ldr	r1, [r2, #0]
  __HAL_USART_DISABLE(husart);
24011d44:	6813      	ldr	r3, [r2, #0]
  CLEAR_BIT(tmpcr1, USART_CR1_FIFOEN);
24011d46:	f021 5100 	bic.w	r1, r1, #536870912	@ 0x20000000
  __HAL_USART_DISABLE(husart);
24011d4a:	f023 0301 	bic.w	r3, r3, #1
24011d4e:	6013      	str	r3, [r2, #0]
  husart->FifoMode = USART_FIFOMODE_DISABLE;
24011d50:	2300      	movs	r3, #0
24011d52:	6443      	str	r3, [r0, #68]	@ 0x44
  WRITE_REG(husart->Instance->CR1, tmpcr1);
24011d54:	6011      	str	r1, [r2, #0]
  husart->State = HAL_USART_STATE_READY;
24011d56:	2201      	movs	r2, #1
  __HAL_UNLOCK(husart);
24011d58:	f880 3058 	strb.w	r3, [r0, #88]	@ 0x58
  husart->State = HAL_USART_STATE_READY;
24011d5c:	f880 2059 	strb.w	r2, [r0, #89]	@ 0x59
  __HAL_LOCK(husart);
24011d60:	4618      	mov	r0, r3
}
24011d62:	4770      	bx	lr

24011d64 <HAL_USARTEx_SetTxFifoThreshold>:
{
24011d64:	b570      	push	{r4, r5, r6, lr}
  __HAL_LOCK(husart);
24011d66:	f890 3058 	ldrb.w	r3, [r0, #88]	@ 0x58
24011d6a:	2b01      	cmp	r3, #1
24011d6c:	f04f 0302 	mov.w	r3, #2
24011d70:	d015      	beq.n	24011d9e <HAL_USARTEx_SetTxFifoThreshold+0x3a>
  tmpcr1 = READ_REG(husart->Instance->CR1);
24011d72:	6805      	ldr	r5, [r0, #0]
  husart->State = HAL_USART_STATE_BUSY;
24011d74:	f880 3059 	strb.w	r3, [r0, #89]	@ 0x59
  tmpcr1 = READ_REG(husart->Instance->CR1);
24011d78:	682e      	ldr	r6, [r5, #0]
  __HAL_USART_DISABLE(husart);
24011d7a:	682b      	ldr	r3, [r5, #0]
24011d7c:	f023 0301 	bic.w	r3, r3, #1
24011d80:	602b      	str	r3, [r5, #0]
  MODIFY_REG(husart->Instance->CR3, USART_CR3_TXFTCFG, Threshold);
24011d82:	68ab      	ldr	r3, [r5, #8]
24011d84:	f023 4360 	bic.w	r3, r3, #3758096384	@ 0xe0000000
24011d88:	4319      	orrs	r1, r3
24011d8a:	60a9      	str	r1, [r5, #8]
  USARTEx_SetNbDataToProcess(husart);
24011d8c:	f7ff ff32 	bl	24011bf4 <USARTEx_SetNbDataToProcess>
  husart->State = HAL_USART_STATE_READY;
24011d90:	2301      	movs	r3, #1
  WRITE_REG(husart->Instance->CR1, tmpcr1);
24011d92:	602e      	str	r6, [r5, #0]
  husart->State = HAL_USART_STATE_READY;
24011d94:	f880 3059 	strb.w	r3, [r0, #89]	@ 0x59
  __HAL_UNLOCK(husart);
24011d98:	2300      	movs	r3, #0
24011d9a:	f880 3058 	strb.w	r3, [r0, #88]	@ 0x58
  __HAL_LOCK(husart);
24011d9e:	4618      	mov	r0, r3
}
24011da0:	bd70      	pop	{r4, r5, r6, pc}

24011da2 <HAL_USARTEx_SetRxFifoThreshold>:
{
24011da2:	b570      	push	{r4, r5, r6, lr}
  __HAL_LOCK(husart);
24011da4:	f890 3058 	ldrb.w	r3, [r0, #88]	@ 0x58
24011da8:	2b01      	cmp	r3, #1
24011daa:	f04f 0302 	mov.w	r3, #2
24011dae:	d015      	beq.n	24011ddc <HAL_USARTEx_SetRxFifoThreshold+0x3a>
  tmpcr1 = READ_REG(husart->Instance->CR1);
24011db0:	6805      	ldr	r5, [r0, #0]
  husart->State = HAL_USART_STATE_BUSY;
24011db2:	f880 3059 	strb.w	r3, [r0, #89]	@ 0x59
  tmpcr1 = READ_REG(husart->Instance->CR1);
24011db6:	682e      	ldr	r6, [r5, #0]
  __HAL_USART_DISABLE(husart);
24011db8:	682b      	ldr	r3, [r5, #0]
24011dba:	f023 0301 	bic.w	r3, r3, #1
24011dbe:	602b      	str	r3, [r5, #0]
  MODIFY_REG(husart->Instance->CR3, USART_CR3_RXFTCFG, Threshold);
24011dc0:	68ab      	ldr	r3, [r5, #8]
24011dc2:	f023 6360 	bic.w	r3, r3, #234881024	@ 0xe000000
24011dc6:	4319      	orrs	r1, r3
24011dc8:	60a9      	str	r1, [r5, #8]
  USARTEx_SetNbDataToProcess(husart);
24011dca:	f7ff ff13 	bl	24011bf4 <USARTEx_SetNbDataToProcess>
  husart->State = HAL_USART_STATE_READY;
24011dce:	2301      	movs	r3, #1
  WRITE_REG(husart->Instance->CR1, tmpcr1);
24011dd0:	602e      	str	r6, [r5, #0]
  husart->State = HAL_USART_STATE_READY;
24011dd2:	f880 3059 	strb.w	r3, [r0, #89]	@ 0x59
  __HAL_UNLOCK(husart);
24011dd6:	2300      	movs	r3, #0
24011dd8:	f880 3058 	strb.w	r3, [r0, #88]	@ 0x58
  __HAL_LOCK(husart);
24011ddc:	4618      	mov	r0, r3
}
24011dde:	bd70      	pop	{r4, r5, r6, pc}

24011de0 <__io_putchar>:
  \param [in]     ch  Character to transmit.
  \returns            Character to transmit.
 */
__STATIC_INLINE uint32_t ITM_SendChar (uint32_t ch)
{
  if (((ITM->TCR & ITM_TCR_ITMENA_Msk) != 0UL) &&      /* ITM enabled */
24011de0:	f04f 4360 	mov.w	r3, #3758096384	@ 0xe0000000
24011de4:	f8d3 2e80 	ldr.w	r2, [r3, #3712]	@ 0xe80
24011de8:	07d1      	lsls	r1, r2, #31
24011dea:	d50a      	bpl.n	24011e02 <__io_putchar+0x22>
      ((ITM->TER & 1UL               ) != 0UL)   )     /* ITM Port #0 enabled */
24011dec:	f8d3 2e00 	ldr.w	r2, [r3, #3584]	@ 0xe00
  if (((ITM->TCR & ITM_TCR_ITMENA_Msk) != 0UL) &&      /* ITM enabled */
24011df0:	07d2      	lsls	r2, r2, #31
24011df2:	d401      	bmi.n	24011df8 <__io_putchar+0x18>
24011df4:	4770      	bx	lr
  {
    while (ITM->PORT[0U].u32 == 0UL)
    {
      __NOP();
24011df6:	bf00      	nop
    while (ITM->PORT[0U].u32 == 0UL)
24011df8:	681a      	ldr	r2, [r3, #0]
24011dfa:	2a00      	cmp	r2, #0
24011dfc:	d0fb      	beq.n	24011df6 <__io_putchar+0x16>
    }
    ITM->PORT[0U].u8 = (uint8_t)ch;
24011dfe:	b2c2      	uxtb	r2, r0
24011e00:	701a      	strb	r2, [r3, #0]
int __io_putchar(int ch)
{
    ITM_SendChar(ch);

    return ch;
}
24011e02:	4770      	bx	lr

24011e04 <HAL_InitTick>:

HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
  return HAL_OK;
}
24011e04:	2000      	movs	r0, #0
24011e06:	4770      	bx	lr

24011e08 <HAL_GetTick>:

uint32_t HAL_GetTick(void)
{
  return 1;
}
24011e08:	2001      	movs	r0, #1
24011e0a:	4770      	bx	lr

24011e0c <HAL_Delay>:
void HAL_Delay(uint32_t Delay)
{
  int i = 0;

  for (i = 0; i < 0x400; i++);
}
24011e0c:	4770      	bx	lr

24011e0e <SystemClock_Config>:

void SystemClock_Config(void)
{
24011e0e:	b530      	push	{r4, r5, lr}
24011e10:	b09f      	sub	sp, #124	@ 0x7c
  RCC_OscInitTypeDef RCC_OscInitStruct = {0, };
24011e12:	224c      	movs	r2, #76	@ 0x4c
24011e14:	2100      	movs	r1, #0
24011e16:	a80b      	add	r0, sp, #44	@ 0x2c
24011e18:	f000 ffd6 	bl	24012dc8 <memset>
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0, };
24011e1c:	2220      	movs	r2, #32
24011e1e:	2100      	movs	r1, #0
24011e20:	a803      	add	r0, sp, #12
24011e22:	f000 ffd1 	bl	24012dc8 <memset>

  /** Supply configuration update enable
  */
  HAL_PWREx_ConfigSupply(PWR_LDO_SUPPLY);
24011e26:	2002      	movs	r0, #2
24011e28:	f7f6 f92e 	bl	24008088 <HAL_PWREx_ConfigSupply>

  /** Configure the main internal regulator output voltage
  */
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE0);
24011e2c:	2300      	movs	r3, #0
24011e2e:	9301      	str	r3, [sp, #4]
24011e30:	4b29      	ldr	r3, [pc, #164]	@ (24011ed8 <SystemClock_Config+0xca>)
24011e32:	699a      	ldr	r2, [r3, #24]
24011e34:	f442 4240 	orr.w	r2, r2, #49152	@ 0xc000
24011e38:	619a      	str	r2, [r3, #24]
24011e3a:	699a      	ldr	r2, [r3, #24]
24011e3c:	f402 4240 	and.w	r2, r2, #49152	@ 0xc000
24011e40:	9201      	str	r2, [sp, #4]
24011e42:	4a26      	ldr	r2, [pc, #152]	@ (24011edc <SystemClock_Config+0xce>)
24011e44:	6ad1      	ldr	r1, [r2, #44]	@ 0x2c
24011e46:	f041 0101 	orr.w	r1, r1, #1
24011e4a:	62d1      	str	r1, [r2, #44]	@ 0x2c
24011e4c:	6ad2      	ldr	r2, [r2, #44]	@ 0x2c
24011e4e:	f002 0201 	and.w	r2, r2, #1
24011e52:	9201      	str	r2, [sp, #4]
24011e54:	9a01      	ldr	r2, [sp, #4]

  while (!__HAL_PWR_GET_FLAG(PWR_FLAG_VOSRDY)) {}
24011e56:	699a      	ldr	r2, [r3, #24]
24011e58:	0494      	lsls	r4, r2, #18
24011e5a:	d5fc      	bpl.n	24011e56 <SystemClock_Config+0x48>

  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
  RCC_OscInitStruct.HSEState       = RCC_HSE_ON;
24011e5c:	2001      	movs	r0, #1
24011e5e:	f44f 3380 	mov.w	r3, #65536	@ 0x10000
  RCC_OscInitStruct.PLL            = PLL1_conf;
24011e62:	4d1f      	ldr	r5, [pc, #124]	@ (24011ee0 <SystemClock_Config+0xd2>)
24011e64:	ac14      	add	r4, sp, #80	@ 0x50
  RCC_OscInitStruct.HSEState       = RCC_HSE_ON;
24011e66:	e9cd 030b 	strd	r0, r3, [sp, #44]	@ 0x2c
  RCC_OscInitStruct.PLL            = PLL1_conf;
24011e6a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
24011e6c:	c40f      	stmia	r4!, {r0, r1, r2, r3}
24011e6e:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
24011e70:	c40f      	stmia	r4!, {r0, r1, r2, r3}
24011e72:	e895 0003 	ldmia.w	r5, {r0, r1}
24011e76:	e884 0003 	stmia.w	r4, {r0, r1}

  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
24011e7a:	a80b      	add	r0, sp, #44	@ 0x2c
24011e7c:	f7f7 fb7e 	bl	2400957c <HAL_RCC_OscConfig>
24011e80:	b100      	cbz	r0, 24011e84 <SystemClock_Config+0x76>
24011e82:	e7fe      	b.n	24011e82 <SystemClock_Config+0x74>
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK   | RCC_CLOCKTYPE_SYSCLK
                              | RCC_CLOCKTYPE_PCLK1  | RCC_CLOCKTYPE_PCLK2
                              | RCC_CLOCKTYPE_D3PCLK1| RCC_CLOCKTYPE_D1PCLK1;

  RCC_ClkInitStruct.SYSCLKSource   = RCC_SYSCLKSOURCE_PLLCLK;
24011e84:	223f      	movs	r2, #63	@ 0x3f
24011e86:	2303      	movs	r3, #3
  RCC_ClkInitStruct.SYSCLKDivider  = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.AHBCLKDivider  = RCC_HCLK_DIV2;

  RCC_ClkInitStruct.APB3CLKDivider = RCC_APB3_DIV2;
24011e88:	2108      	movs	r1, #8
  RCC_ClkInitStruct.SYSCLKDivider  = RCC_SYSCLK_DIV1;
24011e8a:	9005      	str	r0, [sp, #20]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_APB1_DIV2;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_APB2_DIV2;
  RCC_ClkInitStruct.APB4CLKDivider = RCC_APB4_DIV2;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
24011e8c:	a803      	add	r0, sp, #12
  RCC_ClkInitStruct.SYSCLKSource   = RCC_SYSCLKSOURCE_PLLCLK;
24011e8e:	e9cd 2303 	strd	r2, r3, [sp, #12]
  RCC_ClkInitStruct.APB3CLKDivider = RCC_APB3_DIV2;
24011e92:	2340      	movs	r3, #64	@ 0x40
  RCC_ClkInitStruct.APB2CLKDivider = RCC_APB2_DIV2;
24011e94:	f44f 6280 	mov.w	r2, #1024	@ 0x400
  RCC_ClkInitStruct.APB3CLKDivider = RCC_APB3_DIV2;
24011e98:	e9cd 1306 	strd	r1, r3, [sp, #24]
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
24011e9c:	2102      	movs	r1, #2
  RCC_ClkInitStruct.APB1CLKDivider = RCC_APB1_DIV2;
24011e9e:	9308      	str	r3, [sp, #32]
  RCC_ClkInitStruct.APB4CLKDivider = RCC_APB4_DIV2;
24011ea0:	e9cd 2309 	strd	r2, r3, [sp, #36]	@ 0x24
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
24011ea4:	f7f7 feec 	bl	24009c80 <HAL_RCC_ClockConfig>
24011ea8:	b100      	cbz	r0, 24011eac <SystemClock_Config+0x9e>
24011eaa:	e7fe      	b.n	24011eaa <SystemClock_Config+0x9c>
  {
    Error_Handler();
  }

  /*activate CSI clock mondatory for I/O Compensation Cell*/
  __HAL_RCC_CSI_ENABLE() ;
24011eac:	4b0d      	ldr	r3, [pc, #52]	@ (24011ee4 <SystemClock_Config+0xd6>)
24011eae:	681a      	ldr	r2, [r3, #0]
24011eb0:	f042 0280 	orr.w	r2, r2, #128	@ 0x80
24011eb4:	601a      	str	r2, [r3, #0]

  /* Enable SYSCFG clock mondatory for I/O Compensation Cell */
  __HAL_RCC_SYSCFG_CLK_ENABLE() ;
24011eb6:	f8d3 20f4 	ldr.w	r2, [r3, #244]	@ 0xf4
24011eba:	f042 0202 	orr.w	r2, r2, #2
24011ebe:	f8c3 20f4 	str.w	r2, [r3, #244]	@ 0xf4
24011ec2:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
24011ec6:	f003 0302 	and.w	r3, r3, #2
24011eca:	9302      	str	r3, [sp, #8]
24011ecc:	9b02      	ldr	r3, [sp, #8]

  /* Enables the I/O Compensation Cell */
  HAL_EnableCompensationCell();
24011ece:	f7ee fe0d 	bl	24000aec <HAL_EnableCompensationCell>
}
24011ed2:	b01f      	add	sp, #124	@ 0x7c
24011ed4:	bd30      	pop	{r4, r5, pc}
24011ed6:	bf00      	nop
24011ed8:	58024800 	.word	0x58024800
24011edc:	58000400 	.word	0x58000400
24011ee0:	240004a8 	.word	0x240004a8
24011ee4:	58024400 	.word	0x58024400

24011ee8 <Error_Handler>:
void Error_Handler(void)
{
    while(1)
    {
        //HAL_GPIO_TogglePin(LED_STATUS_GPIO_Port, LED_STATUS_Pin);
        HAL_Delay(500);
24011ee8:	e7fe      	b.n	24011ee8 <Error_Handler>

24011eea <Read>:
    }
}

int Read(uint32_t Address, uint32_t Size, uint16_t* buffer)
{
24011eea:	b508      	push	{r3, lr}
24011eec:	4613      	mov	r3, r2
  uint32_t ret = LOADER_OK;

  if (IS25LP128D_read(Address & 0x00FFFFFF, (uint8_t *)buffer, Size))
24011eee:	f020 407f 	bic.w	r0, r0, #4278190080	@ 0xff000000
24011ef2:	460a      	mov	r2, r1
24011ef4:	4619      	mov	r1, r3
24011ef6:	f000 faf3 	bl	240124e0 <IS25LP128D_read>
    ret = LOADER_FAIL;

  return ret;
}
24011efa:	fab0 f080 	clz	r0, r0
24011efe:	0940      	lsrs	r0, r0, #5
24011f00:	bd08      	pop	{r3, pc}

24011f02 <Write>:

int Write(uint32_t Address, uint32_t Size, uint8_t* buffer)
{
24011f02:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
24011f06:	4606      	mov	r6, r0
24011f08:	460d      	mov	r5, r1
24011f0a:	4617      	mov	r7, r2
  uint32_t ret = LOADER_OK;

  uint8_t *ptr = buffer;
  uint32_t written = 0;
24011f0c:	2400      	movs	r4, #0
  uint32_t page_size = 0x100;

  //printf("addr = 0x%08X, size = %d\r\n", Address, Size);

  while (Size > written)
24011f0e:	42ac      	cmp	r4, r5
24011f10:	eb07 0104 	add.w	r1, r7, r4
24011f14:	eb04 0806 	add.w	r8, r4, r6
24011f18:	d301      	bcc.n	24011f1e <Write+0x1c>
  uint32_t ret = LOADER_OK;
24011f1a:	2001      	movs	r0, #1
24011f1c:	e00b      	b.n	24011f36 <Write+0x34>
  {
    if (IS25LP128D_program_page(Address & 0x00FFFFFF, ptr, page_size))
24011f1e:	f44f 7280 	mov.w	r2, #256	@ 0x100
24011f22:	f028 407f 	bic.w	r0, r8, #4278190080	@ 0xff000000
24011f26:	f000 fa8b 	bl	24012440 <IS25LP128D_program_page>
24011f2a:	b130      	cbz	r0, 24011f3a <Write+0x38>
    {
      printf("fail: Write: address = 0x%80X\r\n", Address);
24011f2c:	4641      	mov	r1, r8
24011f2e:	4804      	ldr	r0, [pc, #16]	@ (24011f40 <Write+0x3e>)
24011f30:	f000 fe3e 	bl	24012bb0 <iprintf>
      ret = LOADER_FAIL;
24011f34:	2000      	movs	r0, #0
    ptr     += page_size;
    written += page_size;
  }

  return ret;
}
24011f36:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    written += page_size;
24011f3a:	f504 7480 	add.w	r4, r4, #256	@ 0x100
24011f3e:	e7e6      	b.n	24011f0e <Write+0xc>
24011f40:	2401420a 	.word	0x2401420a

24011f44 <SectorErase>:

int SectorErase(uint32_t EraseStartAddress, uint32_t EraseEndAddress)
{
24011f44:	b538      	push	{r3, r4, r5, lr}
24011f46:	4604      	mov	r4, r0
24011f48:	460d      	mov	r5, r1
  uint32_t ret     = LOADER_OK;
  uint32_t address = EraseStartAddress;

  while (1)
  {
    if (IS25LP128D_erase_sector(address & 0x00FFFFFF))
24011f4a:	f024 407f 	bic.w	r0, r4, #4278190080	@ 0xff000000
24011f4e:	f000 fa11 	bl	24012374 <IS25LP128D_erase_sector>
24011f52:	b928      	cbnz	r0, 24011f60 <SectorErase+0x1c>
    {
      ret = LOADER_FAIL;
      break;
    }

    address += 4096; // 4 kB sector size
24011f54:	f504 5480 	add.w	r4, r4, #4096	@ 0x1000
    if (address > EraseEndAddress)
24011f58:	42ac      	cmp	r4, r5
24011f5a:	d9f6      	bls.n	24011f4a <SectorErase+0x6>
  uint32_t ret     = LOADER_OK;
24011f5c:	2001      	movs	r0, #1
      break;
  }

  return ret;
}
24011f5e:	bd38      	pop	{r3, r4, r5, pc}
      ret = LOADER_FAIL;
24011f60:	2000      	movs	r0, #0
24011f62:	e7fc      	b.n	24011f5e <SectorErase+0x1a>

24011f64 <CheckSum>:
}
#endif

#if VERIFY
uint32_t CheckSum(uint32_t StartAddress, uint32_t Size, uint32_t InitVal)
{
24011f64:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}

  int      cnt;
  uint32_t Val;

  StartAddress -= StartAddress % 4;
  Size += (Size % 4 == 0) ? 0 : 4 - (Size % 4);
24011f68:	f011 0703 	ands.w	r7, r1, #3
  uint8_t missalignementAddress = StartAddress % 4;
24011f6c:	f000 0903 	and.w	r9, r0, #3
  StartAddress -= StartAddress % 4;
24011f70:	f020 0003 	bic.w	r0, r0, #3
{
24011f74:	4614      	mov	r4, r2
  Size += (Size % 4 == 0) ? 0 : 4 - (Size % 4);
24011f76:	bf18      	it	ne
24011f78:	f1c7 0704 	rsbne	r7, r7, #4
  uint8_t missalignementSize    = Size ;
24011f7c:	b2cd      	uxtb	r5, r1

  for (cnt = 0; cnt < Size; cnt += 4)
24011f7e:	f04f 0800 	mov.w	r8, #0
  {
    IS25LP128D_read(StartAddress - StartAddresse, &Val, 4);
24011f82:	f100 46e0 	add.w	r6, r0, #1879048192	@ 0x70000000
  Size += (Size % 4 == 0) ? 0 : 4 - (Size % 4);
24011f86:	440f      	add	r7, r1
  for (cnt = 0; cnt < Size; cnt += 4)
24011f88:	45b8      	cmp	r8, r7
24011f8a:	d303      	bcc.n	24011f94 <CheckSum+0x30>
    }
    StartAddress += 4;
  }

  return (InitVal);
}
24011f8c:	4620      	mov	r0, r4
24011f8e:	b003      	add	sp, #12
24011f90:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    IS25LP128D_read(StartAddress - StartAddresse, &Val, 4);
24011f94:	2204      	movs	r2, #4
24011f96:	eb06 0008 	add.w	r0, r6, r8
24011f9a:	eb0d 0102 	add.w	r1, sp, r2
24011f9e:	f000 fa9f 	bl	240124e0 <IS25LP128D_read>
    if (missalignementAddress)
24011fa2:	f1b9 0f00 	cmp.w	r9, #0
24011fa6:	d019      	beq.n	24011fdc <CheckSum+0x78>
        InitVal += (uint8_t) (Val >> 8 & 0xff);
24011fa8:	9b01      	ldr	r3, [sp, #4]
      switch (missalignementAddress)
24011faa:	f1b9 0f02 	cmp.w	r9, #2
        InitVal += (uint8_t) (Val >> 24 & 0xff);
24011fae:	ea4f 6113 	mov.w	r1, r3, lsr #24
      switch (missalignementAddress)
24011fb2:	d00a      	beq.n	24011fca <CheckSum+0x66>
24011fb4:	f1b9 0f03 	cmp.w	r9, #3
24011fb8:	d00a      	beq.n	24011fd0 <CheckSum+0x6c>
        InitVal += (uint8_t) (Val >> 24 & 0xff);
24011fba:	f3c3 2207 	ubfx	r2, r3, #8, #8
24011fbe:	f3c3 4307 	ubfx	r3, r3, #16, #8
24011fc2:	4413      	add	r3, r2
        InitVal += (uint8_t) (Val >> 24 & 0xff);
24011fc4:	440b      	add	r3, r1
      InitVal += (uint8_t)(Val >> 24 & 0xff);
24011fc6:	441c      	add	r4, r3
24011fc8:	e003      	b.n	24011fd2 <CheckSum+0x6e>
        InitVal += (uint8_t) (Val >> 24 & 0xff);
24011fca:	f3c3 4307 	ubfx	r3, r3, #16, #8
24011fce:	e7f9      	b.n	24011fc4 <CheckSum+0x60>
        InitVal += (uint8_t) (Val >> 24 & 0xff);
24011fd0:	440c      	add	r4, r1
  for (cnt = 0; cnt < Size; cnt += 4)
24011fd2:	f108 0804 	add.w	r8, r8, #4
24011fd6:	f04f 0900 	mov.w	r9, #0
24011fda:	e7d5      	b.n	24011f88 <CheckSum+0x24>
    else if ((Size-missalignementSize) % 4 && (Size-cnt) <= 4)
24011fdc:	1b7b      	subs	r3, r7, r5
24011fde:	079a      	lsls	r2, r3, #30
24011fe0:	d022      	beq.n	24012028 <CheckSum+0xc4>
24011fe2:	eba7 0208 	sub.w	r2, r7, r8
24011fe6:	2a04      	cmp	r2, #4
24011fe8:	d81e      	bhi.n	24012028 <CheckSum+0xc4>
      switch (Size-missalignementSize)
24011fea:	2b02      	cmp	r3, #2
24011fec:	d00f      	beq.n	2401200e <CheckSum+0xaa>
24011fee:	2b03      	cmp	r3, #3
24011ff0:	d015      	beq.n	2401201e <CheckSum+0xba>
24011ff2:	2b01      	cmp	r3, #1
24011ff4:	d1ed      	bne.n	24011fd2 <CheckSum+0x6e>
        InitVal += (uint8_t)  Val;
24011ff6:	9b01      	ldr	r3, [sp, #4]
        missalignementSize -= 1;
24011ff8:	3d01      	subs	r5, #1
        InitVal += (uint8_t) (Val >> 16 & 0xff);
24011ffa:	f3c3 2207 	ubfx	r2, r3, #8, #8
24011ffe:	f3c3 4107 	ubfx	r1, r3, #16, #8
24012002:	440a      	add	r2, r1
24012004:	fa52 f383 	uxtab	r3, r2, r3
24012008:	441c      	add	r4, r3
        missalignementSize -= 3;
2401200a:	b2ed      	uxtb	r5, r5
        break;
2401200c:	e7e1      	b.n	24011fd2 <CheckSum+0x6e>
        InitVal += (uint8_t)  Val;
2401200e:	9b01      	ldr	r3, [sp, #4]
        missalignementSize -= 2;
24012010:	3d02      	subs	r5, #2
        InitVal += (uint8_t) (Val >> 8 & 0xff);
24012012:	f3c3 2207 	ubfx	r2, r3, #8, #8
24012016:	fa52 f383 	uxtab	r3, r2, r3
2401201a:	441c      	add	r4, r3
        missalignementSize -= 2;
2401201c:	e7f5      	b.n	2401200a <CheckSum+0xa6>
        InitVal += (uint8_t) Val;
2401201e:	f89d 3004 	ldrb.w	r3, [sp, #4]
        missalignementSize -= 3;
24012022:	3d03      	subs	r5, #3
        InitVal += (uint8_t) Val;
24012024:	441c      	add	r4, r3
        missalignementSize -= 3;
24012026:	e7f0      	b.n	2401200a <CheckSum+0xa6>
      InitVal += (uint8_t) Val;
24012028:	9a01      	ldr	r2, [sp, #4]
      InitVal += (uint8_t)(Val >> 24 & 0xff);
2401202a:	b2d3      	uxtb	r3, r2
2401202c:	f3c2 2107 	ubfx	r1, r2, #8, #8
24012030:	eb03 6312 	add.w	r3, r3, r2, lsr #24
24012034:	f3c2 4207 	ubfx	r2, r2, #16, #8
24012038:	440b      	add	r3, r1
2401203a:	4413      	add	r3, r2
2401203c:	e7c3      	b.n	24011fc6 <CheckSum+0x62>

2401203e <Verify>:

uint64_t Verify (uint32_t MemoryAddr, uint32_t RAMBufferAddr, uint32_t Size, uint32_t missalignement)
{
2401203e:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
24012042:	4604      	mov	r4, r0
  uint32_t InitVal = 0;
  uint32_t InternalAddr = MemoryAddr - StartAddresse;
24012044:	f100 49e0 	add.w	r9, r0, #1879048192	@ 0x70000000
  uint32_t VerifiedData = 0;
  uint16_t TmpBuffer = 0x0000;
24012048:	2500      	movs	r5, #0
  uint64_t checksum;

  Size *= 4;

  checksum = CheckSum((uint32_t)MemoryAddr + (missalignement & 0xf),
                      Size - ((missalignement >> 16) & 0xF),
2401204a:	f3c3 4003 	ubfx	r0, r3, #16, #4
{
2401204e:	4688      	mov	r8, r1
  checksum = CheckSum((uint32_t)MemoryAddr + (missalignement & 0xf),
24012050:	f003 030f 	and.w	r3, r3, #15
{
24012054:	4611      	mov	r1, r2
  Size *= 4;
24012056:	ea4f 0a82 	mov.w	sl, r2, lsl #2
  checksum = CheckSum((uint32_t)MemoryAddr + (missalignement & 0xf),
2401205a:	462a      	mov	r2, r5
  uint16_t TmpBuffer = 0x0000;
2401205c:	f8ad 5006 	strh.w	r5, [sp, #6]
  checksum = CheckSum((uint32_t)MemoryAddr + (missalignement & 0xf),
24012060:	ebc0 0181 	rsb	r1, r0, r1, lsl #2
24012064:	1918      	adds	r0, r3, r4
24012066:	f7ff ff7d 	bl	24011f64 <CheckSum>
                      InitVal);

  if (InternalAddr % 2 != 0)
2401206a:	f019 0701 	ands.w	r7, r9, #1
  checksum = CheckSum((uint32_t)MemoryAddr + (missalignement & 0xf),
2401206e:	4606      	mov	r6, r0
  if (InternalAddr % 2 != 0)
24012070:	d118      	bne.n	240120a4 <Verify+0x66>
24012072:	eb07 0508 	add.w	r5, r7, r8
      return ((checksum << 32) + MemoryAddr);

    VerifiedData++;
  }

  while ((Size - VerifiedData) > 1)
24012076:	ebaa 0307 	sub.w	r3, sl, r7
2401207a:	2b01      	cmp	r3, #1
2401207c:	d826      	bhi.n	240120cc <Verify+0x8e>
      return ((checksum << 32) + MemoryAddr + VerifiedData);

    VerifiedData++;
  }

  if ((Size - VerifiedData) != 0)
2401207e:	4557      	cmp	r7, sl
      return ((checksum << 32) + MemoryAddr + VerifiedData);
24012080:	f04f 0500 	mov.w	r5, #0
  if ((Size - VerifiedData) != 0)
24012084:	d01d      	beq.n	240120c2 <Verify+0x84>
  {
    IS25LP128D_read(InternalAddr + VerifiedData, &TmpBuffer, 2);
24012086:	2202      	movs	r2, #2
24012088:	f10d 0106 	add.w	r1, sp, #6
2401208c:	eb07 0009 	add.w	r0, r7, r9
24012090:	f000 fa26 	bl	240124e0 <IS25LP128D_read>

    if ((uint8_t)(TmpBuffer & 0x00FF) != (*((uint8_t*)RAMBufferAddr + VerifiedData)))
24012094:	f817 2008 	ldrb.w	r2, [r7, r8]
24012098:	f89d 3006 	ldrb.w	r3, [sp, #6]
2401209c:	429a      	cmp	r2, r3
2401209e:	d010      	beq.n	240120c2 <Verify+0x84>
      return ((checksum << 32) + MemoryAddr + VerifiedData);
240120a0:	1964      	adds	r4, r4, r5
240120a2:	e021      	b.n	240120e8 <Verify+0xaa>
    IS25LP128D_read((InternalAddr - InternalAddr % 2), &TmpBuffer, 2);
240120a4:	2202      	movs	r2, #2
240120a6:	f10d 0106 	add.w	r1, sp, #6
240120aa:	f029 0001 	bic.w	r0, r9, #1
240120ae:	f000 fa17 	bl	240124e0 <IS25LP128D_read>
    if ((uint8_t)(TmpBuffer >> 8) != (*(uint8_t*)RAMBufferAddr))
240120b2:	f8bd 2006 	ldrh.w	r2, [sp, #6]
240120b6:	f898 3000 	ldrb.w	r3, [r8]
240120ba:	ebb3 2f12 	cmp.w	r3, r2, lsr #8
240120be:	d0d8      	beq.n	24012072 <Verify+0x34>
      return ((checksum << 32) + MemoryAddr);
240120c0:	192d      	adds	r5, r5, r4
  }

  return (checksum << 32);
}
240120c2:	4628      	mov	r0, r5
240120c4:	4631      	mov	r1, r6
240120c6:	b002      	add	sp, #8
240120c8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    IS25LP128D_read(InternalAddr + VerifiedData, &TmpBuffer, 2);
240120cc:	2202      	movs	r2, #2
240120ce:	f10d 0106 	add.w	r1, sp, #6
240120d2:	eb07 0009 	add.w	r0, r7, r9
240120d6:	f000 fa03 	bl	240124e0 <IS25LP128D_read>
    if ((TmpBuffer & 0x00FF) != (*((uint8_t*)RAMBufferAddr + VerifiedData)))
240120da:	7829      	ldrb	r1, [r5, #0]
240120dc:	f89d 3006 	ldrb.w	r3, [sp, #6]
240120e0:	f8bd 2006 	ldrh.w	r2, [sp, #6]
240120e4:	4299      	cmp	r1, r3
240120e6:	d001      	beq.n	240120ec <Verify+0xae>
      return ((checksum << 32) + MemoryAddr + VerifiedData);
240120e8:	19e5      	adds	r5, r4, r7
240120ea:	e006      	b.n	240120fa <Verify+0xbc>
    if ((uint8_t)(TmpBuffer >> 8) != (*((uint8_t *)RAMBufferAddr+VerifiedData)))
240120ec:	786b      	ldrb	r3, [r5, #1]
240120ee:	3502      	adds	r5, #2
240120f0:	ebb3 2f12 	cmp.w	r3, r2, lsr #8
240120f4:	d004      	beq.n	24012100 <Verify+0xc2>
    VerifiedData++;
240120f6:	1c7d      	adds	r5, r7, #1
      return ((checksum << 32) + MemoryAddr + VerifiedData);
240120f8:	1965      	adds	r5, r4, r5
      return ((checksum << 32) + MemoryAddr + VerifiedData);
240120fa:	f146 0600 	adc.w	r6, r6, #0
240120fe:	e7e0      	b.n	240120c2 <Verify+0x84>
    VerifiedData++;
24012100:	3702      	adds	r7, #2
24012102:	e7b8      	b.n	24012076 <Verify+0x38>

24012104 <Init>:
#endif


int Init(void)
{
24012104:	b508      	push	{r3, lr}
  *(uint32_t*)0xE000EDF0 = 0xA05F0000; //enable interrupts in debug
24012106:	4a0e      	ldr	r2, [pc, #56]	@ (24012140 <Init+0x3c>)
24012108:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
2401210c:	f8c3 2df0 	str.w	r2, [r3, #3568]	@ 0xdf0

  SystemInit();
24012110:	f000 fb38 	bl	24012784 <SystemInit>
   * change VTOR setting for other devices
   * SCB->VTOR = 0x20000000 | 0x200;
   *
   * */

  SCB->VTOR = 0x24000000 | 0x200;
24012114:	4b0b      	ldr	r3, [pc, #44]	@ (24012144 <Init+0x40>)
24012116:	4a0c      	ldr	r2, [pc, #48]	@ (24012148 <Init+0x44>)
24012118:	609a      	str	r2, [r3, #8]

  HAL_Init();
2401211a:	f7ee fbcf 	bl	240008bc <HAL_Init>

  SystemClock_Config();
2401211e:	f7ff fe76 	bl	24011e0e <SystemClock_Config>

  MX_USART1_Init();
24012122:	f000 fc7d 	bl	24012a20 <MX_USART1_Init>

  __HAL_RCC_QSPI_FORCE_RESET();  //completely reset peripheral
24012126:	4b09      	ldr	r3, [pc, #36]	@ (2401214c <Init+0x48>)
24012128:	6fda      	ldr	r2, [r3, #124]	@ 0x7c
2401212a:	f442 4280 	orr.w	r2, r2, #16384	@ 0x4000
2401212e:	67da      	str	r2, [r3, #124]	@ 0x7c
  __HAL_RCC_QSPI_RELEASE_RESET();
24012130:	6fda      	ldr	r2, [r3, #124]	@ 0x7c
24012132:	f422 4280 	bic.w	r2, r2, #16384	@ 0x4000
24012136:	67da      	str	r2, [r3, #124]	@ 0x7c

  MX_QSPI_Init();
24012138:	f000 fa1e 	bl	24012578 <MX_QSPI_Init>

  return LOADER_OK;
}
2401213c:	2001      	movs	r0, #1
2401213e:	bd08      	pop	{r3, pc}
24012140:	a05f0000 	.word	0xa05f0000
24012144:	e000ed00 	.word	0xe000ed00
24012148:	24000200 	.word	0x24000200
2401214c:	58024400 	.word	0x58024400

24012150 <check_WIP>:

  return data;
}

static void check_WIP()
{
24012150:	b537      	push	{r0, r1, r2, r4, r5, lr}
  cmd.InstructionMode = qspi_mode ? QSPI_INSTRUCTION_4_LINES : QSPI_INSTRUCTION_1_LINE;
24012152:	4c1d      	ldr	r4, [pc, #116]	@ (240121c8 <check_WIP+0x78>)
  cmd.Instruction     = 0x05;
24012154:	2505      	movs	r5, #5
  cmd.InstructionMode = qspi_mode ? QSPI_INSTRUCTION_4_LINES : QSPI_INSTRUCTION_1_LINE;
24012156:	6823      	ldr	r3, [r4, #0]
  if (HAL_OK != HAL_QSPI_Command(&hqspi, &cmd, HAL_QPSI_TIMEOUT_DEFAULT_VALUE))
24012158:	f241 3288 	movw	r2, #5000	@ 0x1388
2401215c:	491b      	ldr	r1, [pc, #108]	@ (240121cc <check_WIP+0x7c>)
  cmd.InstructionMode = qspi_mode ? QSPI_INSTRUCTION_4_LINES : QSPI_INSTRUCTION_1_LINE;
2401215e:	2b00      	cmp	r3, #0
  cmd.Instruction     = 0x05;
24012160:	6065      	str	r5, [r4, #4]
  if (HAL_OK != HAL_QSPI_Command(&hqspi, &cmd, HAL_QPSI_TIMEOUT_DEFAULT_VALUE))
24012162:	f101 0038 	add.w	r0, r1, #56	@ 0x38
  cmd.InstructionMode = qspi_mode ? QSPI_INSTRUCTION_4_LINES : QSPI_INSTRUCTION_1_LINE;
24012166:	bf14      	ite	ne
24012168:	f44f 7340 	movne.w	r3, #768	@ 0x300
2401216c:	f44f 7380 	moveq.w	r3, #256	@ 0x100
24012170:	61e3      	str	r3, [r4, #28]
  cmd.AddressMode     = QSPI_ADDRESS_NONE;
24012172:	f04f 0300 	mov.w	r3, #0
24012176:	6223      	str	r3, [r4, #32]
  cmd.DataMode        = qspi_mode ? QSPI_DATA_4_LINES : QSPI_DATA_1_LINE;
24012178:	bf0c      	ite	eq
2401217a:	f04f 7380 	moveq.w	r3, #16777216	@ 0x1000000
2401217e:	f04f 7340 	movne.w	r3, #50331648	@ 0x3000000
24012182:	62a3      	str	r3, [r4, #40]	@ 0x28
  cmd.NbData          = 1;
24012184:	2301      	movs	r3, #1
24012186:	62e3      	str	r3, [r4, #44]	@ 0x2c
  if (HAL_OK != HAL_QSPI_Command(&hqspi, &cmd, HAL_QPSI_TIMEOUT_DEFAULT_VALUE))
24012188:	f7f6 fba2 	bl	240088d0 <HAL_QSPI_Command>
2401218c:	b120      	cbz	r0, 24012198 <check_WIP+0x48>
    printf("fail: qspi read status register: HAL_QSPI_Command\r\n");
2401218e:	4810      	ldr	r0, [pc, #64]	@ (240121d0 <check_WIP+0x80>)
24012190:	f000 fd76 	bl	24012c80 <puts>
    Error_Handler();
24012194:	f7ff fea8 	bl	24011ee8 <Error_Handler>
  if (HAL_OK != HAL_QSPI_Receive(&hqspi, &data, HAL_QPSI_TIMEOUT_DEFAULT_VALUE))
24012198:	f241 3288 	movw	r2, #5000	@ 0x1388
2401219c:	f10d 0107 	add.w	r1, sp, #7
240121a0:	480c      	ldr	r0, [pc, #48]	@ (240121d4 <check_WIP+0x84>)
240121a2:	f7f6 fc78 	bl	24008a96 <HAL_QSPI_Receive>
240121a6:	b120      	cbz	r0, 240121b2 <check_WIP+0x62>
    printf("fail: qspi read status register: HAL_QSPI_Receive\r\n");
240121a8:	480b      	ldr	r0, [pc, #44]	@ (240121d8 <check_WIP+0x88>)
240121aa:	f000 fd69 	bl	24012c80 <puts>
    Error_Handler();
240121ae:	f7ff fe9b 	bl	24011ee8 <Error_Handler>
  return data;
240121b2:	f89d 3007 	ldrb.w	r3, [sp, #7]
  while (1)
  {
    if (read_status_register() & 0x01)
240121b6:	07db      	lsls	r3, r3, #31
240121b8:	d503      	bpl.n	240121c2 <check_WIP+0x72>
      HAL_Delay(5);
240121ba:	2005      	movs	r0, #5
240121bc:	f7ff fe26 	bl	24011e0c <HAL_Delay>
    if (read_status_register() & 0x01)
240121c0:	e7c9      	b.n	24012156 <check_WIP+0x6>
    else
      break;
  }
}
240121c2:	b003      	add	sp, #12
240121c4:	bd30      	pop	{r4, r5, pc}
240121c6:	bf00      	nop
240121c8:	24000598 	.word	0x24000598
240121cc:	2400059c 	.word	0x2400059c
240121d0:	2401422a 	.word	0x2401422a
240121d4:	240005d4 	.word	0x240005d4
240121d8:	2401425d 	.word	0x2401425d

240121dc <write_enable>:
  cmd.InstructionMode = qspi_mode ? QSPI_INSTRUCTION_4_LINES : QSPI_INSTRUCTION_1_LINE;
240121dc:	480f      	ldr	r0, [pc, #60]	@ (2401221c <write_enable+0x40>)
  if (HAL_QSPI_Command(&hqspi, &cmd, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
240121de:	f241 3288 	movw	r2, #5000	@ 0x1388
{
240121e2:	b508      	push	{r3, lr}
  cmd.InstructionMode = qspi_mode ? QSPI_INSTRUCTION_4_LINES : QSPI_INSTRUCTION_1_LINE;
240121e4:	6803      	ldr	r3, [r0, #0]
  if (HAL_QSPI_Command(&hqspi, &cmd, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
240121e6:	1d01      	adds	r1, r0, #4
240121e8:	303c      	adds	r0, #60	@ 0x3c
  cmd.InstructionMode = qspi_mode ? QSPI_INSTRUCTION_4_LINES : QSPI_INSTRUCTION_1_LINE;
240121ea:	2b00      	cmp	r3, #0
240121ec:	bf0c      	ite	eq
240121ee:	f44f 7380 	moveq.w	r3, #256	@ 0x100
240121f2:	f44f 7340 	movne.w	r3, #768	@ 0x300
240121f6:	f840 3c20 	str.w	r3, [r0, #-32]
  cmd.Instruction     = 0x06; // write enable
240121fa:	2306      	movs	r3, #6
240121fc:	f840 3c38 	str.w	r3, [r0, #-56]
  cmd.AddressMode     = QSPI_ADDRESS_NONE;
24012200:	2300      	movs	r3, #0
24012202:	f840 3c1c 	str.w	r3, [r0, #-28]
  cmd.DataMode        = QSPI_DATA_NONE;
24012206:	f840 3c14 	str.w	r3, [r0, #-20]
  if (HAL_QSPI_Command(&hqspi, &cmd, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
2401220a:	f7f6 fb61 	bl	240088d0 <HAL_QSPI_Command>
2401220e:	b120      	cbz	r0, 2401221a <write_enable+0x3e>
    printf("qspi write enable fail\r\n");
24012210:	4803      	ldr	r0, [pc, #12]	@ (24012220 <write_enable+0x44>)
}
24012212:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    printf("qspi write enable fail\r\n");
24012216:	f000 bd33 	b.w	24012c80 <puts>
}
2401221a:	bd08      	pop	{r3, pc}
2401221c:	24000598 	.word	0x24000598
24012220:	24014290 	.word	0x24014290

24012224 <HAL_QSPI_MspInit>:
{
24012224:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
24012228:	b0b8      	sub	sp, #224	@ 0xe0
2401222a:	4604      	mov	r4, r0
  GPIO_InitTypeDef GPIO_InitStruct = {0};
2401222c:	2214      	movs	r2, #20
2401222e:	2100      	movs	r1, #0
24012230:	a804      	add	r0, sp, #16
24012232:	f000 fdc9 	bl	24012dc8 <memset>
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
24012236:	22bc      	movs	r2, #188	@ 0xbc
24012238:	2100      	movs	r1, #0
2401223a:	a809      	add	r0, sp, #36	@ 0x24
2401223c:	f000 fdc4 	bl	24012dc8 <memset>
  if(hqspi->Instance==QUADSPI)
24012240:	6822      	ldr	r2, [r4, #0]
24012242:	4b37      	ldr	r3, [pc, #220]	@ (24012320 <HAL_QSPI_MspInit+0xfc>)
24012244:	429a      	cmp	r2, r3
24012246:	d168      	bne.n	2401231a <HAL_QSPI_MspInit+0xf6>
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_QSPI;
24012248:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
    PeriphClkInitStruct.PLL2                 = PLL2_conf;
2401224c:	4d35      	ldr	r5, [pc, #212]	@ (24012324 <HAL_QSPI_MspInit+0x100>)
2401224e:	ac0a      	add	r4, sp, #40	@ 0x28
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_QSPI;
24012250:	9309      	str	r3, [sp, #36]	@ 0x24
    PeriphClkInitStruct.PLL2                 = PLL2_conf;
24012252:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
24012254:	c40f      	stmia	r4!, {r0, r1, r2, r3}
24012256:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
2401225a:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
    PeriphClkInitStruct.QspiClockSelection   = RCC_QSPICLKSOURCE_PLL2;
2401225e:	2320      	movs	r3, #32
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
24012260:	a809      	add	r0, sp, #36	@ 0x24
    PeriphClkInitStruct.QspiClockSelection   = RCC_QSPICLKSOURCE_PLL2;
24012262:	931b      	str	r3, [sp, #108]	@ 0x6c
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
24012264:	f7f8 f816 	bl	2400a294 <HAL_RCCEx_PeriphCLKConfig>
24012268:	b108      	cbz	r0, 2401226e <HAL_QSPI_MspInit+0x4a>
      Error_Handler();
2401226a:	f7ff fe3d 	bl	24011ee8 <Error_Handler>
    __HAL_RCC_QSPI_CLK_ENABLE();
2401226e:	4b2e      	ldr	r3, [pc, #184]	@ (24012328 <HAL_QSPI_MspInit+0x104>)
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
24012270:	2602      	movs	r6, #2
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
24012272:	2500      	movs	r5, #0
24012274:	2403      	movs	r4, #3
    __HAL_RCC_QSPI_CLK_ENABLE();
24012276:	f8d3 20d4 	ldr.w	r2, [r3, #212]	@ 0xd4
    GPIO_InitStruct.Alternate = GPIO_AF10_QUADSPI;
2401227a:	f04f 080a 	mov.w	r8, #10
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
2401227e:	a904      	add	r1, sp, #16
24012280:	482a      	ldr	r0, [pc, #168]	@ (2401232c <HAL_QSPI_MspInit+0x108>)
    __HAL_RCC_QSPI_CLK_ENABLE();
24012282:	f442 4280 	orr.w	r2, r2, #16384	@ 0x4000
    GPIO_InitStruct.Alternate = GPIO_AF9_QUADSPI;
24012286:	2709      	movs	r7, #9
    __HAL_RCC_QSPI_CLK_ENABLE();
24012288:	f8c3 20d4 	str.w	r2, [r3, #212]	@ 0xd4
2401228c:	f8d3 20d4 	ldr.w	r2, [r3, #212]	@ 0xd4
24012290:	f402 4280 	and.w	r2, r2, #16384	@ 0x4000
24012294:	9201      	str	r2, [sp, #4]
24012296:	9a01      	ldr	r2, [sp, #4]
    __HAL_RCC_GPIOB_CLK_ENABLE();
24012298:	f8d3 20e0 	ldr.w	r2, [r3, #224]	@ 0xe0
2401229c:	f042 0202 	orr.w	r2, r2, #2
240122a0:	f8c3 20e0 	str.w	r2, [r3, #224]	@ 0xe0
240122a4:	f8d3 20e0 	ldr.w	r2, [r3, #224]	@ 0xe0
240122a8:	f002 0202 	and.w	r2, r2, #2
240122ac:	9202      	str	r2, [sp, #8]
240122ae:	9a02      	ldr	r2, [sp, #8]
    __HAL_RCC_GPIOF_CLK_ENABLE();
240122b0:	f8d3 20e0 	ldr.w	r2, [r3, #224]	@ 0xe0
240122b4:	f042 0220 	orr.w	r2, r2, #32
240122b8:	f8c3 20e0 	str.w	r2, [r3, #224]	@ 0xe0
240122bc:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
    GPIO_InitStruct.Alternate = GPIO_AF10_QUADSPI;
240122c0:	f8cd 8020 	str.w	r8, [sp, #32]
    __HAL_RCC_GPIOF_CLK_ENABLE();
240122c4:	f003 0320 	and.w	r3, r3, #32
240122c8:	9303      	str	r3, [sp, #12]
240122ca:	9b03      	ldr	r3, [sp, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
240122cc:	2340      	movs	r3, #64	@ 0x40
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
240122ce:	e9cd 5406 	strd	r5, r4, [sp, #24]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
240122d2:	e9cd 3604 	strd	r3, r6, [sp, #16]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
240122d6:	f7f1 ffdf 	bl	24004298 <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = GPIO_PIN_7|GPIO_PIN_6;
240122da:	23c0      	movs	r3, #192	@ 0xc0
    HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
240122dc:	a904      	add	r1, sp, #16
240122de:	4814      	ldr	r0, [pc, #80]	@ (24012330 <HAL_QSPI_MspInit+0x10c>)
    GPIO_InitStruct.Alternate = GPIO_AF9_QUADSPI;
240122e0:	9708      	str	r7, [sp, #32]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
240122e2:	e9cd 3604 	strd	r3, r6, [sp, #16]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
240122e6:	e9cd 5406 	strd	r5, r4, [sp, #24]
    HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
240122ea:	f7f1 ffd5 	bl	24004298 <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = GPIO_PIN_9|GPIO_PIN_8;
240122ee:	f44f 7340 	mov.w	r3, #768	@ 0x300
    HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
240122f2:	a904      	add	r1, sp, #16
240122f4:	480e      	ldr	r0, [pc, #56]	@ (24012330 <HAL_QSPI_MspInit+0x10c>)
    GPIO_InitStruct.Alternate = GPIO_AF10_QUADSPI;
240122f6:	f8cd 8020 	str.w	r8, [sp, #32]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
240122fa:	e9cd 3604 	strd	r3, r6, [sp, #16]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
240122fe:	e9cd 5406 	strd	r5, r4, [sp, #24]
    HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
24012302:	f7f1 ffc9 	bl	24004298 <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = GPIO_PIN_2;
24012306:	2304      	movs	r3, #4
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
24012308:	a904      	add	r1, sp, #16
2401230a:	4808      	ldr	r0, [pc, #32]	@ (2401232c <HAL_QSPI_MspInit+0x108>)
    GPIO_InitStruct.Alternate = GPIO_AF9_QUADSPI;
2401230c:	9708      	str	r7, [sp, #32]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
2401230e:	e9cd 3604 	strd	r3, r6, [sp, #16]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
24012312:	e9cd 5406 	strd	r5, r4, [sp, #24]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
24012316:	f7f1 ffbf 	bl	24004298 <HAL_GPIO_Init>
}
2401231a:	b038      	add	sp, #224	@ 0xe0
2401231c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
24012320:	52005000 	.word	0x52005000
24012324:	240004f0 	.word	0x240004f0
24012328:	58024400 	.word	0x58024400
2401232c:	58020400 	.word	0x58020400
24012330:	58021400 	.word	0x58021400

24012334 <HAL_QSPI_MspDeInit>:
  if(hqspi->Instance==QUADSPI)
24012334:	6802      	ldr	r2, [r0, #0]
{
24012336:	b508      	push	{r3, lr}
  if(hqspi->Instance==QUADSPI)
24012338:	4b0a      	ldr	r3, [pc, #40]	@ (24012364 <HAL_QSPI_MspDeInit+0x30>)
2401233a:	429a      	cmp	r2, r3
2401233c:	d111      	bne.n	24012362 <HAL_QSPI_MspDeInit+0x2e>
    __HAL_RCC_QSPI_CLK_DISABLE();
2401233e:	4a0a      	ldr	r2, [pc, #40]	@ (24012368 <HAL_QSPI_MspDeInit+0x34>)
    HAL_GPIO_DeInit(GPIOB, GPIO_PIN_6|GPIO_PIN_2);
24012340:	2144      	movs	r1, #68	@ 0x44
24012342:	480a      	ldr	r0, [pc, #40]	@ (2401236c <HAL_QSPI_MspDeInit+0x38>)
    __HAL_RCC_QSPI_CLK_DISABLE();
24012344:	f8d2 30d4 	ldr.w	r3, [r2, #212]	@ 0xd4
24012348:	f423 4380 	bic.w	r3, r3, #16384	@ 0x4000
2401234c:	f8c2 30d4 	str.w	r3, [r2, #212]	@ 0xd4
    HAL_GPIO_DeInit(GPIOB, GPIO_PIN_6|GPIO_PIN_2);
24012350:	f7f2 f884 	bl	2400445c <HAL_GPIO_DeInit>
    HAL_GPIO_DeInit(GPIOF, GPIO_PIN_7|GPIO_PIN_6|GPIO_PIN_9|GPIO_PIN_8);
24012354:	f44f 7170 	mov.w	r1, #960	@ 0x3c0
24012358:	4805      	ldr	r0, [pc, #20]	@ (24012370 <HAL_QSPI_MspDeInit+0x3c>)
}
2401235a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    HAL_GPIO_DeInit(GPIOF, GPIO_PIN_7|GPIO_PIN_6|GPIO_PIN_9|GPIO_PIN_8);
2401235e:	f7f2 b87d 	b.w	2400445c <HAL_GPIO_DeInit>
}
24012362:	bd08      	pop	{r3, pc}
24012364:	52005000 	.word	0x52005000
24012368:	58024400 	.word	0x58024400
2401236c:	58020400 	.word	0x58020400
24012370:	58021400 	.word	0x58021400

24012374 <IS25LP128D_erase_sector>:

uint32_t IS25LP128D_erase_sector(uint32_t address)
{
  if (address > 0x00FFFFFF)
24012374:	f1b0 7f80 	cmp.w	r0, #16777216	@ 0x1000000
{
24012378:	b510      	push	{r4, lr}
2401237a:	4604      	mov	r4, r0
  if (address > 0x00FFFFFF)
2401237c:	d304      	bcc.n	24012388 <IS25LP128D_erase_sector+0x14>
  {
    printf("address > 0x01FFFFFF !!!!");
2401237e:	4818      	ldr	r0, [pc, #96]	@ (240123e0 <IS25LP128D_erase_sector+0x6c>)
24012380:	f000 fc16 	bl	24012bb0 <iprintf>
    return 1;
24012384:	2001      	movs	r0, #1
  }

  check_WIP();

  return 0;
}
24012386:	bd10      	pop	{r4, pc}
  write_enable();
24012388:	f7ff ff28 	bl	240121dc <write_enable>
  cmd.InstructionMode = qspi_mode ? QSPI_INSTRUCTION_4_LINES : QSPI_INSTRUCTION_1_LINE;
2401238c:	4815      	ldr	r0, [pc, #84]	@ (240123e4 <IS25LP128D_erase_sector+0x70>)
2401238e:	6802      	ldr	r2, [r0, #0]
  if ( HAL_OK != HAL_QSPI_Command(&hqspi, &cmd, HAL_QPSI_TIMEOUT_DEFAULT_VALUE))
24012390:	1d01      	adds	r1, r0, #4
  cmd.Address         = address;
24012392:	6084      	str	r4, [r0, #8]
  if ( HAL_OK != HAL_QSPI_Command(&hqspi, &cmd, HAL_QPSI_TIMEOUT_DEFAULT_VALUE))
24012394:	303c      	adds	r0, #60	@ 0x3c
  cmd.InstructionMode = qspi_mode ? QSPI_INSTRUCTION_4_LINES : QSPI_INSTRUCTION_1_LINE;
24012396:	2a00      	cmp	r2, #0
24012398:	bf14      	ite	ne
2401239a:	f44f 7240 	movne.w	r2, #768	@ 0x300
2401239e:	f44f 7280 	moveq.w	r2, #256	@ 0x100
240123a2:	f840 2c20 	str.w	r2, [r0, #-32]
  cmd.Instruction     = 0xD7;
240123a6:	f04f 02d7 	mov.w	r2, #215	@ 0xd7
240123aa:	f840 2c38 	str.w	r2, [r0, #-56]
  cmd.AddressMode     = qspi_mode ? QSPI_ADDRESS_4_LINES : QSPI_ADDRESS_1_LINE;
240123ae:	bf0c      	ite	eq
240123b0:	f44f 6280 	moveq.w	r2, #1024	@ 0x400
240123b4:	f44f 6240 	movne.w	r2, #3072	@ 0xc00
240123b8:	f840 2c1c 	str.w	r2, [r0, #-28]
  cmd.DataMode        = QSPI_DATA_NONE;
240123bc:	2200      	movs	r2, #0
240123be:	f840 2c14 	str.w	r2, [r0, #-20]
  if ( HAL_OK != HAL_QSPI_Command(&hqspi, &cmd, HAL_QPSI_TIMEOUT_DEFAULT_VALUE))
240123c2:	f241 3288 	movw	r2, #5000	@ 0x1388
240123c6:	f7f6 fa83 	bl	240088d0 <HAL_QSPI_Command>
240123ca:	4604      	mov	r4, r0
240123cc:	b118      	cbz	r0, 240123d6 <IS25LP128D_erase_sector+0x62>
    printf("fail: qspi erase sector \r\n");
240123ce:	4806      	ldr	r0, [pc, #24]	@ (240123e8 <IS25LP128D_erase_sector+0x74>)
240123d0:	f000 fc56 	bl	24012c80 <puts>
    return 1;
240123d4:	e7d6      	b.n	24012384 <IS25LP128D_erase_sector+0x10>
  check_WIP();
240123d6:	f7ff febb 	bl	24012150 <check_WIP>
  return 0;
240123da:	4620      	mov	r0, r4
240123dc:	e7d3      	b.n	24012386 <IS25LP128D_erase_sector+0x12>
240123de:	bf00      	nop
240123e0:	240142a8 	.word	0x240142a8
240123e4:	24000598 	.word	0x24000598
240123e8:	240142c2 	.word	0x240142c2

240123ec <IS25LP128D_erase_chip>:

uint32_t IS25LP128D_erase_chip()
{
240123ec:	b510      	push	{r4, lr}
  write_enable();
240123ee:	f7ff fef5 	bl	240121dc <write_enable>

  cmd.InstructionMode = qspi_mode ? QSPI_INSTRUCTION_4_LINES : QSPI_INSTRUCTION_1_LINE;
240123f2:	4811      	ldr	r0, [pc, #68]	@ (24012438 <IS25LP128D_erase_chip+0x4c>)
  cmd.Instruction     = 0xC7;
  cmd.AddressMode     = QSPI_ADDRESS_NONE;
  cmd.DataMode        = QSPI_DATA_NONE;

  if ( HAL_OK != HAL_QSPI_Command(&hqspi, &cmd, HAL_QPSI_TIMEOUT_DEFAULT_VALUE))
240123f4:	f241 3288 	movw	r2, #5000	@ 0x1388
  cmd.InstructionMode = qspi_mode ? QSPI_INSTRUCTION_4_LINES : QSPI_INSTRUCTION_1_LINE;
240123f8:	6803      	ldr	r3, [r0, #0]
  if ( HAL_OK != HAL_QSPI_Command(&hqspi, &cmd, HAL_QPSI_TIMEOUT_DEFAULT_VALUE))
240123fa:	1d01      	adds	r1, r0, #4
240123fc:	303c      	adds	r0, #60	@ 0x3c
  cmd.InstructionMode = qspi_mode ? QSPI_INSTRUCTION_4_LINES : QSPI_INSTRUCTION_1_LINE;
240123fe:	2b00      	cmp	r3, #0
24012400:	bf0c      	ite	eq
24012402:	f44f 7380 	moveq.w	r3, #256	@ 0x100
24012406:	f44f 7340 	movne.w	r3, #768	@ 0x300
2401240a:	f840 3c20 	str.w	r3, [r0, #-32]
  cmd.Instruction     = 0xC7;
2401240e:	23c7      	movs	r3, #199	@ 0xc7
24012410:	f840 3c38 	str.w	r3, [r0, #-56]
  cmd.AddressMode     = QSPI_ADDRESS_NONE;
24012414:	2300      	movs	r3, #0
24012416:	f840 3c1c 	str.w	r3, [r0, #-28]
  cmd.DataMode        = QSPI_DATA_NONE;
2401241a:	f840 3c14 	str.w	r3, [r0, #-20]
  if ( HAL_OK != HAL_QSPI_Command(&hqspi, &cmd, HAL_QPSI_TIMEOUT_DEFAULT_VALUE))
2401241e:	f7f6 fa57 	bl	240088d0 <HAL_QSPI_Command>
24012422:	4604      	mov	r4, r0
24012424:	b120      	cbz	r0, 24012430 <IS25LP128D_erase_chip+0x44>
  {
    printf("fail: qspi erase chip\r\n");
24012426:	4805      	ldr	r0, [pc, #20]	@ (2401243c <IS25LP128D_erase_chip+0x50>)
24012428:	f000 fc2a 	bl	24012c80 <puts>
    return 1;
2401242c:	2001      	movs	r0, #1
  }

  check_WIP();

  return 0;
}
2401242e:	bd10      	pop	{r4, pc}
  check_WIP();
24012430:	f7ff fe8e 	bl	24012150 <check_WIP>
  return 0;
24012434:	4620      	mov	r0, r4
24012436:	e7fa      	b.n	2401242e <IS25LP128D_erase_chip+0x42>
24012438:	24000598 	.word	0x24000598
2401243c:	240142dc 	.word	0x240142dc

24012440 <IS25LP128D_program_page>:

uint32_t IS25LP128D_program_page(uint32_t address, uint8_t *data, uint32_t length)
{
24012440:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if (address > 0x00FFFF00 && length > 0xFF)
24012442:	4b23      	ldr	r3, [pc, #140]	@ (240124d0 <IS25LP128D_program_page+0x90>)
{
24012444:	4606      	mov	r6, r0
24012446:	460f      	mov	r7, r1
24012448:	4615      	mov	r5, r2
  if (address > 0x00FFFF00 && length > 0xFF)
2401244a:	4298      	cmp	r0, r3
2401244c:	d905      	bls.n	2401245a <IS25LP128D_program_page+0x1a>
2401244e:	2aff      	cmp	r2, #255	@ 0xff
24012450:	d903      	bls.n	2401245a <IS25LP128D_program_page+0x1a>
  {
    printf("address or length error\r\n");
24012452:	4820      	ldr	r0, [pc, #128]	@ (240124d4 <IS25LP128D_program_page+0x94>)
  cmd.NbData          = length;

  if (   HAL_OK != HAL_QSPI_Command(&hqspi, &cmd, HAL_QPSI_TIMEOUT_DEFAULT_VALUE)
      || HAL_OK != HAL_QSPI_Transmit(&hqspi, data, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) )
  {
    printf("fail: qspi program page\r\n");
24012454:	f000 fc14 	bl	24012c80 <puts>
    return 1;
24012458:	e005      	b.n	24012466 <IS25LP128D_program_page+0x26>
  if (HAL_QSPI_Abort(&hqspi) != HAL_OK)
2401245a:	4c1f      	ldr	r4, [pc, #124]	@ (240124d8 <IS25LP128D_program_page+0x98>)
2401245c:	f104 003c 	add.w	r0, r4, #60	@ 0x3c
24012460:	f7f6 fef1 	bl	24009246 <HAL_QSPI_Abort>
24012464:	b108      	cbz	r0, 2401246a <IS25LP128D_program_page+0x2a>
    return 1;
24012466:	2001      	movs	r0, #1
  }

  check_WIP();

  return 0;
}
24012468:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  write_enable();
2401246a:	f7ff feb7 	bl	240121dc <write_enable>
  cmd.InstructionMode = qspi_mode ? QSPI_INSTRUCTION_4_LINES : QSPI_INSTRUCTION_1_LINE;
2401246e:	6823      	ldr	r3, [r4, #0]
  if (   HAL_OK != HAL_QSPI_Command(&hqspi, &cmd, HAL_QPSI_TIMEOUT_DEFAULT_VALUE)
24012470:	f241 3288 	movw	r2, #5000	@ 0x1388
24012474:	1d21      	adds	r1, r4, #4
  cmd.InstructionMode = qspi_mode ? QSPI_INSTRUCTION_4_LINES : QSPI_INSTRUCTION_1_LINE;
24012476:	2b00      	cmp	r3, #0
  if (   HAL_OK != HAL_QSPI_Command(&hqspi, &cmd, HAL_QPSI_TIMEOUT_DEFAULT_VALUE)
24012478:	f104 003c 	add.w	r0, r4, #60	@ 0x3c
  cmd.Address         = address;
2401247c:	60a6      	str	r6, [r4, #8]
  cmd.InstructionMode = qspi_mode ? QSPI_INSTRUCTION_4_LINES : QSPI_INSTRUCTION_1_LINE;
2401247e:	bf14      	ite	ne
24012480:	f44f 7340 	movne.w	r3, #768	@ 0x300
24012484:	f44f 7380 	moveq.w	r3, #256	@ 0x100
24012488:	61e3      	str	r3, [r4, #28]
  cmd.Instruction     = 0x02;
2401248a:	f04f 0302 	mov.w	r3, #2
2401248e:	6063      	str	r3, [r4, #4]
  cmd.AddressMode     = qspi_mode ? QSPI_ADDRESS_4_LINES : QSPI_ADDRESS_1_LINE;
24012490:	bf14      	ite	ne
24012492:	f44f 6340 	movne.w	r3, #3072	@ 0xc00
24012496:	f44f 6380 	moveq.w	r3, #1024	@ 0x400
2401249a:	6223      	str	r3, [r4, #32]
  cmd.DataMode        = qspi_mode ? QSPI_DATA_4_LINES : QSPI_DATA_1_LINE;
2401249c:	bf0c      	ite	eq
2401249e:	f04f 7380 	moveq.w	r3, #16777216	@ 0x1000000
240124a2:	f04f 7340 	movne.w	r3, #50331648	@ 0x3000000
  cmd.NbData          = length;
240124a6:	e9c4 350a 	strd	r3, r5, [r4, #40]	@ 0x28
  if (   HAL_OK != HAL_QSPI_Command(&hqspi, &cmd, HAL_QPSI_TIMEOUT_DEFAULT_VALUE)
240124aa:	f7f6 fa11 	bl	240088d0 <HAL_QSPI_Command>
240124ae:	b108      	cbz	r0, 240124b4 <IS25LP128D_program_page+0x74>
    printf("fail: qspi program page\r\n");
240124b0:	480a      	ldr	r0, [pc, #40]	@ (240124dc <IS25LP128D_program_page+0x9c>)
240124b2:	e7cf      	b.n	24012454 <IS25LP128D_program_page+0x14>
      || HAL_OK != HAL_QSPI_Transmit(&hqspi, data, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) )
240124b4:	f104 003c 	add.w	r0, r4, #60	@ 0x3c
240124b8:	f241 3288 	movw	r2, #5000	@ 0x1388
240124bc:	4639      	mov	r1, r7
240124be:	f7f6 fa8e 	bl	240089de <HAL_QSPI_Transmit>
240124c2:	4604      	mov	r4, r0
240124c4:	2800      	cmp	r0, #0
240124c6:	d1f3      	bne.n	240124b0 <IS25LP128D_program_page+0x70>
  check_WIP();
240124c8:	f7ff fe42 	bl	24012150 <check_WIP>
  return 0;
240124cc:	4620      	mov	r0, r4
240124ce:	e7cb      	b.n	24012468 <IS25LP128D_program_page+0x28>
240124d0:	00ffff00 	.word	0x00ffff00
240124d4:	240142f3 	.word	0x240142f3
240124d8:	24000598 	.word	0x24000598
240124dc:	2401430c 	.word	0x2401430c

240124e0 <IS25LP128D_read>:

uint32_t IS25LP128D_read(uint32_t address, uint8_t *data, uint32_t length)
{
  if (address > 0x00FFFFFF || data == NULL)
240124e0:	f1b0 7f80 	cmp.w	r0, #16777216	@ 0x1000000
{
240124e4:	b538      	push	{r3, r4, r5, lr}
240124e6:	460d      	mov	r5, r1
  if (address > 0x00FFFFFF || data == NULL)
240124e8:	d200      	bcs.n	240124ec <IS25LP128D_read+0xc>
240124ea:	b921      	cbnz	r1, 240124f6 <IS25LP128D_read+0x16>
  {
    printf("fail: qspi read: 01\r\n");
240124ec:	481d      	ldr	r0, [pc, #116]	@ (24012564 <IS25LP128D_read+0x84>)
240124ee:	f000 fbc7 	bl	24012c80 <puts>
    return 1;
240124f2:	2001      	movs	r0, #1
    printf("fail: qspi read: 03\r\n");

  cmd.DummyCycles = 6;

  return 0;
}
240124f4:	bd38      	pop	{r3, r4, r5, pc}
  cmd.InstructionMode = qspi_mode ? QSPI_INSTRUCTION_4_LINES : QSPI_INSTRUCTION_1_LINE;
240124f6:	4c1c      	ldr	r4, [pc, #112]	@ (24012568 <IS25LP128D_read+0x88>)
240124f8:	6823      	ldr	r3, [r4, #0]
  if (HAL_OK != HAL_QSPI_Command(&hqspi, &cmd, HAL_QPSI_TIMEOUT_DEFAULT_VALUE))
240124fa:	1d21      	adds	r1, r4, #4
  cmd.Address         = address;
240124fc:	60a0      	str	r0, [r4, #8]
  if (HAL_OK != HAL_QSPI_Command(&hqspi, &cmd, HAL_QPSI_TIMEOUT_DEFAULT_VALUE))
240124fe:	f104 003c 	add.w	r0, r4, #60	@ 0x3c
  cmd.InstructionMode = qspi_mode ? QSPI_INSTRUCTION_4_LINES : QSPI_INSTRUCTION_1_LINE;
24012502:	2b00      	cmp	r3, #0
24012504:	bf14      	ite	ne
24012506:	f44f 7340 	movne.w	r3, #768	@ 0x300
2401250a:	f44f 7380 	moveq.w	r3, #256	@ 0x100
2401250e:	61e3      	str	r3, [r4, #28]
  cmd.Instruction     = qspi_mode ? 0xEB : 0x03;
24012510:	bf14      	ite	ne
24012512:	23eb      	movne	r3, #235	@ 0xeb
24012514:	2303      	moveq	r3, #3
24012516:	6063      	str	r3, [r4, #4]
  cmd.AddressMode     = qspi_mode ? QSPI_ADDRESS_4_LINES : QSPI_ADDRESS_1_LINE;
24012518:	bf14      	ite	ne
2401251a:	f44f 6340 	movne.w	r3, #3072	@ 0xc00
2401251e:	f44f 6380 	moveq.w	r3, #1024	@ 0x400
24012522:	6223      	str	r3, [r4, #32]
  cmd.DummyCycles     = 6;
24012524:	f04f 0306 	mov.w	r3, #6
24012528:	61a3      	str	r3, [r4, #24]
  cmd.DataMode        = qspi_mode ? QSPI_DATA_4_LINES : QSPI_DATA_1_LINE;
2401252a:	bf0c      	ite	eq
2401252c:	f04f 7380 	moveq.w	r3, #16777216	@ 0x1000000
24012530:	f04f 7340 	movne.w	r3, #50331648	@ 0x3000000
  cmd.NbData          = length;
24012534:	e9c4 320a 	strd	r3, r2, [r4, #40]	@ 0x28
  if (HAL_OK != HAL_QSPI_Command(&hqspi, &cmd, HAL_QPSI_TIMEOUT_DEFAULT_VALUE))
24012538:	f241 3288 	movw	r2, #5000	@ 0x1388
2401253c:	f7f6 f9c8 	bl	240088d0 <HAL_QSPI_Command>
24012540:	b110      	cbz	r0, 24012548 <IS25LP128D_read+0x68>
    printf("fail: qspi read: 02\r\n");
24012542:	480a      	ldr	r0, [pc, #40]	@ (2401256c <IS25LP128D_read+0x8c>)
24012544:	f000 fb9c 	bl	24012c80 <puts>
  if (HAL_OK != HAL_QSPI_Receive(&hqspi, data, HAL_QPSI_TIMEOUT_DEFAULT_VALUE))
24012548:	f241 3288 	movw	r2, #5000	@ 0x1388
2401254c:	4629      	mov	r1, r5
2401254e:	4808      	ldr	r0, [pc, #32]	@ (24012570 <IS25LP128D_read+0x90>)
24012550:	f7f6 faa1 	bl	24008a96 <HAL_QSPI_Receive>
24012554:	b110      	cbz	r0, 2401255c <IS25LP128D_read+0x7c>
    printf("fail: qspi read: 03\r\n");
24012556:	4807      	ldr	r0, [pc, #28]	@ (24012574 <IS25LP128D_read+0x94>)
24012558:	f000 fb92 	bl	24012c80 <puts>
  cmd.DummyCycles = 6;
2401255c:	2306      	movs	r3, #6
  return 0;
2401255e:	2000      	movs	r0, #0
  cmd.DummyCycles = 6;
24012560:	61a3      	str	r3, [r4, #24]
  return 0;
24012562:	e7c7      	b.n	240124f4 <IS25LP128D_read+0x14>
24012564:	24014325 	.word	0x24014325
24012568:	24000598 	.word	0x24000598
2401256c:	2401433a 	.word	0x2401433a
24012570:	240005d4 	.word	0x240005d4
24012574:	2401434f 	.word	0x2401434f

24012578 <MX_QSPI_Init>:

  return 0;
}

void MX_QSPI_Init(void)
{
24012578:	b510      	push	{r4, lr}
  // peripheral init
  hqspi.Instance = QUADSPI;

  hqspi.Init.ClockPrescaler     = 9;
2401257a:	f8df c0d4 	ldr.w	ip, [pc, #212]	@ 24012650 <MX_QSPI_Init+0xd8>
2401257e:	2309      	movs	r3, #9
  hqspi.Instance = QUADSPI;
24012580:	4c2e      	ldr	r4, [pc, #184]	@ (2401263c <MX_QSPI_Init+0xc4>)
  hqspi.Init.FifoThreshold      = 16;
  hqspi.Init.SampleShifting     = QSPI_SAMPLE_SHIFTING_HALFCYCLE;
  hqspi.Init.FlashSize          = 24; // 16 MBytes
  hqspi.Init.ChipSelectHighTime = QSPI_CS_HIGH_TIME_1_CYCLE;
24012582:	f04f 0e18 	mov.w	lr, #24
  hqspi.Init.ClockPrescaler     = 9;
24012586:	e9c4 c30f 	strd	ip, r3, [r4, #60]	@ 0x3c
  hqspi.Init.FifoThreshold      = 16;
2401258a:	2310      	movs	r3, #16
  hqspi.Init.ClockMode          = QSPI_CLOCK_MODE_0;
  hqspi.Init.FlashID            = QSPI_FLASH_ID_1;
  hqspi.Init.DualFlash          = QSPI_DUALFLASH_DISABLE;

  HAL_QSPI_DeInit(&hqspi);
2401258c:	f104 003c 	add.w	r0, r4, #60	@ 0x3c
  hqspi.Init.SampleShifting     = QSPI_SAMPLE_SHIFTING_HALFCYCLE;
24012590:	e9c4 3311 	strd	r3, r3, [r4, #68]	@ 0x44
  hqspi.Init.ChipSelectHighTime = QSPI_CS_HIGH_TIME_1_CYCLE;
24012594:	2300      	movs	r3, #0
24012596:	e9c4 e313 	strd	lr, r3, [r4, #76]	@ 0x4c
  hqspi.Init.FlashID            = QSPI_FLASH_ID_1;
2401259a:	e9c4 3315 	strd	r3, r3, [r4, #84]	@ 0x54
  hqspi.Init.DualFlash          = QSPI_DUALFLASH_DISABLE;
2401259e:	65e3      	str	r3, [r4, #92]	@ 0x5c
  HAL_QSPI_DeInit(&hqspi);
240125a0:	f7f6 f985 	bl	240088ae <HAL_QSPI_DeInit>

  if (HAL_QSPI_Init(&hqspi) != HAL_OK)
240125a4:	f104 003c 	add.w	r0, r4, #60	@ 0x3c
240125a8:	f7f6 f934 	bl	24008814 <HAL_QSPI_Init>
240125ac:	b108      	cbz	r0, 240125b2 <MX_QSPI_Init+0x3a>
    Error_Handler();
240125ae:	f7ff fc9b 	bl	24011ee8 <Error_Handler>

  // command init
  cmd.AddressSize       = QSPI_ADDRESS_24_BITS;
240125b2:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
  cmd.InstructionMode = qspi_mode ? QSPI_INSTRUCTION_4_LINES : QSPI_INSTRUCTION_1_LINE;
240125b6:	6822      	ldr	r2, [r4, #0]
  if (HAL_QSPI_Command(&hqspi, &cmd, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
240125b8:	4921      	ldr	r1, [pc, #132]	@ (24012640 <MX_QSPI_Init+0xc8>)
  cmd.AddressSize       = QSPI_ADDRESS_24_BITS;
240125ba:	6123      	str	r3, [r4, #16]
  cmd.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
240125bc:	2300      	movs	r3, #0
  if (HAL_QSPI_Command(&hqspi, &cmd, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
240125be:	f101 0038 	add.w	r0, r1, #56	@ 0x38
  cmd.InstructionMode = qspi_mode ? QSPI_INSTRUCTION_4_LINES : QSPI_INSTRUCTION_1_LINE;
240125c2:	429a      	cmp	r2, r3
  cmd.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
240125c4:	6263      	str	r3, [r4, #36]	@ 0x24
  cmd.DummyCycles       = 0;
240125c6:	61a3      	str	r3, [r4, #24]
  cmd.InstructionMode = qspi_mode ? QSPI_INSTRUCTION_4_LINES : QSPI_INSTRUCTION_1_LINE;
240125c8:	bf0c      	ite	eq
240125ca:	f44f 7280 	moveq.w	r2, #256	@ 0x100
240125ce:	f44f 7240 	movne.w	r2, #768	@ 0x300
  cmd.DdrMode           = QSPI_DDR_MODE_DISABLE;
  cmd.DdrHoldHalfCycle  = QSPI_DDR_HHC_ANALOG_DELAY;
  cmd.SIOOMode          = QSPI_SIOO_INST_EVERY_CMD;
240125d2:	63a3      	str	r3, [r4, #56]	@ 0x38
  cmd.DataMode        = QSPI_DATA_NONE;
240125d4:	62a3      	str	r3, [r4, #40]	@ 0x28
  cmd.AddressMode     = QSPI_ADDRESS_NONE;
240125d6:	e9c4 2307 	strd	r2, r3, [r4, #28]
  cmd.DdrHoldHalfCycle  = QSPI_DDR_HHC_ANALOG_DELAY;
240125da:	e9c4 330c 	strd	r3, r3, [r4, #48]	@ 0x30
  cmd.Instruction = 0x66; // reset enable
240125de:	2366      	movs	r3, #102	@ 0x66
  if (HAL_QSPI_Command(&hqspi, &cmd, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
240125e0:	f241 3288 	movw	r2, #5000	@ 0x1388
  cmd.Instruction = 0x66; // reset enable
240125e4:	6063      	str	r3, [r4, #4]
  if (HAL_QSPI_Command(&hqspi, &cmd, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
240125e6:	f7f6 f973 	bl	240088d0 <HAL_QSPI_Command>
240125ea:	b110      	cbz	r0, 240125f2 <MX_QSPI_Init+0x7a>
    printf("fail: qspi reset enable\r\n");
240125ec:	4815      	ldr	r0, [pc, #84]	@ (24012644 <MX_QSPI_Init+0xcc>)
240125ee:	f000 fb47 	bl	24012c80 <puts>
  if (HAL_QSPI_Command(&hqspi, &cmd, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
240125f2:	4913      	ldr	r1, [pc, #76]	@ (24012640 <MX_QSPI_Init+0xc8>)
  cmd.Instruction = 0x99; // reset
240125f4:	2399      	movs	r3, #153	@ 0x99
  if (HAL_QSPI_Command(&hqspi, &cmd, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
240125f6:	f241 3288 	movw	r2, #5000	@ 0x1388
240125fa:	f101 0038 	add.w	r0, r1, #56	@ 0x38
  cmd.Instruction = 0x99; // reset
240125fe:	6063      	str	r3, [r4, #4]
  if (HAL_QSPI_Command(&hqspi, &cmd, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
24012600:	f7f6 f966 	bl	240088d0 <HAL_QSPI_Command>
24012604:	b110      	cbz	r0, 2401260c <MX_QSPI_Init+0x94>
    printf("fail: qspi reset\r\n");
24012606:	4810      	ldr	r0, [pc, #64]	@ (24012648 <MX_QSPI_Init+0xd0>)
24012608:	f000 fb3a 	bl	24012c80 <puts>
  cmd.InstructionMode = QSPI_INSTRUCTION_1_LINE;
2401260c:	f44f 7380 	mov.w	r3, #256	@ 0x100
  if (HAL_OK != HAL_QSPI_Command(&hqspi, &cmd, HAL_QPSI_TIMEOUT_DEFAULT_VALUE))
24012610:	490b      	ldr	r1, [pc, #44]	@ (24012640 <MX_QSPI_Init+0xc8>)
24012612:	f241 3288 	movw	r2, #5000	@ 0x1388
  cmd.InstructionMode = QSPI_INSTRUCTION_1_LINE;
24012616:	61e3      	str	r3, [r4, #28]
  cmd.Instruction     = 0x35;
24012618:	2335      	movs	r3, #53	@ 0x35
  if (HAL_OK != HAL_QSPI_Command(&hqspi, &cmd, HAL_QPSI_TIMEOUT_DEFAULT_VALUE))
2401261a:	f101 0038 	add.w	r0, r1, #56	@ 0x38
  cmd.Instruction     = 0x35;
2401261e:	6063      	str	r3, [r4, #4]
  cmd.AddressMode     = QSPI_ADDRESS_NONE;
24012620:	2300      	movs	r3, #0
24012622:	6223      	str	r3, [r4, #32]
  cmd.DataMode        = QSPI_DATA_NONE;
24012624:	62a3      	str	r3, [r4, #40]	@ 0x28
  if (HAL_OK != HAL_QSPI_Command(&hqspi, &cmd, HAL_QPSI_TIMEOUT_DEFAULT_VALUE))
24012626:	f7f6 f953 	bl	240088d0 <HAL_QSPI_Command>
2401262a:	b120      	cbz	r0, 24012636 <MX_QSPI_Init+0xbe>
    printf("fail: enter_qspi_mode\r\n");
2401262c:	4807      	ldr	r0, [pc, #28]	@ (2401264c <MX_QSPI_Init+0xd4>)
    printf("QSPI init err\r\n");
#endif

  // regieter thread
  //qspi_task_handle = osThreadNew(qspi_task, NULL, &qspiTask_attributes);
}
2401262e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    printf("fail: enter_qspi_mode\r\n");
24012632:	f000 bb25 	b.w	24012c80 <puts>
  qspi_mode = 1;
24012636:	2301      	movs	r3, #1
24012638:	6023      	str	r3, [r4, #0]
}
2401263a:	bd10      	pop	{r4, pc}
2401263c:	24000598 	.word	0x24000598
24012640:	2400059c 	.word	0x2400059c
24012644:	24014364 	.word	0x24014364
24012648:	2401437d 	.word	0x2401437d
2401264c:	2401438f 	.word	0x2401438f
24012650:	52005000 	.word	0x52005000

24012654 <HAL_MspInit>:
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
	__HAL_RCC_SYSCFG_CLK_ENABLE();
24012654:	4b07      	ldr	r3, [pc, #28]	@ (24012674 <HAL_MspInit+0x20>)
{
24012656:	b082      	sub	sp, #8
	__HAL_RCC_SYSCFG_CLK_ENABLE();
24012658:	f8d3 20f4 	ldr.w	r2, [r3, #244]	@ 0xf4
2401265c:	f042 0202 	orr.w	r2, r2, #2
24012660:	f8c3 20f4 	str.w	r2, [r3, #244]	@ 0xf4
24012664:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
24012668:	f003 0302 	and.w	r3, r3, #2
2401266c:	9301      	str	r3, [sp, #4]
2401266e:	9b01      	ldr	r3, [sp, #4]

	/* System interrupt init*/
}
24012670:	b002      	add	sp, #8
24012672:	4770      	bx	lr
24012674:	58024400 	.word	0x58024400

24012678 <NMI_Handler>:
  * @brief This function handles Non maskable interrupt.
  */
void NMI_Handler(void)
{

}
24012678:	4770      	bx	lr

2401267a <HardFault_Handler>:
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{

	while (1)
2401267a:	e7fe      	b.n	2401267a <HardFault_Handler>

2401267c <MemManage_Handler>:
/**
  * @brief This function handles Memory management fault.
  */
void MemManage_Handler(void)
{
	while (1)
2401267c:	e7fe      	b.n	2401267c <MemManage_Handler>

2401267e <BusFault_Handler>:
/**
  * @brief This function handles Pre-fetch fault, memory access fault.
  */
void BusFault_Handler(void)
{
   while (1)
2401267e:	e7fe      	b.n	2401267e <BusFault_Handler>

24012680 <UsageFault_Handler>:
/**
  * @brief This function handles Undefined instruction or illegal state.
  */
void UsageFault_Handler(void)
{
	while (1)
24012680:	e7fe      	b.n	24012680 <UsageFault_Handler>

24012682 <SVC_Handler>:
}

/**
  * @brief This function handles System service call via SWI instruction.
  */
void SVC_Handler(void)
24012682:	4770      	bx	lr

24012684 <DebugMon_Handler>:
}

/**
  * @brief This function handles Debug monitor.
  */
void DebugMon_Handler(void)
24012684:	4770      	bx	lr

24012686 <PendSV_Handler>:
}

/**
  * @brief This function handles Pendable request for system service.
  */
void PendSV_Handler(void)
24012686:	4770      	bx	lr

24012688 <SysTick_Handler>:
/**
  * @brief This function handles System tick timer.
  */
void SysTick_Handler(void)
{
	HAL_IncTick();
24012688:	f7ee b946 	b.w	24000918 <HAL_IncTick>

2401268c <initialise_monitor_handles>:


/* Functions */
void
initialise_monitor_handles() {
}
2401268c:	4770      	bx	lr

2401268e <_getpid>:

int
_getpid(void) {
    return 1;
}
2401268e:	2001      	movs	r0, #1
24012690:	4770      	bx	lr

24012692 <_kill>:

int
_kill(int pid, int sig) {
24012692:	b508      	push	{r3, lr}
    errno = EINVAL;
24012694:	f000 fba0 	bl	24012dd8 <__errno>
24012698:	2316      	movs	r3, #22
2401269a:	6003      	str	r3, [r0, #0]
    return -1;
}
2401269c:	f04f 30ff 	mov.w	r0, #4294967295
240126a0:	bd08      	pop	{r3, pc}

240126a2 <_exit>:

void
_exit (int status) {
240126a2:	b508      	push	{r3, lr}
    errno = EINVAL;
240126a4:	f000 fb98 	bl	24012dd8 <__errno>
240126a8:	2316      	movs	r3, #22
240126aa:	6003      	str	r3, [r0, #0]
    _kill(status, -1);
    while (1) {}        /* Make sure we hang here */
240126ac:	e7fe      	b.n	240126ac <_exit+0xa>

240126ae <_read>:
}

__attribute__((weak)) int _read(int file, char* ptr, int len) {
240126ae:	b570      	push	{r4, r5, r6, lr}
240126b0:	460d      	mov	r5, r1
240126b2:	4614      	mov	r4, r2
    int DataIdx;

    for (DataIdx = 0; DataIdx < len; DataIdx++) {
240126b4:	460e      	mov	r6, r1
240126b6:	1b73      	subs	r3, r6, r5
240126b8:	429c      	cmp	r4, r3
240126ba:	dc01      	bgt.n	240126c0 <_read+0x12>
        *ptr++ = __io_getchar();
    }

    return len;
}
240126bc:	4620      	mov	r0, r4
240126be:	bd70      	pop	{r4, r5, r6, pc}
        *ptr++ = __io_getchar();
240126c0:	f3af 8000 	nop.w
240126c4:	f806 0b01 	strb.w	r0, [r6], #1
    for (DataIdx = 0; DataIdx < len; DataIdx++) {
240126c8:	e7f5      	b.n	240126b6 <_read+0x8>

__attribute__((weak)) int _write(int file, char* ptr, int len) {
240126ca:	b570      	push	{r4, r5, r6, lr}
240126cc:	460d      	mov	r5, r1
240126ce:	4614      	mov	r4, r2
    int DataIdx;

    for (DataIdx = 0; DataIdx < len; DataIdx++) {
240126d0:	460e      	mov	r6, r1
240126d2:	1b73      	subs	r3, r6, r5
240126d4:	429c      	cmp	r4, r3
240126d6:	dc01      	bgt.n	240126dc <_read+0x2e>
        __io_putchar(*ptr++);
    }
    return len;
}
240126d8:	4620      	mov	r0, r4
240126da:	bd70      	pop	{r4, r5, r6, pc}
        __io_putchar(*ptr++);
240126dc:	f816 0b01 	ldrb.w	r0, [r6], #1
240126e0:	f7ff fb7e 	bl	24011de0 <__io_putchar>
    for (DataIdx = 0; DataIdx < len; DataIdx++) {
240126e4:	e7f5      	b.n	240126d2 <_read+0x24>

240126e6 <_close>:

int
_close(int file) {
    return -1;
}
240126e6:	f04f 30ff 	mov.w	r0, #4294967295
240126ea:	4770      	bx	lr

240126ec <_fstat>:


int
_fstat(int file, struct stat* st) {
    st->st_mode = S_IFCHR;
240126ec:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
    return 0;
}
240126f0:	2000      	movs	r0, #0
    st->st_mode = S_IFCHR;
240126f2:	604b      	str	r3, [r1, #4]
}
240126f4:	4770      	bx	lr

240126f6 <_isatty>:

int
_isatty(int file) {
    return 1;
}
240126f6:	2001      	movs	r0, #1
240126f8:	4770      	bx	lr

240126fa <_lseek>:

int
_lseek(int file, int ptr, int dir) {
    return 0;
}
240126fa:	2000      	movs	r0, #0
240126fc:	4770      	bx	lr

240126fe <_open>:

int
_open(char* path, int flags, ...) {
    /* Pretend like we always fail */
    return -1;
}
240126fe:	f04f 30ff 	mov.w	r0, #4294967295
_open(char* path, int flags, ...) {
24012702:	b40e      	push	{r1, r2, r3}
}
24012704:	b003      	add	sp, #12
24012706:	4770      	bx	lr

24012708 <_wait>:

int
_wait(int* status) {
24012708:	b508      	push	{r3, lr}
    errno = ECHILD;
2401270a:	f000 fb65 	bl	24012dd8 <__errno>
2401270e:	230a      	movs	r3, #10
24012710:	6003      	str	r3, [r0, #0]
    return -1;
}
24012712:	f04f 30ff 	mov.w	r0, #4294967295
24012716:	bd08      	pop	{r3, pc}

24012718 <_unlink>:

int
_unlink(char* name) {
24012718:	b508      	push	{r3, lr}
    errno = ENOENT;
2401271a:	f000 fb5d 	bl	24012dd8 <__errno>
2401271e:	2302      	movs	r3, #2
24012720:	6003      	str	r3, [r0, #0]
    return -1;
}
24012722:	f04f 30ff 	mov.w	r0, #4294967295
24012726:	bd08      	pop	{r3, pc}

24012728 <_times>:

int
_times(struct tms* buf) {
    return -1;
}
24012728:	f04f 30ff 	mov.w	r0, #4294967295
2401272c:	4770      	bx	lr

2401272e <_stat>:

int
_stat(char* file, struct stat* st) {
    st->st_mode = S_IFCHR;
2401272e:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
    return 0;
}
24012732:	2000      	movs	r0, #0
    st->st_mode = S_IFCHR;
24012734:	604b      	str	r3, [r1, #4]
}
24012736:	4770      	bx	lr

24012738 <_link>:

int
_link(char* old, char* new) {
24012738:	b508      	push	{r3, lr}
    errno = EMLINK;
2401273a:	f000 fb4d 	bl	24012dd8 <__errno>
2401273e:	231f      	movs	r3, #31
24012740:	6003      	str	r3, [r0, #0]
    return -1;
}
24012742:	f04f 30ff 	mov.w	r0, #4294967295
24012746:	bd08      	pop	{r3, pc}

24012748 <_fork>:

int
_fork(void) {
24012748:	b508      	push	{r3, lr}
    errno = EAGAIN;
2401274a:	f000 fb45 	bl	24012dd8 <__errno>
2401274e:	230b      	movs	r3, #11
24012750:	6003      	str	r3, [r0, #0]
    return -1;
}
24012752:	f04f 30ff 	mov.w	r0, #4294967295
24012756:	bd08      	pop	{r3, pc}

24012758 <_execve>:

int
_execve(char* name, char** argv, char** env) {
24012758:	b508      	push	{r3, lr}
    errno = ENOMEM;
2401275a:	f000 fb3d 	bl	24012dd8 <__errno>
2401275e:	230c      	movs	r3, #12
24012760:	6003      	str	r3, [r0, #0]
    return -1;
}
24012762:	f04f 30ff 	mov.w	r0, #4294967295
24012766:	bd08      	pop	{r3, pc}

24012768 <_sbrk>:
caddr_t _sbrk(int incr) {
    extern char end;       // Defined by the linker
    static char *heap_end;
    char *prev_heap_end;

    if (heap_end == 0) {
24012768:	4a04      	ldr	r2, [pc, #16]	@ (2401277c <_sbrk+0x14>)
caddr_t _sbrk(int incr) {
2401276a:	4603      	mov	r3, r0
    if (heap_end == 0) {
2401276c:	6811      	ldr	r1, [r2, #0]
2401276e:	b909      	cbnz	r1, 24012774 <_sbrk+0xc>
        heap_end = &end;
24012770:	4903      	ldr	r1, [pc, #12]	@ (24012780 <_sbrk+0x18>)
24012772:	6011      	str	r1, [r2, #0]
    }

    prev_heap_end = heap_end;
24012774:	6810      	ldr	r0, [r2, #0]
    heap_end += incr;
24012776:	4403      	add	r3, r0
24012778:	6013      	str	r3, [r2, #0]

    return (caddr_t)prev_heap_end;
}
2401277a:	4770      	bx	lr
2401277c:	24000620 	.word	0x24000620
24012780:	240143dc 	.word	0x240143dc

24012784 <SystemInit>:
 __IO uint32_t tmpreg;
#endif /* DATA_IN_D2_SRAM */

  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << (10*2))|(3UL << (11*2)));  /* set CP10 and CP11 Full Access */
24012784:	4918      	ldr	r1, [pc, #96]	@ (240127e8 <SystemInit+0x64>)

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;

  /* Reset HSEON, CSSON , CSION,RC48ON, CSIKERON PLL1ON, PLL2ON and PLL3ON bits */
  RCC->CR &= 0xEAF6ED7FU;
24012786:	4819      	ldr	r0, [pc, #100]	@ (240127ec <SystemInit+0x68>)
    SCB->CPACR |= ((3UL << (10*2))|(3UL << (11*2)));  /* set CP10 and CP11 Full Access */
24012788:	f8d1 3088 	ldr.w	r3, [r1, #136]	@ 0x88
2401278c:	f443 0370 	orr.w	r3, r3, #15728640	@ 0xf00000
{
24012790:	b510      	push	{r4, lr}
    SCB->CPACR |= ((3UL << (10*2))|(3UL << (11*2)));  /* set CP10 and CP11 Full Access */
24012792:	f8c1 3088 	str.w	r3, [r1, #136]	@ 0x88
  RCC->CR |= RCC_CR_HSION;
24012796:	4b16      	ldr	r3, [pc, #88]	@ (240127f0 <SystemInit+0x6c>)
24012798:	681a      	ldr	r2, [r3, #0]
2401279a:	f042 0201 	orr.w	r2, r2, #1
2401279e:	601a      	str	r2, [r3, #0]
  RCC->CFGR = 0x00000000;
240127a0:	2200      	movs	r2, #0
240127a2:	611a      	str	r2, [r3, #16]
  RCC->CR &= 0xEAF6ED7FU;
240127a4:	681c      	ldr	r4, [r3, #0]
240127a6:	4020      	ands	r0, r4
240127a8:	6018      	str	r0, [r3, #0]

#if defined(D3_SRAM_BASE)
  /* Reset D1CFGR register */
  RCC->D1CFGR = 0x00000000;
240127aa:	619a      	str	r2, [r3, #24]

  /* Reset D2CFGR register */
  RCC->D2CFGR = 0x00000000;
240127ac:	61da      	str	r2, [r3, #28]

  /* Reset D3CFGR register */
  RCC->D3CFGR = 0x00000000;
240127ae:	621a      	str	r2, [r3, #32]

  /* Reset SRDCFGR register */
  RCC->SRDCFGR = 0x00000000;
#endif
  /* Reset PLLCKSELR register */
  RCC->PLLCKSELR = 0x00000000;
240127b0:	629a      	str	r2, [r3, #40]	@ 0x28

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x00000000;
240127b2:	62da      	str	r2, [r3, #44]	@ 0x2c
  /* Reset PLL1DIVR register */
  RCC->PLL1DIVR = 0x00000000;
240127b4:	631a      	str	r2, [r3, #48]	@ 0x30
  /* Reset PLL1FRACR register */
  RCC->PLL1FRACR = 0x00000000;
240127b6:	635a      	str	r2, [r3, #52]	@ 0x34

  /* Reset PLL2DIVR register */
  RCC->PLL2DIVR = 0x00000000;
240127b8:	639a      	str	r2, [r3, #56]	@ 0x38

  /* Reset PLL2FRACR register */

  RCC->PLL2FRACR = 0x00000000;
240127ba:	63da      	str	r2, [r3, #60]	@ 0x3c
  /* Reset PLL3DIVR register */
  RCC->PLL3DIVR = 0x00000000;
240127bc:	641a      	str	r2, [r3, #64]	@ 0x40

  /* Reset PLL3FRACR register */
  RCC->PLL3FRACR = 0x00000000;
240127be:	645a      	str	r2, [r3, #68]	@ 0x44

  /* Reset HSEBYP bit */
  RCC->CR &= 0xFFFBFFFFU;
240127c0:	6818      	ldr	r0, [r3, #0]
240127c2:	f420 2080 	bic.w	r0, r0, #262144	@ 0x40000
240127c6:	6018      	str	r0, [r3, #0]

  /* Disable all interrupts */
  RCC->CIER = 0x00000000;
240127c8:	661a      	str	r2, [r3, #96]	@ 0x60

#if (STM32H7_DEV_ID == 0x450UL)
  /* dual core CM7 or single core line */
  if((DBGMCU->IDCODE & 0xFFFF0000U) < 0x20000000U)
240127ca:	4b0a      	ldr	r3, [pc, #40]	@ (240127f4 <SystemInit+0x70>)
240127cc:	681b      	ldr	r3, [r3, #0]
240127ce:	0c1b      	lsrs	r3, r3, #16
240127d0:	041b      	lsls	r3, r3, #16
240127d2:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
240127d6:	d203      	bcs.n	240127e0 <SystemInit+0x5c>
  {
    /* if stm32h7 revY*/
    /* Change  the switch matrix read issuing capability to 1 for the AXI SRAM target (Target 7) */
    *((__IO uint32_t*)0x51008108) = 0x000000001U;
240127d8:	4b07      	ldr	r3, [pc, #28]	@ (240127f8 <SystemInit+0x74>)
240127da:	2201      	movs	r2, #1
240127dc:	f8c3 2108 	str.w	r2, [r3, #264]	@ 0x108

  /* Configure the Vector Table location add offset address for cortex-M7 ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = D1_AXISRAM_BASE  | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal AXI-RAM */
#else
  SCB->VTOR = FLASH_BANK1_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
240127e0:	f04f 6300 	mov.w	r3, #134217728	@ 0x8000000
240127e4:	608b      	str	r3, [r1, #8]
#endif

#endif /*DUAL_CORE && CORE_CM4*/

}
240127e6:	bd10      	pop	{r4, pc}
240127e8:	e000ed00 	.word	0xe000ed00
240127ec:	eaf6ed7f 	.word	0xeaf6ed7f
240127f0:	58024400 	.word	0x58024400
240127f4:	5c001000 	.word	0x5c001000
240127f8:	51008000 	.word	0x51008000

240127fc <SystemCoreClockUpdate>:
  float_t fracn1, pllvco;


  /* Get SYSCLK source -------------------------------------------------------*/

  switch (RCC->CFGR & RCC_CFGR_SWS)
240127fc:	4a47      	ldr	r2, [pc, #284]	@ (2401291c <SystemCoreClockUpdate+0x120>)
240127fe:	6913      	ldr	r3, [r2, #16]
24012800:	f003 0338 	and.w	r3, r3, #56	@ 0x38
24012804:	2b10      	cmp	r3, #16
{
24012806:	b530      	push	{r4, r5, lr}
  switch (RCC->CFGR & RCC_CFGR_SWS)
24012808:	f000 8084 	beq.w	24012914 <SystemCoreClockUpdate+0x118>
2401280c:	2b18      	cmp	r3, #24
2401280e:	d01a      	beq.n	24012846 <SystemCoreClockUpdate+0x4a>
24012810:	2b00      	cmp	r3, #0
24012812:	f040 8081 	bne.w	24012918 <SystemCoreClockUpdate+0x11c>
  {
  case RCC_CFGR_SWS_HSI:  /* HSI used as system clock source */
    common_system_clock = (uint32_t) (HSI_VALUE >> ((RCC->CR & RCC_CR_HSIDIV)>> 3));
24012816:	6812      	ldr	r2, [r2, #0]
24012818:	4b41      	ldr	r3, [pc, #260]	@ (24012920 <SystemCoreClockUpdate+0x124>)
2401281a:	f3c2 02c1 	ubfx	r2, r2, #3, #2
2401281e:	40d3      	lsrs	r3, r2
    break;
  }

  /* Compute SystemClock frequency --------------------------------------------------*/
#if defined (RCC_D1CFGR_D1CPRE)
  tmp = D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos];
24012820:	493e      	ldr	r1, [pc, #248]	@ (2401291c <SystemCoreClockUpdate+0x120>)
24012822:	4840      	ldr	r0, [pc, #256]	@ (24012924 <SystemCoreClockUpdate+0x128>)
24012824:	698a      	ldr	r2, [r1, #24]
24012826:	f3c2 2203 	ubfx	r2, r2, #8, #4
2401282a:	5c82      	ldrb	r2, [r0, r2]

  /* common_system_clock frequency : CM7 CPU frequency  */
  common_system_clock >>= tmp;
2401282c:	40d3      	lsrs	r3, r2

  /* SystemD2Clock frequency : CM4 CPU, AXI and AHBs Clock frequency  */
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
2401282e:	698a      	ldr	r2, [r1, #24]
24012830:	493d      	ldr	r1, [pc, #244]	@ (24012928 <SystemCoreClockUpdate+0x12c>)
24012832:	f002 020f 	and.w	r2, r2, #15
24012836:	5c82      	ldrb	r2, [r0, r2]
24012838:	f002 021f 	and.w	r2, r2, #31
2401283c:	fa23 f202 	lsr.w	r2, r3, r2
#endif

#if defined(DUAL_CORE) && defined(CORE_CM4)
  SystemCoreClock = SystemD2Clock;
#else
  SystemCoreClock = common_system_clock;
24012840:	e9c1 2300 	strd	r2, r3, [r1]
#endif /* DUAL_CORE && CORE_CM4 */
}
24012844:	bd30      	pop	{r4, r5, pc}
    pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
24012846:	6a90      	ldr	r0, [r2, #40]	@ 0x28
    pllm = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM1)>> 4)  ;
24012848:	6a95      	ldr	r5, [r2, #40]	@ 0x28
    pllfracen = ((RCC->PLLCFGR & RCC_PLLCFGR_PLL1FRACEN)>>RCC_PLLCFGR_PLL1FRACEN_Pos);
2401284a:	6ad4      	ldr	r4, [r2, #44]	@ 0x2c
    if (pllm != 0U)
2401284c:	f415 7f7c 	tst.w	r5, #1008	@ 0x3f0
    pllm = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM1)>> 4)  ;
24012850:	f3c5 1305 	ubfx	r3, r5, #4, #6
    fracn1 = (float_t)(uint32_t)(pllfracen* ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));
24012854:	6b51      	ldr	r1, [r2, #52]	@ 0x34
    if (pllm != 0U)
24012856:	d0e3      	beq.n	24012820 <SystemCoreClockUpdate+0x24>
        pllvco = ( (float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
24012858:	ee07 3a90 	vmov	s15, r3
    fracn1 = (float_t)(uint32_t)(pllfracen* ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));
2401285c:	f3c1 03cc 	ubfx	r3, r1, #3, #13
    pllfracen = ((RCC->PLLCFGR & RCC_PLLCFGR_PLL1FRACEN)>>RCC_PLLCFGR_PLL1FRACEN_Pos);
24012860:	f004 0101 	and.w	r1, r4, #1
    pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
24012864:	f000 0003 	and.w	r0, r0, #3
        pllvco = ( (float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
24012868:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
    fracn1 = (float_t)(uint32_t)(pllfracen* ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));
2401286c:	434b      	muls	r3, r1
2401286e:	2801      	cmp	r0, #1
24012870:	eef7 5a00 	vmov.f32	s11, #112	@ 0x3f800000  1.0
        pllvco = ( (float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
24012874:	ee06 3a90 	vmov	s13, r3
24012878:	eefa 6ae9 	vcvt.f32.s32	s13, s13, #13
2401287c:	d03c      	beq.n	240128f8 <SystemCoreClockUpdate+0xfc>
2401287e:	2802      	cmp	r0, #2
24012880:	d028      	beq.n	240128d4 <SystemCoreClockUpdate+0xd8>
24012882:	bbc8      	cbnz	r0, 240128f8 <SystemCoreClockUpdate+0xfc>
        hsivalue = (HSI_VALUE >> ((RCC->CR & RCC_CR_HSIDIV)>> 3)) ;
24012884:	6811      	ldr	r1, [r2, #0]
        pllvco = ( (float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
24012886:	6b13      	ldr	r3, [r2, #48]	@ 0x30
        hsivalue = (HSI_VALUE >> ((RCC->CR & RCC_CR_HSIDIV)>> 3)) ;
24012888:	f3c1 01c1 	ubfx	r1, r1, #3, #2
2401288c:	4a24      	ldr	r2, [pc, #144]	@ (24012920 <SystemCoreClockUpdate+0x124>)
        pllvco = ( (float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
2401288e:	f3c3 0308 	ubfx	r3, r3, #0, #9
        hsivalue = (HSI_VALUE >> ((RCC->CR & RCC_CR_HSIDIV)>> 3)) ;
24012892:	40ca      	lsrs	r2, r1
        pllvco = ( (float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
24012894:	ee07 2a90 	vmov	s15, r2
24012898:	eeb8 6ae7 	vcvt.f32.s32	s12, s15
2401289c:	eec6 7a07 	vdiv.f32	s15, s12, s14
240128a0:	ee07 3a10 	vmov	s14, r3
240128a4:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
240128a8:	ee37 7a26 	vadd.f32	s14, s14, s13
240128ac:	ee37 7a25 	vadd.f32	s14, s14, s11
240128b0:	ee67 7a87 	vmul.f32	s15, s15, s14
      pllp = (((RCC->PLL1DIVR & RCC_PLL1DIVR_P1) >>9) + 1U ) ;
240128b4:	4b19      	ldr	r3, [pc, #100]	@ (2401291c <SystemCoreClockUpdate+0x120>)
240128b6:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
240128b8:	f3c3 2346 	ubfx	r3, r3, #9, #7
240128bc:	3301      	adds	r3, #1
      common_system_clock =  (uint32_t)(float_t)(pllvco/(float_t)pllp);
240128be:	ee07 3a10 	vmov	s14, r3
240128c2:	eef8 6ac7 	vcvt.f32.s32	s13, s14
240128c6:	ee87 7aa6 	vdiv.f32	s14, s15, s13
240128ca:	eefc 7ac7 	vcvt.u32.f32	s15, s14
240128ce:	ee17 3a90 	vmov	r3, s15
240128d2:	e7a5      	b.n	24012820 <SystemCoreClockUpdate+0x24>
          pllvco = ((float_t)HSE_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
240128d4:	6b13      	ldr	r3, [r2, #48]	@ 0x30
240128d6:	ed9f 6a15 	vldr	s12, [pc, #84]	@ 2401292c <SystemCoreClockUpdate+0x130>
240128da:	f3c3 0308 	ubfx	r3, r3, #0, #9
240128de:	ee07 3a90 	vmov	s15, r3
240128e2:	eef8 7ae7 	vcvt.f32.s32	s15, s15
240128e6:	ee77 7aa6 	vadd.f32	s15, s15, s13
240128ea:	ee77 7aa5 	vadd.f32	s15, s15, s11
          pllvco = ((float_t)CSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
240128ee:	eec6 6a07 	vdiv.f32	s13, s12, s14
240128f2:	ee67 7aa6 	vmul.f32	s15, s15, s13
        break;
240128f6:	e7dd      	b.n	240128b4 <SystemCoreClockUpdate+0xb8>
          pllvco = ((float_t)CSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
240128f8:	6b13      	ldr	r3, [r2, #48]	@ 0x30
240128fa:	ed9f 6a0d 	vldr	s12, [pc, #52]	@ 24012930 <SystemCoreClockUpdate+0x134>
240128fe:	f3c3 0308 	ubfx	r3, r3, #0, #9
24012902:	ee07 3a90 	vmov	s15, r3
24012906:	eef8 7ae7 	vcvt.f32.s32	s15, s15
2401290a:	ee77 7aa6 	vadd.f32	s15, s15, s13
2401290e:	ee77 7aa5 	vadd.f32	s15, s15, s11
24012912:	e7ec      	b.n	240128ee <SystemCoreClockUpdate+0xf2>
  switch (RCC->CFGR & RCC_CFGR_SWS)
24012914:	4b07      	ldr	r3, [pc, #28]	@ (24012934 <SystemCoreClockUpdate+0x138>)
24012916:	e783      	b.n	24012820 <SystemCoreClockUpdate+0x24>
    common_system_clock = CSI_VALUE;
24012918:	4b07      	ldr	r3, [pc, #28]	@ (24012938 <SystemCoreClockUpdate+0x13c>)
2401291a:	e781      	b.n	24012820 <SystemCoreClockUpdate+0x24>
2401291c:	58024400 	.word	0x58024400
24012920:	03d09000 	.word	0x03d09000
24012924:	240141fa 	.word	0x240141fa
24012928:	24000514 	.word	0x24000514
2401292c:	4bbebc20 	.word	0x4bbebc20
24012930:	4a742400 	.word	0x4a742400
24012934:	017d7840 	.word	0x017d7840
24012938:	003d0900 	.word	0x003d0900

2401293c <HAL_UART_MspInit>:
#include "stm32h7xx_hal_uart.h"

static UART_HandleTypeDef huart1;

void HAL_UART_MspInit(UART_HandleTypeDef* huart)
{
2401293c:	b510      	push	{r4, lr}
2401293e:	b0b6      	sub	sp, #216	@ 0xd8
24012940:	4604      	mov	r4, r0
  GPIO_InitTypeDef GPIO_InitStruct = {0};
24012942:	2214      	movs	r2, #20
24012944:	2100      	movs	r1, #0
24012946:	a802      	add	r0, sp, #8
24012948:	f000 fa3e 	bl	24012dc8 <memset>
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
2401294c:	22bc      	movs	r2, #188	@ 0xbc
2401294e:	2100      	movs	r1, #0
24012950:	a807      	add	r0, sp, #28
24012952:	f000 fa39 	bl	24012dc8 <memset>

  if(huart->Instance==USART1)
24012956:	6822      	ldr	r2, [r4, #0]
24012958:	4b19      	ldr	r3, [pc, #100]	@ (240129c0 <HAL_UART_MspInit+0x84>)
2401295a:	429a      	cmp	r2, r3
2401295c:	d12e      	bne.n	240129bc <HAL_UART_MspInit+0x80>
  {
    /** Initializes the peripherals clock
    */
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_USART1;
2401295e:	2301      	movs	r3, #1
    PeriphClkInitStruct.Usart16ClockSelection = RCC_USART16CLKSOURCE_D2PCLK2;
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
24012960:	a807      	add	r0, sp, #28
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_USART1;
24012962:	9307      	str	r3, [sp, #28]
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
24012964:	f7f7 fc96 	bl	2400a294 <HAL_RCCEx_PeriphCLKConfig>
24012968:	b108      	cbz	r0, 2401296e <HAL_UART_MspInit+0x32>
    {
      Error_Handler();
2401296a:	f7ff fabd 	bl	24011ee8 <Error_Handler>
    }

    /* Peripheral clock enable */
    __HAL_RCC_USART1_CLK_ENABLE();
2401296e:	4b15      	ldr	r3, [pc, #84]	@ (240129c4 <HAL_UART_MspInit+0x88>)
    GPIO_InitStruct.Pin = GPIO_PIN_14|GPIO_PIN_15;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    GPIO_InitStruct.Alternate = GPIO_AF4_USART1;
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
24012970:	a902      	add	r1, sp, #8
24012972:	4815      	ldr	r0, [pc, #84]	@ (240129c8 <HAL_UART_MspInit+0x8c>)
    __HAL_RCC_USART1_CLK_ENABLE();
24012974:	f8d3 20f0 	ldr.w	r2, [r3, #240]	@ 0xf0
24012978:	f042 0210 	orr.w	r2, r2, #16
2401297c:	f8c3 20f0 	str.w	r2, [r3, #240]	@ 0xf0
24012980:	f8d3 20f0 	ldr.w	r2, [r3, #240]	@ 0xf0
24012984:	f002 0210 	and.w	r2, r2, #16
24012988:	9200      	str	r2, [sp, #0]
2401298a:	9a00      	ldr	r2, [sp, #0]
    __HAL_RCC_GPIOB_CLK_ENABLE();
2401298c:	f8d3 20e0 	ldr.w	r2, [r3, #224]	@ 0xe0
24012990:	f042 0202 	orr.w	r2, r2, #2
24012994:	f8c3 20e0 	str.w	r2, [r3, #224]	@ 0xe0
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
24012998:	f44f 4240 	mov.w	r2, #49152	@ 0xc000
    __HAL_RCC_GPIOB_CLK_ENABLE();
2401299c:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
240129a0:	f003 0302 	and.w	r3, r3, #2
240129a4:	9301      	str	r3, [sp, #4]
240129a6:	9b01      	ldr	r3, [sp, #4]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
240129a8:	2302      	movs	r3, #2
240129aa:	e9cd 2302 	strd	r2, r3, [sp, #8]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
240129ae:	2300      	movs	r3, #0
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
240129b0:	e9cd 3304 	strd	r3, r3, [sp, #16]
    GPIO_InitStruct.Alternate = GPIO_AF4_USART1;
240129b4:	2304      	movs	r3, #4
240129b6:	9306      	str	r3, [sp, #24]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
240129b8:	f7f1 fc6e 	bl	24004298 <HAL_GPIO_Init>
  }
}
240129bc:	b036      	add	sp, #216	@ 0xd8
240129be:	bd10      	pop	{r4, pc}
240129c0:	40011000 	.word	0x40011000
240129c4:	58024400 	.word	0x58024400
240129c8:	58020400 	.word	0x58020400

240129cc <HAL_UART_MspDeInit>:

void HAL_UART_MspDeInit(UART_HandleTypeDef* huart)
{
  if(huart->Instance == USART1)
240129cc:	6802      	ldr	r2, [r0, #0]
{
240129ce:	b508      	push	{r3, lr}
  if(huart->Instance == USART1)
240129d0:	4b0a      	ldr	r3, [pc, #40]	@ (240129fc <HAL_UART_MspDeInit+0x30>)
240129d2:	429a      	cmp	r2, r3
240129d4:	d110      	bne.n	240129f8 <HAL_UART_MspDeInit+0x2c>
    PeriphClkInitStruct.Usart16ClockSelection =



    /* Peripheral clock disable */
    __HAL_RCC_USART1_CLK_DISABLE();
240129d6:	4a0a      	ldr	r2, [pc, #40]	@ (24012a00 <HAL_UART_MspDeInit+0x34>)

    /**USART1 GPIO Configuration
    PB14     ------> USART1_TX
    PB15     ------> USART1_RX
    */
    HAL_GPIO_DeInit(GPIOB, GPIO_PIN_14 | GPIO_PIN_15);
240129d8:	f44f 4140 	mov.w	r1, #49152	@ 0xc000
240129dc:	4809      	ldr	r0, [pc, #36]	@ (24012a04 <HAL_UART_MspDeInit+0x38>)
    __HAL_RCC_USART1_CLK_DISABLE();
240129de:	f8d2 30f0 	ldr.w	r3, [r2, #240]	@ 0xf0
240129e2:	f023 0310 	bic.w	r3, r3, #16
240129e6:	f8c2 30f0 	str.w	r3, [r2, #240]	@ 0xf0
    HAL_GPIO_DeInit(GPIOB, GPIO_PIN_14 | GPIO_PIN_15);
240129ea:	f7f1 fd37 	bl	2400445c <HAL_GPIO_DeInit>

    /* USART1 interrupt DeInit */
    HAL_NVIC_DisableIRQ(USART1_IRQn);
240129ee:	2025      	movs	r0, #37	@ 0x25
  }
}
240129f0:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    HAL_NVIC_DisableIRQ(USART1_IRQn);
240129f4:	f7ee b9e4 	b.w	24000dc0 <HAL_NVIC_DisableIRQ>
}
240129f8:	bd08      	pop	{r3, pc}
240129fa:	bf00      	nop
240129fc:	40011000 	.word	0x40011000
24012a00:	58024400 	.word	0x58024400
24012a04:	58020400 	.word	0x58020400

24012a08 <_write>:

int _write(int file, char *ptr, int len)
{
24012a08:	b508      	push	{r3, lr}
  HAL_UART_Transmit(&huart1, (const uint8_t *)ptr, len, 0xFFFFFFFF);
24012a0a:	b292      	uxth	r2, r2
24012a0c:	f04f 33ff 	mov.w	r3, #4294967295
24012a10:	4802      	ldr	r0, [pc, #8]	@ (24012a1c <_write+0x14>)
24012a12:	f7fd f876 	bl	2400fb02 <HAL_UART_Transmit>

  return 0;
}
24012a16:	2000      	movs	r0, #0
24012a18:	bd08      	pop	{r3, pc}
24012a1a:	bf00      	nop
24012a1c:	24000628 	.word	0x24000628

24012a20 <MX_USART1_Init>:

void MX_USART1_Init(void)
{
24012a20:	b510      	push	{r4, lr}
  huart1.Instance = USART1;
  huart1.Init.BaudRate = 115200;
24012a22:	4a18      	ldr	r2, [pc, #96]	@ (24012a84 <MX_USART1_Init+0x64>)
24012a24:	f44f 33e1 	mov.w	r3, #115200	@ 0x1c200
  huart1.Instance = USART1;
24012a28:	4c17      	ldr	r4, [pc, #92]	@ (24012a88 <MX_USART1_Init+0x68>)
  huart1.Init.BaudRate = 115200;
24012a2a:	e9c4 2300 	strd	r2, r3, [r4]
  huart1.Init.WordLength = UART_WORDLENGTH_8B;
24012a2e:	2300      	movs	r3, #0
  huart1.Init.StopBits = UART_STOPBITS_1;
  huart1.Init.Parity = UART_PARITY_NONE;
  huart1.Init.Mode = UART_MODE_TX_RX;
24012a30:	220c      	movs	r2, #12
  huart1.Init.OverSampling = UART_OVERSAMPLING_16;
  huart1.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
  huart1.Init.ClockPrescaler = UART_PRESCALER_DIV1;
  huart1.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;

  HAL_UART_DeInit(&huart1);
24012a32:	4620      	mov	r0, r4
  huart1.Init.Parity = UART_PARITY_NONE;
24012a34:	6123      	str	r3, [r4, #16]
  huart1.Init.StopBits = UART_STOPBITS_1;
24012a36:	e9c4 3302 	strd	r3, r3, [r4, #8]
  huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
24012a3a:	e9c4 2305 	strd	r2, r3, [r4, #20]
  huart1.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
24012a3e:	e9c4 3307 	strd	r3, r3, [r4, #28]
  huart1.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
24012a42:	e9c4 3309 	strd	r3, r3, [r4, #36]	@ 0x24
  HAL_UART_DeInit(&huart1);
24012a46:	f7fb fc6e 	bl	2400e326 <HAL_UART_DeInit>

  if (HAL_UART_Init(&huart1) != HAL_OK)
24012a4a:	4620      	mov	r0, r4
24012a4c:	f7fd f975 	bl	2400fd3a <HAL_UART_Init>
24012a50:	b108      	cbz	r0, 24012a56 <MX_USART1_Init+0x36>
  {
    Error_Handler();
24012a52:	f7ff fa49 	bl	24011ee8 <Error_Handler>
  }
  if (HAL_UARTEx_SetTxFifoThreshold(&huart1, UART_TXFIFO_THRESHOLD_1_8) != HAL_OK)
24012a56:	2100      	movs	r1, #0
24012a58:	480b      	ldr	r0, [pc, #44]	@ (24012a88 <MX_USART1_Init+0x68>)
24012a5a:	f7fd fcc8 	bl	240103ee <HAL_UARTEx_SetTxFifoThreshold>
24012a5e:	b108      	cbz	r0, 24012a64 <MX_USART1_Init+0x44>
  {
    Error_Handler();
24012a60:	f7ff fa42 	bl	24011ee8 <Error_Handler>
  }
  if (HAL_UARTEx_SetRxFifoThreshold(&huart1, UART_RXFIFO_THRESHOLD_1_8) != HAL_OK)
24012a64:	2100      	movs	r1, #0
24012a66:	4808      	ldr	r0, [pc, #32]	@ (24012a88 <MX_USART1_Init+0x68>)
24012a68:	f7fd fce1 	bl	2401042e <HAL_UARTEx_SetRxFifoThreshold>
24012a6c:	b108      	cbz	r0, 24012a72 <MX_USART1_Init+0x52>
  {
    Error_Handler();
24012a6e:	f7ff fa3b 	bl	24011ee8 <Error_Handler>
  }
  if (HAL_UARTEx_DisableFifoMode(&huart1) != HAL_OK)
24012a72:	4805      	ldr	r0, [pc, #20]	@ (24012a88 <MX_USART1_Init+0x68>)
24012a74:	f7fd fca0 	bl	240103b8 <HAL_UARTEx_DisableFifoMode>
24012a78:	b118      	cbz	r0, 24012a82 <MX_USART1_Init+0x62>
  {
    Error_Handler();
  }
}
24012a7a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    Error_Handler();
24012a7e:	f7ff ba33 	b.w	24011ee8 <Error_Handler>
}
24012a82:	bd10      	pop	{r4, pc}
24012a84:	40011000 	.word	0x40011000
24012a88:	24000628 	.word	0x24000628
24012a8c:	240004a0 	.word	0x240004a0
24012a90:	240004a0 	.word	0x240004a0
24012a94:	24000578 	.word	0x24000578
24012a98:	24000578 	.word	0x24000578
24012a9c:	2400080c 	.word	0x2400080c

24012aa0 <memchr>:
24012aa0:	f001 01ff 	and.w	r1, r1, #255	@ 0xff
24012aa4:	2a10      	cmp	r2, #16
24012aa6:	db2b      	blt.n	24012b00 <memchr+0x60>
24012aa8:	f010 0f07 	tst.w	r0, #7
24012aac:	d008      	beq.n	24012ac0 <memchr+0x20>
24012aae:	f810 3b01 	ldrb.w	r3, [r0], #1
24012ab2:	3a01      	subs	r2, #1
24012ab4:	428b      	cmp	r3, r1
24012ab6:	d02d      	beq.n	24012b14 <memchr+0x74>
24012ab8:	f010 0f07 	tst.w	r0, #7
24012abc:	b342      	cbz	r2, 24012b10 <memchr+0x70>
24012abe:	d1f6      	bne.n	24012aae <memchr+0xe>
24012ac0:	b4f0      	push	{r4, r5, r6, r7}
24012ac2:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
24012ac6:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
24012aca:	f022 0407 	bic.w	r4, r2, #7
24012ace:	f07f 0700 	mvns.w	r7, #0
24012ad2:	2300      	movs	r3, #0
24012ad4:	e8f0 5602 	ldrd	r5, r6, [r0], #8
24012ad8:	3c08      	subs	r4, #8
24012ada:	ea85 0501 	eor.w	r5, r5, r1
24012ade:	ea86 0601 	eor.w	r6, r6, r1
24012ae2:	fa85 f547 	uadd8	r5, r5, r7
24012ae6:	faa3 f587 	sel	r5, r3, r7
24012aea:	fa86 f647 	uadd8	r6, r6, r7
24012aee:	faa5 f687 	sel	r6, r5, r7
24012af2:	b98e      	cbnz	r6, 24012b18 <memchr+0x78>
24012af4:	d1ee      	bne.n	24012ad4 <memchr+0x34>
24012af6:	bcf0      	pop	{r4, r5, r6, r7}
24012af8:	f001 01ff 	and.w	r1, r1, #255	@ 0xff
24012afc:	f002 0207 	and.w	r2, r2, #7
24012b00:	b132      	cbz	r2, 24012b10 <memchr+0x70>
24012b02:	f810 3b01 	ldrb.w	r3, [r0], #1
24012b06:	3a01      	subs	r2, #1
24012b08:	ea83 0301 	eor.w	r3, r3, r1
24012b0c:	b113      	cbz	r3, 24012b14 <memchr+0x74>
24012b0e:	d1f8      	bne.n	24012b02 <memchr+0x62>
24012b10:	2000      	movs	r0, #0
24012b12:	4770      	bx	lr
24012b14:	3801      	subs	r0, #1
24012b16:	4770      	bx	lr
24012b18:	2d00      	cmp	r5, #0
24012b1a:	bf06      	itte	eq
24012b1c:	4635      	moveq	r5, r6
24012b1e:	3803      	subeq	r0, #3
24012b20:	3807      	subne	r0, #7
24012b22:	f015 0f01 	tst.w	r5, #1
24012b26:	d107      	bne.n	24012b38 <memchr+0x98>
24012b28:	3001      	adds	r0, #1
24012b2a:	f415 7f80 	tst.w	r5, #256	@ 0x100
24012b2e:	bf02      	ittt	eq
24012b30:	3001      	addeq	r0, #1
24012b32:	f415 3fc0 	tsteq.w	r5, #98304	@ 0x18000
24012b36:	3001      	addeq	r0, #1
24012b38:	bcf0      	pop	{r4, r5, r6, r7}
24012b3a:	3801      	subs	r0, #1
24012b3c:	4770      	bx	lr
24012b3e:	bf00      	nop

24012b40 <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  
  ldr   sp, =_estack      /* set stack pointer */
24012b40:	f8df d034 	ldr.w	sp, [pc, #52]	@ 24012b78 <LoopFillZerobss+0x14>

/* Copy the data segment initializers from flash to SRAM */  
  movs  r1, #0
24012b44:	2100      	movs	r1, #0
  b  LoopCopyDataInit
24012b46:	e003      	b.n	24012b50 <LoopCopyDataInit>

24012b48 <CopyDataInit>:

CopyDataInit:
  ldr  r3, =_sidata
24012b48:	4b0c      	ldr	r3, [pc, #48]	@ (24012b7c <LoopFillZerobss+0x18>)
  ldr  r3, [r3, r1]
24012b4a:	585b      	ldr	r3, [r3, r1]
  str  r3, [r0, r1]
24012b4c:	5043      	str	r3, [r0, r1]
  adds  r1, r1, #4
24012b4e:	3104      	adds	r1, #4

24012b50 <LoopCopyDataInit>:
    
LoopCopyDataInit:
  ldr  r0, =_sdata
24012b50:	480b      	ldr	r0, [pc, #44]	@ (24012b80 <LoopFillZerobss+0x1c>)
  ldr  r3, =_edata
24012b52:	4b0c      	ldr	r3, [pc, #48]	@ (24012b84 <LoopFillZerobss+0x20>)
  adds  r2, r0, r1
24012b54:	1842      	adds	r2, r0, r1
  cmp  r2, r3
24012b56:	429a      	cmp	r2, r3
  bcc  CopyDataInit
24012b58:	d3f6      	bcc.n	24012b48 <CopyDataInit>
  ldr  r2, =_sbss
24012b5a:	4a0b      	ldr	r2, [pc, #44]	@ (24012b88 <LoopFillZerobss+0x24>)
  b  LoopFillZerobss
24012b5c:	e002      	b.n	24012b64 <LoopFillZerobss>

24012b5e <FillZerobss>:
/* Zero fill the bss segment. */  
FillZerobss:
  movs  r3, #0
24012b5e:	2300      	movs	r3, #0
  str  r3, [r2], #4
24012b60:	f842 3b04 	str.w	r3, [r2], #4

24012b64 <LoopFillZerobss>:
    
LoopFillZerobss:
  ldr  r3, = _ebss
24012b64:	4b09      	ldr	r3, [pc, #36]	@ (24012b8c <LoopFillZerobss+0x28>)
  cmp  r2, r3
24012b66:	429a      	cmp	r2, r3
  bcc  FillZerobss
24012b68:	d3f9      	bcc.n	24012b5e <FillZerobss>

/* Call the clock system intitialization function.*/
  bl  SystemInit   
24012b6a:	f7ff fe0b 	bl	24012784 <SystemInit>
/* Call static constructors */
  bl __libc_init_array
24012b6e:	f000 f939 	bl	24012de4 <__libc_init_array>
/* Call the application's entry point.*/
  bl  Init
24012b72:	f7ff fac7 	bl	24012104 <Init>
  bx  lr
24012b76:	4770      	bx	lr
  ldr   sp, =_estack      /* set stack pointer */
24012b78:	24080004 	.word	0x24080004
  ldr  r3, =_sidata
24012b7c:	240004a0 	.word	0x240004a0
  ldr  r0, =_sdata
24012b80:	240004a0 	.word	0x240004a0
  ldr  r3, =_edata
24012b84:	24000578 	.word	0x24000578
  ldr  r2, =_sbss
24012b88:	24000578 	.word	0x24000578
  ldr  r3, = _ebss
24012b8c:	2400080c 	.word	0x2400080c

24012b90 <ADC3_IRQHandler>:
 * @retval None       
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
24012b90:	e7fe      	b.n	24012b90 <ADC3_IRQHandler>

24012b92 <_iprintf_r>:
24012b92:	b40e      	push	{r1, r2, r3}
24012b94:	b503      	push	{r0, r1, lr}
24012b96:	ab03      	add	r3, sp, #12
24012b98:	6881      	ldr	r1, [r0, #8]
24012b9a:	f853 2b04 	ldr.w	r2, [r3], #4
24012b9e:	9301      	str	r3, [sp, #4]
24012ba0:	f000 fa7e 	bl	240130a0 <_vfiprintf_r>
24012ba4:	b002      	add	sp, #8
24012ba6:	f85d eb04 	ldr.w	lr, [sp], #4
24012baa:	b003      	add	sp, #12
24012bac:	4770      	bx	lr
	...

24012bb0 <iprintf>:
24012bb0:	b40f      	push	{r0, r1, r2, r3}
24012bb2:	b507      	push	{r0, r1, r2, lr}
24012bb4:	4906      	ldr	r1, [pc, #24]	@ (24012bd0 <iprintf+0x20>)
24012bb6:	ab04      	add	r3, sp, #16
24012bb8:	6808      	ldr	r0, [r1, #0]
24012bba:	f853 2b04 	ldr.w	r2, [r3], #4
24012bbe:	6881      	ldr	r1, [r0, #8]
24012bc0:	9301      	str	r3, [sp, #4]
24012bc2:	f000 fa6d 	bl	240130a0 <_vfiprintf_r>
24012bc6:	b003      	add	sp, #12
24012bc8:	f85d eb04 	ldr.w	lr, [sp], #4
24012bcc:	b004      	add	sp, #16
24012bce:	4770      	bx	lr
24012bd0:	2400051c 	.word	0x2400051c

24012bd4 <_puts_r>:
24012bd4:	6a03      	ldr	r3, [r0, #32]
24012bd6:	b570      	push	{r4, r5, r6, lr}
24012bd8:	6884      	ldr	r4, [r0, #8]
24012bda:	4605      	mov	r5, r0
24012bdc:	460e      	mov	r6, r1
24012bde:	b90b      	cbnz	r3, 24012be4 <_puts_r+0x10>
24012be0:	f000 fec4 	bl	2401396c <__sinit>
24012be4:	6e63      	ldr	r3, [r4, #100]	@ 0x64
24012be6:	07db      	lsls	r3, r3, #31
24012be8:	d405      	bmi.n	24012bf6 <_puts_r+0x22>
24012bea:	89a3      	ldrh	r3, [r4, #12]
24012bec:	0598      	lsls	r0, r3, #22
24012bee:	d402      	bmi.n	24012bf6 <_puts_r+0x22>
24012bf0:	6da0      	ldr	r0, [r4, #88]	@ 0x58
24012bf2:	f000 f920 	bl	24012e36 <__retarget_lock_acquire_recursive>
24012bf6:	89a3      	ldrh	r3, [r4, #12]
24012bf8:	0719      	lsls	r1, r3, #28
24012bfa:	d502      	bpl.n	24012c02 <_puts_r+0x2e>
24012bfc:	6923      	ldr	r3, [r4, #16]
24012bfe:	2b00      	cmp	r3, #0
24012c00:	d135      	bne.n	24012c6e <_puts_r+0x9a>
24012c02:	4621      	mov	r1, r4
24012c04:	4628      	mov	r0, r5
24012c06:	f000 f889 	bl	24012d1c <__swsetup_r>
24012c0a:	b380      	cbz	r0, 24012c6e <_puts_r+0x9a>
24012c0c:	f04f 35ff 	mov.w	r5, #4294967295
24012c10:	6e63      	ldr	r3, [r4, #100]	@ 0x64
24012c12:	07da      	lsls	r2, r3, #31
24012c14:	d405      	bmi.n	24012c22 <_puts_r+0x4e>
24012c16:	89a3      	ldrh	r3, [r4, #12]
24012c18:	059b      	lsls	r3, r3, #22
24012c1a:	d402      	bmi.n	24012c22 <_puts_r+0x4e>
24012c1c:	6da0      	ldr	r0, [r4, #88]	@ 0x58
24012c1e:	f000 f910 	bl	24012e42 <__retarget_lock_release_recursive>
24012c22:	4628      	mov	r0, r5
24012c24:	bd70      	pop	{r4, r5, r6, pc}
24012c26:	2b00      	cmp	r3, #0
24012c28:	da04      	bge.n	24012c34 <_puts_r+0x60>
24012c2a:	69a2      	ldr	r2, [r4, #24]
24012c2c:	429a      	cmp	r2, r3
24012c2e:	dc17      	bgt.n	24012c60 <_puts_r+0x8c>
24012c30:	290a      	cmp	r1, #10
24012c32:	d015      	beq.n	24012c60 <_puts_r+0x8c>
24012c34:	6823      	ldr	r3, [r4, #0]
24012c36:	1c5a      	adds	r2, r3, #1
24012c38:	6022      	str	r2, [r4, #0]
24012c3a:	7019      	strb	r1, [r3, #0]
24012c3c:	68a3      	ldr	r3, [r4, #8]
24012c3e:	f816 1f01 	ldrb.w	r1, [r6, #1]!
24012c42:	3b01      	subs	r3, #1
24012c44:	60a3      	str	r3, [r4, #8]
24012c46:	2900      	cmp	r1, #0
24012c48:	d1ed      	bne.n	24012c26 <_puts_r+0x52>
24012c4a:	2b00      	cmp	r3, #0
24012c4c:	da11      	bge.n	24012c72 <_puts_r+0x9e>
24012c4e:	4622      	mov	r2, r4
24012c50:	210a      	movs	r1, #10
24012c52:	4628      	mov	r0, r5
24012c54:	f000 f81c 	bl	24012c90 <__swbuf_r>
24012c58:	3001      	adds	r0, #1
24012c5a:	d0d7      	beq.n	24012c0c <_puts_r+0x38>
24012c5c:	250a      	movs	r5, #10
24012c5e:	e7d7      	b.n	24012c10 <_puts_r+0x3c>
24012c60:	4622      	mov	r2, r4
24012c62:	4628      	mov	r0, r5
24012c64:	f000 f814 	bl	24012c90 <__swbuf_r>
24012c68:	3001      	adds	r0, #1
24012c6a:	d1e7      	bne.n	24012c3c <_puts_r+0x68>
24012c6c:	e7ce      	b.n	24012c0c <_puts_r+0x38>
24012c6e:	3e01      	subs	r6, #1
24012c70:	e7e4      	b.n	24012c3c <_puts_r+0x68>
24012c72:	6823      	ldr	r3, [r4, #0]
24012c74:	1c5a      	adds	r2, r3, #1
24012c76:	6022      	str	r2, [r4, #0]
24012c78:	220a      	movs	r2, #10
24012c7a:	701a      	strb	r2, [r3, #0]
24012c7c:	e7ee      	b.n	24012c5c <_puts_r+0x88>
	...

24012c80 <puts>:
24012c80:	4b02      	ldr	r3, [pc, #8]	@ (24012c8c <puts+0xc>)
24012c82:	4601      	mov	r1, r0
24012c84:	6818      	ldr	r0, [r3, #0]
24012c86:	f7ff bfa5 	b.w	24012bd4 <_puts_r>
24012c8a:	bf00      	nop
24012c8c:	2400051c 	.word	0x2400051c

24012c90 <__swbuf_r>:
24012c90:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
24012c92:	460e      	mov	r6, r1
24012c94:	4614      	mov	r4, r2
24012c96:	4605      	mov	r5, r0
24012c98:	b118      	cbz	r0, 24012ca2 <__swbuf_r+0x12>
24012c9a:	6a03      	ldr	r3, [r0, #32]
24012c9c:	b90b      	cbnz	r3, 24012ca2 <__swbuf_r+0x12>
24012c9e:	f000 fe65 	bl	2401396c <__sinit>
24012ca2:	69a3      	ldr	r3, [r4, #24]
24012ca4:	60a3      	str	r3, [r4, #8]
24012ca6:	89a3      	ldrh	r3, [r4, #12]
24012ca8:	071a      	lsls	r2, r3, #28
24012caa:	d501      	bpl.n	24012cb0 <__swbuf_r+0x20>
24012cac:	6923      	ldr	r3, [r4, #16]
24012cae:	b943      	cbnz	r3, 24012cc2 <__swbuf_r+0x32>
24012cb0:	4621      	mov	r1, r4
24012cb2:	4628      	mov	r0, r5
24012cb4:	f000 f832 	bl	24012d1c <__swsetup_r>
24012cb8:	b118      	cbz	r0, 24012cc2 <__swbuf_r+0x32>
24012cba:	f04f 37ff 	mov.w	r7, #4294967295
24012cbe:	4638      	mov	r0, r7
24012cc0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
24012cc2:	6823      	ldr	r3, [r4, #0]
24012cc4:	6922      	ldr	r2, [r4, #16]
24012cc6:	1a98      	subs	r0, r3, r2
24012cc8:	6963      	ldr	r3, [r4, #20]
24012cca:	b2f6      	uxtb	r6, r6
24012ccc:	4283      	cmp	r3, r0
24012cce:	4637      	mov	r7, r6
24012cd0:	dc05      	bgt.n	24012cde <__swbuf_r+0x4e>
24012cd2:	4621      	mov	r1, r4
24012cd4:	4628      	mov	r0, r5
24012cd6:	f000 fd17 	bl	24013708 <_fflush_r>
24012cda:	2800      	cmp	r0, #0
24012cdc:	d1ed      	bne.n	24012cba <__swbuf_r+0x2a>
24012cde:	68a3      	ldr	r3, [r4, #8]
24012ce0:	3b01      	subs	r3, #1
24012ce2:	60a3      	str	r3, [r4, #8]
24012ce4:	6823      	ldr	r3, [r4, #0]
24012ce6:	1c5a      	adds	r2, r3, #1
24012ce8:	6022      	str	r2, [r4, #0]
24012cea:	701e      	strb	r6, [r3, #0]
24012cec:	6962      	ldr	r2, [r4, #20]
24012cee:	1c43      	adds	r3, r0, #1
24012cf0:	429a      	cmp	r2, r3
24012cf2:	d004      	beq.n	24012cfe <__swbuf_r+0x6e>
24012cf4:	89a3      	ldrh	r3, [r4, #12]
24012cf6:	07db      	lsls	r3, r3, #31
24012cf8:	d5e1      	bpl.n	24012cbe <__swbuf_r+0x2e>
24012cfa:	2e0a      	cmp	r6, #10
24012cfc:	d1df      	bne.n	24012cbe <__swbuf_r+0x2e>
24012cfe:	4621      	mov	r1, r4
24012d00:	4628      	mov	r0, r5
24012d02:	f000 fd01 	bl	24013708 <_fflush_r>
24012d06:	2800      	cmp	r0, #0
24012d08:	d0d9      	beq.n	24012cbe <__swbuf_r+0x2e>
24012d0a:	e7d6      	b.n	24012cba <__swbuf_r+0x2a>

24012d0c <__swbuf>:
24012d0c:	4b02      	ldr	r3, [pc, #8]	@ (24012d18 <__swbuf+0xc>)
24012d0e:	460a      	mov	r2, r1
24012d10:	4601      	mov	r1, r0
24012d12:	6818      	ldr	r0, [r3, #0]
24012d14:	f7ff bfbc 	b.w	24012c90 <__swbuf_r>
24012d18:	2400051c 	.word	0x2400051c

24012d1c <__swsetup_r>:
24012d1c:	b538      	push	{r3, r4, r5, lr}
24012d1e:	4b29      	ldr	r3, [pc, #164]	@ (24012dc4 <__swsetup_r+0xa8>)
24012d20:	4605      	mov	r5, r0
24012d22:	6818      	ldr	r0, [r3, #0]
24012d24:	460c      	mov	r4, r1
24012d26:	b118      	cbz	r0, 24012d30 <__swsetup_r+0x14>
24012d28:	6a03      	ldr	r3, [r0, #32]
24012d2a:	b90b      	cbnz	r3, 24012d30 <__swsetup_r+0x14>
24012d2c:	f000 fe1e 	bl	2401396c <__sinit>
24012d30:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
24012d34:	0719      	lsls	r1, r3, #28
24012d36:	d422      	bmi.n	24012d7e <__swsetup_r+0x62>
24012d38:	06da      	lsls	r2, r3, #27
24012d3a:	d407      	bmi.n	24012d4c <__swsetup_r+0x30>
24012d3c:	2209      	movs	r2, #9
24012d3e:	602a      	str	r2, [r5, #0]
24012d40:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
24012d44:	81a3      	strh	r3, [r4, #12]
24012d46:	f04f 30ff 	mov.w	r0, #4294967295
24012d4a:	e033      	b.n	24012db4 <__swsetup_r+0x98>
24012d4c:	0758      	lsls	r0, r3, #29
24012d4e:	d512      	bpl.n	24012d76 <__swsetup_r+0x5a>
24012d50:	6b61      	ldr	r1, [r4, #52]	@ 0x34
24012d52:	b141      	cbz	r1, 24012d66 <__swsetup_r+0x4a>
24012d54:	f104 0344 	add.w	r3, r4, #68	@ 0x44
24012d58:	4299      	cmp	r1, r3
24012d5a:	d002      	beq.n	24012d62 <__swsetup_r+0x46>
24012d5c:	4628      	mov	r0, r5
24012d5e:	f000 f871 	bl	24012e44 <_free_r>
24012d62:	2300      	movs	r3, #0
24012d64:	6363      	str	r3, [r4, #52]	@ 0x34
24012d66:	89a3      	ldrh	r3, [r4, #12]
24012d68:	f023 0324 	bic.w	r3, r3, #36	@ 0x24
24012d6c:	81a3      	strh	r3, [r4, #12]
24012d6e:	2300      	movs	r3, #0
24012d70:	6063      	str	r3, [r4, #4]
24012d72:	6923      	ldr	r3, [r4, #16]
24012d74:	6023      	str	r3, [r4, #0]
24012d76:	89a3      	ldrh	r3, [r4, #12]
24012d78:	f043 0308 	orr.w	r3, r3, #8
24012d7c:	81a3      	strh	r3, [r4, #12]
24012d7e:	6923      	ldr	r3, [r4, #16]
24012d80:	b94b      	cbnz	r3, 24012d96 <__swsetup_r+0x7a>
24012d82:	89a3      	ldrh	r3, [r4, #12]
24012d84:	f403 7320 	and.w	r3, r3, #640	@ 0x280
24012d88:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
24012d8c:	d003      	beq.n	24012d96 <__swsetup_r+0x7a>
24012d8e:	4621      	mov	r1, r4
24012d90:	4628      	mov	r0, r5
24012d92:	f000 ffaf 	bl	24013cf4 <__smakebuf_r>
24012d96:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
24012d9a:	f013 0201 	ands.w	r2, r3, #1
24012d9e:	d00a      	beq.n	24012db6 <__swsetup_r+0x9a>
24012da0:	2200      	movs	r2, #0
24012da2:	60a2      	str	r2, [r4, #8]
24012da4:	6962      	ldr	r2, [r4, #20]
24012da6:	4252      	negs	r2, r2
24012da8:	61a2      	str	r2, [r4, #24]
24012daa:	6922      	ldr	r2, [r4, #16]
24012dac:	b942      	cbnz	r2, 24012dc0 <__swsetup_r+0xa4>
24012dae:	f013 0080 	ands.w	r0, r3, #128	@ 0x80
24012db2:	d1c5      	bne.n	24012d40 <__swsetup_r+0x24>
24012db4:	bd38      	pop	{r3, r4, r5, pc}
24012db6:	0799      	lsls	r1, r3, #30
24012db8:	bf58      	it	pl
24012dba:	6962      	ldrpl	r2, [r4, #20]
24012dbc:	60a2      	str	r2, [r4, #8]
24012dbe:	e7f4      	b.n	24012daa <__swsetup_r+0x8e>
24012dc0:	2000      	movs	r0, #0
24012dc2:	e7f7      	b.n	24012db4 <__swsetup_r+0x98>
24012dc4:	2400051c 	.word	0x2400051c

24012dc8 <memset>:
24012dc8:	4402      	add	r2, r0
24012dca:	4603      	mov	r3, r0
24012dcc:	4293      	cmp	r3, r2
24012dce:	d100      	bne.n	24012dd2 <memset+0xa>
24012dd0:	4770      	bx	lr
24012dd2:	f803 1b01 	strb.w	r1, [r3], #1
24012dd6:	e7f9      	b.n	24012dcc <memset+0x4>

24012dd8 <__errno>:
24012dd8:	4b01      	ldr	r3, [pc, #4]	@ (24012de0 <__errno+0x8>)
24012dda:	6818      	ldr	r0, [r3, #0]
24012ddc:	4770      	bx	lr
24012dde:	bf00      	nop
24012de0:	2400051c 	.word	0x2400051c

24012de4 <__libc_init_array>:
24012de4:	b570      	push	{r4, r5, r6, lr}
24012de6:	4d0d      	ldr	r5, [pc, #52]	@ (24012e1c <__libc_init_array+0x38>)
24012de8:	4c0d      	ldr	r4, [pc, #52]	@ (24012e20 <__libc_init_array+0x3c>)
24012dea:	1b64      	subs	r4, r4, r5
24012dec:	10a4      	asrs	r4, r4, #2
24012dee:	2600      	movs	r6, #0
24012df0:	42a6      	cmp	r6, r4
24012df2:	d109      	bne.n	24012e08 <__libc_init_array+0x24>
24012df4:	4d0b      	ldr	r5, [pc, #44]	@ (24012e24 <__libc_init_array+0x40>)
24012df6:	4c0c      	ldr	r4, [pc, #48]	@ (24012e28 <__libc_init_array+0x44>)
24012df8:	f001 f92a 	bl	24014050 <___init_veneer>
24012dfc:	1b64      	subs	r4, r4, r5
24012dfe:	10a4      	asrs	r4, r4, #2
24012e00:	2600      	movs	r6, #0
24012e02:	42a6      	cmp	r6, r4
24012e04:	d105      	bne.n	24012e12 <__libc_init_array+0x2e>
24012e06:	bd70      	pop	{r4, r5, r6, pc}
24012e08:	f855 3b04 	ldr.w	r3, [r5], #4
24012e0c:	4798      	blx	r3
24012e0e:	3601      	adds	r6, #1
24012e10:	e7ee      	b.n	24012df0 <__libc_init_array+0xc>
24012e12:	f855 3b04 	ldr.w	r3, [r5], #4
24012e16:	4798      	blx	r3
24012e18:	3601      	adds	r6, #1
24012e1a:	e7f2      	b.n	24012e02 <__libc_init_array+0x1e>
24012e1c:	240004a0 	.word	0x240004a0
24012e20:	240004a0 	.word	0x240004a0
24012e24:	240004a0 	.word	0x240004a0
24012e28:	240004a0 	.word	0x240004a0

24012e2c <__retarget_lock_init>:
24012e2c:	4770      	bx	lr

24012e2e <__retarget_lock_init_recursive>:
24012e2e:	4770      	bx	lr

24012e30 <__retarget_lock_close>:
24012e30:	4770      	bx	lr

24012e32 <__retarget_lock_close_recursive>:
24012e32:	4770      	bx	lr

24012e34 <__retarget_lock_acquire>:
24012e34:	4770      	bx	lr

24012e36 <__retarget_lock_acquire_recursive>:
24012e36:	4770      	bx	lr

24012e38 <__retarget_lock_try_acquire>:
24012e38:	2001      	movs	r0, #1
24012e3a:	4770      	bx	lr

24012e3c <__retarget_lock_try_acquire_recursive>:
24012e3c:	2001      	movs	r0, #1
24012e3e:	4770      	bx	lr

24012e40 <__retarget_lock_release>:
24012e40:	4770      	bx	lr

24012e42 <__retarget_lock_release_recursive>:
24012e42:	4770      	bx	lr

24012e44 <_free_r>:
24012e44:	b538      	push	{r3, r4, r5, lr}
24012e46:	4605      	mov	r5, r0
24012e48:	2900      	cmp	r1, #0
24012e4a:	d041      	beq.n	24012ed0 <_free_r+0x8c>
24012e4c:	f851 3c04 	ldr.w	r3, [r1, #-4]
24012e50:	1f0c      	subs	r4, r1, #4
24012e52:	2b00      	cmp	r3, #0
24012e54:	bfb8      	it	lt
24012e56:	18e4      	addlt	r4, r4, r3
24012e58:	f000 f8e0 	bl	2401301c <__malloc_lock>
24012e5c:	4a1d      	ldr	r2, [pc, #116]	@ (24012ed4 <_free_r+0x90>)
24012e5e:	6813      	ldr	r3, [r2, #0]
24012e60:	b933      	cbnz	r3, 24012e70 <_free_r+0x2c>
24012e62:	6063      	str	r3, [r4, #4]
24012e64:	6014      	str	r4, [r2, #0]
24012e66:	4628      	mov	r0, r5
24012e68:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
24012e6c:	f000 b8dc 	b.w	24013028 <__malloc_unlock>
24012e70:	42a3      	cmp	r3, r4
24012e72:	d908      	bls.n	24012e86 <_free_r+0x42>
24012e74:	6820      	ldr	r0, [r4, #0]
24012e76:	1821      	adds	r1, r4, r0
24012e78:	428b      	cmp	r3, r1
24012e7a:	bf01      	itttt	eq
24012e7c:	6819      	ldreq	r1, [r3, #0]
24012e7e:	685b      	ldreq	r3, [r3, #4]
24012e80:	1809      	addeq	r1, r1, r0
24012e82:	6021      	streq	r1, [r4, #0]
24012e84:	e7ed      	b.n	24012e62 <_free_r+0x1e>
24012e86:	461a      	mov	r2, r3
24012e88:	685b      	ldr	r3, [r3, #4]
24012e8a:	b10b      	cbz	r3, 24012e90 <_free_r+0x4c>
24012e8c:	42a3      	cmp	r3, r4
24012e8e:	d9fa      	bls.n	24012e86 <_free_r+0x42>
24012e90:	6811      	ldr	r1, [r2, #0]
24012e92:	1850      	adds	r0, r2, r1
24012e94:	42a0      	cmp	r0, r4
24012e96:	d10b      	bne.n	24012eb0 <_free_r+0x6c>
24012e98:	6820      	ldr	r0, [r4, #0]
24012e9a:	4401      	add	r1, r0
24012e9c:	1850      	adds	r0, r2, r1
24012e9e:	4283      	cmp	r3, r0
24012ea0:	6011      	str	r1, [r2, #0]
24012ea2:	d1e0      	bne.n	24012e66 <_free_r+0x22>
24012ea4:	6818      	ldr	r0, [r3, #0]
24012ea6:	685b      	ldr	r3, [r3, #4]
24012ea8:	6053      	str	r3, [r2, #4]
24012eaa:	4408      	add	r0, r1
24012eac:	6010      	str	r0, [r2, #0]
24012eae:	e7da      	b.n	24012e66 <_free_r+0x22>
24012eb0:	d902      	bls.n	24012eb8 <_free_r+0x74>
24012eb2:	230c      	movs	r3, #12
24012eb4:	602b      	str	r3, [r5, #0]
24012eb6:	e7d6      	b.n	24012e66 <_free_r+0x22>
24012eb8:	6820      	ldr	r0, [r4, #0]
24012eba:	1821      	adds	r1, r4, r0
24012ebc:	428b      	cmp	r3, r1
24012ebe:	bf04      	itt	eq
24012ec0:	6819      	ldreq	r1, [r3, #0]
24012ec2:	685b      	ldreq	r3, [r3, #4]
24012ec4:	6063      	str	r3, [r4, #4]
24012ec6:	bf04      	itt	eq
24012ec8:	1809      	addeq	r1, r1, r0
24012eca:	6021      	streq	r1, [r4, #0]
24012ecc:	6054      	str	r4, [r2, #4]
24012ece:	e7ca      	b.n	24012e66 <_free_r+0x22>
24012ed0:	bd38      	pop	{r3, r4, r5, pc}
24012ed2:	bf00      	nop
24012ed4:	240006c8 	.word	0x240006c8

24012ed8 <sbrk_aligned>:
24012ed8:	b570      	push	{r4, r5, r6, lr}
24012eda:	4e0f      	ldr	r6, [pc, #60]	@ (24012f18 <sbrk_aligned+0x40>)
24012edc:	460c      	mov	r4, r1
24012ede:	6831      	ldr	r1, [r6, #0]
24012ee0:	4605      	mov	r5, r0
24012ee2:	b911      	cbnz	r1, 24012eea <sbrk_aligned+0x12>
24012ee4:	f001 f84e 	bl	24013f84 <_sbrk_r>
24012ee8:	6030      	str	r0, [r6, #0]
24012eea:	4621      	mov	r1, r4
24012eec:	4628      	mov	r0, r5
24012eee:	f001 f849 	bl	24013f84 <_sbrk_r>
24012ef2:	1c43      	adds	r3, r0, #1
24012ef4:	d103      	bne.n	24012efe <sbrk_aligned+0x26>
24012ef6:	f04f 34ff 	mov.w	r4, #4294967295
24012efa:	4620      	mov	r0, r4
24012efc:	bd70      	pop	{r4, r5, r6, pc}
24012efe:	1cc4      	adds	r4, r0, #3
24012f00:	f024 0403 	bic.w	r4, r4, #3
24012f04:	42a0      	cmp	r0, r4
24012f06:	d0f8      	beq.n	24012efa <sbrk_aligned+0x22>
24012f08:	1a21      	subs	r1, r4, r0
24012f0a:	4628      	mov	r0, r5
24012f0c:	f001 f83a 	bl	24013f84 <_sbrk_r>
24012f10:	3001      	adds	r0, #1
24012f12:	d1f2      	bne.n	24012efa <sbrk_aligned+0x22>
24012f14:	e7ef      	b.n	24012ef6 <sbrk_aligned+0x1e>
24012f16:	bf00      	nop
24012f18:	240006c4 	.word	0x240006c4

24012f1c <_malloc_r>:
24012f1c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
24012f20:	1ccd      	adds	r5, r1, #3
24012f22:	f025 0503 	bic.w	r5, r5, #3
24012f26:	3508      	adds	r5, #8
24012f28:	2d0c      	cmp	r5, #12
24012f2a:	bf38      	it	cc
24012f2c:	250c      	movcc	r5, #12
24012f2e:	2d00      	cmp	r5, #0
24012f30:	4606      	mov	r6, r0
24012f32:	db01      	blt.n	24012f38 <_malloc_r+0x1c>
24012f34:	42a9      	cmp	r1, r5
24012f36:	d904      	bls.n	24012f42 <_malloc_r+0x26>
24012f38:	230c      	movs	r3, #12
24012f3a:	6033      	str	r3, [r6, #0]
24012f3c:	2000      	movs	r0, #0
24012f3e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
24012f42:	f8df 80d4 	ldr.w	r8, [pc, #212]	@ 24013018 <_malloc_r+0xfc>
24012f46:	f000 f869 	bl	2401301c <__malloc_lock>
24012f4a:	f8d8 3000 	ldr.w	r3, [r8]
24012f4e:	461c      	mov	r4, r3
24012f50:	bb44      	cbnz	r4, 24012fa4 <_malloc_r+0x88>
24012f52:	4629      	mov	r1, r5
24012f54:	4630      	mov	r0, r6
24012f56:	f7ff ffbf 	bl	24012ed8 <sbrk_aligned>
24012f5a:	1c43      	adds	r3, r0, #1
24012f5c:	4604      	mov	r4, r0
24012f5e:	d158      	bne.n	24013012 <_malloc_r+0xf6>
24012f60:	f8d8 4000 	ldr.w	r4, [r8]
24012f64:	4627      	mov	r7, r4
24012f66:	2f00      	cmp	r7, #0
24012f68:	d143      	bne.n	24012ff2 <_malloc_r+0xd6>
24012f6a:	2c00      	cmp	r4, #0
24012f6c:	d04b      	beq.n	24013006 <_malloc_r+0xea>
24012f6e:	6823      	ldr	r3, [r4, #0]
24012f70:	4639      	mov	r1, r7
24012f72:	4630      	mov	r0, r6
24012f74:	eb04 0903 	add.w	r9, r4, r3
24012f78:	f001 f804 	bl	24013f84 <_sbrk_r>
24012f7c:	4581      	cmp	r9, r0
24012f7e:	d142      	bne.n	24013006 <_malloc_r+0xea>
24012f80:	6821      	ldr	r1, [r4, #0]
24012f82:	1a6d      	subs	r5, r5, r1
24012f84:	4629      	mov	r1, r5
24012f86:	4630      	mov	r0, r6
24012f88:	f7ff ffa6 	bl	24012ed8 <sbrk_aligned>
24012f8c:	3001      	adds	r0, #1
24012f8e:	d03a      	beq.n	24013006 <_malloc_r+0xea>
24012f90:	6823      	ldr	r3, [r4, #0]
24012f92:	442b      	add	r3, r5
24012f94:	6023      	str	r3, [r4, #0]
24012f96:	f8d8 3000 	ldr.w	r3, [r8]
24012f9a:	685a      	ldr	r2, [r3, #4]
24012f9c:	bb62      	cbnz	r2, 24012ff8 <_malloc_r+0xdc>
24012f9e:	f8c8 7000 	str.w	r7, [r8]
24012fa2:	e00f      	b.n	24012fc4 <_malloc_r+0xa8>
24012fa4:	6822      	ldr	r2, [r4, #0]
24012fa6:	1b52      	subs	r2, r2, r5
24012fa8:	d420      	bmi.n	24012fec <_malloc_r+0xd0>
24012faa:	2a0b      	cmp	r2, #11
24012fac:	d917      	bls.n	24012fde <_malloc_r+0xc2>
24012fae:	1961      	adds	r1, r4, r5
24012fb0:	42a3      	cmp	r3, r4
24012fb2:	6025      	str	r5, [r4, #0]
24012fb4:	bf18      	it	ne
24012fb6:	6059      	strne	r1, [r3, #4]
24012fb8:	6863      	ldr	r3, [r4, #4]
24012fba:	bf08      	it	eq
24012fbc:	f8c8 1000 	streq.w	r1, [r8]
24012fc0:	5162      	str	r2, [r4, r5]
24012fc2:	604b      	str	r3, [r1, #4]
24012fc4:	4630      	mov	r0, r6
24012fc6:	f000 f82f 	bl	24013028 <__malloc_unlock>
24012fca:	f104 000b 	add.w	r0, r4, #11
24012fce:	1d23      	adds	r3, r4, #4
24012fd0:	f020 0007 	bic.w	r0, r0, #7
24012fd4:	1ac2      	subs	r2, r0, r3
24012fd6:	bf1c      	itt	ne
24012fd8:	1a1b      	subne	r3, r3, r0
24012fda:	50a3      	strne	r3, [r4, r2]
24012fdc:	e7af      	b.n	24012f3e <_malloc_r+0x22>
24012fde:	6862      	ldr	r2, [r4, #4]
24012fe0:	42a3      	cmp	r3, r4
24012fe2:	bf0c      	ite	eq
24012fe4:	f8c8 2000 	streq.w	r2, [r8]
24012fe8:	605a      	strne	r2, [r3, #4]
24012fea:	e7eb      	b.n	24012fc4 <_malloc_r+0xa8>
24012fec:	4623      	mov	r3, r4
24012fee:	6864      	ldr	r4, [r4, #4]
24012ff0:	e7ae      	b.n	24012f50 <_malloc_r+0x34>
24012ff2:	463c      	mov	r4, r7
24012ff4:	687f      	ldr	r7, [r7, #4]
24012ff6:	e7b6      	b.n	24012f66 <_malloc_r+0x4a>
24012ff8:	461a      	mov	r2, r3
24012ffa:	685b      	ldr	r3, [r3, #4]
24012ffc:	42a3      	cmp	r3, r4
24012ffe:	d1fb      	bne.n	24012ff8 <_malloc_r+0xdc>
24013000:	2300      	movs	r3, #0
24013002:	6053      	str	r3, [r2, #4]
24013004:	e7de      	b.n	24012fc4 <_malloc_r+0xa8>
24013006:	230c      	movs	r3, #12
24013008:	6033      	str	r3, [r6, #0]
2401300a:	4630      	mov	r0, r6
2401300c:	f000 f80c 	bl	24013028 <__malloc_unlock>
24013010:	e794      	b.n	24012f3c <_malloc_r+0x20>
24013012:	6005      	str	r5, [r0, #0]
24013014:	e7d6      	b.n	24012fc4 <_malloc_r+0xa8>
24013016:	bf00      	nop
24013018:	240006c8 	.word	0x240006c8

2401301c <__malloc_lock>:
2401301c:	4801      	ldr	r0, [pc, #4]	@ (24013024 <__malloc_lock+0x8>)
2401301e:	f7ff bf0a 	b.w	24012e36 <__retarget_lock_acquire_recursive>
24013022:	bf00      	nop
24013024:	240006c0 	.word	0x240006c0

24013028 <__malloc_unlock>:
24013028:	4801      	ldr	r0, [pc, #4]	@ (24013030 <__malloc_unlock+0x8>)
2401302a:	f7ff bf0a 	b.w	24012e42 <__retarget_lock_release_recursive>
2401302e:	bf00      	nop
24013030:	240006c0 	.word	0x240006c0

24013034 <__sfputc_r>:
24013034:	6893      	ldr	r3, [r2, #8]
24013036:	3b01      	subs	r3, #1
24013038:	2b00      	cmp	r3, #0
2401303a:	b410      	push	{r4}
2401303c:	6093      	str	r3, [r2, #8]
2401303e:	da08      	bge.n	24013052 <__sfputc_r+0x1e>
24013040:	6994      	ldr	r4, [r2, #24]
24013042:	42a3      	cmp	r3, r4
24013044:	db01      	blt.n	2401304a <__sfputc_r+0x16>
24013046:	290a      	cmp	r1, #10
24013048:	d103      	bne.n	24013052 <__sfputc_r+0x1e>
2401304a:	f85d 4b04 	ldr.w	r4, [sp], #4
2401304e:	f7ff be1f 	b.w	24012c90 <__swbuf_r>
24013052:	6813      	ldr	r3, [r2, #0]
24013054:	1c58      	adds	r0, r3, #1
24013056:	6010      	str	r0, [r2, #0]
24013058:	7019      	strb	r1, [r3, #0]
2401305a:	4608      	mov	r0, r1
2401305c:	f85d 4b04 	ldr.w	r4, [sp], #4
24013060:	4770      	bx	lr

24013062 <__sfputs_r>:
24013062:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
24013064:	4606      	mov	r6, r0
24013066:	460f      	mov	r7, r1
24013068:	4614      	mov	r4, r2
2401306a:	18d5      	adds	r5, r2, r3
2401306c:	42ac      	cmp	r4, r5
2401306e:	d101      	bne.n	24013074 <__sfputs_r+0x12>
24013070:	2000      	movs	r0, #0
24013072:	e007      	b.n	24013084 <__sfputs_r+0x22>
24013074:	f814 1b01 	ldrb.w	r1, [r4], #1
24013078:	463a      	mov	r2, r7
2401307a:	4630      	mov	r0, r6
2401307c:	f7ff ffda 	bl	24013034 <__sfputc_r>
24013080:	1c43      	adds	r3, r0, #1
24013082:	d1f3      	bne.n	2401306c <__sfputs_r+0xa>
24013084:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

24013086 <__sprint_r>:
24013086:	6893      	ldr	r3, [r2, #8]
24013088:	b510      	push	{r4, lr}
2401308a:	4614      	mov	r4, r2
2401308c:	b133      	cbz	r3, 2401309c <__sprint_r+0x16>
2401308e:	f000 fca1 	bl	240139d4 <__sfvwrite_r>
24013092:	2300      	movs	r3, #0
24013094:	60a3      	str	r3, [r4, #8]
24013096:	2300      	movs	r3, #0
24013098:	6063      	str	r3, [r4, #4]
2401309a:	bd10      	pop	{r4, pc}
2401309c:	4618      	mov	r0, r3
2401309e:	e7fa      	b.n	24013096 <__sprint_r+0x10>

240130a0 <_vfiprintf_r>:
240130a0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
240130a4:	460d      	mov	r5, r1
240130a6:	b09d      	sub	sp, #116	@ 0x74
240130a8:	4614      	mov	r4, r2
240130aa:	4698      	mov	r8, r3
240130ac:	4606      	mov	r6, r0
240130ae:	b118      	cbz	r0, 240130b8 <_vfiprintf_r+0x18>
240130b0:	6a03      	ldr	r3, [r0, #32]
240130b2:	b90b      	cbnz	r3, 240130b8 <_vfiprintf_r+0x18>
240130b4:	f000 fc5a 	bl	2401396c <__sinit>
240130b8:	6e6b      	ldr	r3, [r5, #100]	@ 0x64
240130ba:	07d9      	lsls	r1, r3, #31
240130bc:	d405      	bmi.n	240130ca <_vfiprintf_r+0x2a>
240130be:	89ab      	ldrh	r3, [r5, #12]
240130c0:	059a      	lsls	r2, r3, #22
240130c2:	d402      	bmi.n	240130ca <_vfiprintf_r+0x2a>
240130c4:	6da8      	ldr	r0, [r5, #88]	@ 0x58
240130c6:	f7ff feb6 	bl	24012e36 <__retarget_lock_acquire_recursive>
240130ca:	89ab      	ldrh	r3, [r5, #12]
240130cc:	071b      	lsls	r3, r3, #28
240130ce:	d501      	bpl.n	240130d4 <_vfiprintf_r+0x34>
240130d0:	692b      	ldr	r3, [r5, #16]
240130d2:	b99b      	cbnz	r3, 240130fc <_vfiprintf_r+0x5c>
240130d4:	4629      	mov	r1, r5
240130d6:	4630      	mov	r0, r6
240130d8:	f7ff fe20 	bl	24012d1c <__swsetup_r>
240130dc:	b170      	cbz	r0, 240130fc <_vfiprintf_r+0x5c>
240130de:	6e6b      	ldr	r3, [r5, #100]	@ 0x64
240130e0:	07dc      	lsls	r4, r3, #31
240130e2:	d504      	bpl.n	240130ee <_vfiprintf_r+0x4e>
240130e4:	f04f 30ff 	mov.w	r0, #4294967295
240130e8:	b01d      	add	sp, #116	@ 0x74
240130ea:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
240130ee:	89ab      	ldrh	r3, [r5, #12]
240130f0:	0598      	lsls	r0, r3, #22
240130f2:	d4f7      	bmi.n	240130e4 <_vfiprintf_r+0x44>
240130f4:	6da8      	ldr	r0, [r5, #88]	@ 0x58
240130f6:	f7ff fea4 	bl	24012e42 <__retarget_lock_release_recursive>
240130fa:	e7f3      	b.n	240130e4 <_vfiprintf_r+0x44>
240130fc:	2300      	movs	r3, #0
240130fe:	9309      	str	r3, [sp, #36]	@ 0x24
24013100:	2320      	movs	r3, #32
24013102:	f88d 3029 	strb.w	r3, [sp, #41]	@ 0x29
24013106:	f8cd 800c 	str.w	r8, [sp, #12]
2401310a:	2330      	movs	r3, #48	@ 0x30
2401310c:	f8df 81ac 	ldr.w	r8, [pc, #428]	@ 240132bc <_vfiprintf_r+0x21c>
24013110:	f88d 302a 	strb.w	r3, [sp, #42]	@ 0x2a
24013114:	f04f 0901 	mov.w	r9, #1
24013118:	4623      	mov	r3, r4
2401311a:	469a      	mov	sl, r3
2401311c:	f813 2b01 	ldrb.w	r2, [r3], #1
24013120:	b10a      	cbz	r2, 24013126 <_vfiprintf_r+0x86>
24013122:	2a25      	cmp	r2, #37	@ 0x25
24013124:	d1f9      	bne.n	2401311a <_vfiprintf_r+0x7a>
24013126:	ebba 0b04 	subs.w	fp, sl, r4
2401312a:	d00b      	beq.n	24013144 <_vfiprintf_r+0xa4>
2401312c:	465b      	mov	r3, fp
2401312e:	4622      	mov	r2, r4
24013130:	4629      	mov	r1, r5
24013132:	4630      	mov	r0, r6
24013134:	f7ff ff95 	bl	24013062 <__sfputs_r>
24013138:	3001      	adds	r0, #1
2401313a:	f000 80a7 	beq.w	2401328c <_vfiprintf_r+0x1ec>
2401313e:	9a09      	ldr	r2, [sp, #36]	@ 0x24
24013140:	445a      	add	r2, fp
24013142:	9209      	str	r2, [sp, #36]	@ 0x24
24013144:	f89a 3000 	ldrb.w	r3, [sl]
24013148:	2b00      	cmp	r3, #0
2401314a:	f000 809f 	beq.w	2401328c <_vfiprintf_r+0x1ec>
2401314e:	2300      	movs	r3, #0
24013150:	f04f 32ff 	mov.w	r2, #4294967295
24013154:	e9cd 2305 	strd	r2, r3, [sp, #20]
24013158:	f10a 0a01 	add.w	sl, sl, #1
2401315c:	9304      	str	r3, [sp, #16]
2401315e:	9307      	str	r3, [sp, #28]
24013160:	f88d 3053 	strb.w	r3, [sp, #83]	@ 0x53
24013164:	931a      	str	r3, [sp, #104]	@ 0x68
24013166:	4654      	mov	r4, sl
24013168:	2205      	movs	r2, #5
2401316a:	f814 1b01 	ldrb.w	r1, [r4], #1
2401316e:	4853      	ldr	r0, [pc, #332]	@ (240132bc <_vfiprintf_r+0x21c>)
24013170:	f7ff fc96 	bl	24012aa0 <memchr>
24013174:	9a04      	ldr	r2, [sp, #16]
24013176:	b9d8      	cbnz	r0, 240131b0 <_vfiprintf_r+0x110>
24013178:	06d1      	lsls	r1, r2, #27
2401317a:	bf44      	itt	mi
2401317c:	2320      	movmi	r3, #32
2401317e:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
24013182:	0713      	lsls	r3, r2, #28
24013184:	bf44      	itt	mi
24013186:	232b      	movmi	r3, #43	@ 0x2b
24013188:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
2401318c:	f89a 3000 	ldrb.w	r3, [sl]
24013190:	2b2a      	cmp	r3, #42	@ 0x2a
24013192:	d015      	beq.n	240131c0 <_vfiprintf_r+0x120>
24013194:	9a07      	ldr	r2, [sp, #28]
24013196:	4654      	mov	r4, sl
24013198:	2000      	movs	r0, #0
2401319a:	f04f 0c0a 	mov.w	ip, #10
2401319e:	4621      	mov	r1, r4
240131a0:	f811 3b01 	ldrb.w	r3, [r1], #1
240131a4:	3b30      	subs	r3, #48	@ 0x30
240131a6:	2b09      	cmp	r3, #9
240131a8:	d94b      	bls.n	24013242 <_vfiprintf_r+0x1a2>
240131aa:	b1b0      	cbz	r0, 240131da <_vfiprintf_r+0x13a>
240131ac:	9207      	str	r2, [sp, #28]
240131ae:	e014      	b.n	240131da <_vfiprintf_r+0x13a>
240131b0:	eba0 0308 	sub.w	r3, r0, r8
240131b4:	fa09 f303 	lsl.w	r3, r9, r3
240131b8:	4313      	orrs	r3, r2
240131ba:	9304      	str	r3, [sp, #16]
240131bc:	46a2      	mov	sl, r4
240131be:	e7d2      	b.n	24013166 <_vfiprintf_r+0xc6>
240131c0:	9b03      	ldr	r3, [sp, #12]
240131c2:	1d19      	adds	r1, r3, #4
240131c4:	681b      	ldr	r3, [r3, #0]
240131c6:	9103      	str	r1, [sp, #12]
240131c8:	2b00      	cmp	r3, #0
240131ca:	bfbb      	ittet	lt
240131cc:	425b      	neglt	r3, r3
240131ce:	f042 0202 	orrlt.w	r2, r2, #2
240131d2:	9307      	strge	r3, [sp, #28]
240131d4:	9307      	strlt	r3, [sp, #28]
240131d6:	bfb8      	it	lt
240131d8:	9204      	strlt	r2, [sp, #16]
240131da:	7823      	ldrb	r3, [r4, #0]
240131dc:	2b2e      	cmp	r3, #46	@ 0x2e
240131de:	d10a      	bne.n	240131f6 <_vfiprintf_r+0x156>
240131e0:	7863      	ldrb	r3, [r4, #1]
240131e2:	2b2a      	cmp	r3, #42	@ 0x2a
240131e4:	d132      	bne.n	2401324c <_vfiprintf_r+0x1ac>
240131e6:	9b03      	ldr	r3, [sp, #12]
240131e8:	1d1a      	adds	r2, r3, #4
240131ea:	681b      	ldr	r3, [r3, #0]
240131ec:	9203      	str	r2, [sp, #12]
240131ee:	ea43 73e3 	orr.w	r3, r3, r3, asr #31
240131f2:	3402      	adds	r4, #2
240131f4:	9305      	str	r3, [sp, #20]
240131f6:	f8df a0d4 	ldr.w	sl, [pc, #212]	@ 240132cc <_vfiprintf_r+0x22c>
240131fa:	7821      	ldrb	r1, [r4, #0]
240131fc:	2203      	movs	r2, #3
240131fe:	4650      	mov	r0, sl
24013200:	f7ff fc4e 	bl	24012aa0 <memchr>
24013204:	b138      	cbz	r0, 24013216 <_vfiprintf_r+0x176>
24013206:	9b04      	ldr	r3, [sp, #16]
24013208:	eba0 000a 	sub.w	r0, r0, sl
2401320c:	2240      	movs	r2, #64	@ 0x40
2401320e:	4082      	lsls	r2, r0
24013210:	4313      	orrs	r3, r2
24013212:	3401      	adds	r4, #1
24013214:	9304      	str	r3, [sp, #16]
24013216:	f814 1b01 	ldrb.w	r1, [r4], #1
2401321a:	4829      	ldr	r0, [pc, #164]	@ (240132c0 <_vfiprintf_r+0x220>)
2401321c:	f88d 1028 	strb.w	r1, [sp, #40]	@ 0x28
24013220:	2206      	movs	r2, #6
24013222:	f7ff fc3d 	bl	24012aa0 <memchr>
24013226:	2800      	cmp	r0, #0
24013228:	d03f      	beq.n	240132aa <_vfiprintf_r+0x20a>
2401322a:	4b26      	ldr	r3, [pc, #152]	@ (240132c4 <_vfiprintf_r+0x224>)
2401322c:	bb1b      	cbnz	r3, 24013276 <_vfiprintf_r+0x1d6>
2401322e:	9b03      	ldr	r3, [sp, #12]
24013230:	3307      	adds	r3, #7
24013232:	f023 0307 	bic.w	r3, r3, #7
24013236:	3308      	adds	r3, #8
24013238:	9303      	str	r3, [sp, #12]
2401323a:	9b09      	ldr	r3, [sp, #36]	@ 0x24
2401323c:	443b      	add	r3, r7
2401323e:	9309      	str	r3, [sp, #36]	@ 0x24
24013240:	e76a      	b.n	24013118 <_vfiprintf_r+0x78>
24013242:	fb0c 3202 	mla	r2, ip, r2, r3
24013246:	460c      	mov	r4, r1
24013248:	2001      	movs	r0, #1
2401324a:	e7a8      	b.n	2401319e <_vfiprintf_r+0xfe>
2401324c:	2300      	movs	r3, #0
2401324e:	3401      	adds	r4, #1
24013250:	9305      	str	r3, [sp, #20]
24013252:	4619      	mov	r1, r3
24013254:	f04f 0c0a 	mov.w	ip, #10
24013258:	4620      	mov	r0, r4
2401325a:	f810 2b01 	ldrb.w	r2, [r0], #1
2401325e:	3a30      	subs	r2, #48	@ 0x30
24013260:	2a09      	cmp	r2, #9
24013262:	d903      	bls.n	2401326c <_vfiprintf_r+0x1cc>
24013264:	2b00      	cmp	r3, #0
24013266:	d0c6      	beq.n	240131f6 <_vfiprintf_r+0x156>
24013268:	9105      	str	r1, [sp, #20]
2401326a:	e7c4      	b.n	240131f6 <_vfiprintf_r+0x156>
2401326c:	fb0c 2101 	mla	r1, ip, r1, r2
24013270:	4604      	mov	r4, r0
24013272:	2301      	movs	r3, #1
24013274:	e7f0      	b.n	24013258 <_vfiprintf_r+0x1b8>
24013276:	ab03      	add	r3, sp, #12
24013278:	9300      	str	r3, [sp, #0]
2401327a:	462a      	mov	r2, r5
2401327c:	4b12      	ldr	r3, [pc, #72]	@ (240132c8 <_vfiprintf_r+0x228>)
2401327e:	a904      	add	r1, sp, #16
24013280:	4630      	mov	r0, r6
24013282:	f3af 8000 	nop.w
24013286:	4607      	mov	r7, r0
24013288:	1c78      	adds	r0, r7, #1
2401328a:	d1d6      	bne.n	2401323a <_vfiprintf_r+0x19a>
2401328c:	6e6b      	ldr	r3, [r5, #100]	@ 0x64
2401328e:	07d9      	lsls	r1, r3, #31
24013290:	d405      	bmi.n	2401329e <_vfiprintf_r+0x1fe>
24013292:	89ab      	ldrh	r3, [r5, #12]
24013294:	059a      	lsls	r2, r3, #22
24013296:	d402      	bmi.n	2401329e <_vfiprintf_r+0x1fe>
24013298:	6da8      	ldr	r0, [r5, #88]	@ 0x58
2401329a:	f7ff fdd2 	bl	24012e42 <__retarget_lock_release_recursive>
2401329e:	89ab      	ldrh	r3, [r5, #12]
240132a0:	065b      	lsls	r3, r3, #25
240132a2:	f53f af1f 	bmi.w	240130e4 <_vfiprintf_r+0x44>
240132a6:	9809      	ldr	r0, [sp, #36]	@ 0x24
240132a8:	e71e      	b.n	240130e8 <_vfiprintf_r+0x48>
240132aa:	ab03      	add	r3, sp, #12
240132ac:	9300      	str	r3, [sp, #0]
240132ae:	462a      	mov	r2, r5
240132b0:	4b05      	ldr	r3, [pc, #20]	@ (240132c8 <_vfiprintf_r+0x228>)
240132b2:	a904      	add	r1, sp, #16
240132b4:	4630      	mov	r0, r6
240132b6:	f000 f883 	bl	240133c0 <_printf_i>
240132ba:	e7e4      	b.n	24013286 <_vfiprintf_r+0x1e6>
240132bc:	240143a6 	.word	0x240143a6
240132c0:	240143b0 	.word	0x240143b0
240132c4:	00000000 	.word	0x00000000
240132c8:	24013063 	.word	0x24013063
240132cc:	240143ac 	.word	0x240143ac

240132d0 <vfiprintf>:
240132d0:	4613      	mov	r3, r2
240132d2:	460a      	mov	r2, r1
240132d4:	4601      	mov	r1, r0
240132d6:	4802      	ldr	r0, [pc, #8]	@ (240132e0 <vfiprintf+0x10>)
240132d8:	6800      	ldr	r0, [r0, #0]
240132da:	f7ff bee1 	b.w	240130a0 <_vfiprintf_r>
240132de:	bf00      	nop
240132e0:	2400051c 	.word	0x2400051c

240132e4 <_printf_common>:
240132e4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
240132e8:	4616      	mov	r6, r2
240132ea:	4698      	mov	r8, r3
240132ec:	688a      	ldr	r2, [r1, #8]
240132ee:	690b      	ldr	r3, [r1, #16]
240132f0:	f8dd 9020 	ldr.w	r9, [sp, #32]
240132f4:	4293      	cmp	r3, r2
240132f6:	bfb8      	it	lt
240132f8:	4613      	movlt	r3, r2
240132fa:	6033      	str	r3, [r6, #0]
240132fc:	f891 2043 	ldrb.w	r2, [r1, #67]	@ 0x43
24013300:	4607      	mov	r7, r0
24013302:	460c      	mov	r4, r1
24013304:	b10a      	cbz	r2, 2401330a <_printf_common+0x26>
24013306:	3301      	adds	r3, #1
24013308:	6033      	str	r3, [r6, #0]
2401330a:	6823      	ldr	r3, [r4, #0]
2401330c:	0699      	lsls	r1, r3, #26
2401330e:	bf42      	ittt	mi
24013310:	6833      	ldrmi	r3, [r6, #0]
24013312:	3302      	addmi	r3, #2
24013314:	6033      	strmi	r3, [r6, #0]
24013316:	6825      	ldr	r5, [r4, #0]
24013318:	f015 0506 	ands.w	r5, r5, #6
2401331c:	d106      	bne.n	2401332c <_printf_common+0x48>
2401331e:	f104 0a19 	add.w	sl, r4, #25
24013322:	68e3      	ldr	r3, [r4, #12]
24013324:	6832      	ldr	r2, [r6, #0]
24013326:	1a9b      	subs	r3, r3, r2
24013328:	42ab      	cmp	r3, r5
2401332a:	dc26      	bgt.n	2401337a <_printf_common+0x96>
2401332c:	f894 3043 	ldrb.w	r3, [r4, #67]	@ 0x43
24013330:	6822      	ldr	r2, [r4, #0]
24013332:	3b00      	subs	r3, #0
24013334:	bf18      	it	ne
24013336:	2301      	movne	r3, #1
24013338:	0692      	lsls	r2, r2, #26
2401333a:	d42b      	bmi.n	24013394 <_printf_common+0xb0>
2401333c:	f104 0243 	add.w	r2, r4, #67	@ 0x43
24013340:	4641      	mov	r1, r8
24013342:	4638      	mov	r0, r7
24013344:	47c8      	blx	r9
24013346:	3001      	adds	r0, #1
24013348:	d01e      	beq.n	24013388 <_printf_common+0xa4>
2401334a:	6823      	ldr	r3, [r4, #0]
2401334c:	6922      	ldr	r2, [r4, #16]
2401334e:	f003 0306 	and.w	r3, r3, #6
24013352:	2b04      	cmp	r3, #4
24013354:	bf02      	ittt	eq
24013356:	68e5      	ldreq	r5, [r4, #12]
24013358:	6833      	ldreq	r3, [r6, #0]
2401335a:	1aed      	subeq	r5, r5, r3
2401335c:	68a3      	ldr	r3, [r4, #8]
2401335e:	bf0c      	ite	eq
24013360:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
24013364:	2500      	movne	r5, #0
24013366:	4293      	cmp	r3, r2
24013368:	bfc4      	itt	gt
2401336a:	1a9b      	subgt	r3, r3, r2
2401336c:	18ed      	addgt	r5, r5, r3
2401336e:	2600      	movs	r6, #0
24013370:	341a      	adds	r4, #26
24013372:	42b5      	cmp	r5, r6
24013374:	d11a      	bne.n	240133ac <_printf_common+0xc8>
24013376:	2000      	movs	r0, #0
24013378:	e008      	b.n	2401338c <_printf_common+0xa8>
2401337a:	2301      	movs	r3, #1
2401337c:	4652      	mov	r2, sl
2401337e:	4641      	mov	r1, r8
24013380:	4638      	mov	r0, r7
24013382:	47c8      	blx	r9
24013384:	3001      	adds	r0, #1
24013386:	d103      	bne.n	24013390 <_printf_common+0xac>
24013388:	f04f 30ff 	mov.w	r0, #4294967295
2401338c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
24013390:	3501      	adds	r5, #1
24013392:	e7c6      	b.n	24013322 <_printf_common+0x3e>
24013394:	18e1      	adds	r1, r4, r3
24013396:	1c5a      	adds	r2, r3, #1
24013398:	2030      	movs	r0, #48	@ 0x30
2401339a:	f881 0043 	strb.w	r0, [r1, #67]	@ 0x43
2401339e:	4422      	add	r2, r4
240133a0:	f894 1045 	ldrb.w	r1, [r4, #69]	@ 0x45
240133a4:	f882 1043 	strb.w	r1, [r2, #67]	@ 0x43
240133a8:	3302      	adds	r3, #2
240133aa:	e7c7      	b.n	2401333c <_printf_common+0x58>
240133ac:	2301      	movs	r3, #1
240133ae:	4622      	mov	r2, r4
240133b0:	4641      	mov	r1, r8
240133b2:	4638      	mov	r0, r7
240133b4:	47c8      	blx	r9
240133b6:	3001      	adds	r0, #1
240133b8:	d0e6      	beq.n	24013388 <_printf_common+0xa4>
240133ba:	3601      	adds	r6, #1
240133bc:	e7d9      	b.n	24013372 <_printf_common+0x8e>
	...

240133c0 <_printf_i>:
240133c0:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
240133c4:	7e0f      	ldrb	r7, [r1, #24]
240133c6:	9e0c      	ldr	r6, [sp, #48]	@ 0x30
240133c8:	2f78      	cmp	r7, #120	@ 0x78
240133ca:	4691      	mov	r9, r2
240133cc:	4680      	mov	r8, r0
240133ce:	460c      	mov	r4, r1
240133d0:	469a      	mov	sl, r3
240133d2:	f101 0243 	add.w	r2, r1, #67	@ 0x43
240133d6:	d807      	bhi.n	240133e8 <_printf_i+0x28>
240133d8:	2f62      	cmp	r7, #98	@ 0x62
240133da:	d80a      	bhi.n	240133f2 <_printf_i+0x32>
240133dc:	2f00      	cmp	r7, #0
240133de:	f000 80d2 	beq.w	24013586 <_printf_i+0x1c6>
240133e2:	2f58      	cmp	r7, #88	@ 0x58
240133e4:	f000 80b9 	beq.w	2401355a <_printf_i+0x19a>
240133e8:	f104 0642 	add.w	r6, r4, #66	@ 0x42
240133ec:	f884 7042 	strb.w	r7, [r4, #66]	@ 0x42
240133f0:	e03a      	b.n	24013468 <_printf_i+0xa8>
240133f2:	f1a7 0363 	sub.w	r3, r7, #99	@ 0x63
240133f6:	2b15      	cmp	r3, #21
240133f8:	d8f6      	bhi.n	240133e8 <_printf_i+0x28>
240133fa:	a101      	add	r1, pc, #4	@ (adr r1, 24013400 <_printf_i+0x40>)
240133fc:	f851 f023 	ldr.w	pc, [r1, r3, lsl #2]
24013400:	24013459 	.word	0x24013459
24013404:	2401346d 	.word	0x2401346d
24013408:	240133e9 	.word	0x240133e9
2401340c:	240133e9 	.word	0x240133e9
24013410:	240133e9 	.word	0x240133e9
24013414:	240133e9 	.word	0x240133e9
24013418:	2401346d 	.word	0x2401346d
2401341c:	240133e9 	.word	0x240133e9
24013420:	240133e9 	.word	0x240133e9
24013424:	240133e9 	.word	0x240133e9
24013428:	240133e9 	.word	0x240133e9
2401342c:	2401356d 	.word	0x2401356d
24013430:	24013497 	.word	0x24013497
24013434:	24013527 	.word	0x24013527
24013438:	240133e9 	.word	0x240133e9
2401343c:	240133e9 	.word	0x240133e9
24013440:	2401358f 	.word	0x2401358f
24013444:	240133e9 	.word	0x240133e9
24013448:	24013497 	.word	0x24013497
2401344c:	240133e9 	.word	0x240133e9
24013450:	240133e9 	.word	0x240133e9
24013454:	2401352f 	.word	0x2401352f
24013458:	6833      	ldr	r3, [r6, #0]
2401345a:	1d1a      	adds	r2, r3, #4
2401345c:	681b      	ldr	r3, [r3, #0]
2401345e:	6032      	str	r2, [r6, #0]
24013460:	f104 0642 	add.w	r6, r4, #66	@ 0x42
24013464:	f884 3042 	strb.w	r3, [r4, #66]	@ 0x42
24013468:	2301      	movs	r3, #1
2401346a:	e09d      	b.n	240135a8 <_printf_i+0x1e8>
2401346c:	6833      	ldr	r3, [r6, #0]
2401346e:	6820      	ldr	r0, [r4, #0]
24013470:	1d19      	adds	r1, r3, #4
24013472:	6031      	str	r1, [r6, #0]
24013474:	0606      	lsls	r6, r0, #24
24013476:	d501      	bpl.n	2401347c <_printf_i+0xbc>
24013478:	681d      	ldr	r5, [r3, #0]
2401347a:	e003      	b.n	24013484 <_printf_i+0xc4>
2401347c:	0645      	lsls	r5, r0, #25
2401347e:	d5fb      	bpl.n	24013478 <_printf_i+0xb8>
24013480:	f9b3 5000 	ldrsh.w	r5, [r3]
24013484:	2d00      	cmp	r5, #0
24013486:	da03      	bge.n	24013490 <_printf_i+0xd0>
24013488:	232d      	movs	r3, #45	@ 0x2d
2401348a:	426d      	negs	r5, r5
2401348c:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
24013490:	4859      	ldr	r0, [pc, #356]	@ (240135f8 <_printf_i+0x238>)
24013492:	230a      	movs	r3, #10
24013494:	e011      	b.n	240134ba <_printf_i+0xfa>
24013496:	6821      	ldr	r1, [r4, #0]
24013498:	6833      	ldr	r3, [r6, #0]
2401349a:	0608      	lsls	r0, r1, #24
2401349c:	f853 5b04 	ldr.w	r5, [r3], #4
240134a0:	d402      	bmi.n	240134a8 <_printf_i+0xe8>
240134a2:	0649      	lsls	r1, r1, #25
240134a4:	bf48      	it	mi
240134a6:	b2ad      	uxthmi	r5, r5
240134a8:	2f6f      	cmp	r7, #111	@ 0x6f
240134aa:	4853      	ldr	r0, [pc, #332]	@ (240135f8 <_printf_i+0x238>)
240134ac:	6033      	str	r3, [r6, #0]
240134ae:	bf14      	ite	ne
240134b0:	230a      	movne	r3, #10
240134b2:	2308      	moveq	r3, #8
240134b4:	2100      	movs	r1, #0
240134b6:	f884 1043 	strb.w	r1, [r4, #67]	@ 0x43
240134ba:	6866      	ldr	r6, [r4, #4]
240134bc:	60a6      	str	r6, [r4, #8]
240134be:	2e00      	cmp	r6, #0
240134c0:	bfa2      	ittt	ge
240134c2:	6821      	ldrge	r1, [r4, #0]
240134c4:	f021 0104 	bicge.w	r1, r1, #4
240134c8:	6021      	strge	r1, [r4, #0]
240134ca:	b90d      	cbnz	r5, 240134d0 <_printf_i+0x110>
240134cc:	2e00      	cmp	r6, #0
240134ce:	d04b      	beq.n	24013568 <_printf_i+0x1a8>
240134d0:	4616      	mov	r6, r2
240134d2:	fbb5 f1f3 	udiv	r1, r5, r3
240134d6:	fb03 5711 	mls	r7, r3, r1, r5
240134da:	5dc7      	ldrb	r7, [r0, r7]
240134dc:	f806 7d01 	strb.w	r7, [r6, #-1]!
240134e0:	462f      	mov	r7, r5
240134e2:	42bb      	cmp	r3, r7
240134e4:	460d      	mov	r5, r1
240134e6:	d9f4      	bls.n	240134d2 <_printf_i+0x112>
240134e8:	2b08      	cmp	r3, #8
240134ea:	d10b      	bne.n	24013504 <_printf_i+0x144>
240134ec:	6823      	ldr	r3, [r4, #0]
240134ee:	07df      	lsls	r7, r3, #31
240134f0:	d508      	bpl.n	24013504 <_printf_i+0x144>
240134f2:	6923      	ldr	r3, [r4, #16]
240134f4:	6861      	ldr	r1, [r4, #4]
240134f6:	4299      	cmp	r1, r3
240134f8:	bfde      	ittt	le
240134fa:	2330      	movle	r3, #48	@ 0x30
240134fc:	f806 3c01 	strble.w	r3, [r6, #-1]
24013500:	f106 36ff 	addle.w	r6, r6, #4294967295
24013504:	1b92      	subs	r2, r2, r6
24013506:	6122      	str	r2, [r4, #16]
24013508:	f8cd a000 	str.w	sl, [sp]
2401350c:	464b      	mov	r3, r9
2401350e:	aa03      	add	r2, sp, #12
24013510:	4621      	mov	r1, r4
24013512:	4640      	mov	r0, r8
24013514:	f7ff fee6 	bl	240132e4 <_printf_common>
24013518:	3001      	adds	r0, #1
2401351a:	d14a      	bne.n	240135b2 <_printf_i+0x1f2>
2401351c:	f04f 30ff 	mov.w	r0, #4294967295
24013520:	b004      	add	sp, #16
24013522:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
24013526:	6823      	ldr	r3, [r4, #0]
24013528:	f043 0320 	orr.w	r3, r3, #32
2401352c:	6023      	str	r3, [r4, #0]
2401352e:	4833      	ldr	r0, [pc, #204]	@ (240135fc <_printf_i+0x23c>)
24013530:	2778      	movs	r7, #120	@ 0x78
24013532:	f884 7045 	strb.w	r7, [r4, #69]	@ 0x45
24013536:	6823      	ldr	r3, [r4, #0]
24013538:	6831      	ldr	r1, [r6, #0]
2401353a:	061f      	lsls	r7, r3, #24
2401353c:	f851 5b04 	ldr.w	r5, [r1], #4
24013540:	d402      	bmi.n	24013548 <_printf_i+0x188>
24013542:	065f      	lsls	r7, r3, #25
24013544:	bf48      	it	mi
24013546:	b2ad      	uxthmi	r5, r5
24013548:	6031      	str	r1, [r6, #0]
2401354a:	07d9      	lsls	r1, r3, #31
2401354c:	bf44      	itt	mi
2401354e:	f043 0320 	orrmi.w	r3, r3, #32
24013552:	6023      	strmi	r3, [r4, #0]
24013554:	b11d      	cbz	r5, 2401355e <_printf_i+0x19e>
24013556:	2310      	movs	r3, #16
24013558:	e7ac      	b.n	240134b4 <_printf_i+0xf4>
2401355a:	4827      	ldr	r0, [pc, #156]	@ (240135f8 <_printf_i+0x238>)
2401355c:	e7e9      	b.n	24013532 <_printf_i+0x172>
2401355e:	6823      	ldr	r3, [r4, #0]
24013560:	f023 0320 	bic.w	r3, r3, #32
24013564:	6023      	str	r3, [r4, #0]
24013566:	e7f6      	b.n	24013556 <_printf_i+0x196>
24013568:	4616      	mov	r6, r2
2401356a:	e7bd      	b.n	240134e8 <_printf_i+0x128>
2401356c:	6833      	ldr	r3, [r6, #0]
2401356e:	6825      	ldr	r5, [r4, #0]
24013570:	6961      	ldr	r1, [r4, #20]
24013572:	1d18      	adds	r0, r3, #4
24013574:	6030      	str	r0, [r6, #0]
24013576:	062e      	lsls	r6, r5, #24
24013578:	681b      	ldr	r3, [r3, #0]
2401357a:	d501      	bpl.n	24013580 <_printf_i+0x1c0>
2401357c:	6019      	str	r1, [r3, #0]
2401357e:	e002      	b.n	24013586 <_printf_i+0x1c6>
24013580:	0668      	lsls	r0, r5, #25
24013582:	d5fb      	bpl.n	2401357c <_printf_i+0x1bc>
24013584:	8019      	strh	r1, [r3, #0]
24013586:	2300      	movs	r3, #0
24013588:	6123      	str	r3, [r4, #16]
2401358a:	4616      	mov	r6, r2
2401358c:	e7bc      	b.n	24013508 <_printf_i+0x148>
2401358e:	6833      	ldr	r3, [r6, #0]
24013590:	1d1a      	adds	r2, r3, #4
24013592:	6032      	str	r2, [r6, #0]
24013594:	681e      	ldr	r6, [r3, #0]
24013596:	6862      	ldr	r2, [r4, #4]
24013598:	2100      	movs	r1, #0
2401359a:	4630      	mov	r0, r6
2401359c:	f7ff fa80 	bl	24012aa0 <memchr>
240135a0:	b108      	cbz	r0, 240135a6 <_printf_i+0x1e6>
240135a2:	1b80      	subs	r0, r0, r6
240135a4:	6060      	str	r0, [r4, #4]
240135a6:	6863      	ldr	r3, [r4, #4]
240135a8:	6123      	str	r3, [r4, #16]
240135aa:	2300      	movs	r3, #0
240135ac:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
240135b0:	e7aa      	b.n	24013508 <_printf_i+0x148>
240135b2:	6923      	ldr	r3, [r4, #16]
240135b4:	4632      	mov	r2, r6
240135b6:	4649      	mov	r1, r9
240135b8:	4640      	mov	r0, r8
240135ba:	47d0      	blx	sl
240135bc:	3001      	adds	r0, #1
240135be:	d0ad      	beq.n	2401351c <_printf_i+0x15c>
240135c0:	6823      	ldr	r3, [r4, #0]
240135c2:	079b      	lsls	r3, r3, #30
240135c4:	d413      	bmi.n	240135ee <_printf_i+0x22e>
240135c6:	68e0      	ldr	r0, [r4, #12]
240135c8:	9b03      	ldr	r3, [sp, #12]
240135ca:	4298      	cmp	r0, r3
240135cc:	bfb8      	it	lt
240135ce:	4618      	movlt	r0, r3
240135d0:	e7a6      	b.n	24013520 <_printf_i+0x160>
240135d2:	2301      	movs	r3, #1
240135d4:	4632      	mov	r2, r6
240135d6:	4649      	mov	r1, r9
240135d8:	4640      	mov	r0, r8
240135da:	47d0      	blx	sl
240135dc:	3001      	adds	r0, #1
240135de:	d09d      	beq.n	2401351c <_printf_i+0x15c>
240135e0:	3501      	adds	r5, #1
240135e2:	68e3      	ldr	r3, [r4, #12]
240135e4:	9903      	ldr	r1, [sp, #12]
240135e6:	1a5b      	subs	r3, r3, r1
240135e8:	42ab      	cmp	r3, r5
240135ea:	dcf2      	bgt.n	240135d2 <_printf_i+0x212>
240135ec:	e7eb      	b.n	240135c6 <_printf_i+0x206>
240135ee:	2500      	movs	r5, #0
240135f0:	f104 0619 	add.w	r6, r4, #25
240135f4:	e7f5      	b.n	240135e2 <_printf_i+0x222>
240135f6:	bf00      	nop
240135f8:	240143b7 	.word	0x240143b7
240135fc:	240143c8 	.word	0x240143c8

24013600 <__sflush_r>:
24013600:	f9b1 200c 	ldrsh.w	r2, [r1, #12]
24013604:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
24013608:	0716      	lsls	r6, r2, #28
2401360a:	4605      	mov	r5, r0
2401360c:	460c      	mov	r4, r1
2401360e:	d454      	bmi.n	240136ba <__sflush_r+0xba>
24013610:	684b      	ldr	r3, [r1, #4]
24013612:	2b00      	cmp	r3, #0
24013614:	dc02      	bgt.n	2401361c <__sflush_r+0x1c>
24013616:	6c0b      	ldr	r3, [r1, #64]	@ 0x40
24013618:	2b00      	cmp	r3, #0
2401361a:	dd48      	ble.n	240136ae <__sflush_r+0xae>
2401361c:	6ae6      	ldr	r6, [r4, #44]	@ 0x2c
2401361e:	2e00      	cmp	r6, #0
24013620:	d045      	beq.n	240136ae <__sflush_r+0xae>
24013622:	2300      	movs	r3, #0
24013624:	f412 5280 	ands.w	r2, r2, #4096	@ 0x1000
24013628:	682f      	ldr	r7, [r5, #0]
2401362a:	6a21      	ldr	r1, [r4, #32]
2401362c:	602b      	str	r3, [r5, #0]
2401362e:	d030      	beq.n	24013692 <__sflush_r+0x92>
24013630:	6d62      	ldr	r2, [r4, #84]	@ 0x54
24013632:	89a3      	ldrh	r3, [r4, #12]
24013634:	0759      	lsls	r1, r3, #29
24013636:	d505      	bpl.n	24013644 <__sflush_r+0x44>
24013638:	6863      	ldr	r3, [r4, #4]
2401363a:	1ad2      	subs	r2, r2, r3
2401363c:	6b63      	ldr	r3, [r4, #52]	@ 0x34
2401363e:	b10b      	cbz	r3, 24013644 <__sflush_r+0x44>
24013640:	6c23      	ldr	r3, [r4, #64]	@ 0x40
24013642:	1ad2      	subs	r2, r2, r3
24013644:	2300      	movs	r3, #0
24013646:	6ae6      	ldr	r6, [r4, #44]	@ 0x2c
24013648:	6a21      	ldr	r1, [r4, #32]
2401364a:	4628      	mov	r0, r5
2401364c:	47b0      	blx	r6
2401364e:	1c43      	adds	r3, r0, #1
24013650:	89a3      	ldrh	r3, [r4, #12]
24013652:	d106      	bne.n	24013662 <__sflush_r+0x62>
24013654:	6829      	ldr	r1, [r5, #0]
24013656:	291d      	cmp	r1, #29
24013658:	d82b      	bhi.n	240136b2 <__sflush_r+0xb2>
2401365a:	4a2a      	ldr	r2, [pc, #168]	@ (24013704 <__sflush_r+0x104>)
2401365c:	410a      	asrs	r2, r1
2401365e:	07d6      	lsls	r6, r2, #31
24013660:	d427      	bmi.n	240136b2 <__sflush_r+0xb2>
24013662:	2200      	movs	r2, #0
24013664:	6062      	str	r2, [r4, #4]
24013666:	04d9      	lsls	r1, r3, #19
24013668:	6922      	ldr	r2, [r4, #16]
2401366a:	6022      	str	r2, [r4, #0]
2401366c:	d504      	bpl.n	24013678 <__sflush_r+0x78>
2401366e:	1c42      	adds	r2, r0, #1
24013670:	d101      	bne.n	24013676 <__sflush_r+0x76>
24013672:	682b      	ldr	r3, [r5, #0]
24013674:	b903      	cbnz	r3, 24013678 <__sflush_r+0x78>
24013676:	6560      	str	r0, [r4, #84]	@ 0x54
24013678:	6b61      	ldr	r1, [r4, #52]	@ 0x34
2401367a:	602f      	str	r7, [r5, #0]
2401367c:	b1b9      	cbz	r1, 240136ae <__sflush_r+0xae>
2401367e:	f104 0344 	add.w	r3, r4, #68	@ 0x44
24013682:	4299      	cmp	r1, r3
24013684:	d002      	beq.n	2401368c <__sflush_r+0x8c>
24013686:	4628      	mov	r0, r5
24013688:	f7ff fbdc 	bl	24012e44 <_free_r>
2401368c:	2300      	movs	r3, #0
2401368e:	6363      	str	r3, [r4, #52]	@ 0x34
24013690:	e00d      	b.n	240136ae <__sflush_r+0xae>
24013692:	2301      	movs	r3, #1
24013694:	4628      	mov	r0, r5
24013696:	47b0      	blx	r6
24013698:	4602      	mov	r2, r0
2401369a:	1c50      	adds	r0, r2, #1
2401369c:	d1c9      	bne.n	24013632 <__sflush_r+0x32>
2401369e:	682b      	ldr	r3, [r5, #0]
240136a0:	2b00      	cmp	r3, #0
240136a2:	d0c6      	beq.n	24013632 <__sflush_r+0x32>
240136a4:	2b1d      	cmp	r3, #29
240136a6:	d001      	beq.n	240136ac <__sflush_r+0xac>
240136a8:	2b16      	cmp	r3, #22
240136aa:	d11e      	bne.n	240136ea <__sflush_r+0xea>
240136ac:	602f      	str	r7, [r5, #0]
240136ae:	2000      	movs	r0, #0
240136b0:	e022      	b.n	240136f8 <__sflush_r+0xf8>
240136b2:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
240136b6:	b21b      	sxth	r3, r3
240136b8:	e01b      	b.n	240136f2 <__sflush_r+0xf2>
240136ba:	690f      	ldr	r7, [r1, #16]
240136bc:	2f00      	cmp	r7, #0
240136be:	d0f6      	beq.n	240136ae <__sflush_r+0xae>
240136c0:	0793      	lsls	r3, r2, #30
240136c2:	680e      	ldr	r6, [r1, #0]
240136c4:	bf08      	it	eq
240136c6:	694b      	ldreq	r3, [r1, #20]
240136c8:	600f      	str	r7, [r1, #0]
240136ca:	bf18      	it	ne
240136cc:	2300      	movne	r3, #0
240136ce:	eba6 0807 	sub.w	r8, r6, r7
240136d2:	608b      	str	r3, [r1, #8]
240136d4:	f1b8 0f00 	cmp.w	r8, #0
240136d8:	dde9      	ble.n	240136ae <__sflush_r+0xae>
240136da:	6a21      	ldr	r1, [r4, #32]
240136dc:	6aa6      	ldr	r6, [r4, #40]	@ 0x28
240136de:	4643      	mov	r3, r8
240136e0:	463a      	mov	r2, r7
240136e2:	4628      	mov	r0, r5
240136e4:	47b0      	blx	r6
240136e6:	2800      	cmp	r0, #0
240136e8:	dc08      	bgt.n	240136fc <__sflush_r+0xfc>
240136ea:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
240136ee:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
240136f2:	81a3      	strh	r3, [r4, #12]
240136f4:	f04f 30ff 	mov.w	r0, #4294967295
240136f8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
240136fc:	4407      	add	r7, r0
240136fe:	eba8 0800 	sub.w	r8, r8, r0
24013702:	e7e7      	b.n	240136d4 <__sflush_r+0xd4>
24013704:	dfbffffe 	.word	0xdfbffffe

24013708 <_fflush_r>:
24013708:	b538      	push	{r3, r4, r5, lr}
2401370a:	690b      	ldr	r3, [r1, #16]
2401370c:	4605      	mov	r5, r0
2401370e:	460c      	mov	r4, r1
24013710:	b913      	cbnz	r3, 24013718 <_fflush_r+0x10>
24013712:	2500      	movs	r5, #0
24013714:	4628      	mov	r0, r5
24013716:	bd38      	pop	{r3, r4, r5, pc}
24013718:	b118      	cbz	r0, 24013722 <_fflush_r+0x1a>
2401371a:	6a03      	ldr	r3, [r0, #32]
2401371c:	b90b      	cbnz	r3, 24013722 <_fflush_r+0x1a>
2401371e:	f000 f925 	bl	2401396c <__sinit>
24013722:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
24013726:	2b00      	cmp	r3, #0
24013728:	d0f3      	beq.n	24013712 <_fflush_r+0xa>
2401372a:	6e62      	ldr	r2, [r4, #100]	@ 0x64
2401372c:	07d0      	lsls	r0, r2, #31
2401372e:	d404      	bmi.n	2401373a <_fflush_r+0x32>
24013730:	0599      	lsls	r1, r3, #22
24013732:	d402      	bmi.n	2401373a <_fflush_r+0x32>
24013734:	6da0      	ldr	r0, [r4, #88]	@ 0x58
24013736:	f7ff fb7e 	bl	24012e36 <__retarget_lock_acquire_recursive>
2401373a:	4628      	mov	r0, r5
2401373c:	4621      	mov	r1, r4
2401373e:	f7ff ff5f 	bl	24013600 <__sflush_r>
24013742:	6e63      	ldr	r3, [r4, #100]	@ 0x64
24013744:	07da      	lsls	r2, r3, #31
24013746:	4605      	mov	r5, r0
24013748:	d4e4      	bmi.n	24013714 <_fflush_r+0xc>
2401374a:	89a3      	ldrh	r3, [r4, #12]
2401374c:	059b      	lsls	r3, r3, #22
2401374e:	d4e1      	bmi.n	24013714 <_fflush_r+0xc>
24013750:	6da0      	ldr	r0, [r4, #88]	@ 0x58
24013752:	f7ff fb76 	bl	24012e42 <__retarget_lock_release_recursive>
24013756:	e7dd      	b.n	24013714 <_fflush_r+0xc>

24013758 <fflush>:
24013758:	4601      	mov	r1, r0
2401375a:	b920      	cbnz	r0, 24013766 <fflush+0xe>
2401375c:	4a04      	ldr	r2, [pc, #16]	@ (24013770 <fflush+0x18>)
2401375e:	4905      	ldr	r1, [pc, #20]	@ (24013774 <fflush+0x1c>)
24013760:	4805      	ldr	r0, [pc, #20]	@ (24013778 <fflush+0x20>)
24013762:	f000 ba83 	b.w	24013c6c <_fwalk_sglue>
24013766:	4b05      	ldr	r3, [pc, #20]	@ (2401377c <fflush+0x24>)
24013768:	6818      	ldr	r0, [r3, #0]
2401376a:	f7ff bfcd 	b.w	24013708 <_fflush_r>
2401376e:	bf00      	nop
24013770:	2400056c 	.word	0x2400056c
24013774:	24013709 	.word	0x24013709
24013778:	24000520 	.word	0x24000520
2401377c:	2400051c 	.word	0x2400051c

24013780 <std>:
24013780:	2300      	movs	r3, #0
24013782:	b510      	push	{r4, lr}
24013784:	4604      	mov	r4, r0
24013786:	e9c0 3300 	strd	r3, r3, [r0]
2401378a:	e9c0 3304 	strd	r3, r3, [r0, #16]
2401378e:	6083      	str	r3, [r0, #8]
24013790:	8181      	strh	r1, [r0, #12]
24013792:	6643      	str	r3, [r0, #100]	@ 0x64
24013794:	81c2      	strh	r2, [r0, #14]
24013796:	6183      	str	r3, [r0, #24]
24013798:	4619      	mov	r1, r3
2401379a:	2208      	movs	r2, #8
2401379c:	305c      	adds	r0, #92	@ 0x5c
2401379e:	f7ff fb13 	bl	24012dc8 <memset>
240137a2:	4b0d      	ldr	r3, [pc, #52]	@ (240137d8 <std+0x58>)
240137a4:	6263      	str	r3, [r4, #36]	@ 0x24
240137a6:	4b0d      	ldr	r3, [pc, #52]	@ (240137dc <std+0x5c>)
240137a8:	62a3      	str	r3, [r4, #40]	@ 0x28
240137aa:	4b0d      	ldr	r3, [pc, #52]	@ (240137e0 <std+0x60>)
240137ac:	62e3      	str	r3, [r4, #44]	@ 0x2c
240137ae:	4b0d      	ldr	r3, [pc, #52]	@ (240137e4 <std+0x64>)
240137b0:	6323      	str	r3, [r4, #48]	@ 0x30
240137b2:	4b0d      	ldr	r3, [pc, #52]	@ (240137e8 <std+0x68>)
240137b4:	6224      	str	r4, [r4, #32]
240137b6:	429c      	cmp	r4, r3
240137b8:	d006      	beq.n	240137c8 <std+0x48>
240137ba:	f103 0268 	add.w	r2, r3, #104	@ 0x68
240137be:	4294      	cmp	r4, r2
240137c0:	d002      	beq.n	240137c8 <std+0x48>
240137c2:	33d0      	adds	r3, #208	@ 0xd0
240137c4:	429c      	cmp	r4, r3
240137c6:	d105      	bne.n	240137d4 <std+0x54>
240137c8:	f104 0058 	add.w	r0, r4, #88	@ 0x58
240137cc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
240137d0:	f7ff bb2d 	b.w	24012e2e <__retarget_lock_init_recursive>
240137d4:	bd10      	pop	{r4, pc}
240137d6:	bf00      	nop
240137d8:	24013d6d 	.word	0x24013d6d
240137dc:	24013d93 	.word	0x24013d93
240137e0:	24013dcb 	.word	0x24013dcb
240137e4:	24013def 	.word	0x24013def
240137e8:	240006cc 	.word	0x240006cc

240137ec <stdio_exit_handler>:
240137ec:	4a02      	ldr	r2, [pc, #8]	@ (240137f8 <stdio_exit_handler+0xc>)
240137ee:	4903      	ldr	r1, [pc, #12]	@ (240137fc <stdio_exit_handler+0x10>)
240137f0:	4803      	ldr	r0, [pc, #12]	@ (24013800 <stdio_exit_handler+0x14>)
240137f2:	f000 ba3b 	b.w	24013c6c <_fwalk_sglue>
240137f6:	bf00      	nop
240137f8:	2400056c 	.word	0x2400056c
240137fc:	24013709 	.word	0x24013709
24013800:	24000520 	.word	0x24000520

24013804 <cleanup_stdio>:
24013804:	6841      	ldr	r1, [r0, #4]
24013806:	4b0c      	ldr	r3, [pc, #48]	@ (24013838 <cleanup_stdio+0x34>)
24013808:	4299      	cmp	r1, r3
2401380a:	b510      	push	{r4, lr}
2401380c:	4604      	mov	r4, r0
2401380e:	d001      	beq.n	24013814 <cleanup_stdio+0x10>
24013810:	f7ff ff7a 	bl	24013708 <_fflush_r>
24013814:	68a1      	ldr	r1, [r4, #8]
24013816:	4b09      	ldr	r3, [pc, #36]	@ (2401383c <cleanup_stdio+0x38>)
24013818:	4299      	cmp	r1, r3
2401381a:	d002      	beq.n	24013822 <cleanup_stdio+0x1e>
2401381c:	4620      	mov	r0, r4
2401381e:	f7ff ff73 	bl	24013708 <_fflush_r>
24013822:	68e1      	ldr	r1, [r4, #12]
24013824:	4b06      	ldr	r3, [pc, #24]	@ (24013840 <cleanup_stdio+0x3c>)
24013826:	4299      	cmp	r1, r3
24013828:	d004      	beq.n	24013834 <cleanup_stdio+0x30>
2401382a:	4620      	mov	r0, r4
2401382c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
24013830:	f7ff bf6a 	b.w	24013708 <_fflush_r>
24013834:	bd10      	pop	{r4, pc}
24013836:	bf00      	nop
24013838:	240006cc 	.word	0x240006cc
2401383c:	24000734 	.word	0x24000734
24013840:	2400079c 	.word	0x2400079c

24013844 <__fp_lock>:
24013844:	b508      	push	{r3, lr}
24013846:	6e4b      	ldr	r3, [r1, #100]	@ 0x64
24013848:	07da      	lsls	r2, r3, #31
2401384a:	d405      	bmi.n	24013858 <__fp_lock+0x14>
2401384c:	898b      	ldrh	r3, [r1, #12]
2401384e:	059b      	lsls	r3, r3, #22
24013850:	d402      	bmi.n	24013858 <__fp_lock+0x14>
24013852:	6d88      	ldr	r0, [r1, #88]	@ 0x58
24013854:	f7ff faef 	bl	24012e36 <__retarget_lock_acquire_recursive>
24013858:	2000      	movs	r0, #0
2401385a:	bd08      	pop	{r3, pc}

2401385c <__fp_unlock>:
2401385c:	b508      	push	{r3, lr}
2401385e:	6e4b      	ldr	r3, [r1, #100]	@ 0x64
24013860:	07da      	lsls	r2, r3, #31
24013862:	d405      	bmi.n	24013870 <__fp_unlock+0x14>
24013864:	898b      	ldrh	r3, [r1, #12]
24013866:	059b      	lsls	r3, r3, #22
24013868:	d402      	bmi.n	24013870 <__fp_unlock+0x14>
2401386a:	6d88      	ldr	r0, [r1, #88]	@ 0x58
2401386c:	f7ff fae9 	bl	24012e42 <__retarget_lock_release_recursive>
24013870:	2000      	movs	r0, #0
24013872:	bd08      	pop	{r3, pc}

24013874 <global_stdio_init.part.0>:
24013874:	b510      	push	{r4, lr}
24013876:	4b0b      	ldr	r3, [pc, #44]	@ (240138a4 <global_stdio_init.part.0+0x30>)
24013878:	4c0b      	ldr	r4, [pc, #44]	@ (240138a8 <global_stdio_init.part.0+0x34>)
2401387a:	4a0c      	ldr	r2, [pc, #48]	@ (240138ac <global_stdio_init.part.0+0x38>)
2401387c:	601a      	str	r2, [r3, #0]
2401387e:	4620      	mov	r0, r4
24013880:	2200      	movs	r2, #0
24013882:	2104      	movs	r1, #4
24013884:	f7ff ff7c 	bl	24013780 <std>
24013888:	f104 0068 	add.w	r0, r4, #104	@ 0x68
2401388c:	2201      	movs	r2, #1
2401388e:	2109      	movs	r1, #9
24013890:	f7ff ff76 	bl	24013780 <std>
24013894:	f104 00d0 	add.w	r0, r4, #208	@ 0xd0
24013898:	2202      	movs	r2, #2
2401389a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
2401389e:	2112      	movs	r1, #18
240138a0:	f7ff bf6e 	b.w	24013780 <std>
240138a4:	24000804 	.word	0x24000804
240138a8:	240006cc 	.word	0x240006cc
240138ac:	240137ed 	.word	0x240137ed

240138b0 <__sfp_lock_acquire>:
240138b0:	4801      	ldr	r0, [pc, #4]	@ (240138b8 <__sfp_lock_acquire+0x8>)
240138b2:	f7ff bac0 	b.w	24012e36 <__retarget_lock_acquire_recursive>
240138b6:	bf00      	nop
240138b8:	240006c3 	.word	0x240006c3

240138bc <__sfp_lock_release>:
240138bc:	4801      	ldr	r0, [pc, #4]	@ (240138c4 <__sfp_lock_release+0x8>)
240138be:	f7ff bac0 	b.w	24012e42 <__retarget_lock_release_recursive>
240138c2:	bf00      	nop
240138c4:	240006c3 	.word	0x240006c3

240138c8 <__sfp>:
240138c8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
240138ca:	4607      	mov	r7, r0
240138cc:	f7ff fff0 	bl	240138b0 <__sfp_lock_acquire>
240138d0:	4b23      	ldr	r3, [pc, #140]	@ (24013960 <__sfp+0x98>)
240138d2:	681b      	ldr	r3, [r3, #0]
240138d4:	b90b      	cbnz	r3, 240138da <__sfp+0x12>
240138d6:	f7ff ffcd 	bl	24013874 <global_stdio_init.part.0>
240138da:	4e22      	ldr	r6, [pc, #136]	@ (24013964 <__sfp+0x9c>)
240138dc:	e9d6 3401 	ldrd	r3, r4, [r6, #4]
240138e0:	3b01      	subs	r3, #1
240138e2:	d50f      	bpl.n	24013904 <__sfp+0x3c>
240138e4:	6835      	ldr	r5, [r6, #0]
240138e6:	2d00      	cmp	r5, #0
240138e8:	d137      	bne.n	2401395a <__sfp+0x92>
240138ea:	f44f 71d6 	mov.w	r1, #428	@ 0x1ac
240138ee:	4638      	mov	r0, r7
240138f0:	f7ff fb14 	bl	24012f1c <_malloc_r>
240138f4:	4604      	mov	r4, r0
240138f6:	bb28      	cbnz	r0, 24013944 <__sfp+0x7c>
240138f8:	6030      	str	r0, [r6, #0]
240138fa:	f7ff ffdf 	bl	240138bc <__sfp_lock_release>
240138fe:	230c      	movs	r3, #12
24013900:	603b      	str	r3, [r7, #0]
24013902:	e01b      	b.n	2401393c <__sfp+0x74>
24013904:	f9b4 500c 	ldrsh.w	r5, [r4, #12]
24013908:	b9d5      	cbnz	r5, 24013940 <__sfp+0x78>
2401390a:	4b17      	ldr	r3, [pc, #92]	@ (24013968 <__sfp+0xa0>)
2401390c:	60e3      	str	r3, [r4, #12]
2401390e:	f104 0058 	add.w	r0, r4, #88	@ 0x58
24013912:	6665      	str	r5, [r4, #100]	@ 0x64
24013914:	f7ff fa8b 	bl	24012e2e <__retarget_lock_init_recursive>
24013918:	f7ff ffd0 	bl	240138bc <__sfp_lock_release>
2401391c:	e9c4 5501 	strd	r5, r5, [r4, #4]
24013920:	e9c4 5504 	strd	r5, r5, [r4, #16]
24013924:	6025      	str	r5, [r4, #0]
24013926:	61a5      	str	r5, [r4, #24]
24013928:	2208      	movs	r2, #8
2401392a:	4629      	mov	r1, r5
2401392c:	f104 005c 	add.w	r0, r4, #92	@ 0x5c
24013930:	f7ff fa4a 	bl	24012dc8 <memset>
24013934:	e9c4 550d 	strd	r5, r5, [r4, #52]	@ 0x34
24013938:	e9c4 5512 	strd	r5, r5, [r4, #72]	@ 0x48
2401393c:	4620      	mov	r0, r4
2401393e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
24013940:	3468      	adds	r4, #104	@ 0x68
24013942:	e7cd      	b.n	240138e0 <__sfp+0x18>
24013944:	2304      	movs	r3, #4
24013946:	6005      	str	r5, [r0, #0]
24013948:	6043      	str	r3, [r0, #4]
2401394a:	300c      	adds	r0, #12
2401394c:	60a0      	str	r0, [r4, #8]
2401394e:	f44f 72d0 	mov.w	r2, #416	@ 0x1a0
24013952:	4629      	mov	r1, r5
24013954:	f7ff fa38 	bl	24012dc8 <memset>
24013958:	6034      	str	r4, [r6, #0]
2401395a:	6836      	ldr	r6, [r6, #0]
2401395c:	e7be      	b.n	240138dc <__sfp+0x14>
2401395e:	bf00      	nop
24013960:	24000804 	.word	0x24000804
24013964:	2400056c 	.word	0x2400056c
24013968:	ffff0001 	.word	0xffff0001

2401396c <__sinit>:
2401396c:	b510      	push	{r4, lr}
2401396e:	4604      	mov	r4, r0
24013970:	f7ff ff9e 	bl	240138b0 <__sfp_lock_acquire>
24013974:	6a23      	ldr	r3, [r4, #32]
24013976:	b11b      	cbz	r3, 24013980 <__sinit+0x14>
24013978:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
2401397c:	f7ff bf9e 	b.w	240138bc <__sfp_lock_release>
24013980:	4b04      	ldr	r3, [pc, #16]	@ (24013994 <__sinit+0x28>)
24013982:	6223      	str	r3, [r4, #32]
24013984:	4b04      	ldr	r3, [pc, #16]	@ (24013998 <__sinit+0x2c>)
24013986:	681b      	ldr	r3, [r3, #0]
24013988:	2b00      	cmp	r3, #0
2401398a:	d1f5      	bne.n	24013978 <__sinit+0xc>
2401398c:	f7ff ff72 	bl	24013874 <global_stdio_init.part.0>
24013990:	e7f2      	b.n	24013978 <__sinit+0xc>
24013992:	bf00      	nop
24013994:	24013805 	.word	0x24013805
24013998:	24000804 	.word	0x24000804

2401399c <__fp_lock_all>:
2401399c:	b508      	push	{r3, lr}
2401399e:	f7ff ff87 	bl	240138b0 <__sfp_lock_acquire>
240139a2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
240139a6:	4a02      	ldr	r2, [pc, #8]	@ (240139b0 <__fp_lock_all+0x14>)
240139a8:	4902      	ldr	r1, [pc, #8]	@ (240139b4 <__fp_lock_all+0x18>)
240139aa:	2000      	movs	r0, #0
240139ac:	f000 b95e 	b.w	24013c6c <_fwalk_sglue>
240139b0:	2400056c 	.word	0x2400056c
240139b4:	24013845 	.word	0x24013845

240139b8 <__fp_unlock_all>:
240139b8:	b508      	push	{r3, lr}
240139ba:	4a04      	ldr	r2, [pc, #16]	@ (240139cc <__fp_unlock_all+0x14>)
240139bc:	4904      	ldr	r1, [pc, #16]	@ (240139d0 <__fp_unlock_all+0x18>)
240139be:	2000      	movs	r0, #0
240139c0:	f000 f954 	bl	24013c6c <_fwalk_sglue>
240139c4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
240139c8:	f7ff bf78 	b.w	240138bc <__sfp_lock_release>
240139cc:	2400056c 	.word	0x2400056c
240139d0:	2401385d 	.word	0x2401385d

240139d4 <__sfvwrite_r>:
240139d4:	6893      	ldr	r3, [r2, #8]
240139d6:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
240139da:	4606      	mov	r6, r0
240139dc:	460c      	mov	r4, r1
240139de:	4691      	mov	r9, r2
240139e0:	b91b      	cbnz	r3, 240139ea <__sfvwrite_r+0x16>
240139e2:	2000      	movs	r0, #0
240139e4:	b003      	add	sp, #12
240139e6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
240139ea:	898b      	ldrh	r3, [r1, #12]
240139ec:	0718      	lsls	r0, r3, #28
240139ee:	d550      	bpl.n	24013a92 <__sfvwrite_r+0xbe>
240139f0:	690b      	ldr	r3, [r1, #16]
240139f2:	2b00      	cmp	r3, #0
240139f4:	d04d      	beq.n	24013a92 <__sfvwrite_r+0xbe>
240139f6:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
240139fa:	f8d9 8000 	ldr.w	r8, [r9]
240139fe:	f013 0702 	ands.w	r7, r3, #2
24013a02:	d16b      	bne.n	24013adc <__sfvwrite_r+0x108>
24013a04:	f013 0301 	ands.w	r3, r3, #1
24013a08:	f000 809c 	beq.w	24013b44 <__sfvwrite_r+0x170>
24013a0c:	4638      	mov	r0, r7
24013a0e:	46ba      	mov	sl, r7
24013a10:	46bb      	mov	fp, r7
24013a12:	f1bb 0f00 	cmp.w	fp, #0
24013a16:	f000 8103 	beq.w	24013c20 <__sfvwrite_r+0x24c>
24013a1a:	b950      	cbnz	r0, 24013a32 <__sfvwrite_r+0x5e>
24013a1c:	465a      	mov	r2, fp
24013a1e:	210a      	movs	r1, #10
24013a20:	4650      	mov	r0, sl
24013a22:	f7ff f83d 	bl	24012aa0 <memchr>
24013a26:	2800      	cmp	r0, #0
24013a28:	f000 8100 	beq.w	24013c2c <__sfvwrite_r+0x258>
24013a2c:	3001      	adds	r0, #1
24013a2e:	eba0 070a 	sub.w	r7, r0, sl
24013a32:	6820      	ldr	r0, [r4, #0]
24013a34:	6921      	ldr	r1, [r4, #16]
24013a36:	68a5      	ldr	r5, [r4, #8]
24013a38:	6963      	ldr	r3, [r4, #20]
24013a3a:	455f      	cmp	r7, fp
24013a3c:	463a      	mov	r2, r7
24013a3e:	bf28      	it	cs
24013a40:	465a      	movcs	r2, fp
24013a42:	4288      	cmp	r0, r1
24013a44:	f240 80f5 	bls.w	24013c32 <__sfvwrite_r+0x25e>
24013a48:	441d      	add	r5, r3
24013a4a:	42aa      	cmp	r2, r5
24013a4c:	f340 80f1 	ble.w	24013c32 <__sfvwrite_r+0x25e>
24013a50:	4651      	mov	r1, sl
24013a52:	462a      	mov	r2, r5
24013a54:	f000 f9cf 	bl	24013df6 <memmove>
24013a58:	6823      	ldr	r3, [r4, #0]
24013a5a:	442b      	add	r3, r5
24013a5c:	6023      	str	r3, [r4, #0]
24013a5e:	4621      	mov	r1, r4
24013a60:	4630      	mov	r0, r6
24013a62:	f7ff fe51 	bl	24013708 <_fflush_r>
24013a66:	2800      	cmp	r0, #0
24013a68:	d167      	bne.n	24013b3a <__sfvwrite_r+0x166>
24013a6a:	1b7f      	subs	r7, r7, r5
24013a6c:	f040 80f9 	bne.w	24013c62 <__sfvwrite_r+0x28e>
24013a70:	4621      	mov	r1, r4
24013a72:	4630      	mov	r0, r6
24013a74:	f7ff fe48 	bl	24013708 <_fflush_r>
24013a78:	2800      	cmp	r0, #0
24013a7a:	d15e      	bne.n	24013b3a <__sfvwrite_r+0x166>
24013a7c:	f8d9 3008 	ldr.w	r3, [r9, #8]
24013a80:	1b5b      	subs	r3, r3, r5
24013a82:	44aa      	add	sl, r5
24013a84:	ebab 0b05 	sub.w	fp, fp, r5
24013a88:	f8c9 3008 	str.w	r3, [r9, #8]
24013a8c:	2b00      	cmp	r3, #0
24013a8e:	d1c0      	bne.n	24013a12 <__sfvwrite_r+0x3e>
24013a90:	e7a7      	b.n	240139e2 <__sfvwrite_r+0xe>
24013a92:	4621      	mov	r1, r4
24013a94:	4630      	mov	r0, r6
24013a96:	f7ff f941 	bl	24012d1c <__swsetup_r>
24013a9a:	2800      	cmp	r0, #0
24013a9c:	d0ab      	beq.n	240139f6 <__sfvwrite_r+0x22>
24013a9e:	f04f 30ff 	mov.w	r0, #4294967295
24013aa2:	e79f      	b.n	240139e4 <__sfvwrite_r+0x10>
24013aa4:	e9d8 a500 	ldrd	sl, r5, [r8]
24013aa8:	f108 0808 	add.w	r8, r8, #8
24013aac:	f8d4 b028 	ldr.w	fp, [r4, #40]	@ 0x28
24013ab0:	6a21      	ldr	r1, [r4, #32]
24013ab2:	2d00      	cmp	r5, #0
24013ab4:	d0f6      	beq.n	24013aa4 <__sfvwrite_r+0xd0>
24013ab6:	42bd      	cmp	r5, r7
24013ab8:	462b      	mov	r3, r5
24013aba:	4652      	mov	r2, sl
24013abc:	bf28      	it	cs
24013abe:	463b      	movcs	r3, r7
24013ac0:	4630      	mov	r0, r6
24013ac2:	47d8      	blx	fp
24013ac4:	2800      	cmp	r0, #0
24013ac6:	dd38      	ble.n	24013b3a <__sfvwrite_r+0x166>
24013ac8:	f8d9 3008 	ldr.w	r3, [r9, #8]
24013acc:	1a1b      	subs	r3, r3, r0
24013ace:	4482      	add	sl, r0
24013ad0:	1a2d      	subs	r5, r5, r0
24013ad2:	f8c9 3008 	str.w	r3, [r9, #8]
24013ad6:	2b00      	cmp	r3, #0
24013ad8:	d1e8      	bne.n	24013aac <__sfvwrite_r+0xd8>
24013ada:	e782      	b.n	240139e2 <__sfvwrite_r+0xe>
24013adc:	f04f 0a00 	mov.w	sl, #0
24013ae0:	4f61      	ldr	r7, [pc, #388]	@ (24013c68 <__sfvwrite_r+0x294>)
24013ae2:	4655      	mov	r5, sl
24013ae4:	e7e2      	b.n	24013aac <__sfvwrite_r+0xd8>
24013ae6:	e9d8 7a00 	ldrd	r7, sl, [r8]
24013aea:	f108 0808 	add.w	r8, r8, #8
24013aee:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
24013af2:	6820      	ldr	r0, [r4, #0]
24013af4:	68a2      	ldr	r2, [r4, #8]
24013af6:	f1ba 0f00 	cmp.w	sl, #0
24013afa:	d0f4      	beq.n	24013ae6 <__sfvwrite_r+0x112>
24013afc:	0599      	lsls	r1, r3, #22
24013afe:	d563      	bpl.n	24013bc8 <__sfvwrite_r+0x1f4>
24013b00:	4552      	cmp	r2, sl
24013b02:	d836      	bhi.n	24013b72 <__sfvwrite_r+0x19e>
24013b04:	f413 6f90 	tst.w	r3, #1152	@ 0x480
24013b08:	d033      	beq.n	24013b72 <__sfvwrite_r+0x19e>
24013b0a:	6921      	ldr	r1, [r4, #16]
24013b0c:	6965      	ldr	r5, [r4, #20]
24013b0e:	eba0 0b01 	sub.w	fp, r0, r1
24013b12:	eb05 0545 	add.w	r5, r5, r5, lsl #1
24013b16:	eb05 75d5 	add.w	r5, r5, r5, lsr #31
24013b1a:	f10b 0201 	add.w	r2, fp, #1
24013b1e:	106d      	asrs	r5, r5, #1
24013b20:	4452      	add	r2, sl
24013b22:	4295      	cmp	r5, r2
24013b24:	bf38      	it	cc
24013b26:	4615      	movcc	r5, r2
24013b28:	055b      	lsls	r3, r3, #21
24013b2a:	d53d      	bpl.n	24013ba8 <__sfvwrite_r+0x1d4>
24013b2c:	4629      	mov	r1, r5
24013b2e:	4630      	mov	r0, r6
24013b30:	f7ff f9f4 	bl	24012f1c <_malloc_r>
24013b34:	b948      	cbnz	r0, 24013b4a <__sfvwrite_r+0x176>
24013b36:	230c      	movs	r3, #12
24013b38:	6033      	str	r3, [r6, #0]
24013b3a:	89a3      	ldrh	r3, [r4, #12]
24013b3c:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
24013b40:	81a3      	strh	r3, [r4, #12]
24013b42:	e7ac      	b.n	24013a9e <__sfvwrite_r+0xca>
24013b44:	461f      	mov	r7, r3
24013b46:	469a      	mov	sl, r3
24013b48:	e7d1      	b.n	24013aee <__sfvwrite_r+0x11a>
24013b4a:	465a      	mov	r2, fp
24013b4c:	6921      	ldr	r1, [r4, #16]
24013b4e:	9001      	str	r0, [sp, #4]
24013b50:	f000 fa3a 	bl	24013fc8 <memcpy>
24013b54:	89a2      	ldrh	r2, [r4, #12]
24013b56:	9b01      	ldr	r3, [sp, #4]
24013b58:	f422 6290 	bic.w	r2, r2, #1152	@ 0x480
24013b5c:	f042 0280 	orr.w	r2, r2, #128	@ 0x80
24013b60:	81a2      	strh	r2, [r4, #12]
24013b62:	6123      	str	r3, [r4, #16]
24013b64:	6165      	str	r5, [r4, #20]
24013b66:	445b      	add	r3, fp
24013b68:	eba5 050b 	sub.w	r5, r5, fp
24013b6c:	6023      	str	r3, [r4, #0]
24013b6e:	4652      	mov	r2, sl
24013b70:	60a5      	str	r5, [r4, #8]
24013b72:	4552      	cmp	r2, sl
24013b74:	bf28      	it	cs
24013b76:	4652      	movcs	r2, sl
24013b78:	6820      	ldr	r0, [r4, #0]
24013b7a:	9201      	str	r2, [sp, #4]
24013b7c:	4639      	mov	r1, r7
24013b7e:	f000 f93a 	bl	24013df6 <memmove>
24013b82:	68a3      	ldr	r3, [r4, #8]
24013b84:	9a01      	ldr	r2, [sp, #4]
24013b86:	1a9b      	subs	r3, r3, r2
24013b88:	60a3      	str	r3, [r4, #8]
24013b8a:	6823      	ldr	r3, [r4, #0]
24013b8c:	4413      	add	r3, r2
24013b8e:	4655      	mov	r5, sl
24013b90:	6023      	str	r3, [r4, #0]
24013b92:	f8d9 3008 	ldr.w	r3, [r9, #8]
24013b96:	1b5b      	subs	r3, r3, r5
24013b98:	442f      	add	r7, r5
24013b9a:	ebaa 0a05 	sub.w	sl, sl, r5
24013b9e:	f8c9 3008 	str.w	r3, [r9, #8]
24013ba2:	2b00      	cmp	r3, #0
24013ba4:	d1a3      	bne.n	24013aee <__sfvwrite_r+0x11a>
24013ba6:	e71c      	b.n	240139e2 <__sfvwrite_r+0xe>
24013ba8:	462a      	mov	r2, r5
24013baa:	4630      	mov	r0, r6
24013bac:	f000 fa1a 	bl	24013fe4 <_realloc_r>
24013bb0:	4603      	mov	r3, r0
24013bb2:	2800      	cmp	r0, #0
24013bb4:	d1d5      	bne.n	24013b62 <__sfvwrite_r+0x18e>
24013bb6:	6921      	ldr	r1, [r4, #16]
24013bb8:	4630      	mov	r0, r6
24013bba:	f7ff f943 	bl	24012e44 <_free_r>
24013bbe:	89a3      	ldrh	r3, [r4, #12]
24013bc0:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
24013bc4:	81a3      	strh	r3, [r4, #12]
24013bc6:	e7b6      	b.n	24013b36 <__sfvwrite_r+0x162>
24013bc8:	6923      	ldr	r3, [r4, #16]
24013bca:	4283      	cmp	r3, r0
24013bcc:	d302      	bcc.n	24013bd4 <__sfvwrite_r+0x200>
24013bce:	6961      	ldr	r1, [r4, #20]
24013bd0:	4551      	cmp	r1, sl
24013bd2:	d915      	bls.n	24013c00 <__sfvwrite_r+0x22c>
24013bd4:	4552      	cmp	r2, sl
24013bd6:	bf28      	it	cs
24013bd8:	4652      	movcs	r2, sl
24013bda:	4639      	mov	r1, r7
24013bdc:	4615      	mov	r5, r2
24013bde:	f000 f90a 	bl	24013df6 <memmove>
24013be2:	68a3      	ldr	r3, [r4, #8]
24013be4:	6822      	ldr	r2, [r4, #0]
24013be6:	1b5b      	subs	r3, r3, r5
24013be8:	442a      	add	r2, r5
24013bea:	60a3      	str	r3, [r4, #8]
24013bec:	6022      	str	r2, [r4, #0]
24013bee:	2b00      	cmp	r3, #0
24013bf0:	d1cf      	bne.n	24013b92 <__sfvwrite_r+0x1be>
24013bf2:	4621      	mov	r1, r4
24013bf4:	4630      	mov	r0, r6
24013bf6:	f7ff fd87 	bl	24013708 <_fflush_r>
24013bfa:	2800      	cmp	r0, #0
24013bfc:	d0c9      	beq.n	24013b92 <__sfvwrite_r+0x1be>
24013bfe:	e79c      	b.n	24013b3a <__sfvwrite_r+0x166>
24013c00:	f06f 4300 	mvn.w	r3, #2147483648	@ 0x80000000
24013c04:	4553      	cmp	r3, sl
24013c06:	bf28      	it	cs
24013c08:	4653      	movcs	r3, sl
24013c0a:	6aa5      	ldr	r5, [r4, #40]	@ 0x28
24013c0c:	fb93 f3f1 	sdiv	r3, r3, r1
24013c10:	463a      	mov	r2, r7
24013c12:	434b      	muls	r3, r1
24013c14:	4630      	mov	r0, r6
24013c16:	6a21      	ldr	r1, [r4, #32]
24013c18:	47a8      	blx	r5
24013c1a:	1e05      	subs	r5, r0, #0
24013c1c:	dcb9      	bgt.n	24013b92 <__sfvwrite_r+0x1be>
24013c1e:	e78c      	b.n	24013b3a <__sfvwrite_r+0x166>
24013c20:	e9d8 ab00 	ldrd	sl, fp, [r8]
24013c24:	2000      	movs	r0, #0
24013c26:	f108 0808 	add.w	r8, r8, #8
24013c2a:	e6f2      	b.n	24013a12 <__sfvwrite_r+0x3e>
24013c2c:	f10b 0701 	add.w	r7, fp, #1
24013c30:	e6ff      	b.n	24013a32 <__sfvwrite_r+0x5e>
24013c32:	4293      	cmp	r3, r2
24013c34:	dc08      	bgt.n	24013c48 <__sfvwrite_r+0x274>
24013c36:	6aa5      	ldr	r5, [r4, #40]	@ 0x28
24013c38:	6a21      	ldr	r1, [r4, #32]
24013c3a:	4652      	mov	r2, sl
24013c3c:	4630      	mov	r0, r6
24013c3e:	47a8      	blx	r5
24013c40:	1e05      	subs	r5, r0, #0
24013c42:	f73f af12 	bgt.w	24013a6a <__sfvwrite_r+0x96>
24013c46:	e778      	b.n	24013b3a <__sfvwrite_r+0x166>
24013c48:	4651      	mov	r1, sl
24013c4a:	9201      	str	r2, [sp, #4]
24013c4c:	f000 f8d3 	bl	24013df6 <memmove>
24013c50:	9a01      	ldr	r2, [sp, #4]
24013c52:	68a3      	ldr	r3, [r4, #8]
24013c54:	1a9b      	subs	r3, r3, r2
24013c56:	60a3      	str	r3, [r4, #8]
24013c58:	6823      	ldr	r3, [r4, #0]
24013c5a:	4413      	add	r3, r2
24013c5c:	6023      	str	r3, [r4, #0]
24013c5e:	4615      	mov	r5, r2
24013c60:	e703      	b.n	24013a6a <__sfvwrite_r+0x96>
24013c62:	2001      	movs	r0, #1
24013c64:	e70a      	b.n	24013a7c <__sfvwrite_r+0xa8>
24013c66:	bf00      	nop
24013c68:	7ffffc00 	.word	0x7ffffc00

24013c6c <_fwalk_sglue>:
24013c6c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
24013c70:	4607      	mov	r7, r0
24013c72:	4688      	mov	r8, r1
24013c74:	4614      	mov	r4, r2
24013c76:	2600      	movs	r6, #0
24013c78:	e9d4 9501 	ldrd	r9, r5, [r4, #4]
24013c7c:	f1b9 0901 	subs.w	r9, r9, #1
24013c80:	d505      	bpl.n	24013c8e <_fwalk_sglue+0x22>
24013c82:	6824      	ldr	r4, [r4, #0]
24013c84:	2c00      	cmp	r4, #0
24013c86:	d1f7      	bne.n	24013c78 <_fwalk_sglue+0xc>
24013c88:	4630      	mov	r0, r6
24013c8a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
24013c8e:	89ab      	ldrh	r3, [r5, #12]
24013c90:	2b01      	cmp	r3, #1
24013c92:	d907      	bls.n	24013ca4 <_fwalk_sglue+0x38>
24013c94:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
24013c98:	3301      	adds	r3, #1
24013c9a:	d003      	beq.n	24013ca4 <_fwalk_sglue+0x38>
24013c9c:	4629      	mov	r1, r5
24013c9e:	4638      	mov	r0, r7
24013ca0:	47c0      	blx	r8
24013ca2:	4306      	orrs	r6, r0
24013ca4:	3568      	adds	r5, #104	@ 0x68
24013ca6:	e7e9      	b.n	24013c7c <_fwalk_sglue+0x10>

24013ca8 <__swhatbuf_r>:
24013ca8:	b570      	push	{r4, r5, r6, lr}
24013caa:	460c      	mov	r4, r1
24013cac:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
24013cb0:	2900      	cmp	r1, #0
24013cb2:	b096      	sub	sp, #88	@ 0x58
24013cb4:	4615      	mov	r5, r2
24013cb6:	461e      	mov	r6, r3
24013cb8:	da0d      	bge.n	24013cd6 <__swhatbuf_r+0x2e>
24013cba:	89a3      	ldrh	r3, [r4, #12]
24013cbc:	f013 0f80 	tst.w	r3, #128	@ 0x80
24013cc0:	f04f 0100 	mov.w	r1, #0
24013cc4:	bf14      	ite	ne
24013cc6:	2340      	movne	r3, #64	@ 0x40
24013cc8:	f44f 6380 	moveq.w	r3, #1024	@ 0x400
24013ccc:	2000      	movs	r0, #0
24013cce:	6031      	str	r1, [r6, #0]
24013cd0:	602b      	str	r3, [r5, #0]
24013cd2:	b016      	add	sp, #88	@ 0x58
24013cd4:	bd70      	pop	{r4, r5, r6, pc}
24013cd6:	466a      	mov	r2, sp
24013cd8:	f000 f90e 	bl	24013ef8 <_fstat_r>
24013cdc:	2800      	cmp	r0, #0
24013cde:	dbec      	blt.n	24013cba <__swhatbuf_r+0x12>
24013ce0:	9901      	ldr	r1, [sp, #4]
24013ce2:	f401 4170 	and.w	r1, r1, #61440	@ 0xf000
24013ce6:	f5a1 5300 	sub.w	r3, r1, #8192	@ 0x2000
24013cea:	4259      	negs	r1, r3
24013cec:	4159      	adcs	r1, r3
24013cee:	f44f 6380 	mov.w	r3, #1024	@ 0x400
24013cf2:	e7eb      	b.n	24013ccc <__swhatbuf_r+0x24>

24013cf4 <__smakebuf_r>:
24013cf4:	898b      	ldrh	r3, [r1, #12]
24013cf6:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
24013cf8:	079d      	lsls	r5, r3, #30
24013cfa:	4606      	mov	r6, r0
24013cfc:	460c      	mov	r4, r1
24013cfe:	d507      	bpl.n	24013d10 <__smakebuf_r+0x1c>
24013d00:	f104 0347 	add.w	r3, r4, #71	@ 0x47
24013d04:	6023      	str	r3, [r4, #0]
24013d06:	6123      	str	r3, [r4, #16]
24013d08:	2301      	movs	r3, #1
24013d0a:	6163      	str	r3, [r4, #20]
24013d0c:	b003      	add	sp, #12
24013d0e:	bdf0      	pop	{r4, r5, r6, r7, pc}
24013d10:	ab01      	add	r3, sp, #4
24013d12:	466a      	mov	r2, sp
24013d14:	f7ff ffc8 	bl	24013ca8 <__swhatbuf_r>
24013d18:	9f00      	ldr	r7, [sp, #0]
24013d1a:	4605      	mov	r5, r0
24013d1c:	4639      	mov	r1, r7
24013d1e:	4630      	mov	r0, r6
24013d20:	f7ff f8fc 	bl	24012f1c <_malloc_r>
24013d24:	b948      	cbnz	r0, 24013d3a <__smakebuf_r+0x46>
24013d26:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
24013d2a:	059a      	lsls	r2, r3, #22
24013d2c:	d4ee      	bmi.n	24013d0c <__smakebuf_r+0x18>
24013d2e:	f023 0303 	bic.w	r3, r3, #3
24013d32:	f043 0302 	orr.w	r3, r3, #2
24013d36:	81a3      	strh	r3, [r4, #12]
24013d38:	e7e2      	b.n	24013d00 <__smakebuf_r+0xc>
24013d3a:	89a3      	ldrh	r3, [r4, #12]
24013d3c:	6020      	str	r0, [r4, #0]
24013d3e:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
24013d42:	81a3      	strh	r3, [r4, #12]
24013d44:	9b01      	ldr	r3, [sp, #4]
24013d46:	e9c4 0704 	strd	r0, r7, [r4, #16]
24013d4a:	b15b      	cbz	r3, 24013d64 <__smakebuf_r+0x70>
24013d4c:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
24013d50:	4630      	mov	r0, r6
24013d52:	f000 f8e3 	bl	24013f1c <_isatty_r>
24013d56:	b128      	cbz	r0, 24013d64 <__smakebuf_r+0x70>
24013d58:	89a3      	ldrh	r3, [r4, #12]
24013d5a:	f023 0303 	bic.w	r3, r3, #3
24013d5e:	f043 0301 	orr.w	r3, r3, #1
24013d62:	81a3      	strh	r3, [r4, #12]
24013d64:	89a3      	ldrh	r3, [r4, #12]
24013d66:	431d      	orrs	r5, r3
24013d68:	81a5      	strh	r5, [r4, #12]
24013d6a:	e7cf      	b.n	24013d0c <__smakebuf_r+0x18>

24013d6c <__sread>:
24013d6c:	b510      	push	{r4, lr}
24013d6e:	460c      	mov	r4, r1
24013d70:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
24013d74:	f000 f8f4 	bl	24013f60 <_read_r>
24013d78:	2800      	cmp	r0, #0
24013d7a:	bfab      	itete	ge
24013d7c:	6d63      	ldrge	r3, [r4, #84]	@ 0x54
24013d7e:	89a3      	ldrhlt	r3, [r4, #12]
24013d80:	181b      	addge	r3, r3, r0
24013d82:	f423 5380 	biclt.w	r3, r3, #4096	@ 0x1000
24013d86:	bfac      	ite	ge
24013d88:	6563      	strge	r3, [r4, #84]	@ 0x54
24013d8a:	81a3      	strhlt	r3, [r4, #12]
24013d8c:	bd10      	pop	{r4, pc}

24013d8e <__seofread>:
24013d8e:	2000      	movs	r0, #0
24013d90:	4770      	bx	lr

24013d92 <__swrite>:
24013d92:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
24013d96:	461f      	mov	r7, r3
24013d98:	898b      	ldrh	r3, [r1, #12]
24013d9a:	05db      	lsls	r3, r3, #23
24013d9c:	4605      	mov	r5, r0
24013d9e:	460c      	mov	r4, r1
24013da0:	4616      	mov	r6, r2
24013da2:	d505      	bpl.n	24013db0 <__swrite+0x1e>
24013da4:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
24013da8:	2302      	movs	r3, #2
24013daa:	2200      	movs	r2, #0
24013dac:	f000 f8c6 	bl	24013f3c <_lseek_r>
24013db0:	89a3      	ldrh	r3, [r4, #12]
24013db2:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
24013db6:	f423 5380 	bic.w	r3, r3, #4096	@ 0x1000
24013dba:	81a3      	strh	r3, [r4, #12]
24013dbc:	4632      	mov	r2, r6
24013dbe:	463b      	mov	r3, r7
24013dc0:	4628      	mov	r0, r5
24013dc2:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
24013dc6:	f000 b8ed 	b.w	24013fa4 <_write_r>

24013dca <__sseek>:
24013dca:	b510      	push	{r4, lr}
24013dcc:	460c      	mov	r4, r1
24013dce:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
24013dd2:	f000 f8b3 	bl	24013f3c <_lseek_r>
24013dd6:	1c43      	adds	r3, r0, #1
24013dd8:	89a3      	ldrh	r3, [r4, #12]
24013dda:	bf15      	itete	ne
24013ddc:	6560      	strne	r0, [r4, #84]	@ 0x54
24013dde:	f423 5380 	biceq.w	r3, r3, #4096	@ 0x1000
24013de2:	f443 5380 	orrne.w	r3, r3, #4096	@ 0x1000
24013de6:	81a3      	strheq	r3, [r4, #12]
24013de8:	bf18      	it	ne
24013dea:	81a3      	strhne	r3, [r4, #12]
24013dec:	bd10      	pop	{r4, pc}

24013dee <__sclose>:
24013dee:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
24013df2:	f000 b81b 	b.w	24013e2c <_close_r>

24013df6 <memmove>:
24013df6:	4288      	cmp	r0, r1
24013df8:	b510      	push	{r4, lr}
24013dfa:	eb01 0402 	add.w	r4, r1, r2
24013dfe:	d902      	bls.n	24013e06 <memmove+0x10>
24013e00:	4284      	cmp	r4, r0
24013e02:	4623      	mov	r3, r4
24013e04:	d807      	bhi.n	24013e16 <memmove+0x20>
24013e06:	1e43      	subs	r3, r0, #1
24013e08:	42a1      	cmp	r1, r4
24013e0a:	d008      	beq.n	24013e1e <memmove+0x28>
24013e0c:	f811 2b01 	ldrb.w	r2, [r1], #1
24013e10:	f803 2f01 	strb.w	r2, [r3, #1]!
24013e14:	e7f8      	b.n	24013e08 <memmove+0x12>
24013e16:	4402      	add	r2, r0
24013e18:	4601      	mov	r1, r0
24013e1a:	428a      	cmp	r2, r1
24013e1c:	d100      	bne.n	24013e20 <memmove+0x2a>
24013e1e:	bd10      	pop	{r4, pc}
24013e20:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
24013e24:	f802 4d01 	strb.w	r4, [r2, #-1]!
24013e28:	e7f7      	b.n	24013e1a <memmove+0x24>
	...

24013e2c <_close_r>:
24013e2c:	b538      	push	{r3, r4, r5, lr}
24013e2e:	4d06      	ldr	r5, [pc, #24]	@ (24013e48 <_close_r+0x1c>)
24013e30:	2300      	movs	r3, #0
24013e32:	4604      	mov	r4, r0
24013e34:	4608      	mov	r0, r1
24013e36:	602b      	str	r3, [r5, #0]
24013e38:	f7fe fc55 	bl	240126e6 <_close>
24013e3c:	1c43      	adds	r3, r0, #1
24013e3e:	d102      	bne.n	24013e46 <_close_r+0x1a>
24013e40:	682b      	ldr	r3, [r5, #0]
24013e42:	b103      	cbz	r3, 24013e46 <_close_r+0x1a>
24013e44:	6023      	str	r3, [r4, #0]
24013e46:	bd38      	pop	{r3, r4, r5, pc}
24013e48:	24000808 	.word	0x24000808

24013e4c <_reclaim_reent>:
24013e4c:	4b29      	ldr	r3, [pc, #164]	@ (24013ef4 <_reclaim_reent+0xa8>)
24013e4e:	681b      	ldr	r3, [r3, #0]
24013e50:	4283      	cmp	r3, r0
24013e52:	b570      	push	{r4, r5, r6, lr}
24013e54:	4604      	mov	r4, r0
24013e56:	d04b      	beq.n	24013ef0 <_reclaim_reent+0xa4>
24013e58:	69c3      	ldr	r3, [r0, #28]
24013e5a:	b1ab      	cbz	r3, 24013e88 <_reclaim_reent+0x3c>
24013e5c:	68db      	ldr	r3, [r3, #12]
24013e5e:	b16b      	cbz	r3, 24013e7c <_reclaim_reent+0x30>
24013e60:	2500      	movs	r5, #0
24013e62:	69e3      	ldr	r3, [r4, #28]
24013e64:	68db      	ldr	r3, [r3, #12]
24013e66:	5959      	ldr	r1, [r3, r5]
24013e68:	2900      	cmp	r1, #0
24013e6a:	d13b      	bne.n	24013ee4 <_reclaim_reent+0x98>
24013e6c:	3504      	adds	r5, #4
24013e6e:	2d80      	cmp	r5, #128	@ 0x80
24013e70:	d1f7      	bne.n	24013e62 <_reclaim_reent+0x16>
24013e72:	69e3      	ldr	r3, [r4, #28]
24013e74:	4620      	mov	r0, r4
24013e76:	68d9      	ldr	r1, [r3, #12]
24013e78:	f7fe ffe4 	bl	24012e44 <_free_r>
24013e7c:	69e3      	ldr	r3, [r4, #28]
24013e7e:	6819      	ldr	r1, [r3, #0]
24013e80:	b111      	cbz	r1, 24013e88 <_reclaim_reent+0x3c>
24013e82:	4620      	mov	r0, r4
24013e84:	f7fe ffde 	bl	24012e44 <_free_r>
24013e88:	6961      	ldr	r1, [r4, #20]
24013e8a:	b111      	cbz	r1, 24013e92 <_reclaim_reent+0x46>
24013e8c:	4620      	mov	r0, r4
24013e8e:	f7fe ffd9 	bl	24012e44 <_free_r>
24013e92:	69e1      	ldr	r1, [r4, #28]
24013e94:	b111      	cbz	r1, 24013e9c <_reclaim_reent+0x50>
24013e96:	4620      	mov	r0, r4
24013e98:	f7fe ffd4 	bl	24012e44 <_free_r>
24013e9c:	6b21      	ldr	r1, [r4, #48]	@ 0x30
24013e9e:	b111      	cbz	r1, 24013ea6 <_reclaim_reent+0x5a>
24013ea0:	4620      	mov	r0, r4
24013ea2:	f7fe ffcf 	bl	24012e44 <_free_r>
24013ea6:	6b61      	ldr	r1, [r4, #52]	@ 0x34
24013ea8:	b111      	cbz	r1, 24013eb0 <_reclaim_reent+0x64>
24013eaa:	4620      	mov	r0, r4
24013eac:	f7fe ffca 	bl	24012e44 <_free_r>
24013eb0:	6ba1      	ldr	r1, [r4, #56]	@ 0x38
24013eb2:	b111      	cbz	r1, 24013eba <_reclaim_reent+0x6e>
24013eb4:	4620      	mov	r0, r4
24013eb6:	f7fe ffc5 	bl	24012e44 <_free_r>
24013eba:	6ca1      	ldr	r1, [r4, #72]	@ 0x48
24013ebc:	b111      	cbz	r1, 24013ec4 <_reclaim_reent+0x78>
24013ebe:	4620      	mov	r0, r4
24013ec0:	f7fe ffc0 	bl	24012e44 <_free_r>
24013ec4:	6c61      	ldr	r1, [r4, #68]	@ 0x44
24013ec6:	b111      	cbz	r1, 24013ece <_reclaim_reent+0x82>
24013ec8:	4620      	mov	r0, r4
24013eca:	f7fe ffbb 	bl	24012e44 <_free_r>
24013ece:	6ae1      	ldr	r1, [r4, #44]	@ 0x2c
24013ed0:	b111      	cbz	r1, 24013ed8 <_reclaim_reent+0x8c>
24013ed2:	4620      	mov	r0, r4
24013ed4:	f7fe ffb6 	bl	24012e44 <_free_r>
24013ed8:	6a23      	ldr	r3, [r4, #32]
24013eda:	b14b      	cbz	r3, 24013ef0 <_reclaim_reent+0xa4>
24013edc:	4620      	mov	r0, r4
24013ede:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
24013ee2:	4718      	bx	r3
24013ee4:	680e      	ldr	r6, [r1, #0]
24013ee6:	4620      	mov	r0, r4
24013ee8:	f7fe ffac 	bl	24012e44 <_free_r>
24013eec:	4631      	mov	r1, r6
24013eee:	e7bb      	b.n	24013e68 <_reclaim_reent+0x1c>
24013ef0:	bd70      	pop	{r4, r5, r6, pc}
24013ef2:	bf00      	nop
24013ef4:	2400051c 	.word	0x2400051c

24013ef8 <_fstat_r>:
24013ef8:	b538      	push	{r3, r4, r5, lr}
24013efa:	4d07      	ldr	r5, [pc, #28]	@ (24013f18 <_fstat_r+0x20>)
24013efc:	2300      	movs	r3, #0
24013efe:	4604      	mov	r4, r0
24013f00:	4608      	mov	r0, r1
24013f02:	4611      	mov	r1, r2
24013f04:	602b      	str	r3, [r5, #0]
24013f06:	f7fe fbf1 	bl	240126ec <_fstat>
24013f0a:	1c43      	adds	r3, r0, #1
24013f0c:	d102      	bne.n	24013f14 <_fstat_r+0x1c>
24013f0e:	682b      	ldr	r3, [r5, #0]
24013f10:	b103      	cbz	r3, 24013f14 <_fstat_r+0x1c>
24013f12:	6023      	str	r3, [r4, #0]
24013f14:	bd38      	pop	{r3, r4, r5, pc}
24013f16:	bf00      	nop
24013f18:	24000808 	.word	0x24000808

24013f1c <_isatty_r>:
24013f1c:	b538      	push	{r3, r4, r5, lr}
24013f1e:	4d06      	ldr	r5, [pc, #24]	@ (24013f38 <_isatty_r+0x1c>)
24013f20:	2300      	movs	r3, #0
24013f22:	4604      	mov	r4, r0
24013f24:	4608      	mov	r0, r1
24013f26:	602b      	str	r3, [r5, #0]
24013f28:	f7fe fbe5 	bl	240126f6 <_isatty>
24013f2c:	1c43      	adds	r3, r0, #1
24013f2e:	d102      	bne.n	24013f36 <_isatty_r+0x1a>
24013f30:	682b      	ldr	r3, [r5, #0]
24013f32:	b103      	cbz	r3, 24013f36 <_isatty_r+0x1a>
24013f34:	6023      	str	r3, [r4, #0]
24013f36:	bd38      	pop	{r3, r4, r5, pc}
24013f38:	24000808 	.word	0x24000808

24013f3c <_lseek_r>:
24013f3c:	b538      	push	{r3, r4, r5, lr}
24013f3e:	4d07      	ldr	r5, [pc, #28]	@ (24013f5c <_lseek_r+0x20>)
24013f40:	4604      	mov	r4, r0
24013f42:	4608      	mov	r0, r1
24013f44:	4611      	mov	r1, r2
24013f46:	2200      	movs	r2, #0
24013f48:	602a      	str	r2, [r5, #0]
24013f4a:	461a      	mov	r2, r3
24013f4c:	f7fe fbd5 	bl	240126fa <_lseek>
24013f50:	1c43      	adds	r3, r0, #1
24013f52:	d102      	bne.n	24013f5a <_lseek_r+0x1e>
24013f54:	682b      	ldr	r3, [r5, #0]
24013f56:	b103      	cbz	r3, 24013f5a <_lseek_r+0x1e>
24013f58:	6023      	str	r3, [r4, #0]
24013f5a:	bd38      	pop	{r3, r4, r5, pc}
24013f5c:	24000808 	.word	0x24000808

24013f60 <_read_r>:
24013f60:	b538      	push	{r3, r4, r5, lr}
24013f62:	4d07      	ldr	r5, [pc, #28]	@ (24013f80 <_read_r+0x20>)
24013f64:	4604      	mov	r4, r0
24013f66:	4608      	mov	r0, r1
24013f68:	4611      	mov	r1, r2
24013f6a:	2200      	movs	r2, #0
24013f6c:	602a      	str	r2, [r5, #0]
24013f6e:	461a      	mov	r2, r3
24013f70:	f7fe fb9d 	bl	240126ae <_read>
24013f74:	1c43      	adds	r3, r0, #1
24013f76:	d102      	bne.n	24013f7e <_read_r+0x1e>
24013f78:	682b      	ldr	r3, [r5, #0]
24013f7a:	b103      	cbz	r3, 24013f7e <_read_r+0x1e>
24013f7c:	6023      	str	r3, [r4, #0]
24013f7e:	bd38      	pop	{r3, r4, r5, pc}
24013f80:	24000808 	.word	0x24000808

24013f84 <_sbrk_r>:
24013f84:	b538      	push	{r3, r4, r5, lr}
24013f86:	4d06      	ldr	r5, [pc, #24]	@ (24013fa0 <_sbrk_r+0x1c>)
24013f88:	2300      	movs	r3, #0
24013f8a:	4604      	mov	r4, r0
24013f8c:	4608      	mov	r0, r1
24013f8e:	602b      	str	r3, [r5, #0]
24013f90:	f7fe fbea 	bl	24012768 <_sbrk>
24013f94:	1c43      	adds	r3, r0, #1
24013f96:	d102      	bne.n	24013f9e <_sbrk_r+0x1a>
24013f98:	682b      	ldr	r3, [r5, #0]
24013f9a:	b103      	cbz	r3, 24013f9e <_sbrk_r+0x1a>
24013f9c:	6023      	str	r3, [r4, #0]
24013f9e:	bd38      	pop	{r3, r4, r5, pc}
24013fa0:	24000808 	.word	0x24000808

24013fa4 <_write_r>:
24013fa4:	b538      	push	{r3, r4, r5, lr}
24013fa6:	4d07      	ldr	r5, [pc, #28]	@ (24013fc4 <_write_r+0x20>)
24013fa8:	4604      	mov	r4, r0
24013faa:	4608      	mov	r0, r1
24013fac:	4611      	mov	r1, r2
24013fae:	2200      	movs	r2, #0
24013fb0:	602a      	str	r2, [r5, #0]
24013fb2:	461a      	mov	r2, r3
24013fb4:	f7fe fd28 	bl	24012a08 <_write>
24013fb8:	1c43      	adds	r3, r0, #1
24013fba:	d102      	bne.n	24013fc2 <_write_r+0x1e>
24013fbc:	682b      	ldr	r3, [r5, #0]
24013fbe:	b103      	cbz	r3, 24013fc2 <_write_r+0x1e>
24013fc0:	6023      	str	r3, [r4, #0]
24013fc2:	bd38      	pop	{r3, r4, r5, pc}
24013fc4:	24000808 	.word	0x24000808

24013fc8 <memcpy>:
24013fc8:	440a      	add	r2, r1
24013fca:	4291      	cmp	r1, r2
24013fcc:	f100 33ff 	add.w	r3, r0, #4294967295
24013fd0:	d100      	bne.n	24013fd4 <memcpy+0xc>
24013fd2:	4770      	bx	lr
24013fd4:	b510      	push	{r4, lr}
24013fd6:	f811 4b01 	ldrb.w	r4, [r1], #1
24013fda:	f803 4f01 	strb.w	r4, [r3, #1]!
24013fde:	4291      	cmp	r1, r2
24013fe0:	d1f9      	bne.n	24013fd6 <memcpy+0xe>
24013fe2:	bd10      	pop	{r4, pc}

24013fe4 <_realloc_r>:
24013fe4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
24013fe8:	4680      	mov	r8, r0
24013fea:	4615      	mov	r5, r2
24013fec:	460c      	mov	r4, r1
24013fee:	b921      	cbnz	r1, 24013ffa <_realloc_r+0x16>
24013ff0:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
24013ff4:	4611      	mov	r1, r2
24013ff6:	f7fe bf91 	b.w	24012f1c <_malloc_r>
24013ffa:	b92a      	cbnz	r2, 24014008 <_realloc_r+0x24>
24013ffc:	f7fe ff22 	bl	24012e44 <_free_r>
24014000:	2400      	movs	r4, #0
24014002:	4620      	mov	r0, r4
24014004:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
24014008:	f000 f81a 	bl	24014040 <_malloc_usable_size_r>
2401400c:	4285      	cmp	r5, r0
2401400e:	4606      	mov	r6, r0
24014010:	d802      	bhi.n	24014018 <_realloc_r+0x34>
24014012:	ebb5 0f50 	cmp.w	r5, r0, lsr #1
24014016:	d8f4      	bhi.n	24014002 <_realloc_r+0x1e>
24014018:	4629      	mov	r1, r5
2401401a:	4640      	mov	r0, r8
2401401c:	f7fe ff7e 	bl	24012f1c <_malloc_r>
24014020:	4607      	mov	r7, r0
24014022:	2800      	cmp	r0, #0
24014024:	d0ec      	beq.n	24014000 <_realloc_r+0x1c>
24014026:	42b5      	cmp	r5, r6
24014028:	462a      	mov	r2, r5
2401402a:	4621      	mov	r1, r4
2401402c:	bf28      	it	cs
2401402e:	4632      	movcs	r2, r6
24014030:	f7ff ffca 	bl	24013fc8 <memcpy>
24014034:	4621      	mov	r1, r4
24014036:	4640      	mov	r0, r8
24014038:	f7fe ff04 	bl	24012e44 <_free_r>
2401403c:	463c      	mov	r4, r7
2401403e:	e7e0      	b.n	24014002 <_realloc_r+0x1e>

24014040 <_malloc_usable_size_r>:
24014040:	f851 3c04 	ldr.w	r3, [r1, #-4]
24014044:	1f18      	subs	r0, r3, #4
24014046:	2b00      	cmp	r3, #0
24014048:	bfbc      	itt	lt
2401404a:	580b      	ldrlt	r3, [r1, r0]
2401404c:	18c0      	addlt	r0, r0, r3
2401404e:	4770      	bx	lr

24014050 <___init_veneer>:
24014050:	f85f f000 	ldr.w	pc, [pc]	@ 24014054 <___init_veneer+0x4>
24014054:	00000001 	.word	0x00000001
24014058:	00000010 	.word	0x00000010
2401405c:	00000000 	.word	0x00000000
24014060:	00527a01 	.word	0x00527a01
24014064:	010e7c02 	.word	0x010e7c02
24014068:	000d0c1b 	.word	0x000d0c1b
2401406c:	00000038 	.word	0x00000038
24014070:	00000018 	.word	0x00000018
24014074:	ffffea2c 	.word	0xffffea2c
24014078:	0000009e 	.word	0x0000009e
2401407c:	100e5100 	.word	0x100e5100
24014080:	03850484 	.word	0x03850484
24014084:	01870286 	.word	0x01870286
24014088:	c5c6c75b 	.word	0xc5c6c75b
2401408c:	4c000ec4 	.word	0x4c000ec4
24014090:	0a0b420a 	.word	0x0a0b420a
24014094:	100e0b42 	.word	0x100e0b42
24014098:	03850484 	.word	0x03850484
2401409c:	01870286 	.word	0x01870286
240140a0:	c5c6c751 	.word	0xc5c6c751
240140a4:	00000ec4 	.word	0x00000ec4
